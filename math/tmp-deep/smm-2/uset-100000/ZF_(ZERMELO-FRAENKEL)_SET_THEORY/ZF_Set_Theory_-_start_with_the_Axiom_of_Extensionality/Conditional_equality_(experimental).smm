$[ uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/The_universal_class.smm $]
$( =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                    Conditional equality (experimental)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  This is a very useless definition, which "abbreviates" ` ( x = y -> ph ) ` as
  ` CondEq ( x = y -> ph ) ` . What this display hides, though, is that the
  first expression, even though it has a shorter constant string, is actually
  much more complicated in its parse tree: it is parsed as
  (wi (wceq (cv vx) (cv vy)) wph), while the ` CondEq ` version is parsed as
  (wcdeq vx vy wph).  It also allows us to give a name to the specific 3-ary
  operation ` ( x = y -> ph ) ` .

  This is all used as part of a metatheorem: we want to say that
  ` |- ( x = y -> ( ph ( x ) <-> ph ( y ) ) ) ` and
  ` |- ( x = y -> A ( x ) = A ( y ) ) ` are provable, for any expressions
  ` ph ( x ) ` or ` A ( x ) ` in the language.  The proof is by induction, so
  the base case is each of the primitives, which is why you will see a theorem
  for each of the set.mm primitive operations.

  The metatheorem comes with a disjoint variables assumption: every variable in
  ` ph ( x ) ` is assumed disjoint from ` x ` except ` x ` itself.  For such a
  proof by induction, we must consider each of the possible forms of
  ` ph ( x ) ` .  If it is a variable other than ` x ` , then we have
  ` CondEq ( x = y -> A = A ) ` or ` CondEq ( x = y -> ( ph <-> ph ) ) ` ,
  which is provable by ~ cdeqth and reflexivity.  Since we are only working
  with class and wff expressions, it can't be ` x ` itself in set.mm, but if it
  was we'd have to also prove ` CondEq ( x = y -> x = y ) ` (where _set_
  equality is being used on the right).

  Otherwise, it is a primitive operation applied to smaller expressions.  In
  these cases, for each set variable parameter to the operation, we must
  consider if it is equal to ` x ` or not, which yields 2^n proof obligations.
  Luckily, all primitive operations in set.mm have either zero or one set
  variable, so we only need to prove one statement for the non-set constructors
  (like implication) and two for the constructors taking a set (the forall and
  the class builder).

  In each of the primitive proofs, we are allowed to assume that ` y ` is
  disjoint from ` ph ( x ) ` and vice versa, because this is maintained through
  the induction.  This is how we satisfy the DV assumptions of ~ cdeqab1 and
  ~ cdeqab .

$)
$c CondEq $.
$( conditional equality $)
$( Extend wff notation to include conditional equality.  This is a technical
     device used in the proof that ` F/ ` is the not-free predicate, and that
     definitions are conservative as a result. $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	awcdeq $a wff CondEq ( x = y -> ph ) $.
$}
$( Define conditional equality.  All the notation to the left of the ` <-> `
     is fake; the parentheses and arrows are all part of the notation, which
     could equally well be written ` CondEq x y ph ` .  On the right side is
     the actual implication arrow.  The reason for this definition is to
     "flatten" the structure on the right side (whose tree structure is
     something like (wi (wceq (cv vx) (cv vy)) wph) ) into just (wcdeq vx vy
     wph).  (Contributed by Mario Carneiro, 11-Aug-2016.) $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	adf-cdeq $a |- ( CondEq ( x = y -> ph ) <-> ( x = y -> ph ) ) $.
$}
$( Deduce conditional equality.  (Contributed by Mario Carneiro,
       11-Aug-2016.) $)
${
	$v ph x y $.
	e0 $e |- ( x = y -> ph ) $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	pcdeqi $p |- CondEq ( x = y -> ph ) $=
	e0 f0 f1 f2 adf-cdeq f0 f1 f2 awcdeq f1 asup_set_class f2 asup_set_class awceq f0 awi pmpbir $.
$}
$( Property of conditional equality.  (Contributed by Mario Carneiro,
       11-Aug-2016.) $)
${
	$v ph x y $.
	e0 $e |- CondEq ( x = y -> ph ) $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	pcdeqri $p |- ( x = y -> ph ) $=
	e0 f0 f1 f2 adf-cdeq f0 f1 f2 awcdeq f1 asup_set_class f2 asup_set_class awceq f0 awi pmpbi $.
$}
$( Deduce conditional equality from a theorem.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) $)
${
	$v ph x y $.
	e0 $e |- ph $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	pcdeqth $p |- CondEq ( x = y -> ph ) $=
	e0 f0 f1 asup_set_class f2 asup_set_class awceq pa1i f0 f1 f2 pcdeqi $.
$}
$( Distribute conditional equality over negation.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) $)
${
	$v ph ps x y $.
	e0 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pcdeqnot $p |- CondEq ( x = y -> ( -. ph <-> -. ps ) ) $=
	e0 f0 f1 awb f2 f3 pcdeqri f2 asup_set_class f3 asup_set_class awceq f0 f1 pnotbid f0 awn f1 awn awb f2 f3 pcdeqi $.
$}
$( Distribute conditional equality over quantification.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) $)
${
	$v ph ps x y z $.
	$d x z $.
	$d y z $.
	e0 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	f4 $f set z $.
	pcdeqal $p |- CondEq ( x = y -> ( A. z ph <-> A. z ps ) ) $=
	e0 f0 f1 awb f2 f3 pcdeqri f2 asup_set_class f3 asup_set_class awceq f0 f1 f4 palbidv f0 f4 awal f1 f4 awal awb f2 f3 pcdeqi $.
$}
$( Distribute conditional equality over abstraction.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) $)
${
	$v ph ps x y z $.
	$d x z $.
	$d y z $.
	e0 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	f4 $f set z $.
	pcdeqab $p |- CondEq ( x = y -> { z | ph } = { z | ps } ) $=
	e0 f0 f1 awb f2 f3 pcdeqri f2 asup_set_class f3 asup_set_class awceq f0 f1 f4 pabbidv f0 f4 acab f1 f4 acab awceq f2 f3 pcdeqi $.
$}
$( Distribute conditional equality over quantification.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) $)
${
	$v ph ps x y $.
	$d x ps $.
	$d y ph $.
	e0 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pcdeqal1 $p |- CondEq ( x = y -> ( A. x ph <-> A. y ps ) ) $=
	e0 f0 f1 awb f2 f3 pcdeqri f0 f1 f2 f3 pcbvalv f0 f2 awal f1 f3 awal awb f2 asup_set_class f3 asup_set_class awceq pa1i f0 f2 awal f1 f3 awal awb f2 f3 pcdeqi $.
$}
$( Distribute conditional equality over abstraction.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) $)
${
	$v ph ps x y $.
	$d x ps $.
	$d y ph $.
	e0 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pcdeqab1 $p |- CondEq ( x = y -> { x | ph } = { y | ps } ) $=
	e0 f0 f1 awb f2 f3 pcdeqri f0 f1 f2 f3 pcbvabv f0 f2 acab f1 f3 acab awceq f2 asup_set_class f3 asup_set_class awceq pa1i f0 f2 acab f1 f3 acab awceq f2 f3 pcdeqi $.
$}
$( Distribute conditional equality over implication.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) $)
${
	$v ph ps ch th x y $.
	e0 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	e1 $e |- CondEq ( x = y -> ( ch <-> th ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f wff ch $.
	f3 $f wff th $.
	f4 $f set x $.
	f5 $f set y $.
	pcdeqim $p |- CondEq ( x = y -> ( ( ph -> ch ) <-> ( ps -> th ) ) ) $=
	e0 f0 f1 awb f4 f5 pcdeqri e1 f2 f3 awb f4 f5 pcdeqri f4 asup_set_class f5 asup_set_class awceq f0 f1 f2 f3 pimbi12d f0 f2 awi f1 f3 awi awb f4 f5 pcdeqi $.
$}
$( Conditional equality for set-to-class promotion.  (Contributed by Mario
     Carneiro, 11-Aug-2016.) $)
${
	$v x y $.
	f0 $f set x $.
	f1 $f set y $.
	pcdeqcv $p |- CondEq ( x = y -> x = y ) $=
	f0 asup_set_class f1 asup_set_class awceq pid f0 asup_set_class f1 asup_set_class awceq f0 f1 pcdeqi $.
$}
$( Distribute conditional equality over equality.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) $)
${
	$v x y A B C D $.
	e0 $e |- CondEq ( x = y -> A = B ) $.
	e1 $e |- CondEq ( x = y -> C = D ) $.
	f0 $f set x $.
	f1 $f set y $.
	f2 $f class A $.
	f3 $f class B $.
	f4 $f class C $.
	f5 $f class D $.
	pcdeqeq $p |- CondEq ( x = y -> ( A = C <-> B = D ) ) $=
	e0 f2 f3 awceq f0 f1 pcdeqri e1 f4 f5 awceq f0 f1 pcdeqri f0 asup_set_class f1 asup_set_class awceq f2 f3 f4 f5 peqeq12d f2 f4 awceq f3 f5 awceq awb f0 f1 pcdeqi $.
$}
$( Distribute conditional equality over elementhood.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) $)
${
	$v x y A B C D $.
	e0 $e |- CondEq ( x = y -> A = B ) $.
	e1 $e |- CondEq ( x = y -> C = D ) $.
	f0 $f set x $.
	f1 $f set y $.
	f2 $f class A $.
	f3 $f class B $.
	f4 $f class C $.
	f5 $f class D $.
	pcdeqel $p |- CondEq ( x = y -> ( A e. C <-> B e. D ) ) $=
	e0 f2 f3 awceq f0 f1 pcdeqri e1 f4 f5 awceq f0 f1 pcdeqri f0 asup_set_class f1 asup_set_class awceq f2 f3 f4 f5 peleq12d f2 f4 awcel f3 f5 awcel awb f0 f1 pcdeqi $.
$}
$( If we have a conditional equality proof, where ` ph ` is ` ph ( x ) `
       and ` ps ` is ` ph ( y ) ` , and ` ph ( x ) ` in fact does not have
       ` x ` free in it according to ` F/ ` , then ` ph ( x ) <-> ph ( y ) `
       unconditionally.  This proves that ` F/ x ph ` is actually a not-free
       predicate.  (Contributed by Mario Carneiro, 11-Aug-2016.) $)
${
	$v ph ps x y $.
	$d x ps $.
	$d y ph $.
	e0 $e |- F/ x ph $.
	e1 $e |- CondEq ( x = y -> ( ph <-> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pnfcdeq $p |- ( ph <-> ps ) $=
	e0 f0 f2 f3 psbf f1 f2 pnfv e1 f0 f1 awb f2 f3 pcdeqri f0 f1 f2 f3 psbie f0 f0 f2 f3 awsb f1 pbitr3i $.
$}
$( Variation of ~ nfcdeq for classes.  (Contributed by Mario Carneiro,
       11-Aug-2016.) $)
${
	$v x y z A B $.
	$d x z B $.
	$d y z A $.
	e0 $e |- F/_ x A $.
	e1 $e |- CondEq ( x = y -> A = B ) $.
	f0 $f set x $.
	f1 $f set y $.
	f2 $f class A $.
	f3 $f class B $.
	i0 $f set z $.
	pnfccdeq $p |- A = B $=
	e0 f0 i0 f2 pnfcri i0 pequid i0 asup_set_class i0 asup_set_class awceq f0 f1 pcdeqth e1 f0 f1 i0 asup_set_class i0 asup_set_class f2 f3 pcdeqel i0 asup_set_class f2 awcel i0 asup_set_class f3 awcel f0 f1 pnfcdeq i0 f2 f3 peqriv $.
$}
$( Let the computer know the theorems to look for to prove the metatheorem $)
$( $j
    condequality 'wcdeq' from 'cdeqth';
    condcongruence 'cdeqnot' 'cdeqim' 'cdeqal1' 'cdeqal' 'cdeqcv' 'cdeqeq'
      'cdeqel' 'cdeqab1' 'cdeqab';
    notfree 'wnf' from 'nfcdeq';
    notfree 'wnfc' from 'nfccdeq';
  $)

