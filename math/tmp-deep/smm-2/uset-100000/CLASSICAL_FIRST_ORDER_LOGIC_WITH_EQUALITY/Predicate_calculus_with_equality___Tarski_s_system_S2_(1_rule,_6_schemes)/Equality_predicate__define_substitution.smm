$[ turnstile_special_source.smm $]
$[ uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Predicate_calculus_with_equality___Tarski_s_system_S2_(1_rule,_6_schemes)/Axiom_scheme_ax-17_(Distinctness)_-_first_use_of__d.smm $]
$( =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Equality predicate; define substitution

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)
$( --- Start of patch to prevent connective overloading $)
$( Add 'class' as a typecode. $)
$( $j syntax 'class'; $)
$( This syntax construction states that a variable ` x ` , which has been
     declared to be a set variable by $f statement vx, is also a class
     expression.  This can be justified informally as follows.  We know that
     the class builder ` { y | y e. x } ` is a class by ~ cab .  Since (when
     ` y ` is distinct from ` x ` ) we have ` x = { y | y e. x } ` by
     ~ cvjust , we can argue that the syntax " ` class x ` " can be viewed as
     an abbreviation for " ` class { y | y e. x } ` ".  See the discussion
     under the definition of class in [Jech] p. 4 showing that "Every set can
     be considered to be a class."

     While it is tempting and perhaps occasionally useful to view ~ cv as a
     "type conversion" from a set variable to a class variable, keep in mind
     that ~ cv is intrinsically no different from any other class-building
     syntax such as ~ cab , ~ cun , or ~ c0 .

     For a general discussion of the theory of classes and the role of ~ cv ,
     see ~ http://us.metamath.org/mpeuni/mmset.html#class .

     (The description above applies to set theory, not predicate calculus.  The
     purpose of introducing ` class x ` here, and not in set theory where it
     belongs, is to allow us to express i.e.  "prove" the ~ weq of predicate
     calculus from the ~ wceq of set theory, so that we don't "overload" the
     ` = ` connective with two syntax definitions.  This is done to prevent
     ambiguity that would complicate some Metamath parsers.) $)
$( --- End of patch to prevent connective overloading $)
$( --- Start of old code before overloading prevention patch. $)
$( (None - the above patch had no old code.) $)
$( --- End of old code before overloading prevention patch. $)
$( Declare the equality predicate symbol. $)
$c = $.
$( Equal sign (read:  'is equal to') $)
$( --- Start of patch to prevent connective overloading $)
$( Extend wff definition to include class equality.

       For a general discussion of the theory of classes, see
       ~ http://us.metamath.org/mpeuni/mmset.html#class .

       (The purpose of introducing ` wff A = B ` here, and not in set theory
       where it belongs, is to allow us to express i.e.  "prove" the ~ weq of
       predicate calculus in terms of the ~ wceq of set theory, so that we
       don't "overload" the ` = ` connective with two syntax definitions.  This
       is done to prevent ambiguity that would complicate some Metamath
       parsers.  For example, some parsers - although not the Metamath program
       - stumble on the fact that the ` = ` in ` x = y ` could be the ` = ` of
       either ~ weq or ~ wceq , although mathematically it makes no
       difference.  The class variables ` A ` and ` B ` are introduced
       temporarily for the purpose of this definition but otherwise not used in
       predicate calculus.  See ~ df-cleq for more information on the set
       theory usage of ~ wceq .) $)
${
	$v A B $.
	f0 $f class A $.
	f1 $f class B $.
	awceq $a wff A = B $.
$}
$( Extend wff definition to include atomic formulas using the equality
     predicate.

     (Instead of introducing ~ weq as an axiomatic statement, as was done in an
     older version of this database, we introduce it by "proving" a special
     case of set theory's more general ~ wceq .  This lets us avoid overloading
     the ` = ` connective, thus preventing ambiguity that would complicate
     certain Metamath parsers.  However, logically ~ weq is considered to be a
     primitive syntax, even though here it is artificially "derived" from
     ~ wceq .  Note:  To see the proof steps of this syntax proof, type "show
     proof weq /all" in the Metamath program.)  (Contributed by NM,
     24-Jan-2006.) $)
$( --- End of patch to prevent connective overloading $)
$( --- Start of old code before overloading prevention patch. $)
$( @( Extend wff definition to include atomic formulas using the equality
     predicate.

     After we introduce ~ cv and ~ wceq in set theory, this syntax construction
     becomes redundant, since it can be derived with the proof
     "vx cv vy cv wceq". @)
  weq @a wff x = y @.
  $)
$( --- End of old code before overloading prevention patch. $)
$( Lemma used in proofs of substitution properties.  (Contributed by NM,
     5-Aug-1993.) $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	pequs3 $p |- ( E. x ( x = y /\ ph ) <-> -. A. x ( x = y -> -. ph ) ) $=
	f1 asup_set_class f2 asup_set_class awceq f0 f1 palinexa f1 asup_set_class f2 asup_set_class awceq f0 awn awi f1 awal f1 asup_set_class f2 asup_set_class awceq f0 awa f1 awex pcon2bii $.
$}
$( Specialization, with additional weakening to allow bundling of ` x ` and
       ` y ` .  Uses only Tarski's FOL axiom schemes.  (Contributed by NM,
       23-Apr-2017.)  (Proof shortened by Wolf Lammen, 5-Aug-2017.) $)
${
	$v ph ps x y $.
	e0 $e |- ( x = y -> ( ph -> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pspeimfw $p |- ( -. A. x -. x = y -> ( A. x ph -> E. x ps ) ) $=
	e0 f2 asup_set_class f3 asup_set_class awceq f0 f1 awi f2 peximi f2 asup_set_class f3 asup_set_class awceq f2 adf-ex f0 f1 f2 p19.35 f2 asup_set_class f3 asup_set_class awceq f2 awex f0 f1 awi f2 awex f2 asup_set_class f3 asup_set_class awceq awn f2 awal awn f0 f2 awal f1 f2 awex awi p3imtr3i $.
$}
$( Specialization, with additional weakening to allow bundling of ` x ` and
       ` y ` .  Uses only Tarski's FOL axiom schemes.  (Contributed by NM,
       23-Apr-1017.)  (Proof shortened by Wolf Lammen, 7-Aug-2017.) $)
${
	$v ph ps x y $.
	e0 $e |- ( -. ps -> A. x -. ps ) $.
	e1 $e |- ( x = y -> ( ph -> ps ) ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pspimfw $p |- ( -. A. x -. x = y -> ( A. x ph -> ps ) ) $=
	e1 f0 f1 f2 f3 pspeimfw f1 f2 adf-ex e0 f1 f1 awn f2 awal pcon1i f1 f2 awex f1 awn f2 awal awn f1 psylbi f2 asup_set_class f3 asup_set_class awceq awn f2 awal awn f0 f2 awal f1 f2 awex f1 psyl6 $.
$}
$( Inference that has ~ ax-11 (without ` A. y ` ) as its conclusion.  Uses
       only Tarski's FOL axiom schemes.  The hypotheses may be eliminable
       without one or more of these axioms in special cases.  Proof similar to
       Lemma 16 of [Tarski] p. 70.  (Contributed by NM, 20-May-2008.) $)
${
	$v ph ps x y $.
	e0 $e |- ( x = y -> ( ph <-> ps ) ) $.
	e1 $e |- ( ps -> A. x ps ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	pax11i $p |- ( x = y -> ( ph -> A. x ( x = y -> ph ) ) ) $=
	e0 e1 e0 f2 asup_set_class f3 asup_set_class awceq f0 f1 pbiimprcd f1 f2 asup_set_class f3 asup_set_class awceq f0 awi f2 palrimih f2 asup_set_class f3 asup_set_class awceq f0 f1 f2 asup_set_class f3 asup_set_class awceq f0 awi f2 awal psyl6bi $.
$}
$c [ $.
$( Left bracket $)
$c / $.
$( Slash. $)
$c ] $.
$( Right bracket $)
$( Extend wff definition to include proper substitution (read "the wff that
     results when ` y ` is properly substituted for ` x ` in wff ` ph ` ").
     (Contributed by NM, 24-Jan-2006.) $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	awsb $a wff [ y / x ] ph $.
$}
$( Define proper substitution.  Remark 9.1 in [Megill] p. 447 (p. 15 of the
     preprint).  For our notation, we use ` [ y / x ] ph ` to mean "the wff
     that results from the proper substitution of ` y ` for ` x ` in the wff
     ` ph ` ."  We can also use ` [ y / x ] ph ` in place of the "free for"
     side condition used in traditional predicate calculus; see, for example,
     ~ stdpc4 .

     Our notation was introduced in Haskell B. Curry's _Foundations of
     Mathematical Logic_ (1977), p. 316 and is frequently used in textbooks of
     lambda calculus and combinatory logic.  This notation improves the common
     but ambiguous notation, " ` ph ( y ) ` is the wff that results when ` y `
     is properly substituted for ` x ` in ` ph ( x ) ` ."  For example, if the
     original ` ph ( x ) ` is ` x = y ` , then ` ph ( y ) ` is ` y = y ` , from
     which we obtain that ` ph ( x ) ` is ` x = x ` .  So what exactly does
     ` ph ( x ) ` mean?  Curry's notation solves this problem.

     In most books, proper substitution has a somewhat complicated recursive
     definition with multiple cases based on the occurrences of free and bound
     variables in the wff.  Instead, we use a single formula that is exactly
     equivalent and gives us a direct definition.  We later prove that our
     definition has the properties we expect of proper substitution (see
     theorems ~ sbequ , ~ sbcom2 and ~ sbid2v ).

     Note that our definition is valid even when ` x ` and ` y ` are replaced
     with the same variable, as ~ sbid shows.  We achieve this by having ` x `
     free in the first conjunct and bound in the second.  We can also achieve
     this by using a dummy variable, as the alternate definition ~ dfsb7 shows
     (which some logicians may prefer because it doesn't mix free and bound
     variables).  Another version that mixes free and bound variables is
     ~ dfsb3 .  When ` x ` and ` y ` are distinct, we can express proper
     substitution with the simpler expressions of ~ sb5 and ~ sb6 .

     There are no restrictions on any of the variables, including what
     variables may occur in wff ` ph ` .  (Contributed by NM, 5-Aug-1993.) $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	adf-sb $a |- ( [ y / x ] ph <-> ( ( x = y -> ph ) /\ E. x ( x = y /\ ph ) ) ) $.
$}
$( An equality theorem for substitution.  (Contributed by NM, 5-Aug-1993.) $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	psbequ2 $p |- ( x = y -> ( [ y / x ] ph -> ph ) ) $=
	f0 f1 f2 adf-sb f1 asup_set_class f2 asup_set_class awceq f0 awi f1 asup_set_class f2 asup_set_class awceq f0 awa f1 awex psimpl f1 asup_set_class f2 asup_set_class awceq f0 awi f1 asup_set_class f2 asup_set_class awceq f0 awa f1 awex awa f1 asup_set_class f2 asup_set_class awceq f0 pcom12 f0 f1 f2 awsb f1 asup_set_class f2 asup_set_class awceq f0 awi f1 asup_set_class f2 asup_set_class awceq f0 awa f1 awex awa f1 asup_set_class f2 asup_set_class awceq f0 psyl5bi $.
$}
$( One direction of a simplified definition of substitution.  (Contributed by
     NM, 5-Aug-1993.) $)
${
	$v ph x y $.
	f0 $f wff ph $.
	f1 $f set x $.
	f2 $f set y $.
	psb1 $p |- ( [ y / x ] ph -> E. x ( x = y /\ ph ) ) $=
	f0 f1 f2 adf-sb f0 f1 f2 awsb f1 asup_set_class f2 asup_set_class awceq f0 awi f1 asup_set_class f2 asup_set_class awceq f0 awa f1 awex psimprbi $.
$}
$( Infer substitution into antecedent and consequent of an implication.
       (Contributed by NM, 25-Jun-1998.) $)
${
	$v ph ps x y $.
	e0 $e |- ( ph -> ps ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	psbimi $p |- ( [ y / x ] ph -> [ y / x ] ps ) $=
	e0 f0 f1 f2 asup_set_class f3 asup_set_class awceq pimim2i e0 f0 f1 f2 asup_set_class f3 asup_set_class awceq panim2i f2 asup_set_class f3 asup_set_class awceq f0 awa f2 asup_set_class f3 asup_set_class awceq f1 awa f2 peximi f2 asup_set_class f3 asup_set_class awceq f0 awi f2 asup_set_class f3 asup_set_class awceq f1 awi f2 asup_set_class f3 asup_set_class awceq f0 awa f2 awex f2 asup_set_class f3 asup_set_class awceq f1 awa f2 awex panim12i f0 f2 f3 adf-sb f1 f2 f3 adf-sb f2 asup_set_class f3 asup_set_class awceq f0 awi f2 asup_set_class f3 asup_set_class awceq f0 awa f2 awex awa f2 asup_set_class f3 asup_set_class awceq f1 awi f2 asup_set_class f3 asup_set_class awceq f1 awa f2 awex awa f0 f2 f3 awsb f1 f2 f3 awsb p3imtr4i $.
$}
$( Infer substitution into both sides of a logical equivalence.
       (Contributed by NM, 5-Aug-1993.) $)
${
	$v ph ps x y $.
	e0 $e |- ( ph <-> ps ) $.
	f0 $f wff ph $.
	f1 $f wff ps $.
	f2 $f set x $.
	f3 $f set y $.
	psbbii $p |- ( [ y / x ] ph <-> [ y / x ] ps ) $=
	e0 f0 f1 pbiimpi f0 f1 f2 f3 psbimi e0 f0 f1 pbiimpri f1 f0 f2 f3 psbimi f0 f2 f3 awsb f1 f2 f3 awsb pimpbii $.
$}

