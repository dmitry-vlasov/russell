$[ uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY.mm $]
$( =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Introduce the Axiom of Extensionality

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
$)
$( Axiom of Extensionality.  An axiom of Zermelo-Fraenkel set theory.  It
       states that two sets are identical if they contain the same elements.
       Axiom Ext of [BellMachover] p. 461.

       Set theory can also be formulated with a _single_ primitive predicate
       ` e. ` on top of traditional predicate calculus _without_ equality.  In
       that case the Axiom of Extensionality becomes
       ` ( A. w ( w e. x <-> w e. y ) -> ( x e. z -> y e. z ) ) ` , and
       equality ` x = y ` is _defined_ as ` A. w ( w e. x <-> w e. y ) ` .  All
       of the usual axioms of equality then become theorems of set theory.
       See, for example, Axiom 1 of [TakeutiZaring] p. 8.

       To use the above "equality-free" version of Extensionality with
       Metamath's logical axioms, we would rewrite ~ ax-8 through ~ ax-16 with
       equality expanded according to the above definition.  Some of those
       axioms could be proved from set theory and would be redundant.  Not all
       of them are redundant, since our axioms of predicate calculus make
       essential use of equality for the proper substitution that is a
       primitive notion in traditional predicate calculus.  A study of such an
       axiomatization would be an interesting project for someone exploring the
       foundations of logic.

       _General remarks_:  Our set theory axioms are presented using defined
       connectives ( ` <-> ` , ` E. ` , etc.) for convenience.  However, it is
       implicitly understood that the actual axioms use only the primitive
       connectives ` -> ` , ` -. ` , ` A. ` , ` = ` , and ` e. ` .  It is
       straightforward to establish the equivalence between the actual axioms
       and the ones we display, and we will not do so.

       It is important to understand that strictly speaking, all of our set
       theory axioms are really schemes that represent an infinite number of
       actual axioms.  This is inherent in the design of Metamath
       ("metavariable math"), which manipulates only metavariables.  For
       example, the metavariable ` x ` in ~ ax-ext can represent any actual
       variable _v1_, _v2_, _v3_,... .  Distinct variable restrictions ($d)
       prevent us from substituting say _v1_ for both ` x ` and ` z ` .  This
       is in contrast to typical textbook presentations that present actual
       axioms (except for Replacement ~ ax-rep , which involves a wff
       metavariable).  In practice, though, the theorems and proofs are
       essentially the same.  The $d restrictions make each of the infinite
       axioms generated by the ~ ax-ext scheme exactly logically equivalent to
       each other and in particular to the actual axiom of the textbook
       version.  (Contributed by NM, 5-Aug-1993.) $)
${
	$d x y z $.
	fax-ext_0 $f set x $.
	fax-ext_1 $f set y $.
	fax-ext_2 $f set z $.
	ax-ext $a |- ( A. z ( z e. x <-> z e. y ) -> x = y ) $.
$}
$( The Axiom of Extensionality ( ~ ax-ext ) restated so that it postulates
       the existence of a set ` z ` given two arbitrary sets ` x ` and ` y ` .
       This way to express it follows the general idea of the other ZFC axioms,
       which is to postulate the existence of sets given other sets.
       (Contributed by NM, 28-Sep-2003.) $)
${
	$d x y z $.
	faxext2_0 $f set x $.
	faxext2_1 $f set y $.
	faxext2_2 $f set z $.
	axext2 $p |- E. z ( ( z e. x <-> z e. y ) -> x = y ) $= faxext2_2 sup_set_class faxext2_0 sup_set_class wcel faxext2_2 sup_set_class faxext2_1 sup_set_class wcel wb faxext2_0 sup_set_class faxext2_1 sup_set_class wceq wi faxext2_2 wex faxext2_2 sup_set_class faxext2_0 sup_set_class wcel faxext2_2 sup_set_class faxext2_1 sup_set_class wcel wb faxext2_2 wal faxext2_0 sup_set_class faxext2_1 sup_set_class wceq wi faxext2_0 faxext2_1 faxext2_2 ax-ext faxext2_2 sup_set_class faxext2_0 sup_set_class wcel faxext2_2 sup_set_class faxext2_1 sup_set_class wcel wb faxext2_0 sup_set_class faxext2_1 sup_set_class wceq faxext2_2 19.36v mpbir $.
$}
$( A generalization of the Axiom of Extensionality in which ` x ` and ` y `
       need not be distinct.  (Contributed by NM, 15-Sep-1993.)  (Proof
       shortened by Andrew Salmon, 12-Aug-2011.) $)
${
	$d z x w $.
	$d z y w $.
	iaxext3_0 $f set w $.
	faxext3_0 $f set x $.
	faxext3_1 $f set y $.
	faxext3_2 $f set z $.
	axext3 $p |- ( A. z ( z e. x <-> z e. y ) -> x = y ) $= faxext3_2 sup_set_class iaxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel wb faxext3_2 wal iaxext3_0 sup_set_class faxext3_1 sup_set_class wceq wi faxext3_2 sup_set_class faxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel wb faxext3_2 wal faxext3_0 sup_set_class faxext3_1 sup_set_class wceq wi iaxext3_0 faxext3_0 iaxext3_0 sup_set_class faxext3_0 sup_set_class wceq faxext3_2 sup_set_class iaxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel wb faxext3_2 wal faxext3_2 sup_set_class faxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel wb faxext3_2 wal iaxext3_0 sup_set_class faxext3_1 sup_set_class wceq faxext3_0 sup_set_class faxext3_1 sup_set_class wceq iaxext3_0 sup_set_class faxext3_0 sup_set_class wceq faxext3_2 sup_set_class iaxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel wb faxext3_2 sup_set_class faxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel wb faxext3_2 iaxext3_0 sup_set_class faxext3_0 sup_set_class wceq faxext3_2 sup_set_class iaxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_0 sup_set_class wcel faxext3_2 sup_set_class faxext3_1 sup_set_class wcel iaxext3_0 faxext3_0 faxext3_2 elequ2 bibi1d albidv iaxext3_0 faxext3_0 faxext3_1 equequ1 imbi12d iaxext3_0 faxext3_1 faxext3_2 ax-ext chvarv $.
$}
$( A bidirectional version of Extensionality.  Although this theorem
       "looks" like it is just a definition of equality, it requires the Axiom
       of Extensionality for its proof under our axiomatization.  See the
       comments for ~ ax-ext and ~ df-cleq .  (Contributed by NM,
       14-Nov-2008.) $)
${
	$d z x $.
	$d z y $.
	faxext4_0 $f set x $.
	faxext4_1 $f set y $.
	faxext4_2 $f set z $.
	axext4 $p |- ( x = y <-> A. z ( z e. x <-> z e. y ) ) $= faxext4_0 sup_set_class faxext4_1 sup_set_class wceq faxext4_2 sup_set_class faxext4_0 sup_set_class wcel faxext4_2 sup_set_class faxext4_1 sup_set_class wcel wb faxext4_2 wal faxext4_0 sup_set_class faxext4_1 sup_set_class wceq faxext4_2 sup_set_class faxext4_0 sup_set_class wcel faxext4_2 sup_set_class faxext4_1 sup_set_class wcel wb faxext4_2 faxext4_0 faxext4_1 faxext4_2 elequ2 alrimiv faxext4_0 faxext4_1 faxext4_2 axext3 impbii $.
$}
$( Any set defined by a property is the only set defined by that property.
       Theorem 1.1 of [BellMachover] p. 462.  (Contributed by NM,
       30-Jun-1994.) $)
${
	$d x y z $.
	$d ph z $.
	ibm1.1_0 $f set z $.
	fbm1.1_0 $f wff ph $.
	fbm1.1_1 $f set x $.
	fbm1.1_2 $f set y $.
	ebm1.1_0 $e |- F/ x ph $.
	bm1.1 $p |- ( E. x A. y ( y e. x <-> ph ) -> E! x A. y ( y e. x <-> ph ) ) $= fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 wex fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 wex fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 ibm1.1_0 wsb wa fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq wi ibm1.1_0 wal fbm1.1_1 wal wa fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 weu fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 wex fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 ibm1.1_0 wsb wa fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq wi ibm1.1_0 wal fbm1.1_1 wal fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 ibm1.1_0 wsb wa fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq wi fbm1.1_1 ibm1.1_0 fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 ibm1.1_0 wsb fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 ibm1.1_0 fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb fbm1.1_1 fbm1.1_2 fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 fbm1.1_1 fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_1 nfv ebm1.1_0 nfbi nfal fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 fbm1.1_1 ibm1.1_0 fbm1.1_2 elequ2 bibi1d albidv sbie fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal wa fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb wa fbm1.1_2 wal fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 19.26 fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb wa fbm1.1_2 wal fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel wb fbm1.1_2 wal fbm1.1_1 sup_set_class ibm1.1_0 sup_set_class wceq fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel fbm1.1_0 wb wa fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel wb fbm1.1_2 fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 fbm1.1_2 sup_set_class ibm1.1_0 sup_set_class wcel biantr alimi fbm1.1_1 ibm1.1_0 fbm1.1_2 ax-ext syl sylbir sylan2b gen2 jctr fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal fbm1.1_1 ibm1.1_0 fbm1.1_2 sup_set_class fbm1.1_1 sup_set_class wcel fbm1.1_0 wb fbm1.1_2 wal ibm1.1_0 nfv eu2 sylibr $.
$}

