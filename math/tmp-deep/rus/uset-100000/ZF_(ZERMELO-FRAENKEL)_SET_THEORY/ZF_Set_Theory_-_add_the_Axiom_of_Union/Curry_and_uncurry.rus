import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Function_transposition.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Curry and uncurry

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

constant {
	symbol curry ;;
}

constant {
	symbol uncurry ;;
}

/*Extend class notation to include the currying function. */

rule ccur (A : class) {
	term : class = # curry A ;;
}

/*Extend class notation to include the uncurrying function. */

rule cunc (A : class) {
	term : class = # uncurry A ;;
}

/*Define the currying of ` F ` , which splits a function of two arguments
       into a function of the first argument, producing a function over the
       second argument.  (Contributed by Mario Carneiro, 7-Jan-2017.) */

definition df-cur (x : set, y : set, z : set, F : class) disjointed(x y z F) {
	defiendum : class = # curry F ;;
	definiens : class = # ( x ∈ dom dom F ↦ { 〈 y , z 〉 | 〈 x , y 〉 F z } ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the uncurrying of ` F ` , which takes a function producing
       functions, and transforms it into a two-argument function.  (Contributed
       by Mario Carneiro, 7-Jan-2017.) */

definition df-unc (x : set, y : set, z : set, F : class) disjointed(x y z F) {
	defiendum : class = # uncurry F ;;
	definiens : class = # { 〈 〈 x , y 〉 , z 〉 | y ( F ` x ) z } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}


