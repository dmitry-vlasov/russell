import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Functions.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Operations

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Extend class notation to include the value of an operation ` F ` (such as
     ` + ` ) for two arguments ` A ` and ` B ` .  Note that the syntax is
     simply three class symbols in a row surrounded by parentheses.  Since
     operation values are the only possible class expressions consisting of
     three class expressions in a row surrounded by parentheses, the syntax is
     unambiguous.  (For an example of how syntax could become ambiguous if we
     are not careful, see the comment in ~ cneg .) */

rule co (A : class, B : class, F : class) {
	term : class = # ( A F B ) ;;
}

/* Extend class notation to include class abstraction (class builder) of
     nested ordered pairs. */

rule coprab (ph : wff, x : set, y : set, z : set) {
	term : class = # { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

/* Extend the definition of a class to include maps-to notation for defining
     an operation via a rule. */

rule cmpt2 (x : set, y : set, A : class, B : class, C : class) {
	term : class = # ( x ∈ A , y ∈ B ↦ C ) ;;
}

/* Define the value of an operation.  Definition of operation value in
     [Enderton] p. 79.  Note that the syntax is simply three class expressions
     in a row bracketed by parentheses.  There are no restrictions of any kind
     on what those class expressions may be, although only certain kinds of
     class expressions - a binary operation ` F ` and its arguments ` A ` and
     ` B ` - will be useful for proving meaningful theorems.  For example, if
     class ` F ` is the operation ` + ` and arguments ` A ` and ` B ` are ` 3 `
     and ` 2 ` , the expression ` ( 3 + 2 ) ` can be proved to equal ` 5 ` (see
     ~ 3p2e5 ).  This definition is well-defined, although not very meaningful,
     when classes ` A ` and/or ` B ` are proper classes (i.e. are not sets);
     see ~ ovprc1 and ~ ovprc2 .  On the other hand, we often find uses for
     this definition when ` F ` is a proper class, such as ` +o ` in ~ oav .
     ` F ` is normally equal to a class of nested ordered pairs of the form
     defined by ~ df-oprab .  (Contributed by NM, 28-Feb-1995.) */

definition df-ov (A : class, B : class, F : class)  {
	defiendum : class = # ( A F B ) ;;
	definiens : class = # ( F ` 〈 A , B 〉 ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Define the class abstraction (class builder) of a collection of nested
       ordered pairs (for use in defining operations).  This is a special case
       of Definition 4.16 of [TakeutiZaring] p. 14.  Normally ` x ` , ` y ` ,
       and ` z ` are distinct, although the definition doesn't strictly require
       it.  See ~ df-ov for the value of an operation.  The brace notation is
       called "class abstraction" by Quine; it is also called a "class builder"
       in the literature.  The value of the most common operation class builder
       is given by ~ ovmpt2 .  (Contributed by NM, 12-Mar-1995.) */

definition df-oprab (ph : wff, x : set, y : set, z : set, w : set) disjointed(x w, y w, z w, w ph) {
	defiendum : class = # { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	definiens : class = # { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Define maps-to notation for defining an operation via a rule.  Read as
       "the operation defined by the map from ` x , y ` (in ` A X. B ` ) to
       ` B ( x , y ) ` ."  An extension of ~ df-mpt for two arguments.
       (Contributed by NM, 17-Feb-2008.) */

definition df-mpt2 (x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x z, y z, z A, z B, z C) {
	defiendum : class = # ( x ∈ A , y ∈ B ↦ C ) ;;
	definiens : class = # { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Equality theorem for operation value.  (Contributed by NM,
     28-Feb-1995.) */

theorem oveq (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( F = G → ( A F B ) = ( A G B ) ) ;;
}

proof of oveq {
	step 1 : wff = fveq1 () |- ( F = G → ( F ` 〈 A , B 〉 ) = ( G ` 〈 A , B 〉 ) ) ;;
	step 2 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 3 : wff = df-ov () |- ( A G B ) = ( G ` 〈 A , B 〉 ) ;;
	step 4 : wff = 3eqtr4g (step 1, step 2, step 3) |- ( F = G → ( A F B ) = ( A G B ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Equality theorem for operation value.  (Contributed by NM,
     28-Feb-1995.) */

theorem oveq1 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( A F C ) = ( B F C ) ) ;;
}

proof of oveq1 {
	step 1 : wff = opeq1 () |- ( A = B → 〈 A , C 〉 = 〈 B , C 〉 ) ;;
	step 2 : wff = fveq2d (step 1) |- ( A = B → ( F ` 〈 A , C 〉 ) = ( F ` 〈 B , C 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( A F C ) = ( F ` 〈 A , C 〉 ) ;;
	step 4 : wff = df-ov () |- ( B F C ) = ( F ` 〈 B , C 〉 ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ( A F C ) = ( B F C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Equality theorem for operation value.  (Contributed by NM,
     28-Feb-1995.) */

theorem oveq2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( C F A ) = ( C F B ) ) ;;
}

proof of oveq2 {
	step 1 : wff = opeq2 () |- ( A = B → 〈 C , A 〉 = 〈 C , B 〉 ) ;;
	step 2 : wff = fveq2d (step 1) |- ( A = B → ( F ` 〈 C , A 〉 ) = ( F ` 〈 C , B 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( C F A ) = ( F ` 〈 C , A 〉 ) ;;
	step 4 : wff = df-ov () |- ( C F B ) = ( F ` 〈 C , B 〉 ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ( C F A ) = ( C F B ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Equality theorem for operation value.  (Contributed by NM,
     16-Jul-1995.) */

theorem oveq12 (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → ( A F C ) = ( B F D ) ) ;;
}

proof of oveq12 {
	step 1 : wff = oveq1 () |- ( A = B → ( A F C ) = ( B F C ) ) ;;
	step 2 : wff = oveq2 () |- ( C = D → ( B F C ) = ( B F D ) ) ;;
	step 3 : wff = sylan9eq (step 1, step 2) |- ( ( A = B ∧ C = D ) → ( A F C ) = ( B F D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Equality inference for operation value.  (Contributed by NM,
       28-Feb-1995.) */

theorem oveq1i (A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A F C ) = ( B F C ) ;;
}

proof of oveq1i {
	step 1 : wff = oveq1 () |- ( A = B → ( A F C ) = ( B F C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A F C ) = ( B F C ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for operation value.  (Contributed by NM,
       28-Feb-1995.) */

theorem oveq2i (A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C F A ) = ( C F B ) ;;
}

proof of oveq2i {
	step 1 : wff = oveq2 () |- ( A = B → ( C F A ) = ( C F B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C F A ) = ( C F B ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for operation value.  (Contributed by NM,
         28-Feb-1995.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem oveq12i (A : class, B : class, C : class, D : class, F : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A F C ) = ( B F D ) ;;
}

proof of oveq12i {
	step 1 : wff = oveq12 () |- ( ( A = B ∧ C = D ) → ( A F C ) = ( B F D ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A F C ) = ( B F D ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for operation value.  (Contributed by NM,
       24-Nov-2007.) */

theorem oveqi (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C A D ) = ( C B D ) ;;
}

proof of oveqi {
	step 1 : wff = oveq () |- ( A = B → ( C A D ) = ( C B D ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C A D ) = ( C B D ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for operation value.  (Contributed by FL,
       11-Jul-2010.) */

theorem oveq123i (A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- A = C ;;
	hyp 2 : wff = |- B = D ;;
	hyp 3 : wff = |- F = G ;;
	-----------------------
	prop 1 : wff = |- ( A F B ) = ( C G D ) ;;
}

proof of oveq123i {
	step 1 : wff = oveq12i (hyp 1, hyp 2) |- ( A F B ) = ( C F D ) ;;
	step 2 : wff = oveqi (hyp 3) |- ( C F D ) = ( C G D ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( A F B ) = ( C G D ) ;;
	qed prop 1 = step 3 ;;
}

/* Equality deduction for operation value.  (Contributed by NM,
       13-Mar-1995.) */

theorem oveq1d (ph : wff, A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F C ) = ( B F C ) ) ;;
}

proof of oveq1d {
	step 1 : wff = oveq1 () |- ( A = B → ( A F C ) = ( B F C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A F C ) = ( B F C ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for operation value.  (Contributed by NM,
       13-Mar-1995.) */

theorem oveq2d (ph : wff, A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C F A ) = ( C F B ) ) ;;
}

proof of oveq2d {
	step 1 : wff = oveq2 () |- ( A = B → ( C F A ) = ( C F B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C F A ) = ( C F B ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for operation value.  (Contributed by NM,
       9-Sep-2006.) */

theorem oveqd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C A D ) = ( C B D ) ) ;;
}

proof of oveqd {
	step 1 : wff = oveq () |- ( A = B → ( C A D ) = ( C B D ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C A D ) = ( C B D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for operation value.  (Contributed by NM,
         13-Mar-1995.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem oveq12d (ph : wff, A : class, B : class, C : class, D : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F C ) = ( B F D ) ) ;;
}

proof of oveq12d {
	step 1 : wff = oveq12 () |- ( ( A = B ∧ C = D ) → ( A F C ) = ( B F D ) ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → ( A F C ) = ( B F D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for operation value.  (Contributed by NM,
         10-Aug-1995.) */

theorem oveqan12d (ph : wff, ps : wff, A : class, B : class, C : class, D : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → ( A F C ) = ( B F D ) ) ;;
}

proof of oveqan12d {
	step 1 : wff = oveq12 () |- ( ( A = B ∧ C = D ) → ( A F C ) = ( B F D ) ) ;;
	step 2 : wff = syl2an (hyp 1, hyp 2, step 1) |- ( ( ph ∧ ps ) → ( A F C ) = ( B F D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for operation value.  (Contributed by NM,
         10-Aug-1995.) */

theorem oveqan12rd (ph : wff, ps : wff, A : class, B : class, C : class, D : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps ∧ ph ) → ( A F C ) = ( B F D ) ) ;;
}

proof of oveqan12rd {
	step 1 : wff = oveqan12d (hyp 1, hyp 2) |- ( ( ph ∧ ps ) → ( A F C ) = ( B F D ) ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( ps ∧ ph ) → ( A F C ) = ( B F D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for operation value.  (Contributed by FL,
       22-Dec-2008.) */

theorem oveq123d (ph : wff, A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F C ) = ( B G D ) ) ;;
}

proof of oveq123d {
	step 1 : wff = oveqd (hyp 1) |- ( ph → ( A F C ) = ( A G C ) ) ;;
	step 2 : wff = oveq12d (hyp 2, hyp 3) |- ( ph → ( A G C ) = ( B G D ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → ( A F C ) = ( B G D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction version of bound-variable hypothesis builder ~ nfov .
       (Contributed by NM, 13-Dec-2005.)  (Proof shortened by Andrew Salmon,
       22-Oct-2011.) */

theorem nfovd (ph : wff, x : set, A : class, B : class, F : class)  {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	hyp 2 : wff = |- ( ph → F/_ x F ) ;;
	hyp 3 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x ( A F B ) ) ;;
}

proof of nfovd {
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = nfopd (hyp 1, hyp 3) |- ( ph → F/_ x 〈 A , B 〉 ) ;;
	step 3 : wff = nffvd (hyp 2, step 2) |- ( ph → F/_ x ( F ` 〈 A , B 〉 ) ) ;;
	step 4 : wff = nfcxfrd (step 1, step 3) |- ( ph → F/_ x ( A F B ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Bound-variable hypothesis builder for operation value.  (Contributed by
       NM, 4-May-2004.) */

theorem nfov (x : set, A : class, B : class, F : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x F ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x ( A F B ) ;;
}

proof of nfov {
	step 1 : wff = a1i (hyp 1) |- ( T. → F/_ x A ) ;;
	step 2 : wff = a1i (hyp 2) |- ( T. → F/_ x F ) ;;
	step 3 : wff = a1i (hyp 3) |- ( T. → F/_ x B ) ;;
	step 4 : wff = nfovd (step 1, step 2, step 3) |- ( T. → F/_ x ( A F B ) ) ;;
	step 5 : wff = trud (step 4) |- F/_ x ( A F B ) ;;
	qed prop 1 = step 5 ;;
}

/* The law of concretion.  Special case of Theorem 9.5 of [Quine] p. 61.
       (Contributed by Mario Carneiro, 20-Mar-2013.) */

theorem oprabid (ph : wff, x : set, y : set, z : set) disjointed(a ph r s t w, a r s t w x, a r s t w y, a r s t w z) {
	prop 1 : wff = |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ph ) ;;
}

proof of oprabid {
	var w : set, t : set, s : set, r : set, a : set;;
	step 1 : wff = opex () |- 〈 〈 x , y 〉 , z 〉 ∈ _V ;;
	step 2 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 3 : wff = vex () |- z ∈ _V ;;
	step 4 : wff = eqvinop (step 2, step 3) |- ( w = 〈 〈 x , y 〉 , z 〉 ↔ ∃ a ∃ t ( w = 〈 a , t 〉 ∧ 〈 a , t 〉 = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 5 : wff = biimpi (step 4) |- ( w = 〈 〈 x , y 〉 , z 〉 → ∃ a ∃ t ( w = 〈 a , t 〉 ∧ 〈 a , t 〉 = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 6 : wff = eqeq1 () |- ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 ↔ 〈 a , t 〉 = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 7 : wff = vex () |- a ∈ _V ;;
	step 8 : wff = vex () |- t ∈ _V ;;
	step 9 : wff = opth1 (step 7, step 8) |- ( 〈 a , t 〉 = 〈 〈 x , y 〉 , z 〉 → a = 〈 x , y 〉 ) ;;
	step 10 : wff = syl6bi (step 6, step 9) |- ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → a = 〈 x , y 〉 ) ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = eqvinop (step 11, step 12) |- ( a = 〈 x , y 〉 ↔ ∃ r ∃ s ( a = 〈 r , s 〉 ∧ 〈 r , s 〉 = 〈 x , y 〉 ) ) ;;
	step 14 : wff = opeq1 () |- ( a = 〈 r , s 〉 → 〈 a , t 〉 = 〈 〈 r , s 〉 , t 〉 ) ;;
	step 15 : wff = eqeq2d (step 14) |- ( a = 〈 r , s 〉 → ( w = 〈 a , t 〉 ↔ w = 〈 〈 r , s 〉 , t 〉 ) ) ;;
	step 16 : wff = vex () |- x ∈ _V ;;
	step 17 : wff = vex () |- y ∈ _V ;;
	step 18 : wff = vex () |- z ∈ _V ;;
	step 19 : wff = otth2 (step 16, step 17, step 18) |- ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ↔ ( x = r ∧ y = s ∧ z = t ) ) ;;
	step 20 : wff = df-3an () |- ( ( x = r ∧ y = s ∧ z = t ) ↔ ( ( x = r ∧ y = s ) ∧ z = t ) ) ;;
	step 21 : wff = bitri (step 19, step 20) |- ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ↔ ( ( x = r ∧ y = s ) ∧ z = t ) ) ;;
	step 22 : wff = anbi1i (step 21) |- ( ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) ↔ ( ( ( x = r ∧ y = s ) ∧ z = t ) ∧ ph ) ) ;;
	step 23 : wff = anass () |- ( ( ( ( x = r ∧ y = s ) ∧ z = t ) ∧ ph ) ↔ ( ( x = r ∧ y = s ) ∧ ( z = t ∧ ph ) ) ) ;;
	step 24 : wff = anass () |- ( ( ( x = r ∧ y = s ) ∧ ( z = t ∧ ph ) ) ↔ ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 25 : wff = 3bitri (step 22, step 23, step 24) |- ( ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) ↔ ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 26 : wff = 3exbii (step 25) |- ( ∃ x ∃ y ∃ z ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 27 : wff = nfcvf2 () |- ( ¬ ∀ x x = z → F/_ z x ) ;;
	step 28 : wff = nfcvd () |- ( ¬ ∀ x x = z → F/_ z r ) ;;
	step 29 : wff = nfeqd (step 27, step 28) |- ( ¬ ∀ x x = z → F/ z x = r ) ;;
	step 30 : wff = exdistrf (step 29) |- ( ∃ x ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) → ∃ x ( x = r ∧ ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 31 : wff = eximi (step 30) |- ( ∃ y ∃ x ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) → ∃ y ∃ x ( x = r ∧ ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 32 : wff = excom () |- ( ∃ x ∃ y ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) ↔ ∃ y ∃ x ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 33 : wff = excom () |- ( ∃ x ∃ y ( x = r ∧ ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) ↔ ∃ y ∃ x ( x = r ∧ ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 34 : wff = 3imtr4i (step 31, step 32, step 33) |- ( ∃ x ∃ y ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) → ∃ x ∃ y ( x = r ∧ ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 35 : wff = nfcvf2 () |- ( ¬ ∀ x x = y → F/_ y x ) ;;
	step 36 : wff = nfcvd () |- ( ¬ ∀ x x = y → F/_ y r ) ;;
	step 37 : wff = nfeqd (step 35, step 36) |- ( ¬ ∀ x x = y → F/ y x = r ) ;;
	step 38 : wff = exdistrf (step 37) |- ( ∃ x ∃ y ( x = r ∧ ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) → ∃ x ( x = r ∧ ∃ y ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) ) ;;
	step 39 : wff = nfcvf2 () |- ( ¬ ∀ y y = z → F/_ z y ) ;;
	step 40 : wff = nfcvd () |- ( ¬ ∀ y y = z → F/_ z s ) ;;
	step 41 : wff = nfeqd (step 39, step 40) |- ( ¬ ∀ y y = z → F/ z y = s ) ;;
	step 42 : wff = exdistrf (step 41) |- ( ∃ y ∃ z ( y = s ∧ ( z = t ∧ ph ) ) → ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ;;
	step 43 : wff = anim2i (step 42) |- ( ( x = r ∧ ∃ y ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) → ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) ;;
	step 44 : wff = eximi (step 43) |- ( ∃ x ( x = r ∧ ∃ y ∃ z ( y = s ∧ ( z = t ∧ ph ) ) ) → ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) ;;
	step 45 : wff = 3syl (step 34, step 38, step 44) |- ( ∃ x ∃ y ∃ z ( x = r ∧ ( y = s ∧ ( z = t ∧ ph ) ) ) → ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) ;;
	step 46 : wff = sylbi (step 26, step 45) |- ( ∃ x ∃ y ∃ z ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) → ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) ;;
	step 47 : wff = vex () |- x ∈ _V ;;
	step 48 : wff = vex () |- y ∈ _V ;;
	step 49 : wff = vex () |- z ∈ _V ;;
	step 50 : wff = otth2 (step 47, step 48, step 49) |- ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ↔ ( x = r ∧ y = s ∧ z = t ) ) ;;
	step 51 : wff = euequ1 () |- ∃! x x = r ;;
	step 52 : wff = eupick () |- ( ( ∃! x x = r ∧ ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) → ( x = r → ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) ;;
	step 53 : wff = mpan (step 51, step 52) |- ( ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) → ( x = r → ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) ) ;;
	step 54 : wff = euequ1 () |- ∃! y y = s ;;
	step 55 : wff = eupick () |- ( ( ∃! y y = s ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) → ( y = s → ∃ z ( z = t ∧ ph ) ) ) ;;
	step 56 : wff = mpan (step 54, step 55) |- ( ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) → ( y = s → ∃ z ( z = t ∧ ph ) ) ) ;;
	step 57 : wff = euequ1 () |- ∃! z z = t ;;
	step 58 : wff = eupick () |- ( ( ∃! z z = t ∧ ∃ z ( z = t ∧ ph ) ) → ( z = t → ph ) ) ;;
	step 59 : wff = mpan (step 57, step 58) |- ( ∃ z ( z = t ∧ ph ) → ( z = t → ph ) ) ;;
	step 60 : wff = syl6 (step 56, step 59) |- ( ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) → ( y = s → ( z = t → ph ) ) ) ;;
	step 61 : wff = syl6 (step 53, step 60) |- ( ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) → ( x = r → ( y = s → ( z = t → ph ) ) ) ) ;;
	step 62 : wff = 3impd (step 61) |- ( ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) → ( ( x = r ∧ y = s ∧ z = t ) → ph ) ) ;;
	step 63 : wff = syl5bi (step 50, step 62) |- ( ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) → ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 → ph ) ) ;;
	step 64 : wff = com12 (step 63) |- ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 → ( ∃ x ( x = r ∧ ∃ y ( y = s ∧ ∃ z ( z = t ∧ ph ) ) ) → ph ) ) ;;
	step 65 : wff = syl5 (step 46, step 64) |- ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 → ( ∃ x ∃ y ∃ z ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) → ph ) ) ;;
	step 66 : wff = eqeq1 () |- ( w = 〈 〈 r , s 〉 , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 r , s 〉 , t 〉 = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 67 : wff = eqcom () |- ( 〈 〈 r , s 〉 , t 〉 = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ) ;;
	step 68 : wff = syl6bb (step 66, step 67) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ) ) ;;
	step 69 : wff = eqeq1 () |- ( w = 〈 〈 r , s 〉 , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 r , s 〉 , t 〉 = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 70 : wff = eqcom () |- ( 〈 〈 r , s 〉 , t 〉 = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ) ;;
	step 71 : wff = syl6bb (step 69, step 70) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ) ) ;;
	step 72 : wff = anbi1d (step 71) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) ) ) ;;
	step 73 : wff = 3exbidv (step 72) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) ) ) ;;
	step 74 : wff = imbi1d (step 73) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ↔ ( ∃ x ∃ y ∃ z ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) → ph ) ) ) ;;
	step 75 : wff = imbi12d (step 68, step 74) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ↔ ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 → ( ∃ x ∃ y ∃ z ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 r , s 〉 , t 〉 ∧ ph ) → ph ) ) ) ) ;;
	step 76 : wff = mpbiri (step 65, step 75) |- ( w = 〈 〈 r , s 〉 , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ;;
	step 77 : wff = syl6bi (step 15, step 76) |- ( a = 〈 r , s 〉 → ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ) ;;
	step 78 : wff = adantr (step 77) |- ( ( a = 〈 r , s 〉 ∧ 〈 r , s 〉 = 〈 x , y 〉 ) → ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ) ;;
	step 79 : wff = exlimivv (step 78) |- ( ∃ r ∃ s ( a = 〈 r , s 〉 ∧ 〈 r , s 〉 = 〈 x , y 〉 ) → ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ) ;;
	step 80 : wff = sylbi (step 13, step 79) |- ( a = 〈 x , y 〉 → ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ) ;;
	step 81 : wff = com3l (step 80) |- ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( a = 〈 x , y 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ) ;;
	step 82 : wff = mpdd (step 10, step 81) |- ( w = 〈 a , t 〉 → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ;;
	step 83 : wff = adantr (step 82) |- ( ( w = 〈 a , t 〉 ∧ 〈 a , t 〉 = 〈 〈 x , y 〉 , z 〉 ) → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ;;
	step 84 : wff = exlimivv (step 83) |- ( ∃ a ∃ t ( w = 〈 a , t 〉 ∧ 〈 a , t 〉 = 〈 〈 x , y 〉 , z 〉 ) → ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ) ;;
	step 85 : wff = mpcom (step 5, step 84) |- ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ph ) ) ;;
	step 86 : wff = 19.8a () |- ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 87 : wff = 19.8a () |- ( ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 88 : wff = 19.8a () |- ( ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 89 : wff = 3syl (step 86, step 87, step 88) |- ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 90 : wff = ex (step 89) |- ( w = 〈 〈 x , y 〉 , z 〉 → ( ph → ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ) ;;
	step 91 : wff = impbid (step 85, step 90) |- ( w = 〈 〈 x , y 〉 , z 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ph ) ) ;;
	step 92 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 93 : wff = elab2 (step 1, step 91, step 92) |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ph ) ;;
	qed prop 1 = step 93 ;;
}

/* The result of an operation is a set.  (Contributed by NM, 13-Mar-1995.) */

theorem ovex (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( A F B ) ∈ _V ;;
}

proof of ovex {
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = fvex () |- ( F ` 〈 A , B 〉 ) ∈ _V ;;
	step 3 : wff = eqeltri (step 1, step 2) |- ( A F B ) ∈ _V ;;
	qed prop 1 = step 3 ;;
}

/* The result of an operation value is always a subset of the union of the
     range.  (Contributed by Mario Carneiro, 12-Jan-2017.) */

theorem ovssunirn (F : class, X : class, Y : class)  {
	prop 1 : wff = |- ( X F Y ) ⊆ ⋃ ran F ;;
}

proof of ovssunirn {
	step 1 : wff = df-ov () |- ( X F Y ) = ( F ` 〈 X , Y 〉 ) ;;
	step 2 : wff = fvssunirn () |- ( F ` 〈 X , Y 〉 ) ⊆ ⋃ ran F ;;
	step 3 : wff = eqsstri (step 1, step 2) |- ( X F Y ) ⊆ ⋃ ran F ;;
	qed prop 1 = step 3 ;;
}

/* The value of an operation when the one of the arguments is a proper
       class.  Note: this theorem is dependent on our particular definitions of
       operation value, function value, and ordered pair.  (Contributed by
       Mario Carneiro, 26-Apr-2015.) */

theorem ovprc (A : class, B : class, F : class)  {
	hyp 1 : wff = |- Rel dom F ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( A F B ) = ∅ ) ;;
}

proof of ovprc {
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = df-br () |- ( A dom F B ↔ 〈 A , B 〉 ∈ dom F ) ;;
	step 3 : wff = brrelex12 () |- ( ( Rel dom F ∧ A dom F B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 4 : wff = mpan (hyp 1, step 3) |- ( A dom F B → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 5 : wff = sylbir (step 2, step 4) |- ( 〈 A , B 〉 ∈ dom F → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 6 : wff = con3i (step 5) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ¬ 〈 A , B 〉 ∈ dom F ) ;;
	step 7 : wff = ndmfv () |- ( ¬ 〈 A , B 〉 ∈ dom F → ( F ` 〈 A , B 〉 ) = ∅ ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( F ` 〈 A , B 〉 ) = ∅ ) ;;
	step 9 : wff = syl5eq (step 1, step 8) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( A F B ) = ∅ ) ;;
	qed prop 1 = step 9 ;;
}

/* The value of an operation when the first argument is a proper class.
       (Contributed by NM, 16-Jun-2004.) */

theorem ovprc1 (A : class, B : class, F : class)  {
	hyp 1 : wff = |- Rel dom F ;;
	-----------------------
	prop 1 : wff = |- ( ¬ A ∈ _V → ( A F B ) = ∅ ) ;;
}

proof of ovprc1 {
	step 1 : wff = simpl () |- ( ( A ∈ _V ∧ B ∈ _V ) → A ∈ _V ) ;;
	step 2 : wff = con3i (step 1) |- ( ¬ A ∈ _V → ¬ ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 3 : wff = ovprc (hyp 1) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( A F B ) = ∅ ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ¬ A ∈ _V → ( A F B ) = ∅ ) ;;
	qed prop 1 = step 4 ;;
}

/* The value of an operation when the second argument is a proper class.
       (Contributed by Mario Carneiro, 26-Apr-2015.) */

theorem ovprc2 (A : class, B : class, F : class)  {
	hyp 1 : wff = |- Rel dom F ;;
	-----------------------
	prop 1 : wff = |- ( ¬ B ∈ _V → ( A F B ) = ∅ ) ;;
}

proof of ovprc2 {
	step 1 : wff = simpr () |- ( ( A ∈ _V ∧ B ∈ _V ) → B ∈ _V ) ;;
	step 2 : wff = con3i (step 1) |- ( ¬ B ∈ _V → ¬ ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 3 : wff = ovprc (hyp 1) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( A F B ) = ∅ ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ¬ B ∈ _V → ( A F B ) = ∅ ) ;;
	qed prop 1 = step 4 ;;
}

/* Reverse closure for an operation value.  (Contributed by Mario Carneiro,
       5-May-2015.) */

theorem ovrcl (A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- Rel dom F ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ ( A F B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
}

proof of ovrcl {
	step 1 : wff = n0i () |- ( C ∈ ( A F B ) → ¬ ( A F B ) = ∅ ) ;;
	step 2 : wff = ovprc (hyp 1) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( A F B ) = ∅ ) ;;
	step 3 : wff = nsyl2 (step 1, step 2) |- ( C ∈ ( A F B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Move class substitution in and out of an operation.  (Contributed by NM,
       12-Nov-2005.)  (Proof shortened by Mario Carneiro, 5-Dec-2016.) */

theorem csbovg (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(y A, y B, y C, y D, y F, x y) {
	prop 1 : wff = |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ C ) ) ;;
}

proof of csbovg {
	var y : set;;
	step 1 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ ( B F C ) = [_ A / x ]_ ( B F C ) ) ;;
	step 2 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ F = [_ A / x ]_ F ) ;;
	step 3 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ B = [_ A / x ]_ B ) ;;
	step 4 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ C = [_ A / x ]_ C ) ;;
	step 5 : wff = oveq123d (step 2, step 3, step 4) |- ( y = A → ( [_ y / x ]_ B [_ y / x ]_ F [_ y / x ]_ C ) = ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ C ) ) ;;
	step 6 : wff = eqeq12d (step 1, step 5) |- ( y = A → ( [_ y / x ]_ ( B F C ) = ( [_ y / x ]_ B [_ y / x ]_ F [_ y / x ]_ C ) ↔ [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ C ) ) ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 9 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ F ;;
	step 10 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ C ;;
	step 11 : wff = nfov (step 8, step 9, step 10) |- F/_ x ( [_ y / x ]_ B [_ y / x ]_ F [_ y / x ]_ C ) ;;
	step 12 : wff = csbeq1a () |- ( x = y → F = [_ y / x ]_ F ) ;;
	step 13 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 14 : wff = csbeq1a () |- ( x = y → C = [_ y / x ]_ C ) ;;
	step 15 : wff = oveq123d (step 12, step 13, step 14) |- ( x = y → ( B F C ) = ( [_ y / x ]_ B [_ y / x ]_ F [_ y / x ]_ C ) ) ;;
	step 16 : wff = csbief (step 7, step 11, step 15) |- [_ y / x ]_ ( B F C ) = ( [_ y / x ]_ B [_ y / x ]_ F [_ y / x ]_ C ) ;;
	step 17 : wff = vtoclg (step 6, step 16) |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Move class substitution in and out of an operation.  (Contributed by NM,
       12-Nov-2005.) */

theorem csbov12g (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x F) {
	prop 1 : wff = |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B F [_ A / x ]_ C ) ) ;;
}

proof of csbov12g {
	step 1 : wff = csbovg () |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ C ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ D → [_ A / x ]_ F = F ) ;;
	step 3 : wff = oveqd (step 2) |- ( A ∈ D → ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ C ) = ( [_ A / x ]_ B F [_ A / x ]_ C ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B F [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Move class substitution in and out of an operation.  (Contributed by NM,
       12-Nov-2005.) */

theorem csbov1g (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x C, x F) {
	prop 1 : wff = |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B F C ) ) ;;
}

proof of csbov1g {
	step 1 : wff = csbov12g () |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B F [_ A / x ]_ C ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ D → [_ A / x ]_ C = C ) ;;
	step 3 : wff = oveq2d (step 2) |- ( A ∈ D → ( [_ A / x ]_ B F [_ A / x ]_ C ) = ( [_ A / x ]_ B F C ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B F C ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Move class substitution in and out of an operation.  (Contributed by NM,
       12-Nov-2005.) */

theorem csbov2g (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x B, x F) {
	prop 1 : wff = |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( B F [_ A / x ]_ C ) ) ;;
}

proof of csbov2g {
	step 1 : wff = csbov12g () |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( [_ A / x ]_ B F [_ A / x ]_ C ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ D → [_ A / x ]_ B = B ) ;;
	step 3 : wff = oveq1d (step 2) |- ( A ∈ D → ( [_ A / x ]_ B F [_ A / x ]_ C ) = ( B F [_ A / x ]_ C ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( A ∈ D → [_ A / x ]_ ( B F C ) = ( B F [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 4 ;;
}

/* A frequently used special case of ~ rspc2ev for operation values.
       (Contributed by NM, 21-Mar-2007.) */

theorem rspceov (x : set, y : set, A : class, B : class, C : class, D : class, S : class, F : class) disjointed(x A, x y B, x y C, y D, x y F, x y S) {
	prop 1 : wff = |- ( ( C ∈ A ∧ D ∈ B ∧ S = ( C F D ) ) → ∃ x ∈ A ∃ y ∈ B S = ( x F y ) ) ;;
}

proof of rspceov {
	step 1 : wff = oveq1 () |- ( x = C → ( x F y ) = ( C F y ) ) ;;
	step 2 : wff = eqeq2d (step 1) |- ( x = C → ( S = ( x F y ) ↔ S = ( C F y ) ) ) ;;
	step 3 : wff = oveq2 () |- ( y = D → ( C F y ) = ( C F D ) ) ;;
	step 4 : wff = eqeq2d (step 3) |- ( y = D → ( S = ( C F y ) ↔ S = ( C F D ) ) ) ;;
	step 5 : wff = rspc2ev (step 2, step 4) |- ( ( C ∈ A ∧ D ∈ B ∧ S = ( C F D ) ) → ∃ x ∈ A ∃ y ∈ B S = ( x F y ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Equivalence of operation value and ordered triple membership, analogous
       to ~ fnopfvb .  (Contributed by NM, 17-Dec-2008.)  (Revised by Mario
       Carneiro, 28-Apr-2015.) */

theorem fnotovb (A : class, B : class, C : class, D : class, R : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ C ∈ A ∧ D ∈ B ) → ( ( C F D ) = R ↔ 〈 C , D , R 〉 ∈ F ) ) ;;
}

proof of fnotovb {
	step 1 : wff = opelxpi () |- ( ( C ∈ A ∧ D ∈ B ) → 〈 C , D 〉 ∈ ( A × B ) ) ;;
	step 2 : wff = fnopfvb () |- ( ( F Fn ( A × B ) ∧ 〈 C , D 〉 ∈ ( A × B ) ) → ( ( F ` 〈 C , D 〉 ) = R ↔ 〈 〈 C , D 〉 , R 〉 ∈ F ) ) ;;
	step 3 : wff = sylan2 (step 1, step 2) |- ( ( F Fn ( A × B ) ∧ ( C ∈ A ∧ D ∈ B ) ) → ( ( F ` 〈 C , D 〉 ) = R ↔ 〈 〈 C , D 〉 , R 〉 ∈ F ) ) ;;
	step 4 : wff = 3impb (step 3) |- ( ( F Fn ( A × B ) ∧ C ∈ A ∧ D ∈ B ) → ( ( F ` 〈 C , D 〉 ) = R ↔ 〈 〈 C , D 〉 , R 〉 ∈ F ) ) ;;
	step 5 : wff = df-ov () |- ( C F D ) = ( F ` 〈 C , D 〉 ) ;;
	step 6 : wff = eqeq1i (step 5) |- ( ( C F D ) = R ↔ ( F ` 〈 C , D 〉 ) = R ) ;;
	step 7 : wff = df-ot () |- 〈 C , D , R 〉 = 〈 〈 C , D 〉 , R 〉 ;;
	step 8 : wff = eleq1i (step 7) |- ( 〈 C , D , R 〉 ∈ F ↔ 〈 〈 C , D 〉 , R 〉 ∈ F ) ;;
	step 9 : wff = 3bitr4g (step 4, step 6, step 8) |- ( ( F Fn ( A × B ) ∧ C ∈ A ∧ D ∈ B ) → ( ( C F D ) = R ↔ 〈 C , D , R 〉 ∈ F ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Class abstraction for operations in terms of class abstraction of
       ordered pairs.  (Contributed by NM, 12-Mar-1995.) */

theorem dfoprab2 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x z w v, y z w v, w ph v) {
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
}

proof of dfoprab2 {
	var v : set;;
	step 1 : wff = excom () |- ( ∃ z ∃ w ∃ x ∃ y ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ w ∃ z ∃ x ∃ y ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 2 : wff = exrot4 () |- ( ∃ z ∃ w ∃ x ∃ y ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ x ∃ y ∃ z ∃ w ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 3 : wff = opeq1 () |- ( w = 〈 x , y 〉 → 〈 w , z 〉 = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 4 : wff = eqeq2d (step 3) |- ( w = 〈 x , y 〉 → ( v = 〈 w , z 〉 ↔ v = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 5 : wff = pm5.32ri (step 4) |- ( ( v = 〈 w , z 〉 ∧ w = 〈 x , y 〉 ) ↔ ( v = 〈 〈 x , y 〉 , z 〉 ∧ w = 〈 x , y 〉 ) ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( ( v = 〈 w , z 〉 ∧ w = 〈 x , y 〉 ) ∧ ph ) ↔ ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ w = 〈 x , y 〉 ) ∧ ph ) ) ;;
	step 7 : wff = anass () |- ( ( ( v = 〈 w , z 〉 ∧ w = 〈 x , y 〉 ) ∧ ph ) ↔ ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 8 : wff = an32 () |- ( ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ w = 〈 x , y 〉 ) ∧ ph ) ↔ ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ∧ w = 〈 x , y 〉 ) ) ;;
	step 9 : wff = 3bitr3i (step 6, step 7, step 8) |- ( ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ∧ w = 〈 x , y 〉 ) ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ w ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ w ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ∧ w = 〈 x , y 〉 ) ) ;;
	step 11 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 12 : wff = isseti (step 11) |- ∃ w w = 〈 x , y 〉 ;;
	step 13 : wff = 19.42v () |- ( ∃ w ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ∧ w = 〈 x , y 〉 ) ↔ ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ∧ ∃ w w = 〈 x , y 〉 ) ) ;;
	step 14 : wff = mpbiran2 (step 12, step 13) |- ( ∃ w ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ∧ w = 〈 x , y 〉 ) ↔ ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 15 : wff = bitri (step 10, step 14) |- ( ∃ w ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 16 : wff = 3exbii (step 15) |- ( ∃ x ∃ y ∃ z ∃ w ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 17 : wff = bitri (step 2, step 16) |- ( ∃ z ∃ w ∃ x ∃ y ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 18 : wff = 19.42vv () |- ( ∃ x ∃ y ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ( v = 〈 w , z 〉 ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 19 : wff = 2exbii (step 18) |- ( ∃ w ∃ z ∃ x ∃ y ( v = 〈 w , z 〉 ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ w ∃ z ( v = 〈 w , z 〉 ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 20 : wff = 3bitr3i (step 1, step 17, step 19) |- ( ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ w ∃ z ( v = 〈 w , z 〉 ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 21 : wff = abbii (step 20) |- { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } = { v | ∃ w ∃ z ( v = 〈 w , z 〉 ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) } ;;
	step 22 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 23 : wff = df-opab () |- { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { v | ∃ w ∃ z ( v = 〈 w , z 〉 ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) } ;;
	step 24 : wff = 3eqtr4i (step 21, step 22, step 23) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	qed prop 1 = step 24 ;;
}

/* An operation class abstraction is a relation.  (Contributed by NM,
       16-Jun-2004.) */

theorem reloprab (ph : wff, x : set, y : set, z : set) disjointed(x z w, y z w, w ph) {
	prop 1 : wff = |- Rel { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of reloprab {
	var w : set;;
	step 1 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 2 : wff = relopabi (step 1) |- Rel { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 2 ;;
}

/* @{
    @d x y z w v @.  @d ph v @.
    dfoprab2f.1 @e |- ( ph -> A. w ph ) @.
    @( Class abstraction for operations in terms of class abstraction of
       ordered pairs.  This is a version of ~ dfoprab2 with bound-variable
       hypothesis instead of distinct variable requirement. @)
    dfoprab2f @p |- { <. <. x , y >. , z >. | ph } =
                   { <. w , z >. | E. x E. y ( w = <. x , y >. /\ ph ) } @=
      ( vv coprab cv cop wceq wa wex copab dfoprab2 ax-17 hban hbex weq
      eqeq1 anbi1d 2exbidv cbvopab1
      eqtri ) ABCDHGIZBICIJZKZALZCMZBMZGDNEIZUFKZALZCMBM
      ZEDNABCDGOUJUNGDEUIEBUHECUGAEUGEPFQRRUNGPGESZUHUMBCUOUGULAUEUKUFTUAUBUCUD
      @.
  @}
*/

/* The abstraction variables in an operation class abstraction are not
       free.  (Contributed by NM, 25-Apr-1995.)  (Revised by David Abernethy,
       19-Jun-2012.) */

theorem nfoprab1 (ph : wff, x : set, y : set, z : set) disjointed(w x, w y, w z, w ph) {
	prop 1 : wff = |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of nfoprab1 {
	var w : set;;
	step 1 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 2 : wff = nfe1 () |- F/ x ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 3 : wff = nfab (step 2) |- F/_ x { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 4 : wff = nfcxfr (step 1, step 3) |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 4 ;;
}

/* The abstraction variables in an operation class abstraction are not
       free.  (Contributed by NM, 25-Apr-1995.)  (Revised by David Abernethy,
       30-Jul-2012.) */

theorem nfoprab2 (ph : wff, x : set, y : set, z : set) disjointed(w x, w y, w z, w ph) {
	prop 1 : wff = |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of nfoprab2 {
	var w : set;;
	step 1 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 2 : wff = nfe1 () |- F/ y ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 3 : wff = nfex (step 2) |- F/ y ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 4 : wff = nfab (step 3) |- F/_ y { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 5 : wff = nfcxfr (step 1, step 4) |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 5 ;;
}

/* The abstraction variables in an operation class abstraction are not
       free.  (Contributed by NM, 22-Aug-2013.) */

theorem nfoprab3 (ph : wff, x : set, y : set, z : set) disjointed(w x, w y, w z, w ph) {
	prop 1 : wff = |- F/_ z { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of nfoprab3 {
	var w : set;;
	step 1 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 2 : wff = nfe1 () |- F/ z ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 3 : wff = nfex (step 2) |- F/ z ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 4 : wff = nfex (step 3) |- F/ z ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 5 : wff = nfab (step 4) |- F/_ z { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 6 : wff = nfcxfr (step 1, step 5) |- F/_ z { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 6 ;;
}

/* Bound-variable hypothesis builder for an operation class abstraction.
       (Contributed by NM, 22-Aug-2013.) */

theorem nfoprab (ph : wff, x : set, y : set, z : set, w : set) disjointed(v w x, v w y, v w z, v ph) {
	hyp 1 : wff = |- F/ w ph ;;
	-----------------------
	prop 1 : wff = |- F/_ w { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of nfoprab {
	var v : set;;
	step 1 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 2 : wff = nfv () |- F/ w v = 〈 〈 x , y 〉 , z 〉 ;;
	step 3 : wff = nfan (step 2, hyp 1) |- F/ w ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 4 : wff = nfex (step 3) |- F/ w ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 5 : wff = nfex (step 4) |- F/ w ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 6 : wff = nfex (step 5) |- F/ w ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 7 : wff = nfab (step 6) |- F/_ w { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 8 : wff = nfcxfr (step 1, step 7) |- F/_ w { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 8 ;;
}

/* Equivalent wff's yield equal operation class abstractions (deduction
       rule).  (Contributed by NM, 21-Feb-2004.)  (Revised by Mario Carneiro,
       24-Jun-2014.) */

theorem oprabbid (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set) disjointed(x z w, y z w, w ph, w ps, w ch) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ y ph ;;
	hyp 3 : wff = |- F/ z ph ;;
	hyp 4 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ps } = { 〈 〈 x , y 〉 , z 〉 | ch } ) ;;
}

proof of oprabbid {
	var w : set;;
	step 1 : wff = anbi2d (hyp 4) |- ( ph → ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ↔ ( w = 〈 〈 x , y 〉 , z 〉 ∧ ch ) ) ) ;;
	step 2 : wff = exbid (hyp 3, step 1) |- ( ph → ( ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ↔ ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ch ) ) ) ;;
	step 3 : wff = exbid (hyp 2, step 2) |- ( ph → ( ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ↔ ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ch ) ) ) ;;
	step 4 : wff = exbid (hyp 1, step 3) |- ( ph → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ↔ ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ch ) ) ) ;;
	step 5 : wff = abbidv (step 4) |- ( ph → { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ch ) } ) ;;
	step 6 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ps } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) } ;;
	step 7 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ch } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ch ) } ;;
	step 8 : wff = 3eqtr4g (step 5, step 6, step 7) |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ps } = { 〈 〈 x , y 〉 , z 〉 | ch } ) ;;
	qed prop 1 = step 8 ;;
}

/* Equivalent wff's yield equal operation class abstractions (deduction
       rule).  (Contributed by NM, 21-Feb-2004.) */

theorem oprabbidv (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set) disjointed(x z ph, y z ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ps } = { 〈 〈 x , y 〉 , z 〉 | ch } ) ;;
}

proof of oprabbidv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = nfv () |- F/ z ph ;;
	step 4 : wff = oprabbid (step 1, step 2, step 3, hyp 1) |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ps } = { 〈 〈 x , y 〉 , z 〉 | ch } ) ;;
	qed prop 1 = step 4 ;;
}

/* Equivalent wff's yield equal operation class abstractions.  (Contributed
       by NM, 28-May-1995.)  (Revised by David Abernethy, 19-Jun-2012.) */

theorem oprabbii (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x z w, y z w, w ph, w ps) {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , z 〉 | ps } ;;
}

proof of oprabbii {
	var w : set;;
	step 1 : wff = eqid () |- w = w ;;
	step 2 : wff = a1i (hyp 1) |- ( w = w → ( ph ↔ ps ) ) ;;
	step 3 : wff = oprabbidv (step 2) |- ( w = w → { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , z 〉 | ps } ) ;;
	step 4 : wff = ax-mp (step 1, step 3) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	qed prop 1 = step 4 ;;
}

/* Equivalence of ordered pair abstraction subclass and implication.
       Compare ~ ssopab2 .  (Contributed by FL, 6-Nov-2013.)  (Proof shortened
       by Mario Carneiro, 11-Dec-2016.) */

theorem ssoprab2 (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(ph w, ps w, x w, y w, z w) {
	prop 1 : wff = |- ( ∀ x ∀ y ∀ z ( ph → ps ) → { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ) ;;
}

proof of ssoprab2 {
	var w : set;;
	step 1 : wff = id () |- ( ( ph → ps ) → ( ph → ps ) ) ;;
	step 2 : wff = anim2d (step 1) |- ( ( ph → ps ) → ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 3 : wff = alimi (step 2) |- ( ∀ z ( ph → ps ) → ∀ z ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 4 : wff = exim () |- ( ∀ z ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) → ( ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ∀ z ( ph → ps ) → ( ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 6 : wff = alimi (step 5) |- ( ∀ y ∀ z ( ph → ps ) → ∀ y ( ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 7 : wff = exim () |- ( ∀ y ( ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) → ( ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ∀ y ∀ z ( ph → ps ) → ( ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 9 : wff = alimi (step 8) |- ( ∀ x ∀ y ∀ z ( ph → ps ) → ∀ x ( ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 10 : wff = exim () |- ( ∀ x ( ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( ∀ x ∀ y ∀ z ( ph → ps ) → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) ) ) ;;
	step 12 : wff = ss2abdv (step 11) |- ( ∀ x ∀ y ∀ z ( ph → ps ) → { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ⊆ { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) } ) ;;
	step 13 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 14 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ps } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ps ) } ;;
	step 15 : wff = 3sstr4g (step 12, step 13, step 14) |- ( ∀ x ∀ y ∀ z ( ph → ps ) → { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ) ;;
	qed prop 1 = step 15 ;;
}

/* Equivalence of ordered pair abstraction subclass and implication.  Compare
     ~ ssopab2b .  (Contributed by FL, 6-Nov-2013.)  (Proof shortened by Mario
     Carneiro, 11-Dec-2016.) */

theorem ssoprab2b (ph : wff, ps : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ∀ x ∀ y ∀ z ( ph → ps ) ) ;;
}

proof of ssoprab2b {
	step 1 : wff = nfoprab1 () |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 2 : wff = nfoprab1 () |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	step 3 : wff = nfss (step 1, step 2) |- F/ x { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	step 4 : wff = nfoprab2 () |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 5 : wff = nfoprab2 () |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	step 6 : wff = nfss (step 4, step 5) |- F/ y { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	step 7 : wff = nfoprab3 () |- F/_ z { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 8 : wff = nfoprab3 () |- F/_ z { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	step 9 : wff = nfss (step 7, step 8) |- F/ z { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	step 10 : wff = ssel () |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } → ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ps } ) ) ;;
	step 11 : wff = oprabid () |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ph ) ;;
	step 12 : wff = oprabid () |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ps ) ;;
	step 13 : wff = 3imtr3g (step 10, step 11, step 12) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } → ( ph → ps ) ) ;;
	step 14 : wff = alrimi (step 9, step 13) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } → ∀ z ( ph → ps ) ) ;;
	step 15 : wff = alrimi (step 6, step 14) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } → ∀ y ∀ z ( ph → ps ) ) ;;
	step 16 : wff = alrimi (step 3, step 15) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } → ∀ x ∀ y ∀ z ( ph → ps ) ) ;;
	step 17 : wff = ssoprab2 () |- ( ∀ x ∀ y ∀ z ( ph → ps ) → { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ) ;;
	step 18 : wff = impbii (step 16, step 17) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ∀ x ∀ y ∀ z ( ph → ps ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Equivalence of ordered pair abstraction subclass and biconditional.
     Compare ~ eqopab2b .  (Contributed by Mario Carneiro, 4-Jan-2017.) */

theorem eqoprab2b (ph : wff, ps : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ∀ x ∀ y ∀ z ( ph ↔ ps ) ) ;;
}

proof of eqoprab2b {
	step 1 : wff = ssoprab2b () |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ∀ x ∀ y ∀ z ( ph → ps ) ) ;;
	step 2 : wff = ssoprab2b () |- ( { 〈 〈 x , y 〉 , z 〉 | ps } ⊆ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ∀ x ∀ y ∀ z ( ps → ph ) ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ∧ { 〈 〈 x , y 〉 , z 〉 | ps } ⊆ { 〈 〈 x , y 〉 , z 〉 | ph } ) ↔ ( ∀ x ∀ y ∀ z ( ph → ps ) ∧ ∀ x ∀ y ∀ z ( ps → ph ) ) ) ;;
	step 4 : wff = eqss () |- ( { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ( { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ∧ { 〈 〈 x , y 〉 , z 〉 | ps } ⊆ { 〈 〈 x , y 〉 , z 〉 | ph } ) ) ;;
	step 5 : wff = 2albiim () |- ( ∀ y ∀ z ( ph ↔ ps ) ↔ ( ∀ y ∀ z ( ph → ps ) ∧ ∀ y ∀ z ( ps → ph ) ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ x ∀ y ∀ z ( ph ↔ ps ) ↔ ∀ x ( ∀ y ∀ z ( ph → ps ) ∧ ∀ y ∀ z ( ps → ph ) ) ) ;;
	step 7 : wff = 19.26 () |- ( ∀ x ( ∀ y ∀ z ( ph → ps ) ∧ ∀ y ∀ z ( ps → ph ) ) ↔ ( ∀ x ∀ y ∀ z ( ph → ps ) ∧ ∀ x ∀ y ∀ z ( ps → ph ) ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ∀ x ∀ y ∀ z ( ph ↔ ps ) ↔ ( ∀ x ∀ y ∀ z ( ph → ps ) ∧ ∀ x ∀ y ∀ z ( ps → ph ) ) ) ;;
	step 9 : wff = 3bitr4i (step 3, step 4, step 8) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , z 〉 | ps } ↔ ∀ x ∀ y ∀ z ( ph ↔ ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* An equality theorem for the maps to notation.  (Contributed by Mario
       Carneiro, 16-Dec-2013.)  (Revised by Mario Carneiro, 19-Mar-2015.) */

theorem mpt2eq123 (x : set, y : set, A : class, B : class, C : class, D : class, E : class, F : class) disjointed(x y z A, y z B, x y z D, y z E, z C, z F) {
	prop 1 : wff = |- ( ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
}

proof of mpt2eq123 {
	var z : set;;
	step 1 : wff = nfv () |- F/ x A = D ;;
	step 2 : wff = nfra1 () |- F/ x ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ x ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) ;;
	step 4 : wff = nfv () |- F/ y A = D ;;
	step 5 : wff = nfcv () |- F/_ y A ;;
	step 6 : wff = nfv () |- F/ y B = E ;;
	step 7 : wff = nfra1 () |- F/ y ∀ y ∈ B C = F ;;
	step 8 : wff = nfan (step 6, step 7) |- F/ y ( B = E ∧ ∀ y ∈ B C = F ) ;;
	step 9 : wff = nfral (step 5, step 8) |- F/ y ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ;;
	step 10 : wff = nfan (step 4, step 9) |- F/ y ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) ;;
	step 11 : wff = nfv () |- F/ z ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) ;;
	step 12 : wff = rsp () |- ( ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) → ( x ∈ A → ( B = E ∧ ∀ y ∈ B C = F ) ) ) ;;
	step 13 : wff = rsp () |- ( ∀ y ∈ B C = F → ( y ∈ B → C = F ) ) ;;
	step 14 : wff = eqeq2 () |- ( C = F → ( z = C ↔ z = F ) ) ;;
	step 15 : wff = syl6 (step 13, step 14) |- ( ∀ y ∈ B C = F → ( y ∈ B → ( z = C ↔ z = F ) ) ) ;;
	step 16 : wff = pm5.32d (step 15) |- ( ∀ y ∈ B C = F → ( ( y ∈ B ∧ z = C ) ↔ ( y ∈ B ∧ z = F ) ) ) ;;
	step 17 : wff = eleq2 () |- ( B = E → ( y ∈ B ↔ y ∈ E ) ) ;;
	step 18 : wff = anbi1d (step 17) |- ( B = E → ( ( y ∈ B ∧ z = F ) ↔ ( y ∈ E ∧ z = F ) ) ) ;;
	step 19 : wff = sylan9bbr (step 16, step 18) |- ( ( B = E ∧ ∀ y ∈ B C = F ) → ( ( y ∈ B ∧ z = C ) ↔ ( y ∈ E ∧ z = F ) ) ) ;;
	step 20 : wff = syl6 (step 12, step 19) |- ( ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) → ( x ∈ A → ( ( y ∈ B ∧ z = C ) ↔ ( y ∈ E ∧ z = F ) ) ) ) ;;
	step 21 : wff = pm5.32d (step 20) |- ( ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) → ( ( x ∈ A ∧ ( y ∈ B ∧ z = C ) ) ↔ ( x ∈ A ∧ ( y ∈ E ∧ z = F ) ) ) ) ;;
	step 22 : wff = eleq2 () |- ( A = D → ( x ∈ A ↔ x ∈ D ) ) ;;
	step 23 : wff = anbi1d (step 22) |- ( A = D → ( ( x ∈ A ∧ ( y ∈ E ∧ z = F ) ) ↔ ( x ∈ D ∧ ( y ∈ E ∧ z = F ) ) ) ) ;;
	step 24 : wff = sylan9bbr (step 21, step 23) |- ( ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) → ( ( x ∈ A ∧ ( y ∈ B ∧ z = C ) ) ↔ ( x ∈ D ∧ ( y ∈ E ∧ z = F ) ) ) ) ;;
	step 25 : wff = anass () |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ z = C ) ) ) ;;
	step 26 : wff = anass () |- ( ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) ↔ ( x ∈ D ∧ ( y ∈ E ∧ z = F ) ) ) ;;
	step 27 : wff = 3bitr4g (step 24, step 25, step 26) |- ( ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) → ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) ) ) ;;
	step 28 : wff = oprabbid (step 3, step 10, step 11, step 27) |- ( ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) } ) ;;
	step 29 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 30 : wff = df-mpt2 () |- ( x ∈ D , y ∈ E ↦ F ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) } ;;
	step 31 : wff = 3eqtr4g (step 28, step 29, step 30) |- ( ( A = D ∧ ∀ x ∈ A ( B = E ∧ ∀ y ∈ B C = F ) ) → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
	qed prop 1 = step 31 ;;
}

/* An equality theorem for the maps to notation.  (Contributed by Mario
       Carneiro, 16-Dec-2013.) */

theorem mpt2eq12 (x : set, y : set, A : class, B : class, C : class, D : class, E : class) disjointed(x y A, x y B, x y C, x y D) {
	prop 1 : wff = |- ( ( A = C ∧ B = D ) → ( x ∈ A , y ∈ B ↦ E ) = ( x ∈ C , y ∈ D ↦ E ) ) ;;
}

proof of mpt2eq12 {
	step 1 : wff = eqid () |- E = E ;;
	step 2 : wff = rgenw (step 1) |- ∀ y ∈ B E = E ;;
	step 3 : wff = jctr (step 2) |- ( B = D → ( B = D ∧ ∀ y ∈ B E = E ) ) ;;
	step 4 : wff = ralrimivw (step 3) |- ( B = D → ∀ x ∈ A ( B = D ∧ ∀ y ∈ B E = E ) ) ;;
	step 5 : wff = mpt2eq123 () |- ( ( A = C ∧ ∀ x ∈ A ( B = D ∧ ∀ y ∈ B E = E ) ) → ( x ∈ A , y ∈ B ↦ E ) = ( x ∈ C , y ∈ D ↦ E ) ) ;;
	step 6 : wff = sylan2 (step 4, step 5) |- ( ( A = C ∧ B = D ) → ( x ∈ A , y ∈ B ↦ E ) = ( x ∈ C , y ∈ D ↦ E ) ) ;;
	qed prop 1 = step 6 ;;
}

/* An equality deduction for the maps to notation.  (Contributed by Mario
         Carneiro, 26-Jan-2017.) */

theorem mpt2eq123dva (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, E : class, F : class) disjointed(z A, z B, z C, z D, z E, x z ph, z F, y z ph) {
	hyp 1 : wff = |- ( ph → A = D ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → B = E ) ;;
	hyp 3 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → C = F ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
}

proof of mpt2eq123dva {
	var z : set;;
	step 1 : wff = eqeq2d (hyp 3) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( z = C ↔ z = F ) ) ;;
	step 2 : wff = pm5.32da (step 1) |- ( ph → ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = F ) ) ) ;;
	step 3 : wff = eleq2d (hyp 2) |- ( ( ph ∧ x ∈ A ) → ( y ∈ B ↔ y ∈ E ) ) ;;
	step 4 : wff = pm5.32da (step 3) |- ( ph → ( ( x ∈ A ∧ y ∈ B ) ↔ ( x ∈ A ∧ y ∈ E ) ) ) ;;
	step 5 : wff = eleq2d (hyp 1) |- ( ph → ( x ∈ A ↔ x ∈ D ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( ph → ( ( x ∈ A ∧ y ∈ E ) ↔ ( x ∈ D ∧ y ∈ E ) ) ) ;;
	step 7 : wff = bitrd (step 4, step 6) |- ( ph → ( ( x ∈ A ∧ y ∈ B ) ↔ ( x ∈ D ∧ y ∈ E ) ) ) ;;
	step 8 : wff = anbi1d (step 7) |- ( ph → ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = F ) ↔ ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) ) ) ;;
	step 9 : wff = bitrd (step 2, step 8) |- ( ph → ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) ) ) ;;
	step 10 : wff = oprabbidv (step 9) |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) } ) ;;
	step 11 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 12 : wff = df-mpt2 () |- ( x ∈ D , y ∈ E ↦ F ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ D ∧ y ∈ E ) ∧ z = F ) } ;;
	step 13 : wff = 3eqtr4g (step 10, step 11, step 12) |- ( ph → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
	qed prop 1 = step 13 ;;
}

/* An equality deduction for the maps to notation.  (Contributed by NM,
       12-Sep-2011.) */

theorem mpt2eq123dv (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, E : class, F : class) disjointed(x ph, y ph) {
	hyp 1 : wff = |- ( ph → A = D ) ;;
	hyp 2 : wff = |- ( ph → B = E ) ;;
	hyp 3 : wff = |- ( ph → C = F ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
}

proof of mpt2eq123dv {
	step 1 : wff = adantr (hyp 2) |- ( ( ph ∧ x ∈ A ) → B = E ) ;;
	step 2 : wff = adantr (hyp 3) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → C = F ) ;;
	step 3 : wff = mpt2eq123dva (hyp 1, step 1, step 2) |- ( ph → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
	qed prop 1 = step 3 ;;
}

/* An equality inference for the maps to notation.  (Contributed by NM,
       15-Jul-2013.) */

theorem mpt2eq123i (x : set, y : set, A : class, B : class, C : class, D : class, E : class, F : class)  {
	hyp 1 : wff = |- A = D ;;
	hyp 2 : wff = |- B = E ;;
	hyp 3 : wff = |- C = F ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ;;
}

proof of mpt2eq123i {
	step 1 : wff = a1i (hyp 1) |- ( T. → A = D ) ;;
	step 2 : wff = a1i (hyp 2) |- ( T. → B = E ) ;;
	step 3 : wff = a1i (hyp 3) |- ( T. → C = F ) ;;
	step 4 : wff = mpt2eq123dv (step 1, step 2, step 3) |- ( T. → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ) ;;
	step 5 : wff = trud (step 4) |- ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ D , y ∈ E ↦ F ) ;;
	qed prop 1 = step 5 ;;
}

/* Slightly more general equality inference for the maps to notation.
       (Contributed by NM, 17-Oct-2013.) */

theorem mpt2eq3dva (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x z ph, y z ph, z A, z B, z C, z D) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ∧ y ∈ B ) → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ) ;;
}

proof of mpt2eq3dva {
	var z : set;;
	step 1 : wff = 3expb (hyp 1) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → C = D ) ;;
	step 2 : wff = eqeq2d (step 1) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( z = C ↔ z = D ) ) ;;
	step 3 : wff = pm5.32da (step 2) |- ( ph → ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ) ;;
	step 4 : wff = oprabbidv (step 3) |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) } ) ;;
	step 5 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 6 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ D ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) } ;;
	step 7 : wff = 3eqtr4g (step 4, step 5, step 6) |- ( ph → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ) ;;
	qed prop 1 = step 7 ;;
}

/* An equality inference for the maps to notation.  (Contributed by Mario
       Carneiro, 16-Dec-2013.) */

theorem mpt2eq3ia (x : set, y : set, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
}

proof of mpt2eq3ia {
	step 1 : wff = 3adant1 (hyp 1) |- ( ( T. ∧ x ∈ A ∧ y ∈ B ) → C = D ) ;;
	step 2 : wff = mpt2eq3dva (step 1) |- ( T. → ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ) ;;
	step 3 : wff = trud (step 2) |- ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
	qed prop 1 = step 3 ;;
}

/* Bound-variable hypothesis builder for an operation in maps-to notation.
       (Contributed by NM, 27-Aug-2013.) */

theorem nfmpt21 (x : set, y : set, A : class, B : class, C : class) disjointed(z A, z B, z C, z x, z y) {
	prop 1 : wff = |- F/_ x ( x ∈ A , y ∈ B ↦ C ) ;;
}

proof of nfmpt21 {
	var z : set;;
	step 1 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = nfoprab1 () |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 3 : wff = nfcxfr (step 1, step 2) |- F/_ x ( x ∈ A , y ∈ B ↦ C ) ;;
	qed prop 1 = step 3 ;;
}

/* Bound-variable hypothesis builder for an operation in maps-to notation.
       (Contributed by NM, 27-Aug-2013.) */

theorem nfmpt22 (x : set, y : set, A : class, B : class, C : class) disjointed(z A, z B, z C, z x, z y) {
	prop 1 : wff = |- F/_ y ( x ∈ A , y ∈ B ↦ C ) ;;
}

proof of nfmpt22 {
	var z : set;;
	step 1 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = nfoprab2 () |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 3 : wff = nfcxfr (step 1, step 2) |- F/_ y ( x ∈ A , y ∈ B ↦ C ) ;;
	qed prop 1 = step 3 ;;
}

/* Bound-variable hypothesis builder for the maps-to notation.
       (Contributed by NM, 20-Feb-2013.) */

theorem nfmpt2 (x : set, y : set, z : set, A : class, B : class, C : class) disjointed(w x z, w y z, w A, w B, w C) {
	hyp 1 : wff = |- F/_ z A ;;
	hyp 2 : wff = |- F/_ z B ;;
	hyp 3 : wff = |- F/_ z C ;;
	-----------------------
	prop 1 : wff = |- F/_ z ( x ∈ A , y ∈ B ↦ C ) ;;
}

proof of nfmpt2 {
	var w : set;;
	step 1 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , w 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) } ;;
	step 2 : wff = nfcri (hyp 1) |- F/ z x ∈ A ;;
	step 3 : wff = nfcri (hyp 2) |- F/ z y ∈ B ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ z ( x ∈ A ∧ y ∈ B ) ;;
	step 5 : wff = nfeq2 (hyp 3) |- F/ z w = C ;;
	step 6 : wff = nfan (step 4, step 5) |- F/ z ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ;;
	step 7 : wff = nfoprab (step 6) |- F/_ z { 〈 〈 x , y 〉 , w 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) } ;;
	step 8 : wff = nfcxfr (step 1, step 7) |- F/_ z ( x ∈ A , y ∈ B ↦ C ) ;;
	qed prop 1 = step 8 ;;
}

/* Two ways to state the domain of an operation.  (Contributed by FL,
       24-Jan-2010.) */

theorem oprab4 (ph : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z) {
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ( 〈 x , y 〉 ∈ ( A × B ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
}

proof of oprab4 {
	step 1 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 2 : wff = anbi1i (step 1) |- ( ( 〈 x , y 〉 ∈ ( A × B ) ∧ ph ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
	step 3 : wff = oprabbii (step 2) |- { 〈 〈 x , y 〉 , z 〉 | ( 〈 x , y 〉 ∈ ( A × B ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	qed prop 1 = step 3 ;;
}

/* Rule used to change first bound variable in an operation abstraction,
       using implicit substitution.  (Contributed by NM, 20-Dec-2008.)
       (Revised by Mario Carneiro, 5-Dec-2016.) */

theorem cbvoprab1 (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(x y z w v, v ph, v ps) {
	hyp 1 : wff = |- F/ w ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = w → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 w , y 〉 , z 〉 | ps } ;;
}

proof of cbvoprab1 {
	var v : set;;
	step 1 : wff = nfv () |- F/ w v = 〈 x , y 〉 ;;
	step 2 : wff = nfan (step 1, hyp 1) |- F/ w ( v = 〈 x , y 〉 ∧ ph ) ;;
	step 3 : wff = nfex (step 2) |- F/ w ∃ y ( v = 〈 x , y 〉 ∧ ph ) ;;
	step 4 : wff = nfv () |- F/ x v = 〈 w , y 〉 ;;
	step 5 : wff = nfan (step 4, hyp 2) |- F/ x ( v = 〈 w , y 〉 ∧ ps ) ;;
	step 6 : wff = nfex (step 5) |- F/ x ∃ y ( v = 〈 w , y 〉 ∧ ps ) ;;
	step 7 : wff = opeq1 () |- ( x = w → 〈 x , y 〉 = 〈 w , y 〉 ) ;;
	step 8 : wff = eqeq2d (step 7) |- ( x = w → ( v = 〈 x , y 〉 ↔ v = 〈 w , y 〉 ) ) ;;
	step 9 : wff = anbi12d (step 8, hyp 3) |- ( x = w → ( ( v = 〈 x , y 〉 ∧ ph ) ↔ ( v = 〈 w , y 〉 ∧ ps ) ) ) ;;
	step 10 : wff = exbidv (step 9) |- ( x = w → ( ∃ y ( v = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ( v = 〈 w , y 〉 ∧ ps ) ) ) ;;
	step 11 : wff = cbvex (step 3, step 6, step 10) |- ( ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) ↔ ∃ w ∃ y ( v = 〈 w , y 〉 ∧ ps ) ) ;;
	step 12 : wff = opabbii (step 11) |- { 〈 v , z 〉 | ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) } = { 〈 v , z 〉 | ∃ w ∃ y ( v = 〈 w , y 〉 ∧ ps ) } ;;
	step 13 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 v , z 〉 | ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) } ;;
	step 14 : wff = dfoprab2 () |- { 〈 〈 w , y 〉 , z 〉 | ps } = { 〈 v , z 〉 | ∃ w ∃ y ( v = 〈 w , y 〉 ∧ ps ) } ;;
	step 15 : wff = 3eqtr4i (step 12, step 13, step 14) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 w , y 〉 , z 〉 | ps } ;;
	qed prop 1 = step 15 ;;
}

/* Change the second bound variable in an operation abstraction.
       (Contributed by Jeff Madsen, 11-Jun-2010.)  (Revised by Mario Carneiro,
       11-Dec-2016.) */

theorem cbvoprab2 (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(v w x y z, ph v, ps v) {
	hyp 1 : wff = |- F/ w ph ;;
	hyp 2 : wff = |- F/ y ps ;;
	hyp 3 : wff = |- ( y = w → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , w 〉 , z 〉 | ps } ;;
}

proof of cbvoprab2 {
	var v : set;;
	step 1 : wff = nfv () |- F/ w v = 〈 〈 x , y 〉 , z 〉 ;;
	step 2 : wff = nfan (step 1, hyp 1) |- F/ w ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 3 : wff = nfex (step 2) |- F/ w ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ;;
	step 4 : wff = nfv () |- F/ y v = 〈 〈 x , w 〉 , z 〉 ;;
	step 5 : wff = nfan (step 4, hyp 2) |- F/ y ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) ;;
	step 6 : wff = nfex (step 5) |- F/ y ∃ z ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) ;;
	step 7 : wff = opeq2 () |- ( y = w → 〈 x , y 〉 = 〈 x , w 〉 ) ;;
	step 8 : wff = opeq1d (step 7) |- ( y = w → 〈 〈 x , y 〉 , z 〉 = 〈 〈 x , w 〉 , z 〉 ) ;;
	step 9 : wff = eqeq2d (step 8) |- ( y = w → ( v = 〈 〈 x , y 〉 , z 〉 ↔ v = 〈 〈 x , w 〉 , z 〉 ) ) ;;
	step 10 : wff = anbi12d (step 9, hyp 3) |- ( y = w → ( ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) ) ) ;;
	step 11 : wff = exbidv (step 10) |- ( y = w → ( ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ z ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) ) ) ;;
	step 12 : wff = cbvex (step 3, step 6, step 11) |- ( ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ w ∃ z ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ x ∃ w ∃ z ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) ) ;;
	step 14 : wff = abbii (step 13) |- { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } = { v | ∃ x ∃ w ∃ z ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) } ;;
	step 15 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 16 : wff = df-oprab () |- { 〈 〈 x , w 〉 , z 〉 | ps } = { v | ∃ x ∃ w ∃ z ( v = 〈 〈 x , w 〉 , z 〉 ∧ ps ) } ;;
	step 17 : wff = 3eqtr4i (step 14, step 15, step 16) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , w 〉 , z 〉 | ps } ;;
	qed prop 1 = step 17 ;;
}

/* Rule used to change first two bound variables in an operation
       abstraction, using implicit substitution.  (Contributed by NM,
       21-Feb-2004.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem cbvoprab12 (ph : wff, ps : wff, x : set, y : set, z : set, w : set, v : set) disjointed(x y z w v u, u ph, u ps) {
	hyp 1 : wff = |- F/ w ph ;;
	hyp 2 : wff = |- F/ v ph ;;
	hyp 3 : wff = |- F/ x ps ;;
	hyp 4 : wff = |- F/ y ps ;;
	hyp 5 : wff = |- ( ( x = w ∧ y = v ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 w , v 〉 , z 〉 | ps } ;;
}

proof of cbvoprab12 {
	var u : set;;
	step 1 : wff = nfv () |- F/ w u = 〈 x , y 〉 ;;
	step 2 : wff = nfan (step 1, hyp 1) |- F/ w ( u = 〈 x , y 〉 ∧ ph ) ;;
	step 3 : wff = nfv () |- F/ v u = 〈 x , y 〉 ;;
	step 4 : wff = nfan (step 3, hyp 2) |- F/ v ( u = 〈 x , y 〉 ∧ ph ) ;;
	step 5 : wff = nfv () |- F/ x u = 〈 w , v 〉 ;;
	step 6 : wff = nfan (step 5, hyp 3) |- F/ x ( u = 〈 w , v 〉 ∧ ps ) ;;
	step 7 : wff = nfv () |- F/ y u = 〈 w , v 〉 ;;
	step 8 : wff = nfan (step 7, hyp 4) |- F/ y ( u = 〈 w , v 〉 ∧ ps ) ;;
	step 9 : wff = opeq12 () |- ( ( x = w ∧ y = v ) → 〈 x , y 〉 = 〈 w , v 〉 ) ;;
	step 10 : wff = eqeq2d (step 9) |- ( ( x = w ∧ y = v ) → ( u = 〈 x , y 〉 ↔ u = 〈 w , v 〉 ) ) ;;
	step 11 : wff = anbi12d (step 10, hyp 5) |- ( ( x = w ∧ y = v ) → ( ( u = 〈 x , y 〉 ∧ ph ) ↔ ( u = 〈 w , v 〉 ∧ ps ) ) ) ;;
	step 12 : wff = cbvex2 (step 2, step 4, step 6, step 8, step 11) |- ( ∃ x ∃ y ( u = 〈 x , y 〉 ∧ ph ) ↔ ∃ w ∃ v ( u = 〈 w , v 〉 ∧ ps ) ) ;;
	step 13 : wff = opabbii (step 12) |- { 〈 u , z 〉 | ∃ x ∃ y ( u = 〈 x , y 〉 ∧ ph ) } = { 〈 u , z 〉 | ∃ w ∃ v ( u = 〈 w , v 〉 ∧ ps ) } ;;
	step 14 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 u , z 〉 | ∃ x ∃ y ( u = 〈 x , y 〉 ∧ ph ) } ;;
	step 15 : wff = dfoprab2 () |- { 〈 〈 w , v 〉 , z 〉 | ps } = { 〈 u , z 〉 | ∃ w ∃ v ( u = 〈 w , v 〉 ∧ ps ) } ;;
	step 16 : wff = 3eqtr4i (step 13, step 14, step 15) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 w , v 〉 , z 〉 | ps } ;;
	qed prop 1 = step 16 ;;
}

/* Rule used to change first two bound variables in an operation
       abstraction, using implicit substitution.  (Contributed by NM,
       8-Oct-2004.) */

theorem cbvoprab12v (ph : wff, ps : wff, x : set, y : set, z : set, w : set, v : set) disjointed(x y z w v, w v ph, x y ps) {
	hyp 1 : wff = |- ( ( x = w ∧ y = v ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 w , v 〉 , z 〉 | ps } ;;
}

proof of cbvoprab12v {
	step 1 : wff = nfv () |- F/ w ph ;;
	step 2 : wff = nfv () |- F/ v ph ;;
	step 3 : wff = nfv () |- F/ x ps ;;
	step 4 : wff = nfv () |- F/ y ps ;;
	step 5 : wff = cbvoprab12 (step 1, step 2, step 3, step 4, hyp 1) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 w , v 〉 , z 〉 | ps } ;;
	qed prop 1 = step 5 ;;
}

/* Rule used to change the third bound variable in an operation
       abstraction, using implicit substitution.  (Contributed by NM,
       22-Aug-2013.) */

theorem cbvoprab3 (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(x z w v, y z w v, v ph, v ps) {
	hyp 1 : wff = |- F/ w ph ;;
	hyp 2 : wff = |- F/ z ps ;;
	hyp 3 : wff = |- ( z = w → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , w 〉 | ps } ;;
}

proof of cbvoprab3 {
	var v : set;;
	step 1 : wff = nfv () |- F/ w v = 〈 x , y 〉 ;;
	step 2 : wff = nfan (step 1, hyp 1) |- F/ w ( v = 〈 x , y 〉 ∧ ph ) ;;
	step 3 : wff = nfex (step 2) |- F/ w ∃ y ( v = 〈 x , y 〉 ∧ ph ) ;;
	step 4 : wff = nfex (step 3) |- F/ w ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) ;;
	step 5 : wff = nfv () |- F/ z v = 〈 x , y 〉 ;;
	step 6 : wff = nfan (step 5, hyp 2) |- F/ z ( v = 〈 x , y 〉 ∧ ps ) ;;
	step 7 : wff = nfex (step 6) |- F/ z ∃ y ( v = 〈 x , y 〉 ∧ ps ) ;;
	step 8 : wff = nfex (step 7) |- F/ z ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ps ) ;;
	step 9 : wff = anbi2d (hyp 3) |- ( z = w → ( ( v = 〈 x , y 〉 ∧ ph ) ↔ ( v = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 10 : wff = 2exbidv (step 9) |- ( z = w → ( ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 11 : wff = cbvopab2 (step 4, step 8, step 10) |- { 〈 v , z 〉 | ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) } = { 〈 v , w 〉 | ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ps ) } ;;
	step 12 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 v , z 〉 | ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ph ) } ;;
	step 13 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , w 〉 | ps } = { 〈 v , w 〉 | ∃ x ∃ y ( v = 〈 x , y 〉 ∧ ps ) } ;;
	step 14 : wff = 3eqtr4i (step 11, step 12, step 13) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , w 〉 | ps } ;;
	qed prop 1 = step 14 ;;
}

/* Rule used to change the third bound variable in an operation
       abstraction, using implicit substitution.  (Contributed by NM,
       8-Oct-2004.)  (Revised by David Abernethy, 19-Jun-2012.) */

theorem cbvoprab3v (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(x z w, y z w, w ph, z ps) {
	hyp 1 : wff = |- ( z = w → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , w 〉 | ps } ;;
}

proof of cbvoprab3v {
	step 1 : wff = nfv () |- F/ w ph ;;
	step 2 : wff = nfv () |- F/ z ps ;;
	step 3 : wff = cbvoprab3 (step 1, step 2, hyp 1) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 x , y 〉 , w 〉 | ps } ;;
	qed prop 1 = step 3 ;;
}

/* Rule to change the bound variable in a maps-to function, using implicit
       substitution.  This version of ~ cbvmpt2 allows ` B ` to be a function
       of ` x ` .  (Contributed by NM, 29-Dec-2014.) */

theorem cbvmpt2x (x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class, E : class) disjointed(u w x y z, u w x y z A, u w B, u C, u y D, u E) {
	hyp 1 : wff = |- F/_ z B ;;
	hyp 2 : wff = |- F/_ x D ;;
	hyp 3 : wff = |- F/_ z C ;;
	hyp 4 : wff = |- F/_ w C ;;
	hyp 5 : wff = |- F/_ x E ;;
	hyp 6 : wff = |- F/_ y E ;;
	hyp 7 : wff = |- ( x = z → B = D ) ;;
	hyp 8 : wff = |- ( ( x = z ∧ y = w ) → C = E ) ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ D ↦ E ) ;;
}

proof of cbvmpt2x {
	var u : set;;
	step 1 : wff = nfv () |- F/ z x ∈ A ;;
	step 2 : wff = nfcri (hyp 1) |- F/ z y ∈ B ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ z ( x ∈ A ∧ y ∈ B ) ;;
	step 4 : wff = nfeq2 (hyp 3) |- F/ z u = C ;;
	step 5 : wff = nfan (step 3, step 4) |- F/ z ( ( x ∈ A ∧ y ∈ B ) ∧ u = C ) ;;
	step 6 : wff = nfv () |- F/ w x ∈ A ;;
	step 7 : wff = nfcv () |- F/_ w B ;;
	step 8 : wff = nfcri (step 7) |- F/ w y ∈ B ;;
	step 9 : wff = nfan (step 6, step 8) |- F/ w ( x ∈ A ∧ y ∈ B ) ;;
	step 10 : wff = nfeq2 (hyp 4) |- F/ w u = C ;;
	step 11 : wff = nfan (step 9, step 10) |- F/ w ( ( x ∈ A ∧ y ∈ B ) ∧ u = C ) ;;
	step 12 : wff = nfv () |- F/ x z ∈ A ;;
	step 13 : wff = nfcri (hyp 2) |- F/ x w ∈ D ;;
	step 14 : wff = nfan (step 12, step 13) |- F/ x ( z ∈ A ∧ w ∈ D ) ;;
	step 15 : wff = nfeq2 (hyp 5) |- F/ x u = E ;;
	step 16 : wff = nfan (step 14, step 15) |- F/ x ( ( z ∈ A ∧ w ∈ D ) ∧ u = E ) ;;
	step 17 : wff = nfv () |- F/ y ( z ∈ A ∧ w ∈ D ) ;;
	step 18 : wff = nfeq2 (hyp 6) |- F/ y u = E ;;
	step 19 : wff = nfan (step 17, step 18) |- F/ y ( ( z ∈ A ∧ w ∈ D ) ∧ u = E ) ;;
	step 20 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 21 : wff = adantr (step 20) |- ( ( x = z ∧ y = w ) → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 22 : wff = eleq2d (hyp 7) |- ( x = z → ( y ∈ B ↔ y ∈ D ) ) ;;
	step 23 : wff = eleq1 () |- ( y = w → ( y ∈ D ↔ w ∈ D ) ) ;;
	step 24 : wff = sylan9bb (step 22, step 23) |- ( ( x = z ∧ y = w ) → ( y ∈ B ↔ w ∈ D ) ) ;;
	step 25 : wff = anbi12d (step 21, step 24) |- ( ( x = z ∧ y = w ) → ( ( x ∈ A ∧ y ∈ B ) ↔ ( z ∈ A ∧ w ∈ D ) ) ) ;;
	step 26 : wff = eqeq2d (hyp 8) |- ( ( x = z ∧ y = w ) → ( u = C ↔ u = E ) ) ;;
	step 27 : wff = anbi12d (step 25, step 26) |- ( ( x = z ∧ y = w ) → ( ( ( x ∈ A ∧ y ∈ B ) ∧ u = C ) ↔ ( ( z ∈ A ∧ w ∈ D ) ∧ u = E ) ) ) ;;
	step 28 : wff = cbvoprab12 (step 5, step 11, step 16, step 19, step 27) |- { 〈 〈 x , y 〉 , u 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ u = C ) } = { 〈 〈 z , w 〉 , u 〉 | ( ( z ∈ A ∧ w ∈ D ) ∧ u = E ) } ;;
	step 29 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , u 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ u = C ) } ;;
	step 30 : wff = df-mpt2 () |- ( z ∈ A , w ∈ D ↦ E ) = { 〈 〈 z , w 〉 , u 〉 | ( ( z ∈ A ∧ w ∈ D ) ∧ u = E ) } ;;
	step 31 : wff = 3eqtr4i (step 28, step 29, step 30) |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ D ↦ E ) ;;
	qed prop 1 = step 31 ;;
}

/* Rule to change the bound variable in a maps-to function, using implicit
       substitution.  (Contributed by NM, 17-Dec-2013.) */

theorem cbvmpt2 (x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class) disjointed(w x y z A, w x y z B) {
	hyp 1 : wff = |- F/_ z C ;;
	hyp 2 : wff = |- F/_ w C ;;
	hyp 3 : wff = |- F/_ x D ;;
	hyp 4 : wff = |- F/_ y D ;;
	hyp 5 : wff = |- ( ( x = z ∧ y = w ) → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ B ↦ D ) ;;
}

proof of cbvmpt2 {
	step 1 : wff = nfcv () |- F/_ z B ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = eqidd () |- ( x = z → B = B ) ;;
	step 4 : wff = cbvmpt2x (step 1, step 2, hyp 1, hyp 2, hyp 3, hyp 4, step 3, hyp 5) |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ B ↦ D ) ;;
	qed prop 1 = step 4 ;;
}

/* Rule to change the bound variable in a maps-to function, using implicit
       substitution.  With a longer proof analogous to ~ cbvmpt , some distinct
       variable requirements could be eliminated.  (Contributed by NM,
       11-Jun-2013.) */

theorem cbvmpt2v (x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class, E : class) disjointed(w x y z A, w x y z B, w z C, x y D) {
	hyp 1 : wff = |- ( x = z → C = E ) ;;
	hyp 2 : wff = |- ( y = w → E = D ) ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ B ↦ D ) ;;
}

proof of cbvmpt2v {
	step 1 : wff = nfcv () |- F/_ z C ;;
	step 2 : wff = nfcv () |- F/_ w C ;;
	step 3 : wff = nfcv () |- F/_ x D ;;
	step 4 : wff = nfcv () |- F/_ y D ;;
	step 5 : wff = sylan9eq (hyp 1, hyp 2) |- ( ( x = z ∧ y = w ) → C = D ) ;;
	step 6 : wff = cbvmpt2 (step 1, step 2, step 3, step 4, step 5) |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ B ↦ D ) ;;
	qed prop 1 = step 6 ;;
}

/* Eliminate a hypothesis which is a predicate expressing membership in the
       result of an operator (deduction version).  See ~ ghomgrplem for an
       example of its use.  (Contributed by Paul Chapman, 25-Mar-2008.) */

theorem elimdelov (ph : wff, A : class, B : class, C : class, F : class, X : class, Y : class, Z : class)  {
	hyp 1 : wff = |- ( ph → C ∈ ( A F B ) ) ;;
	hyp 2 : wff = |- Z ∈ ( X F Y ) ;;
	-----------------------
	prop 1 : wff = |- if ( ph , C , Z ) ∈ ( if ( ph , A , X ) F if ( ph , B , Y ) ) ;;
}

proof of elimdelov {
	step 1 : wff = iftrue () |- ( ph → if ( ph , C , Z ) = C ) ;;
	step 2 : wff = eqeltrd (step 1, hyp 1) |- ( ph → if ( ph , C , Z ) ∈ ( A F B ) ) ;;
	step 3 : wff = iftrue () |- ( ph → if ( ph , A , X ) = A ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , Y ) = B ) ;;
	step 5 : wff = oveq12d (step 3, step 4) |- ( ph → ( if ( ph , A , X ) F if ( ph , B , Y ) ) = ( A F B ) ) ;;
	step 6 : wff = eleqtrrd (step 2, step 5) |- ( ph → if ( ph , C , Z ) ∈ ( if ( ph , A , X ) F if ( ph , B , Y ) ) ) ;;
	step 7 : wff = iffalse () |- ( ¬ ph → if ( ph , C , Z ) = Z ) ;;
	step 8 : wff = syl6eqel (step 7, hyp 2) |- ( ¬ ph → if ( ph , C , Z ) ∈ ( X F Y ) ) ;;
	step 9 : wff = iffalse () |- ( ¬ ph → if ( ph , A , X ) = X ) ;;
	step 10 : wff = iffalse () |- ( ¬ ph → if ( ph , B , Y ) = Y ) ;;
	step 11 : wff = oveq12d (step 9, step 10) |- ( ¬ ph → ( if ( ph , A , X ) F if ( ph , B , Y ) ) = ( X F Y ) ) ;;
	step 12 : wff = eleqtrrd (step 8, step 11) |- ( ¬ ph → if ( ph , C , Z ) ∈ ( if ( ph , A , X ) F if ( ph , B , Y ) ) ) ;;
	step 13 : wff = pm2.61i (step 6, step 12) |- if ( ph , C , Z ) ∈ ( if ( ph , A , X ) F if ( ph , B , Y ) ) ;;
	qed prop 1 = step 13 ;;
}

/* The domain of an operation class abstraction.  (Contributed by NM,
       17-Mar-1995.)  (Revised by David Abernethy, 19-Jun-2012.) */

theorem dmoprab (ph : wff, x : set, y : set, z : set) disjointed(x z w, y z w, w ph) {
	prop 1 : wff = |- dom { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 x , y 〉 | ∃ z ph } ;;
}

proof of dmoprab {
	var w : set;;
	step 1 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 2 : wff = dmeqi (step 1) |- dom { 〈 〈 x , y 〉 , z 〉 | ph } = dom { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 3 : wff = dmopab () |- dom { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { w | ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 4 : wff = exrot3 () |- ( ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 5 : wff = 19.42v () |- ( ∃ z ( w = 〈 x , y 〉 ∧ ph ) ↔ ( w = 〈 x , y 〉 ∧ ∃ z ph ) ) ;;
	step 6 : wff = 2exbii (step 5) |- ( ∃ x ∃ y ∃ z ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ph ) ) ;;
	step 7 : wff = bitri (step 4, step 6) |- ( ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ph ) ) ;;
	step 8 : wff = abbii (step 7) |- { w | ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { w | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ph ) } ;;
	step 9 : wff = df-opab () |- { 〈 x , y 〉 | ∃ z ph } = { w | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ph ) } ;;
	step 10 : wff = eqtr4i (step 8, step 9) |- { w | ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { 〈 x , y 〉 | ∃ z ph } ;;
	step 11 : wff = 3eqtri (step 2, step 3, step 10) |- dom { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 x , y 〉 | ∃ z ph } ;;
	qed prop 1 = step 11 ;;
}

/* The domain of an operation class abstraction.  (Contributed by NM,
       24-Aug-1995.) */

theorem dmoprabss (ph : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ ( A × B ) ;;
}

proof of dmoprabss {
	step 1 : wff = dmoprab () |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } = { 〈 x , y 〉 | ∃ z ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	step 2 : wff = 19.42v () |- ( ∃ z ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ ∃ z ph ) ) ;;
	step 3 : wff = opabbii (step 2) |- { 〈 x , y 〉 | ∃ z ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ∃ z ph ) } ;;
	step 4 : wff = opabssxp () |- { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ∃ z ph ) } ⊆ ( A × B ) ;;
	step 5 : wff = eqsstri (step 3, step 4) |- { 〈 x , y 〉 | ∃ z ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ ( A × B ) ;;
	step 6 : wff = eqsstri (step 1, step 5) |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ ( A × B ) ;;
	qed prop 1 = step 6 ;;
}

/* The range of an operation class abstraction.  (Contributed by NM,
       30-Aug-2004.)  (Revised by David Abernethy, 19-Apr-2013.) */

theorem rnoprab (ph : wff, x : set, y : set, z : set) disjointed(x z w, y z w, w ph) {
	prop 1 : wff = |- ran { 〈 〈 x , y 〉 , z 〉 | ph } = { z | ∃ x ∃ y ph } ;;
}

proof of rnoprab {
	var w : set;;
	step 1 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 2 : wff = rneqi (step 1) |- ran { 〈 〈 x , y 〉 , z 〉 | ph } = ran { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 3 : wff = rnopab () |- ran { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { z | ∃ w ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 4 : wff = exrot3 () |- ( ∃ w ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ w ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 5 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 6 : wff = isseti (step 5) |- ∃ w w = 〈 x , y 〉 ;;
	step 7 : wff = 19.41v () |- ( ∃ w ( w = 〈 x , y 〉 ∧ ph ) ↔ ( ∃ w w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 8 : wff = mpbiran (step 6, step 7) |- ( ∃ w ( w = 〈 x , y 〉 ∧ ph ) ↔ ph ) ;;
	step 9 : wff = 2exbii (step 8) |- ( ∃ x ∃ y ∃ w ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ph ) ;;
	step 10 : wff = bitri (step 4, step 9) |- ( ∃ w ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ph ) ;;
	step 11 : wff = abbii (step 10) |- { z | ∃ w ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { z | ∃ x ∃ y ph } ;;
	step 12 : wff = 3eqtri (step 2, step 3, step 11) |- ran { 〈 〈 x , y 〉 , z 〉 | ph } = { z | ∃ x ∃ y ph } ;;
	qed prop 1 = step 12 ;;
}

/* The range of a restricted operation class abstraction.  (Contributed by
       Scott Fenton, 21-Mar-2012.) */

theorem rnoprab2 (ph : wff, x : set, y : set, z : set, A : class, B : class) disjointed(A y, x y z) {
	prop 1 : wff = |- ran { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } = { z | ∃ x ∈ A ∃ y ∈ B ph } ;;
}

proof of rnoprab2 {
	step 1 : wff = rnoprab () |- ran { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } = { z | ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	step 2 : wff = r2ex () |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
	step 3 : wff = abbii (step 2) |- { z | ∃ x ∈ A ∃ y ∈ B ph } = { z | ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	step 4 : wff = eqtr4i (step 1, step 3) |- ran { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } = { z | ∃ x ∈ A ∃ y ∈ B ph } ;;
	qed prop 1 = step 4 ;;
}

/* The domain of an operation class abstraction is a relation.
       (Contributed by NM, 17-Mar-1995.) */

theorem reldmoprab (ph : wff, x : set, y : set, z : set) disjointed(x y z) {
	prop 1 : wff = |- Rel dom { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of reldmoprab {
	step 1 : wff = dmoprab () |- dom { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 x , y 〉 | ∃ z ph } ;;
	step 2 : wff = relopabi (step 1) |- Rel dom { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 2 ;;
}

/* Structure of an operation class abstraction.  (Contributed by NM,
       28-Nov-2006.) */

theorem oprabss (ph : wff, x : set, y : set, z : set) disjointed(x y z) {
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( ( _V × _V ) × _V ) ;;
}

proof of oprabss {
	step 1 : wff = reloprab () |- Rel { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 2 : wff = relssdmrn () |- ( Rel { 〈 〈 x , y 〉 , z 〉 | ph } → { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( dom { 〈 〈 x , y 〉 , z 〉 | ph } × ran { 〈 〈 x , y 〉 , z 〉 | ph } ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( dom { 〈 〈 x , y 〉 , z 〉 | ph } × ran { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 4 : wff = reldmoprab () |- Rel dom { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 5 : wff = df-rel () |- ( Rel dom { 〈 〈 x , y 〉 , z 〉 | ph } ↔ dom { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( _V × _V ) ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- dom { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( _V × _V ) ;;
	step 7 : wff = ssv () |- ran { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ _V ;;
	step 8 : wff = xpss12 () |- ( ( dom { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( _V × _V ) ∧ ran { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ _V ) → ( dom { 〈 〈 x , y 〉 , z 〉 | ph } × ran { 〈 〈 x , y 〉 , z 〉 | ph } ) ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 9 : wff = mp2an (step 6, step 7, step 8) |- ( dom { 〈 〈 x , y 〉 , z 〉 | ph } × ran { 〈 〈 x , y 〉 , z 〉 | ph } ) ⊆ ( ( _V × _V ) × _V ) ;;
	step 10 : wff = sstri (step 3, step 9) |- { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ ( ( _V × _V ) × _V ) ;;
	qed prop 1 = step 10 ;;
}

/* The law of concretion for operation class abstraction.  Compare
       ~ elopab .  (Contributed by NM, 14-Sep-1999.)  (Unnecessary distinct
       variable restrictions were removed by David Abernethy, 19-Jun-2012.)
       (Revised by Mario Carneiro, 19-Dec-2013.) */

theorem eloprabga (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, V : class, W : class, X : class) disjointed(x y z w A, x y z w B, x y z w C, w ph, x y z w ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ps ) ) ;;
}

proof of eloprabga {
	var w : set;;
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = elex () |- ( B ∈ W → B ∈ _V ) ;;
	step 3 : wff = elex () |- ( C ∈ X → C ∈ _V ) ;;
	step 4 : wff = opex () |- 〈 〈 A , B 〉 , C 〉 ∈ _V ;;
	step 5 : wff = simpr () |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → w = 〈 〈 A , B 〉 , C 〉 ) ;;
	step 6 : wff = eqeq1d (step 5) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( w = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 A , B 〉 , C 〉 = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 7 : wff = eqcom () |- ( 〈 〈 A , B 〉 , C 〉 = 〈 〈 x , y 〉 , z 〉 ↔ 〈 〈 x , y 〉 , z 〉 = 〈 〈 A , B 〉 , C 〉 ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = vex () |- z ∈ _V ;;
	step 11 : wff = otth2 (step 8, step 9, step 10) |- ( 〈 〈 x , y 〉 , z 〉 = 〈 〈 A , B 〉 , C 〉 ↔ ( x = A ∧ y = B ∧ z = C ) ) ;;
	step 12 : wff = bitri (step 7, step 11) |- ( 〈 〈 A , B 〉 , C 〉 = 〈 〈 x , y 〉 , z 〉 ↔ ( x = A ∧ y = B ∧ z = C ) ) ;;
	step 13 : wff = syl6bb (step 6, step 12) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( w = 〈 〈 x , y 〉 , z 〉 ↔ ( x = A ∧ y = B ∧ z = C ) ) ) ;;
	step 14 : wff = anbi1d (step 13) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ) ) ;;
	step 15 : wff = pm5.32i (hyp 1) |- ( ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ ( ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ) ;;
	step 16 : wff = syl6bb (step 14, step 15) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ( ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ) ) ;;
	step 17 : wff = 3exbidv (step 16) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ) ) ;;
	step 18 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 19 : wff = eleq2i (step 18) |- ( w ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ w ∈ { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ) ;;
	step 20 : wff = abid () |- ( w ∈ { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ↔ ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 21 : wff = bitr2i (step 19, step 20) |- ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ w ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 22 : wff = eleq1 () |- ( w = 〈 〈 A , B 〉 , C 〉 → ( w ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ) ) ;;
	step 23 : wff = syl5bb (step 21, step 22) |- ( w = 〈 〈 A , B 〉 , C 〉 → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ) ) ;;
	step 24 : wff = adantl (step 23) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ) ) ;;
	step 25 : wff = elisset () |- ( A ∈ _V → ∃ x x = A ) ;;
	step 26 : wff = elisset () |- ( B ∈ _V → ∃ y y = B ) ;;
	step 27 : wff = elisset () |- ( C ∈ _V → ∃ z z = C ) ;;
	step 28 : wff = 3anim123i (step 25, step 26, step 27) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( ∃ x x = A ∧ ∃ y y = B ∧ ∃ z z = C ) ) ;;
	step 29 : wff = eeeanv () |- ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ↔ ( ∃ x x = A ∧ ∃ y y = B ∧ ∃ z z = C ) ) ;;
	step 30 : wff = sylibr (step 28, step 29) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ) ;;
	step 31 : wff = biantrurd (step 30) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( ps ↔ ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ) ) ;;
	step 32 : wff = 19.41vvv () |- ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ↔ ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ) ;;
	step 33 : wff = syl6rbbr (step 31, step 32) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ↔ ps ) ) ;;
	step 34 : wff = adantr (step 33) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ps ) ↔ ps ) ) ;;
	step 35 : wff = 3bitr3d (step 17, step 24, step 34) |- ( ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ∧ w = 〈 〈 A , B 〉 , C 〉 ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ps ) ) ;;
	step 36 : wff = expcom (step 35) |- ( w = 〈 〈 A , B 〉 , C 〉 → ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ps ) ) ) ;;
	step 37 : wff = vtocle (step 4, step 36) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ps ) ) ;;
	step 38 : wff = syl3an (step 1, step 2, step 3, step 37) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ps ) ) ;;
	qed prop 1 = step 38 ;;
}

/* The law of concretion for operation class abstraction.  Compare
       ~ elopab .  (Contributed by NM, 14-Sep-1999.)  (Revised by David
       Abernethy, 19-Jun-2012.) */

theorem eloprabg (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, V : class, W : class, X : class) disjointed(x y z A, x y z B, x y z C, x y z th) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ th ) ) ;;
}

proof of eloprabg {
	step 1 : wff = syl3an9b (hyp 1, hyp 2, hyp 3) |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ th ) ) ;;
	step 2 : wff = eloprabga (step 1) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference of operation class abstraction subclass from implication.
       (Contributed by NM, 11-Nov-1995.)  (Revised by David Abernethy,
       19-Jun-2012.) */

theorem ssoprab2i (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(ph w, ps w, x z w, y z w) {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ;;
}

proof of ssoprab2i {
	var w : set;;
	step 1 : wff = anim2i (hyp 1) |- ( ( w = 〈 x , y 〉 ∧ ph ) → ( w = 〈 x , y 〉 ∧ ps ) ) ;;
	step 2 : wff = 2eximi (step 1) |- ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) → ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ps ) ) ;;
	step 3 : wff = ssopab2i (step 2) |- { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ⊆ { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ps ) } ;;
	step 4 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 5 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ps } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ps ) } ;;
	step 6 : wff = 3sstr4i (step 3, step 4, step 5) |- { 〈 〈 x , y 〉 , z 〉 | ph } ⊆ { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	qed prop 1 = step 6 ;;
}

/* Operation with universal domain in maps-to notation.  (Contributed by
       NM, 16-Aug-2013.) */

theorem mpt2v (x : set, y : set, z : set, C : class) disjointed(x z, y z, z C) {
	prop 1 : wff = |- ( x ∈ _V , y ∈ _V ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | z = C } ;;
}

proof of mpt2v {
	step 1 : wff = df-mpt2 () |- ( x ∈ _V , y ∈ _V ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ _V ∧ y ∈ _V ) ∧ z = C ) } ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = pm3.2i (step 2, step 3) |- ( x ∈ _V ∧ y ∈ _V ) ;;
	step 5 : wff = biantrur (step 4) |- ( z = C ↔ ( ( x ∈ _V ∧ y ∈ _V ) ∧ z = C ) ) ;;
	step 6 : wff = oprabbii (step 5) |- { 〈 〈 x , y 〉 , z 〉 | z = C } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ _V ∧ y ∈ _V ) ∧ z = C ) } ;;
	step 7 : wff = eqtr4i (step 1, step 6) |- ( x ∈ _V , y ∈ _V ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | z = C } ;;
	qed prop 1 = step 7 ;;
}

/* Express a two-argument function as a one-argument function, or
       vice-versa.  In this version ` B ( x ) ` is not assumed to be constant
       w.r.t ` x ` .  (Contributed by Mario Carneiro, 29-Dec-2014.) */

theorem mpt2mptx (x : set, y : set, z : set, A : class, B : class, C : class, D : class) disjointed(w x y z A, w y z B, w x y C, w z D) {
	hyp 1 : wff = |- ( z = 〈 x , y 〉 → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
}

proof of mpt2mptx {
	var w : set;;
	step 1 : wff = df-mpt () |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ C ) = { 〈 z , w 〉 | ( z ∈ ⋃_ x ∈ A ( { x } × B ) ∧ w = C ) } ;;
	step 2 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ D ) = { 〈 〈 x , y 〉 , w 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) } ;;
	step 3 : wff = eliunxp () |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( z ∈ ⋃_ x ∈ A ( { x } × B ) ∧ w = C ) ↔ ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ w = C ) ) ;;
	step 5 : wff = 19.41vv () |- ( ∃ x ∃ y ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ w = C ) ↔ ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ w = C ) ) ;;
	step 6 : wff = anass () |- ( ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ w = C ) ↔ ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ) ) ;;
	step 7 : wff = eqeq2d (hyp 1) |- ( z = 〈 x , y 〉 → ( w = C ↔ w = D ) ) ;;
	step 8 : wff = anbi2d (step 7) |- ( z = 〈 x , y 〉 → ( ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ) ↔ ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) ) ;;
	step 10 : wff = bitri (step 6, step 9) |- ( ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ w = C ) ↔ ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) ) ;;
	step 11 : wff = 2exbii (step 10) |- ( ∃ x ∃ y ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ w = C ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) ) ;;
	step 12 : wff = 3bitr2i (step 4, step 5, step 11) |- ( ( z ∈ ⋃_ x ∈ A ( { x } × B ) ∧ w = C ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) ) ;;
	step 13 : wff = opabbii (step 12) |- { 〈 z , w 〉 | ( z ∈ ⋃_ x ∈ A ( { x } × B ) ∧ w = C ) } = { 〈 z , w 〉 | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) } ;;
	step 14 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , w 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) } = { 〈 z , w 〉 | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) ) } ;;
	step 15 : wff = eqtr4i (step 13, step 14) |- { 〈 z , w 〉 | ( z ∈ ⋃_ x ∈ A ( { x } × B ) ∧ w = C ) } = { 〈 〈 x , y 〉 , w 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ w = D ) } ;;
	step 16 : wff = eqtr4i (step 2, step 15) |- ( x ∈ A , y ∈ B ↦ D ) = { 〈 z , w 〉 | ( z ∈ ⋃_ x ∈ A ( { x } × B ) ∧ w = C ) } ;;
	step 17 : wff = eqtr4i (step 1, step 16) |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
	qed prop 1 = step 17 ;;
}

/* Express a two-argument function as a one-argument function, or
       vice-versa.  (Contributed by Mario Carneiro, 17-Dec-2013.)  (Revised by
       Mario Carneiro, 29-Dec-2014.) */

theorem mpt2mpt (x : set, y : set, z : set, A : class, B : class, C : class, D : class) disjointed(x y z A, y z B, x y C, z D, x B) {
	hyp 1 : wff = |- ( z = 〈 x , y 〉 → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( z ∈ ( A × B ) ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
}

proof of mpt2mpt {
	step 1 : wff = iunxpconst () |- ⋃_ x ∈ A ( { x } × B ) = ( A × B ) ;;
	step 2 : wff = mpteq1 () |- ( ⋃_ x ∈ A ( { x } × B ) = ( A × B ) → ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ C ) = ( z ∈ ( A × B ) ↦ C ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ C ) = ( z ∈ ( A × B ) ↦ C ) ;;
	step 4 : wff = mpt2mptx (hyp 1) |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
	step 5 : wff = eqtr3i (step 3, step 4) |- ( z ∈ ( A × B ) ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ;;
	qed prop 1 = step 5 ;;
}

/* Restriction of an operation class abstraction.  (Contributed by NM,
       10-Feb-2007.) */

theorem resoprab (ph : wff, x : set, y : set, z : set, A : class, B : class) disjointed(w x y z A, w x y z B, w ph) {
	prop 1 : wff = |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ↾ ( A × B ) ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
}

proof of resoprab {
	var w : set;;
	step 1 : wff = resopab () |- ( { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ↾ ( A × B ) ) = { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) } ;;
	step 2 : wff = 19.42vv () |- ( ∃ x ∃ y ( w ∈ ( A × B ) ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ( w ∈ ( A × B ) ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 3 : wff = an12 () |- ( ( w ∈ ( A × B ) ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ( w = 〈 x , y 〉 ∧ ( w ∈ ( A × B ) ∧ ph ) ) ) ;;
	step 4 : wff = eleq1 () |- ( w = 〈 x , y 〉 → ( w ∈ ( A × B ) ↔ 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 5 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 6 : wff = syl6bb (step 4, step 5) |- ( w = 〈 x , y 〉 → ( w ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 7 : wff = anbi1d (step 6) |- ( w = 〈 x , y 〉 → ( ( w ∈ ( A × B ) ∧ ph ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ) ;;
	step 8 : wff = pm5.32i (step 7) |- ( ( w = 〈 x , y 〉 ∧ ( w ∈ ( A × B ) ∧ ph ) ) ↔ ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ) ;;
	step 9 : wff = bitri (step 3, step 8) |- ( ( w ∈ ( A × B ) ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ) ;;
	step 10 : wff = 2exbii (step 9) |- ( ∃ x ∃ y ( w ∈ ( A × B ) ∧ ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ) ;;
	step 11 : wff = bitr3i (step 2, step 10) |- ( ( w ∈ ( A × B ) ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ) ;;
	step 12 : wff = opabbii (step 11) |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) } ;;
	step 13 : wff = eqtri (step 1, step 12) |- ( { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ↾ ( A × B ) ) = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) } ;;
	step 14 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 15 : wff = reseq1i (step 14) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ↾ ( A × B ) ) = ( { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ↾ ( A × B ) ) ;;
	step 16 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) } ;;
	step 17 : wff = 3eqtr4i (step 13, step 15, step 16) |- ( { 〈 〈 x , y 〉 , z 〉 | ph } ↾ ( A × B ) ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	qed prop 1 = step 17 ;;
}

/* Restriction of an operator abstraction.  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem resoprab2 (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class) disjointed(A x y z, B x y z, C x y z, D x y z) {
	prop 1 : wff = |- ( ( C ⊆ A ∧ D ⊆ B ) → ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ↾ ( C × D ) ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
}

proof of resoprab2 {
	step 1 : wff = resoprab () |- ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ↾ ( C × D ) ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) } ;;
	step 2 : wff = anass () |- ( ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ ph ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ) ;;
	step 3 : wff = an4 () |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( x ∈ A ∧ y ∈ B ) ) ↔ ( ( x ∈ C ∧ x ∈ A ) ∧ ( y ∈ D ∧ y ∈ B ) ) ) ;;
	step 4 : wff = ssel () |- ( C ⊆ A → ( x ∈ C → x ∈ A ) ) ;;
	step 5 : wff = pm4.71d (step 4) |- ( C ⊆ A → ( x ∈ C ↔ ( x ∈ C ∧ x ∈ A ) ) ) ;;
	step 6 : wff = bicomd (step 5) |- ( C ⊆ A → ( ( x ∈ C ∧ x ∈ A ) ↔ x ∈ C ) ) ;;
	step 7 : wff = ssel () |- ( D ⊆ B → ( y ∈ D → y ∈ B ) ) ;;
	step 8 : wff = pm4.71d (step 7) |- ( D ⊆ B → ( y ∈ D ↔ ( y ∈ D ∧ y ∈ B ) ) ) ;;
	step 9 : wff = bicomd (step 8) |- ( D ⊆ B → ( ( y ∈ D ∧ y ∈ B ) ↔ y ∈ D ) ) ;;
	step 10 : wff = bi2anan9 (step 6, step 9) |- ( ( C ⊆ A ∧ D ⊆ B ) → ( ( ( x ∈ C ∧ x ∈ A ) ∧ ( y ∈ D ∧ y ∈ B ) ) ↔ ( x ∈ C ∧ y ∈ D ) ) ) ;;
	step 11 : wff = syl5bb (step 3, step 10) |- ( ( C ⊆ A ∧ D ⊆ B ) → ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( x ∈ A ∧ y ∈ B ) ) ↔ ( x ∈ C ∧ y ∈ D ) ) ) ;;
	step 12 : wff = anbi1d (step 11) |- ( ( C ⊆ A ∧ D ⊆ B ) → ( ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ ph ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) ) ) ;;
	step 13 : wff = syl5bbr (step 2, step 12) |- ( ( C ⊆ A ∧ D ⊆ B ) → ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) ) ) ;;
	step 14 : wff = oprabbidv (step 13) |- ( ( C ⊆ A ∧ D ⊆ B ) → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
	step 15 : wff = syl5eq (step 1, step 14) |- ( ( C ⊆ A ∧ D ⊆ B ) → ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ↾ ( C × D ) ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
	qed prop 1 = step 15 ;;
}

/* Restriction of the mapping operation.  (Contributed by Mario Carneiro,
       17-Dec-2013.) */

theorem resmpt2 (x : set, y : set, A : class, B : class, C : class, D : class, E : class) disjointed(A x y z, B x y z, C x y z, D x y z, E z) {
	prop 1 : wff = |- ( ( C ⊆ A ∧ D ⊆ B ) → ( ( x ∈ A , y ∈ B ↦ E ) ↾ ( C × D ) ) = ( x ∈ C , y ∈ D ↦ E ) ) ;;
}

proof of resmpt2 {
	var z : set;;
	step 1 : wff = resoprab2 () |- ( ( C ⊆ A ∧ D ⊆ B ) → ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = E ) } ↾ ( C × D ) ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ z = E ) } ) ;;
	step 2 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ E ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = E ) } ;;
	step 3 : wff = reseq1i (step 2) |- ( ( x ∈ A , y ∈ B ↦ E ) ↾ ( C × D ) ) = ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = E ) } ↾ ( C × D ) ) ;;
	step 4 : wff = df-mpt2 () |- ( x ∈ C , y ∈ D ↦ E ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ z = E ) } ;;
	step 5 : wff = 3eqtr4g (step 1, step 3, step 4) |- ( ( C ⊆ A ∧ D ⊆ B ) → ( ( x ∈ A , y ∈ B ↦ E ) ↾ ( C × D ) ) = ( x ∈ C , y ∈ D ↦ E ) ) ;;
	qed prop 1 = step 5 ;;
}

/* "At most one" is a sufficient condition for an operation class
       abstraction to be a function.  (Contributed by NM, 28-Aug-2007.) */

theorem funoprabg (ph : wff, x : set, y : set, z : set) disjointed(x y z w, w ph) {
	prop 1 : wff = |- ( ∀ x ∀ y ∃* z ph → Fun { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
}

proof of funoprabg {
	var w : set;;
	step 1 : wff = mosubopt () |- ( ∀ x ∀ y ∃* z ph → ∃* z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 2 : wff = alrimiv (step 1) |- ( ∀ x ∀ y ∃* z ph → ∀ w ∃* z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 3 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 4 : wff = funeqi (step 3) |- ( Fun { 〈 〈 x , y 〉 , z 〉 | ph } ↔ Fun { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ) ;;
	step 5 : wff = funopab () |- ( Fun { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ↔ ∀ w ∃* z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 6 : wff = bitr2i (step 4, step 5) |- ( ∀ w ∃* z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ Fun { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 7 : wff = sylib (step 2, step 6) |- ( ∀ x ∀ y ∃* z ph → Fun { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	qed prop 1 = step 7 ;;
}

/* "At most one" is a sufficient condition for an operation class
       abstraction to be a function.  (Contributed by NM, 17-Mar-1995.) */

theorem funoprab (ph : wff, x : set, y : set, z : set) disjointed(x y z) {
	hyp 1 : wff = |- ∃* z ph ;;
	-----------------------
	prop 1 : wff = |- Fun { 〈 〈 x , y 〉 , z 〉 | ph } ;;
}

proof of funoprab {
	step 1 : wff = gen2 (hyp 1) |- ∀ x ∀ y ∃* z ph ;;
	step 2 : wff = funoprabg () |- ( ∀ x ∀ y ∃* z ph → Fun { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- Fun { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	qed prop 1 = step 3 ;;
}

/* Functionality and domain of an operation class abstraction.
       (Contributed by NM, 28-Aug-2007.) */

theorem fnoprabg (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x y z, z ph) {
	prop 1 : wff = |- ( ∀ x ∀ y ( ph → ∃! z ps ) → { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } Fn { 〈 x , y 〉 | ph } ) ;;
}

proof of fnoprabg {
	step 1 : wff = eumo () |- ( ∃! z ps → ∃* z ps ) ;;
	step 2 : wff = imim2i (step 1) |- ( ( ph → ∃! z ps ) → ( ph → ∃* z ps ) ) ;;
	step 3 : wff = moanimv () |- ( ∃* z ( ph ∧ ps ) ↔ ( ph → ∃* z ps ) ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( ( ph → ∃! z ps ) → ∃* z ( ph ∧ ps ) ) ;;
	step 5 : wff = 2alimi (step 4) |- ( ∀ x ∀ y ( ph → ∃! z ps ) → ∀ x ∀ y ∃* z ( ph ∧ ps ) ) ;;
	step 6 : wff = funoprabg () |- ( ∀ x ∀ y ∃* z ( ph ∧ ps ) → Fun { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ∀ x ∀ y ( ph → ∃! z ps ) → Fun { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } ) ;;
	step 8 : wff = dmoprab () |- dom { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } = { 〈 x , y 〉 | ∃ z ( ph ∧ ps ) } ;;
	step 9 : wff = nfa1 () |- F/ x ∀ x ∀ y ( ph → ∃! z ps ) ;;
	step 10 : wff = nfa2 () |- F/ y ∀ x ∀ y ( ph → ∃! z ps ) ;;
	step 11 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 12 : wff = exlimiv (step 11) |- ( ∃ z ( ph ∧ ps ) → ph ) ;;
	step 13 : wff = euex () |- ( ∃! z ps → ∃ z ps ) ;;
	step 14 : wff = imim2i (step 13) |- ( ( ph → ∃! z ps ) → ( ph → ∃ z ps ) ) ;;
	step 15 : wff = ancld (step 14) |- ( ( ph → ∃! z ps ) → ( ph → ( ph ∧ ∃ z ps ) ) ) ;;
	step 16 : wff = 19.42v () |- ( ∃ z ( ph ∧ ps ) ↔ ( ph ∧ ∃ z ps ) ) ;;
	step 17 : wff = syl6ibr (step 15, step 16) |- ( ( ph → ∃! z ps ) → ( ph → ∃ z ( ph ∧ ps ) ) ) ;;
	step 18 : wff = impbid2 (step 12, step 17) |- ( ( ph → ∃! z ps ) → ( ∃ z ( ph ∧ ps ) ↔ ph ) ) ;;
	step 19 : wff = sps (step 18) |- ( ∀ y ( ph → ∃! z ps ) → ( ∃ z ( ph ∧ ps ) ↔ ph ) ) ;;
	step 20 : wff = sps (step 19) |- ( ∀ x ∀ y ( ph → ∃! z ps ) → ( ∃ z ( ph ∧ ps ) ↔ ph ) ) ;;
	step 21 : wff = opabbid (step 9, step 10, step 20) |- ( ∀ x ∀ y ( ph → ∃! z ps ) → { 〈 x , y 〉 | ∃ z ( ph ∧ ps ) } = { 〈 x , y 〉 | ph } ) ;;
	step 22 : wff = syl5eq (step 8, step 21) |- ( ∀ x ∀ y ( ph → ∃! z ps ) → dom { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } = { 〈 x , y 〉 | ph } ) ;;
	step 23 : wff = df-fn () |- ( { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } Fn { 〈 x , y 〉 | ph } ↔ ( Fun { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } ∧ dom { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } = { 〈 x , y 〉 | ph } ) ) ;;
	step 24 : wff = sylanbrc (step 7, step 22, step 23) |- ( ∀ x ∀ y ( ph → ∃! z ps ) → { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } Fn { 〈 x , y 〉 | ph } ) ;;
	qed prop 1 = step 24 ;;
}

/* The maps-to notation for an operation is always a function.
       (Contributed by Scott Fenton, 21-Mar-2012.) */

theorem mpt2fun (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(A w z, B w z, C w z, x y w z) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- Fun F ;;
}

proof of mpt2fun {
	var z : set, w : set;;
	step 1 : wff = eqtr3 () |- ( ( z = C ∧ w = C ) → z = w ) ;;
	step 2 : wff = ad2ant2l (step 1) |- ( ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ) → z = w ) ;;
	step 3 : wff = gen2 (step 2) |- ∀ z ∀ w ( ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ) → z = w ) ;;
	step 4 : wff = eqeq1 () |- ( z = w → ( z = C ↔ w = C ) ) ;;
	step 5 : wff = anbi2d (step 4) |- ( z = w → ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ) ) ;;
	step 6 : wff = mo4 (step 5) |- ( ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ∀ z ∀ w ( ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ∧ ( ( x ∈ A ∧ y ∈ B ) ∧ w = C ) ) → z = w ) ) ;;
	step 7 : wff = mpbir (step 3, step 6) |- ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ;;
	step 8 : wff = funoprab (step 7) |- Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 9 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 10 : wff = eqtri (hyp 1, step 9) |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 11 : wff = funeqi (step 10) |- ( Fun F ↔ Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ) ;;
	step 12 : wff = mpbir (step 8, step 11) |- Fun F ;;
	qed prop 1 = step 12 ;;
}

/* Functionality and domain of an operation class abstraction.
       (Contributed by NM, 15-May-1995.) */

theorem fnoprab (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x y z, z ph) {
	hyp 1 : wff = |- ( ph → ∃! z ps ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } Fn { 〈 x , y 〉 | ph } ;;
}

proof of fnoprab {
	step 1 : wff = gen2 (hyp 1) |- ∀ x ∀ y ( ph → ∃! z ps ) ;;
	step 2 : wff = fnoprabg () |- ( ∀ x ∀ y ( ph → ∃! z ps ) → { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } Fn { 〈 x , y 〉 | ph } ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- { 〈 〈 x , y 〉 , z 〉 | ( ph ∧ ps ) } Fn { 〈 x , y 〉 | ph } ;;
	qed prop 1 = step 3 ;;
}

/* An operation maps to a class to which all values belong.  (Contributed
       by NM, 7-Feb-2004.) */

theorem ffnov (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(x y w A, x y w B, x y w C, x y w F) {
	prop 1 : wff = |- ( F : ( A × B ) ⟶ C ↔ ( F Fn ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ) ;;
}

proof of ffnov {
	var w : set;;
	step 1 : wff = ffnfv () |- ( F : ( A × B ) ⟶ C ↔ ( F Fn ( A × B ) ∧ ∀ w ∈ ( A × B ) ( F ` w ) ∈ C ) ) ;;
	step 2 : wff = fveq2 () |- ( w = 〈 x , y 〉 → ( F ` w ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( w = 〈 x , y 〉 → ( F ` w ) = ( x F y ) ) ;;
	step 5 : wff = eleq1d (step 4) |- ( w = 〈 x , y 〉 → ( ( F ` w ) ∈ C ↔ ( x F y ) ∈ C ) ) ;;
	step 6 : wff = ralxp (step 5) |- ( ∀ w ∈ ( A × B ) ( F ` w ) ∈ C ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ;;
	step 7 : wff = anbi2i (step 6) |- ( ( F Fn ( A × B ) ∧ ∀ w ∈ ( A × B ) ( F ` w ) ∈ C ) ↔ ( F Fn ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ) ;;
	step 8 : wff = bitri (step 1, step 7) |- ( F : ( A × B ) ⟶ C ↔ ( F Fn ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Closure law for an operation.  (Contributed by NM, 19-Apr-2007.) */

theorem fovcl (A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y A, y B, x y C, x y F, x y R, x y S) {
	hyp 1 : wff = |- F : ( R × S ) ⟶ C ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
}

proof of fovcl {
	var x : set, y : set;;
	step 1 : wff = ffnov () |- ( F : ( R × S ) ⟶ C ↔ ( F Fn ( R × S ) ∧ ∀ x ∈ R ∀ y ∈ S ( x F y ) ∈ C ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( F : ( R × S ) ⟶ C → ∀ x ∈ R ∀ y ∈ S ( x F y ) ∈ C ) ;;
	step 3 : wff = ax-mp (hyp 1, step 2) |- ∀ x ∈ R ∀ y ∈ S ( x F y ) ∈ C ;;
	step 4 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 5 : wff = eleq1d (step 4) |- ( x = A → ( ( x F y ) ∈ C ↔ ( A F y ) ∈ C ) ) ;;
	step 6 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 7 : wff = eleq1d (step 6) |- ( y = B → ( ( A F y ) ∈ C ↔ ( A F B ) ∈ C ) ) ;;
	step 8 : wff = rspc2v (step 5, step 7) |- ( ( A ∈ R ∧ B ∈ S ) → ( ∀ x ∈ R ∀ y ∈ S ( x F y ) ∈ C → ( A F B ) ∈ C ) ) ;;
	step 9 : wff = mpi (step 3, step 8) |- ( ( A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
	qed prop 1 = step 9 ;;
}

/* Equality of two operations is determined by their values.  (Contributed
       by NM, 1-Sep-2005.) */

theorem eqfnov (x : set, y : set, A : class, B : class, C : class, D : class, F : class, G : class) disjointed(x y z A, x y z B, z C, z D, x y z F, x y z G) {
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ G Fn ( C × D ) ) → ( F = G ↔ ( ( A × B ) = ( C × D ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ) ;;
}

proof of eqfnov {
	var z : set;;
	step 1 : wff = eqfnfv2 () |- ( ( F Fn ( A × B ) ∧ G Fn ( C × D ) ) → ( F = G ↔ ( ( A × B ) = ( C × D ) ∧ ∀ z ∈ ( A × B ) ( F ` z ) = ( G ` z ) ) ) ) ;;
	step 2 : wff = fveq2 () |- ( z = 〈 x , y 〉 → ( F ` z ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = fveq2 () |- ( z = 〈 x , y 〉 → ( G ` z ) = ( G ` 〈 x , y 〉 ) ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( z = 〈 x , y 〉 → ( ( F ` z ) = ( G ` z ) ↔ ( F ` 〈 x , y 〉 ) = ( G ` 〈 x , y 〉 ) ) ) ;;
	step 5 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 6 : wff = df-ov () |- ( x G y ) = ( G ` 〈 x , y 〉 ) ;;
	step 7 : wff = eqeq12i (step 5, step 6) |- ( ( x F y ) = ( x G y ) ↔ ( F ` 〈 x , y 〉 ) = ( G ` 〈 x , y 〉 ) ) ;;
	step 8 : wff = syl6bbr (step 4, step 7) |- ( z = 〈 x , y 〉 → ( ( F ` z ) = ( G ` z ) ↔ ( x F y ) = ( x G y ) ) ) ;;
	step 9 : wff = ralxp (step 8) |- ( ∀ z ∈ ( A × B ) ( F ` z ) = ( G ` z ) ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( ( A × B ) = ( C × D ) ∧ ∀ z ∈ ( A × B ) ( F ` z ) = ( G ` z ) ) ↔ ( ( A × B ) = ( C × D ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ;;
	step 11 : wff = syl6bb (step 1, step 10) |- ( ( F Fn ( A × B ) ∧ G Fn ( C × D ) ) → ( F = G ↔ ( ( A × B ) = ( C × D ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Two operators with the same domain are equal iff their values at each
       point in the domain are equal.  (Contributed by Jeff Madsen,
       7-Jun-2010.) */

theorem eqfnov2 (x : set, y : set, A : class, B : class, F : class, G : class) disjointed(A x y, B x y, F x y, G x y) {
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ G Fn ( A × B ) ) → ( F = G ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ;;
}

proof of eqfnov2 {
	step 1 : wff = eqfnov () |- ( ( F Fn ( A × B ) ∧ G Fn ( A × B ) ) → ( F = G ↔ ( ( A × B ) = ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ) ;;
	step 2 : wff = simpr () |- ( ( ( A × B ) = ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) → ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ;;
	step 3 : wff = eqidd () |- ( ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) → ( A × B ) = ( A × B ) ) ;;
	step 4 : wff = ancri (step 3) |- ( ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) → ( ( A × B ) = ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ;;
	step 5 : wff = impbii (step 2, step 4) |- ( ( ( A × B ) = ( A × B ) ∧ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ;;
	step 6 : wff = syl6bb (step 1, step 5) |- ( ( F Fn ( A × B ) ∧ G Fn ( A × B ) ) → ( F = G ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) = ( x G y ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Representation of a function in terms of its values.  (Contributed by
       NM, 7-Feb-2004.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fnov (x : set, y : set, A : class, B : class, F : class) disjointed(x y z A, x y z B, x y z F) {
	prop 1 : wff = |- ( F Fn ( A × B ) ↔ F = ( x ∈ A , y ∈ B ↦ ( x F y ) ) ) ;;
}

proof of fnov {
	var z : set;;
	step 1 : wff = dffn5 () |- ( F Fn ( A × B ) ↔ F = ( z ∈ ( A × B ) ↦ ( F ` z ) ) ) ;;
	step 2 : wff = fveq2 () |- ( z = 〈 x , y 〉 → ( F ` z ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( z = 〈 x , y 〉 → ( F ` z ) = ( x F y ) ) ;;
	step 5 : wff = mpt2mpt (step 4) |- ( z ∈ ( A × B ) ↦ ( F ` z ) ) = ( x ∈ A , y ∈ B ↦ ( x F y ) ) ;;
	step 6 : wff = eqeq2i (step 5) |- ( F = ( z ∈ ( A × B ) ↦ ( F ` z ) ) ↔ F = ( x ∈ A , y ∈ B ↦ ( x F y ) ) ) ;;
	step 7 : wff = bitri (step 1, step 6) |- ( F Fn ( A × B ) ↔ F = ( x ∈ A , y ∈ B ↦ ( x F y ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Bidirectional equality theorem for a mapping abstraction.  Equivalent to
       ~ eqfnov2 .  (Contributed by Mario Carneiro, 4-Jan-2017.) */

theorem mpt22eqb (x : set, y : set, A : class, B : class, C : class, D : class, V : class) disjointed(x y z A, y z B, z C, z D) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ↔ ∀ x ∈ A ∀ y ∈ B C = D ) ) ;;
}

proof of mpt22eqb {
	var z : set;;
	step 1 : wff = pm13.183 () |- ( C ∈ V → ( C = D ↔ ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ y ∈ B C ∈ V → ∀ y ∈ B ( C = D ↔ ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 3 : wff = ralbi () |- ( ∀ y ∈ B ( C = D ↔ ∀ z ( z = C ↔ z = D ) ) → ( ∀ y ∈ B C = D ↔ ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ∀ y ∈ B C ∈ V → ( ∀ y ∈ B C = D ↔ ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 5 : wff = ralimi (step 4) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ∀ x ∈ A ( ∀ y ∈ B C = D ↔ ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 6 : wff = ralbi () |- ( ∀ x ∈ A ( ∀ y ∈ B C = D ↔ ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) → ( ∀ x ∈ A ∀ y ∈ B C = D ↔ ∀ x ∈ A ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∀ x ∈ A ∀ y ∈ B C = D ↔ ∀ x ∈ A ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 8 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 9 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ D ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) } ;;
	step 10 : wff = eqeq12i (step 8, step 9) |- ( ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ↔ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) } ) ;;
	step 11 : wff = eqoprab2b () |- ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) } ↔ ∀ x ∀ y ∀ z ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ) ;;
	step 12 : wff = pm5.32 () |- ( ( ( x ∈ A ∧ y ∈ B ) → ( z = C ↔ z = D ) ) ↔ ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ z ( ( x ∈ A ∧ y ∈ B ) → ( z = C ↔ z = D ) ) ↔ ∀ z ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ) ;;
	step 14 : wff = 19.21v () |- ( ∀ z ( ( x ∈ A ∧ y ∈ B ) → ( z = C ↔ z = D ) ) ↔ ( ( x ∈ A ∧ y ∈ B ) → ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 15 : wff = bitr3i (step 13, step 14) |- ( ∀ z ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ↔ ( ( x ∈ A ∧ y ∈ B ) → ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 16 : wff = 2albii (step 15) |- ( ∀ x ∀ y ∀ z ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 17 : wff = r2al () |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ∀ z ( z = C ↔ z = D ) ) ) ;;
	step 18 : wff = bitr4i (step 16, step 17) |- ( ∀ x ∀ y ∀ z ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z = D ) ) ↔ ∀ x ∈ A ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ;;
	step 19 : wff = 3bitri (step 10, step 11, step 18) |- ( ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ↔ ∀ x ∈ A ∀ y ∈ B ∀ z ( z = C ↔ z = D ) ) ;;
	step 20 : wff = syl6rbbr (step 7, step 19) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ D ) ↔ ∀ x ∈ A ∀ y ∈ B C = D ) ) ;;
	qed prop 1 = step 20 ;;
}

/* The range of an operation given by the "maps to" notation.  (Contributed
       by FL, 20-Jun-2011.) */

theorem rnmpt2 (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(y z A, z B, z C, z F, x y z, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ran F = { z | ∃ x ∈ A ∃ y ∈ B z = C } ;;
}

proof of rnmpt2 {
	step 1 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 3 : wff = rneqi (step 2) |- ran F = ran { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 4 : wff = rnoprab2 () |- ran { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { z | ∃ x ∈ A ∃ y ∈ B z = C } ;;
	step 5 : wff = eqtri (step 3, step 4) |- ran F = { z | ∃ x ∈ A ∃ y ∈ B z = C } ;;
	qed prop 1 = step 5 ;;
}

/* The domain of an operation defined by maps-to notation is a relation.
       (Contributed by Stefan O'Rear, 27-Nov-2014.) */

theorem reldmmpt2 (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(y z A, z B, z C, z F, x y z, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- Rel dom F ;;
}

proof of reldmmpt2 {
	var z : set;;
	step 1 : wff = reldmoprab () |- Rel dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 3 : wff = eqtri (hyp 1, step 2) |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 4 : wff = dmeqi (step 3) |- dom F = dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 5 : wff = releqi (step 4) |- ( Rel dom F ↔ Rel dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ) ;;
	step 6 : wff = mpbir (step 1, step 5) |- Rel dom F ;;
	qed prop 1 = step 6 ;;
}

/* Membership in the range of an operation class abstraction.  (Contributed
       by NM, 27-Aug-2007.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem elrnmpt2g (x : set, y : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(y z A, z B, z C, z F, x y z D, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( D ∈ V → ( D ∈ ran F ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ) ;;
}

proof of elrnmpt2g {
	var z : set;;
	step 1 : wff = eqeq1 () |- ( z = D → ( z = C ↔ D = C ) ) ;;
	step 2 : wff = 2rexbidv (step 1) |- ( z = D → ( ∃ x ∈ A ∃ y ∈ B z = C ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ) ;;
	step 3 : wff = rnmpt2 (hyp 1) |- ran F = { z | ∃ x ∈ A ∃ y ∈ B z = C } ;;
	step 4 : wff = elab2g (step 2, step 3) |- ( D ∈ V → ( D ∈ ran F ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Membership in the range of an operation class abstraction.
         (Contributed by NM, 1-Aug-2004.)  (Revised by Mario Carneiro,
         31-Aug-2015.) */

theorem elrnmpt2 (x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(y z A, z B, z C, z F, x y z D, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( D ∈ ran F ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ;;
}

proof of elrnmpt2 {
	var z : set;;
	step 1 : wff = rnmpt2 (hyp 1) |- ran F = { z | ∃ x ∈ A ∃ y ∈ B z = C } ;;
	step 2 : wff = eleq2i (step 1) |- ( D ∈ ran F ↔ D ∈ { z | ∃ x ∈ A ∃ y ∈ B z = C } ) ;;
	step 3 : wff = eleq1 () |- ( D = C → ( D ∈ _V ↔ C ∈ _V ) ) ;;
	step 4 : wff = mpbiri (hyp 2, step 3) |- ( D = C → D ∈ _V ) ;;
	step 5 : wff = rexlimivw (step 4) |- ( ∃ y ∈ B D = C → D ∈ _V ) ;;
	step 6 : wff = rexlimivw (step 5) |- ( ∃ x ∈ A ∃ y ∈ B D = C → D ∈ _V ) ;;
	step 7 : wff = eqeq1 () |- ( z = D → ( z = C ↔ D = C ) ) ;;
	step 8 : wff = 2rexbidv (step 7) |- ( z = D → ( ∃ x ∈ A ∃ y ∈ B z = C ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ) ;;
	step 9 : wff = elab3 (step 6, step 8) |- ( D ∈ { z | ∃ x ∈ A ∃ y ∈ B z = C } ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ;;
	step 10 : wff = bitri (step 2, step 9) |- ( D ∈ ran F ↔ ∃ x ∈ A ∃ y ∈ B D = C ) ;;
	qed prop 1 = step 10 ;;
}

/* A restricted quantifier over an image set.  (Contributed by Mario
       Carneiro, 1-Sep-2015.) */

theorem ralrnmpt2 (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, F : class, V : class) disjointed(w x, w y z A, w z B, w z C, w z F, z ps, x y z, x y ph) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	hyp 2 : wff = |- ( z = C → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∀ z ∈ ran F ph ↔ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
}

proof of ralrnmpt2 {
	var w : set;;
	step 1 : wff = rnmpt2 (hyp 1) |- ran F = { w | ∃ x ∈ A ∃ y ∈ B w = C } ;;
	step 2 : wff = raleqi (step 1) |- ( ∀ z ∈ ran F ph ↔ ∀ z ∈ { w | ∃ x ∈ A ∃ y ∈ B w = C } ph ) ;;
	step 3 : wff = eqeq1 () |- ( w = z → ( w = C ↔ z = C ) ) ;;
	step 4 : wff = 2rexbidv (step 3) |- ( w = z → ( ∃ x ∈ A ∃ y ∈ B w = C ↔ ∃ x ∈ A ∃ y ∈ B z = C ) ) ;;
	step 5 : wff = ralab (step 4) |- ( ∀ z ∈ { w | ∃ x ∈ A ∃ y ∈ B w = C } ph ↔ ∀ z ( ∃ x ∈ A ∃ y ∈ B z = C → ph ) ) ;;
	step 6 : wff = ralcom4 () |- ( ∀ x ∈ A ∀ z ( ∃ y ∈ B z = C → ph ) ↔ ∀ z ∀ x ∈ A ( ∃ y ∈ B z = C → ph ) ) ;;
	step 7 : wff = r19.23v () |- ( ∀ x ∈ A ( ∃ y ∈ B z = C → ph ) ↔ ( ∃ x ∈ A ∃ y ∈ B z = C → ph ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ z ∀ x ∈ A ( ∃ y ∈ B z = C → ph ) ↔ ∀ z ( ∃ x ∈ A ∃ y ∈ B z = C → ph ) ) ;;
	step 9 : wff = bitr2i (step 6, step 8) |- ( ∀ z ( ∃ x ∈ A ∃ y ∈ B z = C → ph ) ↔ ∀ x ∈ A ∀ z ( ∃ y ∈ B z = C → ph ) ) ;;
	step 10 : wff = 3bitri (step 2, step 5, step 9) |- ( ∀ z ∈ ran F ph ↔ ∀ x ∈ A ∀ z ( ∃ y ∈ B z = C → ph ) ) ;;
	step 11 : wff = ralcom4 () |- ( ∀ y ∈ B ∀ z ( z = C → ph ) ↔ ∀ z ∀ y ∈ B ( z = C → ph ) ) ;;
	step 12 : wff = r19.23v () |- ( ∀ y ∈ B ( z = C → ph ) ↔ ( ∃ y ∈ B z = C → ph ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ z ∀ y ∈ B ( z = C → ph ) ↔ ∀ z ( ∃ y ∈ B z = C → ph ) ) ;;
	step 14 : wff = bitri (step 11, step 13) |- ( ∀ y ∈ B ∀ z ( z = C → ph ) ↔ ∀ z ( ∃ y ∈ B z = C → ph ) ) ;;
	step 15 : wff = nfv () |- F/ z ps ;;
	step 16 : wff = ceqsalg (step 15, hyp 2) |- ( C ∈ V → ( ∀ z ( z = C → ph ) ↔ ps ) ) ;;
	step 17 : wff = ralimi (step 16) |- ( ∀ y ∈ B C ∈ V → ∀ y ∈ B ( ∀ z ( z = C → ph ) ↔ ps ) ) ;;
	step 18 : wff = ralbi () |- ( ∀ y ∈ B ( ∀ z ( z = C → ph ) ↔ ps ) → ( ∀ y ∈ B ∀ z ( z = C → ph ) ↔ ∀ y ∈ B ps ) ) ;;
	step 19 : wff = syl (step 17, step 18) |- ( ∀ y ∈ B C ∈ V → ( ∀ y ∈ B ∀ z ( z = C → ph ) ↔ ∀ y ∈ B ps ) ) ;;
	step 20 : wff = syl5bbr (step 14, step 19) |- ( ∀ y ∈ B C ∈ V → ( ∀ z ( ∃ y ∈ B z = C → ph ) ↔ ∀ y ∈ B ps ) ) ;;
	step 21 : wff = ralimi (step 20) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ∀ x ∈ A ( ∀ z ( ∃ y ∈ B z = C → ph ) ↔ ∀ y ∈ B ps ) ) ;;
	step 22 : wff = ralbi () |- ( ∀ x ∈ A ( ∀ z ( ∃ y ∈ B z = C → ph ) ↔ ∀ y ∈ B ps ) → ( ∀ x ∈ A ∀ z ( ∃ y ∈ B z = C → ph ) ↔ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
	step 23 : wff = syl (step 21, step 22) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∀ x ∈ A ∀ z ( ∃ y ∈ B z = C → ph ) ↔ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
	step 24 : wff = syl5bb (step 10, step 23) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∀ z ∈ ran F ph ↔ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
	qed prop 1 = step 24 ;;
}

/* A restricted quantifier over an image set.  (Contributed by Mario
       Carneiro, 1-Sep-2015.) */

theorem rexrnmpt2 (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, F : class, V : class) disjointed(y z A, z B, z C, z F, z ps, x y z, x y ph) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	hyp 2 : wff = |- ( z = C → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∃ z ∈ ran F ph ↔ ∃ x ∈ A ∃ y ∈ B ps ) ) ;;
}

proof of rexrnmpt2 {
	step 1 : wff = notbid (hyp 2) |- ( z = C → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = ralrnmpt2 (hyp 1, step 1) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∀ z ∈ ran F ¬ ph ↔ ∀ x ∈ A ∀ y ∈ B ¬ ps ) ) ;;
	step 3 : wff = notbid (step 2) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ¬ ∀ z ∈ ran F ¬ ph ↔ ¬ ∀ x ∈ A ∀ y ∈ B ¬ ps ) ) ;;
	step 4 : wff = dfrex2 () |- ( ∃ z ∈ ran F ph ↔ ¬ ∀ z ∈ ran F ¬ ph ) ;;
	step 5 : wff = dfrex2 () |- ( ∃ y ∈ B ps ↔ ¬ ∀ y ∈ B ¬ ps ) ;;
	step 6 : wff = rexbii (step 5) |- ( ∃ x ∈ A ∃ y ∈ B ps ↔ ∃ x ∈ A ¬ ∀ y ∈ B ¬ ps ) ;;
	step 7 : wff = rexnal () |- ( ∃ x ∈ A ¬ ∀ y ∈ B ¬ ps ↔ ¬ ∀ x ∈ A ∀ y ∈ B ¬ ps ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ∃ x ∈ A ∃ y ∈ B ps ↔ ¬ ∀ x ∈ A ∀ y ∈ B ¬ ps ) ;;
	step 9 : wff = 3bitr4g (step 3, step 4, step 8) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ( ∃ z ∈ ran F ph ↔ ∃ x ∈ A ∃ y ∈ B ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Existence of an operator abstraction.  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem oprabexd (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, F : class) disjointed(A x y z, B x y z, ph x y z) {
	hyp 1 : wff = |- ( ph → A ∈ _V ) ;;
	hyp 2 : wff = |- ( ph → B ∈ _V ) ;;
	hyp 3 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ∃* z ps ) ;;
	hyp 4 : wff = |- ( ph → F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F ∈ _V ) ;;
}

proof of oprabexd {
	step 1 : wff = ex (hyp 3) |- ( ph → ( ( x ∈ A ∧ y ∈ B ) → ∃* z ps ) ) ;;
	step 2 : wff = moanimv () |- ( ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ↔ ( ( x ∈ A ∧ y ∈ B ) → ∃* z ps ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ph → ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ) ;;
	step 4 : wff = alrimivv (step 3) |- ( ph → ∀ x ∀ y ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ) ;;
	step 5 : wff = funoprabg () |- ( ∀ x ∀ y ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) → Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ph → Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ) ;;
	step 7 : wff = dmoprabss () |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ⊆ ( A × B ) ;;
	step 8 : wff = xpexg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A × B ) ∈ _V ) ;;
	step 9 : wff = syl2anc (hyp 1, hyp 2, step 8) |- ( ph → ( A × B ) ∈ _V ) ;;
	step 10 : wff = ssexg () |- ( ( dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ⊆ ( A × B ) ∧ ( A × B ) ∈ _V ) → dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ∈ _V ) ;;
	step 11 : wff = sylancr (step 7, step 9, step 10) |- ( ph → dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ∈ _V ) ;;
	step 12 : wff = funex () |- ( ( Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ∧ dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ∈ _V ) → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ∈ _V ) ;;
	step 13 : wff = syl2anc (step 6, step 11, step 12) |- ( ph → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ∈ _V ) ;;
	step 14 : wff = eqeltrd (hyp 4, step 13) |- ( ph → F ∈ _V ) ;;
	qed prop 1 = step 14 ;;
}

/* Existence of an operation class abstraction.  (Contributed by NM,
       19-Oct-2004.) */

theorem oprabex (ph : wff, x : set, y : set, z : set, A : class, B : class, F : class) disjointed(x y z A, x y z B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → ∃* z ph ) ;;
	hyp 4 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- F ∈ _V ;;
}

proof of oprabex {
	step 1 : wff = moanimv () |- ( ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ( ( x ∈ A ∧ y ∈ B ) → ∃* z ph ) ) ;;
	step 2 : wff = mpbir (hyp 3, step 1) |- ∃* z ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ;;
	step 3 : wff = funoprab (step 2) |- Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ;;
	step 4 : wff = xpex (hyp 1, hyp 2) |- ( A × B ) ∈ _V ;;
	step 5 : wff = dmoprabss () |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ ( A × B ) ;;
	step 6 : wff = ssexi (step 4, step 5) |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ∈ _V ;;
	step 7 : wff = funex () |- ( ( Fun { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ∧ dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ∈ _V ) → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ∈ _V ) ;;
	step 8 : wff = mp2an (step 3, step 6, step 7) |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ∈ _V ;;
	step 9 : wff = eqeltri (hyp 4, step 8) |- F ∈ _V ;;
	qed prop 1 = step 9 ;;
}

/* Existence of an operation class abstraction (special case).
       (Contributed by NM, 19-Oct-2004.) */

theorem oprabex3 (x : set, y : set, z : set, w : set, v : set, u : set, R : class, f : set, F : class, H : class) disjointed(x y z w v u f, x y z w v u f, x y z w v u f, x y z w v u f, x y z w v u f H, x y z R, x y z w v u f) {
	hyp 1 : wff = |- H ∈ _V ;;
	hyp 2 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) ∧ ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) } ;;
	-----------------------
	prop 1 : wff = |- F ∈ _V ;;
}

proof of oprabex3 {
	step 1 : wff = xpex (hyp 1, hyp 1) |- ( H × H ) ∈ _V ;;
	step 2 : wff = xpex (hyp 1, hyp 1) |- ( H × H ) ∈ _V ;;
	step 3 : wff = moeq () |- ∃* z z = R ;;
	step 4 : wff = mosubop (step 3) |- ∃* z ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ;;
	step 5 : wff = mosubop (step 4) |- ∃* z ∃ w ∃ v ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ;;
	step 6 : wff = anass () |- ( ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ( x = 〈 w , v 〉 ∧ ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 7 : wff = 2exbii (step 6) |- ( ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃ u ∃ f ( x = 〈 w , v 〉 ∧ ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 8 : wff = 19.42vv () |- ( ∃ u ∃ f ( x = 〈 w , v 〉 ∧ ( y = 〈 u , f 〉 ∧ z = R ) ) ↔ ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 9 : wff = bitri (step 7, step 8) |- ( ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 10 : wff = 2exbii (step 9) |- ( ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃ w ∃ v ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 11 : wff = mobii (step 10) |- ( ∃* z ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃* z ∃ w ∃ v ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 12 : wff = mpbir (step 5, step 11) |- ∃* z ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ;;
	step 13 : wff = a1i (step 12) |- ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) → ∃* z ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) ;;
	step 14 : wff = oprabex (step 1, step 2, step 13, hyp 2) |- F ∈ _V ;;
	qed prop 1 = step 14 ;;
}

/* Existence of an existentially restricted operation abstraction.
       (Contributed by Jeff Madsen, 11-Jun-2010.) */

theorem oprabrexex2 (ph : wff, x : set, y : set, z : set, w : set, A : class) disjointed(A v x y z w, ph v) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ∃ w ∈ A ph } ∈ _V ;;
}

proof of oprabrexex2 {
	var v : set;;
	step 1 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ∃ w ∈ A ph } = { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) } ;;
	step 2 : wff = rexcom4 () |- ( ∃ w ∈ A ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ x ∃ w ∈ A ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 3 : wff = rexcom4 () |- ( ∃ w ∈ A ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ y ∃ w ∈ A ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 4 : wff = rexcom4 () |- ( ∃ w ∈ A ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ z ∃ w ∈ A ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 5 : wff = r19.42v () |- ( ∃ w ∈ A ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ z ∃ w ∈ A ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ) ;;
	step 7 : wff = bitri (step 4, step 6) |- ( ∃ w ∈ A ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ y ∃ w ∈ A ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ) ;;
	step 9 : wff = bitri (step 3, step 8) |- ( ∃ w ∈ A ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ x ∃ w ∈ A ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ) ;;
	step 11 : wff = bitr2i (step 2, step 10) |- ( ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) ↔ ∃ w ∈ A ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 12 : wff = abbii (step 11) |- { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ∃ w ∈ A ph ) } = { v | ∃ w ∈ A ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 13 : wff = eqtri (step 1, step 12) |- { 〈 〈 x , y 〉 , z 〉 | ∃ w ∈ A ph } = { v | ∃ w ∈ A ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 14 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 15 : wff = eqeltrri (step 14, hyp 2) |- { v | ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ∈ _V ;;
	step 16 : wff = abrexex2 (hyp 1, step 15) |- { v | ∃ w ∈ A ∃ x ∃ y ∃ z ( v = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ∈ _V ;;
	step 17 : wff = eqeltri (step 13, step 16) |- { 〈 〈 x , y 〉 , z 〉 | ∃ w ∈ A ph } ∈ _V ;;
	qed prop 1 = step 17 ;;
}

/* The value of an operation class abstraction.  (Contributed by NM,
       16-May-1995.)  (Revised by David Abernethy, 19-Jun-2012.) */

theorem ovid (ph : wff, x : set, y : set, z : set, R : class, S : class, F : class) disjointed(x y z, z R, z S) {
	hyp 1 : wff = |- ( ( x ∈ R ∧ y ∈ S ) → ∃! z ph ) ;;
	hyp 2 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ R ∧ y ∈ S ) → ( ( x F y ) = z ↔ ph ) ) ;;
}

proof of ovid {
	step 1 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 2 : wff = eqeq1i (step 1) |- ( ( x F y ) = z ↔ ( F ` 〈 x , y 〉 ) = z ) ;;
	step 3 : wff = fnoprab (hyp 1) |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ;;
	step 4 : wff = fneq1i (hyp 2) |- ( F Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ↔ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) ;;
	step 5 : wff = mpbir (step 3, step 4) |- F Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ;;
	step 6 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ↔ ( x ∈ R ∧ y ∈ S ) ) ;;
	step 7 : wff = biimpri (step 6) |- ( ( x ∈ R ∧ y ∈ S ) → 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) ;;
	step 8 : wff = fnopfvb () |- ( ( F Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ∧ 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) → ( ( F ` 〈 x , y 〉 ) = z ↔ 〈 〈 x , y 〉 , z 〉 ∈ F ) ) ;;
	step 9 : wff = sylancr (step 5, step 7, step 8) |- ( ( x ∈ R ∧ y ∈ S ) → ( ( F ` 〈 x , y 〉 ) = z ↔ 〈 〈 x , y 〉 , z 〉 ∈ F ) ) ;;
	step 10 : wff = eleq2i (hyp 2) |- ( 〈 〈 x , y 〉 , z 〉 ∈ F ↔ 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ;;
	step 11 : wff = oprabid () |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ↔ ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( 〈 〈 x , y 〉 , z 〉 ∈ F ↔ ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ) ;;
	step 13 : wff = baib (step 12) |- ( ( x ∈ R ∧ y ∈ S ) → ( 〈 〈 x , y 〉 , z 〉 ∈ F ↔ ph ) ) ;;
	step 14 : wff = bitrd (step 9, step 13) |- ( ( x ∈ R ∧ y ∈ S ) → ( ( F ` 〈 x , y 〉 ) = z ↔ ph ) ) ;;
	step 15 : wff = syl5bb (step 2, step 14) |- ( ( x ∈ R ∧ y ∈ S ) → ( ( x F y ) = z ↔ ph ) ) ;;
	qed prop 1 = step 15 ;;
}

/* The value of an operation class abstraction.  Compare ~ ovidi .  The
       condition ` ( x e. R /\ y e. S ) ` is been removed.  (Contributed by
       Mario Carneiro, 29-Dec-2014.) */

theorem ovidig (ph : wff, x : set, y : set, z : set, F : class) disjointed(x y z) {
	hyp 1 : wff = |- ∃* z ph ;;
	hyp 2 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( x F y ) = z ) ;;
}

proof of ovidig {
	step 1 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 2 : wff = funoprab (hyp 1) |- Fun { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 3 : wff = funeqi (hyp 2) |- ( Fun F ↔ Fun { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 4 : wff = mpbir (step 2, step 3) |- Fun F ;;
	step 5 : wff = oprabid () |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ph ) ;;
	step 6 : wff = biimpri (step 5) |- ( ph → 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 7 : wff = syl6eleqr (step 6, hyp 2) |- ( ph → 〈 〈 x , y 〉 , z 〉 ∈ F ) ;;
	step 8 : wff = funopfv () |- ( Fun F → ( 〈 〈 x , y 〉 , z 〉 ∈ F → ( F ` 〈 x , y 〉 ) = z ) ) ;;
	step 9 : wff = mpsyl (step 4, step 7, step 8) |- ( ph → ( F ` 〈 x , y 〉 ) = z ) ;;
	step 10 : wff = syl5eq (step 1, step 9) |- ( ph → ( x F y ) = z ) ;;
	qed prop 1 = step 10 ;;
}

/* The value of an operation class abstraction (weak version).
       (Contributed by Mario Carneiro, 29-Dec-2014.) */

theorem ovidi (ph : wff, x : set, y : set, z : set, R : class, S : class, F : class) disjointed(x y z, z R, z S) {
	hyp 1 : wff = |- ( ( x ∈ R ∧ y ∈ S ) → ∃* z ph ) ;;
	hyp 2 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ R ∧ y ∈ S ) → ( ph → ( x F y ) = z ) ) ;;
}

proof of ovidi {
	step 1 : wff = moanimv () |- ( ∃* z ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ↔ ( ( x ∈ R ∧ y ∈ S ) → ∃* z ph ) ) ;;
	step 2 : wff = mpbir (hyp 1, step 1) |- ∃* z ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ;;
	step 3 : wff = ovidig (step 2, hyp 2) |- ( ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) → ( x F y ) = z ) ;;
	step 4 : wff = ex (step 3) |- ( ( x ∈ R ∧ y ∈ S ) → ( ph → ( x F y ) = z ) ) ;;
	qed prop 1 = step 4 ;;
}

/* The value of an operation class abstraction.  (Contributed by NM,
       16-May-1995.)  (Revised by David Abernethy, 19-Jun-2012.) */

theorem ov (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z R, x y z S, x y z th) {
	hyp 1 : wff = |- C ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 4 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 5 : wff = |- ( ( x ∈ R ∧ y ∈ S ) → ∃! z ph ) ;;
	hyp 6 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ S ) → ( ( A F B ) = C ↔ th ) ) ;;
}

proof of ov {
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = fveq1i (hyp 6) |- ( F ` 〈 A , B 〉 ) = ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( A F B ) = ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) ;;
	step 4 : wff = eqeq1i (step 3) |- ( ( A F B ) = C ↔ ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ) ;;
	step 5 : wff = fnoprab (hyp 5) |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ;;
	step 6 : wff = eleq1 () |- ( x = A → ( x ∈ R ↔ A ∈ R ) ) ;;
	step 7 : wff = anbi1d (step 6) |- ( x = A → ( ( x ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ y ∈ S ) ) ) ;;
	step 8 : wff = eleq1 () |- ( y = B → ( y ∈ S ↔ B ∈ S ) ) ;;
	step 9 : wff = anbi2d (step 8) |- ( y = B → ( ( A ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 10 : wff = opelopabg (step 7, step 9) |- ( ( A ∈ R ∧ B ∈ S ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 11 : wff = ibir (step 10) |- ( ( A ∈ R ∧ B ∈ S ) → 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) ;;
	step 12 : wff = fnopfvb () |- ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ∧ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ;;
	step 13 : wff = sylancr (step 5, step 11, step 12) |- ( ( A ∈ R ∧ B ∈ S ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ;;
	step 14 : wff = eleq1 () |- ( x = A → ( x ∈ R ↔ A ∈ R ) ) ;;
	step 15 : wff = anbi1d (step 14) |- ( x = A → ( ( x ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ y ∈ S ) ) ) ;;
	step 16 : wff = anbi12d (step 15, hyp 2) |- ( x = A → ( ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ↔ ( ( A ∈ R ∧ y ∈ S ) ∧ ps ) ) ) ;;
	step 17 : wff = eleq1 () |- ( y = B → ( y ∈ S ↔ B ∈ S ) ) ;;
	step 18 : wff = anbi2d (step 17) |- ( y = B → ( ( A ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 19 : wff = anbi12d (step 18, hyp 3) |- ( y = B → ( ( ( A ∈ R ∧ y ∈ S ) ∧ ps ) ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ ch ) ) ) ;;
	step 20 : wff = anbi2d (hyp 4) |- ( z = C → ( ( ( A ∈ R ∧ B ∈ S ) ∧ ch ) ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 21 : wff = eloprabg (step 16, step 19, step 20) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ _V ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 22 : wff = mp3an3 (hyp 1, step 21) |- ( ( A ∈ R ∧ B ∈ S ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 23 : wff = bitrd (step 13, step 22) |- ( ( A ∈ R ∧ B ∈ S ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 24 : wff = syl5bb (step 4, step 23) |- ( ( A ∈ R ∧ B ∈ S ) → ( ( A F B ) = C ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 25 : wff = bianabs (step 24) |- ( ( A ∈ R ∧ B ∈ S ) → ( ( A F B ) = C ↔ th ) ) ;;
	qed prop 1 = step 25 ;;
}

/* The value of an operation class abstraction.  Compare ~ ovig .  The
       condition ` ( x e. R /\ y e. S ) ` is been removed.  (Contributed by FL,
       24-Mar-2007.)  (Revised by Mario Carneiro, 19-Dec-2013.) */

theorem ovigg (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, F : class, V : class, W : class, X : class) disjointed(x y z A, x y z B, x y z C, x y z ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ∃* z ph ;;
	hyp 3 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ps → ( A F B ) = C ) ) ;;
}

proof of ovigg {
	step 1 : wff = eloprabga (hyp 1) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ps ) ) ;;
	step 2 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 3 : wff = fveq1i (hyp 3) |- ( F ` 〈 A , B 〉 ) = ( { 〈 〈 x , y 〉 , z 〉 | ph } ` 〈 A , B 〉 ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- ( A F B ) = ( { 〈 〈 x , y 〉 , z 〉 | ph } ` 〈 A , B 〉 ) ;;
	step 5 : wff = funoprab (hyp 2) |- Fun { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 6 : wff = funopfv () |- ( Fun { 〈 〈 x , y 〉 , z 〉 | ph } → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → ( { 〈 〈 x , y 〉 , z 〉 | ph } ` 〈 A , B 〉 ) = C ) ) ;;
	step 7 : wff = ax-mp (step 5, step 6) |- ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → ( { 〈 〈 x , y 〉 , z 〉 | ph } ` 〈 A , B 〉 ) = C ) ;;
	step 8 : wff = syl5eq (step 4, step 7) |- ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → ( A F B ) = C ) ;;
	step 9 : wff = syl6bir (step 1, step 8) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ps → ( A F B ) = C ) ) ;;
	qed prop 1 = step 9 ;;
}

/* The value of an operation class abstraction (weak version).
       (Unnecessary distinct variable restrictions were removed by David
       Abernethy, 19-Jun-2012.)  (Contributed by NM, 14-Sep-1999.)  (Revised by
       Mario Carneiro, 19-Dec-2013.) */

theorem ovig (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z R, x y z S, x y z ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( ( x ∈ R ∧ y ∈ S ) → ∃* z ph ) ;;
	hyp 3 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) → ( ps → ( A F B ) = C ) ) ;;
}

proof of ovig {
	step 1 : wff = 3simpa () |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) → ( A ∈ R ∧ B ∈ S ) ) ;;
	step 2 : wff = eleq1 () |- ( x = A → ( x ∈ R ↔ A ∈ R ) ) ;;
	step 3 : wff = eleq1 () |- ( y = B → ( y ∈ S ↔ B ∈ S ) ) ;;
	step 4 : wff = bi2anan9 (step 2, step 3) |- ( ( x = A ∧ y = B ) → ( ( x ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 5 : wff = 3adant3 (step 4) |- ( ( x = A ∧ y = B ∧ z = C ) → ( ( x ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 6 : wff = anbi12d (step 5, hyp 1) |- ( ( x = A ∧ y = B ∧ z = C ) → ( ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ ps ) ) ) ;;
	step 7 : wff = moanimv () |- ( ∃* z ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ↔ ( ( x ∈ R ∧ y ∈ S ) → ∃* z ph ) ) ;;
	step 8 : wff = mpbir (hyp 2, step 7) |- ∃* z ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ;;
	step 9 : wff = ovigg (step 6, step 8, hyp 3) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) → ( ( ( A ∈ R ∧ B ∈ S ) ∧ ps ) → ( A F B ) = C ) ) ;;
	step 10 : wff = mpand (step 1, step 9) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) → ( ps → ( A F B ) = C ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Value of a function given by the "maps to" notation.  (This is the
       operation analog of ~ fvmpt2 .)  (Contributed by NM, 21-Feb-2004.)
       (Revised by Mario Carneiro, 1-Sep-2015.) */

theorem ovmpt4g (x : set, y : set, A : class, B : class, C : class, F : class, V : class) disjointed(x y z, z A, z B, z C, z F) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ∧ C ∈ V ) → ( x F y ) = C ) ;;
}

proof of ovmpt4g {
	var z : set;;
	step 1 : wff = elisset () |- ( C ∈ V → ∃ z z = C ) ;;
	step 2 : wff = moeq () |- ∃* z z = C ;;
	step 3 : wff = a1i (step 2) |- ( ( x ∈ A ∧ y ∈ B ) → ∃* z z = C ) ;;
	step 4 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 5 : wff = eqtri (hyp 1, step 4) |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 6 : wff = ovidi (step 3, step 5) |- ( ( x ∈ A ∧ y ∈ B ) → ( z = C → ( x F y ) = z ) ) ;;
	step 7 : wff = eqeq2 () |- ( z = C → ( ( x F y ) = z ↔ ( x F y ) = C ) ) ;;
	step 8 : wff = mpbidi (step 6, step 7) |- ( ( x ∈ A ∧ y ∈ B ) → ( z = C → ( x F y ) = C ) ) ;;
	step 9 : wff = exlimdv (step 8) |- ( ( x ∈ A ∧ y ∈ B ) → ( ∃ z z = C → ( x F y ) = C ) ) ;;
	step 10 : wff = syl5 (step 1, step 9) |- ( ( x ∈ A ∧ y ∈ B ) → ( C ∈ V → ( x F y ) = C ) ) ;;
	step 11 : wff = 3impia (step 10) |- ( ( x ∈ A ∧ y ∈ B ∧ C ∈ V ) → ( x F y ) = C ) ;;
	qed prop 1 = step 11 ;;
}

/* Value of a function given by the "maps to" notation, expressed using
       explicit substitution.  (Contributed by Mario Carneiro, 30-Apr-2015.) */

theorem ovmpt2s (x : set, y : set, A : class, B : class, C : class, D : class, R : class, F : class, V : class) disjointed(x y A, x y B, x y C, x y D) {
	hyp 1 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ∧ [_ A / x ]_ [_ B / y ]_ R ∈ V ) → ( A F B ) = [_ A / x ]_ [_ B / y ]_ R ) ;;
}

proof of ovmpt2s {
	step 1 : wff = elex () |- ( [_ A / x ]_ [_ B / y ]_ R ∈ V → [_ A / x ]_ [_ B / y ]_ R ∈ _V ) ;;
	step 2 : wff = nfcv () |- F/_ x A ;;
	step 3 : wff = nfcv () |- F/_ y A ;;
	step 4 : wff = nfcv () |- F/_ y B ;;
	step 5 : wff = nfcsb1v () |- F/_ x [_ A / x ]_ R ;;
	step 6 : wff = nfel1 (step 5) |- F/ x [_ A / x ]_ R ∈ _V ;;
	step 7 : wff = nfcv () |- F/_ x A ;;
	step 8 : wff = nfmpt21 () |- F/_ x ( x ∈ C , y ∈ D ↦ R ) ;;
	step 9 : wff = nfcxfr (hyp 1, step 8) |- F/_ x F ;;
	step 10 : wff = nfcv () |- F/_ x y ;;
	step 11 : wff = nfov (step 7, step 9, step 10) |- F/_ x ( A F y ) ;;
	step 12 : wff = nfcsb1v () |- F/_ x [_ A / x ]_ R ;;
	step 13 : wff = nfeq (step 11, step 12) |- F/ x ( A F y ) = [_ A / x ]_ R ;;
	step 14 : wff = nfim (step 6, step 13) |- F/ x ( [_ A / x ]_ R ∈ _V → ( A F y ) = [_ A / x ]_ R ) ;;
	step 15 : wff = nfcsb1v () |- F/_ y [_ B / y ]_ [_ A / x ]_ R ;;
	step 16 : wff = nfel1 (step 15) |- F/ y [_ B / y ]_ [_ A / x ]_ R ∈ _V ;;
	step 17 : wff = nfcv () |- F/_ y A ;;
	step 18 : wff = nfmpt22 () |- F/_ y ( x ∈ C , y ∈ D ↦ R ) ;;
	step 19 : wff = nfcxfr (hyp 1, step 18) |- F/_ y F ;;
	step 20 : wff = nfcv () |- F/_ y B ;;
	step 21 : wff = nfov (step 17, step 19, step 20) |- F/_ y ( A F B ) ;;
	step 22 : wff = nfcsb1v () |- F/_ y [_ B / y ]_ [_ A / x ]_ R ;;
	step 23 : wff = nfeq (step 21, step 22) |- F/ y ( A F B ) = [_ B / y ]_ [_ A / x ]_ R ;;
	step 24 : wff = nfim (step 16, step 23) |- F/ y ( [_ B / y ]_ [_ A / x ]_ R ∈ _V → ( A F B ) = [_ B / y ]_ [_ A / x ]_ R ) ;;
	step 25 : wff = csbeq1a () |- ( x = A → R = [_ A / x ]_ R ) ;;
	step 26 : wff = eleq1d (step 25) |- ( x = A → ( R ∈ _V ↔ [_ A / x ]_ R ∈ _V ) ) ;;
	step 27 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 28 : wff = csbeq1a () |- ( x = A → R = [_ A / x ]_ R ) ;;
	step 29 : wff = eqeq12d (step 27, step 28) |- ( x = A → ( ( x F y ) = R ↔ ( A F y ) = [_ A / x ]_ R ) ) ;;
	step 30 : wff = imbi12d (step 26, step 29) |- ( x = A → ( ( R ∈ _V → ( x F y ) = R ) ↔ ( [_ A / x ]_ R ∈ _V → ( A F y ) = [_ A / x ]_ R ) ) ) ;;
	step 31 : wff = csbeq1a () |- ( y = B → [_ A / x ]_ R = [_ B / y ]_ [_ A / x ]_ R ) ;;
	step 32 : wff = eleq1d (step 31) |- ( y = B → ( [_ A / x ]_ R ∈ _V ↔ [_ B / y ]_ [_ A / x ]_ R ∈ _V ) ) ;;
	step 33 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 34 : wff = csbeq1a () |- ( y = B → [_ A / x ]_ R = [_ B / y ]_ [_ A / x ]_ R ) ;;
	step 35 : wff = eqeq12d (step 33, step 34) |- ( y = B → ( ( A F y ) = [_ A / x ]_ R ↔ ( A F B ) = [_ B / y ]_ [_ A / x ]_ R ) ) ;;
	step 36 : wff = imbi12d (step 32, step 35) |- ( y = B → ( ( [_ A / x ]_ R ∈ _V → ( A F y ) = [_ A / x ]_ R ) ↔ ( [_ B / y ]_ [_ A / x ]_ R ∈ _V → ( A F B ) = [_ B / y ]_ [_ A / x ]_ R ) ) ) ;;
	step 37 : wff = ovmpt4g (hyp 1) |- ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x F y ) = R ) ;;
	step 38 : wff = 3expia (step 37) |- ( ( x ∈ C ∧ y ∈ D ) → ( R ∈ _V → ( x F y ) = R ) ) ;;
	step 39 : wff = vtocl2gaf (step 2, step 3, step 4, step 14, step 24, step 30, step 36, step 38) |- ( ( A ∈ C ∧ B ∈ D ) → ( [_ B / y ]_ [_ A / x ]_ R ∈ _V → ( A F B ) = [_ B / y ]_ [_ A / x ]_ R ) ) ;;
	step 40 : wff = csbcomg () |- ( ( A ∈ C ∧ B ∈ D ) → [_ A / x ]_ [_ B / y ]_ R = [_ B / y ]_ [_ A / x ]_ R ) ;;
	step 41 : wff = eleq1d (step 40) |- ( ( A ∈ C ∧ B ∈ D ) → ( [_ A / x ]_ [_ B / y ]_ R ∈ _V ↔ [_ B / y ]_ [_ A / x ]_ R ∈ _V ) ) ;;
	step 42 : wff = csbcomg () |- ( ( A ∈ C ∧ B ∈ D ) → [_ A / x ]_ [_ B / y ]_ R = [_ B / y ]_ [_ A / x ]_ R ) ;;
	step 43 : wff = eqeq2d (step 42) |- ( ( A ∈ C ∧ B ∈ D ) → ( ( A F B ) = [_ A / x ]_ [_ B / y ]_ R ↔ ( A F B ) = [_ B / y ]_ [_ A / x ]_ R ) ) ;;
	step 44 : wff = 3imtr4d (step 39, step 41, step 43) |- ( ( A ∈ C ∧ B ∈ D ) → ( [_ A / x ]_ [_ B / y ]_ R ∈ _V → ( A F B ) = [_ A / x ]_ [_ B / y ]_ R ) ) ;;
	step 45 : wff = syl5 (step 1, step 44) |- ( ( A ∈ C ∧ B ∈ D ) → ( [_ A / x ]_ [_ B / y ]_ R ∈ V → ( A F B ) = [_ A / x ]_ [_ B / y ]_ R ) ) ;;
	step 46 : wff = 3impia (step 45) |- ( ( A ∈ C ∧ B ∈ D ∧ [_ A / x ]_ [_ B / y ]_ R ∈ V ) → ( A F B ) = [_ A / x ]_ [_ B / y ]_ R ) ;;
	qed prop 1 = step 46 ;;
}

/* The value of an operation class abstraction.  A version of ~ ovmpt2g
       using bound-variable hypotheses.  (Contributed by NM, 17-Aug-2006.)
       (Revised by Mario Carneiro, 19-Dec-2013.) */

theorem ov2gf (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class, H : class) disjointed(x y C, x y D) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/_ y B ;;
	hyp 4 : wff = |- F/_ x G ;;
	hyp 5 : wff = |- F/_ y S ;;
	hyp 6 : wff = |- ( x = A → R = G ) ;;
	hyp 7 : wff = |- ( y = B → G = S ) ;;
	hyp 8 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ H ) → ( A F B ) = S ) ;;
}

proof of ov2gf {
	step 1 : wff = elex () |- ( S ∈ H → S ∈ _V ) ;;
	step 2 : wff = nfel1 (hyp 4) |- F/ x G ∈ _V ;;
	step 3 : wff = nfmpt21 () |- F/_ x ( x ∈ C , y ∈ D ↦ R ) ;;
	step 4 : wff = nfcxfr (hyp 8, step 3) |- F/_ x F ;;
	step 5 : wff = nfcv () |- F/_ x y ;;
	step 6 : wff = nfov (hyp 1, step 4, step 5) |- F/_ x ( A F y ) ;;
	step 7 : wff = nfeq (step 6, hyp 4) |- F/ x ( A F y ) = G ;;
	step 8 : wff = nfim (step 2, step 7) |- F/ x ( G ∈ _V → ( A F y ) = G ) ;;
	step 9 : wff = nfel1 (hyp 5) |- F/ y S ∈ _V ;;
	step 10 : wff = nfmpt22 () |- F/_ y ( x ∈ C , y ∈ D ↦ R ) ;;
	step 11 : wff = nfcxfr (hyp 8, step 10) |- F/_ y F ;;
	step 12 : wff = nfov (hyp 2, step 11, hyp 3) |- F/_ y ( A F B ) ;;
	step 13 : wff = nfeq (step 12, hyp 5) |- F/ y ( A F B ) = S ;;
	step 14 : wff = nfim (step 9, step 13) |- F/ y ( S ∈ _V → ( A F B ) = S ) ;;
	step 15 : wff = eleq1d (hyp 6) |- ( x = A → ( R ∈ _V ↔ G ∈ _V ) ) ;;
	step 16 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 17 : wff = eqeq12d (step 16, hyp 6) |- ( x = A → ( ( x F y ) = R ↔ ( A F y ) = G ) ) ;;
	step 18 : wff = imbi12d (step 15, step 17) |- ( x = A → ( ( R ∈ _V → ( x F y ) = R ) ↔ ( G ∈ _V → ( A F y ) = G ) ) ) ;;
	step 19 : wff = eleq1d (hyp 7) |- ( y = B → ( G ∈ _V ↔ S ∈ _V ) ) ;;
	step 20 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 21 : wff = eqeq12d (step 20, hyp 7) |- ( y = B → ( ( A F y ) = G ↔ ( A F B ) = S ) ) ;;
	step 22 : wff = imbi12d (step 19, step 21) |- ( y = B → ( ( G ∈ _V → ( A F y ) = G ) ↔ ( S ∈ _V → ( A F B ) = S ) ) ) ;;
	step 23 : wff = ovmpt4g (hyp 8) |- ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x F y ) = R ) ;;
	step 24 : wff = 3expia (step 23) |- ( ( x ∈ C ∧ y ∈ D ) → ( R ∈ _V → ( x F y ) = R ) ) ;;
	step 25 : wff = vtocl2gaf (hyp 1, hyp 2, hyp 3, step 8, step 14, step 18, step 22, step 24) |- ( ( A ∈ C ∧ B ∈ D ) → ( S ∈ _V → ( A F B ) = S ) ) ;;
	step 26 : wff = syl5 (step 1, step 25) |- ( ( A ∈ C ∧ B ∈ D ) → ( S ∈ H → ( A F B ) = S ) ) ;;
	step 27 : wff = 3impia (step 26) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ H ) → ( A F B ) = S ) ;;
	qed prop 1 = step 27 ;;
}

/* Value of an operation given by a maps-to rule, deduction form.
         (Contributed by Mario Carneiro, 29-Dec-2014.) */

theorem ovmpt2dxf (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, L : class, X : class) disjointed(x y, x A, y B) {
	hyp 1 : wff = |- ( ph → F = ( x ∈ C , y ∈ D ↦ R ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R = S ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x = A ) → D = L ) ;;
	hyp 4 : wff = |- ( ph → A ∈ C ) ;;
	hyp 5 : wff = |- ( ph → B ∈ L ) ;;
	hyp 6 : wff = |- ( ph → S ∈ X ) ;;
	hyp 7 : wff = |- F/ x ph ;;
	hyp 8 : wff = |- F/ y ph ;;
	hyp 9 : wff = |- F/_ y A ;;
	hyp 10 : wff = |- F/_ x B ;;
	hyp 11 : wff = |- F/_ x S ;;
	hyp 12 : wff = |- F/_ y S ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F B ) = S ) ;;
}

proof of ovmpt2dxf {
	step 1 : wff = oveqd (hyp 1) |- ( ph → ( A F B ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) ) ;;
	step 2 : wff = eqid () |- ( x ∈ C , y ∈ D ↦ R ) = ( x ∈ C , y ∈ D ↦ R ) ;;
	step 3 : wff = ovmpt4g (step 2) |- ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ;;
	step 4 : wff = a1i (step 3) |- ( ph → ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ;;
	step 5 : wff = alrimi (hyp 8, step 4) |- ( ph → ∀ y ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ;;
	step 6 : wff = spsbc () |- ( B ∈ L → ( ∀ y ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) → [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ) ;;
	step 7 : wff = sylc (hyp 5, step 5, step 6) |- ( ph → [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ;;
	step 8 : wff = alrimi (hyp 7, step 7) |- ( ph → ∀ x [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ;;
	step 9 : wff = spsbc () |- ( A ∈ C → ( ∀ x [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) → [. A / x ]. [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ) ;;
	step 10 : wff = sylc (hyp 4, step 8, step 9) |- ( ph → [. A / x ]. [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ;;
	step 11 : wff = adantr (hyp 5) |- ( ( ph ∧ x = A ) → B ∈ L ) ;;
	step 12 : wff = simplr () |- ( ( ( ph ∧ x = A ) ∧ y = B ) → x = A ) ;;
	step 13 : wff = ad2antrr (hyp 4) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → A ∈ C ) ;;
	step 14 : wff = eqeltrd (step 12, step 13) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → x ∈ C ) ;;
	step 15 : wff = ad2antrr (hyp 5) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → B ∈ L ) ;;
	step 16 : wff = simpr () |- ( ( ( ph ∧ x = A ) ∧ y = B ) → y = B ) ;;
	step 17 : wff = adantr (hyp 3) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → D = L ) ;;
	step 18 : wff = eleq12d (step 16, step 17) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → ( y ∈ D ↔ B ∈ L ) ) ;;
	step 19 : wff = mpbird (step 15, step 18) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → y ∈ D ) ;;
	step 20 : wff = anassrs (hyp 2) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → R = S ) ;;
	step 21 : wff = elex () |- ( S ∈ X → S ∈ _V ) ;;
	step 22 : wff = syl (hyp 6, step 21) |- ( ph → S ∈ _V ) ;;
	step 23 : wff = ad2antrr (step 22) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → S ∈ _V ) ;;
	step 24 : wff = eqeltrd (step 20, step 23) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → R ∈ _V ) ;;
	step 25 : wff = biimt () |- ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ↔ ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ) ;;
	step 26 : wff = syl3anc (step 14, step 19, step 24, step 25) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → ( ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ↔ ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ) ) ;;
	step 27 : wff = simplr () |- ( ( ( ph ∧ x = A ) ∧ y = B ) → x = A ) ;;
	step 28 : wff = simpr () |- ( ( ( ph ∧ x = A ) ∧ y = B ) → y = B ) ;;
	step 29 : wff = oveq12d (step 27, step 28) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) ) ;;
	step 30 : wff = anassrs (hyp 2) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → R = S ) ;;
	step 31 : wff = eqeq12d (step 29, step 30) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → ( ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ↔ ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 32 : wff = bitr3d (step 26, step 31) |- ( ( ( ph ∧ x = A ) ∧ y = B ) → ( ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ↔ ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 33 : wff = nfeq2 (hyp 9) |- F/ y x = A ;;
	step 34 : wff = nfan (hyp 8, step 33) |- F/ y ( ph ∧ x = A ) ;;
	step 35 : wff = nfmpt22 () |- F/_ y ( x ∈ C , y ∈ D ↦ R ) ;;
	step 36 : wff = nfcv () |- F/_ y B ;;
	step 37 : wff = nfov (hyp 9, step 35, step 36) |- F/_ y ( A ( x ∈ C , y ∈ D ↦ R ) B ) ;;
	step 38 : wff = nfeq (step 37, hyp 12) |- F/ y ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ;;
	step 39 : wff = a1i (step 38) |- ( ( ph ∧ x = A ) → F/ y ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ;;
	step 40 : wff = sbciedf (step 11, step 32, step 34, step 39) |- ( ( ph ∧ x = A ) → ( [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ↔ ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 41 : wff = nfcv () |- F/_ x A ;;
	step 42 : wff = nfmpt21 () |- F/_ x ( x ∈ C , y ∈ D ↦ R ) ;;
	step 43 : wff = nfov (step 41, step 42, hyp 10) |- F/_ x ( A ( x ∈ C , y ∈ D ↦ R ) B ) ;;
	step 44 : wff = nfeq (step 43, hyp 11) |- F/ x ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ;;
	step 45 : wff = a1i (step 44) |- ( ph → F/ x ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ;;
	step 46 : wff = sbciedf (hyp 4, step 40, hyp 7, step 45) |- ( ph → ( [. A / x ]. [. B / y ]. ( ( x ∈ C ∧ y ∈ D ∧ R ∈ _V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ↔ ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 47 : wff = mpbid (step 10, step 46) |- ( ph → ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ;;
	step 48 : wff = eqtrd (step 1, step 47) |- ( ph → ( A F B ) = S ) ;;
	qed prop 1 = step 48 ;;
}

/* Value of an operation given by a maps-to rule, deduction form.
       (Contributed by Mario Carneiro, 29-Dec-2014.) */

theorem ovmpt2dx (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, L : class, X : class) disjointed(x y, x A, y B, y A, x B, x y S, x y ph) {
	hyp 1 : wff = |- ( ph → F = ( x ∈ C , y ∈ D ↦ R ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R = S ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x = A ) → D = L ) ;;
	hyp 4 : wff = |- ( ph → A ∈ C ) ;;
	hyp 5 : wff = |- ( ph → B ∈ L ) ;;
	hyp 6 : wff = |- ( ph → S ∈ X ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F B ) = S ) ;;
}

proof of ovmpt2dx {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = nfcv () |- F/_ y A ;;
	step 4 : wff = nfcv () |- F/_ x B ;;
	step 5 : wff = nfcv () |- F/_ x S ;;
	step 6 : wff = nfcv () |- F/_ y S ;;
	step 7 : wff = ovmpt2dxf (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, hyp 6, step 1, step 2, step 3, step 4, step 5, step 6) |- ( ph → ( A F B ) = S ) ;;
	qed prop 1 = step 7 ;;
}

/* Value of an operation given by a maps-to rule, deduction form.
       (Contributed by Mario Carneiro, 7-Dec-2014.) */

theorem ovmpt2d (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, X : class) disjointed(x y A, x y B, x y S, x y ph) {
	hyp 1 : wff = |- ( ph → F = ( x ∈ C , y ∈ D ↦ R ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R = S ) ;;
	hyp 3 : wff = |- ( ph → A ∈ C ) ;;
	hyp 4 : wff = |- ( ph → B ∈ D ) ;;
	hyp 5 : wff = |- ( ph → S ∈ X ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F B ) = S ) ;;
}

proof of ovmpt2d {
	step 1 : wff = eqidd () |- ( ( ph ∧ x = A ) → D = D ) ;;
	step 2 : wff = ovmpt2dx (hyp 1, hyp 2, step 1, hyp 3, hyp 4, hyp 5) |- ( ph → ( A F B ) = S ) ;;
	qed prop 1 = step 2 ;;
}

/* The value of an operation class abstraction.  Variant of ~ ovmpt2ga
       which does not require ` D ` and ` x ` to be distinct.  (Contributed by
       Jeff Madsen, 10-Jun-2010.)  (Revised by Mario Carneiro, 20-Dec-2013.) */

theorem ovmpt2x (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, H : class, L : class) disjointed(x y A, x y B, x y C, x y L, x y S) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → R = S ) ;;
	hyp 2 : wff = |- ( x = A → D = L ) ;;
	hyp 3 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ H ) → ( A F B ) = S ) ;;
}

proof of ovmpt2x {
	step 1 : wff = elex () |- ( S ∈ H → S ∈ _V ) ;;
	step 2 : wff = a1i (hyp 3) |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) → F = ( x ∈ C , y ∈ D ↦ R ) ) ;;
	step 3 : wff = adantl (hyp 1) |- ( ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) ∧ ( x = A ∧ y = B ) ) → R = S ) ;;
	step 4 : wff = adantl (hyp 2) |- ( ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) ∧ x = A ) → D = L ) ;;
	step 5 : wff = simp1 () |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) → A ∈ C ) ;;
	step 6 : wff = simp2 () |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) → B ∈ L ) ;;
	step 7 : wff = simp3 () |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) → S ∈ _V ) ;;
	step 8 : wff = ovmpt2dx (step 2, step 3, step 4, step 5, step 6, step 7) |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ _V ) → ( A F B ) = S ) ;;
	step 9 : wff = syl3an3 (step 1, step 8) |- ( ( A ∈ C ∧ B ∈ L ∧ S ∈ H ) → ( A F B ) = S ) ;;
	qed prop 1 = step 9 ;;
}

/* Value of an operation given by a maps-to rule.  (Contributed by Mario
       Carneiro, 19-Dec-2013.) */

theorem ovmpt2ga (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, H : class) disjointed(x y A, x y B, x y C, x y D, x y S) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → R = S ) ;;
	hyp 2 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ H ) → ( A F B ) = S ) ;;
}

proof of ovmpt2ga {
	step 1 : wff = elex () |- ( S ∈ H → S ∈ _V ) ;;
	step 2 : wff = a1i (hyp 2) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → F = ( x ∈ C , y ∈ D ↦ R ) ) ;;
	step 3 : wff = adantl (hyp 1) |- ( ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) ∧ ( x = A ∧ y = B ) ) → R = S ) ;;
	step 4 : wff = simp1 () |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → A ∈ C ) ;;
	step 5 : wff = simp2 () |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → B ∈ D ) ;;
	step 6 : wff = simp3 () |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → S ∈ _V ) ;;
	step 7 : wff = ovmpt2d (step 2, step 3, step 4, step 5, step 6) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → ( A F B ) = S ) ;;
	step 8 : wff = syl3an3 (step 1, step 7) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ H ) → ( A F B ) = S ) ;;
	qed prop 1 = step 8 ;;
}

/* Value of an operation given by a maps-to rule.  (Contributed by NM,
       19-Dec-2013.) */

theorem ovmpt2a (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class) disjointed(x y A, x y B, x y C, x y D, x y S) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → R = S ) ;;
	hyp 2 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	hyp 3 : wff = |- S ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( A F B ) = S ) ;;
}

proof of ovmpt2a {
	step 1 : wff = ovmpt2ga (hyp 1, hyp 2) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → ( A F B ) = S ) ;;
	step 2 : wff = mp3an3 (hyp 3, step 1) |- ( ( A ∈ C ∧ B ∈ D ) → ( A F B ) = S ) ;;
	qed prop 1 = step 2 ;;
}

/* Alternate deduction version of ~ ovmpt2 , suitable for iteration.
         (Contributed by Mario Carneiro, 7-Jan-2017.) */

theorem ovmpt2df (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, F : class, V : class) disjointed(x y A, y B, x y ph) {
	hyp 1 : wff = |- ( ph → A ∈ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B ∈ D ) ;;
	hyp 3 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R ∈ V ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( ( A F B ) = R → ps ) ) ;;
	hyp 5 : wff = |- F/_ x F ;;
	hyp 6 : wff = |- F/ x ps ;;
	hyp 7 : wff = |- F/_ y F ;;
	hyp 8 : wff = |- F/ y ps ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ;;
}

proof of ovmpt2df {
	step 1 : wff = elex () |- ( A ∈ C → A ∈ _V ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → A ∈ _V ) ;;
	step 3 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( ph → ∃ x x = A ) ;;
	step 5 : wff = nfv () |- F/ x ph ;;
	step 6 : wff = nfmpt21 () |- F/_ x ( x ∈ C , y ∈ D ↦ R ) ;;
	step 7 : wff = nfeq (hyp 5, step 6) |- F/ x F = ( x ∈ C , y ∈ D ↦ R ) ;;
	step 8 : wff = nfim (step 7, hyp 6) |- F/ x ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ;;
	step 9 : wff = elex () |- ( B ∈ D → B ∈ _V ) ;;
	step 10 : wff = syl (hyp 2, step 9) |- ( ( ph ∧ x = A ) → B ∈ _V ) ;;
	step 11 : wff = isset () |- ( B ∈ _V ↔ ∃ y y = B ) ;;
	step 12 : wff = sylib (step 10, step 11) |- ( ( ph ∧ x = A ) → ∃ y y = B ) ;;
	step 13 : wff = nfv () |- F/ y ( ph ∧ x = A ) ;;
	step 14 : wff = nfmpt22 () |- F/_ y ( x ∈ C , y ∈ D ↦ R ) ;;
	step 15 : wff = nfeq (hyp 7, step 14) |- F/ y F = ( x ∈ C , y ∈ D ↦ R ) ;;
	step 16 : wff = nfim (step 15, hyp 8) |- F/ y ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ;;
	step 17 : wff = oveq () |- ( F = ( x ∈ C , y ∈ D ↦ R ) → ( A F B ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) ) ;;
	step 18 : wff = simprl () |- ( ( ph ∧ ( x = A ∧ y = B ) ) → x = A ) ;;
	step 19 : wff = simprr () |- ( ( ph ∧ ( x = A ∧ y = B ) ) → y = B ) ;;
	step 20 : wff = oveq12d (step 18, step 19) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) ) ;;
	step 21 : wff = simprl () |- ( ( ph ∧ ( x = A ∧ y = B ) ) → x = A ) ;;
	step 22 : wff = adantr (hyp 1) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → A ∈ C ) ;;
	step 23 : wff = eqeltrd (step 21, step 22) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → x ∈ C ) ;;
	step 24 : wff = simprr () |- ( ( ph ∧ ( x = A ∧ y = B ) ) → y = B ) ;;
	step 25 : wff = adantrr (hyp 2) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → B ∈ D ) ;;
	step 26 : wff = eqeltrd (step 24, step 25) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → y ∈ D ) ;;
	step 27 : wff = eqid () |- ( x ∈ C , y ∈ D ↦ R ) = ( x ∈ C , y ∈ D ↦ R ) ;;
	step 28 : wff = ovmpt4g (step 27) |- ( ( x ∈ C ∧ y ∈ D ∧ R ∈ V ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ;;
	step 29 : wff = syl3anc (step 23, step 26, hyp 3, step 28) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( x ( x ∈ C , y ∈ D ↦ R ) y ) = R ) ;;
	step 30 : wff = eqtr3d (step 20, step 29) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( A ( x ∈ C , y ∈ D ↦ R ) B ) = R ) ;;
	step 31 : wff = eqeq2d (step 30) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( ( A F B ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) ↔ ( A F B ) = R ) ) ;;
	step 32 : wff = sylbid (step 31, hyp 4) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( ( A F B ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) → ps ) ) ;;
	step 33 : wff = syl5 (step 17, step 32) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ;;
	step 34 : wff = expr (step 33) |- ( ( ph ∧ x = A ) → ( y = B → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ) ;;
	step 35 : wff = exlimd (step 13, step 16, step 34) |- ( ( ph ∧ x = A ) → ( ∃ y y = B → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ) ;;
	step 36 : wff = mpd (step 12, step 35) |- ( ( ph ∧ x = A ) → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ;;
	step 37 : wff = ex (step 36) |- ( ph → ( x = A → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ) ;;
	step 38 : wff = exlimd (step 5, step 8, step 37) |- ( ph → ( ∃ x x = A → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ) ;;
	step 39 : wff = mpd (step 4, step 38) |- ( ph → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ;;
	qed prop 1 = step 39 ;;
}

/* Alternate deduction version of ~ ovmpt2 , suitable for iteration.
       (Contributed by Mario Carneiro, 7-Jan-2017.) */

theorem ovmpt2dv (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, F : class, V : class) disjointed(x y A, y B, x y ph, x y F, x y ps) {
	hyp 1 : wff = |- ( ph → A ∈ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B ∈ D ) ;;
	hyp 3 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R ∈ V ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( ( A F B ) = R → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ;;
}

proof of ovmpt2dv {
	step 1 : wff = nfcv () |- F/_ x F ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = nfcv () |- F/_ y F ;;
	step 4 : wff = nfv () |- F/ y ps ;;
	step 5 : wff = ovmpt2df (hyp 1, hyp 2, hyp 3, hyp 4, step 1, step 2, step 3, step 4) |- ( ph → ( F = ( x ∈ C , y ∈ D ↦ R ) → ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Alternate deduction version of ~ ovmpt2 , suitable for iteration.
       (Contributed by Mario Carneiro, 7-Jan-2017.) */

theorem ovmpt2dv2 (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, V : class) disjointed(x y A, x y B, x y ph, x y S) {
	hyp 1 : wff = |- ( ph → A ∈ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B ∈ D ) ;;
	hyp 3 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R ∈ V ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x = A ∧ y = B ) ) → R = S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F = ( x ∈ C , y ∈ D ↦ R ) → ( A F B ) = S ) ) ;;
}

proof of ovmpt2dv2 {
	step 1 : wff = eqidd () |- ( ph → ( x ∈ C , y ∈ D ↦ R ) = ( x ∈ C , y ∈ D ↦ R ) ) ;;
	step 2 : wff = eqeq2d (hyp 4) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( ( A ( x ∈ C , y ∈ D ↦ R ) B ) = R ↔ ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 3 : wff = biimpd (step 2) |- ( ( ph ∧ ( x = A ∧ y = B ) ) → ( ( A ( x ∈ C , y ∈ D ↦ R ) B ) = R → ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 4 : wff = nfmpt21 () |- F/_ x ( x ∈ C , y ∈ D ↦ R ) ;;
	step 5 : wff = nfcv () |- F/_ x A ;;
	step 6 : wff = nfmpt21 () |- F/_ x ( x ∈ C , y ∈ D ↦ R ) ;;
	step 7 : wff = nfcv () |- F/_ x B ;;
	step 8 : wff = nfov (step 5, step 6, step 7) |- F/_ x ( A ( x ∈ C , y ∈ D ↦ R ) B ) ;;
	step 9 : wff = nfeq1 (step 8) |- F/ x ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ;;
	step 10 : wff = nfmpt22 () |- F/_ y ( x ∈ C , y ∈ D ↦ R ) ;;
	step 11 : wff = nfcv () |- F/_ y A ;;
	step 12 : wff = nfmpt22 () |- F/_ y ( x ∈ C , y ∈ D ↦ R ) ;;
	step 13 : wff = nfcv () |- F/_ y B ;;
	step 14 : wff = nfov (step 11, step 12, step 13) |- F/_ y ( A ( x ∈ C , y ∈ D ↦ R ) B ) ;;
	step 15 : wff = nfeq1 (step 14) |- F/ y ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ;;
	step 16 : wff = ovmpt2df (hyp 1, hyp 2, hyp 3, step 3, step 4, step 9, step 10, step 15) |- ( ph → ( ( x ∈ C , y ∈ D ↦ R ) = ( x ∈ C , y ∈ D ↦ R ) → ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 17 : wff = mpd (step 1, step 16) |- ( ph → ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ;;
	step 18 : wff = oveq () |- ( F = ( x ∈ C , y ∈ D ↦ R ) → ( A F B ) = ( A ( x ∈ C , y ∈ D ↦ R ) B ) ) ;;
	step 19 : wff = eqeq1d (step 18) |- ( F = ( x ∈ C , y ∈ D ↦ R ) → ( ( A F B ) = S ↔ ( A ( x ∈ C , y ∈ D ↦ R ) B ) = S ) ) ;;
	step 20 : wff = syl5ibrcom (step 17, step 19) |- ( ph → ( F = ( x ∈ C , y ∈ D ↦ R ) → ( A F B ) = S ) ) ;;
	qed prop 1 = step 20 ;;
}

/* Value of an operation given by a maps-to rule.  Special case.
       (Contributed by NM, 14-Sep-1999.)  (Revised by David Abernethy,
       19-Jun-2012.) */

theorem ovmpt2g (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class, H : class) disjointed(x y A, x y B, x y C, x y D, x y S) {
	hyp 1 : wff = |- ( x = A → R = G ) ;;
	hyp 2 : wff = |- ( y = B → G = S ) ;;
	hyp 3 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ H ) → ( A F B ) = S ) ;;
}

proof of ovmpt2g {
	step 1 : wff = sylan9eq (hyp 1, hyp 2) |- ( ( x = A ∧ y = B ) → R = S ) ;;
	step 2 : wff = ovmpt2ga (step 1, hyp 3) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ H ) → ( A F B ) = S ) ;;
	qed prop 1 = step 2 ;;
}

/* Value of an operation given by a maps-to rule.  Special case.
       (Contributed by NM, 16-May-1995.)  (Revised by David Abernethy,
       19-Jun-2012.) */

theorem ovmpt2 (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class) disjointed(x y A, x y B, x y C, x y D, x y S) {
	hyp 1 : wff = |- ( x = A → R = G ) ;;
	hyp 2 : wff = |- ( y = B → G = S ) ;;
	hyp 3 : wff = |- F = ( x ∈ C , y ∈ D ↦ R ) ;;
	hyp 4 : wff = |- S ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( A F B ) = S ) ;;
}

proof of ovmpt2 {
	step 1 : wff = ovmpt2g (hyp 1, hyp 2, hyp 3) |- ( ( A ∈ C ∧ B ∈ D ∧ S ∈ _V ) → ( A F B ) = S ) ;;
	step 2 : wff = mp3an3 (hyp 4, step 1) |- ( ( A ∈ C ∧ B ∈ D ) → ( A F B ) = S ) ;;
	qed prop 1 = step 2 ;;
}

/* The value of an operation class abstraction.  Special case.
       (Contributed by NM, 28-May-1995.)  (Revised by Mario Carneiro,
       29-Dec-2014.) */

theorem ov3 (x : set, y : set, z : set, w : set, v : set, u : set, A : class, B : class, C : class, D : class, R : class, S : class, f : set, F : class, H : class) disjointed(f u v w x y z A, f u v w x y z B, x y z R, f u v w y z C, f u v w y z D, f u v w x y z H, f u v w z S) {
	hyp 1 : wff = |- S ∈ _V ;;
	hyp 2 : wff = |- ( ( ( w = A ∧ v = B ) ∧ ( u = C ∧ f = D ) ) → R = S ) ;;
	hyp 3 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) ∧ ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( 〈 A , B 〉 F 〈 C , D 〉 ) = S ) ;;
}

proof of ov3 {
	step 1 : wff = isseti (hyp 1) |- ∃ z z = S ;;
	step 2 : wff = nfv () |- F/ z ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) ;;
	step 3 : wff = nfcv () |- F/_ z 〈 A , B 〉 ;;
	step 4 : wff = nfoprab3 () |- F/_ z { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) ∧ ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) } ;;
	step 5 : wff = nfcxfr (hyp 3, step 4) |- F/_ z F ;;
	step 6 : wff = nfcv () |- F/_ z 〈 C , D 〉 ;;
	step 7 : wff = nfov (step 3, step 5, step 6) |- F/_ z ( 〈 A , B 〉 F 〈 C , D 〉 ) ;;
	step 8 : wff = nfeq1 (step 7) |- F/ z ( 〈 A , B 〉 F 〈 C , D 〉 ) = S ;;
	step 9 : wff = eqeq2d (hyp 2) |- ( ( ( w = A ∧ v = B ) ∧ ( u = C ∧ f = D ) ) → ( z = R ↔ z = S ) ) ;;
	step 10 : wff = copsex4g (step 9) |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) ↔ z = S ) ) ;;
	step 11 : wff = opelxpi () |- ( ( A ∈ H ∧ B ∈ H ) → 〈 A , B 〉 ∈ ( H × H ) ) ;;
	step 12 : wff = opelxpi () |- ( ( C ∈ H ∧ D ∈ H ) → 〈 C , D 〉 ∈ ( H × H ) ) ;;
	step 13 : wff = nfcv () |- F/_ x 〈 A , B 〉 ;;
	step 14 : wff = nfcv () |- F/_ y 〈 A , B 〉 ;;
	step 15 : wff = nfcv () |- F/_ y 〈 C , D 〉 ;;
	step 16 : wff = nfv () |- F/ x ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ;;
	step 17 : wff = nfcv () |- F/_ x 〈 A , B 〉 ;;
	step 18 : wff = nfoprab1 () |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) ∧ ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) } ;;
	step 19 : wff = nfcxfr (hyp 3, step 18) |- F/_ x F ;;
	step 20 : wff = nfcv () |- F/_ x y ;;
	step 21 : wff = nfov (step 17, step 19, step 20) |- F/_ x ( 〈 A , B 〉 F y ) ;;
	step 22 : wff = nfeq1 (step 21) |- F/ x ( 〈 A , B 〉 F y ) = z ;;
	step 23 : wff = nfim (step 16, step 22) |- F/ x ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F y ) = z ) ;;
	step 24 : wff = nfv () |- F/ y ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) ;;
	step 25 : wff = nfcv () |- F/_ y 〈 A , B 〉 ;;
	step 26 : wff = nfoprab2 () |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) ∧ ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) } ;;
	step 27 : wff = nfcxfr (hyp 3, step 26) |- F/_ y F ;;
	step 28 : wff = nfcv () |- F/_ y 〈 C , D 〉 ;;
	step 29 : wff = nfov (step 25, step 27, step 28) |- F/_ y ( 〈 A , B 〉 F 〈 C , D 〉 ) ;;
	step 30 : wff = nfeq1 (step 29) |- F/ y ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ;;
	step 31 : wff = nfim (step 24, step 30) |- F/ y ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ) ;;
	step 32 : wff = eqeq1 () |- ( x = 〈 A , B 〉 → ( x = 〈 w , v 〉 ↔ 〈 A , B 〉 = 〈 w , v 〉 ) ) ;;
	step 33 : wff = anbi1d (step 32) |- ( x = 〈 A , B 〉 → ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ↔ ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ) ) ;;
	step 34 : wff = anbi1d (step 33) |- ( x = 〈 A , B 〉 → ( ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) ) ;;
	step 35 : wff = 4exbidv (step 34) |- ( x = 〈 A , B 〉 → ( ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) ) ;;
	step 36 : wff = oveq1 () |- ( x = 〈 A , B 〉 → ( x F y ) = ( 〈 A , B 〉 F y ) ) ;;
	step 37 : wff = eqeq1d (step 36) |- ( x = 〈 A , B 〉 → ( ( x F y ) = z ↔ ( 〈 A , B 〉 F y ) = z ) ) ;;
	step 38 : wff = imbi12d (step 35, step 37) |- ( x = 〈 A , B 〉 → ( ( ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) → ( x F y ) = z ) ↔ ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F y ) = z ) ) ) ;;
	step 39 : wff = eqeq1 () |- ( y = 〈 C , D 〉 → ( y = 〈 u , f 〉 ↔ 〈 C , D 〉 = 〈 u , f 〉 ) ) ;;
	step 40 : wff = anbi2d (step 39) |- ( y = 〈 C , D 〉 → ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ↔ ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ) ) ;;
	step 41 : wff = anbi1d (step 40) |- ( y = 〈 C , D 〉 → ( ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) ) ) ;;
	step 42 : wff = 4exbidv (step 41) |- ( y = 〈 C , D 〉 → ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) ) ) ;;
	step 43 : wff = oveq2 () |- ( y = 〈 C , D 〉 → ( 〈 A , B 〉 F y ) = ( 〈 A , B 〉 F 〈 C , D 〉 ) ) ;;
	step 44 : wff = eqeq1d (step 43) |- ( y = 〈 C , D 〉 → ( ( 〈 A , B 〉 F y ) = z ↔ ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ) ) ;;
	step 45 : wff = imbi12d (step 42, step 44) |- ( y = 〈 C , D 〉 → ( ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F y ) = z ) ↔ ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ) ) ) ;;
	step 46 : wff = moeq () |- ∃* z z = R ;;
	step 47 : wff = mosubop (step 46) |- ∃* z ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ;;
	step 48 : wff = mosubop (step 47) |- ∃* z ∃ w ∃ v ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ;;
	step 49 : wff = anass () |- ( ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ( x = 〈 w , v 〉 ∧ ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 50 : wff = 2exbii (step 49) |- ( ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃ u ∃ f ( x = 〈 w , v 〉 ∧ ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 51 : wff = 19.42vv () |- ( ∃ u ∃ f ( x = 〈 w , v 〉 ∧ ( y = 〈 u , f 〉 ∧ z = R ) ) ↔ ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 52 : wff = bitri (step 50, step 51) |- ( ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 53 : wff = 2exbii (step 52) |- ( ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃ w ∃ v ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 54 : wff = mobii (step 53) |- ( ∃* z ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ↔ ∃* z ∃ w ∃ v ( x = 〈 w , v 〉 ∧ ∃ u ∃ f ( y = 〈 u , f 〉 ∧ z = R ) ) ) ;;
	step 55 : wff = mpbir (step 48, step 54) |- ∃* z ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ;;
	step 56 : wff = a1i (step 55) |- ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) → ∃* z ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) ) ;;
	step 57 : wff = ovidi (step 56, hyp 3) |- ( ( x ∈ ( H × H ) ∧ y ∈ ( H × H ) ) → ( ∃ w ∃ v ∃ u ∃ f ( ( x = 〈 w , v 〉 ∧ y = 〈 u , f 〉 ) ∧ z = R ) → ( x F y ) = z ) ) ;;
	step 58 : wff = vtocl2gaf (step 13, step 14, step 15, step 23, step 31, step 38, step 45, step 57) |- ( ( 〈 A , B 〉 ∈ ( H × H ) ∧ 〈 C , D 〉 ∈ ( H × H ) ) → ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ) ) ;;
	step 59 : wff = syl2an (step 11, step 12, step 58) |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( ∃ w ∃ v ∃ u ∃ f ( ( 〈 A , B 〉 = 〈 w , v 〉 ∧ 〈 C , D 〉 = 〈 u , f 〉 ) ∧ z = R ) → ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ) ) ;;
	step 60 : wff = sylbird (step 10, step 59) |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( z = S → ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ) ) ;;
	step 61 : wff = eqeq2 () |- ( z = S → ( ( 〈 A , B 〉 F 〈 C , D 〉 ) = z ↔ ( 〈 A , B 〉 F 〈 C , D 〉 ) = S ) ) ;;
	step 62 : wff = mpbidi (step 60, step 61) |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( z = S → ( 〈 A , B 〉 F 〈 C , D 〉 ) = S ) ) ;;
	step 63 : wff = exlimd (step 2, step 8, step 62) |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( ∃ z z = S → ( 〈 A , B 〉 F 〈 C , D 〉 ) = S ) ) ;;
	step 64 : wff = mpi (step 1, step 63) |- ( ( ( A ∈ H ∧ B ∈ H ) ∧ ( C ∈ H ∧ D ∈ H ) ) → ( 〈 A , B 〉 F 〈 C , D 〉 ) = S ) ;;
	qed prop 1 = step 64 ;;
}

/* The value of an operation class abstraction.  Special case.
       (Contributed by NM, 13-Nov-2006.) */

theorem ov6g (x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class, G : class, H : class, J : class) disjointed(w x y z A, w x y z B, w x y z C, w z R, w x y z S) {
	hyp 1 : wff = |- ( 〈 x , y 〉 = 〈 A , B 〉 → R = S ) ;;
	hyp 2 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( 〈 x , y 〉 ∈ C ∧ z = R ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ G ∧ B ∈ H ∧ 〈 A , B 〉 ∈ C ) ∧ S ∈ J ) → ( A F B ) = S ) ;;
}

proof of ov6g {
	var w : set;;
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = eqid () |- S = S ;;
	step 3 : wff = biidd () |- ( ( x = A ∧ y = B ) → ( S = S ↔ S = S ) ) ;;
	step 4 : wff = copsex2g (step 3) |- ( ( A ∈ G ∧ B ∈ H ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) ↔ S = S ) ) ;;
	step 5 : wff = mpbiri (step 2, step 4) |- ( ( A ∈ G ∧ B ∈ H ) → ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) ) ;;
	step 6 : wff = 3adant3 (step 5) |- ( ( A ∈ G ∧ B ∈ H ∧ 〈 A , B 〉 ∈ C ) → ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( ( A ∈ G ∧ B ∈ H ∧ 〈 A , B 〉 ∈ C ) ∧ S ∈ J ) → ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) ) ;;
	step 8 : wff = eqeq1 () |- ( w = 〈 A , B 〉 → ( w = 〈 x , y 〉 ↔ 〈 A , B 〉 = 〈 x , y 〉 ) ) ;;
	step 9 : wff = anbi1d (step 8) |- ( w = 〈 A , B 〉 → ( ( w = 〈 x , y 〉 ∧ z = R ) ↔ ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = R ) ) ) ;;
	step 10 : wff = eqeq2d (hyp 1) |- ( 〈 x , y 〉 = 〈 A , B 〉 → ( z = R ↔ z = S ) ) ;;
	step 11 : wff = eqcoms (step 10) |- ( 〈 A , B 〉 = 〈 x , y 〉 → ( z = R ↔ z = S ) ) ;;
	step 12 : wff = pm5.32i (step 11) |- ( ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = R ) ↔ ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = S ) ) ;;
	step 13 : wff = syl6bb (step 9, step 12) |- ( w = 〈 A , B 〉 → ( ( w = 〈 x , y 〉 ∧ z = R ) ↔ ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = S ) ) ) ;;
	step 14 : wff = 2exbidv (step 13) |- ( w = 〈 A , B 〉 → ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ↔ ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = S ) ) ) ;;
	step 15 : wff = eqeq1 () |- ( z = S → ( z = S ↔ S = S ) ) ;;
	step 16 : wff = anbi2d (step 15) |- ( z = S → ( ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = S ) ↔ ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) ) ) ;;
	step 17 : wff = 2exbidv (step 16) |- ( z = S → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ z = S ) ↔ ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) ) ) ;;
	step 18 : wff = moeq () |- ∃* z z = R ;;
	step 19 : wff = mosubop (step 18) |- ∃* z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ;;
	step 20 : wff = a1i (step 19) |- ( w ∈ C → ∃* z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ) ;;
	step 21 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ( 〈 x , y 〉 ∈ C ∧ z = R ) } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) } ;;
	step 22 : wff = eleq1 () |- ( w = 〈 x , y 〉 → ( w ∈ C ↔ 〈 x , y 〉 ∈ C ) ) ;;
	step 23 : wff = anbi1d (step 22) |- ( w = 〈 x , y 〉 → ( ( w ∈ C ∧ z = R ) ↔ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) ) ;;
	step 24 : wff = pm5.32i (step 23) |- ( ( w = 〈 x , y 〉 ∧ ( w ∈ C ∧ z = R ) ) ↔ ( w = 〈 x , y 〉 ∧ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) ) ;;
	step 25 : wff = an12 () |- ( ( w = 〈 x , y 〉 ∧ ( w ∈ C ∧ z = R ) ) ↔ ( w ∈ C ∧ ( w = 〈 x , y 〉 ∧ z = R ) ) ) ;;
	step 26 : wff = bitr3i (step 24, step 25) |- ( ( w = 〈 x , y 〉 ∧ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) ↔ ( w ∈ C ∧ ( w = 〈 x , y 〉 ∧ z = R ) ) ) ;;
	step 27 : wff = 2exbii (step 26) |- ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) ↔ ∃ x ∃ y ( w ∈ C ∧ ( w = 〈 x , y 〉 ∧ z = R ) ) ) ;;
	step 28 : wff = 19.42vv () |- ( ∃ x ∃ y ( w ∈ C ∧ ( w = 〈 x , y 〉 ∧ z = R ) ) ↔ ( w ∈ C ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ) ) ;;
	step 29 : wff = bitri (step 27, step 28) |- ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) ↔ ( w ∈ C ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ) ) ;;
	step 30 : wff = opabbii (step 29) |- { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ( 〈 x , y 〉 ∈ C ∧ z = R ) ) } = { 〈 w , z 〉 | ( w ∈ C ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ) } ;;
	step 31 : wff = 3eqtri (hyp 2, step 21, step 30) |- F = { 〈 w , z 〉 | ( w ∈ C ∧ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ z = R ) ) } ;;
	step 32 : wff = fvopab3ig (step 14, step 17, step 20, step 31) |- ( ( 〈 A , B 〉 ∈ C ∧ S ∈ J ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) → ( F ` 〈 A , B 〉 ) = S ) ) ;;
	step 33 : wff = 3ad2antl3 (step 32) |- ( ( ( A ∈ G ∧ B ∈ H ∧ 〈 A , B 〉 ∈ C ) ∧ S ∈ J ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ S = S ) → ( F ` 〈 A , B 〉 ) = S ) ) ;;
	step 34 : wff = mpd (step 7, step 33) |- ( ( ( A ∈ G ∧ B ∈ H ∧ 〈 A , B 〉 ∈ C ) ∧ S ∈ J ) → ( F ` 〈 A , B 〉 ) = S ) ;;
	step 35 : wff = syl5eq (step 1, step 34) |- ( ( ( A ∈ G ∧ B ∈ H ∧ 〈 A , B 〉 ∈ C ) ∧ S ∈ J ) → ( A F B ) = S ) ;;
	qed prop 1 = step 35 ;;
}

/* The value of an operation class abstraction.  (Contributed by Jeff
       Madsen, 10-Jun-2010.) */

theorem ovg (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class) disjointed(ph c, ps x, ch x y, th x y z, ta x y c, R x y z c, S x y z c, A x y z c, B x y z c, C x y z c) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 4 : wff = |- ( ( ta ∧ ( x ∈ R ∧ y ∈ S ) ) → ∃! z ph ) ;;
	hyp 5 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( ( A F B ) = C ↔ th ) ) ;;
}

proof of ovg {
	var c : set;;
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = fveq1i (hyp 5) |- ( F ` 〈 A , B 〉 ) = ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( A F B ) = ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) ;;
	step 4 : wff = eqeq1i (step 3) |- ( ( A F B ) = C ↔ ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ) ;;
	step 5 : wff = eqeq2 () |- ( c = C → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = c ↔ ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ) ) ;;
	step 6 : wff = opeq2 () |- ( c = C → 〈 〈 A , B 〉 , c 〉 = 〈 〈 A , B 〉 , C 〉 ) ;;
	step 7 : wff = eleq1d (step 6) |- ( c = C → ( 〈 〈 A , B 〉 , c 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ;;
	step 8 : wff = bibi12d (step 5, step 7) |- ( c = C → ( ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = c ↔ 〈 〈 A , B 〉 , c 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ↔ ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ) ;;
	step 9 : wff = imbi2d (step 8) |- ( c = C → ( ( ( ta ∧ ( A ∈ R ∧ B ∈ S ) ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = c ↔ 〈 〈 A , B 〉 , c 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ↔ ( ( ta ∧ ( A ∈ R ∧ B ∈ S ) ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ) ) ;;
	step 10 : wff = ex (hyp 4) |- ( ta → ( ( x ∈ R ∧ y ∈ S ) → ∃! z ph ) ) ;;
	step 11 : wff = alrimivv (step 10) |- ( ta → ∀ x ∀ y ( ( x ∈ R ∧ y ∈ S ) → ∃! z ph ) ) ;;
	step 12 : wff = fnoprabg () |- ( ∀ x ∀ y ( ( x ∈ R ∧ y ∈ S ) → ∃! z ph ) → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) ;;
	step 13 : wff = syl (step 11, step 12) |- ( ta → { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) ;;
	step 14 : wff = eleq1 () |- ( x = A → ( x ∈ R ↔ A ∈ R ) ) ;;
	step 15 : wff = anbi1d (step 14) |- ( x = A → ( ( x ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ y ∈ S ) ) ) ;;
	step 16 : wff = eleq1 () |- ( y = B → ( y ∈ S ↔ B ∈ S ) ) ;;
	step 17 : wff = anbi2d (step 16) |- ( y = B → ( ( A ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 18 : wff = opelopabg (step 15, step 17) |- ( ( A ∈ R ∧ B ∈ S ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 19 : wff = ibir (step 18) |- ( ( A ∈ R ∧ B ∈ S ) → 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) ;;
	step 20 : wff = fnopfvb () |- ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } Fn { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ∧ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ R ∧ y ∈ S ) } ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = c ↔ 〈 〈 A , B 〉 , c 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ;;
	step 21 : wff = syl2an (step 13, step 19, step 20) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ) ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = c ↔ 〈 〈 A , B 〉 , c 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ;;
	step 22 : wff = vtoclg (step 9, step 21) |- ( C ∈ D → ( ( ta ∧ ( A ∈ R ∧ B ∈ S ) ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ) ;;
	step 23 : wff = com12 (step 22) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ) ) → ( C ∈ D → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ) ;;
	step 24 : wff = exp32 (step 23) |- ( ta → ( A ∈ R → ( B ∈ S → ( C ∈ D → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ) ) ) ;;
	step 25 : wff = 3imp2 (step 24) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ) ) ;;
	step 26 : wff = eleq1 () |- ( x = A → ( x ∈ R ↔ A ∈ R ) ) ;;
	step 27 : wff = anbi1d (step 26) |- ( x = A → ( ( x ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ y ∈ S ) ) ) ;;
	step 28 : wff = anbi12d (step 27, hyp 1) |- ( x = A → ( ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) ↔ ( ( A ∈ R ∧ y ∈ S ) ∧ ps ) ) ) ;;
	step 29 : wff = eleq1 () |- ( y = B → ( y ∈ S ↔ B ∈ S ) ) ;;
	step 30 : wff = anbi2d (step 29) |- ( y = B → ( ( A ∈ R ∧ y ∈ S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 31 : wff = anbi12d (step 30, hyp 2) |- ( y = B → ( ( ( A ∈ R ∧ y ∈ S ) ∧ ps ) ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ ch ) ) ) ;;
	step 32 : wff = anbi2d (hyp 3) |- ( z = C → ( ( ( A ∈ R ∧ B ∈ S ) ∧ ch ) ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 33 : wff = eloprabg (step 28, step 31, step 32) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 34 : wff = adantl (step 33) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( 〈 〈 A , B 〉 , C 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 35 : wff = bitrd (step 25, step 34) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( ( { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ R ∧ y ∈ S ) ∧ ph ) } ` 〈 A , B 〉 ) = C ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 36 : wff = syl5bb (step 4, step 35) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( ( A F B ) = C ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 37 : wff = biidd () |- ( ( A ∈ R ∧ B ∈ S ) → ( ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ↔ ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ) ) ;;
	step 38 : wff = bianabs (step 37) |- ( ( A ∈ R ∧ B ∈ S ) → ( ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ↔ th ) ) ;;
	step 39 : wff = 3adant3 (step 38) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) → ( ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ↔ th ) ) ;;
	step 40 : wff = adantl (step 39) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( ( ( A ∈ R ∧ B ∈ S ) ∧ th ) ↔ th ) ) ;;
	step 41 : wff = bitrd (step 36, step 40) |- ( ( ta ∧ ( A ∈ R ∧ B ∈ S ∧ C ∈ D ) ) → ( ( A F B ) = C ↔ th ) ) ;;
	qed prop 1 = step 41 ;;
}

/* The value of a restricted operation.  (Contributed by FL, 10-Nov-2006.) */

theorem ovres (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( A ( F ↾ ( C × D ) ) B ) = ( A F B ) ) ;;
}

proof of ovres {
	step 1 : wff = opelxpi () |- ( ( A ∈ C ∧ B ∈ D ) → 〈 A , B 〉 ∈ ( C × D ) ) ;;
	step 2 : wff = fvres () |- ( 〈 A , B 〉 ∈ ( C × D ) → ( ( F ↾ ( C × D ) ) ` 〈 A , B 〉 ) = ( F ` 〈 A , B 〉 ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ( A ∈ C ∧ B ∈ D ) → ( ( F ↾ ( C × D ) ) ` 〈 A , B 〉 ) = ( F ` 〈 A , B 〉 ) ) ;;
	step 4 : wff = df-ov () |- ( A ( F ↾ ( C × D ) ) B ) = ( ( F ↾ ( C × D ) ) ` 〈 A , B 〉 ) ;;
	step 5 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 6 : wff = 3eqtr4g (step 3, step 4, step 5) |- ( ( A ∈ C ∧ B ∈ D ) → ( A ( F ↾ ( C × D ) ) B ) = ( A F B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Lemma for converting metric theorems to metric space theorems.
       (Contributed by Mario Carneiro, 2-Oct-2015.) */

theorem ovresd (ph : wff, A : class, B : class, D : class, X : class)  {
	hyp 1 : wff = |- ( ph → A ∈ X ) ;;
	hyp 2 : wff = |- ( ph → B ∈ X ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ( D ↾ ( X × X ) ) B ) = ( A D B ) ) ;;
}

proof of ovresd {
	step 1 : wff = ovres () |- ( ( A ∈ X ∧ B ∈ X ) → ( A ( D ↾ ( X × X ) ) B ) = ( A D B ) ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → ( A ( D ↾ ( X × X ) ) B ) = ( A D B ) ) ;;
	qed prop 1 = step 2 ;;
}

/* The value of a member of the domain of a subclass of an operation.
     (Contributed by NM, 23-Aug-2007.) */

theorem oprssov (A : class, B : class, C : class, D : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A F B ) = ( A G B ) ) ;;
}

proof of oprssov {
	step 1 : wff = ovres () |- ( ( A ∈ C ∧ B ∈ D ) → ( A ( F ↾ ( C × D ) ) B ) = ( A F B ) ) ;;
	step 2 : wff = adantl (step 1) |- ( ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A ( F ↾ ( C × D ) ) B ) = ( A F B ) ) ;;
	step 3 : wff = fndm () |- ( G Fn ( C × D ) → dom G = ( C × D ) ) ;;
	step 4 : wff = reseq2d (step 3) |- ( G Fn ( C × D ) → ( F ↾ dom G ) = ( F ↾ ( C × D ) ) ) ;;
	step 5 : wff = 3ad2ant2 (step 4) |- ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) → ( F ↾ dom G ) = ( F ↾ ( C × D ) ) ) ;;
	step 6 : wff = funssres () |- ( ( Fun F ∧ G ⊆ F ) → ( F ↾ dom G ) = G ) ;;
	step 7 : wff = 3adant2 (step 6) |- ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) → ( F ↾ dom G ) = G ) ;;
	step 8 : wff = eqtr3d (step 5, step 7) |- ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) → ( F ↾ ( C × D ) ) = G ) ;;
	step 9 : wff = oveqd (step 8) |- ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) → ( A ( F ↾ ( C × D ) ) B ) = ( A G B ) ) ;;
	step 10 : wff = adantr (step 9) |- ( ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A ( F ↾ ( C × D ) ) B ) = ( A G B ) ) ;;
	step 11 : wff = eqtr3d (step 2, step 10) |- ( ( ( Fun F ∧ G Fn ( C × D ) ∧ G ⊆ F ) ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A F B ) = ( A G B ) ) ;;
	qed prop 1 = step 11 ;;
}

/* An operation's value belongs to its codomain.  (Contributed by NM,
     27-Aug-2006.) */

theorem fovrn (A : class, B : class, C : class, R : class, S : class, F : class)  {
	prop 1 : wff = |- ( ( F : ( R × S ) ⟶ C ∧ A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
}

proof of fovrn {
	step 1 : wff = opelxpi () |- ( ( A ∈ R ∧ B ∈ S ) → 〈 A , B 〉 ∈ ( R × S ) ) ;;
	step 2 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 3 : wff = ffvelrn () |- ( ( F : ( R × S ) ⟶ C ∧ 〈 A , B 〉 ∈ ( R × S ) ) → ( F ` 〈 A , B 〉 ) ∈ C ) ;;
	step 4 : wff = syl5eqel (step 2, step 3) |- ( ( F : ( R × S ) ⟶ C ∧ 〈 A , B 〉 ∈ ( R × S ) ) → ( A F B ) ∈ C ) ;;
	step 5 : wff = sylan2 (step 1, step 4) |- ( ( F : ( R × S ) ⟶ C ∧ ( A ∈ R ∧ B ∈ S ) ) → ( A F B ) ∈ C ) ;;
	step 6 : wff = 3impb (step 5) |- ( ( F : ( R × S ) ⟶ C ∧ A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
	qed prop 1 = step 6 ;;
}

/* An operation's value belongs to its codomain.  (Contributed by Mario
       Carneiro, 29-Dec-2016.) */

theorem fovrnda (ph : wff, A : class, B : class, C : class, R : class, S : class, F : class)  {
	hyp 1 : wff = |- ( ph → F : ( R × S ) ⟶ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ R ∧ B ∈ S ) ) → ( A F B ) ∈ C ) ;;
}

proof of fovrnda {
	step 1 : wff = fovrn () |- ( ( F : ( R × S ) ⟶ C ∧ A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
	step 2 : wff = syl3an1 (hyp 1, step 1) |- ( ( ph ∧ A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
	step 3 : wff = 3expb (step 2) |- ( ( ph ∧ ( A ∈ R ∧ B ∈ S ) ) → ( A F B ) ∈ C ) ;;
	qed prop 1 = step 3 ;;
}

/* An operation's value belongs to its codomain.  (Contributed by Mario
       Carneiro, 29-Dec-2016.) */

theorem fovrnd (ph : wff, A : class, B : class, C : class, R : class, S : class, F : class)  {
	hyp 1 : wff = |- ( ph → F : ( R × S ) ⟶ C ) ;;
	hyp 2 : wff = |- ( ph → A ∈ R ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F B ) ∈ C ) ;;
}

proof of fovrnd {
	step 1 : wff = fovrn () |- ( ( F : ( R × S ) ⟶ C ∧ A ∈ R ∧ B ∈ S ) → ( A F B ) ∈ C ) ;;
	step 2 : wff = syl3anc (hyp 1, hyp 2, hyp 3, step 1) |- ( ph → ( A F B ) ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/* The range of an operation expressed as a collection of the operation's
       values.  (Contributed by NM, 29-Oct-2006.) */

theorem fnrnov (x : set, y : set, z : set, A : class, B : class, F : class) disjointed(w x y z A, w x y z B, w z, w x y z F) {
	prop 1 : wff = |- ( F Fn ( A × B ) → ran F = { z | ∃ x ∈ A ∃ y ∈ B z = ( x F y ) } ) ;;
}

proof of fnrnov {
	var w : set;;
	step 1 : wff = fnrnfv () |- ( F Fn ( A × B ) → ran F = { z | ∃ w ∈ ( A × B ) z = ( F ` w ) } ) ;;
	step 2 : wff = fveq2 () |- ( w = 〈 x , y 〉 → ( F ` w ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( w = 〈 x , y 〉 → ( F ` w ) = ( x F y ) ) ;;
	step 5 : wff = eqeq2d (step 4) |- ( w = 〈 x , y 〉 → ( z = ( F ` w ) ↔ z = ( x F y ) ) ) ;;
	step 6 : wff = rexxp (step 5) |- ( ∃ w ∈ ( A × B ) z = ( F ` w ) ↔ ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ) ;;
	step 7 : wff = abbii (step 6) |- { z | ∃ w ∈ ( A × B ) z = ( F ` w ) } = { z | ∃ x ∈ A ∃ y ∈ B z = ( x F y ) } ;;
	step 8 : wff = syl6eq (step 1, step 7) |- ( F Fn ( A × B ) → ran F = { z | ∃ x ∈ A ∃ y ∈ B z = ( x F y ) } ) ;;
	qed prop 1 = step 8 ;;
}

/* An onto mapping of an operation expressed in terms of operation values.
       (Contributed by NM, 29-Oct-2006.) */

theorem foov (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(w x y z A, w x y z B, w z C, w x y z F) {
	prop 1 : wff = |- ( F : ( A × B ) ↠ C ↔ ( F : ( A × B ) ⟶ C ∧ ∀ z ∈ C ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ) ) ;;
}

proof of foov {
	var w : set;;
	step 1 : wff = dffo3 () |- ( F : ( A × B ) ↠ C ↔ ( F : ( A × B ) ⟶ C ∧ ∀ z ∈ C ∃ w ∈ ( A × B ) z = ( F ` w ) ) ) ;;
	step 2 : wff = fveq2 () |- ( w = 〈 x , y 〉 → ( F ` w ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( w = 〈 x , y 〉 → ( F ` w ) = ( x F y ) ) ;;
	step 5 : wff = eqeq2d (step 4) |- ( w = 〈 x , y 〉 → ( z = ( F ` w ) ↔ z = ( x F y ) ) ) ;;
	step 6 : wff = rexxp (step 5) |- ( ∃ w ∈ ( A × B ) z = ( F ` w ) ↔ ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ) ;;
	step 7 : wff = ralbii (step 6) |- ( ∀ z ∈ C ∃ w ∈ ( A × B ) z = ( F ` w ) ↔ ∀ z ∈ C ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ) ;;
	step 8 : wff = anbi2i (step 7) |- ( ( F : ( A × B ) ⟶ C ∧ ∀ z ∈ C ∃ w ∈ ( A × B ) z = ( F ` w ) ) ↔ ( F : ( A × B ) ⟶ C ∧ ∀ z ∈ C ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( F : ( A × B ) ↠ C ↔ ( F : ( A × B ) ⟶ C ∧ ∀ z ∈ C ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/* An operation's value belongs to its range.  (Contributed by NM,
     10-Feb-2007.) */

theorem fnovrn (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ C ∈ A ∧ D ∈ B ) → ( C F D ) ∈ ran F ) ;;
}

proof of fnovrn {
	step 1 : wff = opelxpi () |- ( ( C ∈ A ∧ D ∈ B ) → 〈 C , D 〉 ∈ ( A × B ) ) ;;
	step 2 : wff = df-ov () |- ( C F D ) = ( F ` 〈 C , D 〉 ) ;;
	step 3 : wff = fnfvelrn () |- ( ( F Fn ( A × B ) ∧ 〈 C , D 〉 ∈ ( A × B ) ) → ( F ` 〈 C , D 〉 ) ∈ ran F ) ;;
	step 4 : wff = syl5eqel (step 2, step 3) |- ( ( F Fn ( A × B ) ∧ 〈 C , D 〉 ∈ ( A × B ) ) → ( C F D ) ∈ ran F ) ;;
	step 5 : wff = sylan2 (step 1, step 4) |- ( ( F Fn ( A × B ) ∧ ( C ∈ A ∧ D ∈ B ) ) → ( C F D ) ∈ ran F ) ;;
	step 6 : wff = 3impb (step 5) |- ( ( F Fn ( A × B ) ∧ C ∈ A ∧ D ∈ B ) → ( C F D ) ∈ ran F ) ;;
	qed prop 1 = step 6 ;;
}

/* A member of an operation's range is a value of the operation.
       (Contributed by NM, 7-Feb-2007.)  (Revised by Mario Carneiro,
       30-Jan-2014.) */

theorem ovelrn (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z F) {
	prop 1 : wff = |- ( F Fn ( A × B ) → ( C ∈ ran F ↔ ∃ x ∈ A ∃ y ∈ B C = ( x F y ) ) ) ;;
}

proof of ovelrn {
	var z : set;;
	step 1 : wff = fnrnov () |- ( F Fn ( A × B ) → ran F = { z | ∃ x ∈ A ∃ y ∈ B z = ( x F y ) } ) ;;
	step 2 : wff = eleq2d (step 1) |- ( F Fn ( A × B ) → ( C ∈ ran F ↔ C ∈ { z | ∃ x ∈ A ∃ y ∈ B z = ( x F y ) } ) ) ;;
	step 3 : wff = ovex () |- ( x F y ) ∈ _V ;;
	step 4 : wff = eleq1 () |- ( C = ( x F y ) → ( C ∈ _V ↔ ( x F y ) ∈ _V ) ) ;;
	step 5 : wff = mpbiri (step 3, step 4) |- ( C = ( x F y ) → C ∈ _V ) ;;
	step 6 : wff = rexlimivw (step 5) |- ( ∃ y ∈ B C = ( x F y ) → C ∈ _V ) ;;
	step 7 : wff = rexlimivw (step 6) |- ( ∃ x ∈ A ∃ y ∈ B C = ( x F y ) → C ∈ _V ) ;;
	step 8 : wff = eqeq1 () |- ( z = C → ( z = ( x F y ) ↔ C = ( x F y ) ) ) ;;
	step 9 : wff = 2rexbidv (step 8) |- ( z = C → ( ∃ x ∈ A ∃ y ∈ B z = ( x F y ) ↔ ∃ x ∈ A ∃ y ∈ B C = ( x F y ) ) ) ;;
	step 10 : wff = elab3 (step 7, step 9) |- ( C ∈ { z | ∃ x ∈ A ∃ y ∈ B z = ( x F y ) } ↔ ∃ x ∈ A ∃ y ∈ B C = ( x F y ) ) ;;
	step 11 : wff = syl6bb (step 2, step 10) |- ( F Fn ( A × B ) → ( C ∈ ran F ↔ ∃ x ∈ A ∃ y ∈ B C = ( x F y ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Membership relation for the values of a function whose image is a
       subclass.  (Contributed by Mario Carneiro, 23-Dec-2013.) */

theorem funimassov (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z F) {
	prop 1 : wff = |- ( ( Fun F ∧ ( A × B ) ⊆ dom F ) → ( ( F " ( A × B ) ) ⊆ C ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ) ;;
}

proof of funimassov {
	var z : set;;
	step 1 : wff = funimass4 () |- ( ( Fun F ∧ ( A × B ) ⊆ dom F ) → ( ( F " ( A × B ) ) ⊆ C ↔ ∀ z ∈ ( A × B ) ( F ` z ) ∈ C ) ) ;;
	step 2 : wff = fveq2 () |- ( z = 〈 x , y 〉 → ( F ` z ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( z = 〈 x , y 〉 → ( F ` z ) = ( x F y ) ) ;;
	step 5 : wff = eleq1d (step 4) |- ( z = 〈 x , y 〉 → ( ( F ` z ) ∈ C ↔ ( x F y ) ∈ C ) ) ;;
	step 6 : wff = ralxp (step 5) |- ( ∀ z ∈ ( A × B ) ( F ` z ) ∈ C ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ;;
	step 7 : wff = syl6bb (step 1, step 6) |- ( ( Fun F ∧ ( A × B ) ⊆ dom F ) → ( ( F " ( A × B ) ) ⊆ C ↔ ∀ x ∈ A ∀ y ∈ B ( x F y ) ∈ C ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Operation value in an image.  (Contributed by Mario Carneiro,
       23-Dec-2013.)  (Revised by Mario Carneiro, 29-Jan-2014.) */

theorem ovelimab (x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z F) {
	prop 1 : wff = |- ( ( F Fn A ∧ ( B × C ) ⊆ A ) → ( D ∈ ( F " ( B × C ) ) ↔ ∃ x ∈ B ∃ y ∈ C D = ( x F y ) ) ) ;;
}

proof of ovelimab {
	var z : set;;
	step 1 : wff = fvelimab () |- ( ( F Fn A ∧ ( B × C ) ⊆ A ) → ( D ∈ ( F " ( B × C ) ) ↔ ∃ z ∈ ( B × C ) ( F ` z ) = D ) ) ;;
	step 2 : wff = fveq2 () |- ( z = 〈 x , y 〉 → ( F ` z ) = ( F ` 〈 x , y 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( z = 〈 x , y 〉 → ( F ` z ) = ( x F y ) ) ;;
	step 5 : wff = eqeq1d (step 4) |- ( z = 〈 x , y 〉 → ( ( F ` z ) = D ↔ ( x F y ) = D ) ) ;;
	step 6 : wff = eqcom () |- ( ( x F y ) = D ↔ D = ( x F y ) ) ;;
	step 7 : wff = syl6bb (step 5, step 6) |- ( z = 〈 x , y 〉 → ( ( F ` z ) = D ↔ D = ( x F y ) ) ) ;;
	step 8 : wff = rexxp (step 7) |- ( ∃ z ∈ ( B × C ) ( F ` z ) = D ↔ ∃ x ∈ B ∃ y ∈ C D = ( x F y ) ) ;;
	step 9 : wff = syl6bb (step 1, step 8) |- ( ( F Fn A ∧ ( B × C ) ⊆ A ) → ( D ∈ ( F " ( B × C ) ) ↔ ∃ x ∈ B ∃ y ∈ C D = ( x F y ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/* The value of a constant operation.  (Contributed by NM, 5-Nov-2006.) */

theorem ovconst2 (A : class, B : class, C : class, R : class, S : class)  {
	hyp 1 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( R ∈ A ∧ S ∈ B ) → ( R ( ( A × B ) × { C } ) S ) = C ) ;;
}

proof of ovconst2 {
	step 1 : wff = df-ov () |- ( R ( ( A × B ) × { C } ) S ) = ( ( ( A × B ) × { C } ) ` 〈 R , S 〉 ) ;;
	step 2 : wff = opelxpi () |- ( ( R ∈ A ∧ S ∈ B ) → 〈 R , S 〉 ∈ ( A × B ) ) ;;
	step 3 : wff = fvconst2 (hyp 1) |- ( 〈 R , S 〉 ∈ ( A × B ) → ( ( ( A × B ) × { C } ) ` 〈 R , S 〉 ) = C ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ( R ∈ A ∧ S ∈ B ) → ( ( ( A × B ) × { C } ) ` 〈 R , S 〉 ) = C ) ;;
	step 5 : wff = syl5eq (step 1, step 4) |- ( ( R ∈ A ∧ S ∈ B ) → ( R ( ( A × B ) × { C } ) S ) = C ) ;;
	qed prop 1 = step 5 ;;
}

/* Existence of a class abstraction of existentially restricted sets.
       Variables ` x ` and ` y ` are normally free-variable parameters in the
       class expression substituted for ` C ` , which can be thought of as
       ` C ( x , y ) ` .  See comments for ~ abrexex .  (Contributed by NM,
       20-Sep-2011.) */

theorem ab2rexex (x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x z A, y z B, z C) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { z | ∃ x ∈ A ∃ y ∈ B z = C } ∈ _V ;;
}

proof of ab2rexex {
	step 1 : wff = abrexex (hyp 2) |- { z | ∃ y ∈ B z = C } ∈ _V ;;
	step 2 : wff = abrexex2 (hyp 1, step 1) |- { z | ∃ x ∈ A ∃ y ∈ B z = C } ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/* Existence of an existentially restricted class abstraction. ` ph ` is
       normally has free-variable parameters ` x ` , ` y ` , and ` z ` .
       Compare ~ abrexex2 .  (Contributed by NM, 20-Sep-2011.) */

theorem ab2rexex2 (ph : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x z A, y z B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- { z | ph } ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { z | ∃ x ∈ A ∃ y ∈ B ph } ∈ _V ;;
}

proof of ab2rexex2 {
	step 1 : wff = abrexex2 (hyp 2, hyp 3) |- { z | ∃ y ∈ B ph } ∈ _V ;;
	step 2 : wff = abrexex2 (hyp 1, step 1) |- { z | ∃ x ∈ A ∃ y ∈ B ph } ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/* Domain of closure of an operation.  (Contributed by NM, 24-Aug-1995.) */

theorem oprssdm (x : set, y : set, S : class, F : class) disjointed(x y S, x y F) {
	hyp 1 : wff = |- ¬ ∅ ∈ S ;;
	hyp 2 : wff = |- ( ( x ∈ S ∧ y ∈ S ) → ( x F y ) ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( S × S ) ⊆ dom F ;;
}

proof of oprssdm {
	step 1 : wff = relxp () |- Rel ( S × S ) ;;
	step 2 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( S × S ) ↔ ( x ∈ S ∧ y ∈ S ) ) ;;
	step 3 : wff = df-ov () |- ( x F y ) = ( F ` 〈 x , y 〉 ) ;;
	step 4 : wff = syl5eqelr (step 3, hyp 2) |- ( ( x ∈ S ∧ y ∈ S ) → ( F ` 〈 x , y 〉 ) ∈ S ) ;;
	step 5 : wff = ndmfv () |- ( ¬ 〈 x , y 〉 ∈ dom F → ( F ` 〈 x , y 〉 ) = ∅ ) ;;
	step 6 : wff = eleq1d (step 5) |- ( ¬ 〈 x , y 〉 ∈ dom F → ( ( F ` 〈 x , y 〉 ) ∈ S ↔ ∅ ∈ S ) ) ;;
	step 7 : wff = mtbiri (hyp 1, step 6) |- ( ¬ 〈 x , y 〉 ∈ dom F → ¬ ( F ` 〈 x , y 〉 ) ∈ S ) ;;
	step 8 : wff = con4i (step 7) |- ( ( F ` 〈 x , y 〉 ) ∈ S → 〈 x , y 〉 ∈ dom F ) ;;
	step 9 : wff = syl (step 4, step 8) |- ( ( x ∈ S ∧ y ∈ S ) → 〈 x , y 〉 ∈ dom F ) ;;
	step 10 : wff = sylbi (step 2, step 9) |- ( 〈 x , y 〉 ∈ ( S × S ) → 〈 x , y 〉 ∈ dom F ) ;;
	step 11 : wff = relssi (step 1, step 10) |- ( S × S ) ⊆ dom F ;;
	qed prop 1 = step 11 ;;
}

/* The value of an operation outside its domain.  (Contributed by NM,
     28-Mar-2008.) */

theorem ndmovg (A : class, B : class, R : class, S : class, F : class)  {
	prop 1 : wff = |- ( ( dom F = ( R × S ) ∧ ¬ ( A ∈ R ∧ B ∈ S ) ) → ( A F B ) = ∅ ) ;;
}

proof of ndmovg {
	step 1 : wff = df-ov () |- ( A F B ) = ( F ` 〈 A , B 〉 ) ;;
	step 2 : wff = eleq2 () |- ( dom F = ( R × S ) → ( 〈 A , B 〉 ∈ dom F ↔ 〈 A , B 〉 ∈ ( R × S ) ) ) ;;
	step 3 : wff = opelxp () |- ( 〈 A , B 〉 ∈ ( R × S ) ↔ ( A ∈ R ∧ B ∈ S ) ) ;;
	step 4 : wff = syl6bb (step 2, step 3) |- ( dom F = ( R × S ) → ( 〈 A , B 〉 ∈ dom F ↔ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 5 : wff = notbid (step 4) |- ( dom F = ( R × S ) → ( ¬ 〈 A , B 〉 ∈ dom F ↔ ¬ ( A ∈ R ∧ B ∈ S ) ) ) ;;
	step 6 : wff = ndmfv () |- ( ¬ 〈 A , B 〉 ∈ dom F → ( F ` 〈 A , B 〉 ) = ∅ ) ;;
	step 7 : wff = syl6bir (step 5, step 6) |- ( dom F = ( R × S ) → ( ¬ ( A ∈ R ∧ B ∈ S ) → ( F ` 〈 A , B 〉 ) = ∅ ) ) ;;
	step 8 : wff = imp (step 7) |- ( ( dom F = ( R × S ) ∧ ¬ ( A ∈ R ∧ B ∈ S ) ) → ( F ` 〈 A , B 〉 ) = ∅ ) ;;
	step 9 : wff = syl5eq (step 1, step 8) |- ( ( dom F = ( R × S ) ∧ ¬ ( A ∈ R ∧ B ∈ S ) ) → ( A F B ) = ∅ ) ;;
	qed prop 1 = step 9 ;;
}

/* The value of an operation outside its domain.  (Contributed by NM,
       24-Aug-1995.) */

theorem ndmov (A : class, B : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ∅ ) ;;
}

proof of ndmov {
	step 1 : wff = ndmovg () |- ( ( dom F = ( S × S ) ∧ ¬ ( A ∈ S ∧ B ∈ S ) ) → ( A F B ) = ∅ ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ∅ ) ;;
	qed prop 1 = step 2 ;;
}

/* The closure of an operation outside its domain, when the domain
         includes the empty set.  This technical lemma can make the operation
         more convenient to work in some cases.  It is dependent on our
         particular definitions of operation value, function value, and ordered
         pair.  (Contributed by NM, 24-Sep-2004.) */

theorem ndmovcl (A : class, B : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	hyp 2 : wff = |- ( ( A ∈ S ∧ B ∈ S ) → ( A F B ) ∈ S ) ;;
	hyp 3 : wff = |- ∅ ∈ S ;;
	-----------------------
	prop 1 : wff = |- ( A F B ) ∈ S ;;
}

proof of ndmovcl {
	step 1 : wff = ndmov (hyp 1) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ∅ ) ;;
	step 2 : wff = syl6eqel (step 1, hyp 3) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) ∈ S ) ;;
	step 3 : wff = pm2.61i (hyp 2, step 2) |- ( A F B ) ∈ S ;;
	qed prop 1 = step 3 ;;
}

/* Reverse closure law, when an operation's domain doesn't contain the
         empty set.  (Contributed by NM, 3-Feb-1996.) */

theorem ndmovrcl (A : class, B : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	hyp 2 : wff = |- ¬ ∅ ∈ S ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) ∈ S → ( A ∈ S ∧ B ∈ S ) ) ;;
}

proof of ndmovrcl {
	step 1 : wff = ndmov (hyp 1) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ∅ ) ;;
	step 2 : wff = eleq1d (step 1) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( ( A F B ) ∈ S ↔ ∅ ∈ S ) ) ;;
	step 3 : wff = mtbiri (hyp 2, step 2) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ¬ ( A F B ) ∈ S ) ;;
	step 4 : wff = con4i (step 3) |- ( ( A F B ) ∈ S → ( A ∈ S ∧ B ∈ S ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Any operation is commutative outside its domain.  (Contributed by NM,
       24-Aug-1995.) */

theorem ndmovcom (A : class, B : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ( B F A ) ) ;;
}

proof of ndmovcom {
	step 1 : wff = ndmov (hyp 1) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ∅ ) ;;
	step 2 : wff = ancom () |- ( ( A ∈ S ∧ B ∈ S ) ↔ ( B ∈ S ∧ A ∈ S ) ) ;;
	step 3 : wff = ndmov (hyp 1) |- ( ¬ ( B ∈ S ∧ A ∈ S ) → ( B F A ) = ∅ ) ;;
	step 4 : wff = sylnbi (step 2, step 3) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( B F A ) = ∅ ) ;;
	step 5 : wff = eqtr4d (step 1, step 4) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A F B ) = ( B F A ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Any operation is associative outside its domain, if the domain doesn't
         contain the empty set.  (Contributed by NM, 24-Aug-1995.) */

theorem ndmovass (A : class, B : class, C : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	hyp 2 : wff = |- ¬ ∅ ∈ S ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
}

proof of ndmovass {
	step 1 : wff = ndmovrcl (hyp 1, hyp 2) |- ( ( A F B ) ∈ S → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 2 : wff = anim1i (step 1) |- ( ( ( A F B ) ∈ S ∧ C ∈ S ) → ( ( A ∈ S ∧ B ∈ S ) ∧ C ∈ S ) ) ;;
	step 3 : wff = df-3an () |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ↔ ( ( A ∈ S ∧ B ∈ S ) ∧ C ∈ S ) ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( ( ( A F B ) ∈ S ∧ C ∈ S ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ¬ ( ( A F B ) ∈ S ∧ C ∈ S ) ) ;;
	step 6 : wff = ndmov (hyp 1) |- ( ¬ ( ( A F B ) ∈ S ∧ C ∈ S ) → ( ( A F B ) F C ) = ∅ ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ( A F B ) F C ) = ∅ ) ;;
	step 8 : wff = ndmovrcl (hyp 1, hyp 2) |- ( ( B F C ) ∈ S → ( B ∈ S ∧ C ∈ S ) ) ;;
	step 9 : wff = anim2i (step 8) |- ( ( A ∈ S ∧ ( B F C ) ∈ S ) → ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ) ;;
	step 10 : wff = 3anass () |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ↔ ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ) ;;
	step 11 : wff = sylibr (step 9, step 10) |- ( ( A ∈ S ∧ ( B F C ) ∈ S ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 12 : wff = con3i (step 11) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ¬ ( A ∈ S ∧ ( B F C ) ∈ S ) ) ;;
	step 13 : wff = ndmov (hyp 1) |- ( ¬ ( A ∈ S ∧ ( B F C ) ∈ S ) → ( A F ( B F C ) ) = ∅ ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( A F ( B F C ) ) = ∅ ) ;;
	step 15 : wff = eqtr4d (step 7, step 14) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Any operation is distributive outside its domain, if the domain
         doesn't contain the empty set.  (Contributed by NM, 24-Aug-1995.) */

theorem ndmovdistr (A : class, B : class, C : class, S : class, F : class, G : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	hyp 2 : wff = |- ¬ ∅ ∈ S ;;
	hyp 3 : wff = |- dom G = ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( A G ( B F C ) ) = ( ( A G B ) F ( A G C ) ) ) ;;
}

proof of ndmovdistr {
	step 1 : wff = ndmovrcl (hyp 1, hyp 2) |- ( ( B F C ) ∈ S → ( B ∈ S ∧ C ∈ S ) ) ;;
	step 2 : wff = anim2i (step 1) |- ( ( A ∈ S ∧ ( B F C ) ∈ S ) → ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ) ;;
	step 3 : wff = 3anass () |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ↔ ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( ( A ∈ S ∧ ( B F C ) ∈ S ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ¬ ( A ∈ S ∧ ( B F C ) ∈ S ) ) ;;
	step 6 : wff = ndmov (hyp 3) |- ( ¬ ( A ∈ S ∧ ( B F C ) ∈ S ) → ( A G ( B F C ) ) = ∅ ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( A G ( B F C ) ) = ∅ ) ;;
	step 8 : wff = ndmovrcl (hyp 3, hyp 2) |- ( ( A G B ) ∈ S → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 9 : wff = ndmovrcl (hyp 3, hyp 2) |- ( ( A G C ) ∈ S → ( A ∈ S ∧ C ∈ S ) ) ;;
	step 10 : wff = anim12i (step 8, step 9) |- ( ( ( A G B ) ∈ S ∧ ( A G C ) ∈ S ) → ( ( A ∈ S ∧ B ∈ S ) ∧ ( A ∈ S ∧ C ∈ S ) ) ) ;;
	step 11 : wff = 3anass () |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ↔ ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ) ;;
	step 12 : wff = anandi () |- ( ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ↔ ( ( A ∈ S ∧ B ∈ S ) ∧ ( A ∈ S ∧ C ∈ S ) ) ) ;;
	step 13 : wff = bitri (step 11, step 12) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ↔ ( ( A ∈ S ∧ B ∈ S ) ∧ ( A ∈ S ∧ C ∈ S ) ) ) ;;
	step 14 : wff = sylibr (step 10, step 13) |- ( ( ( A G B ) ∈ S ∧ ( A G C ) ∈ S ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 15 : wff = con3i (step 14) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ¬ ( ( A G B ) ∈ S ∧ ( A G C ) ∈ S ) ) ;;
	step 16 : wff = ndmov (hyp 1) |- ( ¬ ( ( A G B ) ∈ S ∧ ( A G C ) ∈ S ) → ( ( A G B ) F ( A G C ) ) = ∅ ) ;;
	step 17 : wff = syl (step 15, step 16) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ( A G B ) F ( A G C ) ) = ∅ ) ;;
	step 18 : wff = eqtr4d (step 7, step 17) |- ( ¬ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( A G ( B F C ) ) = ( ( A G B ) F ( A G C ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Elimination of redundant antecedents in an ordering law.  (Contributed
       by NM, 7-Mar-1996.) */

theorem ndmovord (A : class, B : class, C : class, R : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	hyp 3 : wff = |- ¬ ∅ ∈ S ;;
	hyp 4 : wff = |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
}

proof of ndmovord {
	step 1 : wff = 3expia (hyp 4) |- ( ( A ∈ S ∧ B ∈ S ) → ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ) ;;
	step 2 : wff = brel (hyp 2) |- ( A R B → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 3 : wff = brel (hyp 2) |- ( ( C F A ) R ( C F B ) → ( ( C F A ) ∈ S ∧ ( C F B ) ∈ S ) ) ;;
	step 4 : wff = ndmovrcl (hyp 1, hyp 3) |- ( ( C F A ) ∈ S → ( C ∈ S ∧ A ∈ S ) ) ;;
	step 5 : wff = simprd (step 4) |- ( ( C F A ) ∈ S → A ∈ S ) ;;
	step 6 : wff = ndmovrcl (hyp 1, hyp 3) |- ( ( C F B ) ∈ S → ( C ∈ S ∧ B ∈ S ) ) ;;
	step 7 : wff = simprd (step 6) |- ( ( C F B ) ∈ S → B ∈ S ) ;;
	step 8 : wff = anim12i (step 5, step 7) |- ( ( ( C F A ) ∈ S ∧ ( C F B ) ∈ S ) → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 9 : wff = syl (step 3, step 8) |- ( ( C F A ) R ( C F B ) → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 10 : wff = pm5.21ni (step 2, step 9) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 11 : wff = a1d (step 10) |- ( ¬ ( A ∈ S ∧ B ∈ S ) → ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ) ;;
	step 12 : wff = pm2.61i (step 1, step 11) |- ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Elimination of redundant antecedent in an ordering law.  (Contributed by
       NM, 25-Jun-1998.) */

theorem ndmovordi (A : class, B : class, C : class, R : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = ( S × S ) ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	hyp 3 : wff = |- ¬ ∅ ∈ S ;;
	hyp 4 : wff = |- ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( C F A ) R ( C F B ) → A R B ) ;;
}

proof of ndmovordi {
	step 1 : wff = brel (hyp 2) |- ( ( C F A ) R ( C F B ) → ( ( C F A ) ∈ S ∧ ( C F B ) ∈ S ) ) ;;
	step 2 : wff = simpld (step 1) |- ( ( C F A ) R ( C F B ) → ( C F A ) ∈ S ) ;;
	step 3 : wff = ndmovrcl (hyp 1, hyp 3) |- ( ( C F A ) ∈ S → ( C ∈ S ∧ A ∈ S ) ) ;;
	step 4 : wff = simpld (step 3) |- ( ( C F A ) ∈ S → C ∈ S ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( ( C F A ) R ( C F B ) → C ∈ S ) ;;
	step 6 : wff = biimprd (hyp 4) |- ( C ∈ S → ( ( C F A ) R ( C F B ) → A R B ) ) ;;
	step 7 : wff = mpcom (step 5, step 6) |- ( ( C F A ) R ( C F B ) → A R B ) ;;
	qed prop 1 = step 7 ;;
}

/* Convert an operation closure law to class notation.  (Contributed by
       Mario Carneiro, 26-May-2014.) */

theorem caovclg (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, E : class, F : class) disjointed(x y A, y B, x y C, x y D, x y E, x y ph, x y F) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ C ∧ y ∈ D ) ) → ( x F y ) ∈ E ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A F B ) ∈ E ) ;;
}

proof of caovclg {
	step 1 : wff = ralrimivva (hyp 1) |- ( ph → ∀ x ∈ C ∀ y ∈ D ( x F y ) ∈ E ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 3 : wff = eleq1d (step 2) |- ( x = A → ( ( x F y ) ∈ E ↔ ( A F y ) ∈ E ) ) ;;
	step 4 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 5 : wff = eleq1d (step 4) |- ( y = B → ( ( A F y ) ∈ E ↔ ( A F B ) ∈ E ) ) ;;
	step 6 : wff = rspc2v (step 3, step 5) |- ( ( A ∈ C ∧ B ∈ D ) → ( ∀ x ∈ C ∀ y ∈ D ( x F y ) ∈ E → ( A F B ) ∈ E ) ) ;;
	step 7 : wff = mpan9 (step 1, step 6) |- ( ( ph ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A F B ) ∈ E ) ;;
	qed prop 1 = step 7 ;;
}

/* Convert an operation closure law to class notation.  (Contributed by
       Mario Carneiro, 30-Dec-2014.) */

theorem caovcld (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, E : class, F : class) disjointed(x y A, y B, x y C, x y D, x y E, x y ph, x y F) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ C ∧ y ∈ D ) ) → ( x F y ) ∈ E ) ;;
	hyp 2 : wff = |- ( ph → A ∈ C ) ;;
	hyp 3 : wff = |- ( ph → B ∈ D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F B ) ∈ E ) ;;
}

proof of caovcld {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovclg (hyp 1) |- ( ( ph ∧ ( A ∈ C ∧ B ∈ D ) ) → ( A F B ) ∈ E ) ;;
	step 3 : wff = syl12anc (step 1, hyp 2, hyp 3, step 2) |- ( ph → ( A F B ) ∈ E ) ;;
	qed prop 1 = step 3 ;;
}

/* Convert an operation closure law to class notation.  (Contributed by NM,
       4-Aug-1995.)  (Revised by Mario Carneiro, 26-May-2014.) */

theorem caovcl (x : set, y : set, A : class, B : class, S : class, F : class) disjointed(x y A, y B, x y F, x y, x y S) {
	hyp 1 : wff = |- ( ( x ∈ S ∧ y ∈ S ) → ( x F y ) ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ S ∧ B ∈ S ) → ( A F B ) ∈ S ) ;;
}

proof of caovcl {
	step 1 : wff = tru () |- T. ;;
	step 2 : wff = adantl (hyp 1) |- ( ( T. ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) ∈ S ) ;;
	step 3 : wff = caovclg (step 2) |- ( ( T. ∧ ( A ∈ S ∧ B ∈ S ) ) → ( A F B ) ∈ S ) ;;
	step 4 : wff = mpan (step 1, step 3) |- ( ( A ∈ S ∧ B ∈ S ) → ( A F B ) ∈ S ) ;;
	qed prop 1 = step 4 ;;
}

/* General laws for commutative, associative, distributive operations. */

/* Convert an operation commutative law to class notation.  (Contributed
         by Mario Carneiro, 1-Jun-2013.) */

theorem caovcomg (ph : wff, x : set, y : set, A : class, B : class, S : class, F : class) disjointed(x y A, x y B, x y, x y, x y ph, x y F, x y, x y, x y, x y, x y S, x y) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ) ) → ( A F B ) = ( B F A ) ) ;;
}

proof of caovcomg {
	step 1 : wff = ralrimivva (hyp 1) |- ( ph → ∀ x ∈ S ∀ y ∈ S ( x F y ) = ( y F x ) ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 3 : wff = oveq2 () |- ( x = A → ( y F x ) = ( y F A ) ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( x = A → ( ( x F y ) = ( y F x ) ↔ ( A F y ) = ( y F A ) ) ) ;;
	step 5 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 6 : wff = oveq1 () |- ( y = B → ( y F A ) = ( B F A ) ) ;;
	step 7 : wff = eqeq12d (step 5, step 6) |- ( y = B → ( ( A F y ) = ( y F A ) ↔ ( A F B ) = ( B F A ) ) ) ;;
	step 8 : wff = rspc2v (step 4, step 7) |- ( ( A ∈ S ∧ B ∈ S ) → ( ∀ x ∈ S ∀ y ∈ S ( x F y ) = ( y F x ) → ( A F B ) = ( B F A ) ) ) ;;
	step 9 : wff = mpan9 (step 1, step 8) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ) ) → ( A F B ) = ( B F A ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Convert an operation commutative law to class notation.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovcomd (ph : wff, x : set, y : set, A : class, B : class, S : class, F : class) disjointed(x y A, x y B, x y, x y, x y ph, x y F, x y, x y, x y, x y, x y S, x y) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F B ) = ( B F A ) ) ;;
}

proof of caovcomd {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovcomg (hyp 1) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ) ) → ( A F B ) = ( B F A ) ) ;;
	step 3 : wff = syl12anc (step 1, hyp 2, hyp 3, step 2) |- ( ph → ( A F B ) = ( B F A ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Convert an operation commutative law to class notation.  (Contributed
         by NM, 26-Aug-1995.)  (Revised by Mario Carneiro, 1-Jun-2013.) */

theorem caovcom (x : set, y : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y, x y, x y, x y F, x y, x y, x y, x y, x y, x y) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( x F y ) = ( y F x ) ;;
	-----------------------
	prop 1 : wff = |- ( A F B ) = ( B F A ) ;;
}

proof of caovcom {
	step 1 : wff = pm3.2i (hyp 1, hyp 2) |- ( A ∈ _V ∧ B ∈ _V ) ;;
	step 2 : wff = a1i (hyp 3) |- ( ( A ∈ _V ∧ ( x ∈ _V ∧ y ∈ _V ) ) → ( x F y ) = ( y F x ) ) ;;
	step 3 : wff = caovcomg (step 2) |- ( ( A ∈ _V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( A F B ) = ( B F A ) ) ;;
	step 4 : wff = mp2an (hyp 1, step 1, step 3) |- ( A F B ) = ( B F A ) ;;
	qed prop 1 = step 4 ;;
}

/* Convert an operation associative law to class notation.  (Contributed
         by Mario Carneiro, 1-Jun-2013.)  (Revised by Mario Carneiro,
         26-May-2014.) */

theorem caovassg (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
}

proof of caovassg {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ S ∀ y ∈ S ∀ z ∈ S ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 3 : wff = oveq1d (step 2) |- ( x = A → ( ( x F y ) F z ) = ( ( A F y ) F z ) ) ;;
	step 4 : wff = oveq1 () |- ( x = A → ( x F ( y F z ) ) = ( A F ( y F z ) ) ) ;;
	step 5 : wff = eqeq12d (step 3, step 4) |- ( x = A → ( ( ( x F y ) F z ) = ( x F ( y F z ) ) ↔ ( ( A F y ) F z ) = ( A F ( y F z ) ) ) ) ;;
	step 6 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 7 : wff = oveq1d (step 6) |- ( y = B → ( ( A F y ) F z ) = ( ( A F B ) F z ) ) ;;
	step 8 : wff = oveq1 () |- ( y = B → ( y F z ) = ( B F z ) ) ;;
	step 9 : wff = oveq2d (step 8) |- ( y = B → ( A F ( y F z ) ) = ( A F ( B F z ) ) ) ;;
	step 10 : wff = eqeq12d (step 7, step 9) |- ( y = B → ( ( ( A F y ) F z ) = ( A F ( y F z ) ) ↔ ( ( A F B ) F z ) = ( A F ( B F z ) ) ) ) ;;
	step 11 : wff = oveq2 () |- ( z = C → ( ( A F B ) F z ) = ( ( A F B ) F C ) ) ;;
	step 12 : wff = oveq2 () |- ( z = C → ( B F z ) = ( B F C ) ) ;;
	step 13 : wff = oveq2d (step 12) |- ( z = C → ( A F ( B F z ) ) = ( A F ( B F C ) ) ) ;;
	step 14 : wff = eqeq12d (step 11, step 13) |- ( z = C → ( ( ( A F B ) F z ) = ( A F ( B F z ) ) ↔ ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ) ;;
	step 15 : wff = rspc3v (step 5, step 10, step 14) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ∀ x ∈ S ∀ y ∈ S ∀ z ∈ S ( ( x F y ) F z ) = ( x F ( y F z ) ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ) ;;
	step 16 : wff = mpan9 (step 1, step 15) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Convert an operation associative law to class notation.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovassd (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
}

proof of caovassd {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovassg (hyp 1) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	step 3 : wff = syl13anc (step 1, hyp 2, hyp 3, hyp 4, step 2) |- ( ph → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Convert an operation associative law to class notation.  (Contributed
         by NM, 26-Aug-1995.)  (Revised by Mario Carneiro, 26-May-2014.) */

theorem caovass (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) F C ) = ( A F ( B F C ) ) ;;
}

proof of caovass {
	step 1 : wff = tru () |- T. ;;
	step 2 : wff = a1i (hyp 4) |- ( ( T. ∧ ( x ∈ _V ∧ y ∈ _V ∧ z ∈ _V ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	step 3 : wff = caovassg (step 2) |- ( ( T. ∧ ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	step 4 : wff = mpan (step 1, step 3) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	step 5 : wff = mp3an (hyp 1, hyp 2, hyp 3, step 4) |- ( ( A F B ) F C ) = ( A F ( B F C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Convert an operation cancellation law to class notation.  (Contributed
         by NM, 20-Aug-1995.)  (Revised by Mario Carneiro, 30-Dec-2014.) */

theorem caovcang (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, T : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z T) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ T ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) = ( x F z ) ↔ y = z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ T ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ;;
}

proof of caovcang {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ T ∀ y ∈ S ∀ z ∈ S ( ( x F y ) = ( x F z ) ↔ y = z ) ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 3 : wff = oveq1 () |- ( x = A → ( x F z ) = ( A F z ) ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( x = A → ( ( x F y ) = ( x F z ) ↔ ( A F y ) = ( A F z ) ) ) ;;
	step 5 : wff = bibi1d (step 4) |- ( x = A → ( ( ( x F y ) = ( x F z ) ↔ y = z ) ↔ ( ( A F y ) = ( A F z ) ↔ y = z ) ) ) ;;
	step 6 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 7 : wff = eqeq1d (step 6) |- ( y = B → ( ( A F y ) = ( A F z ) ↔ ( A F B ) = ( A F z ) ) ) ;;
	step 8 : wff = eqeq1 () |- ( y = B → ( y = z ↔ B = z ) ) ;;
	step 9 : wff = bibi12d (step 7, step 8) |- ( y = B → ( ( ( A F y ) = ( A F z ) ↔ y = z ) ↔ ( ( A F B ) = ( A F z ) ↔ B = z ) ) ) ;;
	step 10 : wff = oveq2 () |- ( z = C → ( A F z ) = ( A F C ) ) ;;
	step 11 : wff = eqeq2d (step 10) |- ( z = C → ( ( A F B ) = ( A F z ) ↔ ( A F B ) = ( A F C ) ) ) ;;
	step 12 : wff = eqeq2 () |- ( z = C → ( B = z ↔ B = C ) ) ;;
	step 13 : wff = bibi12d (step 11, step 12) |- ( z = C → ( ( ( A F B ) = ( A F z ) ↔ B = z ) ↔ ( ( A F B ) = ( A F C ) ↔ B = C ) ) ) ;;
	step 14 : wff = rspc3v (step 5, step 9, step 13) |- ( ( A ∈ T ∧ B ∈ S ∧ C ∈ S ) → ( ∀ x ∈ T ∀ y ∈ S ∀ z ∈ S ( ( x F y ) = ( x F z ) ↔ y = z ) → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ) ;;
	step 15 : wff = mpan9 (step 1, step 14) |- ( ( ph ∧ ( A ∈ T ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Convert an operation cancellation law to class notation.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovcand (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, T : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z T) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ T ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) = ( x F z ) ↔ y = z ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ T ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ;;
}

proof of caovcand {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovcang (hyp 1) |- ( ( ph ∧ ( A ∈ T ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ;;
	step 3 : wff = syl13anc (step 1, hyp 2, hyp 3, hyp 4, step 2) |- ( ph → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Commute the arguments of an operation cancellation law.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovcanrd (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, T : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z T) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ T ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) = ( x F z ) ↔ y = z ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ T ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	hyp 5 : wff = |- ( ph → A ∈ S ) ;;
	hyp 6 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( B F A ) = ( C F A ) ↔ B = C ) ) ;;
}

proof of caovcanrd {
	step 1 : wff = caovcomd (hyp 6, hyp 5, hyp 3) |- ( ph → ( A F B ) = ( B F A ) ) ;;
	step 2 : wff = caovcomd (hyp 6, hyp 5, hyp 4) |- ( ph → ( A F C ) = ( C F A ) ) ;;
	step 3 : wff = eqeq12d (step 1, step 2) |- ( ph → ( ( A F B ) = ( A F C ) ↔ ( B F A ) = ( C F A ) ) ) ;;
	step 4 : wff = caovcand (hyp 1, hyp 2, hyp 3, hyp 4) |- ( ph → ( ( A F B ) = ( A F C ) ↔ B = C ) ) ;;
	step 5 : wff = bitr3d (step 3, step 4) |- ( ph → ( ( B F A ) = ( C F A ) ↔ B = C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Convert an operation cancellation law to class notation.  (Contributed
         by NM, 20-Aug-1995.) */

theorem caovcan (x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- C ∈ _V ;;
	hyp 2 : wff = |- ( ( x ∈ S ∧ y ∈ S ) → ( ( x F y ) = ( x F z ) → y = z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ S ∧ B ∈ S ) → ( ( A F B ) = ( A F C ) → B = C ) ) ;;
}

proof of caovcan {
	step 1 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x F C ) = ( A F C ) ) ;;
	step 3 : wff = eqeq12d (step 1, step 2) |- ( x = A → ( ( x F y ) = ( x F C ) ↔ ( A F y ) = ( A F C ) ) ) ;;
	step 4 : wff = imbi1d (step 3) |- ( x = A → ( ( ( x F y ) = ( x F C ) → y = C ) ↔ ( ( A F y ) = ( A F C ) → y = C ) ) ) ;;
	step 5 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 6 : wff = eqeq1d (step 5) |- ( y = B → ( ( A F y ) = ( A F C ) ↔ ( A F B ) = ( A F C ) ) ) ;;
	step 7 : wff = eqeq1 () |- ( y = B → ( y = C ↔ B = C ) ) ;;
	step 8 : wff = imbi12d (step 6, step 7) |- ( y = B → ( ( ( A F y ) = ( A F C ) → y = C ) ↔ ( ( A F B ) = ( A F C ) → B = C ) ) ) ;;
	step 9 : wff = oveq2 () |- ( z = C → ( x F z ) = ( x F C ) ) ;;
	step 10 : wff = eqeq2d (step 9) |- ( z = C → ( ( x F y ) = ( x F z ) ↔ ( x F y ) = ( x F C ) ) ) ;;
	step 11 : wff = eqeq2 () |- ( z = C → ( y = z ↔ y = C ) ) ;;
	step 12 : wff = imbi12d (step 10, step 11) |- ( z = C → ( ( ( x F y ) = ( x F z ) → y = z ) ↔ ( ( x F y ) = ( x F C ) → y = C ) ) ) ;;
	step 13 : wff = imbi2d (step 12) |- ( z = C → ( ( ( x ∈ S ∧ y ∈ S ) → ( ( x F y ) = ( x F z ) → y = z ) ) ↔ ( ( x ∈ S ∧ y ∈ S ) → ( ( x F y ) = ( x F C ) → y = C ) ) ) ) ;;
	step 14 : wff = vtocl (hyp 1, step 13, hyp 2) |- ( ( x ∈ S ∧ y ∈ S ) → ( ( x F y ) = ( x F C ) → y = C ) ) ;;
	step 15 : wff = vtocl2ga (step 4, step 8, step 14) |- ( ( A ∈ S ∧ B ∈ S ) → ( ( A F B ) = ( A F C ) → B = C ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Convert an operation ordering law to class notation.  (Contributed by
         Mario Carneiro, 31-Dec-2014.) */

theorem caovordig (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x R y → ( z F x ) R ( z F y ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( A R B → ( C F A ) R ( C F B ) ) ) ;;
}

proof of caovordig {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ S ∀ y ∈ S ∀ z ∈ S ( x R y → ( z F x ) R ( z F y ) ) ) ;;
	step 2 : wff = breq1 () |- ( x = A → ( x R y ↔ A R y ) ) ;;
	step 3 : wff = oveq2 () |- ( x = A → ( z F x ) = ( z F A ) ) ;;
	step 4 : wff = breq1d (step 3) |- ( x = A → ( ( z F x ) R ( z F y ) ↔ ( z F A ) R ( z F y ) ) ) ;;
	step 5 : wff = imbi12d (step 2, step 4) |- ( x = A → ( ( x R y → ( z F x ) R ( z F y ) ) ↔ ( A R y → ( z F A ) R ( z F y ) ) ) ) ;;
	step 6 : wff = breq2 () |- ( y = B → ( A R y ↔ A R B ) ) ;;
	step 7 : wff = oveq2 () |- ( y = B → ( z F y ) = ( z F B ) ) ;;
	step 8 : wff = breq2d (step 7) |- ( y = B → ( ( z F A ) R ( z F y ) ↔ ( z F A ) R ( z F B ) ) ) ;;
	step 9 : wff = imbi12d (step 6, step 8) |- ( y = B → ( ( A R y → ( z F A ) R ( z F y ) ) ↔ ( A R B → ( z F A ) R ( z F B ) ) ) ) ;;
	step 10 : wff = oveq1 () |- ( z = C → ( z F A ) = ( C F A ) ) ;;
	step 11 : wff = oveq1 () |- ( z = C → ( z F B ) = ( C F B ) ) ;;
	step 12 : wff = breq12d (step 10, step 11) |- ( z = C → ( ( z F A ) R ( z F B ) ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 13 : wff = imbi2d (step 12) |- ( z = C → ( ( A R B → ( z F A ) R ( z F B ) ) ↔ ( A R B → ( C F A ) R ( C F B ) ) ) ) ;;
	step 14 : wff = rspc3v (step 5, step 9, step 13) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ∀ x ∈ S ∀ y ∈ S ∀ z ∈ S ( x R y → ( z F x ) R ( z F y ) ) → ( A R B → ( C F A ) R ( C F B ) ) ) ) ;;
	step 15 : wff = mpan9 (step 1, step 14) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( A R B → ( C F A ) R ( C F B ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Convert an operation ordering law to class notation.  (Contributed by
         Mario Carneiro, 31-Dec-2014.) */

theorem caovordid (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x R y → ( z F x ) R ( z F y ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A R B → ( C F A ) R ( C F B ) ) ) ;;
}

proof of caovordid {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovordig (hyp 1) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( A R B → ( C F A ) R ( C F B ) ) ) ;;
	step 3 : wff = syl13anc (step 1, hyp 2, hyp 3, hyp 4, step 2) |- ( ph → ( A R B → ( C F A ) R ( C F B ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Convert an operation ordering law to class notation.  (Contributed by
         NM, 19-Feb-1996.)  (Revised by Mario Carneiro, 30-Dec-2014.) */

theorem caovordg (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
}

proof of caovordg {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ S ∀ y ∈ S ∀ z ∈ S ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	step 2 : wff = breq1 () |- ( x = A → ( x R y ↔ A R y ) ) ;;
	step 3 : wff = oveq2 () |- ( x = A → ( z F x ) = ( z F A ) ) ;;
	step 4 : wff = breq1d (step 3) |- ( x = A → ( ( z F x ) R ( z F y ) ↔ ( z F A ) R ( z F y ) ) ) ;;
	step 5 : wff = bibi12d (step 2, step 4) |- ( x = A → ( ( x R y ↔ ( z F x ) R ( z F y ) ) ↔ ( A R y ↔ ( z F A ) R ( z F y ) ) ) ) ;;
	step 6 : wff = breq2 () |- ( y = B → ( A R y ↔ A R B ) ) ;;
	step 7 : wff = oveq2 () |- ( y = B → ( z F y ) = ( z F B ) ) ;;
	step 8 : wff = breq2d (step 7) |- ( y = B → ( ( z F A ) R ( z F y ) ↔ ( z F A ) R ( z F B ) ) ) ;;
	step 9 : wff = bibi12d (step 6, step 8) |- ( y = B → ( ( A R y ↔ ( z F A ) R ( z F y ) ) ↔ ( A R B ↔ ( z F A ) R ( z F B ) ) ) ) ;;
	step 10 : wff = oveq1 () |- ( z = C → ( z F A ) = ( C F A ) ) ;;
	step 11 : wff = oveq1 () |- ( z = C → ( z F B ) = ( C F B ) ) ;;
	step 12 : wff = breq12d (step 10, step 11) |- ( z = C → ( ( z F A ) R ( z F B ) ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 13 : wff = bibi2d (step 12) |- ( z = C → ( ( A R B ↔ ( z F A ) R ( z F B ) ) ↔ ( A R B ↔ ( C F A ) R ( C F B ) ) ) ) ;;
	step 14 : wff = rspc3v (step 5, step 9, step 13) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ∀ x ∈ S ∀ y ∈ S ∀ z ∈ S ( x R y ↔ ( z F x ) R ( z F y ) ) → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ) ;;
	step 15 : wff = mpan9 (step 1, step 14) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Convert an operation ordering law to class notation.  (Contributed by
         Mario Carneiro, 30-Dec-2014.) */

theorem caovordd (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
}

proof of caovordd {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovordg (hyp 1) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 3 : wff = syl13anc (step 1, hyp 2, hyp 3, hyp 4, step 2) |- ( ph → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Operation ordering law with commuted arguments.  (Contributed by Mario
         Carneiro, 30-Dec-2014.) */

theorem caovord2d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A R B ↔ ( A F C ) R ( B F C ) ) ) ;;
}

proof of caovord2d {
	step 1 : wff = caovordd (hyp 1, hyp 2, hyp 3, hyp 4) |- ( ph → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 2 : wff = caovcomd (hyp 5, hyp 4, hyp 2) |- ( ph → ( C F A ) = ( A F C ) ) ;;
	step 3 : wff = caovcomd (hyp 5, hyp 4, hyp 3) |- ( ph → ( C F B ) = ( B F C ) ) ;;
	step 4 : wff = breq12d (step 2, step 3) |- ( ph → ( ( C F A ) R ( C F B ) ↔ ( A F C ) R ( B F C ) ) ) ;;
	step 5 : wff = bitrd (step 1, step 4) |- ( ph → ( A R B ↔ ( A F C ) R ( B F C ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Ordering law.  (Contributed by Mario Carneiro, 30-Dec-2014.) */

theorem caovord3d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z ph, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 6 : wff = |- ( ph → D ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) = ( C F D ) → ( A R C ↔ D R B ) ) ) ;;
}

proof of caovord3d {
	step 1 : wff = breq1 () |- ( ( A F B ) = ( C F D ) → ( ( A F B ) R ( C F B ) ↔ ( C F D ) R ( C F B ) ) ) ;;
	step 2 : wff = caovord2d (hyp 1, hyp 2, hyp 4, hyp 3, hyp 5) |- ( ph → ( A R C ↔ ( A F B ) R ( C F B ) ) ) ;;
	step 3 : wff = caovordd (hyp 1, hyp 6, hyp 3, hyp 4) |- ( ph → ( D R B ↔ ( C F D ) R ( C F B ) ) ) ;;
	step 4 : wff = bibi12d (step 2, step 3) |- ( ph → ( ( A R C ↔ D R B ) ↔ ( ( A F B ) R ( C F B ) ↔ ( C F D ) R ( C F B ) ) ) ) ;;
	step 5 : wff = syl5ibr (step 1, step 4) |- ( ph → ( ( A F B ) = ( C F D ) → ( A R C ↔ D R B ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Convert an operation ordering law to class notation.  (Contributed by
         NM, 19-Feb-1996.) */

theorem caovord (x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( z ∈ S → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
}

proof of caovord {
	step 1 : wff = oveq1 () |- ( z = C → ( z F A ) = ( C F A ) ) ;;
	step 2 : wff = oveq1 () |- ( z = C → ( z F B ) = ( C F B ) ) ;;
	step 3 : wff = breq12d (step 1, step 2) |- ( z = C → ( ( z F A ) R ( z F B ) ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 4 : wff = bibi2d (step 3) |- ( z = C → ( ( A R B ↔ ( z F A ) R ( z F B ) ) ↔ ( A R B ↔ ( C F A ) R ( C F B ) ) ) ) ;;
	step 5 : wff = breq1 () |- ( x = A → ( x R y ↔ A R y ) ) ;;
	step 6 : wff = oveq2 () |- ( x = A → ( z F x ) = ( z F A ) ) ;;
	step 7 : wff = breq1d (step 6) |- ( x = A → ( ( z F x ) R ( z F y ) ↔ ( z F A ) R ( z F y ) ) ) ;;
	step 8 : wff = bibi12d (step 5, step 7) |- ( x = A → ( ( x R y ↔ ( z F x ) R ( z F y ) ) ↔ ( A R y ↔ ( z F A ) R ( z F y ) ) ) ) ;;
	step 9 : wff = breq2 () |- ( y = B → ( A R y ↔ A R B ) ) ;;
	step 10 : wff = oveq2 () |- ( y = B → ( z F y ) = ( z F B ) ) ;;
	step 11 : wff = breq2d (step 10) |- ( y = B → ( ( z F A ) R ( z F y ) ↔ ( z F A ) R ( z F B ) ) ) ;;
	step 12 : wff = bibi12d (step 9, step 11) |- ( y = B → ( ( A R y ↔ ( z F A ) R ( z F y ) ) ↔ ( A R B ↔ ( z F A ) R ( z F B ) ) ) ) ;;
	step 13 : wff = sylan9bb (step 8, step 12) |- ( ( x = A ∧ y = B ) → ( ( x R y ↔ ( z F x ) R ( z F y ) ) ↔ ( A R B ↔ ( z F A ) R ( z F B ) ) ) ) ;;
	step 14 : wff = imbi2d (step 13) |- ( ( x = A ∧ y = B ) → ( ( z ∈ S → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ↔ ( z ∈ S → ( A R B ↔ ( z F A ) R ( z F B ) ) ) ) ) ;;
	step 15 : wff = vtocl2 (hyp 1, hyp 2, step 14, hyp 3) |- ( z ∈ S → ( A R B ↔ ( z F A ) R ( z F B ) ) ) ;;
	step 16 : wff = vtoclga (step 4, step 15) |- ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/* (We don't bother to eliminate this redundant hypothesis.) */

/* Operation ordering law with commuted arguments.  (Contributed by NM,
         27-Feb-1996.) */

theorem caovord2 (x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( z ∈ S → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	hyp 4 : wff = |- C ∈ _V ;;
	hyp 5 : wff = |- ( x F y ) = ( y F x ) ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ S → ( A R B ↔ ( A F C ) R ( B F C ) ) ) ;;
}

proof of caovord2 {
	step 1 : wff = caovord (hyp 1, hyp 2, hyp 3) |- ( C ∈ S → ( A R B ↔ ( C F A ) R ( C F B ) ) ) ;;
	step 2 : wff = caovcom (hyp 4, hyp 1, hyp 5) |- ( C F A ) = ( A F C ) ;;
	step 3 : wff = caovcom (hyp 4, hyp 2, hyp 5) |- ( C F B ) = ( B F C ) ;;
	step 4 : wff = breq12i (step 2, step 3) |- ( ( C F A ) R ( C F B ) ↔ ( A F C ) R ( B F C ) ) ;;
	step 5 : wff = syl6bb (step 1, step 4) |- ( C ∈ S → ( A R B ↔ ( A F C ) R ( B F C ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* (We don't bother to eliminate redundant hypotheses.) */

/* Ordering law.  (Contributed by NM, 29-Feb-1996.) */

theorem caovord3 (x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z, x y z F, x y z, x y z, x y z, x y z R, x y z S, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( z ∈ S → ( x R y ↔ ( z F x ) R ( z F y ) ) ) ;;
	hyp 4 : wff = |- C ∈ _V ;;
	hyp 5 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 6 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( ( B ∈ S ∧ C ∈ S ) ∧ ( A F B ) = ( C F D ) ) → ( A R C ↔ D R B ) ) ;;
}

proof of caovord3 {
	step 1 : wff = caovord2 (hyp 1, hyp 4, hyp 3, hyp 2, hyp 5) |- ( B ∈ S → ( A R C ↔ ( A F B ) R ( C F B ) ) ) ;;
	step 2 : wff = adantr (step 1) |- ( ( B ∈ S ∧ C ∈ S ) → ( A R C ↔ ( A F B ) R ( C F B ) ) ) ;;
	step 3 : wff = breq1 () |- ( ( A F B ) = ( C F D ) → ( ( A F B ) R ( C F B ) ↔ ( C F D ) R ( C F B ) ) ) ;;
	step 4 : wff = sylan9bb (step 2, step 3) |- ( ( ( B ∈ S ∧ C ∈ S ) ∧ ( A F B ) = ( C F D ) ) → ( A R C ↔ ( C F D ) R ( C F B ) ) ) ;;
	step 5 : wff = caovord (hyp 6, hyp 2, hyp 3) |- ( C ∈ S → ( D R B ↔ ( C F D ) R ( C F B ) ) ) ;;
	step 6 : wff = ad2antlr (step 5) |- ( ( ( B ∈ S ∧ C ∈ S ) ∧ ( A F B ) = ( C F D ) ) → ( D R B ↔ ( C F D ) R ( C F B ) ) ) ;;
	step 7 : wff = bitr4d (step 4, step 6) |- ( ( ( B ∈ S ∧ C ∈ S ) ∧ ( A F B ) = ( C F D ) ) → ( A R C ↔ D R B ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Convert an operation distributive law to class notation.  (Contributed
         by NM, 25-Aug-1995.)  (Revised by Mario Carneiro, 26-Jul-2014.) */

theorem caovdig (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class, G : class, H : class, K : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z G, x y z H, x y z K, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ K ∧ y ∈ S ∧ z ∈ S ) ) → ( x G ( y F z ) ) = ( ( x G y ) H ( x G z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ K ∧ B ∈ S ∧ C ∈ S ) ) → ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ;;
}

proof of caovdig {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ K ∀ y ∈ S ∀ z ∈ S ( x G ( y F z ) ) = ( ( x G y ) H ( x G z ) ) ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x G ( y F z ) ) = ( A G ( y F z ) ) ) ;;
	step 3 : wff = oveq1 () |- ( x = A → ( x G y ) = ( A G y ) ) ;;
	step 4 : wff = oveq1 () |- ( x = A → ( x G z ) = ( A G z ) ) ;;
	step 5 : wff = oveq12d (step 3, step 4) |- ( x = A → ( ( x G y ) H ( x G z ) ) = ( ( A G y ) H ( A G z ) ) ) ;;
	step 6 : wff = eqeq12d (step 2, step 5) |- ( x = A → ( ( x G ( y F z ) ) = ( ( x G y ) H ( x G z ) ) ↔ ( A G ( y F z ) ) = ( ( A G y ) H ( A G z ) ) ) ) ;;
	step 7 : wff = oveq1 () |- ( y = B → ( y F z ) = ( B F z ) ) ;;
	step 8 : wff = oveq2d (step 7) |- ( y = B → ( A G ( y F z ) ) = ( A G ( B F z ) ) ) ;;
	step 9 : wff = oveq2 () |- ( y = B → ( A G y ) = ( A G B ) ) ;;
	step 10 : wff = oveq1d (step 9) |- ( y = B → ( ( A G y ) H ( A G z ) ) = ( ( A G B ) H ( A G z ) ) ) ;;
	step 11 : wff = eqeq12d (step 8, step 10) |- ( y = B → ( ( A G ( y F z ) ) = ( ( A G y ) H ( A G z ) ) ↔ ( A G ( B F z ) ) = ( ( A G B ) H ( A G z ) ) ) ) ;;
	step 12 : wff = oveq2 () |- ( z = C → ( B F z ) = ( B F C ) ) ;;
	step 13 : wff = oveq2d (step 12) |- ( z = C → ( A G ( B F z ) ) = ( A G ( B F C ) ) ) ;;
	step 14 : wff = oveq2 () |- ( z = C → ( A G z ) = ( A G C ) ) ;;
	step 15 : wff = oveq2d (step 14) |- ( z = C → ( ( A G B ) H ( A G z ) ) = ( ( A G B ) H ( A G C ) ) ) ;;
	step 16 : wff = eqeq12d (step 13, step 15) |- ( z = C → ( ( A G ( B F z ) ) = ( ( A G B ) H ( A G z ) ) ↔ ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ) ;;
	step 17 : wff = rspc3v (step 6, step 11, step 16) |- ( ( A ∈ K ∧ B ∈ S ∧ C ∈ S ) → ( ∀ x ∈ K ∀ y ∈ S ∀ z ∈ S ( x G ( y F z ) ) = ( ( x G y ) H ( x G z ) ) → ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ) ;;
	step 18 : wff = mpan9 (step 1, step 17) |- ( ( ph ∧ ( A ∈ K ∧ B ∈ S ∧ C ∈ S ) ) → ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Convert an operation distributive law to class notation.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovdid (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class, G : class, H : class, K : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z G, x y z H, x y z K, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ K ∧ y ∈ S ∧ z ∈ S ) ) → ( x G ( y F z ) ) = ( ( x G y ) H ( x G z ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ K ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ;;
}

proof of caovdid {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovdig (hyp 1) |- ( ( ph ∧ ( A ∈ K ∧ B ∈ S ∧ C ∈ S ) ) → ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ;;
	step 3 : wff = syl13anc (step 1, hyp 2, hyp 3, hyp 4, step 2) |- ( ph → ( A G ( B F C ) ) = ( ( A G B ) H ( A G C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Convert an operation distributive law to class notation.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovdir2d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class, G : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z G, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( x G ( y F z ) ) = ( ( x G y ) F ( x G z ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ S ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) ∈ S ) ;;
	hyp 6 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x G y ) = ( y G x ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) G C ) = ( ( A G C ) F ( B G C ) ) ) ;;
}

proof of caovdir2d {
	step 1 : wff = caovdid (hyp 1, hyp 4, hyp 2, hyp 3) |- ( ph → ( C G ( A F B ) ) = ( ( C G A ) F ( C G B ) ) ) ;;
	step 2 : wff = caovcld (hyp 5, hyp 2, hyp 3) |- ( ph → ( A F B ) ∈ S ) ;;
	step 3 : wff = caovcomd (hyp 6, step 2, hyp 4) |- ( ph → ( ( A F B ) G C ) = ( C G ( A F B ) ) ) ;;
	step 4 : wff = caovcomd (hyp 6, hyp 2, hyp 4) |- ( ph → ( A G C ) = ( C G A ) ) ;;
	step 5 : wff = caovcomd (hyp 6, hyp 3, hyp 4) |- ( ph → ( B G C ) = ( C G B ) ) ;;
	step 6 : wff = oveq12d (step 4, step 5) |- ( ph → ( ( A G C ) F ( B G C ) ) = ( ( C G A ) F ( C G B ) ) ) ;;
	step 7 : wff = 3eqtr4d (step 1, step 3, step 6) |- ( ph → ( ( A F B ) G C ) = ( ( A G C ) F ( B G C ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Convert an operation reverse distributive law to class notation.
         (Contributed by Mario Carneiro, 19-Oct-2014.) */

theorem caovdirg (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class, G : class, H : class, K : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z G, x y z H, x y z K, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ K ) ) → ( ( x F y ) G z ) = ( ( x G z ) H ( y G z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ K ) ) → ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ;;
}

proof of caovdirg {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ S ∀ y ∈ S ∀ z ∈ K ( ( x F y ) G z ) = ( ( x G z ) H ( y G z ) ) ) ;;
	step 2 : wff = oveq1 () |- ( x = A → ( x F y ) = ( A F y ) ) ;;
	step 3 : wff = oveq1d (step 2) |- ( x = A → ( ( x F y ) G z ) = ( ( A F y ) G z ) ) ;;
	step 4 : wff = oveq1 () |- ( x = A → ( x G z ) = ( A G z ) ) ;;
	step 5 : wff = oveq1d (step 4) |- ( x = A → ( ( x G z ) H ( y G z ) ) = ( ( A G z ) H ( y G z ) ) ) ;;
	step 6 : wff = eqeq12d (step 3, step 5) |- ( x = A → ( ( ( x F y ) G z ) = ( ( x G z ) H ( y G z ) ) ↔ ( ( A F y ) G z ) = ( ( A G z ) H ( y G z ) ) ) ) ;;
	step 7 : wff = oveq2 () |- ( y = B → ( A F y ) = ( A F B ) ) ;;
	step 8 : wff = oveq1d (step 7) |- ( y = B → ( ( A F y ) G z ) = ( ( A F B ) G z ) ) ;;
	step 9 : wff = oveq1 () |- ( y = B → ( y G z ) = ( B G z ) ) ;;
	step 10 : wff = oveq2d (step 9) |- ( y = B → ( ( A G z ) H ( y G z ) ) = ( ( A G z ) H ( B G z ) ) ) ;;
	step 11 : wff = eqeq12d (step 8, step 10) |- ( y = B → ( ( ( A F y ) G z ) = ( ( A G z ) H ( y G z ) ) ↔ ( ( A F B ) G z ) = ( ( A G z ) H ( B G z ) ) ) ) ;;
	step 12 : wff = oveq2 () |- ( z = C → ( ( A F B ) G z ) = ( ( A F B ) G C ) ) ;;
	step 13 : wff = oveq2 () |- ( z = C → ( A G z ) = ( A G C ) ) ;;
	step 14 : wff = oveq2 () |- ( z = C → ( B G z ) = ( B G C ) ) ;;
	step 15 : wff = oveq12d (step 13, step 14) |- ( z = C → ( ( A G z ) H ( B G z ) ) = ( ( A G C ) H ( B G C ) ) ) ;;
	step 16 : wff = eqeq12d (step 12, step 15) |- ( z = C → ( ( ( A F B ) G z ) = ( ( A G z ) H ( B G z ) ) ↔ ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ) ;;
	step 17 : wff = rspc3v (step 6, step 11, step 16) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ K ) → ( ∀ x ∈ S ∀ y ∈ S ∀ z ∈ K ( ( x F y ) G z ) = ( ( x G z ) H ( y G z ) ) → ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ) ;;
	step 18 : wff = mpan9 (step 1, step 17) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ K ) ) → ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Convert an operation distributive law to class notation.  (Contributed
         by Mario Carneiro, 30-Dec-2014.) */

theorem caovdird (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class, G : class, H : class, K : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z G, x y z H, x y z K, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ K ) ) → ( ( x F y ) G z ) = ( ( x G z ) H ( y G z ) ) ) ;;
	hyp 2 : wff = |- ( ph → A ∈ S ) ;;
	hyp 3 : wff = |- ( ph → B ∈ S ) ;;
	hyp 4 : wff = |- ( ph → C ∈ K ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ;;
}

proof of caovdird {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = caovdirg (hyp 1) |- ( ( ph ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ K ) ) → ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ;;
	step 3 : wff = syl13anc (step 1, hyp 2, hyp 3, hyp 4, step 2) |- ( ph → ( ( A F B ) G C ) = ( ( A G C ) H ( B G C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Convert an operation distributive law to class notation.  (Contributed
         by NM, 25-Aug-1995.)  (Revised by Mario Carneiro, 28-Jun-2013.) */

theorem caovdi (x : set, y : set, z : set, A : class, B : class, C : class, F : class, G : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z G, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x G ( y F z ) ) = ( ( x G y ) F ( x G z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A G ( B F C ) ) = ( ( A G B ) F ( A G C ) ) ;;
}

proof of caovdi {
	step 1 : wff = tru () |- T. ;;
	step 2 : wff = a1i (hyp 4) |- ( ( T. ∧ ( x ∈ _V ∧ y ∈ _V ∧ z ∈ _V ) ) → ( x G ( y F z ) ) = ( ( x G y ) F ( x G z ) ) ) ;;
	step 3 : wff = caovdig (step 2) |- ( ( T. ∧ ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) ) → ( A G ( B F C ) ) = ( ( A G B ) F ( A G C ) ) ) ;;
	step 4 : wff = mpan (step 1, step 3) |- ( ( A ∈ _V ∧ B ∈ _V ∧ C ∈ _V ) → ( A G ( B F C ) ) = ( ( A G B ) F ( A G C ) ) ) ;;
	step 5 : wff = mp3an (hyp 1, hyp 2, hyp 3, step 4) |- ( A G ( B F C ) ) = ( ( A G B ) F ( A G C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
         30-Dec-2014.) */

theorem caov32d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) F C ) = ( ( A F C ) F B ) ) ;;
}

proof of caov32d {
	step 1 : wff = caovcomd (hyp 4, hyp 2, hyp 3) |- ( ph → ( B F C ) = ( C F B ) ) ;;
	step 2 : wff = oveq2d (step 1) |- ( ph → ( A F ( B F C ) ) = ( A F ( C F B ) ) ) ;;
	step 3 : wff = caovassd (hyp 5, hyp 1, hyp 2, hyp 3) |- ( ph → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	step 4 : wff = caovassd (hyp 5, hyp 1, hyp 3, hyp 2) |- ( ph → ( ( A F C ) F B ) = ( A F ( C F B ) ) ) ;;
	step 5 : wff = 3eqtr4d (step 2, step 3, step 4) |- ( ph → ( ( A F B ) F C ) = ( ( A F C ) F B ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
         30-Dec-2014.) */

theorem caov12d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F ( B F C ) ) = ( B F ( A F C ) ) ) ;;
}

proof of caov12d {
	step 1 : wff = caovcomd (hyp 4, hyp 1, hyp 2) |- ( ph → ( A F B ) = ( B F A ) ) ;;
	step 2 : wff = oveq1d (step 1) |- ( ph → ( ( A F B ) F C ) = ( ( B F A ) F C ) ) ;;
	step 3 : wff = caovassd (hyp 5, hyp 1, hyp 2, hyp 3) |- ( ph → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	step 4 : wff = caovassd (hyp 5, hyp 2, hyp 1, hyp 3) |- ( ph → ( ( B F A ) F C ) = ( B F ( A F C ) ) ) ;;
	step 5 : wff = 3eqtr3d (step 2, step 3, step 4) |- ( ph → ( A F ( B F C ) ) = ( B F ( A F C ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
         30-Dec-2014.) */

theorem caov31d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) F C ) = ( ( C F B ) F A ) ) ;;
}

proof of caov31d {
	step 1 : wff = caovcomd (hyp 4, hyp 1, hyp 3) |- ( ph → ( A F C ) = ( C F A ) ) ;;
	step 2 : wff = oveq1d (step 1) |- ( ph → ( ( A F C ) F B ) = ( ( C F A ) F B ) ) ;;
	step 3 : wff = caov32d (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ph → ( ( A F B ) F C ) = ( ( A F C ) F B ) ) ;;
	step 4 : wff = caov32d (hyp 3, hyp 2, hyp 1, hyp 4, hyp 5) |- ( ph → ( ( C F B ) F A ) = ( ( C F A ) F B ) ) ;;
	step 5 : wff = 3eqtr4d (step 2, step 3, step 4) |- ( ph → ( ( A F B ) F C ) = ( ( C F B ) F A ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
         30-Dec-2014.) */

theorem caov13d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A F ( B F C ) ) = ( C F ( B F A ) ) ) ;;
}

proof of caov13d {
	step 1 : wff = caov31d (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ph → ( ( A F B ) F C ) = ( ( C F B ) F A ) ) ;;
	step 2 : wff = caovassd (hyp 5, hyp 1, hyp 2, hyp 3) |- ( ph → ( ( A F B ) F C ) = ( A F ( B F C ) ) ) ;;
	step 3 : wff = caovassd (hyp 5, hyp 3, hyp 2, hyp 1) |- ( ph → ( ( C F B ) F A ) = ( C F ( B F A ) ) ) ;;
	step 4 : wff = 3eqtr3d (step 1, step 2, step 3) |- ( ph → ( A F ( B F C ) ) = ( C F ( B F A ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Rearrange arguments in a commutative, associative operation.
           (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
           30-Dec-2014.) */

theorem caov4d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	hyp 6 : wff = |- ( ph → D ∈ S ) ;;
	hyp 7 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( B F D ) ) ) ;;
}

proof of caov4d {
	step 1 : wff = caov12d (hyp 2, hyp 3, hyp 6, hyp 4, hyp 5) |- ( ph → ( B F ( C F D ) ) = ( C F ( B F D ) ) ) ;;
	step 2 : wff = oveq2d (step 1) |- ( ph → ( A F ( B F ( C F D ) ) ) = ( A F ( C F ( B F D ) ) ) ) ;;
	step 3 : wff = caovcld (hyp 7, hyp 3, hyp 6) |- ( ph → ( C F D ) ∈ S ) ;;
	step 4 : wff = caovassd (hyp 5, hyp 1, hyp 2, step 3) |- ( ph → ( ( A F B ) F ( C F D ) ) = ( A F ( B F ( C F D ) ) ) ) ;;
	step 5 : wff = caovcld (hyp 7, hyp 2, hyp 6) |- ( ph → ( B F D ) ∈ S ) ;;
	step 6 : wff = caovassd (hyp 5, hyp 1, hyp 3, step 5) |- ( ph → ( ( A F C ) F ( B F D ) ) = ( A F ( C F ( B F D ) ) ) ) ;;
	step 7 : wff = 3eqtr4d (step 2, step 4, step 6) |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( B F D ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Rearrange arguments in a commutative, associative operation.
           (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
           30-Dec-2014.) */

theorem caov411d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	hyp 6 : wff = |- ( ph → D ∈ S ) ;;
	hyp 7 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( C F B ) F ( A F D ) ) ) ;;
}

proof of caov411d {
	step 1 : wff = caov4d (hyp 2, hyp 1, hyp 3, hyp 4, hyp 5, hyp 6, hyp 7) |- ( ph → ( ( B F A ) F ( C F D ) ) = ( ( B F C ) F ( A F D ) ) ) ;;
	step 2 : wff = caovcomd (hyp 4, hyp 2, hyp 1) |- ( ph → ( B F A ) = ( A F B ) ) ;;
	step 3 : wff = oveq1d (step 2) |- ( ph → ( ( B F A ) F ( C F D ) ) = ( ( A F B ) F ( C F D ) ) ) ;;
	step 4 : wff = caovcomd (hyp 4, hyp 2, hyp 3) |- ( ph → ( B F C ) = ( C F B ) ) ;;
	step 5 : wff = oveq1d (step 4) |- ( ph → ( ( B F C ) F ( A F D ) ) = ( ( C F B ) F ( A F D ) ) ) ;;
	step 6 : wff = 3eqtr3d (step 1, step 3, step 5) |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( C F B ) F ( A F D ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Rearrange arguments in a commutative, associative operation.
           (Contributed by NM, 26-Aug-1995.)  (Revised by Mario Carneiro,
           30-Dec-2014.) */

theorem caov42d (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, S : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z ph, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z) {
	hyp 1 : wff = |- ( ph → A ∈ S ) ;;
	hyp 2 : wff = |- ( ph → B ∈ S ) ;;
	hyp 3 : wff = |- ( ph → C ∈ S ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) = ( y F x ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ∧ z ∈ S ) ) → ( ( x F y ) F z ) = ( x F ( y F z ) ) ) ;;
	hyp 6 : wff = |- ( ph → D ∈ S ) ;;
	hyp 7 : wff = |- ( ( ph ∧ ( x ∈ S ∧ y ∈ S ) ) → ( x F y ) ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( D F B ) ) ) ;;
}

proof of caov42d {
	step 1 : wff = caov4d (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, hyp 6, hyp 7) |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( B F D ) ) ) ;;
	step 2 : wff = caovcomd (hyp 4, hyp 2, hyp 6) |- ( ph → ( B F D ) = ( D F B ) ) ;;
	step 3 : wff = oveq2d (step 2) |- ( ph → ( ( A F C ) F ( B F D ) ) = ( ( A F C ) F ( D F B ) ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( ph → ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( D F B ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.) */

theorem caov32 (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) F C ) = ( ( A F C ) F B ) ;;
}

proof of caov32 {
	step 1 : wff = caovcom (hyp 2, hyp 3, hyp 4) |- ( B F C ) = ( C F B ) ;;
	step 2 : wff = oveq2i (step 1) |- ( A F ( B F C ) ) = ( A F ( C F B ) ) ;;
	step 3 : wff = caovass (hyp 1, hyp 2, hyp 3, hyp 5) |- ( ( A F B ) F C ) = ( A F ( B F C ) ) ;;
	step 4 : wff = caovass (hyp 1, hyp 3, hyp 2, hyp 5) |- ( ( A F C ) F B ) = ( A F ( C F B ) ) ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- ( ( A F B ) F C ) = ( ( A F C ) F B ) ;;
	qed prop 1 = step 5 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.) */

theorem caov12 (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A F ( B F C ) ) = ( B F ( A F C ) ) ;;
}

proof of caov12 {
	step 1 : wff = caovcom (hyp 1, hyp 2, hyp 4) |- ( A F B ) = ( B F A ) ;;
	step 2 : wff = oveq1i (step 1) |- ( ( A F B ) F C ) = ( ( B F A ) F C ) ;;
	step 3 : wff = caovass (hyp 1, hyp 2, hyp 3, hyp 5) |- ( ( A F B ) F C ) = ( A F ( B F C ) ) ;;
	step 4 : wff = caovass (hyp 2, hyp 1, hyp 3, hyp 5) |- ( ( B F A ) F C ) = ( B F ( A F C ) ) ;;
	step 5 : wff = 3eqtr3i (step 2, step 3, step 4) |- ( A F ( B F C ) ) = ( B F ( A F C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.) */

theorem caov31 (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) F C ) = ( ( C F B ) F A ) ;;
}

proof of caov31 {
	step 1 : wff = caovass (hyp 1, hyp 3, hyp 2, hyp 5) |- ( ( A F C ) F B ) = ( A F ( C F B ) ) ;;
	step 2 : wff = caov12 (hyp 1, hyp 3, hyp 2, hyp 4, hyp 5) |- ( A F ( C F B ) ) = ( C F ( A F B ) ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( ( A F C ) F B ) = ( C F ( A F B ) ) ;;
	step 4 : wff = caov32 (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ( A F B ) F C ) = ( ( A F C ) F B ) ;;
	step 5 : wff = caov32 (hyp 3, hyp 1, hyp 2, hyp 4, hyp 5) |- ( ( C F A ) F B ) = ( ( C F B ) F A ) ;;
	step 6 : wff = caovass (hyp 3, hyp 1, hyp 2, hyp 5) |- ( ( C F A ) F B ) = ( C F ( A F B ) ) ;;
	step 7 : wff = eqtr3i (step 5, step 6) |- ( ( C F B ) F A ) = ( C F ( A F B ) ) ;;
	step 8 : wff = 3eqtr4i (step 3, step 4, step 7) |- ( ( A F B ) F C ) = ( ( C F B ) F A ) ;;
	qed prop 1 = step 8 ;;
}

/* Rearrange arguments in a commutative, associative operation.
         (Contributed by NM, 26-Aug-1995.) */

theorem caov13 (x : set, y : set, z : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A F ( B F C ) ) = ( C F ( B F A ) ) ;;
}

proof of caov13 {
	step 1 : wff = caov31 (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ( A F B ) F C ) = ( ( C F B ) F A ) ;;
	step 2 : wff = caovass (hyp 1, hyp 2, hyp 3, hyp 5) |- ( ( A F B ) F C ) = ( A F ( B F C ) ) ;;
	step 3 : wff = caovass (hyp 3, hyp 2, hyp 1, hyp 5) |- ( ( C F B ) F A ) = ( C F ( B F A ) ) ;;
	step 4 : wff = 3eqtr3i (step 1, step 2, step 3) |- ( A F ( B F C ) ) = ( C F ( B F A ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Rearrange arguments in a commutative, associative operation.
           (Contributed by NM, 26-Aug-1995.) */

theorem caov4 (x : set, y : set, z : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	hyp 6 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( B F D ) ) ;;
}

proof of caov4 {
	step 1 : wff = caov12 (hyp 2, hyp 3, hyp 6, hyp 4, hyp 5) |- ( B F ( C F D ) ) = ( C F ( B F D ) ) ;;
	step 2 : wff = oveq2i (step 1) |- ( A F ( B F ( C F D ) ) ) = ( A F ( C F ( B F D ) ) ) ;;
	step 3 : wff = ovex () |- ( C F D ) ∈ _V ;;
	step 4 : wff = caovass (hyp 1, hyp 2, step 3, hyp 5) |- ( ( A F B ) F ( C F D ) ) = ( A F ( B F ( C F D ) ) ) ;;
	step 5 : wff = ovex () |- ( B F D ) ∈ _V ;;
	step 6 : wff = caovass (hyp 1, hyp 3, step 5, hyp 5) |- ( ( A F C ) F ( B F D ) ) = ( A F ( C F ( B F D ) ) ) ;;
	step 7 : wff = 3eqtr4i (step 2, step 4, step 6) |- ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( B F D ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Rearrange arguments in a commutative, associative operation.
           (Contributed by NM, 26-Aug-1995.) */

theorem caov411 (x : set, y : set, z : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	hyp 6 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) F ( C F D ) ) = ( ( C F B ) F ( A F D ) ) ;;
}

proof of caov411 {
	step 1 : wff = caov31 (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ( A F B ) F C ) = ( ( C F B ) F A ) ;;
	step 2 : wff = oveq1i (step 1) |- ( ( ( A F B ) F C ) F D ) = ( ( ( C F B ) F A ) F D ) ;;
	step 3 : wff = ovex () |- ( A F B ) ∈ _V ;;
	step 4 : wff = caovass (step 3, hyp 3, hyp 6, hyp 5) |- ( ( ( A F B ) F C ) F D ) = ( ( A F B ) F ( C F D ) ) ;;
	step 5 : wff = ovex () |- ( C F B ) ∈ _V ;;
	step 6 : wff = caovass (step 5, hyp 1, hyp 6, hyp 5) |- ( ( ( C F B ) F A ) F D ) = ( ( C F B ) F ( A F D ) ) ;;
	step 7 : wff = 3eqtr3i (step 2, step 4, step 6) |- ( ( A F B ) F ( C F D ) ) = ( ( C F B ) F ( A F D ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Rearrange arguments in a commutative, associative operation.
           (Contributed by NM, 26-Aug-1995.) */

theorem caov42 (x : set, y : set, z : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z, x y z F, x y z, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	hyp 6 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( D F B ) ) ;;
}

proof of caov42 {
	step 1 : wff = caov4 (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, hyp 6) |- ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( B F D ) ) ;;
	step 2 : wff = caovcom (hyp 2, hyp 6, hyp 4) |- ( B F D ) = ( D F B ) ;;
	step 3 : wff = oveq2i (step 2) |- ( ( A F C ) F ( B F D ) ) = ( ( A F C ) F ( D F B ) ) ;;
	step 4 : wff = eqtri (step 1, step 3) |- ( ( A F B ) F ( C F D ) ) = ( ( A F C ) F ( D F B ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Reverse distributive law.  (Contributed by NM, 26-Aug-1995.) */

theorem caovdir (x : set, y : set, z : set, A : class, B : class, C : class, F : class, G : class) disjointed(x y z A, x y z B, x y z C, x y z, x y z, x y z F, x y z G, x y z, x y z, x y z, x y z, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x G y ) = ( y G x ) ;;
	hyp 5 : wff = |- ( x G ( y F z ) ) = ( ( x G y ) F ( x G z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A F B ) G C ) = ( ( A G C ) F ( B G C ) ) ;;
}

proof of caovdir {
	step 1 : wff = caovdi (hyp 3, hyp 1, hyp 2, hyp 5) |- ( C G ( A F B ) ) = ( ( C G A ) F ( C G B ) ) ;;
	step 2 : wff = ovex () |- ( A F B ) ∈ _V ;;
	step 3 : wff = caovcom (hyp 3, step 2, hyp 4) |- ( C G ( A F B ) ) = ( ( A F B ) G C ) ;;
	step 4 : wff = caovcom (hyp 3, hyp 1, hyp 4) |- ( C G A ) = ( A G C ) ;;
	step 5 : wff = caovcom (hyp 3, hyp 2, hyp 4) |- ( C G B ) = ( B G C ) ;;
	step 6 : wff = oveq12i (step 4, step 5) |- ( ( C G A ) F ( C G B ) ) = ( ( A G C ) F ( B G C ) ) ;;
	step 7 : wff = 3eqtr3i (step 1, step 3, step 6) |- ( ( A F B ) G C ) = ( ( A G C ) F ( B G C ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Lemma used by real number construction.  (Contributed by NM,
         26-Aug-1995.) */

theorem caovdilem (x : set, y : set, z : set, A : class, B : class, C : class, D : class, F : class, G : class, H : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z, x y z F, x y z G, x y z H, x y z, x y z, x y z, x y z, x y z H, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x G y ) = ( y G x ) ;;
	hyp 5 : wff = |- ( x G ( y F z ) ) = ( ( x G y ) F ( x G z ) ) ;;
	hyp 6 : wff = |- D ∈ _V ;;
	hyp 7 : wff = |- H ∈ _V ;;
	hyp 8 : wff = |- ( ( x G y ) G z ) = ( x G ( y G z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A G C ) F ( B G D ) ) G H ) = ( ( A G ( C G H ) ) F ( B G ( D G H ) ) ) ;;
}

proof of caovdilem {
	step 1 : wff = ovex () |- ( A G C ) ∈ _V ;;
	step 2 : wff = ovex () |- ( B G D ) ∈ _V ;;
	step 3 : wff = caovdir (step 1, step 2, hyp 7, hyp 4, hyp 5) |- ( ( ( A G C ) F ( B G D ) ) G H ) = ( ( ( A G C ) G H ) F ( ( B G D ) G H ) ) ;;
	step 4 : wff = caovass (hyp 1, hyp 3, hyp 7, hyp 8) |- ( ( A G C ) G H ) = ( A G ( C G H ) ) ;;
	step 5 : wff = caovass (hyp 2, hyp 6, hyp 7, hyp 8) |- ( ( B G D ) G H ) = ( B G ( D G H ) ) ;;
	step 6 : wff = oveq12i (step 4, step 5) |- ( ( ( A G C ) G H ) F ( ( B G D ) G H ) ) = ( ( A G ( C G H ) ) F ( B G ( D G H ) ) ) ;;
	step 7 : wff = eqtri (step 3, step 6) |- ( ( ( A G C ) F ( B G D ) ) G H ) = ( ( A G ( C G H ) ) F ( B G ( D G H ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Lemma used in real number construction.  (Contributed by NM,
         26-Aug-1995.) */

theorem caovlem2 (x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, F : class, G : class, H : class) disjointed(x y z A, x y z B, x y z C, x y z D, x y z, x y z F, x y z G, x y z H, x y z, x y z R, x y z, x y z, x y z H, x y z R) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x G y ) = ( y G x ) ;;
	hyp 5 : wff = |- ( x G ( y F z ) ) = ( ( x G y ) F ( x G z ) ) ;;
	hyp 6 : wff = |- D ∈ _V ;;
	hyp 7 : wff = |- H ∈ _V ;;
	hyp 8 : wff = |- ( ( x G y ) G z ) = ( x G ( y G z ) ) ;;
	hyp 9 : wff = |- R ∈ _V ;;
	hyp 10 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 11 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( ( A G C ) F ( B G D ) ) G H ) F ( ( ( A G D ) F ( B G C ) ) G R ) ) = ( ( A G ( ( C G H ) F ( D G R ) ) ) F ( B G ( ( C G R ) F ( D G H ) ) ) ) ;;
}

proof of caovlem2 {
	step 1 : wff = ovex () |- ( A G ( C G H ) ) ∈ _V ;;
	step 2 : wff = ovex () |- ( B G ( D G H ) ) ∈ _V ;;
	step 3 : wff = ovex () |- ( A G ( D G R ) ) ∈ _V ;;
	step 4 : wff = ovex () |- ( B G ( C G R ) ) ∈ _V ;;
	step 5 : wff = caov42 (step 1, step 2, step 3, hyp 10, hyp 11, step 4) |- ( ( ( A G ( C G H ) ) F ( B G ( D G H ) ) ) F ( ( A G ( D G R ) ) F ( B G ( C G R ) ) ) ) = ( ( ( A G ( C G H ) ) F ( A G ( D G R ) ) ) F ( ( B G ( C G R ) ) F ( B G ( D G H ) ) ) ) ;;
	step 6 : wff = caovdilem (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, hyp 6, hyp 7, hyp 8) |- ( ( ( A G C ) F ( B G D ) ) G H ) = ( ( A G ( C G H ) ) F ( B G ( D G H ) ) ) ;;
	step 7 : wff = caovdilem (hyp 1, hyp 2, hyp 6, hyp 4, hyp 5, hyp 3, hyp 9, hyp 8) |- ( ( ( A G D ) F ( B G C ) ) G R ) = ( ( A G ( D G R ) ) F ( B G ( C G R ) ) ) ;;
	step 8 : wff = oveq12i (step 6, step 7) |- ( ( ( ( A G C ) F ( B G D ) ) G H ) F ( ( ( A G D ) F ( B G C ) ) G R ) ) = ( ( ( A G ( C G H ) ) F ( B G ( D G H ) ) ) F ( ( A G ( D G R ) ) F ( B G ( C G R ) ) ) ) ;;
	step 9 : wff = ovex () |- ( C G H ) ∈ _V ;;
	step 10 : wff = ovex () |- ( D G R ) ∈ _V ;;
	step 11 : wff = caovdi (hyp 1, step 9, step 10, hyp 5) |- ( A G ( ( C G H ) F ( D G R ) ) ) = ( ( A G ( C G H ) ) F ( A G ( D G R ) ) ) ;;
	step 12 : wff = ovex () |- ( C G R ) ∈ _V ;;
	step 13 : wff = ovex () |- ( D G H ) ∈ _V ;;
	step 14 : wff = caovdi (hyp 2, step 12, step 13, hyp 5) |- ( B G ( ( C G R ) F ( D G H ) ) ) = ( ( B G ( C G R ) ) F ( B G ( D G H ) ) ) ;;
	step 15 : wff = oveq12i (step 11, step 14) |- ( ( A G ( ( C G H ) F ( D G R ) ) ) F ( B G ( ( C G R ) F ( D G H ) ) ) ) = ( ( ( A G ( C G H ) ) F ( A G ( D G R ) ) ) F ( ( B G ( C G R ) ) F ( B G ( D G H ) ) ) ) ;;
	step 16 : wff = 3eqtr4i (step 5, step 8, step 15) |- ( ( ( ( A G C ) F ( B G D ) ) G H ) F ( ( ( A G D ) F ( B G C ) ) G R ) ) = ( ( A G ( ( C G H ) F ( D G R ) ) ) F ( B G ( ( C G R ) F ( D G H ) ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Identity element. */

/* Uniqueness of inverse element in commutative, associative operation
         with identity.  Remark in proof of Proposition 9-2.4 of [Gleason]
         p. 119.  (Contributed by NM, 4-Mar-1996.) */

theorem caovmo (x : set, y : set, z : set, w : set, A : class, B : class, S : class, F : class) disjointed(x y z A, x y z B, x y z, x y z, x y z, x y z F, x y z, x y z, x y z, x y z, x y z S, x y z, u w A, u v w x y B, u v w x y z F, w x S) {
	hyp 1 : wff = |- B ∈ S ;;
	hyp 2 : wff = |- dom F = ( S × S ) ;;
	hyp 3 : wff = |- ¬ ∅ ∈ S ;;
	hyp 4 : wff = |- ( x F y ) = ( y F x ) ;;
	hyp 5 : wff = |- ( ( x F y ) F z ) = ( x F ( y F z ) ) ;;
	hyp 6 : wff = |- ( x ∈ S → ( x F B ) = x ) ;;
	-----------------------
	prop 1 : wff = |- ∃* w ( A F w ) = B ;;
}

proof of caovmo {
	var v : set, u : set;;
	step 1 : wff = oveq1 () |- ( u = A → ( u F w ) = ( A F w ) ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( u = A → ( ( u F w ) = B ↔ ( A F w ) = B ) ) ;;
	step 3 : wff = mobidv (step 2) |- ( u = A → ( ∃* w ( u F w ) = B ↔ ∃* w ( A F w ) = B ) ) ;;
	step 4 : wff = oveq2 () |- ( w = v → ( u F w ) = ( u F v ) ) ;;
	step 5 : wff = eqeq1d (step 4) |- ( w = v → ( ( u F w ) = B ↔ ( u F v ) = B ) ) ;;
	step 6 : wff = mo4 (step 5) |- ( ∃* w ( u F w ) = B ↔ ∀ w ∀ v ( ( ( u F w ) = B ∧ ( u F v ) = B ) → w = v ) ) ;;
	step 7 : wff = simpr () |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u F v ) = B ) ;;
	step 8 : wff = oveq2d (step 7) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( w F ( u F v ) ) = ( w F B ) ) ;;
	step 9 : wff = simpl () |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u F w ) = B ) ;;
	step 10 : wff = oveq1d (step 9) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( ( u F w ) F v ) = ( B F v ) ) ;;
	step 11 : wff = vex () |- u ∈ _V ;;
	step 12 : wff = vex () |- w ∈ _V ;;
	step 13 : wff = vex () |- v ∈ _V ;;
	step 14 : wff = caovass (step 11, step 12, step 13, hyp 5) |- ( ( u F w ) F v ) = ( u F ( w F v ) ) ;;
	step 15 : wff = vex () |- u ∈ _V ;;
	step 16 : wff = vex () |- w ∈ _V ;;
	step 17 : wff = vex () |- v ∈ _V ;;
	step 18 : wff = caov12 (step 15, step 16, step 17, hyp 4, hyp 5) |- ( u F ( w F v ) ) = ( w F ( u F v ) ) ;;
	step 19 : wff = eqtri (step 14, step 18) |- ( ( u F w ) F v ) = ( w F ( u F v ) ) ;;
	step 20 : wff = elexi (hyp 1) |- B ∈ _V ;;
	step 21 : wff = vex () |- v ∈ _V ;;
	step 22 : wff = caovcom (step 20, step 21, hyp 4) |- ( B F v ) = ( v F B ) ;;
	step 23 : wff = 3eqtr3g (step 10, step 19, step 22) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( w F ( u F v ) ) = ( v F B ) ) ;;
	step 24 : wff = eqtr3d (step 8, step 23) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( w F B ) = ( v F B ) ) ;;
	step 25 : wff = simpl () |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u F w ) = B ) ;;
	step 26 : wff = syl6eqel (step 25, hyp 1) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u F w ) ∈ S ) ;;
	step 27 : wff = ndmovrcl (hyp 2, hyp 3) |- ( ( u F w ) ∈ S → ( u ∈ S ∧ w ∈ S ) ) ;;
	step 28 : wff = syl (step 26, step 27) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u ∈ S ∧ w ∈ S ) ) ;;
	step 29 : wff = simprd (step 28) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → w ∈ S ) ;;
	step 30 : wff = oveq1 () |- ( x = w → ( x F B ) = ( w F B ) ) ;;
	step 31 : wff = id () |- ( x = w → x = w ) ;;
	step 32 : wff = eqeq12d (step 30, step 31) |- ( x = w → ( ( x F B ) = x ↔ ( w F B ) = w ) ) ;;
	step 33 : wff = vtoclga (step 32, hyp 6) |- ( w ∈ S → ( w F B ) = w ) ;;
	step 34 : wff = syl (step 29, step 33) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( w F B ) = w ) ;;
	step 35 : wff = simpr () |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u F v ) = B ) ;;
	step 36 : wff = syl6eqel (step 35, hyp 1) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u F v ) ∈ S ) ;;
	step 37 : wff = ndmovrcl (hyp 2, hyp 3) |- ( ( u F v ) ∈ S → ( u ∈ S ∧ v ∈ S ) ) ;;
	step 38 : wff = syl (step 36, step 37) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( u ∈ S ∧ v ∈ S ) ) ;;
	step 39 : wff = simprd (step 38) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → v ∈ S ) ;;
	step 40 : wff = oveq1 () |- ( x = v → ( x F B ) = ( v F B ) ) ;;
	step 41 : wff = id () |- ( x = v → x = v ) ;;
	step 42 : wff = eqeq12d (step 40, step 41) |- ( x = v → ( ( x F B ) = x ↔ ( v F B ) = v ) ) ;;
	step 43 : wff = vtoclga (step 42, hyp 6) |- ( v ∈ S → ( v F B ) = v ) ;;
	step 44 : wff = syl (step 39, step 43) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → ( v F B ) = v ) ;;
	step 45 : wff = 3eqtr3d (step 24, step 34, step 44) |- ( ( ( u F w ) = B ∧ ( u F v ) = B ) → w = v ) ;;
	step 46 : wff = ax-gen (step 45) |- ∀ v ( ( ( u F w ) = B ∧ ( u F v ) = B ) → w = v ) ;;
	step 47 : wff = mpgbir (step 6, step 46) |- ∃* w ( u F w ) = B ;;
	step 48 : wff = vtoclg (step 3, step 47) |- ( A ∈ S → ∃* w ( A F w ) = B ) ;;
	step 49 : wff = moanimv () |- ( ∃* w ( A ∈ S ∧ ( A F w ) = B ) ↔ ( A ∈ S → ∃* w ( A F w ) = B ) ) ;;
	step 50 : wff = mpbir (step 48, step 49) |- ∃* w ( A ∈ S ∧ ( A F w ) = B ) ;;
	step 51 : wff = eleq1 () |- ( ( A F w ) = B → ( ( A F w ) ∈ S ↔ B ∈ S ) ) ;;
	step 52 : wff = mpbiri (hyp 1, step 51) |- ( ( A F w ) = B → ( A F w ) ∈ S ) ;;
	step 53 : wff = ndmovrcl (hyp 2, hyp 3) |- ( ( A F w ) ∈ S → ( A ∈ S ∧ w ∈ S ) ) ;;
	step 54 : wff = syl (step 52, step 53) |- ( ( A F w ) = B → ( A ∈ S ∧ w ∈ S ) ) ;;
	step 55 : wff = simpld (step 54) |- ( ( A F w ) = B → A ∈ S ) ;;
	step 56 : wff = ancri (step 55) |- ( ( A F w ) = B → ( A ∈ S ∧ ( A F w ) = B ) ) ;;
	step 57 : wff = moimi (step 56) |- ( ∃* w ( A ∈ S ∧ ( A F w ) = B ) → ∃* w ( A F w ) = B ) ;;
	step 58 : wff = ax-mp (step 50, step 57) |- ∃* w ( A F w ) = B ;;
	qed prop 1 = step 58 ;;
}

/* Lemma for ~ grprinvd .  (Contributed by NM, 9-Aug-2013.) */

theorem grprinvlem (ph : wff, ps : wff, x : set, y : set, z : set, B : class, .+ : class, O : class, X : class) disjointed(u v w x y z B, u v w x y z O, u v w x y z ph, u v w y z, u v w x y z .+, u v w y z X, u v w y ps) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ B ∧ y ∈ B ) → ( x .+ y ) ∈ B ) ;;
	hyp 2 : wff = |- ( ph → O ∈ B ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ B ) → ( O .+ x ) = x ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ B ∧ y ∈ B ∧ z ∈ B ) ) → ( ( x .+ y ) .+ z ) = ( x .+ ( y .+ z ) ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ x ∈ B ) → ∃ y ∈ B ( y .+ x ) = O ) ;;
	hyp 6 : wff = |- ( ( ph ∧ ps ) → X ∈ B ) ;;
	hyp 7 : wff = |- ( ( ph ∧ ps ) → ( X .+ X ) = X ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → X = O ) ;;
}

proof of grprinvlem {
	var w : set, v : set, u : set;;
	step 1 : wff = ralrimiva (hyp 5) |- ( ph → ∀ x ∈ B ∃ y ∈ B ( y .+ x ) = O ) ;;
	step 2 : wff = oveq2 () |- ( x = z → ( y .+ x ) = ( y .+ z ) ) ;;
	step 3 : wff = eqeq1d (step 2) |- ( x = z → ( ( y .+ x ) = O ↔ ( y .+ z ) = O ) ) ;;
	step 4 : wff = rexbidv (step 3) |- ( x = z → ( ∃ y ∈ B ( y .+ x ) = O ↔ ∃ y ∈ B ( y .+ z ) = O ) ) ;;
	step 5 : wff = cbvralv (step 4) |- ( ∀ x ∈ B ∃ y ∈ B ( y .+ x ) = O ↔ ∀ z ∈ B ∃ y ∈ B ( y .+ z ) = O ) ;;
	step 6 : wff = sylib (step 1, step 5) |- ( ph → ∀ z ∈ B ∃ y ∈ B ( y .+ z ) = O ) ;;
	step 7 : wff = oveq2 () |- ( z = X → ( y .+ z ) = ( y .+ X ) ) ;;
	step 8 : wff = eqeq1d (step 7) |- ( z = X → ( ( y .+ z ) = O ↔ ( y .+ X ) = O ) ) ;;
	step 9 : wff = rexbidv (step 8) |- ( z = X → ( ∃ y ∈ B ( y .+ z ) = O ↔ ∃ y ∈ B ( y .+ X ) = O ) ) ;;
	step 10 : wff = rspccva (step 9) |- ( ( ∀ z ∈ B ∃ y ∈ B ( y .+ z ) = O ∧ X ∈ B ) → ∃ y ∈ B ( y .+ X ) = O ) ;;
	step 11 : wff = sylan (step 6, step 10) |- ( ( ph ∧ X ∈ B ) → ∃ y ∈ B ( y .+ X ) = O ) ;;
	step 12 : wff = syldan (hyp 6, step 11) |- ( ( ph ∧ ps ) → ∃ y ∈ B ( y .+ X ) = O ) ;;
	step 13 : wff = oveq2d (hyp 7) |- ( ( ph ∧ ps ) → ( y .+ ( X .+ X ) ) = ( y .+ X ) ) ;;
	step 14 : wff = adantr (step 13) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( y .+ ( X .+ X ) ) = ( y .+ X ) ) ;;
	step 15 : wff = simprr () |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( y .+ X ) = O ) ;;
	step 16 : wff = oveq1d (step 15) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( ( y .+ X ) .+ X ) = ( O .+ X ) ) ;;
	step 17 : wff = simpll () |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ph ) ;;
	step 18 : wff = caovassg (hyp 4) |- ( ( ph ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 19 : wff = sylan (step 17, step 18) |- ( ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 20 : wff = simprl () |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → y ∈ B ) ;;
	step 21 : wff = adantr (hyp 6) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → X ∈ B ) ;;
	step 22 : wff = adantr (hyp 6) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → X ∈ B ) ;;
	step 23 : wff = caovassd (step 19, step 20, step 21, step 22) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( ( y .+ X ) .+ X ) = ( y .+ ( X .+ X ) ) ) ;;
	step 24 : wff = ralrimiva (hyp 3) |- ( ph → ∀ x ∈ B ( O .+ x ) = x ) ;;
	step 25 : wff = oveq2 () |- ( x = y → ( O .+ x ) = ( O .+ y ) ) ;;
	step 26 : wff = id () |- ( x = y → x = y ) ;;
	step 27 : wff = eqeq12d (step 25, step 26) |- ( x = y → ( ( O .+ x ) = x ↔ ( O .+ y ) = y ) ) ;;
	step 28 : wff = cbvralv (step 27) |- ( ∀ x ∈ B ( O .+ x ) = x ↔ ∀ y ∈ B ( O .+ y ) = y ) ;;
	step 29 : wff = sylib (step 24, step 28) |- ( ph → ∀ y ∈ B ( O .+ y ) = y ) ;;
	step 30 : wff = adantr (step 29) |- ( ( ph ∧ ps ) → ∀ y ∈ B ( O .+ y ) = y ) ;;
	step 31 : wff = oveq2 () |- ( y = X → ( O .+ y ) = ( O .+ X ) ) ;;
	step 32 : wff = id () |- ( y = X → y = X ) ;;
	step 33 : wff = eqeq12d (step 31, step 32) |- ( y = X → ( ( O .+ y ) = y ↔ ( O .+ X ) = X ) ) ;;
	step 34 : wff = rspcv (step 33) |- ( X ∈ B → ( ∀ y ∈ B ( O .+ y ) = y → ( O .+ X ) = X ) ) ;;
	step 35 : wff = sylc (hyp 6, step 30, step 34) |- ( ( ph ∧ ps ) → ( O .+ X ) = X ) ;;
	step 36 : wff = adantr (step 35) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( O .+ X ) = X ) ;;
	step 37 : wff = 3eqtr3d (step 16, step 23, step 36) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( y .+ ( X .+ X ) ) = X ) ;;
	step 38 : wff = simprr () |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → ( y .+ X ) = O ) ;;
	step 39 : wff = 3eqtr3d (step 14, step 37, step 38) |- ( ( ( ph ∧ ps ) ∧ ( y ∈ B ∧ ( y .+ X ) = O ) ) → X = O ) ;;
	step 40 : wff = expr (step 39) |- ( ( ( ph ∧ ps ) ∧ y ∈ B ) → ( ( y .+ X ) = O → X = O ) ) ;;
	step 41 : wff = rexlimdva (step 40) |- ( ( ph ∧ ps ) → ( ∃ y ∈ B ( y .+ X ) = O → X = O ) ) ;;
	step 42 : wff = mpd (step 12, step 41) |- ( ( ph ∧ ps ) → X = O ) ;;
	qed prop 1 = step 42 ;;
}

/* Deduce right inverse from left inverse and left identity in an
         associative structure (such as a group).  (Contributed by NM,
         10-Aug-2013.)  (Proof shortened by Mario Carneiro, 6-Jan-2015.) */

theorem grprinvd (ph : wff, ps : wff, x : set, y : set, z : set, B : class, .+ : class, N : class, O : class, X : class) disjointed(u v w x y z B, u v w x y z O, u v w x y z ph, u v w y z N, u v w x y z .+, u v w y z X, u v w y ps) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ B ∧ y ∈ B ) → ( x .+ y ) ∈ B ) ;;
	hyp 2 : wff = |- ( ph → O ∈ B ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ B ) → ( O .+ x ) = x ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ B ∧ y ∈ B ∧ z ∈ B ) ) → ( ( x .+ y ) .+ z ) = ( x .+ ( y .+ z ) ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ x ∈ B ) → ∃ y ∈ B ( y .+ x ) = O ) ;;
	hyp 6 : wff = |- ( ( ph ∧ ps ) → X ∈ B ) ;;
	hyp 7 : wff = |- ( ( ph ∧ ps ) → N ∈ B ) ;;
	hyp 8 : wff = |- ( ( ph ∧ ps ) → ( N .+ X ) = O ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → ( X .+ N ) = O ) ;;
}

proof of grprinvd {
	var w : set, v : set, u : set;;
	step 1 : wff = 3expb (hyp 1) |- ( ( ph ∧ ( x ∈ B ∧ y ∈ B ) ) → ( x .+ y ) ∈ B ) ;;
	step 2 : wff = caovclg (step 1) |- ( ( ph ∧ ( u ∈ B ∧ v ∈ B ) ) → ( u .+ v ) ∈ B ) ;;
	step 3 : wff = adantlr (step 2) |- ( ( ( ph ∧ ps ) ∧ ( u ∈ B ∧ v ∈ B ) ) → ( u .+ v ) ∈ B ) ;;
	step 4 : wff = caovcld (step 3, hyp 6, hyp 7) |- ( ( ph ∧ ps ) → ( X .+ N ) ∈ B ) ;;
	step 5 : wff = caovassg (hyp 4) |- ( ( ph ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 6 : wff = adantlr (step 5) |- ( ( ( ph ∧ ps ) ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 7 : wff = 3expb (hyp 1) |- ( ( ph ∧ ( x ∈ B ∧ y ∈ B ) ) → ( x .+ y ) ∈ B ) ;;
	step 8 : wff = caovclg (step 7) |- ( ( ph ∧ ( u ∈ B ∧ v ∈ B ) ) → ( u .+ v ) ∈ B ) ;;
	step 9 : wff = adantlr (step 8) |- ( ( ( ph ∧ ps ) ∧ ( u ∈ B ∧ v ∈ B ) ) → ( u .+ v ) ∈ B ) ;;
	step 10 : wff = caovcld (step 9, hyp 6, hyp 7) |- ( ( ph ∧ ps ) → ( X .+ N ) ∈ B ) ;;
	step 11 : wff = caovassd (step 6, hyp 6, hyp 7, step 10) |- ( ( ph ∧ ps ) → ( ( X .+ N ) .+ ( X .+ N ) ) = ( X .+ ( N .+ ( X .+ N ) ) ) ) ;;
	step 12 : wff = oveq1d (hyp 8) |- ( ( ph ∧ ps ) → ( ( N .+ X ) .+ N ) = ( O .+ N ) ) ;;
	step 13 : wff = caovassg (hyp 4) |- ( ( ph ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 14 : wff = adantlr (step 13) |- ( ( ( ph ∧ ps ) ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 15 : wff = caovassd (step 14, hyp 7, hyp 6, hyp 7) |- ( ( ph ∧ ps ) → ( ( N .+ X ) .+ N ) = ( N .+ ( X .+ N ) ) ) ;;
	step 16 : wff = ralrimiva (hyp 3) |- ( ph → ∀ x ∈ B ( O .+ x ) = x ) ;;
	step 17 : wff = oveq2 () |- ( x = y → ( O .+ x ) = ( O .+ y ) ) ;;
	step 18 : wff = id () |- ( x = y → x = y ) ;;
	step 19 : wff = eqeq12d (step 17, step 18) |- ( x = y → ( ( O .+ x ) = x ↔ ( O .+ y ) = y ) ) ;;
	step 20 : wff = cbvralv (step 19) |- ( ∀ x ∈ B ( O .+ x ) = x ↔ ∀ y ∈ B ( O .+ y ) = y ) ;;
	step 21 : wff = sylib (step 16, step 20) |- ( ph → ∀ y ∈ B ( O .+ y ) = y ) ;;
	step 22 : wff = adantr (step 21) |- ( ( ph ∧ ps ) → ∀ y ∈ B ( O .+ y ) = y ) ;;
	step 23 : wff = oveq2 () |- ( y = N → ( O .+ y ) = ( O .+ N ) ) ;;
	step 24 : wff = id () |- ( y = N → y = N ) ;;
	step 25 : wff = eqeq12d (step 23, step 24) |- ( y = N → ( ( O .+ y ) = y ↔ ( O .+ N ) = N ) ) ;;
	step 26 : wff = rspcv (step 25) |- ( N ∈ B → ( ∀ y ∈ B ( O .+ y ) = y → ( O .+ N ) = N ) ) ;;
	step 27 : wff = sylc (hyp 7, step 22, step 26) |- ( ( ph ∧ ps ) → ( O .+ N ) = N ) ;;
	step 28 : wff = 3eqtr3d (step 12, step 15, step 27) |- ( ( ph ∧ ps ) → ( N .+ ( X .+ N ) ) = N ) ;;
	step 29 : wff = oveq2d (step 28) |- ( ( ph ∧ ps ) → ( X .+ ( N .+ ( X .+ N ) ) ) = ( X .+ N ) ) ;;
	step 30 : wff = eqtrd (step 11, step 29) |- ( ( ph ∧ ps ) → ( ( X .+ N ) .+ ( X .+ N ) ) = ( X .+ N ) ) ;;
	step 31 : wff = grprinvlem (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, step 4, step 30) |- ( ( ph ∧ ps ) → ( X .+ N ) = O ) ;;
	qed prop 1 = step 31 ;;
}

/* Deduce right identity from left inverse and left identity in an
       associative structure (such as a group).  (Contributed by NM,
       10-Aug-2013.)  (Proof shortened by Mario Carneiro, 6-Jan-2015.) */

theorem grpridd (ph : wff, x : set, y : set, z : set, B : class, .+ : class, O : class) disjointed(n u v w x y z B, n u v w x y z O, n u v w x y z ph, u v w y z, n u v w x y z .+, u v w y z, u v w y) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ B ∧ y ∈ B ) → ( x .+ y ) ∈ B ) ;;
	hyp 2 : wff = |- ( ph → O ∈ B ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ B ) → ( O .+ x ) = x ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ B ∧ y ∈ B ∧ z ∈ B ) ) → ( ( x .+ y ) .+ z ) = ( x .+ ( y .+ z ) ) ) ;;
	hyp 5 : wff = |- ( ( ph ∧ x ∈ B ) → ∃ y ∈ B ( y .+ x ) = O ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ x ∈ B ) → ( x .+ O ) = x ) ;;
}

proof of grpridd {
	var w : set, v : set, u : set, n : set;;
	step 1 : wff = oveq1 () |- ( y = n → ( y .+ x ) = ( n .+ x ) ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( y = n → ( ( y .+ x ) = O ↔ ( n .+ x ) = O ) ) ;;
	step 3 : wff = cbvrexv (step 2) |- ( ∃ y ∈ B ( y .+ x ) = O ↔ ∃ n ∈ B ( n .+ x ) = O ) ;;
	step 4 : wff = sylib (hyp 5, step 3) |- ( ( ph ∧ x ∈ B ) → ∃ n ∈ B ( n .+ x ) = O ) ;;
	step 5 : wff = caovassg (hyp 4) |- ( ( ph ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 6 : wff = adantlr (step 5) |- ( ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) ∧ ( u ∈ B ∧ v ∈ B ∧ w ∈ B ) ) → ( ( u .+ v ) .+ w ) = ( u .+ ( v .+ w ) ) ) ;;
	step 7 : wff = simprl () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → x ∈ B ) ;;
	step 8 : wff = simprrl () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → n ∈ B ) ;;
	step 9 : wff = simprl () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → x ∈ B ) ;;
	step 10 : wff = caovassd (step 6, step 7, step 8, step 9) |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( ( x .+ n ) .+ x ) = ( x .+ ( n .+ x ) ) ) ;;
	step 11 : wff = simprl () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → x ∈ B ) ;;
	step 12 : wff = simprrl () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → n ∈ B ) ;;
	step 13 : wff = simprrr () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( n .+ x ) = O ) ;;
	step 14 : wff = grprinvd (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, step 11, step 12, step 13) |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( x .+ n ) = O ) ;;
	step 15 : wff = oveq1d (step 14) |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( ( x .+ n ) .+ x ) = ( O .+ x ) ) ;;
	step 16 : wff = simprrr () |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( n .+ x ) = O ) ;;
	step 17 : wff = oveq2d (step 16) |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( x .+ ( n .+ x ) ) = ( x .+ O ) ) ;;
	step 18 : wff = 3eqtr3d (step 10, step 15, step 17) |- ( ( ph ∧ ( x ∈ B ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) ) → ( O .+ x ) = ( x .+ O ) ) ;;
	step 19 : wff = anassrs (step 18) |- ( ( ( ph ∧ x ∈ B ) ∧ ( n ∈ B ∧ ( n .+ x ) = O ) ) → ( O .+ x ) = ( x .+ O ) ) ;;
	step 20 : wff = expr (step 19) |- ( ( ( ph ∧ x ∈ B ) ∧ n ∈ B ) → ( ( n .+ x ) = O → ( O .+ x ) = ( x .+ O ) ) ) ;;
	step 21 : wff = rexlimdva (step 20) |- ( ( ph ∧ x ∈ B ) → ( ∃ n ∈ B ( n .+ x ) = O → ( O .+ x ) = ( x .+ O ) ) ) ;;
	step 22 : wff = mpd (step 4, step 21) |- ( ( ph ∧ x ∈ B ) → ( O .+ x ) = ( x .+ O ) ) ;;
	step 23 : wff = eqtr3d (step 22, hyp 3) |- ( ( ph ∧ x ∈ B ) → ( x .+ O ) = x ) ;;
	qed prop 1 = step 23 ;;
}


