import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Definite_description_binder_(inverted_iota).rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                                 Functions

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Introduce new constant symbols. */

constant {
	symbol : ;;
}

/*Colon */

constant {
	symbol Fun ;;
}

/*Function predicate */

constant {
	symbol Fn ;;
}

/*Function connective */

constant {
	symbol ⟶ ;;
	ascii --> ;;
	latex \longrightarrow ;;
}

/*Domain-codomain connective */

constant {
	symbol ↣ ;;
	ascii -1-1-> ;;
	latex \rightarrowtail ;;
}

/*'One-to-one' domain-codomain connective */

constant {
	symbol ↠ ;;
	ascii -onto-> ;;
	latex \twoheadrightarrow ;;
}

/*'Onto' domain-codomain connective */

constant {
	symbol ⤖ ;;
	ascii -1-1-onto-> ;;
	latex \rightarrowtail\twoheadrightarrow ;;
}

/*'One-to-one' and 'onto' domain-codomain connective */

constant {
	symbol ` ;;
}

/*Left apostrophe (function value symbol) */

constant {
	symbol Isom ;;
}

/*Isomorphism */

/*Extend the definition of a wff to include the function predicate.  (Read:
     ` A ` is a function.) */

rule wfun (A : class) {
	term : wff = # Fun A ;;
}

/*Extend the definition of a wff to include the function predicate with a
     domain.  (Read: ` A ` is a function on ` B ` .) */

rule wfn (A : class, B : class) {
	term : wff = # A Fn B ;;
}

/*Extend the definition of a wff to include the function predicate with
     domain and codomain.  (Read: ` F ` maps ` A ` into ` B ` .) */

rule wf (A : class, B : class, F : class) {
	term : wff = # F : A ⟶ B ;;
}

/*Extend the definition of a wff to include one-to-one functions.  (Read:
     ` F ` maps ` A ` one-to-one into ` B ` .)  The notation ("1-1" above the
     arrow) is from Definition 6.15(5) of [TakeutiZaring] p. 27. */

rule wf1 (A : class, B : class, F : class) {
	term : wff = # F : A ↣ B ;;
}

/*Extend the definition of a wff to include onto functions.  (Read: ` F `
     maps ` A ` onto ` B ` .)  The notation ("onto" below the arrow) is from
     Definition 6.15(4) of [TakeutiZaring] p. 27. */

rule wfo (A : class, B : class, F : class) {
	term : wff = # F : A ↠ B ;;
}

/*Extend the definition of a wff to include one-to-one onto functions.
     (Read: ` F ` maps ` A ` one-to-one onto ` B ` .)  The notation ("1-1"
     above the arrow and "onto" below the arrow) is from Definition 6.15(6) of
     [TakeutiZaring] p. 27. */

rule wf1o (A : class, B : class, F : class) {
	term : wff = # F : A ⤖ B ;;
}

/*Extend the definition of a class to include the value of a function.
     (Read:  The value of ` F ` at ` A ` , or " ` F ` of ` A ` .") */

rule cfv (A : class, F : class) {
	term : class = # ( F ` A ) ;;
}

/*Extend the definition of a wff to include the isomorphism property.
     (Read: ` H ` is an ` R ` , ` S ` isomorphism of ` A ` onto ` B ` .) */

rule wiso (A : class, B : class, R : class, S : class, H : class) {
	term : wff = # H Isom R , S ( A , B ) ;;
}

/*Define predicate that determines if some class ` A ` is a function.
       Definition 10.1 of [Quine] p. 65.  For example, the expression
       ` Fun cos ` is true once we define cosine ( ~ df-cos ).  This is not the
       same as defining a specific function's mapping, which is typically done
       using the format of ~ cmpt with the maps-to notation (see ~ df-mpt and
       ~ df-mpt2 ).  Contrast this predicate with the predicates to determine
       if some class is a function with a given domain ( ~ df-fn ), a function
       with a given domain and codomain ( ~ df-f ), a one-to-one function
       ( ~ df-f1 ), an onto function ( ~ df-fo ), or a one-to-one onto function
       ( ~ df-f1o ).  For alternate definitions, see ~ dffun2 , ~ dffun3 ,
       ~ dffun4 , ~ dffun5 , ~ dffun6 , ~ dffun7 , ~ dffun8 , and ~ dffun9 .
       (Contributed by NM, 1-Aug-1994.) */

definition df-fun (A : class) disjointed(A) {
	defiendum : wff = # Fun A ;;
	definiens : wff = # ( Rel A ∧ ( A ∘ ⁻¹ A ) ⊆ _I ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define a function with domain.  Definition 6.15(1) of [TakeutiZaring]
       p. 27.  For alternate definitions, see ~ dffn2 , ~ dffn3 , ~ dffn4 , and
       ~ dffn5 .  (Contributed by NM, 1-Aug-1994.) */

definition df-fn (A : class, B : class) disjointed(A) {
	defiendum : wff = # A Fn B ;;
	definiens : wff = # ( Fun A ∧ dom A = B ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define a function (mapping) with domain and codomain.  Definition
       6.15(3) of [TakeutiZaring] p. 27.  For alternate definitions, see
       ~ dff2 , ~ dff3 , and ~ dff4 .  (Contributed by NM, 1-Aug-1994.) */

definition df-f (A : class, B : class, F : class) disjointed(A, F) {
	defiendum : wff = # F : A ⟶ B ;;
	definiens : wff = # ( F Fn A ∧ ran F ⊆ B ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define a one-to-one function.  For equivalent definitions see ~ dff12
       and ~ dff13 .  Compare Definition 6.15(5) of [TakeutiZaring] p. 27.  We
       use their notation ("1-1" above the arrow).  (Contributed by NM,
       1-Aug-1994.) */

definition df-f1 (A : class, B : class, F : class) disjointed(A, F) {
	defiendum : wff = # F : A ↣ B ;;
	definiens : wff = # ( F : A ⟶ B ∧ Fun ⁻¹ F ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define an onto function.  Definition 6.15(4) of [TakeutiZaring] p. 27.
       We use their notation ("onto" under the arrow).  For alternate
       definitions, see ~ dffo2 , ~ dffo3 , ~ dffo4 , and ~ dffo5 .
       (Contributed by NM, 1-Aug-1994.) */

definition df-fo (A : class, B : class, F : class) disjointed(A, F) {
	defiendum : wff = # F : A ↠ B ;;
	definiens : wff = # ( F Fn A ∧ ran F = B ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define a one-to-one onto function.  For equivalent definitions see
       ~ dff1o2 , ~ dff1o3 , ~ dff1o4 , and ~ dff1o5 .  Compare Definition
       6.15(6) of [TakeutiZaring] p. 27.  We use their notation ("1-1" above
       the arrow and "onto" below the arrow).  (Contributed by NM,
       1-Aug-1994.) */

definition df-f1o (A : class, B : class, F : class) disjointed(A, F) {
	defiendum : wff = # F : A ⤖ B ;;
	definiens : wff = # ( F : A ↣ B ∧ F : A ↠ B ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define the value of a function, ` ( F `` A ) ` , also known as function
       application.  For example, ` ( cos `` 0 ) = 1 ` (we prove this in ~ cos0
       after we define cosine in ~ df-cos ).  Typically, function ` F ` is
       defined using maps-to notation (see ~ df-mpt and ~ df-mpt2 ), but this
       is not required.  For example,
       ` F = { <. 2 , 6 >. , <. 3 , 9 >. } -> ( F `` 3 ) = 9 ` ( ~ ex-fv ).
       Note that ~ df-ov will define two-argument functions using ordered pairs
       as ` ( A F B ) = ( F `` <. A , B >. ) ` .  This particular definition is
       quite convenient: it can be applied to any class and evaluates to the
       empty set when it is not meaningful (as shown by ~ ndmfv and ~ fvprc ).
       The left apostrophe notation originated with Peano and was adopted in
       Definition *30.01 of [WhiteheadRussell] p. 235, Definition 10.11 of
       [Quine] p. 68, and Definition 6.11 of [TakeutiZaring] p. 26.  It means
       the same thing as the more familiar ` F ( A ) ` notation for a
       function's value at ` A ` , i.e.  " ` F ` of ` A ` ," but without
       context-dependent notational ambiguity.  Alternate definitions are
       ~ dffv2 , ~ dffv3 , ~ fv2 , and ~ fv3 (the latter two previously
       required ` A ` to be a set.)  Restricted equivalents that require ` F `
       to be a function are shown in ~ funfv and ~ funfv2 .  For the familiar
       definition of function value in terms of ordered pair membership, see
       ~ funopfvb .  (Contributed by Scott Fenton, 6-Oct-2017.) */

definition df-fv (x : set, A : class, F : class) disjointed(x A, x F) {
	defiendum : class = # ( F ` A ) ;;
	definiens : class = # ( iota x A F x ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the isomorphism predicate.  We read this as " ` H ` is an ` R ` ,
       ` S ` isomorphism of ` A ` onto ` B ` ."  Normally, ` R ` and ` S ` are
       ordering relations on ` A ` and ` B ` respectively.  Definition 6.28 of
       [TakeutiZaring] p. 32, whose notation is the same as ours except that
       ` R ` and ` S ` are subscripts.  (Contributed by NM, 4-Mar-1997.) */

definition df-isom (x : set, y : set, A : class, B : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y R, x y S, x y H) {
	defiendum : wff = # H Isom R , S ( A , B ) ;;
	definiens : wff = # ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Alternate definition of a function.  (Contributed by NM,
       29-Dec-1996.) */

theorem dffun2 (x : set, y : set, z : set, A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ) ;;
}

proof of dffun2 {
	step 1 : wff = df-fun () |- ( Fun A ↔ ( Rel A ∧ ( A ∘ ⁻¹ A ) ⊆ _I ) ) ;;
	step 2 : wff = df-id () |- _I = { 〈 y , z 〉 | y = z } ;;
	step 3 : wff = sseq2i (step 2) |- ( ( A ∘ ⁻¹ A ) ⊆ _I ↔ ( A ∘ ⁻¹ A ) ⊆ { 〈 y , z 〉 | y = z } ) ;;
	step 4 : wff = df-co () |- ( A ∘ ⁻¹ A ) = { 〈 y , z 〉 | ∃ x ( y ⁻¹ A x ∧ x A z ) } ;;
	step 5 : wff = sseq1i (step 4) |- ( ( A ∘ ⁻¹ A ) ⊆ { 〈 y , z 〉 | y = z } ↔ { 〈 y , z 〉 | ∃ x ( y ⁻¹ A x ∧ x A z ) } ⊆ { 〈 y , z 〉 | y = z } ) ;;
	step 6 : wff = ssopab2b () |- ( { 〈 y , z 〉 | ∃ x ( y ⁻¹ A x ∧ x A z ) } ⊆ { 〈 y , z 〉 | y = z } ↔ ∀ y ∀ z ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ) ;;
	step 7 : wff = 3bitri (step 3, step 5, step 6) |- ( ( A ∘ ⁻¹ A ) ⊆ _I ↔ ∀ y ∀ z ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ) ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = brcnv (step 8, step 9) |- ( y ⁻¹ A x ↔ x A y ) ;;
	step 11 : wff = anbi1i (step 10) |- ( ( y ⁻¹ A x ∧ x A z ) ↔ ( x A y ∧ x A z ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ x ( y ⁻¹ A x ∧ x A z ) ↔ ∃ x ( x A y ∧ x A z ) ) ;;
	step 13 : wff = imbi1i (step 12) |- ( ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ↔ ( ∃ x ( x A y ∧ x A z ) → y = z ) ) ;;
	step 14 : wff = 19.23v () |- ( ∀ x ( ( x A y ∧ x A z ) → y = z ) ↔ ( ∃ x ( x A y ∧ x A z ) → y = z ) ) ;;
	step 15 : wff = bitr4i (step 13, step 14) |- ( ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ↔ ∀ x ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 16 : wff = albii (step 15) |- ( ∀ z ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ↔ ∀ z ∀ x ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 17 : wff = alcom () |- ( ∀ z ∀ x ( ( x A y ∧ x A z ) → y = z ) ↔ ∀ x ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 18 : wff = bitri (step 16, step 17) |- ( ∀ z ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ↔ ∀ x ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 19 : wff = albii (step 18) |- ( ∀ y ∀ z ( ∃ x ( y ⁻¹ A x ∧ x A z ) → y = z ) ↔ ∀ y ∀ x ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 20 : wff = alcom () |- ( ∀ y ∀ x ∀ z ( ( x A y ∧ x A z ) → y = z ) ↔ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 21 : wff = 3bitri (step 7, step 19, step 20) |- ( ( A ∘ ⁻¹ A ) ⊆ _I ↔ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 22 : wff = anbi2i (step 21) |- ( ( Rel A ∧ ( A ∘ ⁻¹ A ) ⊆ _I ) ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ) ;;
	step 23 : wff = bitri (step 1, step 22) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ) ;;
	qed prop 1 = step 23 ;;
}

/*Alternate definition of function.  (Contributed by NM, 29-Dec-1996.) */

theorem dffun3 (x : set, y : set, z : set, A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( x A y → y = z ) ) ) ;;
}

proof of dffun3 {
	step 1 : wff = dffun2 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ) ;;
	step 2 : wff = breq2 () |- ( y = z → ( x A y ↔ x A z ) ) ;;
	step 3 : wff = mo4 (step 2) |- ( ∃* y x A y ↔ ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ;;
	step 4 : wff = nfv () |- F/ z x A y ;;
	step 5 : wff = mo2 (step 4) |- ( ∃* y x A y ↔ ∃ z ∀ y ( x A y → y = z ) ) ;;
	step 6 : wff = bitr3i (step 3, step 5) |- ( ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ↔ ∃ z ∀ y ( x A y → y = z ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ↔ ∀ x ∃ z ∀ y ( x A y → y = z ) ) ;;
	step 8 : wff = anbi2i (step 7) |- ( ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( x A y → y = z ) ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( x A y → y = z ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Alternate definition of a function.  Definition 6.4(4) of
       [TakeutiZaring] p. 24.  (Contributed by NM, 29-Dec-1996.) */

theorem dffun4 (x : set, y : set, z : set, A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) → y = z ) ) ) ;;
}

proof of dffun4 {
	step 1 : wff = dffun2 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ) ;;
	step 2 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = df-br () |- ( x A z ↔ 〈 x , z 〉 ∈ A ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( x A y ∧ x A z ) ↔ ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) ) ;;
	step 5 : wff = imbi1i (step 4) |- ( ( ( x A y ∧ x A z ) → y = z ) ↔ ( ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) → y = z ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ z ( ( x A y ∧ x A z ) → y = z ) ↔ ∀ z ( ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) → y = z ) ) ;;
	step 7 : wff = 2albii (step 6) |- ( ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ↔ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) → y = z ) ) ;;
	step 8 : wff = anbi2i (step 7) |- ( ( Rel A ∧ ∀ x ∀ y ∀ z ( ( x A y ∧ x A z ) → y = z ) ) ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) → y = z ) ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ A ∧ 〈 x , z 〉 ∈ A ) → y = z ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Alternate definition of function.  (Contributed by NM, 29-Dec-1996.) */

theorem dffun5 (x : set, y : set, z : set, A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ) ;;
}

proof of dffun5 {
	step 1 : wff = dffun3 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( x A y → y = z ) ) ) ;;
	step 2 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = imbi1i (step 2) |- ( ( x A y → y = z ) ↔ ( 〈 x , y 〉 ∈ A → y = z ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ y ( x A y → y = z ) ↔ ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ z ∀ y ( x A y → y = z ) ↔ ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ x ∃ z ∀ y ( x A y → y = z ) ↔ ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ;;
	step 7 : wff = anbi2i (step 6) |- ( ( Rel A ∧ ∀ x ∃ z ∀ y ( x A y → y = z ) ) ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ) ;;
	step 8 : wff = bitri (step 1, step 7) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Definition of function, using bound-variable hypotheses instead of
       distinct variable conditions.  (Contributed by NM, 9-Mar-1995.)
       (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem dffun6f (x : set, y : set, A : class) disjointed(x y w v u, A w v u) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	-----------------------
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃* y x A y ) ) ;;
}

proof of dffun6f {
	var w : set, v : set, u : set;;
	step 1 : wff = dffun3 () |- ( Fun A ↔ ( Rel A ∧ ∀ w ∃ u ∀ v ( w A v → v = u ) ) ) ;;
	step 2 : wff = nfcv () |- F/_ y w ;;
	step 3 : wff = nfcv () |- F/_ y v ;;
	step 4 : wff = nfbr (step 2, hyp 2, step 3) |- F/ y w A v ;;
	step 5 : wff = nfv () |- F/ v w A y ;;
	step 6 : wff = breq2 () |- ( v = y → ( w A v ↔ w A y ) ) ;;
	step 7 : wff = cbvmo (step 4, step 5, step 6) |- ( ∃* v w A v ↔ ∃* y w A y ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ w ∃* v w A v ↔ ∀ w ∃* y w A y ) ;;
	step 9 : wff = nfv () |- F/ u w A v ;;
	step 10 : wff = mo2 (step 9) |- ( ∃* v w A v ↔ ∃ u ∀ v ( w A v → v = u ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ w ∃* v w A v ↔ ∀ w ∃ u ∀ v ( w A v → v = u ) ) ;;
	step 12 : wff = nfcv () |- F/_ x w ;;
	step 13 : wff = nfcv () |- F/_ x y ;;
	step 14 : wff = nfbr (step 12, hyp 1, step 13) |- F/ x w A y ;;
	step 15 : wff = nfmo (step 14) |- F/ x ∃* y w A y ;;
	step 16 : wff = nfv () |- F/ w ∃* y x A y ;;
	step 17 : wff = breq1 () |- ( w = x → ( w A y ↔ x A y ) ) ;;
	step 18 : wff = mobidv (step 17) |- ( w = x → ( ∃* y w A y ↔ ∃* y x A y ) ) ;;
	step 19 : wff = cbval (step 15, step 16, step 18) |- ( ∀ w ∃* y w A y ↔ ∀ x ∃* y x A y ) ;;
	step 20 : wff = 3bitr3ri (step 8, step 11, step 19) |- ( ∀ x ∃* y x A y ↔ ∀ w ∃ u ∀ v ( w A v → v = u ) ) ;;
	step 21 : wff = anbi2i (step 20) |- ( ( Rel A ∧ ∀ x ∃* y x A y ) ↔ ( Rel A ∧ ∀ w ∃ u ∀ v ( w A v → v = u ) ) ) ;;
	step 22 : wff = bitr4i (step 1, step 21) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃* y x A y ) ) ;;
	qed prop 1 = step 22 ;;
}

/*Alternate definition of a function using "at most one" notation.
       (Contributed by NM, 9-Mar-1995.) */

theorem dffun6 (x : set, y : set, F : class) disjointed(x y, x y F) {
	prop 1 : wff = |- ( Fun F ↔ ( Rel F ∧ ∀ x ∃* y x F y ) ) ;;
}

proof of dffun6 {
	step 1 : wff = nfcv () |- F/_ x F ;;
	step 2 : wff = nfcv () |- F/_ y F ;;
	step 3 : wff = dffun6f (step 1, step 2) |- ( Fun F ↔ ( Rel F ∧ ∀ x ∃* y x F y ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A function has at most one value for each argument.  (Contributed by NM,
       24-May-1998.) */

theorem funmo (y : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( Fun F → ∃* y A F y ) ;;
}

proof of funmo {
	var x : set;;
	step 1 : wff = dffun6 () |- ( Fun F ↔ ( Rel F ∧ ∀ x ∃* y x F y ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( Fun F → Rel F ) ;;
	step 3 : wff = brrelex () |- ( ( Rel F ∧ A F y ) → A ∈ _V ) ;;
	step 4 : wff = ex (step 3) |- ( Rel F → ( A F y → A ∈ _V ) ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( Fun F → ( A F y → A ∈ _V ) ) ;;
	step 6 : wff = ancrd (step 5) |- ( Fun F → ( A F y → ( A ∈ _V ∧ A F y ) ) ) ;;
	step 7 : wff = alrimiv (step 6) |- ( Fun F → ∀ y ( A F y → ( A ∈ _V ∧ A F y ) ) ) ;;
	step 8 : wff = breq1 () |- ( x = A → ( x F y ↔ A F y ) ) ;;
	step 9 : wff = mobidv (step 8) |- ( x = A → ( ∃* y x F y ↔ ∃* y A F y ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( x = A → ( ( Fun F → ∃* y x F y ) ↔ ( Fun F → ∃* y A F y ) ) ) ;;
	step 11 : wff = dffun6 () |- ( Fun F ↔ ( Rel F ∧ ∀ x ∃* y x F y ) ) ;;
	step 12 : wff = simprbi (step 11) |- ( Fun F → ∀ x ∃* y x F y ) ;;
	step 13 : wff = 19.21bi (step 12) |- ( Fun F → ∃* y x F y ) ;;
	step 14 : wff = vtoclg (step 10, step 13) |- ( A ∈ _V → ( Fun F → ∃* y A F y ) ) ;;
	step 15 : wff = com12 (step 14) |- ( Fun F → ( A ∈ _V → ∃* y A F y ) ) ;;
	step 16 : wff = moanimv () |- ( ∃* y ( A ∈ _V ∧ A F y ) ↔ ( A ∈ _V → ∃* y A F y ) ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( Fun F → ∃* y ( A ∈ _V ∧ A F y ) ) ;;
	step 18 : wff = moim () |- ( ∀ y ( A F y → ( A ∈ _V ∧ A F y ) ) → ( ∃* y ( A ∈ _V ∧ A F y ) → ∃* y A F y ) ) ;;
	step 19 : wff = sylc (step 7, step 17, step 18) |- ( Fun F → ∃* y A F y ) ;;
	qed prop 1 = step 19 ;;
}

/*A function is a relation.  (Contributed by NM, 1-Aug-1994.) */

theorem funrel (A : class)  {
	prop 1 : wff = |- ( Fun A → Rel A ) ;;
}

proof of funrel {
	step 1 : wff = df-fun () |- ( Fun A ↔ ( Rel A ∧ ( A ∘ ⁻¹ A ) ⊆ _I ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( Fun A → Rel A ) ;;
	qed prop 1 = step 2 ;;
}

/*Subclass theorem for function predicate.  (Contributed by NM,
       16-Aug-1994.)  (Proof shortened by Mario Carneiro, 24-Jun-2014.) */

theorem funss (A : class, B : class) disjointed(A, B) {
	prop 1 : wff = |- ( A ⊆ B → ( Fun B → Fun A ) ) ;;
}

proof of funss {
	step 1 : wff = relss () |- ( A ⊆ B → ( Rel B → Rel A ) ) ;;
	step 2 : wff = coss1 () |- ( A ⊆ B → ( A ∘ ⁻¹ A ) ⊆ ( B ∘ ⁻¹ A ) ) ;;
	step 3 : wff = cnvss () |- ( A ⊆ B → ⁻¹ A ⊆ ⁻¹ B ) ;;
	step 4 : wff = coss2 () |- ( ⁻¹ A ⊆ ⁻¹ B → ( B ∘ ⁻¹ A ) ⊆ ( B ∘ ⁻¹ B ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( A ⊆ B → ( B ∘ ⁻¹ A ) ⊆ ( B ∘ ⁻¹ B ) ) ;;
	step 6 : wff = sstrd (step 2, step 5) |- ( A ⊆ B → ( A ∘ ⁻¹ A ) ⊆ ( B ∘ ⁻¹ B ) ) ;;
	step 7 : wff = sstr2 () |- ( ( A ∘ ⁻¹ A ) ⊆ ( B ∘ ⁻¹ B ) → ( ( B ∘ ⁻¹ B ) ⊆ _I → ( A ∘ ⁻¹ A ) ⊆ _I ) ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( A ⊆ B → ( ( B ∘ ⁻¹ B ) ⊆ _I → ( A ∘ ⁻¹ A ) ⊆ _I ) ) ;;
	step 9 : wff = anim12d (step 1, step 8) |- ( A ⊆ B → ( ( Rel B ∧ ( B ∘ ⁻¹ B ) ⊆ _I ) → ( Rel A ∧ ( A ∘ ⁻¹ A ) ⊆ _I ) ) ) ;;
	step 10 : wff = df-fun () |- ( Fun B ↔ ( Rel B ∧ ( B ∘ ⁻¹ B ) ⊆ _I ) ) ;;
	step 11 : wff = df-fun () |- ( Fun A ↔ ( Rel A ∧ ( A ∘ ⁻¹ A ) ⊆ _I ) ) ;;
	step 12 : wff = 3imtr4g (step 9, step 10, step 11) |- ( A ⊆ B → ( Fun B → Fun A ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Equality theorem for function predicate.  (Contributed by NM,
     16-Aug-1994.) */

theorem funeq (A : class, B : class)  {
	prop 1 : wff = |- ( A = B → ( Fun A ↔ Fun B ) ) ;;
}

proof of funeq {
	step 1 : wff = eqimss2 () |- ( A = B → B ⊆ A ) ;;
	step 2 : wff = funss () |- ( B ⊆ A → ( Fun A → Fun B ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A = B → ( Fun A → Fun B ) ) ;;
	step 4 : wff = eqimss () |- ( A = B → A ⊆ B ) ;;
	step 5 : wff = funss () |- ( A ⊆ B → ( Fun B → Fun A ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A = B → ( Fun B → Fun A ) ) ;;
	step 7 : wff = impbid (step 3, step 6) |- ( A = B → ( Fun A ↔ Fun B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality inference for the function predicate.  (Contributed by Jonathan
       Ben-Naim, 3-Jun-2011.) */

theorem funeqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( Fun A ↔ Fun B ) ;;
}

proof of funeqi {
	step 1 : wff = funeq () |- ( A = B → ( Fun A ↔ Fun B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( Fun A ↔ Fun B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for the function predicate.  (Contributed by NM,
       23-Feb-2013.) */

theorem funeqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( Fun A ↔ Fun B ) ) ;;
}

proof of funeqd {
	step 1 : wff = funeq () |- ( A = B → ( Fun A ↔ Fun B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( Fun A ↔ Fun B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for a function.  (Contributed by NM,
       30-Jan-2004.) */

theorem nffun (x : set, F : class)  {
	hyp 1 : wff = |- F/_ x F ;;
	-----------------------
	prop 1 : wff = |- F/ x Fun F ;;
}

proof of nffun {
	step 1 : wff = df-fun () |- ( Fun F ↔ ( Rel F ∧ ( F ∘ ⁻¹ F ) ⊆ _I ) ) ;;
	step 2 : wff = nfrel (hyp 1) |- F/ x Rel F ;;
	step 3 : wff = nfcnv (hyp 1) |- F/_ x ⁻¹ F ;;
	step 4 : wff = nfco (hyp 1, step 3) |- F/_ x ( F ∘ ⁻¹ F ) ;;
	step 5 : wff = nfcv () |- F/_ x _I ;;
	step 6 : wff = nfss (step 4, step 5) |- F/ x ( F ∘ ⁻¹ F ) ⊆ _I ;;
	step 7 : wff = nfan (step 2, step 6) |- F/ x ( Rel F ∧ ( F ∘ ⁻¹ F ) ⊆ _I ) ;;
	step 8 : wff = nfxfr (step 1, step 7) |- F/ x Fun F ;;
	qed prop 1 = step 8 ;;
}

/*There is exactly one value of a function.  (Contributed by NM,
       22-Apr-2004.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem funeu (y : set, A : class, B : class, F : class) disjointed(y A, y F) {
	prop 1 : wff = |- ( ( Fun F ∧ A F B ) → ∃! y A F y ) ;;
}

proof of funeu {
	step 1 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 2 : wff = releldm () |- ( ( Rel F ∧ A F B ) → A ∈ dom F ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( Fun F ∧ A F B ) → A ∈ dom F ) ;;
	step 4 : wff = eldmg () |- ( A ∈ dom F → ( A ∈ dom F ↔ ∃ y A F y ) ) ;;
	step 5 : wff = ibi (step 4) |- ( A ∈ dom F → ∃ y A F y ) ;;
	step 6 : wff = syl (step 3, step 5) |- ( ( Fun F ∧ A F B ) → ∃ y A F y ) ;;
	step 7 : wff = funmo () |- ( Fun F → ∃* y A F y ) ;;
	step 8 : wff = adantr (step 7) |- ( ( Fun F ∧ A F B ) → ∃* y A F y ) ;;
	step 9 : wff = df-mo () |- ( ∃* y A F y ↔ ( ∃ y A F y → ∃! y A F y ) ) ;;
	step 10 : wff = sylib (step 8, step 9) |- ( ( Fun F ∧ A F B ) → ( ∃ y A F y → ∃! y A F y ) ) ;;
	step 11 : wff = mpd (step 6, step 10) |- ( ( Fun F ∧ A F B ) → ∃! y A F y ) ;;
	qed prop 1 = step 11 ;;
}

/*There is exactly one value of a function.  (Contributed by NM,
       3-Aug-1994.) */

theorem funeu2 (y : set, A : class, B : class, F : class) disjointed(y A, y F) {
	prop 1 : wff = |- ( ( Fun F ∧ 〈 A , B 〉 ∈ F ) → ∃! y 〈 A , y 〉 ∈ F ) ;;
}

proof of funeu2 {
	step 1 : wff = df-br () |- ( A F B ↔ 〈 A , B 〉 ∈ F ) ;;
	step 2 : wff = funeu () |- ( ( Fun F ∧ A F B ) → ∃! y A F y ) ;;
	step 3 : wff = df-br () |- ( A F y ↔ 〈 A , y 〉 ∈ F ) ;;
	step 4 : wff = eubii (step 3) |- ( ∃! y A F y ↔ ∃! y 〈 A , y 〉 ∈ F ) ;;
	step 5 : wff = sylib (step 2, step 4) |- ( ( Fun F ∧ A F B ) → ∃! y 〈 A , y 〉 ∈ F ) ;;
	step 6 : wff = sylan2br (step 1, step 5) |- ( ( Fun F ∧ 〈 A , B 〉 ∈ F ) → ∃! y 〈 A , y 〉 ∈ F ) ;;
	qed prop 1 = step 6 ;;
}

/*Alternate definition of a function.  One possibility for the definition
       of a function in [Enderton] p. 42.  (Enderton's definition is ambiguous
       because "there is only one" could mean either "there is at most one" or
       "there is exactly one."  However, ~ dffun8 shows that it doesn't matter
       which meaning we pick.)  (Contributed by NM, 4-Nov-2002.) */

theorem dffun7 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ) ;;
}

proof of dffun7 {
	step 1 : wff = dffun6 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃* y x A y ) ) ;;
	step 2 : wff = moabs () |- ( ∃* y x A y ↔ ( ∃ y x A y → ∃* y x A y ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = eldm (step 3) |- ( x ∈ dom A ↔ ∃ y x A y ) ;;
	step 5 : wff = imbi1i (step 4) |- ( ( x ∈ dom A → ∃* y x A y ) ↔ ( ∃ y x A y → ∃* y x A y ) ) ;;
	step 6 : wff = bitr4i (step 2, step 5) |- ( ∃* y x A y ↔ ( x ∈ dom A → ∃* y x A y ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ x ∃* y x A y ↔ ∀ x ( x ∈ dom A → ∃* y x A y ) ) ;;
	step 8 : wff = df-ral () |- ( ∀ x ∈ dom A ∃* y x A y ↔ ∀ x ( x ∈ dom A → ∃* y x A y ) ) ;;
	step 9 : wff = bitr4i (step 7, step 8) |- ( ∀ x ∃* y x A y ↔ ∀ x ∈ dom A ∃* y x A y ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( Rel A ∧ ∀ x ∃* y x A y ) ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Alternate definition of a function.  One possibility for the definition
       of a function in [Enderton] p. 42.  Compare ~ dffun7 .  (Contributed by
       NM, 4-Nov-2002.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem dffun8 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃! y x A y ) ) ;;
}

proof of dffun8 {
	step 1 : wff = dffun7 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ) ;;
	step 2 : wff = df-mo () |- ( ∃* y x A y ↔ ( ∃ y x A y → ∃! y x A y ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = eldm (step 3) |- ( x ∈ dom A ↔ ∃ y x A y ) ;;
	step 5 : wff = pm5.5 () |- ( ∃ y x A y → ( ( ∃ y x A y → ∃! y x A y ) ↔ ∃! y x A y ) ) ;;
	step 6 : wff = sylbi (step 4, step 5) |- ( x ∈ dom A → ( ( ∃ y x A y → ∃! y x A y ) ↔ ∃! y x A y ) ) ;;
	step 7 : wff = syl5bb (step 2, step 6) |- ( x ∈ dom A → ( ∃* y x A y ↔ ∃! y x A y ) ) ;;
	step 8 : wff = ralbiia (step 7) |- ( ∀ x ∈ dom A ∃* y x A y ↔ ∀ x ∈ dom A ∃! y x A y ) ;;
	step 9 : wff = anbi2i (step 8) |- ( ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ↔ ( Rel A ∧ ∀ x ∈ dom A ∃! y x A y ) ) ;;
	step 10 : wff = bitri (step 1, step 9) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃! y x A y ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Alternate definition of a function.  (Contributed by NM, 28-Mar-2007.)
       (Revised by NM, 16-Jun-2017.) */

theorem dffun9 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y ∈ ran A x A y ) ) ;;
}

proof of dffun9 {
	step 1 : wff = dffun7 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = brelrn (step 2, step 3) |- ( x A y → y ∈ ran A ) ;;
	step 5 : wff = pm4.71ri (step 4) |- ( x A y ↔ ( y ∈ ran A ∧ x A y ) ) ;;
	step 6 : wff = mobii (step 5) |- ( ∃* y x A y ↔ ∃* y ( y ∈ ran A ∧ x A y ) ) ;;
	step 7 : wff = df-rmo () |- ( ∃* y ∈ ran A x A y ↔ ∃* y ( y ∈ ran A ∧ x A y ) ) ;;
	step 8 : wff = bitr4i (step 6, step 7) |- ( ∃* y x A y ↔ ∃* y ∈ ran A x A y ) ;;
	step 9 : wff = ralbii (step 8) |- ( ∀ x ∈ dom A ∃* y x A y ↔ ∀ x ∈ dom A ∃* y ∈ ran A x A y ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( Rel A ∧ ∀ x ∈ dom A ∃* y x A y ) ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y ∈ ran A x A y ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( Fun A ↔ ( Rel A ∧ ∀ x ∈ dom A ∃* y ∈ ran A x A y ) ) ;;
	qed prop 1 = step 11 ;;
}

/*An equivalence for the function predicate.  (Contributed by NM,
     13-Aug-2004.) */

theorem funfn (A : class)  {
	prop 1 : wff = |- ( Fun A ↔ A Fn dom A ) ;;
}

proof of funfn {
	step 1 : wff = eqid () |- dom A = dom A ;;
	step 2 : wff = biantru (step 1) |- ( Fun A ↔ ( Fun A ∧ dom A = dom A ) ) ;;
	step 3 : wff = df-fn () |- ( A Fn dom A ↔ ( Fun A ∧ dom A = dom A ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( Fun A ↔ A Fn dom A ) ;;
	qed prop 1 = step 4 ;;
}

/*The identity relation is a function.  Part of Theorem 10.4 of [Quine]
     p. 65.  (Contributed by NM, 30-Apr-1998.) */

theorem funi ()  {
	prop 1 : wff = |- Fun _I ;;
}

proof of funi {
	step 1 : wff = reli () |- Rel _I ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ _I ;;
	step 3 : wff = coi2 () |- ( Rel ⁻¹ _I → ( _I ∘ ⁻¹ _I ) = ⁻¹ _I ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( _I ∘ ⁻¹ _I ) = ⁻¹ _I ;;
	step 5 : wff = cnvi () |- ⁻¹ _I = _I ;;
	step 6 : wff = eqtri (step 4, step 5) |- ( _I ∘ ⁻¹ _I ) = _I ;;
	step 7 : wff = eqimssi (step 6) |- ( _I ∘ ⁻¹ _I ) ⊆ _I ;;
	step 8 : wff = df-fun () |- ( Fun _I ↔ ( Rel _I ∧ ( _I ∘ ⁻¹ _I ) ⊆ _I ) ) ;;
	step 9 : wff = mpbir2an (step 1, step 7, step 8) |- Fun _I ;;
	qed prop 1 = step 9 ;;
}

/*The universe is not a function.  (Contributed by Raph Levien,
     27-Jan-2004.) */

theorem nfunv ()  {
	prop 1 : wff = |- ¬ Fun _V ;;
}

proof of nfunv {
	step 1 : wff = 0nelxp () |- ¬ ∅ ∈ ( _V × _V ) ;;
	step 2 : wff = 0ex () |- ∅ ∈ _V ;;
	step 3 : wff = df-rel () |- ( Rel _V ↔ _V ⊆ ( _V × _V ) ) ;;
	step 4 : wff = biimpi (step 3) |- ( Rel _V → _V ⊆ ( _V × _V ) ) ;;
	step 5 : wff = sseld (step 4) |- ( Rel _V → ( ∅ ∈ _V → ∅ ∈ ( _V × _V ) ) ) ;;
	step 6 : wff = mpi (step 2, step 5) |- ( Rel _V → ∅ ∈ ( _V × _V ) ) ;;
	step 7 : wff = mto (step 1, step 6) |- ¬ Rel _V ;;
	step 8 : wff = funrel () |- ( Fun _V → Rel _V ) ;;
	step 9 : wff = mto (step 7, step 8) |- ¬ Fun _V ;;
	qed prop 1 = step 9 ;;
}

/*A Kuratowski ordered pair is a function only if its components are
       equal.  (Contributed by NM, 5-Jun-2008.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem funopg (A : class, B : class, V : class, W : class) disjointed(t u v w x y z A, t u v w x y z B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ Fun 〈 A , B 〉 ) → A = B ) ;;
}

proof of funopg {
	var x : set, y : set, z : set, w : set, v : set, u : set, t : set;;
	step 1 : wff = opeq1 () |- ( u = A → 〈 u , t 〉 = 〈 A , t 〉 ) ;;
	step 2 : wff = funeqd (step 1) |- ( u = A → ( Fun 〈 u , t 〉 ↔ Fun 〈 A , t 〉 ) ) ;;
	step 3 : wff = eqeq1 () |- ( u = A → ( u = t ↔ A = t ) ) ;;
	step 4 : wff = imbi12d (step 2, step 3) |- ( u = A → ( ( Fun 〈 u , t 〉 → u = t ) ↔ ( Fun 〈 A , t 〉 → A = t ) ) ) ;;
	step 5 : wff = opeq2 () |- ( t = B → 〈 A , t 〉 = 〈 A , B 〉 ) ;;
	step 6 : wff = funeqd (step 5) |- ( t = B → ( Fun 〈 A , t 〉 ↔ Fun 〈 A , B 〉 ) ) ;;
	step 7 : wff = eqeq2 () |- ( t = B → ( A = t ↔ A = B ) ) ;;
	step 8 : wff = imbi12d (step 6, step 7) |- ( t = B → ( ( Fun 〈 A , t 〉 → A = t ) ↔ ( Fun 〈 A , B 〉 → A = B ) ) ) ;;
	step 9 : wff = funrel () |- ( Fun 〈 u , t 〉 → Rel 〈 u , t 〉 ) ;;
	step 10 : wff = vex () |- u ∈ _V ;;
	step 11 : wff = vex () |- t ∈ _V ;;
	step 12 : wff = relop (step 10, step 11) |- ( Rel 〈 u , t 〉 ↔ ∃ x ∃ y ( u = { x } ∧ t = { x , y } ) ) ;;
	step 13 : wff = sylib (step 9, step 12) |- ( Fun 〈 u , t 〉 → ∃ x ∃ y ( u = { x } ∧ t = { x , y } ) ) ;;
	step 14 : wff = vex () |- u ∈ _V ;;
	step 15 : wff = vex () |- t ∈ _V ;;
	step 16 : wff = opth (step 14, step 15) |- ( 〈 u , t 〉 = 〈 { x } , { x , y } 〉 ↔ ( u = { x } ∧ t = { x , y } ) ) ;;
	step 17 : wff = vex () |- x ∈ _V ;;
	step 18 : wff = opid (step 17) |- 〈 x , x 〉 = { { x } } ;;
	step 19 : wff = preq1i (step 18) |- { 〈 x , x 〉 , { { x } , { x , y } } } = { { { x } } , { { x } , { x , y } } } ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = dfop (step 20, step 21) |- 〈 x , y 〉 = { { x } , { x , y } } ;;
	step 23 : wff = preq2i (step 22) |- { 〈 x , x 〉 , 〈 x , y 〉 } = { 〈 x , x 〉 , { { x } , { x , y } } } ;;
	step 24 : wff = snex () |- { x } ∈ _V ;;
	step 25 : wff = zfpair2 () |- { x , y } ∈ _V ;;
	step 26 : wff = dfop (step 24, step 25) |- 〈 { x } , { x , y } 〉 = { { { x } } , { { x } , { x , y } } } ;;
	step 27 : wff = 3eqtr4ri (step 19, step 23, step 26) |- 〈 { x } , { x , y } 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } ;;
	step 28 : wff = eqeq2i (step 27) |- ( 〈 u , t 〉 = 〈 { x } , { x , y } 〉 ↔ 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } ) ;;
	step 29 : wff = bitr3i (step 16, step 28) |- ( ( u = { x } ∧ t = { x , y } ) ↔ 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } ) ;;
	step 30 : wff = dffun4 () |- ( Fun 〈 u , t 〉 ↔ ( Rel 〈 u , t 〉 ∧ ∀ z ∀ w ∀ v ( ( 〈 z , w 〉 ∈ 〈 u , t 〉 ∧ 〈 z , v 〉 ∈ 〈 u , t 〉 ) → w = v ) ) ) ;;
	step 31 : wff = simprbi (step 30) |- ( Fun 〈 u , t 〉 → ∀ z ∀ w ∀ v ( ( 〈 z , w 〉 ∈ 〈 u , t 〉 ∧ 〈 z , v 〉 ∈ 〈 u , t 〉 ) → w = v ) ) ;;
	step 32 : wff = opex () |- 〈 x , x 〉 ∈ _V ;;
	step 33 : wff = prid1 (step 32) |- 〈 x , x 〉 ∈ { 〈 x , x 〉 , 〈 x , y 〉 } ;;
	step 34 : wff = eleq2 () |- ( 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } → ( 〈 x , x 〉 ∈ 〈 u , t 〉 ↔ 〈 x , x 〉 ∈ { 〈 x , x 〉 , 〈 x , y 〉 } ) ) ;;
	step 35 : wff = mpbiri (step 33, step 34) |- ( 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } → 〈 x , x 〉 ∈ 〈 u , t 〉 ) ;;
	step 36 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 37 : wff = prid2 (step 36) |- 〈 x , y 〉 ∈ { 〈 x , x 〉 , 〈 x , y 〉 } ;;
	step 38 : wff = eleq2 () |- ( 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } → ( 〈 x , y 〉 ∈ 〈 u , t 〉 ↔ 〈 x , y 〉 ∈ { 〈 x , x 〉 , 〈 x , y 〉 } ) ) ;;
	step 39 : wff = mpbiri (step 37, step 38) |- ( 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } → 〈 x , y 〉 ∈ 〈 u , t 〉 ) ;;
	step 40 : wff = jca (step 35, step 39) |- ( 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } → ( 〈 x , x 〉 ∈ 〈 u , t 〉 ∧ 〈 x , y 〉 ∈ 〈 u , t 〉 ) ) ;;
	step 41 : wff = vex () |- x ∈ _V ;;
	step 42 : wff = vex () |- x ∈ _V ;;
	step 43 : wff = vex () |- y ∈ _V ;;
	step 44 : wff = opeq12 () |- ( ( z = x ∧ w = x ) → 〈 z , w 〉 = 〈 x , x 〉 ) ;;
	step 45 : wff = 3adant3 (step 44) |- ( ( z = x ∧ w = x ∧ v = y ) → 〈 z , w 〉 = 〈 x , x 〉 ) ;;
	step 46 : wff = eleq1d (step 45) |- ( ( z = x ∧ w = x ∧ v = y ) → ( 〈 z , w 〉 ∈ 〈 u , t 〉 ↔ 〈 x , x 〉 ∈ 〈 u , t 〉 ) ) ;;
	step 47 : wff = opeq12 () |- ( ( z = x ∧ v = y ) → 〈 z , v 〉 = 〈 x , y 〉 ) ;;
	step 48 : wff = 3adant2 (step 47) |- ( ( z = x ∧ w = x ∧ v = y ) → 〈 z , v 〉 = 〈 x , y 〉 ) ;;
	step 49 : wff = eleq1d (step 48) |- ( ( z = x ∧ w = x ∧ v = y ) → ( 〈 z , v 〉 ∈ 〈 u , t 〉 ↔ 〈 x , y 〉 ∈ 〈 u , t 〉 ) ) ;;
	step 50 : wff = anbi12d (step 46, step 49) |- ( ( z = x ∧ w = x ∧ v = y ) → ( ( 〈 z , w 〉 ∈ 〈 u , t 〉 ∧ 〈 z , v 〉 ∈ 〈 u , t 〉 ) ↔ ( 〈 x , x 〉 ∈ 〈 u , t 〉 ∧ 〈 x , y 〉 ∈ 〈 u , t 〉 ) ) ) ;;
	step 51 : wff = eqeq12 () |- ( ( w = x ∧ v = y ) → ( w = v ↔ x = y ) ) ;;
	step 52 : wff = 3adant1 (step 51) |- ( ( z = x ∧ w = x ∧ v = y ) → ( w = v ↔ x = y ) ) ;;
	step 53 : wff = imbi12d (step 50, step 52) |- ( ( z = x ∧ w = x ∧ v = y ) → ( ( ( 〈 z , w 〉 ∈ 〈 u , t 〉 ∧ 〈 z , v 〉 ∈ 〈 u , t 〉 ) → w = v ) ↔ ( ( 〈 x , x 〉 ∈ 〈 u , t 〉 ∧ 〈 x , y 〉 ∈ 〈 u , t 〉 ) → x = y ) ) ) ;;
	step 54 : wff = spc3gv (step 53) |- ( ( x ∈ _V ∧ x ∈ _V ∧ y ∈ _V ) → ( ∀ z ∀ w ∀ v ( ( 〈 z , w 〉 ∈ 〈 u , t 〉 ∧ 〈 z , v 〉 ∈ 〈 u , t 〉 ) → w = v ) → ( ( 〈 x , x 〉 ∈ 〈 u , t 〉 ∧ 〈 x , y 〉 ∈ 〈 u , t 〉 ) → x = y ) ) ) ;;
	step 55 : wff = mp3an (step 41, step 42, step 43, step 54) |- ( ∀ z ∀ w ∀ v ( ( 〈 z , w 〉 ∈ 〈 u , t 〉 ∧ 〈 z , v 〉 ∈ 〈 u , t 〉 ) → w = v ) → ( ( 〈 x , x 〉 ∈ 〈 u , t 〉 ∧ 〈 x , y 〉 ∈ 〈 u , t 〉 ) → x = y ) ) ;;
	step 56 : wff = syl2im (step 31, step 40, step 55) |- ( Fun 〈 u , t 〉 → ( 〈 u , t 〉 = { 〈 x , x 〉 , 〈 x , y 〉 } → x = y ) ) ;;
	step 57 : wff = syl5bi (step 29, step 56) |- ( Fun 〈 u , t 〉 → ( ( u = { x } ∧ t = { x , y } ) → x = y ) ) ;;
	step 58 : wff = dfsn2 () |- { x } = { x , x } ;;
	step 59 : wff = preq2 () |- ( x = y → { x , x } = { x , y } ) ;;
	step 60 : wff = syl5req (step 58, step 59) |- ( x = y → { x , y } = { x } ) ;;
	step 61 : wff = eqeq2d (step 60) |- ( x = y → ( t = { x , y } ↔ t = { x } ) ) ;;
	step 62 : wff = eqtr3 () |- ( ( u = { x } ∧ t = { x } ) → u = t ) ;;
	step 63 : wff = expcom (step 62) |- ( t = { x } → ( u = { x } → u = t ) ) ;;
	step 64 : wff = syl6bi (step 61, step 63) |- ( x = y → ( t = { x , y } → ( u = { x } → u = t ) ) ) ;;
	step 65 : wff = com13 (step 64) |- ( u = { x } → ( t = { x , y } → ( x = y → u = t ) ) ) ;;
	step 66 : wff = imp (step 65) |- ( ( u = { x } ∧ t = { x , y } ) → ( x = y → u = t ) ) ;;
	step 67 : wff = sylcom (step 57, step 66) |- ( Fun 〈 u , t 〉 → ( ( u = { x } ∧ t = { x , y } ) → u = t ) ) ;;
	step 68 : wff = exlimdvv (step 67) |- ( Fun 〈 u , t 〉 → ( ∃ x ∃ y ( u = { x } ∧ t = { x , y } ) → u = t ) ) ;;
	step 69 : wff = mpd (step 13, step 68) |- ( Fun 〈 u , t 〉 → u = t ) ;;
	step 70 : wff = vtocl2g (step 4, step 8, step 69) |- ( ( A ∈ V ∧ B ∈ W ) → ( Fun 〈 A , B 〉 → A = B ) ) ;;
	step 71 : wff = 3impia (step 70) |- ( ( A ∈ V ∧ B ∈ W ∧ Fun 〈 A , B 〉 ) → A = B ) ;;
	qed prop 1 = step 71 ;;
}

/*A class of ordered pairs is a function when there is at most one second
       member for each pair.  (Contributed by NM, 16-May-1995.) */

theorem funopab (ph : wff, x : set, y : set) disjointed(x y, ph) {
	prop 1 : wff = |- ( Fun { 〈 x , y 〉 | ph } ↔ ∀ x ∃* y ph ) ;;
}

proof of funopab {
	step 1 : wff = relopab () |- Rel { 〈 x , y 〉 | ph } ;;
	step 2 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ph } ;;
	step 3 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ph } ;;
	step 4 : wff = dffun6f (step 2, step 3) |- ( Fun { 〈 x , y 〉 | ph } ↔ ( Rel { 〈 x , y 〉 | ph } ∧ ∀ x ∃* y x { 〈 x , y 〉 | ph } y ) ) ;;
	step 5 : wff = mpbiran (step 1, step 4) |- ( Fun { 〈 x , y 〉 | ph } ↔ ∀ x ∃* y x { 〈 x , y 〉 | ph } y ) ;;
	step 6 : wff = df-br () |- ( x { 〈 x , y 〉 | ph } y ↔ 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 7 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( x { 〈 x , y 〉 | ph } y ↔ ph ) ;;
	step 9 : wff = mobii (step 8) |- ( ∃* y x { 〈 x , y 〉 | ph } y ↔ ∃* y ph ) ;;
	step 10 : wff = albii (step 9) |- ( ∀ x ∃* y x { 〈 x , y 〉 | ph } y ↔ ∀ x ∃* y ph ) ;;
	step 11 : wff = bitri (step 5, step 10) |- ( Fun { 〈 x , y 〉 | ph } ↔ ∀ x ∃* y ph ) ;;
	qed prop 1 = step 11 ;;
}

/*A class of ordered pairs of values is a function.  (Contributed by NM,
       14-Nov-1995.) */

theorem funopabeq (x : set, y : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- Fun { 〈 x , y 〉 | y = A } ;;
}

proof of funopabeq {
	step 1 : wff = funopab () |- ( Fun { 〈 x , y 〉 | y = A } ↔ ∀ x ∃* y y = A ) ;;
	step 2 : wff = moeq () |- ∃* y y = A ;;
	step 3 : wff = mpgbir (step 1, step 2) |- Fun { 〈 x , y 〉 | y = A } ;;
	qed prop 1 = step 3 ;;
}

/*A class of ordered pairs of values in the form used by ~ df-mpt is a
       function.  (Contributed by NM, 17-Feb-2013.) */

theorem funopab4 (ph : wff, x : set, y : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- Fun { 〈 x , y 〉 | ( ph ∧ y = A ) } ;;
}

proof of funopab4 {
	step 1 : wff = simpr () |- ( ( ph ∧ y = A ) → y = A ) ;;
	step 2 : wff = ssopab2i (step 1) |- { 〈 x , y 〉 | ( ph ∧ y = A ) } ⊆ { 〈 x , y 〉 | y = A } ;;
	step 3 : wff = funopabeq () |- Fun { 〈 x , y 〉 | y = A } ;;
	step 4 : wff = funss () |- ( { 〈 x , y 〉 | ( ph ∧ y = A ) } ⊆ { 〈 x , y 〉 | y = A } → ( Fun { 〈 x , y 〉 | y = A } → Fun { 〈 x , y 〉 | ( ph ∧ y = A ) } ) ) ;;
	step 5 : wff = mp2 (step 2, step 3, step 4) |- Fun { 〈 x , y 〉 | ( ph ∧ y = A ) } ;;
	qed prop 1 = step 5 ;;
}

/*A function in maps-to notation is a function.  (Contributed by Mario
       Carneiro, 13-Jan-2013.) */

theorem funmpt (x : set, A : class, B : class) disjointed(A y, B y, x y) {
	prop 1 : wff = |- Fun ( x ∈ A ↦ B ) ;;
}

proof of funmpt {
	var y : set;;
	step 1 : wff = funopab4 () |- Fun { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 2 : wff = df-mpt () |- ( x ∈ A ↦ B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 3 : wff = funeqi (step 2) |- ( Fun ( x ∈ A ↦ B ) ↔ Fun { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ) ;;
	step 4 : wff = mpbir (step 1, step 3) |- Fun ( x ∈ A ↦ B ) ;;
	qed prop 1 = step 4 ;;
}

/*Functionality of a class given by a "maps to" notation.  (Contributed by
       FL, 17-Feb-2008.)  (Revised by Mario Carneiro, 31-May-2014.) */

theorem funmpt2 (x : set, A : class, B : class, F : class)  {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- Fun F ;;
}

proof of funmpt2 {
	step 1 : wff = funmpt () |- Fun ( x ∈ A ↦ B ) ;;
	step 2 : wff = funeqi (hyp 1) |- ( Fun F ↔ Fun ( x ∈ A ↦ B ) ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- Fun F ;;
	qed prop 1 = step 3 ;;
}

/*The composition of two functions is a function.  Exercise 29 of
       [TakeutiZaring] p. 25.  (Contributed by NM, 26-Jan-1997.)  (Proof
       shortened by Andrew Salmon, 17-Sep-2011.) */

theorem funco (F : class, G : class) disjointed(x y z F, x y z G) {
	prop 1 : wff = |- ( ( Fun F ∧ Fun G ) → Fun ( F ∘ G ) ) ;;
}

proof of funco {
	var x : set, y : set, z : set;;
	step 1 : wff = funmo () |- ( Fun G → ∃* z x G z ) ;;
	step 2 : wff = funmo () |- ( Fun F → ∃* y z F y ) ;;
	step 3 : wff = alrimiv (step 2) |- ( Fun F → ∀ z ∃* y z F y ) ;;
	step 4 : wff = moexexv () |- ( ( ∃* z x G z ∧ ∀ z ∃* y z F y ) → ∃* y ∃ z ( x G z ∧ z F y ) ) ;;
	step 5 : wff = syl2anr (step 1, step 3, step 4) |- ( ( Fun F ∧ Fun G ) → ∃* y ∃ z ( x G z ∧ z F y ) ) ;;
	step 6 : wff = alrimiv (step 5) |- ( ( Fun F ∧ Fun G ) → ∀ x ∃* y ∃ z ( x G z ∧ z F y ) ) ;;
	step 7 : wff = funopab () |- ( Fun { 〈 x , y 〉 | ∃ z ( x G z ∧ z F y ) } ↔ ∀ x ∃* y ∃ z ( x G z ∧ z F y ) ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( Fun F ∧ Fun G ) → Fun { 〈 x , y 〉 | ∃ z ( x G z ∧ z F y ) } ) ;;
	step 9 : wff = df-co () |- ( F ∘ G ) = { 〈 x , y 〉 | ∃ z ( x G z ∧ z F y ) } ;;
	step 10 : wff = funeqi (step 9) |- ( Fun ( F ∘ G ) ↔ Fun { 〈 x , y 〉 | ∃ z ( x G z ∧ z F y ) } ) ;;
	step 11 : wff = sylibr (step 8, step 10) |- ( ( Fun F ∧ Fun G ) → Fun ( F ∘ G ) ) ;;
	qed prop 1 = step 11 ;;
}

/*A restriction of a function is a function.  Compare Exercise 18 of
     [TakeutiZaring] p. 25.  (Contributed by NM, 16-Aug-1994.) */

theorem funres (A : class, F : class)  {
	prop 1 : wff = |- ( Fun F → Fun ( F ↾ A ) ) ;;
}

proof of funres {
	step 1 : wff = resss () |- ( F ↾ A ) ⊆ F ;;
	step 2 : wff = funss () |- ( ( F ↾ A ) ⊆ F → ( Fun F → Fun ( F ↾ A ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( Fun F → Fun ( F ↾ A ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The restriction of a function to the domain of a subclass equals the
       subclass.  (Contributed by NM, 15-Aug-1994.) */

theorem funssres (F : class, G : class) disjointed(x y F, x y G, x y) {
	prop 1 : wff = |- ( ( Fun F ∧ G ⊆ F ) → ( F ↾ dom G ) = G ) ;;
}

proof of funssres {
	var x : set, y : set;;
	step 1 : wff = ssel () |- ( G ⊆ F → ( 〈 x , y 〉 ∈ G → 〈 x , y 〉 ∈ F ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opeldm (step 2, step 3) |- ( 〈 x , y 〉 ∈ G → x ∈ dom G ) ;;
	step 5 : wff = a1i (step 4) |- ( G ⊆ F → ( 〈 x , y 〉 ∈ G → x ∈ dom G ) ) ;;
	step 6 : wff = jcad (step 1, step 5) |- ( G ⊆ F → ( 〈 x , y 〉 ∈ G → ( 〈 x , y 〉 ∈ F ∧ x ∈ dom G ) ) ) ;;
	step 7 : wff = adantl (step 6) |- ( ( Fun F ∧ G ⊆ F ) → ( 〈 x , y 〉 ∈ G → ( 〈 x , y 〉 ∈ F ∧ x ∈ dom G ) ) ) ;;
	step 8 : wff = funeu2 () |- ( ( Fun F ∧ 〈 x , y 〉 ∈ F ) → ∃! y 〈 x , y 〉 ∈ F ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = eldm2 (step 9) |- ( x ∈ dom G ↔ ∃ y 〈 x , y 〉 ∈ G ) ;;
	step 11 : wff = ssel () |- ( G ⊆ F → ( 〈 x , y 〉 ∈ G → 〈 x , y 〉 ∈ F ) ) ;;
	step 12 : wff = ancrd (step 11) |- ( G ⊆ F → ( 〈 x , y 〉 ∈ G → ( 〈 x , y 〉 ∈ F ∧ 〈 x , y 〉 ∈ G ) ) ) ;;
	step 13 : wff = eximdv (step 12) |- ( G ⊆ F → ( ∃ y 〈 x , y 〉 ∈ G → ∃ y ( 〈 x , y 〉 ∈ F ∧ 〈 x , y 〉 ∈ G ) ) ) ;;
	step 14 : wff = syl5bi (step 10, step 13) |- ( G ⊆ F → ( x ∈ dom G → ∃ y ( 〈 x , y 〉 ∈ F ∧ 〈 x , y 〉 ∈ G ) ) ) ;;
	step 15 : wff = imp (step 14) |- ( ( G ⊆ F ∧ x ∈ dom G ) → ∃ y ( 〈 x , y 〉 ∈ F ∧ 〈 x , y 〉 ∈ G ) ) ;;
	step 16 : wff = eupick () |- ( ( ∃! y 〈 x , y 〉 ∈ F ∧ ∃ y ( 〈 x , y 〉 ∈ F ∧ 〈 x , y 〉 ∈ G ) ) → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ G ) ) ;;
	step 17 : wff = syl2an (step 8, step 15, step 16) |- ( ( ( Fun F ∧ 〈 x , y 〉 ∈ F ) ∧ ( G ⊆ F ∧ x ∈ dom G ) ) → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ G ) ) ;;
	step 18 : wff = exp43 (step 17) |- ( Fun F → ( 〈 x , y 〉 ∈ F → ( G ⊆ F → ( x ∈ dom G → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ G ) ) ) ) ) ;;
	step 19 : wff = com23 (step 18) |- ( Fun F → ( G ⊆ F → ( 〈 x , y 〉 ∈ F → ( x ∈ dom G → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ G ) ) ) ) ) ;;
	step 20 : wff = imp (step 19) |- ( ( Fun F ∧ G ⊆ F ) → ( 〈 x , y 〉 ∈ F → ( x ∈ dom G → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ G ) ) ) ) ;;
	step 21 : wff = com34 (step 20) |- ( ( Fun F ∧ G ⊆ F ) → ( 〈 x , y 〉 ∈ F → ( 〈 x , y 〉 ∈ F → ( x ∈ dom G → 〈 x , y 〉 ∈ G ) ) ) ) ;;
	step 22 : wff = pm2.43d (step 21) |- ( ( Fun F ∧ G ⊆ F ) → ( 〈 x , y 〉 ∈ F → ( x ∈ dom G → 〈 x , y 〉 ∈ G ) ) ) ;;
	step 23 : wff = imp3a (step 22) |- ( ( Fun F ∧ G ⊆ F ) → ( ( 〈 x , y 〉 ∈ F ∧ x ∈ dom G ) → 〈 x , y 〉 ∈ G ) ) ;;
	step 24 : wff = impbid (step 7, step 23) |- ( ( Fun F ∧ G ⊆ F ) → ( 〈 x , y 〉 ∈ G ↔ ( 〈 x , y 〉 ∈ F ∧ x ∈ dom G ) ) ) ;;
	step 25 : wff = vex () |- y ∈ _V ;;
	step 26 : wff = opelres (step 25) |- ( 〈 x , y 〉 ∈ ( F ↾ dom G ) ↔ ( 〈 x , y 〉 ∈ F ∧ x ∈ dom G ) ) ;;
	step 27 : wff = syl6rbbr (step 24, step 26) |- ( ( Fun F ∧ G ⊆ F ) → ( 〈 x , y 〉 ∈ ( F ↾ dom G ) ↔ 〈 x , y 〉 ∈ G ) ) ;;
	step 28 : wff = alrimivv (step 27) |- ( ( Fun F ∧ G ⊆ F ) → ∀ x ∀ y ( 〈 x , y 〉 ∈ ( F ↾ dom G ) ↔ 〈 x , y 〉 ∈ G ) ) ;;
	step 29 : wff = relres () |- Rel ( F ↾ dom G ) ;;
	step 30 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 31 : wff = relss () |- ( G ⊆ F → ( Rel F → Rel G ) ) ;;
	step 32 : wff = mpan9 (step 30, step 31) |- ( ( Fun F ∧ G ⊆ F ) → Rel G ) ;;
	step 33 : wff = eqrel () |- ( ( Rel ( F ↾ dom G ) ∧ Rel G ) → ( ( F ↾ dom G ) = G ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( F ↾ dom G ) ↔ 〈 x , y 〉 ∈ G ) ) ) ;;
	step 34 : wff = sylancr (step 29, step 32, step 33) |- ( ( Fun F ∧ G ⊆ F ) → ( ( F ↾ dom G ) = G ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( F ↾ dom G ) ↔ 〈 x , y 〉 ∈ G ) ) ) ;;
	step 35 : wff = mpbird (step 28, step 34) |- ( ( Fun F ∧ G ⊆ F ) → ( F ↾ dom G ) = G ) ;;
	qed prop 1 = step 35 ;;
}

/*Equality of restrictions of a function and a subclass.  (Contributed by
     NM, 16-Aug-1994.) */

theorem fun2ssres (A : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ G ⊆ F ∧ A ⊆ dom G ) → ( F ↾ A ) = ( G ↾ A ) ) ;;
}

proof of fun2ssres {
	step 1 : wff = resabs1 () |- ( A ⊆ dom G → ( ( F ↾ dom G ) ↾ A ) = ( F ↾ A ) ) ;;
	step 2 : wff = eqcomd (step 1) |- ( A ⊆ dom G → ( F ↾ A ) = ( ( F ↾ dom G ) ↾ A ) ) ;;
	step 3 : wff = funssres () |- ( ( Fun F ∧ G ⊆ F ) → ( F ↾ dom G ) = G ) ;;
	step 4 : wff = reseq1d (step 3) |- ( ( Fun F ∧ G ⊆ F ) → ( ( F ↾ dom G ) ↾ A ) = ( G ↾ A ) ) ;;
	step 5 : wff = sylan9eqr (step 2, step 4) |- ( ( ( Fun F ∧ G ⊆ F ) ∧ A ⊆ dom G ) → ( F ↾ A ) = ( G ↾ A ) ) ;;
	step 6 : wff = 3impa (step 5) |- ( ( Fun F ∧ G ⊆ F ∧ A ⊆ dom G ) → ( F ↾ A ) = ( G ↾ A ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The union of functions with disjoint domains is a function.  Theorem 4.6
       of [Monk1] p. 43.  (Contributed by NM, 12-Aug-1994.) */

theorem funun (F : class, G : class) disjointed(x y z F, x y z G) {
	prop 1 : wff = |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → Fun ( F ∪ G ) ) ;;
}

proof of funun {
	var x : set, y : set, z : set;;
	step 1 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 2 : wff = funrel () |- ( Fun G → Rel G ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( Fun F ∧ Fun G ) → ( Rel F ∧ Rel G ) ) ;;
	step 4 : wff = relun () |- ( Rel ( F ∪ G ) ↔ ( Rel F ∧ Rel G ) ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ( Fun F ∧ Fun G ) → Rel ( F ∪ G ) ) ;;
	step 6 : wff = adantr (step 5) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → Rel ( F ∪ G ) ) ;;
	step 7 : wff = elun () |- ( 〈 x , y 〉 ∈ ( F ∪ G ) ↔ ( 〈 x , y 〉 ∈ F ∨ 〈 x , y 〉 ∈ G ) ) ;;
	step 8 : wff = elun () |- ( 〈 x , z 〉 ∈ ( F ∪ G ) ↔ ( 〈 x , z 〉 ∈ F ∨ 〈 x , z 〉 ∈ G ) ) ;;
	step 9 : wff = anbi12i (step 7, step 8) |- ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) ↔ ( ( 〈 x , y 〉 ∈ F ∨ 〈 x , y 〉 ∈ G ) ∧ ( 〈 x , z 〉 ∈ F ∨ 〈 x , z 〉 ∈ G ) ) ) ;;
	step 10 : wff = anddi () |- ( ( ( 〈 x , y 〉 ∈ F ∨ 〈 x , y 〉 ∈ G ) ∧ ( 〈 x , z 〉 ∈ F ∨ 〈 x , z 〉 ∈ G ) ) ↔ ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ∨ ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ) ;;
	step 11 : wff = bitri (step 9, step 10) |- ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) ↔ ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ∨ ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ) ;;
	step 12 : wff = disj1 () |- ( ( dom F ∩ dom G ) = ∅ ↔ ∀ x ( x ∈ dom F → ¬ x ∈ dom G ) ) ;;
	step 13 : wff = biimpi (step 12) |- ( ( dom F ∩ dom G ) = ∅ → ∀ x ( x ∈ dom F → ¬ x ∈ dom G ) ) ;;
	step 14 : wff = 19.21bi (step 13) |- ( ( dom F ∩ dom G ) = ∅ → ( x ∈ dom F → ¬ x ∈ dom G ) ) ;;
	step 15 : wff = imnan () |- ( ( x ∈ dom F → ¬ x ∈ dom G ) ↔ ¬ ( x ∈ dom F ∧ x ∈ dom G ) ) ;;
	step 16 : wff = sylib (step 14, step 15) |- ( ( dom F ∩ dom G ) = ∅ → ¬ ( x ∈ dom F ∧ x ∈ dom G ) ) ;;
	step 17 : wff = vex () |- x ∈ _V ;;
	step 18 : wff = vex () |- y ∈ _V ;;
	step 19 : wff = opeldm (step 17, step 18) |- ( 〈 x , y 〉 ∈ F → x ∈ dom F ) ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- z ∈ _V ;;
	step 22 : wff = opeldm (step 20, step 21) |- ( 〈 x , z 〉 ∈ G → x ∈ dom G ) ;;
	step 23 : wff = anim12i (step 19, step 22) |- ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( x ∈ dom F ∧ x ∈ dom G ) ) ;;
	step 24 : wff = nsyl (step 16, step 23) |- ( ( dom F ∩ dom G ) = ∅ → ¬ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ;;
	step 25 : wff = orel2 () |- ( ¬ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) → ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ) ) ;;
	step 26 : wff = syl (step 24, step 25) |- ( ( dom F ∩ dom G ) = ∅ → ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) → ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ) ) ;;
	step 27 : wff = disj1 () |- ( ( dom F ∩ dom G ) = ∅ ↔ ∀ x ( x ∈ dom F → ¬ x ∈ dom G ) ) ;;
	step 28 : wff = biimpi (step 27) |- ( ( dom F ∩ dom G ) = ∅ → ∀ x ( x ∈ dom F → ¬ x ∈ dom G ) ) ;;
	step 29 : wff = 19.21bi (step 28) |- ( ( dom F ∩ dom G ) = ∅ → ( x ∈ dom F → ¬ x ∈ dom G ) ) ;;
	step 30 : wff = con2d (step 29) |- ( ( dom F ∩ dom G ) = ∅ → ( x ∈ dom G → ¬ x ∈ dom F ) ) ;;
	step 31 : wff = imnan () |- ( ( x ∈ dom G → ¬ x ∈ dom F ) ↔ ¬ ( x ∈ dom G ∧ x ∈ dom F ) ) ;;
	step 32 : wff = sylib (step 30, step 31) |- ( ( dom F ∩ dom G ) = ∅ → ¬ ( x ∈ dom G ∧ x ∈ dom F ) ) ;;
	step 33 : wff = vex () |- x ∈ _V ;;
	step 34 : wff = vex () |- y ∈ _V ;;
	step 35 : wff = opeldm (step 33, step 34) |- ( 〈 x , y 〉 ∈ G → x ∈ dom G ) ;;
	step 36 : wff = vex () |- x ∈ _V ;;
	step 37 : wff = vex () |- z ∈ _V ;;
	step 38 : wff = opeldm (step 36, step 37) |- ( 〈 x , z 〉 ∈ F → x ∈ dom F ) ;;
	step 39 : wff = anim12i (step 35, step 38) |- ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) → ( x ∈ dom G ∧ x ∈ dom F ) ) ;;
	step 40 : wff = nsyl (step 32, step 39) |- ( ( dom F ∩ dom G ) = ∅ → ¬ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ) ;;
	step 41 : wff = orel1 () |- ( ¬ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) → ( ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) → ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ;;
	step 42 : wff = syl (step 40, step 41) |- ( ( dom F ∩ dom G ) = ∅ → ( ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) → ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ;;
	step 43 : wff = orim12d (step 26, step 42) |- ( ( dom F ∩ dom G ) = ∅ → ( ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ∨ ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ) ;;
	step 44 : wff = adantl (step 43) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ∨ ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ) ;;
	step 45 : wff = syl5bi (step 11, step 44) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) ) ) ;;
	step 46 : wff = dffun4 () |- ( Fun F ↔ ( Rel F ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) → y = z ) ) ) ;;
	step 47 : wff = simprbi (step 46) |- ( Fun F → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) → y = z ) ) ;;
	step 48 : wff = 19.21bi (step 47) |- ( Fun F → ∀ y ∀ z ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) → y = z ) ) ;;
	step 49 : wff = 19.21bbi (step 48) |- ( Fun F → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) → y = z ) ) ;;
	step 50 : wff = dffun4 () |- ( Fun G ↔ ( Rel G ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) → y = z ) ) ) ;;
	step 51 : wff = simprbi (step 50) |- ( Fun G → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) → y = z ) ) ;;
	step 52 : wff = 19.21bi (step 51) |- ( Fun G → ∀ y ∀ z ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) → y = z ) ) ;;
	step 53 : wff = 19.21bbi (step 52) |- ( Fun G → ( ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) → y = z ) ) ;;
	step 54 : wff = jaao (step 49, step 53) |- ( ( Fun F ∧ Fun G ) → ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) → y = z ) ) ;;
	step 55 : wff = adantr (step 54) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ F ) ∨ ( 〈 x , y 〉 ∈ G ∧ 〈 x , z 〉 ∈ G ) ) → y = z ) ) ;;
	step 56 : wff = syld (step 45, step 55) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) → y = z ) ) ;;
	step 57 : wff = alrimiv (step 56) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ∀ z ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) → y = z ) ) ;;
	step 58 : wff = alrimivv (step 57) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) → y = z ) ) ;;
	step 59 : wff = dffun4 () |- ( Fun ( F ∪ G ) ↔ ( Rel ( F ∪ G ) ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ ( F ∪ G ) ∧ 〈 x , z 〉 ∈ ( F ∪ G ) ) → y = z ) ) ) ;;
	step 60 : wff = sylanbrc (step 6, step 58, step 59) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → Fun ( F ∪ G ) ) ;;
	qed prop 1 = step 60 ;;
}

/*The converse singleton of an ordered pair is a function.  This is
       equivalent to ~ funsn via ~ cnvsn , but stating it this way allows us to
       skip the sethood assumptions on ` A ` and ` B ` .  (Contributed by NM,
       30-Apr-2015.) */

theorem funcnvsn (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- Fun ⁻¹ { 〈 A , B 〉 } ;;
}

proof of funcnvsn {
	var x : set, y : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ { 〈 A , B 〉 } ;;
	step 2 : wff = moeq () |- ∃* y y = A ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = brcnv (step 3, step 4) |- ( x ⁻¹ { 〈 A , B 〉 } y ↔ y { 〈 A , B 〉 } x ) ;;
	step 6 : wff = df-br () |- ( y { 〈 A , B 〉 } x ↔ 〈 y , x 〉 ∈ { 〈 A , B 〉 } ) ;;
	step 7 : wff = bitri (step 5, step 6) |- ( x ⁻¹ { 〈 A , B 〉 } y ↔ 〈 y , x 〉 ∈ { 〈 A , B 〉 } ) ;;
	step 8 : wff = elsni () |- ( 〈 y , x 〉 ∈ { 〈 A , B 〉 } → 〈 y , x 〉 = 〈 A , B 〉 ) ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = opth1 (step 9, step 10) |- ( 〈 y , x 〉 = 〈 A , B 〉 → y = A ) ;;
	step 12 : wff = syl (step 8, step 11) |- ( 〈 y , x 〉 ∈ { 〈 A , B 〉 } → y = A ) ;;
	step 13 : wff = sylbi (step 7, step 12) |- ( x ⁻¹ { 〈 A , B 〉 } y → y = A ) ;;
	step 14 : wff = moimi (step 13) |- ( ∃* y y = A → ∃* y x ⁻¹ { 〈 A , B 〉 } y ) ;;
	step 15 : wff = ax-mp (step 2, step 14) |- ∃* y x ⁻¹ { 〈 A , B 〉 } y ;;
	step 16 : wff = ax-gen (step 15) |- ∀ x ∃* y x ⁻¹ { 〈 A , B 〉 } y ;;
	step 17 : wff = dffun6 () |- ( Fun ⁻¹ { 〈 A , B 〉 } ↔ ( Rel ⁻¹ { 〈 A , B 〉 } ∧ ∀ x ∃* y x ⁻¹ { 〈 A , B 〉 } y ) ) ;;
	step 18 : wff = mpbir2an (step 1, step 16, step 17) |- Fun ⁻¹ { 〈 A , B 〉 } ;;
	qed prop 1 = step 18 ;;
}

/*A singleton of an ordered pair is a function.  Theorem 10.5 of [Quine]
       p. 65.  (Contributed by NM, 28-Jun-2011.) */

theorem funsng (A : class, B : class, V : class, W : class) disjointed(A, B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → Fun { 〈 A , B 〉 } ) ;;
}

proof of funsng {
	step 1 : wff = funcnvsn () |- Fun ⁻¹ { 〈 B , A 〉 } ;;
	step 2 : wff = cnvsng () |- ( ( B ∈ W ∧ A ∈ V ) → ⁻¹ { 〈 B , A 〉 } = { 〈 A , B 〉 } ) ;;
	step 3 : wff = ancoms (step 2) |- ( ( A ∈ V ∧ B ∈ W ) → ⁻¹ { 〈 B , A 〉 } = { 〈 A , B 〉 } ) ;;
	step 4 : wff = funeqd (step 3) |- ( ( A ∈ V ∧ B ∈ W ) → ( Fun ⁻¹ { 〈 B , A 〉 } ↔ Fun { 〈 A , B 〉 } ) ) ;;
	step 5 : wff = mpbii (step 1, step 4) |- ( ( A ∈ V ∧ B ∈ W ) → Fun { 〈 A , B 〉 } ) ;;
	qed prop 1 = step 5 ;;
}

/*Functionality and domain of the singleton of an ordered pair.
       (Contributed by Mario Carneiro, 30-Apr-2015.) */

theorem fnsng (A : class, B : class, V : class, W : class) disjointed(A, B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 } Fn { A } ) ;;
}

proof of fnsng {
	step 1 : wff = funsng () |- ( ( A ∈ V ∧ B ∈ W ) → Fun { 〈 A , B 〉 } ) ;;
	step 2 : wff = dmsnopg () |- ( B ∈ W → dom { 〈 A , B 〉 } = { A } ) ;;
	step 3 : wff = adantl (step 2) |- ( ( A ∈ V ∧ B ∈ W ) → dom { 〈 A , B 〉 } = { A } ) ;;
	step 4 : wff = df-fn () |- ( { 〈 A , B 〉 } Fn { A } ↔ ( Fun { 〈 A , B 〉 } ∧ dom { 〈 A , B 〉 } = { A } ) ) ;;
	step 5 : wff = sylanbrc (step 1, step 3, step 4) |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 } Fn { A } ) ;;
	qed prop 1 = step 5 ;;
}

/*A singleton of an ordered pair is a function.  Theorem 10.5 of [Quine]
       p. 65.  (Contributed by NM, 12-Aug-1994.) */

theorem funsn (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- Fun { 〈 A , B 〉 } ;;
}

proof of funsn {
	step 1 : wff = funsng () |- ( ( A ∈ _V ∧ B ∈ _V ) → Fun { 〈 A , B 〉 } ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- Fun { 〈 A , B 〉 } ;;
	qed prop 1 = step 2 ;;
}

/*A set of two pairs is a function if their first members are different.
     (Contributed by FL, 26-Jun-2011.) */

theorem funprg (A : class, B : class, C : class, D : class, V : class, W : class, X : class, Y : class)  {
	prop 1 : wff = |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
}

proof of funprg {
	step 1 : wff = simp1l () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → A ∈ V ) ;;
	step 2 : wff = simp2l () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → C ∈ X ) ;;
	step 3 : wff = funsng () |- ( ( A ∈ V ∧ C ∈ X ) → Fun { 〈 A , C 〉 } ) ;;
	step 4 : wff = syl2anc (step 1, step 2, step 3) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → Fun { 〈 A , C 〉 } ) ;;
	step 5 : wff = simp1r () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → B ∈ W ) ;;
	step 6 : wff = simp2r () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → D ∈ Y ) ;;
	step 7 : wff = funsng () |- ( ( B ∈ W ∧ D ∈ Y ) → Fun { 〈 B , D 〉 } ) ;;
	step 8 : wff = syl2anc (step 5, step 6, step 7) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → Fun { 〈 B , D 〉 } ) ;;
	step 9 : wff = simp2l () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → C ∈ X ) ;;
	step 10 : wff = dmsnopg () |- ( C ∈ X → dom { 〈 A , C 〉 } = { A } ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → dom { 〈 A , C 〉 } = { A } ) ;;
	step 12 : wff = simp2r () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → D ∈ Y ) ;;
	step 13 : wff = dmsnopg () |- ( D ∈ Y → dom { 〈 B , D 〉 } = { B } ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → dom { 〈 B , D 〉 } = { B } ) ;;
	step 15 : wff = ineq12d (step 11, step 14) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → ( dom { 〈 A , C 〉 } ∩ dom { 〈 B , D 〉 } ) = ( { A } ∩ { B } ) ) ;;
	step 16 : wff = disjsn2 () |- ( A ≠ B → ( { A } ∩ { B } ) = ∅ ) ;;
	step 17 : wff = 3ad2ant3 (step 16) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → ( { A } ∩ { B } ) = ∅ ) ;;
	step 18 : wff = eqtrd (step 15, step 17) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → ( dom { 〈 A , C 〉 } ∩ dom { 〈 B , D 〉 } ) = ∅ ) ;;
	step 19 : wff = funun () |- ( ( ( Fun { 〈 A , C 〉 } ∧ Fun { 〈 B , D 〉 } ) ∧ ( dom { 〈 A , C 〉 } ∩ dom { 〈 B , D 〉 } ) = ∅ ) → Fun ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ) ;;
	step 20 : wff = syl21anc (step 4, step 8, step 18, step 19) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → Fun ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ) ;;
	step 21 : wff = df-pr () |- { 〈 A , C 〉 , 〈 B , D 〉 } = ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ;;
	step 22 : wff = funeqi (step 21) |- ( Fun { 〈 A , C 〉 , 〈 B , D 〉 } ↔ Fun ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ) ;;
	step 23 : wff = sylibr (step 20, step 22) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
	qed prop 1 = step 23 ;;
}

/*A function with a domain of two elements.  (Contributed by Jeff Madsen,
       20-Jun-2010.) */

theorem funpr (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ≠ B → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
}

proof of funpr {
	step 1 : wff = pm3.2i (hyp 1, hyp 2) |- ( A ∈ _V ∧ B ∈ _V ) ;;
	step 2 : wff = pm3.2i (hyp 3, hyp 4) |- ( C ∈ _V ∧ D ∈ _V ) ;;
	step 3 : wff = funprg () |- ( ( ( A ∈ _V ∧ B ∈ _V ) ∧ ( C ∈ _V ∧ D ∈ _V ) ∧ A ≠ B ) → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
	step 4 : wff = mp3an12 (step 1, step 2, step 3) |- ( A ≠ B → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
	qed prop 1 = step 4 ;;
}

/*A function with a domain of three elements.  (Contributed by NM,
       14-Sep-2011.) */

theorem funtp (A : class, B : class, C : class, D : class, E : class, F : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	hyp 5 : wff = |- E ∈ _V ;;
	hyp 6 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → Fun { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ) ;;
}

proof of funtp {
	step 1 : wff = funpr (hyp 1, hyp 2, hyp 4, hyp 5) |- ( A ≠ B → Fun { 〈 A , D 〉 , 〈 B , E 〉 } ) ;;
	step 2 : wff = funsn (hyp 3, hyp 6) |- Fun { 〈 C , F 〉 } ;;
	step 3 : wff = jctir (step 1, step 2) |- ( A ≠ B → ( Fun { 〈 A , D 〉 , 〈 B , E 〉 } ∧ Fun { 〈 C , F 〉 } ) ) ;;
	step 4 : wff = dmprop (hyp 4, hyp 5) |- dom { 〈 A , D 〉 , 〈 B , E 〉 } = { A , B } ;;
	step 5 : wff = df-pr () |- { A , B } = ( { A } ∪ { B } ) ;;
	step 6 : wff = eqtri (step 4, step 5) |- dom { 〈 A , D 〉 , 〈 B , E 〉 } = ( { A } ∪ { B } ) ;;
	step 7 : wff = dmsnop (hyp 6) |- dom { 〈 C , F 〉 } = { C } ;;
	step 8 : wff = ineq12i (step 6, step 7) |- ( dom { 〈 A , D 〉 , 〈 B , E 〉 } ∩ dom { 〈 C , F 〉 } ) = ( ( { A } ∪ { B } ) ∩ { C } ) ;;
	step 9 : wff = disjsn2 () |- ( A ≠ C → ( { A } ∩ { C } ) = ∅ ) ;;
	step 10 : wff = disjsn2 () |- ( B ≠ C → ( { B } ∩ { C } ) = ∅ ) ;;
	step 11 : wff = anim12i (step 9, step 10) |- ( ( A ≠ C ∧ B ≠ C ) → ( ( { A } ∩ { C } ) = ∅ ∧ ( { B } ∩ { C } ) = ∅ ) ) ;;
	step 12 : wff = undisj1 () |- ( ( ( { A } ∩ { C } ) = ∅ ∧ ( { B } ∩ { C } ) = ∅ ) ↔ ( ( { A } ∪ { B } ) ∩ { C } ) = ∅ ) ;;
	step 13 : wff = sylib (step 11, step 12) |- ( ( A ≠ C ∧ B ≠ C ) → ( ( { A } ∪ { B } ) ∩ { C } ) = ∅ ) ;;
	step 14 : wff = syl5eq (step 8, step 13) |- ( ( A ≠ C ∧ B ≠ C ) → ( dom { 〈 A , D 〉 , 〈 B , E 〉 } ∩ dom { 〈 C , F 〉 } ) = ∅ ) ;;
	step 15 : wff = funun () |- ( ( ( Fun { 〈 A , D 〉 , 〈 B , E 〉 } ∧ Fun { 〈 C , F 〉 } ) ∧ ( dom { 〈 A , D 〉 , 〈 B , E 〉 } ∩ dom { 〈 C , F 〉 } ) = ∅ ) → Fun ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ) ;;
	step 16 : wff = syl2an (step 3, step 14, step 15) |- ( ( A ≠ B ∧ ( A ≠ C ∧ B ≠ C ) ) → Fun ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ) ;;
	step 17 : wff = 3impb (step 16) |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → Fun ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ) ;;
	step 18 : wff = df-tp () |- { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ;;
	step 19 : wff = funeqi (step 18) |- ( Fun { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ↔ Fun ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ) ;;
	step 20 : wff = sylibr (step 17, step 19) |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → Fun { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ) ;;
	qed prop 1 = step 20 ;;
}

/*Functionality and domain of the singleton of an ordered pair.
       (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) */

theorem fnsn (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { 〈 A , B 〉 } Fn { A } ;;
}

proof of fnsn {
	step 1 : wff = fnsng () |- ( ( A ∈ _V ∧ B ∈ _V ) → { 〈 A , B 〉 } Fn { A } ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- { 〈 A , B 〉 } Fn { A } ;;
	qed prop 1 = step 2 ;;
}

/*Domain of a function with a domain of two different values.
       (Contributed by FL, 26-Jun-2011.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem fnprg (A : class, B : class, C : class, D : class, V : class, W : class, X : class, Y : class)  {
	prop 1 : wff = |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ) ;;
}

proof of fnprg {
	step 1 : wff = funprg () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
	step 2 : wff = dmpropg () |- ( ( C ∈ X ∧ D ∈ Y ) → dom { 〈 A , C 〉 , 〈 B , D 〉 } = { A , B } ) ;;
	step 3 : wff = 3ad2ant2 (step 2) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → dom { 〈 A , C 〉 , 〈 B , D 〉 } = { A , B } ) ;;
	step 4 : wff = df-fn () |- ( { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ↔ ( Fun { 〈 A , C 〉 , 〈 B , D 〉 } ∧ dom { 〈 A , C 〉 , 〈 B , D 〉 } = { A , B } ) ) ;;
	step 5 : wff = sylanbrc (step 1, step 3, step 4) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( C ∈ X ∧ D ∈ Y ) ∧ A ≠ B ) → { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ) ;;
	qed prop 1 = step 5 ;;
}

/*A function with a domain of three elements.  (Contributed by NM,
       14-Sep-2011.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem fntp (A : class, B : class, C : class, D : class, E : class, F : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	hyp 5 : wff = |- E ∈ _V ;;
	hyp 6 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } Fn { A , B , C } ) ;;
}

proof of fntp {
	step 1 : wff = funtp (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, hyp 6) |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → Fun { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ) ;;
	step 2 : wff = dmtpop (hyp 4, hyp 5, hyp 6) |- dom { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = { A , B , C } ;;
	step 3 : wff = a1i (step 2) |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → dom { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = { A , B , C } ) ;;
	step 4 : wff = df-fn () |- ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } Fn { A , B , C } ↔ ( Fun { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ∧ dom { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = { A , B , C } ) ) ;;
	step 5 : wff = sylanbrc (step 1, step 3, step 4) |- ( ( A ≠ B ∧ A ≠ C ∧ B ≠ C ) → { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } Fn { A , B , C } ) ;;
	qed prop 1 = step 5 ;;
}

/*The empty set is a function.  Theorem 10.3 of [Quine] p. 65.  (Contributed
     by NM, 7-Apr-1998.) */

theorem fun0 ()  {
	prop 1 : wff = |- Fun ∅ ;;
}

proof of fun0 {
	step 1 : wff = 0ss () |- ∅ ⊆ { 〈 ∅ , ∅ 〉 } ;;
	step 2 : wff = 0ex () |- ∅ ∈ _V ;;
	step 3 : wff = 0ex () |- ∅ ∈ _V ;;
	step 4 : wff = funsn (step 2, step 3) |- Fun { 〈 ∅ , ∅ 〉 } ;;
	step 5 : wff = funss () |- ( ∅ ⊆ { 〈 ∅ , ∅ 〉 } → ( Fun { 〈 ∅ , ∅ 〉 } → Fun ∅ ) ) ;;
	step 6 : wff = mp2 (step 1, step 4, step 5) |- Fun ∅ ;;
	qed prop 1 = step 6 ;;
}

/*The double converse of a function is a function.  (Contributed by NM,
     21-Sep-2004.) */

theorem funcnvcnv (A : class)  {
	prop 1 : wff = |- ( Fun A → Fun ⁻¹ ⁻¹ A ) ;;
}

proof of funcnvcnv {
	step 1 : wff = cnvcnvss () |- ⁻¹ ⁻¹ A ⊆ A ;;
	step 2 : wff = funss () |- ( ⁻¹ ⁻¹ A ⊆ A → ( Fun A → Fun ⁻¹ ⁻¹ A ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( Fun A → Fun ⁻¹ ⁻¹ A ) ;;
	qed prop 1 = step 3 ;;
}

/*A simpler equivalence for single-rooted (see ~ funcnv ).  (Contributed
       by NM, 9-Aug-2004.) */

theorem funcnv2 (x : set, y : set, A : class) disjointed(x y A, x y, x y) {
	prop 1 : wff = |- ( Fun ⁻¹ A ↔ ∀ y ∃* x x A y ) ;;
}

proof of funcnv2 {
	step 1 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 2 : wff = dffun6 () |- ( Fun ⁻¹ A ↔ ( Rel ⁻¹ A ∧ ∀ y ∃* x y ⁻¹ A x ) ) ;;
	step 3 : wff = mpbiran (step 1, step 2) |- ( Fun ⁻¹ A ↔ ∀ y ∃* x y ⁻¹ A x ) ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = brcnv (step 4, step 5) |- ( y ⁻¹ A x ↔ x A y ) ;;
	step 7 : wff = mobii (step 6) |- ( ∃* x y ⁻¹ A x ↔ ∃* x x A y ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ y ∃* x y ⁻¹ A x ↔ ∀ y ∃* x x A y ) ;;
	step 9 : wff = bitri (step 3, step 8) |- ( Fun ⁻¹ A ↔ ∀ y ∃* x x A y ) ;;
	qed prop 1 = step 9 ;;
}

/*The converse of a class is a function iff the class is single-rooted,
       which means that for any ` y ` in the range of ` A ` there is at most
       one ` x ` such that ` x A y ` .  Definition of single-rooted in
       [Enderton] p. 43.  See ~ funcnv2 for a simpler version.  (Contributed by
       NM, 13-Aug-2004.) */

theorem funcnv (x : set, y : set, A : class) disjointed(x y A, x y, x y) {
	prop 1 : wff = |- ( Fun ⁻¹ A ↔ ∀ y ∈ ran A ∃* x x A y ) ;;
}

proof of funcnv {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = brelrn (step 1, step 2) |- ( x A y → y ∈ ran A ) ;;
	step 4 : wff = pm4.71ri (step 3) |- ( x A y ↔ ( y ∈ ran A ∧ x A y ) ) ;;
	step 5 : wff = mobii (step 4) |- ( ∃* x x A y ↔ ∃* x ( y ∈ ran A ∧ x A y ) ) ;;
	step 6 : wff = moanimv () |- ( ∃* x ( y ∈ ran A ∧ x A y ) ↔ ( y ∈ ran A → ∃* x x A y ) ) ;;
	step 7 : wff = bitri (step 5, step 6) |- ( ∃* x x A y ↔ ( y ∈ ran A → ∃* x x A y ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ y ∃* x x A y ↔ ∀ y ( y ∈ ran A → ∃* x x A y ) ) ;;
	step 9 : wff = funcnv2 () |- ( Fun ⁻¹ A ↔ ∀ y ∃* x x A y ) ;;
	step 10 : wff = df-ral () |- ( ∀ y ∈ ran A ∃* x x A y ↔ ∀ y ( y ∈ ran A → ∃* x x A y ) ) ;;
	step 11 : wff = 3bitr4i (step 8, step 9, step 10) |- ( Fun ⁻¹ A ↔ ∀ y ∈ ran A ∃* x x A y ) ;;
	qed prop 1 = step 11 ;;
}

/*A condition showing a class is single-rooted.  (See ~ funcnv ).
       (Contributed by NM, 26-May-2006.) */

theorem funcnv3 (x : set, y : set, A : class) disjointed(x y A, x y, x y) {
	prop 1 : wff = |- ( Fun ⁻¹ A ↔ ∀ y ∈ ran A ∃! x ∈ dom A x A y ) ;;
}

proof of funcnv3 {
	step 1 : wff = dfrn2 () |- ran A = { y | ∃ x x A y } ;;
	step 2 : wff = abeq2i (step 1) |- ( y ∈ ran A ↔ ∃ x x A y ) ;;
	step 3 : wff = biimpi (step 2) |- ( y ∈ ran A → ∃ x x A y ) ;;
	step 4 : wff = biantrurd (step 3) |- ( y ∈ ran A → ( ∃* x x A y ↔ ( ∃ x x A y ∧ ∃* x x A y ) ) ) ;;
	step 5 : wff = ralbiia (step 4) |- ( ∀ y ∈ ran A ∃* x x A y ↔ ∀ y ∈ ran A ( ∃ x x A y ∧ ∃* x x A y ) ) ;;
	step 6 : wff = funcnv () |- ( Fun ⁻¹ A ↔ ∀ y ∈ ran A ∃* x x A y ) ;;
	step 7 : wff = df-reu () |- ( ∃! x ∈ dom A x A y ↔ ∃! x ( x ∈ dom A ∧ x A y ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = breldm (step 8, step 9) |- ( x A y → x ∈ dom A ) ;;
	step 11 : wff = pm4.71ri (step 10) |- ( x A y ↔ ( x ∈ dom A ∧ x A y ) ) ;;
	step 12 : wff = eubii (step 11) |- ( ∃! x x A y ↔ ∃! x ( x ∈ dom A ∧ x A y ) ) ;;
	step 13 : wff = eu5 () |- ( ∃! x x A y ↔ ( ∃ x x A y ∧ ∃* x x A y ) ) ;;
	step 14 : wff = 3bitr2i (step 7, step 12, step 13) |- ( ∃! x ∈ dom A x A y ↔ ( ∃ x x A y ∧ ∃* x x A y ) ) ;;
	step 15 : wff = ralbii (step 14) |- ( ∀ y ∈ ran A ∃! x ∈ dom A x A y ↔ ∀ y ∈ ran A ( ∃ x x A y ∧ ∃* x x A y ) ) ;;
	step 16 : wff = 3bitr4i (step 5, step 6, step 15) |- ( Fun ⁻¹ A ↔ ∀ y ∈ ran A ∃! x ∈ dom A x A y ) ;;
	qed prop 1 = step 16 ;;
}

/*The double converse of a class is a function iff the class is
       single-valued.  Each side is equivalent to Definition 6.4(2) of
       [TakeutiZaring] p. 23, who use the notation "Un(A)" for single-valued.
       Note that ` A ` is not necessarily a function.  (Contributed by NM,
       13-Aug-2004.) */

theorem fun2cnv (x : set, y : set, A : class) disjointed(x y A, x y, x y) {
	prop 1 : wff = |- ( Fun ⁻¹ ⁻¹ A ↔ ∀ x ∃* y x A y ) ;;
}

proof of fun2cnv {
	step 1 : wff = funcnv2 () |- ( Fun ⁻¹ ⁻¹ A ↔ ∀ x ∃* y y ⁻¹ A x ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = brcnv (step 2, step 3) |- ( y ⁻¹ A x ↔ x A y ) ;;
	step 5 : wff = mobii (step 4) |- ( ∃* y y ⁻¹ A x ↔ ∃* y x A y ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ x ∃* y y ⁻¹ A x ↔ ∀ x ∃* y x A y ) ;;
	step 7 : wff = bitri (step 1, step 6) |- ( Fun ⁻¹ ⁻¹ A ↔ ∀ x ∃* y x A y ) ;;
	qed prop 1 = step 7 ;;
}

/*A single-valued relation is a function.  (See ~ fun2cnv for
       "single-valued.") Definition 6.4(4) of [TakeutiZaring] p. 24.
       (Contributed by NM, 17-Jan-2006.) */

theorem svrelfun (A : class) disjointed(x y A, x y, x y) {
	prop 1 : wff = |- ( Fun A ↔ ( Rel A ∧ Fun ⁻¹ ⁻¹ A ) ) ;;
}

proof of svrelfun {
	var x : set, y : set;;
	step 1 : wff = dffun6 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃* y x A y ) ) ;;
	step 2 : wff = fun2cnv () |- ( Fun ⁻¹ ⁻¹ A ↔ ∀ x ∃* y x A y ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( Rel A ∧ Fun ⁻¹ ⁻¹ A ) ↔ ( Rel A ∧ ∀ x ∃* y x A y ) ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( Fun A ↔ ( Rel A ∧ Fun ⁻¹ ⁻¹ A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Single-rootedness (see ~ funcnv ) of a class cut down by a cross
       product.  (Contributed by NM, 5-Mar-2007.) */

theorem fncnv (x : set, y : set, A : class, B : class, R : class) disjointed(x y A, x y B, x y R) {
	prop 1 : wff = |- ( ⁻¹ ( R ∩ ( A × B ) ) Fn B ↔ ∀ y ∈ B ∃! x ∈ A x R y ) ;;
}

proof of fncnv {
	step 1 : wff = df-fn () |- ( ⁻¹ ( R ∩ ( A × B ) ) Fn B ↔ ( Fun ⁻¹ ( R ∩ ( A × B ) ) ∧ dom ⁻¹ ( R ∩ ( A × B ) ) = B ) ) ;;
	step 2 : wff = df-rn () |- ran ( R ∩ ( A × B ) ) = dom ⁻¹ ( R ∩ ( A × B ) ) ;;
	step 3 : wff = eqeq1i (step 2) |- ( ran ( R ∩ ( A × B ) ) = B ↔ dom ⁻¹ ( R ∩ ( A × B ) ) = B ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( Fun ⁻¹ ( R ∩ ( A × B ) ) ∧ ran ( R ∩ ( A × B ) ) = B ) ↔ ( Fun ⁻¹ ( R ∩ ( A × B ) ) ∧ dom ⁻¹ ( R ∩ ( A × B ) ) = B ) ) ;;
	step 5 : wff = rninxp () |- ( ran ( R ∩ ( A × B ) ) = B ↔ ∀ y ∈ B ∃ x ∈ A x R y ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( ran ( R ∩ ( A × B ) ) = B ∧ ∀ y ∈ B ∃* x ∈ A x R y ) ↔ ( ∀ y ∈ B ∃ x ∈ A x R y ∧ ∀ y ∈ B ∃* x ∈ A x R y ) ) ;;
	step 7 : wff = funcnv () |- ( Fun ⁻¹ ( R ∩ ( A × B ) ) ↔ ∀ y ∈ ran ( R ∩ ( A × B ) ) ∃* x x ( R ∩ ( A × B ) ) y ) ;;
	step 8 : wff = raleq () |- ( ran ( R ∩ ( A × B ) ) = B → ( ∀ y ∈ ran ( R ∩ ( A × B ) ) ∃* x x ( R ∩ ( A × B ) ) y ↔ ∀ y ∈ B ∃* x x ( R ∩ ( A × B ) ) y ) ) ;;
	step 9 : wff = biimt () |- ( y ∈ B → ( ∃* x ∈ A x R y ↔ ( y ∈ B → ∃* x ∈ A x R y ) ) ) ;;
	step 10 : wff = moanimv () |- ( ∃* x ( y ∈ B ∧ ( x ∈ A ∧ x R y ) ) ↔ ( y ∈ B → ∃* x ( x ∈ A ∧ x R y ) ) ) ;;
	step 11 : wff = brinxp2 () |- ( x ( R ∩ ( A × B ) ) y ↔ ( x ∈ A ∧ y ∈ B ∧ x R y ) ) ;;
	step 12 : wff = 3anan12 () |- ( ( x ∈ A ∧ y ∈ B ∧ x R y ) ↔ ( y ∈ B ∧ ( x ∈ A ∧ x R y ) ) ) ;;
	step 13 : wff = bitri (step 11, step 12) |- ( x ( R ∩ ( A × B ) ) y ↔ ( y ∈ B ∧ ( x ∈ A ∧ x R y ) ) ) ;;
	step 14 : wff = mobii (step 13) |- ( ∃* x x ( R ∩ ( A × B ) ) y ↔ ∃* x ( y ∈ B ∧ ( x ∈ A ∧ x R y ) ) ) ;;
	step 15 : wff = df-rmo () |- ( ∃* x ∈ A x R y ↔ ∃* x ( x ∈ A ∧ x R y ) ) ;;
	step 16 : wff = imbi2i (step 15) |- ( ( y ∈ B → ∃* x ∈ A x R y ) ↔ ( y ∈ B → ∃* x ( x ∈ A ∧ x R y ) ) ) ;;
	step 17 : wff = 3bitr4i (step 10, step 14, step 16) |- ( ∃* x x ( R ∩ ( A × B ) ) y ↔ ( y ∈ B → ∃* x ∈ A x R y ) ) ;;
	step 18 : wff = syl6rbbr (step 9, step 17) |- ( y ∈ B → ( ∃* x x ( R ∩ ( A × B ) ) y ↔ ∃* x ∈ A x R y ) ) ;;
	step 19 : wff = ralbiia (step 18) |- ( ∀ y ∈ B ∃* x x ( R ∩ ( A × B ) ) y ↔ ∀ y ∈ B ∃* x ∈ A x R y ) ;;
	step 20 : wff = syl6bb (step 8, step 19) |- ( ran ( R ∩ ( A × B ) ) = B → ( ∀ y ∈ ran ( R ∩ ( A × B ) ) ∃* x x ( R ∩ ( A × B ) ) y ↔ ∀ y ∈ B ∃* x ∈ A x R y ) ) ;;
	step 21 : wff = syl5bb (step 7, step 20) |- ( ran ( R ∩ ( A × B ) ) = B → ( Fun ⁻¹ ( R ∩ ( A × B ) ) ↔ ∀ y ∈ B ∃* x ∈ A x R y ) ) ;;
	step 22 : wff = pm5.32i (step 21) |- ( ( ran ( R ∩ ( A × B ) ) = B ∧ Fun ⁻¹ ( R ∩ ( A × B ) ) ) ↔ ( ran ( R ∩ ( A × B ) ) = B ∧ ∀ y ∈ B ∃* x ∈ A x R y ) ) ;;
	step 23 : wff = r19.26 () |- ( ∀ y ∈ B ( ∃ x ∈ A x R y ∧ ∃* x ∈ A x R y ) ↔ ( ∀ y ∈ B ∃ x ∈ A x R y ∧ ∀ y ∈ B ∃* x ∈ A x R y ) ) ;;
	step 24 : wff = 3bitr4i (step 6, step 22, step 23) |- ( ( ran ( R ∩ ( A × B ) ) = B ∧ Fun ⁻¹ ( R ∩ ( A × B ) ) ) ↔ ∀ y ∈ B ( ∃ x ∈ A x R y ∧ ∃* x ∈ A x R y ) ) ;;
	step 25 : wff = ancom () |- ( ( Fun ⁻¹ ( R ∩ ( A × B ) ) ∧ ran ( R ∩ ( A × B ) ) = B ) ↔ ( ran ( R ∩ ( A × B ) ) = B ∧ Fun ⁻¹ ( R ∩ ( A × B ) ) ) ) ;;
	step 26 : wff = reu5 () |- ( ∃! x ∈ A x R y ↔ ( ∃ x ∈ A x R y ∧ ∃* x ∈ A x R y ) ) ;;
	step 27 : wff = ralbii (step 26) |- ( ∀ y ∈ B ∃! x ∈ A x R y ↔ ∀ y ∈ B ( ∃ x ∈ A x R y ∧ ∃* x ∈ A x R y ) ) ;;
	step 28 : wff = 3bitr4i (step 24, step 25, step 27) |- ( ( Fun ⁻¹ ( R ∩ ( A × B ) ) ∧ ran ( R ∩ ( A × B ) ) = B ) ↔ ∀ y ∈ B ∃! x ∈ A x R y ) ;;
	step 29 : wff = 3bitr2i (step 1, step 4, step 28) |- ( ⁻¹ ( R ∩ ( A × B ) ) Fn B ↔ ∀ y ∈ B ∃! x ∈ A x R y ) ;;
	qed prop 1 = step 29 ;;
}

/*Two ways of stating that ` A ` is one-to-one (but not necessarily a
       function).  Each side is equivalent to Definition 6.4(3) of
       [TakeutiZaring] p. 24, who use the notation "Un_2 (A)" for one-to-one
       (but not necessarily a function).  (Contributed by NM, 17-Jan-2006.) */

theorem fun11 (x : set, y : set, z : set, w : set, A : class) disjointed(x y z w A, x y, x y) {
	prop 1 : wff = |- ( ( Fun ⁻¹ ⁻¹ A ∧ Fun ⁻¹ A ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ) ;;
}

proof of fun11 {
	step 1 : wff = dfbi2 () |- ( ( x = z ↔ y = w ) ↔ ( ( x = z → y = w ) ∧ ( y = w → x = z ) ) ) ;;
	step 2 : wff = imbi2i (step 1) |- ( ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ↔ ( ( x A y ∧ z A w ) → ( ( x = z → y = w ) ∧ ( y = w → x = z ) ) ) ) ;;
	step 3 : wff = pm4.76 () |- ( ( ( ( x A y ∧ z A w ) → ( x = z → y = w ) ) ∧ ( ( x A y ∧ z A w ) → ( y = w → x = z ) ) ) ↔ ( ( x A y ∧ z A w ) → ( ( x = z → y = w ) ∧ ( y = w → x = z ) ) ) ) ;;
	step 4 : wff = bi2.04 () |- ( ( ( x A y ∧ z A w ) → ( x = z → y = w ) ) ↔ ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ) ;;
	step 5 : wff = bi2.04 () |- ( ( ( x A y ∧ z A w ) → ( y = w → x = z ) ) ↔ ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ;;
	step 6 : wff = anbi12i (step 4, step 5) |- ( ( ( ( x A y ∧ z A w ) → ( x = z → y = w ) ) ∧ ( ( x A y ∧ z A w ) → ( y = w → x = z ) ) ) ↔ ( ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ∧ ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ) ;;
	step 7 : wff = 3bitr2i (step 2, step 3, step 6) |- ( ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ↔ ( ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ∧ ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ) ;;
	step 8 : wff = 2albii (step 7) |- ( ∀ x ∀ y ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ↔ ∀ x ∀ y ( ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ∧ ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ) ;;
	step 9 : wff = 19.26-2 () |- ( ∀ x ∀ y ( ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ∧ ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ↔ ( ∀ x ∀ y ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ∧ ∀ x ∀ y ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ) ;;
	step 10 : wff = alcom () |- ( ∀ x ∀ y ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ↔ ∀ y ∀ x ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ) ;;
	step 11 : wff = nfv () |- F/ x ( ( z A y ∧ z A w ) → y = w ) ;;
	step 12 : wff = breq1 () |- ( x = z → ( x A y ↔ z A y ) ) ;;
	step 13 : wff = anbi1d (step 12) |- ( x = z → ( ( x A y ∧ z A w ) ↔ ( z A y ∧ z A w ) ) ) ;;
	step 14 : wff = imbi1d (step 13) |- ( x = z → ( ( ( x A y ∧ z A w ) → y = w ) ↔ ( ( z A y ∧ z A w ) → y = w ) ) ) ;;
	step 15 : wff = equsal (step 11, step 14) |- ( ∀ x ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ↔ ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 16 : wff = albii (step 15) |- ( ∀ y ∀ x ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ↔ ∀ y ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 17 : wff = bitri (step 10, step 16) |- ( ∀ x ∀ y ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ↔ ∀ y ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 18 : wff = nfv () |- F/ y ( ( x A w ∧ z A w ) → x = z ) ;;
	step 19 : wff = breq2 () |- ( y = w → ( x A y ↔ x A w ) ) ;;
	step 20 : wff = anbi1d (step 19) |- ( y = w → ( ( x A y ∧ z A w ) ↔ ( x A w ∧ z A w ) ) ) ;;
	step 21 : wff = imbi1d (step 20) |- ( y = w → ( ( ( x A y ∧ z A w ) → x = z ) ↔ ( ( x A w ∧ z A w ) → x = z ) ) ) ;;
	step 22 : wff = equsal (step 18, step 21) |- ( ∀ y ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ↔ ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 23 : wff = albii (step 22) |- ( ∀ x ∀ y ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ↔ ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 24 : wff = anbi12i (step 17, step 23) |- ( ( ∀ x ∀ y ( x = z → ( ( x A y ∧ z A w ) → y = w ) ) ∧ ∀ x ∀ y ( y = w → ( ( x A y ∧ z A w ) → x = z ) ) ) ↔ ( ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ) ;;
	step 25 : wff = 3bitri (step 8, step 9, step 24) |- ( ∀ x ∀ y ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ↔ ( ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ) ;;
	step 26 : wff = 2albii (step 25) |- ( ∀ z ∀ w ∀ x ∀ y ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ↔ ∀ z ∀ w ( ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ) ;;
	step 27 : wff = 19.26-2 () |- ( ∀ z ∀ w ( ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ↔ ( ∀ z ∀ w ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ z ∀ w ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ) ;;
	step 28 : wff = bitr2i (step 26, step 27) |- ( ( ∀ z ∀ w ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ z ∀ w ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ↔ ∀ z ∀ w ∀ x ∀ y ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ) ;;
	step 29 : wff = fun2cnv () |- ( Fun ⁻¹ ⁻¹ A ↔ ∀ z ∃* y z A y ) ;;
	step 30 : wff = breq2 () |- ( y = w → ( z A y ↔ z A w ) ) ;;
	step 31 : wff = mo4 (step 30) |- ( ∃* y z A y ↔ ∀ y ∀ w ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 32 : wff = albii (step 31) |- ( ∀ z ∃* y z A y ↔ ∀ z ∀ y ∀ w ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 33 : wff = alcom () |- ( ∀ y ∀ w ( ( z A y ∧ z A w ) → y = w ) ↔ ∀ w ∀ y ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 34 : wff = albii (step 33) |- ( ∀ z ∀ y ∀ w ( ( z A y ∧ z A w ) → y = w ) ↔ ∀ z ∀ w ∀ y ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 35 : wff = 3bitri (step 29, step 32, step 34) |- ( Fun ⁻¹ ⁻¹ A ↔ ∀ z ∀ w ∀ y ( ( z A y ∧ z A w ) → y = w ) ) ;;
	step 36 : wff = funcnv2 () |- ( Fun ⁻¹ A ↔ ∀ w ∃* x x A w ) ;;
	step 37 : wff = breq1 () |- ( x = z → ( x A w ↔ z A w ) ) ;;
	step 38 : wff = mo4 (step 37) |- ( ∃* x x A w ↔ ∀ x ∀ z ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 39 : wff = albii (step 38) |- ( ∀ w ∃* x x A w ↔ ∀ w ∀ x ∀ z ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 40 : wff = alcom () |- ( ∀ x ∀ z ( ( x A w ∧ z A w ) → x = z ) ↔ ∀ z ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 41 : wff = albii (step 40) |- ( ∀ w ∀ x ∀ z ( ( x A w ∧ z A w ) → x = z ) ↔ ∀ w ∀ z ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 42 : wff = alcom () |- ( ∀ w ∀ z ∀ x ( ( x A w ∧ z A w ) → x = z ) ↔ ∀ z ∀ w ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 43 : wff = bitri (step 41, step 42) |- ( ∀ w ∀ x ∀ z ( ( x A w ∧ z A w ) → x = z ) ↔ ∀ z ∀ w ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 44 : wff = 3bitri (step 36, step 39, step 43) |- ( Fun ⁻¹ A ↔ ∀ z ∀ w ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ;;
	step 45 : wff = anbi12i (step 35, step 44) |- ( ( Fun ⁻¹ ⁻¹ A ∧ Fun ⁻¹ A ) ↔ ( ∀ z ∀ w ∀ y ( ( z A y ∧ z A w ) → y = w ) ∧ ∀ z ∀ w ∀ x ( ( x A w ∧ z A w ) → x = z ) ) ) ;;
	step 46 : wff = alrot4 () |- ( ∀ x ∀ y ∀ z ∀ w ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ↔ ∀ z ∀ w ∀ x ∀ y ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ) ;;
	step 47 : wff = 3bitr4i (step 28, step 45, step 46) |- ( ( Fun ⁻¹ ⁻¹ A ∧ Fun ⁻¹ A ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( x A y ∧ z A w ) → ( x = z ↔ y = w ) ) ) ;;
	qed prop 1 = step 47 ;;
}

/*The union of a chain (with respect to inclusion) of functions is a
       function.  (Contributed by NM, 10-Aug-2004.) */

theorem fununi (A : class, f : set, g : set) disjointed(f g x y z w v A, x y, x y) {
	prop 1 : wff = |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⋃ A ) ;;
}

proof of fununi {
	var x : set, y : set, z : set, w : set, v : set;;
	step 1 : wff = funrel () |- ( Fun f → Rel f ) ;;
	step 2 : wff = adantr (step 1) |- ( ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Rel f ) ;;
	step 3 : wff = ralimi (step 2) |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ f ∈ A Rel f ) ;;
	step 4 : wff = reluni () |- ( Rel ⋃ A ↔ ∀ f ∈ A Rel f ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Rel ⋃ A ) ;;
	step 6 : wff = r19.28av () |- ( ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 7 : wff = ralimi (step 6) |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 8 : wff = ssel () |- ( w ⊆ v → ( 〈 x , y 〉 ∈ w → 〈 x , y 〉 ∈ v ) ) ;;
	step 9 : wff = anim1d (step 8) |- ( w ⊆ v → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → ( 〈 x , y 〉 ∈ v ∧ 〈 x , z 〉 ∈ v ) ) ) ;;
	step 10 : wff = dffun4 () |- ( Fun v ↔ ( Rel v ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ v ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 11 : wff = simprbi (step 10) |- ( Fun v → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ v ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 12 : wff = 19.21bbi (step 11) |- ( Fun v → ∀ z ( ( 〈 x , y 〉 ∈ v ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 13 : wff = 19.21bi (step 12) |- ( Fun v → ( ( 〈 x , y 〉 ∈ v ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 14 : wff = syl9r (step 9, step 13) |- ( Fun v → ( w ⊆ v → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 15 : wff = adantl (step 14) |- ( ( Fun w ∧ Fun v ) → ( w ⊆ v → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 16 : wff = ssel () |- ( v ⊆ w → ( 〈 x , z 〉 ∈ v → 〈 x , z 〉 ∈ w ) ) ;;
	step 17 : wff = anim2d (step 16) |- ( v ⊆ w → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ w ) ) ) ;;
	step 18 : wff = dffun4 () |- ( Fun w ↔ ( Rel w ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ w ) → y = z ) ) ) ;;
	step 19 : wff = simprbi (step 18) |- ( Fun w → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ w ) → y = z ) ) ;;
	step 20 : wff = 19.21bbi (step 19) |- ( Fun w → ∀ z ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ w ) → y = z ) ) ;;
	step 21 : wff = 19.21bi (step 20) |- ( Fun w → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ w ) → y = z ) ) ;;
	step 22 : wff = syl9r (step 17, step 21) |- ( Fun w → ( v ⊆ w → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 23 : wff = adantr (step 22) |- ( ( Fun w ∧ Fun v ) → ( v ⊆ w → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 24 : wff = jaod (step 15, step 23) |- ( ( Fun w ∧ Fun v ) → ( ( w ⊆ v ∨ v ⊆ w ) → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 25 : wff = imp (step 24) |- ( ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 26 : wff = ralimi (step 25) |- ( ∀ v ∈ A ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) → ∀ v ∈ A ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 27 : wff = ralimi (step 26) |- ( ∀ w ∈ A ∀ v ∈ A ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) → ∀ w ∈ A ∀ v ∈ A ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 28 : wff = funeq () |- ( f = w → ( Fun f ↔ Fun w ) ) ;;
	step 29 : wff = sseq1 () |- ( f = w → ( f ⊆ g ↔ w ⊆ g ) ) ;;
	step 30 : wff = sseq2 () |- ( f = w → ( g ⊆ f ↔ g ⊆ w ) ) ;;
	step 31 : wff = orbi12d (step 29, step 30) |- ( f = w → ( ( f ⊆ g ∨ g ⊆ f ) ↔ ( w ⊆ g ∨ g ⊆ w ) ) ) ;;
	step 32 : wff = anbi12d (step 28, step 31) |- ( f = w → ( ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ( Fun w ∧ ( w ⊆ g ∨ g ⊆ w ) ) ) ) ;;
	step 33 : wff = sseq2 () |- ( g = v → ( w ⊆ g ↔ w ⊆ v ) ) ;;
	step 34 : wff = sseq1 () |- ( g = v → ( g ⊆ w ↔ v ⊆ w ) ) ;;
	step 35 : wff = orbi12d (step 33, step 34) |- ( g = v → ( ( w ⊆ g ∨ g ⊆ w ) ↔ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 36 : wff = anbi2d (step 35) |- ( g = v → ( ( Fun w ∧ ( w ⊆ g ∨ g ⊆ w ) ) ↔ ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ) ;;
	step 37 : wff = cbvral2v (step 32, step 36) |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ∀ w ∈ A ∀ v ∈ A ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 38 : wff = ralcom () |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ∀ g ∈ A ∀ f ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 39 : wff = orcom () |- ( ( f ⊆ g ∨ g ⊆ f ) ↔ ( g ⊆ f ∨ f ⊆ g ) ) ;;
	step 40 : wff = sseq1 () |- ( g = w → ( g ⊆ f ↔ w ⊆ f ) ) ;;
	step 41 : wff = sseq2 () |- ( g = w → ( f ⊆ g ↔ f ⊆ w ) ) ;;
	step 42 : wff = orbi12d (step 40, step 41) |- ( g = w → ( ( g ⊆ f ∨ f ⊆ g ) ↔ ( w ⊆ f ∨ f ⊆ w ) ) ) ;;
	step 43 : wff = syl5bb (step 39, step 42) |- ( g = w → ( ( f ⊆ g ∨ g ⊆ f ) ↔ ( w ⊆ f ∨ f ⊆ w ) ) ) ;;
	step 44 : wff = anbi2d (step 43) |- ( g = w → ( ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ( Fun f ∧ ( w ⊆ f ∨ f ⊆ w ) ) ) ) ;;
	step 45 : wff = funeq () |- ( f = v → ( Fun f ↔ Fun v ) ) ;;
	step 46 : wff = sseq2 () |- ( f = v → ( w ⊆ f ↔ w ⊆ v ) ) ;;
	step 47 : wff = sseq1 () |- ( f = v → ( f ⊆ w ↔ v ⊆ w ) ) ;;
	step 48 : wff = orbi12d (step 46, step 47) |- ( f = v → ( ( w ⊆ f ∨ f ⊆ w ) ↔ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 49 : wff = anbi12d (step 45, step 48) |- ( f = v → ( ( Fun f ∧ ( w ⊆ f ∨ f ⊆ w ) ) ↔ ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ) ;;
	step 50 : wff = cbvral2v (step 44, step 49) |- ( ∀ g ∈ A ∀ f ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ∀ w ∈ A ∀ v ∈ A ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 51 : wff = bitri (step 38, step 50) |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ∀ w ∈ A ∀ v ∈ A ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 52 : wff = anbi12i (step 37, step 51) |- ( ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ∧ ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ) ↔ ( ∀ w ∈ A ∀ v ∈ A ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ∧ ∀ w ∈ A ∀ v ∈ A ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ) ;;
	step 53 : wff = anidm () |- ( ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ∧ ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ) ↔ ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 54 : wff = anandir () |- ( ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) ↔ ( ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ∧ ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ) ;;
	step 55 : wff = 2ralbii (step 54) |- ( ∀ w ∈ A ∀ v ∈ A ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) ↔ ∀ w ∈ A ∀ v ∈ A ( ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ∧ ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ) ;;
	step 56 : wff = r19.26-2 () |- ( ∀ w ∈ A ∀ v ∈ A ( ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ∧ ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ↔ ( ∀ w ∈ A ∀ v ∈ A ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ∧ ∀ w ∈ A ∀ v ∈ A ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ) ;;
	step 57 : wff = bitr2i (step 55, step 56) |- ( ( ∀ w ∈ A ∀ v ∈ A ( Fun w ∧ ( w ⊆ v ∨ v ⊆ w ) ) ∧ ∀ w ∈ A ∀ v ∈ A ( Fun v ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ↔ ∀ w ∈ A ∀ v ∈ A ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 58 : wff = 3bitr3i (step 52, step 53, step 57) |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) ↔ ∀ w ∈ A ∀ v ∈ A ( ( Fun w ∧ Fun v ) ∧ ( w ⊆ v ∨ v ⊆ w ) ) ) ;;
	step 59 : wff = eluni () |- ( 〈 x , y 〉 ∈ ⋃ A ↔ ∃ w ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ) ;;
	step 60 : wff = eluni () |- ( 〈 x , z 〉 ∈ ⋃ A ↔ ∃ v ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ;;
	step 61 : wff = anbi12i (step 59, step 60) |- ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) ↔ ( ∃ w ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ∧ ∃ v ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ) ;;
	step 62 : wff = eeanv () |- ( ∃ w ∃ v ( ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ∧ ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ↔ ( ∃ w ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ∧ ∃ v ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ) ;;
	step 63 : wff = an4 () |- ( ( ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ∧ ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ↔ ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ∧ ( w ∈ A ∧ v ∈ A ) ) ) ;;
	step 64 : wff = ancom () |- ( ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ∧ ( w ∈ A ∧ v ∈ A ) ) ↔ ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) ) ;;
	step 65 : wff = bitri (step 63, step 64) |- ( ( ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ∧ ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ↔ ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) ) ;;
	step 66 : wff = 2exbii (step 65) |- ( ∃ w ∃ v ( ( 〈 x , y 〉 ∈ w ∧ w ∈ A ) ∧ ( 〈 x , z 〉 ∈ v ∧ v ∈ A ) ) ↔ ∃ w ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) ) ;;
	step 67 : wff = 3bitr2i (step 61, step 62, step 66) |- ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) ↔ ∃ w ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) ) ;;
	step 68 : wff = imbi1i (step 67) |- ( ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ↔ ( ∃ w ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ) ;;
	step 69 : wff = 19.23v () |- ( ∀ w ( ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ↔ ( ∃ w ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ) ;;
	step 70 : wff = r2al () |- ( ∀ w ∈ A ∀ v ∈ A ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ↔ ∀ w ∀ v ( ( w ∈ A ∧ v ∈ A ) → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 71 : wff = impexp () |- ( ( ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ↔ ( ( w ∈ A ∧ v ∈ A ) → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 72 : wff = 2albii (step 71) |- ( ∀ w ∀ v ( ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ↔ ∀ w ∀ v ( ( w ∈ A ∧ v ∈ A ) → ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ) ;;
	step 73 : wff = 19.23v () |- ( ∀ v ( ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ↔ ( ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ) ;;
	step 74 : wff = albii (step 73) |- ( ∀ w ∀ v ( ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ↔ ∀ w ( ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ) ;;
	step 75 : wff = 3bitr2ri (step 70, step 72, step 74) |- ( ∀ w ( ∃ v ( ( w ∈ A ∧ v ∈ A ) ∧ ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) ) → y = z ) ↔ ∀ w ∈ A ∀ v ∈ A ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 76 : wff = 3bitr2i (step 68, step 69, step 75) |- ( ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ↔ ∀ w ∈ A ∀ v ∈ A ( ( 〈 x , y 〉 ∈ w ∧ 〈 x , z 〉 ∈ v ) → y = z ) ) ;;
	step 77 : wff = 3imtr4i (step 27, step 58, step 76) |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) → ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ) ;;
	step 78 : wff = alrimiv (step 77) |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) → ∀ z ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ) ;;
	step 79 : wff = alrimivv (step 78) |- ( ∀ f ∈ A ∀ g ∈ A ( Fun f ∧ ( f ⊆ g ∨ g ⊆ f ) ) → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ) ;;
	step 80 : wff = syl (step 7, step 79) |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ) ;;
	step 81 : wff = dffun4 () |- ( Fun ⋃ A ↔ ( Rel ⋃ A ∧ ∀ x ∀ y ∀ z ( ( 〈 x , y 〉 ∈ ⋃ A ∧ 〈 x , z 〉 ∈ ⋃ A ) → y = z ) ) ) ;;
	step 82 : wff = sylanbrc (step 5, step 80, step 81) |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⋃ A ) ;;
	qed prop 1 = step 82 ;;
}

/*The union of a chain (with respect to inclusion) of single-rooted sets
       is single-rooted.  (See ~ funcnv for "single-rooted" definition.)
       (Contributed by NM, 11-Aug-2004.) */

theorem funcnvuni (A : class, f : set, g : set) disjointed(f g x y z w v A, x y, x y) {
	prop 1 : wff = |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⁻¹ ⋃ A ) ;;
}

proof of funcnvuni {
	var x : set, y : set, z : set, w : set, v : set;;
	step 1 : wff = cnveq () |- ( x = v → ⁻¹ x = ⁻¹ v ) ;;
	step 2 : wff = eqeq2d (step 1) |- ( x = v → ( z = ⁻¹ x ↔ z = ⁻¹ v ) ) ;;
	step 3 : wff = cbvrexv (step 2) |- ( ∃ x ∈ A z = ⁻¹ x ↔ ∃ v ∈ A z = ⁻¹ v ) ;;
	step 4 : wff = cnveq () |- ( f = v → ⁻¹ f = ⁻¹ v ) ;;
	step 5 : wff = funeqd (step 4) |- ( f = v → ( Fun ⁻¹ f ↔ Fun ⁻¹ v ) ) ;;
	step 6 : wff = sseq1 () |- ( f = v → ( f ⊆ g ↔ v ⊆ g ) ) ;;
	step 7 : wff = sseq2 () |- ( f = v → ( g ⊆ f ↔ g ⊆ v ) ) ;;
	step 8 : wff = orbi12d (step 6, step 7) |- ( f = v → ( ( f ⊆ g ∨ g ⊆ f ) ↔ ( v ⊆ g ∨ g ⊆ v ) ) ) ;;
	step 9 : wff = ralbidv (step 8) |- ( f = v → ( ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ↔ ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) ) ) ;;
	step 10 : wff = anbi12d (step 5, step 9) |- ( f = v → ( ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) ↔ ( Fun ⁻¹ v ∧ ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) ) ) ) ;;
	step 11 : wff = rspcv (step 10) |- ( v ∈ A → ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( Fun ⁻¹ v ∧ ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) ) ) ) ;;
	step 12 : wff = funeq () |- ( z = ⁻¹ v → ( Fun z ↔ Fun ⁻¹ v ) ) ;;
	step 13 : wff = biimprcd (step 12) |- ( Fun ⁻¹ v → ( z = ⁻¹ v → Fun z ) ) ;;
	step 14 : wff = sseq2 () |- ( g = x → ( v ⊆ g ↔ v ⊆ x ) ) ;;
	step 15 : wff = sseq1 () |- ( g = x → ( g ⊆ v ↔ x ⊆ v ) ) ;;
	step 16 : wff = orbi12d (step 14, step 15) |- ( g = x → ( ( v ⊆ g ∨ g ⊆ v ) ↔ ( v ⊆ x ∨ x ⊆ v ) ) ) ;;
	step 17 : wff = rspcv (step 16) |- ( x ∈ A → ( ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) → ( v ⊆ x ∨ x ⊆ v ) ) ) ;;
	step 18 : wff = cnvss () |- ( v ⊆ x → ⁻¹ v ⊆ ⁻¹ x ) ;;
	step 19 : wff = cnvss () |- ( x ⊆ v → ⁻¹ x ⊆ ⁻¹ v ) ;;
	step 20 : wff = orim12i (step 18, step 19) |- ( ( v ⊆ x ∨ x ⊆ v ) → ( ⁻¹ v ⊆ ⁻¹ x ∨ ⁻¹ x ⊆ ⁻¹ v ) ) ;;
	step 21 : wff = sseq12 () |- ( ( z = ⁻¹ v ∧ w = ⁻¹ x ) → ( z ⊆ w ↔ ⁻¹ v ⊆ ⁻¹ x ) ) ;;
	step 22 : wff = ancoms (step 21) |- ( ( w = ⁻¹ x ∧ z = ⁻¹ v ) → ( z ⊆ w ↔ ⁻¹ v ⊆ ⁻¹ x ) ) ;;
	step 23 : wff = sseq12 () |- ( ( w = ⁻¹ x ∧ z = ⁻¹ v ) → ( w ⊆ z ↔ ⁻¹ x ⊆ ⁻¹ v ) ) ;;
	step 24 : wff = orbi12d (step 22, step 23) |- ( ( w = ⁻¹ x ∧ z = ⁻¹ v ) → ( ( z ⊆ w ∨ w ⊆ z ) ↔ ( ⁻¹ v ⊆ ⁻¹ x ∨ ⁻¹ x ⊆ ⁻¹ v ) ) ) ;;
	step 25 : wff = syl5ibrcom (step 20, step 24) |- ( ( v ⊆ x ∨ x ⊆ v ) → ( ( w = ⁻¹ x ∧ z = ⁻¹ v ) → ( z ⊆ w ∨ w ⊆ z ) ) ) ;;
	step 26 : wff = exp3a (step 25) |- ( ( v ⊆ x ∨ x ⊆ v ) → ( w = ⁻¹ x → ( z = ⁻¹ v → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ;;
	step 27 : wff = syl6com (step 17, step 26) |- ( ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) → ( x ∈ A → ( w = ⁻¹ x → ( z = ⁻¹ v → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 28 : wff = rexlimdv (step 27) |- ( ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) → ( ∃ x ∈ A w = ⁻¹ x → ( z = ⁻¹ v → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ;;
	step 29 : wff = com23 (step 28) |- ( ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) → ( z = ⁻¹ v → ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ;;
	step 30 : wff = alrimdv (step 29) |- ( ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) → ( z = ⁻¹ v → ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ;;
	step 31 : wff = anim12ii (step 13, step 30) |- ( ( Fun ⁻¹ v ∧ ∀ g ∈ A ( v ⊆ g ∨ g ⊆ v ) ) → ( z = ⁻¹ v → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 32 : wff = syl6com (step 11, step 31) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( v ∈ A → ( z = ⁻¹ v → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ) ;;
	step 33 : wff = rexlimdv (step 32) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( ∃ v ∈ A z = ⁻¹ v → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 34 : wff = syl5bi (step 3, step 33) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( ∃ x ∈ A z = ⁻¹ x → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 35 : wff = alrimiv (step 34) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ z ( ∃ x ∈ A z = ⁻¹ x → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 36 : wff = df-ral () |- ( ∀ z ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ↔ ∀ z ( z ∈ { y | ∃ x ∈ A y = ⁻¹ x } → ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ) ) ;;
	step 37 : wff = vex () |- z ∈ _V ;;
	step 38 : wff = eqeq1 () |- ( y = z → ( y = ⁻¹ x ↔ z = ⁻¹ x ) ) ;;
	step 39 : wff = rexbidv (step 38) |- ( y = z → ( ∃ x ∈ A y = ⁻¹ x ↔ ∃ x ∈ A z = ⁻¹ x ) ) ;;
	step 40 : wff = elab (step 37, step 39) |- ( z ∈ { y | ∃ x ∈ A y = ⁻¹ x } ↔ ∃ x ∈ A z = ⁻¹ x ) ;;
	step 41 : wff = eqeq1 () |- ( y = w → ( y = ⁻¹ x ↔ w = ⁻¹ x ) ) ;;
	step 42 : wff = rexbidv (step 41) |- ( y = w → ( ∃ x ∈ A y = ⁻¹ x ↔ ∃ x ∈ A w = ⁻¹ x ) ) ;;
	step 43 : wff = ralab (step 42) |- ( ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ↔ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ;;
	step 44 : wff = anbi2i (step 43) |- ( ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ↔ ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ;;
	step 45 : wff = imbi12i (step 40, step 44) |- ( ( z ∈ { y | ∃ x ∈ A y = ⁻¹ x } → ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ) ↔ ( ∃ x ∈ A z = ⁻¹ x → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 46 : wff = albii (step 45) |- ( ∀ z ( z ∈ { y | ∃ x ∈ A y = ⁻¹ x } → ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ) ↔ ∀ z ( ∃ x ∈ A z = ⁻¹ x → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ) ;;
	step 47 : wff = bitr2i (step 36, step 46) |- ( ∀ z ( ∃ x ∈ A z = ⁻¹ x → ( Fun z ∧ ∀ w ( ∃ x ∈ A w = ⁻¹ x → ( z ⊆ w ∨ w ⊆ z ) ) ) ) ↔ ∀ z ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ) ;;
	step 48 : wff = sylib (step 35, step 47) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ z ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) ) ;;
	step 49 : wff = fununi () |- ( ∀ z ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( Fun z ∧ ∀ w ∈ { y | ∃ x ∈ A y = ⁻¹ x } ( z ⊆ w ∨ w ⊆ z ) ) → Fun ⋃ { y | ∃ x ∈ A y = ⁻¹ x } ) ;;
	step 50 : wff = syl (step 48, step 49) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⋃ { y | ∃ x ∈ A y = ⁻¹ x } ) ;;
	step 51 : wff = cnvuni () |- ⁻¹ ⋃ A = ⋃_ x ∈ A ⁻¹ x ;;
	step 52 : wff = vex () |- x ∈ _V ;;
	step 53 : wff = cnvex (step 52) |- ⁻¹ x ∈ _V ;;
	step 54 : wff = dfiun2 (step 53) |- ⋃_ x ∈ A ⁻¹ x = ⋃ { y | ∃ x ∈ A y = ⁻¹ x } ;;
	step 55 : wff = eqtri (step 51, step 54) |- ⁻¹ ⋃ A = ⋃ { y | ∃ x ∈ A y = ⁻¹ x } ;;
	step 56 : wff = funeqi (step 55) |- ( Fun ⁻¹ ⋃ A ↔ Fun ⋃ { y | ∃ x ∈ A y = ⁻¹ x } ) ;;
	step 57 : wff = sylibr (step 50, step 56) |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⁻¹ ⋃ A ) ;;
	qed prop 1 = step 57 ;;
}

/*The union of a chain (with respect to inclusion) of one-to-one functions
       is a one-to-one function.  (Contributed by NM, 11-Aug-2004.) */

theorem fun11uni (A : class, f : set, g : set) disjointed(f g A) {
	prop 1 : wff = |- ( ∀ f ∈ A ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( Fun ⋃ A ∧ Fun ⁻¹ ⋃ A ) ) ;;
}

proof of fun11uni {
	step 1 : wff = simpl () |- ( ( Fun f ∧ Fun ⁻¹ f ) → Fun f ) ;;
	step 2 : wff = anim1i (step 1) |- ( ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 3 : wff = ralimi (step 2) |- ( ∀ f ∈ A ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 4 : wff = fununi () |- ( ∀ f ∈ A ( Fun f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⋃ A ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ∀ f ∈ A ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⋃ A ) ;;
	step 6 : wff = simpr () |- ( ( Fun f ∧ Fun ⁻¹ f ) → Fun ⁻¹ f ) ;;
	step 7 : wff = anim1i (step 6) |- ( ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 8 : wff = ralimi (step 7) |- ( ∀ f ∈ A ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) ) ;;
	step 9 : wff = funcnvuni () |- ( ∀ f ∈ A ( Fun ⁻¹ f ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⁻¹ ⋃ A ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ∀ f ∈ A ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → Fun ⁻¹ ⋃ A ) ;;
	step 11 : wff = jca (step 5, step 10) |- ( ∀ f ∈ A ( ( Fun f ∧ Fun ⁻¹ f ) ∧ ∀ g ∈ A ( f ⊆ g ∨ g ⊆ f ) ) → ( Fun ⋃ A ∧ Fun ⁻¹ ⋃ A ) ) ;;
	qed prop 1 = step 11 ;;
}

/*The intersection with a function is a function.  Exercise 14(a) of
       [Enderton] p. 53.  (Contributed by NM, 19-Mar-2004.)  (Proof shortened
       by Andrew Salmon, 17-Sep-2011.) */

theorem funin (F : class, G : class) disjointed(F, G) {
	prop 1 : wff = |- ( Fun F → Fun ( F ∩ G ) ) ;;
}

proof of funin {
	step 1 : wff = inss1 () |- ( F ∩ G ) ⊆ F ;;
	step 2 : wff = funss () |- ( ( F ∩ G ) ⊆ F → ( Fun F → Fun ( F ∩ G ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( Fun F → Fun ( F ∩ G ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The restriction of a one-to-one function is one-to-one.  (Contributed by
     NM, 25-Mar-1998.) */

theorem funres11 (A : class, F : class)  {
	prop 1 : wff = |- ( Fun ⁻¹ F → Fun ⁻¹ ( F ↾ A ) ) ;;
}

proof of funres11 {
	step 1 : wff = resss () |- ( F ↾ A ) ⊆ F ;;
	step 2 : wff = cnvss () |- ( ( F ↾ A ) ⊆ F → ⁻¹ ( F ↾ A ) ⊆ ⁻¹ F ) ;;
	step 3 : wff = funss () |- ( ⁻¹ ( F ↾ A ) ⊆ ⁻¹ F → ( Fun ⁻¹ F → Fun ⁻¹ ( F ↾ A ) ) ) ;;
	step 4 : wff = mp2b (step 1, step 2, step 3) |- ( Fun ⁻¹ F → Fun ⁻¹ ( F ↾ A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*The converse of a restricted function.  (Contributed by NM,
     27-Mar-1998.) */

theorem funcnvres (A : class, F : class)  {
	prop 1 : wff = |- ( Fun ⁻¹ F → ⁻¹ ( F ↾ A ) = ( ⁻¹ F ↾ ( F " A ) ) ) ;;
}

proof of funcnvres {
	step 1 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 2 : wff = df-rn () |- ran ( F ↾ A ) = dom ⁻¹ ( F ↾ A ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( F " A ) = dom ⁻¹ ( F ↾ A ) ;;
	step 4 : wff = reseq2i (step 3) |- ( ⁻¹ F ↾ ( F " A ) ) = ( ⁻¹ F ↾ dom ⁻¹ ( F ↾ A ) ) ;;
	step 5 : wff = resss () |- ( F ↾ A ) ⊆ F ;;
	step 6 : wff = cnvss () |- ( ( F ↾ A ) ⊆ F → ⁻¹ ( F ↾ A ) ⊆ ⁻¹ F ) ;;
	step 7 : wff = ax-mp (step 5, step 6) |- ⁻¹ ( F ↾ A ) ⊆ ⁻¹ F ;;
	step 8 : wff = funssres () |- ( ( Fun ⁻¹ F ∧ ⁻¹ ( F ↾ A ) ⊆ ⁻¹ F ) → ( ⁻¹ F ↾ dom ⁻¹ ( F ↾ A ) ) = ⁻¹ ( F ↾ A ) ) ;;
	step 9 : wff = mpan2 (step 7, step 8) |- ( Fun ⁻¹ F → ( ⁻¹ F ↾ dom ⁻¹ ( F ↾ A ) ) = ⁻¹ ( F ↾ A ) ) ;;
	step 10 : wff = syl5req (step 4, step 9) |- ( Fun ⁻¹ F → ⁻¹ ( F ↾ A ) = ( ⁻¹ F ↾ ( F " A ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Converse of a restricted identity function.  (Contributed by FL,
     4-Mar-2007.) */

theorem cnvresid (A : class)  {
	prop 1 : wff = |- ⁻¹ ( _I ↾ A ) = ( _I ↾ A ) ;;
}

proof of cnvresid {
	step 1 : wff = cnvi () |- ⁻¹ _I = _I ;;
	step 2 : wff = eqcomi (step 1) |- _I = ⁻¹ _I ;;
	step 3 : wff = funi () |- Fun _I ;;
	step 4 : wff = funeq () |- ( _I = ⁻¹ _I → ( Fun _I ↔ Fun ⁻¹ _I ) ) ;;
	step 5 : wff = mpbii (step 3, step 4) |- ( _I = ⁻¹ _I → Fun ⁻¹ _I ) ;;
	step 6 : wff = funcnvres () |- ( Fun ⁻¹ _I → ⁻¹ ( _I ↾ A ) = ( ⁻¹ _I ↾ ( _I " A ) ) ) ;;
	step 7 : wff = cnvi () |- ⁻¹ _I = _I ;;
	step 8 : wff = imai () |- ( _I " A ) = A ;;
	step 9 : wff = reseq12i (step 7, step 8) |- ( ⁻¹ _I ↾ ( _I " A ) ) = ( _I ↾ A ) ;;
	step 10 : wff = syl6eq (step 6, step 9) |- ( Fun ⁻¹ _I → ⁻¹ ( _I ↾ A ) = ( _I ↾ A ) ) ;;
	step 11 : wff = mp2b (step 2, step 5, step 10) |- ⁻¹ ( _I ↾ A ) = ( _I ↾ A ) ;;
	qed prop 1 = step 11 ;;
}

/*The converse of a restriction of the converse of a function equals the
     function restricted to the image of its converse.  (Contributed by NM,
     4-May-2005.) */

theorem funcnvres2 (A : class, F : class)  {
	prop 1 : wff = |- ( Fun F → ⁻¹ ( ⁻¹ F ↾ A ) = ( F ↾ ( ⁻¹ F " A ) ) ) ;;
}

proof of funcnvres2 {
	step 1 : wff = funcnvcnv () |- ( Fun F → Fun ⁻¹ ⁻¹ F ) ;;
	step 2 : wff = funcnvres () |- ( Fun ⁻¹ ⁻¹ F → ⁻¹ ( ⁻¹ F ↾ A ) = ( ⁻¹ ⁻¹ F ↾ ( ⁻¹ F " A ) ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( Fun F → ⁻¹ ( ⁻¹ F ↾ A ) = ( ⁻¹ ⁻¹ F ↾ ( ⁻¹ F " A ) ) ) ;;
	step 4 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 5 : wff = dfrel2 () |- ( Rel F ↔ ⁻¹ ⁻¹ F = F ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( Fun F → ⁻¹ ⁻¹ F = F ) ;;
	step 7 : wff = reseq1d (step 6) |- ( Fun F → ( ⁻¹ ⁻¹ F ↾ ( ⁻¹ F " A ) ) = ( F ↾ ( ⁻¹ F " A ) ) ) ;;
	step 8 : wff = eqtrd (step 3, step 7) |- ( Fun F → ⁻¹ ( ⁻¹ F ↾ A ) = ( F ↾ ( ⁻¹ F " A ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*The image of the preimage of a function.  (Contributed by NM,
     25-May-2004.) */

theorem funimacnv (A : class, F : class)  {
	prop 1 : wff = |- ( Fun F → ( F " ( ⁻¹ F " A ) ) = ( A ∩ ran F ) ) ;;
}

proof of funimacnv {
	step 1 : wff = funcnvres2 () |- ( Fun F → ⁻¹ ( ⁻¹ F ↾ A ) = ( F ↾ ( ⁻¹ F " A ) ) ) ;;
	step 2 : wff = rneqd (step 1) |- ( Fun F → ran ⁻¹ ( ⁻¹ F ↾ A ) = ran ( F ↾ ( ⁻¹ F " A ) ) ) ;;
	step 3 : wff = df-ima () |- ( F " ( ⁻¹ F " A ) ) = ran ( F ↾ ( ⁻¹ F " A ) ) ;;
	step 4 : wff = syl6reqr (step 2, step 3) |- ( Fun F → ( F " ( ⁻¹ F " A ) ) = ran ⁻¹ ( ⁻¹ F ↾ A ) ) ;;
	step 5 : wff = df-rn () |- ran F = dom ⁻¹ F ;;
	step 6 : wff = ineq2i (step 5) |- ( A ∩ ran F ) = ( A ∩ dom ⁻¹ F ) ;;
	step 7 : wff = dmres () |- dom ( ⁻¹ F ↾ A ) = ( A ∩ dom ⁻¹ F ) ;;
	step 8 : wff = dfdm4 () |- dom ( ⁻¹ F ↾ A ) = ran ⁻¹ ( ⁻¹ F ↾ A ) ;;
	step 9 : wff = 3eqtr2ri (step 6, step 7, step 8) |- ran ⁻¹ ( ⁻¹ F ↾ A ) = ( A ∩ ran F ) ;;
	step 10 : wff = syl6eq (step 4, step 9) |- ( Fun F → ( F " ( ⁻¹ F " A ) ) = ( A ∩ ran F ) ) ;;
	qed prop 1 = step 10 ;;
}

/*A kind of contraposition law that infers a subclass of an image from a
     preimage subclass.  (Contributed by NM, 25-May-2004.) */

theorem funimass1 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ ran F ) → ( ( ⁻¹ F " A ) ⊆ B → A ⊆ ( F " B ) ) ) ;;
}

proof of funimass1 {
	step 1 : wff = imass2 () |- ( ( ⁻¹ F " A ) ⊆ B → ( F " ( ⁻¹ F " A ) ) ⊆ ( F " B ) ) ;;
	step 2 : wff = funimacnv () |- ( Fun F → ( F " ( ⁻¹ F " A ) ) = ( A ∩ ran F ) ) ;;
	step 3 : wff = dfss () |- ( A ⊆ ran F ↔ A = ( A ∩ ran F ) ) ;;
	step 4 : wff = biimpi (step 3) |- ( A ⊆ ran F → A = ( A ∩ ran F ) ) ;;
	step 5 : wff = eqcomd (step 4) |- ( A ⊆ ran F → ( A ∩ ran F ) = A ) ;;
	step 6 : wff = sylan9eq (step 2, step 5) |- ( ( Fun F ∧ A ⊆ ran F ) → ( F " ( ⁻¹ F " A ) ) = A ) ;;
	step 7 : wff = sseq1d (step 6) |- ( ( Fun F ∧ A ⊆ ran F ) → ( ( F " ( ⁻¹ F " A ) ) ⊆ ( F " B ) ↔ A ⊆ ( F " B ) ) ) ;;
	step 8 : wff = syl5ib (step 1, step 7) |- ( ( Fun F ∧ A ⊆ ran F ) → ( ( ⁻¹ F " A ) ⊆ B → A ⊆ ( F " B ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*A kind of contraposition law that infers an image subclass from a subclass
     of a preimage.  (Contributed by NM, 25-May-2004.) */

theorem funimass2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ ( ⁻¹ F " B ) ) → ( F " A ) ⊆ B ) ;;
}

proof of funimass2 {
	step 1 : wff = imass2 () |- ( A ⊆ ( ⁻¹ F " B ) → ( F " A ) ⊆ ( F " ( ⁻¹ F " B ) ) ) ;;
	step 2 : wff = funimacnv () |- ( Fun F → ( F " ( ⁻¹ F " B ) ) = ( B ∩ ran F ) ) ;;
	step 3 : wff = sseq2d (step 2) |- ( Fun F → ( ( F " A ) ⊆ ( F " ( ⁻¹ F " B ) ) ↔ ( F " A ) ⊆ ( B ∩ ran F ) ) ) ;;
	step 4 : wff = inss1 () |- ( B ∩ ran F ) ⊆ B ;;
	step 5 : wff = sstr2 () |- ( ( F " A ) ⊆ ( B ∩ ran F ) → ( ( B ∩ ran F ) ⊆ B → ( F " A ) ⊆ B ) ) ;;
	step 6 : wff = mpi (step 4, step 5) |- ( ( F " A ) ⊆ ( B ∩ ran F ) → ( F " A ) ⊆ B ) ;;
	step 7 : wff = syl6bi (step 3, step 6) |- ( Fun F → ( ( F " A ) ⊆ ( F " ( ⁻¹ F " B ) ) → ( F " A ) ⊆ B ) ) ;;
	step 8 : wff = imp (step 7) |- ( ( Fun F ∧ ( F " A ) ⊆ ( F " ( ⁻¹ F " B ) ) ) → ( F " A ) ⊆ B ) ;;
	step 9 : wff = sylan2 (step 1, step 8) |- ( ( Fun F ∧ A ⊆ ( ⁻¹ F " B ) ) → ( F " A ) ⊆ B ) ;;
	qed prop 1 = step 9 ;;
}

/*The image of a difference is the difference of images.  (Contributed by
       NM, 24-May-1998.) */

theorem imadif (A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( Fun ⁻¹ F → ( F " ( A ∖ B ) ) = ( ( F " A ) ∖ ( F " B ) ) ) ;;
}

proof of imadif {
	var x : set, y : set;;
	step 1 : wff = anandir () |- ( ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ↔ ( ( x ∈ A ∧ x F y ) ∧ ( ¬ x ∈ B ∧ x F y ) ) ) ;;
	step 2 : wff = exbii (step 1) |- ( ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ↔ ∃ x ( ( x ∈ A ∧ x F y ) ∧ ( ¬ x ∈ B ∧ x F y ) ) ) ;;
	step 3 : wff = 19.40 () |- ( ∃ x ( ( x ∈ A ∧ x F y ) ∧ ( ¬ x ∈ B ∧ x F y ) ) → ( ∃ x ( x ∈ A ∧ x F y ) ∧ ∃ x ( ¬ x ∈ B ∧ x F y ) ) ) ;;
	step 4 : wff = sylbi (step 2, step 3) |- ( ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) → ( ∃ x ( x ∈ A ∧ x F y ) ∧ ∃ x ( ¬ x ∈ B ∧ x F y ) ) ) ;;
	step 5 : wff = nfv () |- F/ x Fun ⁻¹ F ;;
	step 6 : wff = nfe1 () |- F/ x ∃ x ( x F y ∧ ¬ x ∈ B ) ;;
	step 7 : wff = nfan (step 5, step 6) |- F/ x ( Fun ⁻¹ F ∧ ∃ x ( x F y ∧ ¬ x ∈ B ) ) ;;
	step 8 : wff = funmo () |- ( Fun ⁻¹ F → ∃* x y ⁻¹ F x ) ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = brcnv (step 9, step 10) |- ( y ⁻¹ F x ↔ x F y ) ;;
	step 12 : wff = mobii (step 11) |- ( ∃* x y ⁻¹ F x ↔ ∃* x x F y ) ;;
	step 13 : wff = sylib (step 8, step 12) |- ( Fun ⁻¹ F → ∃* x x F y ) ;;
	step 14 : wff = mopick () |- ( ( ∃* x x F y ∧ ∃ x ( x F y ∧ ¬ x ∈ B ) ) → ( x F y → ¬ x ∈ B ) ) ;;
	step 15 : wff = sylan (step 13, step 14) |- ( ( Fun ⁻¹ F ∧ ∃ x ( x F y ∧ ¬ x ∈ B ) ) → ( x F y → ¬ x ∈ B ) ) ;;
	step 16 : wff = con2d (step 15) |- ( ( Fun ⁻¹ F ∧ ∃ x ( x F y ∧ ¬ x ∈ B ) ) → ( x ∈ B → ¬ x F y ) ) ;;
	step 17 : wff = imnan () |- ( ( x ∈ B → ¬ x F y ) ↔ ¬ ( x ∈ B ∧ x F y ) ) ;;
	step 18 : wff = sylib (step 16, step 17) |- ( ( Fun ⁻¹ F ∧ ∃ x ( x F y ∧ ¬ x ∈ B ) ) → ¬ ( x ∈ B ∧ x F y ) ) ;;
	step 19 : wff = alrimi (step 7, step 18) |- ( ( Fun ⁻¹ F ∧ ∃ x ( x F y ∧ ¬ x ∈ B ) ) → ∀ x ¬ ( x ∈ B ∧ x F y ) ) ;;
	step 20 : wff = ex (step 19) |- ( Fun ⁻¹ F → ( ∃ x ( x F y ∧ ¬ x ∈ B ) → ∀ x ¬ ( x ∈ B ∧ x F y ) ) ) ;;
	step 21 : wff = exancom () |- ( ∃ x ( x F y ∧ ¬ x ∈ B ) ↔ ∃ x ( ¬ x ∈ B ∧ x F y ) ) ;;
	step 22 : wff = alnex () |- ( ∀ x ¬ ( x ∈ B ∧ x F y ) ↔ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ;;
	step 23 : wff = 3imtr3g (step 20, step 21, step 22) |- ( Fun ⁻¹ F → ( ∃ x ( ¬ x ∈ B ∧ x F y ) → ¬ ∃ x ( x ∈ B ∧ x F y ) ) ) ;;
	step 24 : wff = anim2d (step 23) |- ( Fun ⁻¹ F → ( ( ∃ x ( x ∈ A ∧ x F y ) ∧ ∃ x ( ¬ x ∈ B ∧ x F y ) ) → ( ∃ x ( x ∈ A ∧ x F y ) ∧ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ) ) ;;
	step 25 : wff = syl5 (step 4, step 24) |- ( Fun ⁻¹ F → ( ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) → ( ∃ x ( x ∈ A ∧ x F y ) ∧ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ) ) ;;
	step 26 : wff = alnex () |- ( ∀ x ¬ ( x ∈ B ∧ x F y ) ↔ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ;;
	step 27 : wff = 19.29r () |- ( ( ∃ x ( x ∈ A ∧ x F y ) ∧ ∀ x ¬ ( x ∈ B ∧ x F y ) ) → ∃ x ( ( x ∈ A ∧ x F y ) ∧ ¬ ( x ∈ B ∧ x F y ) ) ) ;;
	step 28 : wff = sylan2br (step 26, step 27) |- ( ( ∃ x ( x ∈ A ∧ x F y ) ∧ ¬ ∃ x ( x ∈ B ∧ x F y ) ) → ∃ x ( ( x ∈ A ∧ x F y ) ∧ ¬ ( x ∈ B ∧ x F y ) ) ) ;;
	step 29 : wff = andi () |- ( ( ( x ∈ A ∧ x F y ) ∧ ( ¬ x ∈ B ∨ ¬ x F y ) ) ↔ ( ( ( x ∈ A ∧ x F y ) ∧ ¬ x ∈ B ) ∨ ( ( x ∈ A ∧ x F y ) ∧ ¬ x F y ) ) ) ;;
	step 30 : wff = ianor () |- ( ¬ ( x ∈ B ∧ x F y ) ↔ ( ¬ x ∈ B ∨ ¬ x F y ) ) ;;
	step 31 : wff = anbi2i (step 30) |- ( ( ( x ∈ A ∧ x F y ) ∧ ¬ ( x ∈ B ∧ x F y ) ) ↔ ( ( x ∈ A ∧ x F y ) ∧ ( ¬ x ∈ B ∨ ¬ x F y ) ) ) ;;
	step 32 : wff = an32 () |- ( ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ↔ ( ( x ∈ A ∧ x F y ) ∧ ¬ x ∈ B ) ) ;;
	step 33 : wff = pm3.24 () |- ¬ ( x F y ∧ ¬ x F y ) ;;
	step 34 : wff = intnan (step 33) |- ¬ ( x ∈ A ∧ ( x F y ∧ ¬ x F y ) ) ;;
	step 35 : wff = anass () |- ( ( ( x ∈ A ∧ x F y ) ∧ ¬ x F y ) ↔ ( x ∈ A ∧ ( x F y ∧ ¬ x F y ) ) ) ;;
	step 36 : wff = mtbir (step 34, step 35) |- ¬ ( ( x ∈ A ∧ x F y ) ∧ ¬ x F y ) ;;
	step 37 : wff = biorfi (step 36) |- ( ( ( x ∈ A ∧ x F y ) ∧ ¬ x ∈ B ) ↔ ( ( ( x ∈ A ∧ x F y ) ∧ ¬ x ∈ B ) ∨ ( ( x ∈ A ∧ x F y ) ∧ ¬ x F y ) ) ) ;;
	step 38 : wff = bitri (step 32, step 37) |- ( ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ↔ ( ( ( x ∈ A ∧ x F y ) ∧ ¬ x ∈ B ) ∨ ( ( x ∈ A ∧ x F y ) ∧ ¬ x F y ) ) ) ;;
	step 39 : wff = 3bitr4i (step 29, step 31, step 38) |- ( ( ( x ∈ A ∧ x F y ) ∧ ¬ ( x ∈ B ∧ x F y ) ) ↔ ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ) ;;
	step 40 : wff = exbii (step 39) |- ( ∃ x ( ( x ∈ A ∧ x F y ) ∧ ¬ ( x ∈ B ∧ x F y ) ) ↔ ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ) ;;
	step 41 : wff = sylib (step 28, step 40) |- ( ( ∃ x ( x ∈ A ∧ x F y ) ∧ ¬ ∃ x ( x ∈ B ∧ x F y ) ) → ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ) ;;
	step 42 : wff = impbid1 (step 25, step 41) |- ( Fun ⁻¹ F → ( ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ↔ ( ∃ x ( x ∈ A ∧ x F y ) ∧ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ) ) ;;
	step 43 : wff = eldif () |- ( x ∈ ( A ∖ B ) ↔ ( x ∈ A ∧ ¬ x ∈ B ) ) ;;
	step 44 : wff = anbi1i (step 43) |- ( ( x ∈ ( A ∖ B ) ∧ x F y ) ↔ ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ) ;;
	step 45 : wff = exbii (step 44) |- ( ∃ x ( x ∈ ( A ∖ B ) ∧ x F y ) ↔ ∃ x ( ( x ∈ A ∧ ¬ x ∈ B ) ∧ x F y ) ) ;;
	step 46 : wff = vex () |- y ∈ _V ;;
	step 47 : wff = elima2 (step 46) |- ( y ∈ ( F " A ) ↔ ∃ x ( x ∈ A ∧ x F y ) ) ;;
	step 48 : wff = vex () |- y ∈ _V ;;
	step 49 : wff = elima2 (step 48) |- ( y ∈ ( F " B ) ↔ ∃ x ( x ∈ B ∧ x F y ) ) ;;
	step 50 : wff = notbii (step 49) |- ( ¬ y ∈ ( F " B ) ↔ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ;;
	step 51 : wff = anbi12i (step 47, step 50) |- ( ( y ∈ ( F " A ) ∧ ¬ y ∈ ( F " B ) ) ↔ ( ∃ x ( x ∈ A ∧ x F y ) ∧ ¬ ∃ x ( x ∈ B ∧ x F y ) ) ) ;;
	step 52 : wff = 3bitr4g (step 42, step 45, step 51) |- ( Fun ⁻¹ F → ( ∃ x ( x ∈ ( A ∖ B ) ∧ x F y ) ↔ ( y ∈ ( F " A ) ∧ ¬ y ∈ ( F " B ) ) ) ) ;;
	step 53 : wff = vex () |- y ∈ _V ;;
	step 54 : wff = elima2 (step 53) |- ( y ∈ ( F " ( A ∖ B ) ) ↔ ∃ x ( x ∈ ( A ∖ B ) ∧ x F y ) ) ;;
	step 55 : wff = eldif () |- ( y ∈ ( ( F " A ) ∖ ( F " B ) ) ↔ ( y ∈ ( F " A ) ∧ ¬ y ∈ ( F " B ) ) ) ;;
	step 56 : wff = 3bitr4g (step 52, step 54, step 55) |- ( Fun ⁻¹ F → ( y ∈ ( F " ( A ∖ B ) ) ↔ y ∈ ( ( F " A ) ∖ ( F " B ) ) ) ) ;;
	step 57 : wff = eqrdv (step 56) |- ( Fun ⁻¹ F → ( F " ( A ∖ B ) ) = ( ( F " A ) ∖ ( F " B ) ) ) ;;
	qed prop 1 = step 57 ;;
}

/*The image of an intersection is the intersection of images.  (Contributed
     by Paul Chapman, 11-Apr-2009.) */

theorem imain (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( Fun ⁻¹ F → ( F " ( A ∩ B ) ) = ( ( F " A ) ∩ ( F " B ) ) ) ;;
}

proof of imain {
	step 1 : wff = imadif () |- ( Fun ⁻¹ F → ( F " ( A ∖ ( A ∖ B ) ) ) = ( ( F " A ) ∖ ( F " ( A ∖ B ) ) ) ) ;;
	step 2 : wff = imadif () |- ( Fun ⁻¹ F → ( F " ( A ∖ B ) ) = ( ( F " A ) ∖ ( F " B ) ) ) ;;
	step 3 : wff = difeq2d (step 2) |- ( Fun ⁻¹ F → ( ( F " A ) ∖ ( F " ( A ∖ B ) ) ) = ( ( F " A ) ∖ ( ( F " A ) ∖ ( F " B ) ) ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( Fun ⁻¹ F → ( F " ( A ∖ ( A ∖ B ) ) ) = ( ( F " A ) ∖ ( ( F " A ) ∖ ( F " B ) ) ) ) ;;
	step 5 : wff = dfin4 () |- ( A ∩ B ) = ( A ∖ ( A ∖ B ) ) ;;
	step 6 : wff = imaeq2i (step 5) |- ( F " ( A ∩ B ) ) = ( F " ( A ∖ ( A ∖ B ) ) ) ;;
	step 7 : wff = dfin4 () |- ( ( F " A ) ∩ ( F " B ) ) = ( ( F " A ) ∖ ( ( F " A ) ∖ ( F " B ) ) ) ;;
	step 8 : wff = 3eqtr4g (step 4, step 6, step 7) |- ( Fun ⁻¹ F → ( F " ( A ∩ B ) ) = ( ( F " A ) ∩ ( F " B ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Axiom of Replacement using abbreviations.  Axiom 39(vi) of [Quine]
       p. 284.  Compare Exercise 9 of [TakeutiZaring] p. 29.  (Contributed by
       NM, 10-Sep-2006.) */

theorem funimaexg (A : class, B : class, C : class) disjointed(w B, x y z w A) {
	prop 1 : wff = |- ( ( Fun A ∧ B ∈ C ) → ( A " B ) ∈ _V ) ;;
}

proof of funimaexg {
	var x : set, y : set, z : set, w : set;;
	step 1 : wff = imaeq2 () |- ( w = B → ( A " w ) = ( A " B ) ) ;;
	step 2 : wff = eleq1d (step 1) |- ( w = B → ( ( A " w ) ∈ _V ↔ ( A " B ) ∈ _V ) ) ;;
	step 3 : wff = imbi2d (step 2) |- ( w = B → ( ( Fun A → ( A " w ) ∈ _V ) ↔ ( Fun A → ( A " B ) ∈ _V ) ) ) ;;
	step 4 : wff = dffun5 () |- ( Fun A ↔ ( Rel A ∧ ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ) ;;
	step 5 : wff = simprbi (step 4) |- ( Fun A → ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) ) ;;
	step 6 : wff = nfv () |- F/ z 〈 x , y 〉 ∈ A ;;
	step 7 : wff = axrep4 (step 6) |- ( ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) → ∃ z ∀ y ( y ∈ z ↔ ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) ) ) ;;
	step 8 : wff = isset () |- ( ( A " w ) ∈ _V ↔ ∃ z z = ( A " w ) ) ;;
	step 9 : wff = dfima3 () |- ( A " w ) = { y | ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) } ;;
	step 10 : wff = eqeq2i (step 9) |- ( z = ( A " w ) ↔ z = { y | ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) } ) ;;
	step 11 : wff = abeq2 () |- ( z = { y | ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) } ↔ ∀ y ( y ∈ z ↔ ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( z = ( A " w ) ↔ ∀ y ( y ∈ z ↔ ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ z z = ( A " w ) ↔ ∃ z ∀ y ( y ∈ z ↔ ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) ) ) ;;
	step 14 : wff = bitri (step 8, step 13) |- ( ( A " w ) ∈ _V ↔ ∃ z ∀ y ( y ∈ z ↔ ∃ x ( x ∈ w ∧ 〈 x , y 〉 ∈ A ) ) ) ;;
	step 15 : wff = sylibr (step 7, step 14) |- ( ∀ x ∃ z ∀ y ( 〈 x , y 〉 ∈ A → y = z ) → ( A " w ) ∈ _V ) ;;
	step 16 : wff = syl (step 5, step 15) |- ( Fun A → ( A " w ) ∈ _V ) ;;
	step 17 : wff = vtoclg (step 3, step 16) |- ( B ∈ C → ( Fun A → ( A " B ) ∈ _V ) ) ;;
	step 18 : wff = impcom (step 17) |- ( ( Fun A ∧ B ∈ C ) → ( A " B ) ∈ _V ) ;;
	qed prop 1 = step 18 ;;
}

/*The image of a set under any function is also a set.  Equivalent of
       Axiom of Replacement ~ ax-rep .  Axiom 39(vi) of [Quine] p. 284.
       Compare Exercise 9 of [TakeutiZaring] p. 29.  (Contributed by NM,
       17-Nov-2002.) */

theorem funimaex (A : class, B : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( Fun A → ( A " B ) ∈ _V ) ;;
}

proof of funimaex {
	step 1 : wff = funimaexg () |- ( ( Fun A ∧ B ∈ _V ) → ( A " B ) ∈ _V ) ;;
	step 2 : wff = mpan2 (hyp 1, step 1) |- ( Fun A → ( A " B ) ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/*Part of a study of the Axiom of Replacement used by the Isabelle
       prover.  The object PrimReplace is apparently the image of the function
       encoded by ` ph ( x , y ) ` i.e. the class
       ` ( { <. x , y >. | ph } " A ) ` .  If so, we can prove Isabelle's
       "Axiom of Replacement" conclusion without using the Axiom of
       Replacement, for which I (N. Megill) currently have no explanation.
       (Contributed by NM, 26-Oct-2006.)  (Proof shortened by Mario Carneiro,
       4-Dec-2016.) */

theorem isarep1 (ph : wff, x : set, y : set, A : class, b : set) disjointed(x z A, b x y z, z ph) {
	prop 1 : wff = |- ( b ∈ ( { 〈 x , y 〉 | ph } " A ) ↔ ∃ x ∈ A [ b / y ] ph ) ;;
}

proof of isarep1 {
	var z : set;;
	step 1 : wff = vex () |- b ∈ _V ;;
	step 2 : wff = elima (step 1) |- ( b ∈ ( { 〈 x , y 〉 | ph } " A ) ↔ ∃ z ∈ A z { 〈 x , y 〉 | ph } b ) ;;
	step 3 : wff = df-br () |- ( z { 〈 x , y 〉 | ph } b ↔ 〈 z , b 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 4 : wff = opelopabsb () |- ( 〈 z , b 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. z / x ]. [. b / y ]. ph ) ;;
	step 5 : wff = sbsbc () |- ( [ b / y ] ph ↔ [. b / y ]. ph ) ;;
	step 6 : wff = sbbii (step 5) |- ( [ z / x ] [ b / y ] ph ↔ [ z / x ] [. b / y ]. ph ) ;;
	step 7 : wff = sbsbc () |- ( [ z / x ] [. b / y ]. ph ↔ [. z / x ]. [. b / y ]. ph ) ;;
	step 8 : wff = bitr2i (step 6, step 7) |- ( [. z / x ]. [. b / y ]. ph ↔ [ z / x ] [ b / y ] ph ) ;;
	step 9 : wff = 3bitri (step 3, step 4, step 8) |- ( z { 〈 x , y 〉 | ph } b ↔ [ z / x ] [ b / y ] ph ) ;;
	step 10 : wff = rexbii (step 9) |- ( ∃ z ∈ A z { 〈 x , y 〉 | ph } b ↔ ∃ z ∈ A [ z / x ] [ b / y ] ph ) ;;
	step 11 : wff = nfs1v () |- F/ x [ z / x ] [ b / y ] ph ;;
	step 12 : wff = nfv () |- F/ z [ b / y ] ph ;;
	step 13 : wff = sbequ12r () |- ( z = x → ( [ z / x ] [ b / y ] ph ↔ [ b / y ] ph ) ) ;;
	step 14 : wff = cbvrex (step 11, step 12, step 13) |- ( ∃ z ∈ A [ z / x ] [ b / y ] ph ↔ ∃ x ∈ A [ b / y ] ph ) ;;
	step 15 : wff = 3bitri (step 2, step 10, step 14) |- ( b ∈ ( { 〈 x , y 〉 | ph } " A ) ↔ ∃ x ∈ A [ b / y ] ph ) ;;
	qed prop 1 = step 15 ;;
}

/*Part of a study of the Axiom of Replacement used by the Isabelle
       prover.  In Isabelle, the sethood of PrimReplace is apparently
       postulated implicitly by its type signature " ` [ ` i, ` [ ` i, i ` ] `
       => o ` ] ` => i", which automatically asserts that it is a set without
       using any axioms.  To prove that it is a set in Metamath, we need the
       hypotheses of Isabelle's "Axiom of Replacement" as well as the Axiom of
       Replacement in the form ~ funimaex .  (Contributed by NM,
       26-Oct-2006.) */

theorem isarep2 (ph : wff, x : set, y : set, z : set, w : set, A : class) disjointed(w x y A, x y, y z, w ph, z ph) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ∀ x ∈ A ∀ y ∀ z ( ( ph ∧ [ z / y ] ph ) → y = z ) ;;
	-----------------------
	prop 1 : wff = |- ∃ w w = ( { 〈 x , y 〉 | ph } " A ) ;;
}

proof of isarep2 {
	step 1 : wff = resima () |- ( ( { 〈 x , y 〉 | ph } ↾ A ) " A ) = ( { 〈 x , y 〉 | ph } " A ) ;;
	step 2 : wff = resopab () |- ( { 〈 x , y 〉 | ph } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 3 : wff = imaeq1i (step 2) |- ( ( { 〈 x , y 〉 | ph } ↾ A ) " A ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } " A ) ;;
	step 4 : wff = eqtr3i (step 1, step 3) |- ( { 〈 x , y 〉 | ph } " A ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } " A ) ;;
	step 5 : wff = funopab () |- ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ↔ ∀ x ∃* y ( x ∈ A ∧ ph ) ) ;;
	step 6 : wff = rspec (hyp 2) |- ( x ∈ A → ∀ y ∀ z ( ( ph ∧ [ z / y ] ph ) → y = z ) ) ;;
	step 7 : wff = nfv () |- F/ z ph ;;
	step 8 : wff = mo3 (step 7) |- ( ∃* y ph ↔ ∀ y ∀ z ( ( ph ∧ [ z / y ] ph ) → y = z ) ) ;;
	step 9 : wff = sylibr (step 6, step 8) |- ( x ∈ A → ∃* y ph ) ;;
	step 10 : wff = moanimv () |- ( ∃* y ( x ∈ A ∧ ph ) ↔ ( x ∈ A → ∃* y ph ) ) ;;
	step 11 : wff = mpbir (step 9, step 10) |- ∃* y ( x ∈ A ∧ ph ) ;;
	step 12 : wff = mpgbir (step 5, step 11) |- Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 13 : wff = funimaex (hyp 1) |- ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } → ( { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } " A ) ∈ _V ) ;;
	step 14 : wff = ax-mp (step 12, step 13) |- ( { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } " A ) ∈ _V ;;
	step 15 : wff = eqeltri (step 4, step 14) |- ( { 〈 x , y 〉 | ph } " A ) ∈ _V ;;
	step 16 : wff = isseti (step 15) |- ∃ w w = ( { 〈 x , y 〉 | ph } " A ) ;;
	qed prop 1 = step 16 ;;
}

/*Equality theorem for function predicate with domain.  (Contributed by NM,
     1-Aug-1994.) */

theorem fneq1 (A : class, F : class, G : class)  {
	prop 1 : wff = |- ( F = G → ( F Fn A ↔ G Fn A ) ) ;;
}

proof of fneq1 {
	step 1 : wff = funeq () |- ( F = G → ( Fun F ↔ Fun G ) ) ;;
	step 2 : wff = dmeq () |- ( F = G → dom F = dom G ) ;;
	step 3 : wff = eqeq1d (step 2) |- ( F = G → ( dom F = A ↔ dom G = A ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( F = G → ( ( Fun F ∧ dom F = A ) ↔ ( Fun G ∧ dom G = A ) ) ) ;;
	step 5 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 6 : wff = df-fn () |- ( G Fn A ↔ ( Fun G ∧ dom G = A ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( F = G → ( F Fn A ↔ G Fn A ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for function predicate with domain.  (Contributed by NM,
     1-Aug-1994.) */

theorem fneq2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F Fn A ↔ F Fn B ) ) ;;
}

proof of fneq2 {
	step 1 : wff = eqeq2 () |- ( A = B → ( dom F = A ↔ dom F = B ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( A = B → ( ( Fun F ∧ dom F = A ) ↔ ( Fun F ∧ dom F = B ) ) ) ;;
	step 3 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 4 : wff = df-fn () |- ( F Fn B ↔ ( Fun F ∧ dom F = B ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F Fn A ↔ F Fn B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality deduction for function predicate with domain.  (Contributed by
       Paul Chapman, 22-Jun-2011.) */

theorem fneq1d (ph : wff, A : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F Fn A ↔ G Fn A ) ) ;;
}

proof of fneq1d {
	step 1 : wff = fneq1 () |- ( F = G → ( F Fn A ↔ G Fn A ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F Fn A ↔ G Fn A ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for function predicate with domain.  (Contributed by
       Paul Chapman, 22-Jun-2011.) */

theorem fneq2d (ph : wff, A : class, B : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F Fn A ↔ F Fn B ) ) ;;
}

proof of fneq2d {
	step 1 : wff = fneq2 () |- ( A = B → ( F Fn A ↔ F Fn B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F Fn A ↔ F Fn B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for function predicate with domain.  (Contributed by
       NM, 26-Jun-2011.) */

theorem fneq12d (ph : wff, A : class, B : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F Fn A ↔ G Fn B ) ) ;;
}

proof of fneq12d {
	step 1 : wff = fneq1d (hyp 1) |- ( ph → ( F Fn A ↔ G Fn A ) ) ;;
	step 2 : wff = fneq2d (hyp 2) |- ( ph → ( G Fn A ↔ G Fn B ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( F Fn A ↔ G Fn B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality inference for function predicate with domain.  (Contributed by
       Paul Chapman, 22-Jun-2011.) */

theorem fneq1i (A : class, F : class, G : class)  {
	hyp 1 : wff = |- F = G ;;
	-----------------------
	prop 1 : wff = |- ( F Fn A ↔ G Fn A ) ;;
}

proof of fneq1i {
	step 1 : wff = fneq1 () |- ( F = G → ( F Fn A ↔ G Fn A ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F Fn A ↔ G Fn A ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for function predicate with domain.  (Contributed by
       NM, 4-Sep-2011.) */

theorem fneq2i (A : class, B : class, F : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( F Fn A ↔ F Fn B ) ;;
}

proof of fneq2i {
	step 1 : wff = fneq2 () |- ( A = B → ( F Fn A ↔ F Fn B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F Fn A ↔ F Fn B ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for a function with domain.
       (Contributed by NM, 30-Jan-2004.) */

theorem nffn (x : set, A : class, F : class)  {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x F Fn A ;;
}

proof of nffn {
	step 1 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 2 : wff = nffun (hyp 1) |- F/ x Fun F ;;
	step 3 : wff = nfdm (hyp 1) |- F/_ x dom F ;;
	step 4 : wff = nfeq (step 3, hyp 2) |- F/ x dom F = A ;;
	step 5 : wff = nfan (step 2, step 4) |- F/ x ( Fun F ∧ dom F = A ) ;;
	step 6 : wff = nfxfr (step 1, step 5) |- F/ x F Fn A ;;
	qed prop 1 = step 6 ;;
}

/*A function with domain is a function.  (Contributed by NM, 1-Aug-1994.) */

theorem fnfun (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → Fun F ) ;;
}

proof of fnfun {
	step 1 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( F Fn A → Fun F ) ;;
	qed prop 1 = step 2 ;;
}

/*A function with domain is a relation.  (Contributed by NM, 1-Aug-1994.) */

theorem fnrel (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → Rel F ) ;;
}

proof of fnrel {
	step 1 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 2 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F Fn A → Rel F ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a function.  (Contributed by NM, 2-Aug-1994.) */

theorem fndm (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → dom F = A ) ;;
}

proof of fndm {
	step 1 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( F Fn A → dom F = A ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference to convert a function and domain antecedent.  (Contributed by
       NM, 22-Apr-2004.) */

theorem funfni (ph : wff, A : class, B : class, F : class)  {
	hyp 1 : wff = |- ( ( Fun F ∧ B ∈ dom F ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ph ) ;;
}

proof of funfni {
	step 1 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 2 : wff = adantr (step 1) |- ( ( F Fn A ∧ B ∈ A ) → Fun F ) ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = eleq2d (step 3) |- ( F Fn A → ( B ∈ dom F ↔ B ∈ A ) ) ;;
	step 5 : wff = biimpar (step 4) |- ( ( F Fn A ∧ B ∈ A ) → B ∈ dom F ) ;;
	step 6 : wff = syl2anc (step 2, step 5, hyp 1) |- ( ( F Fn A ∧ B ∈ A ) → ph ) ;;
	qed prop 1 = step 6 ;;
}

/*A function has a unique domain.  (Contributed by NM, 11-Aug-1994.) */

theorem fndmu (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ F Fn B ) → A = B ) ;;
}

proof of fndmu {
	step 1 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 2 : wff = fndm () |- ( F Fn B → dom F = B ) ;;
	step 3 : wff = sylan9req (step 1, step 2) |- ( ( F Fn A ∧ F Fn B ) → A = B ) ;;
	qed prop 1 = step 3 ;;
}

/*The first argument of binary relation on a function belongs to the
     function's domain.  (Contributed by NM, 7-May-2004.) */

theorem fnbr (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ B F C ) → B ∈ A ) ;;
}

proof of fnbr {
	step 1 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 2 : wff = releldm () |- ( ( Rel F ∧ B F C ) → B ∈ dom F ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F Fn A ∧ B F C ) → B ∈ dom F ) ;;
	step 4 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 5 : wff = eleq2d (step 4) |- ( F Fn A → ( B ∈ dom F ↔ B ∈ A ) ) ;;
	step 6 : wff = biimpa (step 5) |- ( ( F Fn A ∧ B ∈ dom F ) → B ∈ A ) ;;
	step 7 : wff = syldan (step 3, step 6) |- ( ( F Fn A ∧ B F C ) → B ∈ A ) ;;
	qed prop 1 = step 7 ;;
}

/*The first argument of an ordered pair in a function belongs to the
     function's domain.  (Contributed by NM, 8-Aug-1994.) */

theorem fnop (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ 〈 B , C 〉 ∈ F ) → B ∈ A ) ;;
}

proof of fnop {
	step 1 : wff = df-br () |- ( B F C ↔ 〈 B , C 〉 ∈ F ) ;;
	step 2 : wff = fnbr () |- ( ( F Fn A ∧ B F C ) → B ∈ A ) ;;
	step 3 : wff = sylan2br (step 1, step 2) |- ( ( F Fn A ∧ 〈 B , C 〉 ∈ F ) → B ∈ A ) ;;
	qed prop 1 = step 3 ;;
}

/*There is exactly one value of a function.  (Contributed by NM,
       22-Apr-2004.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fneu (y : set, A : class, B : class, F : class) disjointed(y F, y B, A) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ∃! y B F y ) ;;
}

proof of fneu {
	step 1 : wff = funmo () |- ( Fun F → ∃* y B F y ) ;;
	step 2 : wff = adantr (step 1) |- ( ( Fun F ∧ B ∈ dom F ) → ∃* y B F y ) ;;
	step 3 : wff = eldmg () |- ( B ∈ dom F → ( B ∈ dom F ↔ ∃ y B F y ) ) ;;
	step 4 : wff = ibi (step 3) |- ( B ∈ dom F → ∃ y B F y ) ;;
	step 5 : wff = adantl (step 4) |- ( ( Fun F ∧ B ∈ dom F ) → ∃ y B F y ) ;;
	step 6 : wff = exmoeu2 () |- ( ∃ y B F y → ( ∃* y B F y ↔ ∃! y B F y ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ( Fun F ∧ B ∈ dom F ) → ( ∃* y B F y ↔ ∃! y B F y ) ) ;;
	step 8 : wff = mpbid (step 2, step 7) |- ( ( Fun F ∧ B ∈ dom F ) → ∃! y B F y ) ;;
	step 9 : wff = funfni (step 8) |- ( ( F Fn A ∧ B ∈ A ) → ∃! y B F y ) ;;
	qed prop 1 = step 9 ;;
}

/*There is exactly one value of a function.  (Contributed by NM,
       7-Nov-1995.) */

theorem fneu2 (y : set, A : class, B : class, F : class) disjointed(y F, y B, A) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ∃! y 〈 B , y 〉 ∈ F ) ;;
}

proof of fneu2 {
	step 1 : wff = fneu () |- ( ( F Fn A ∧ B ∈ A ) → ∃! y B F y ) ;;
	step 2 : wff = df-br () |- ( B F y ↔ 〈 B , y 〉 ∈ F ) ;;
	step 3 : wff = eubii (step 2) |- ( ∃! y B F y ↔ ∃! y 〈 B , y 〉 ∈ F ) ;;
	step 4 : wff = sylib (step 1, step 3) |- ( ( F Fn A ∧ B ∈ A ) → ∃! y 〈 B , y 〉 ∈ F ) ;;
	qed prop 1 = step 4 ;;
}

/*The union of two functions with disjoint domains.  (Contributed by NM,
     22-Sep-2004.) */

theorem fnun (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( F Fn A ∧ G Fn B ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ B ) ) ;;
}

proof of fnun {
	step 1 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 2 : wff = df-fn () |- ( G Fn B ↔ ( Fun G ∧ dom G = B ) ) ;;
	step 3 : wff = ineq12 () |- ( ( dom F = A ∧ dom G = B ) → ( dom F ∩ dom G ) = ( A ∩ B ) ) ;;
	step 4 : wff = eqeq1d (step 3) |- ( ( dom F = A ∧ dom G = B ) → ( ( dom F ∩ dom G ) = ∅ ↔ ( A ∩ B ) = ∅ ) ) ;;
	step 5 : wff = anbi2d (step 4) |- ( ( dom F = A ∧ dom G = B ) → ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) ↔ ( ( Fun F ∧ Fun G ) ∧ ( A ∩ B ) = ∅ ) ) ) ;;
	step 6 : wff = funun () |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → Fun ( F ∪ G ) ) ;;
	step 7 : wff = syl6bir (step 5, step 6) |- ( ( dom F = A ∧ dom G = B ) → ( ( ( Fun F ∧ Fun G ) ∧ ( A ∩ B ) = ∅ ) → Fun ( F ∪ G ) ) ) ;;
	step 8 : wff = dmun () |- dom ( F ∪ G ) = ( dom F ∪ dom G ) ;;
	step 9 : wff = uneq12 () |- ( ( dom F = A ∧ dom G = B ) → ( dom F ∪ dom G ) = ( A ∪ B ) ) ;;
	step 10 : wff = syl5eq (step 8, step 9) |- ( ( dom F = A ∧ dom G = B ) → dom ( F ∪ G ) = ( A ∪ B ) ) ;;
	step 11 : wff = jctird (step 7, step 10) |- ( ( dom F = A ∧ dom G = B ) → ( ( ( Fun F ∧ Fun G ) ∧ ( A ∩ B ) = ∅ ) → ( Fun ( F ∪ G ) ∧ dom ( F ∪ G ) = ( A ∪ B ) ) ) ) ;;
	step 12 : wff = df-fn () |- ( ( F ∪ G ) Fn ( A ∪ B ) ↔ ( Fun ( F ∪ G ) ∧ dom ( F ∪ G ) = ( A ∪ B ) ) ) ;;
	step 13 : wff = syl6ibr (step 11, step 12) |- ( ( dom F = A ∧ dom G = B ) → ( ( ( Fun F ∧ Fun G ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ B ) ) ) ;;
	step 14 : wff = exp3a (step 13) |- ( ( dom F = A ∧ dom G = B ) → ( ( Fun F ∧ Fun G ) → ( ( A ∩ B ) = ∅ → ( F ∪ G ) Fn ( A ∪ B ) ) ) ) ;;
	step 15 : wff = impcom (step 14) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F = A ∧ dom G = B ) ) → ( ( A ∩ B ) = ∅ → ( F ∪ G ) Fn ( A ∪ B ) ) ) ;;
	step 16 : wff = an4s (step 15) |- ( ( ( Fun F ∧ dom F = A ) ∧ ( Fun G ∧ dom G = B ) ) → ( ( A ∩ B ) = ∅ → ( F ∪ G ) Fn ( A ∪ B ) ) ) ;;
	step 17 : wff = syl2anb (step 1, step 2, step 16) |- ( ( F Fn A ∧ G Fn B ) → ( ( A ∩ B ) = ∅ → ( F ∪ G ) Fn ( A ∪ B ) ) ) ;;
	step 18 : wff = imp (step 17) |- ( ( ( F Fn A ∧ G Fn B ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ B ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Extension of a function with a new ordered pair.  (Contributed by NM,
       28-Sep-2013.)  (Revised by Mario Carneiro, 30-Apr-2015.) */

theorem fnunsn (ph : wff, D : class, E : class, F : class, G : class, X : class, Y : class)  {
	hyp 1 : wff = |- ( ph → X ∈ _V ) ;;
	hyp 2 : wff = |- ( ph → Y ∈ _V ) ;;
	hyp 3 : wff = |- ( ph → F Fn D ) ;;
	hyp 4 : wff = |- G = ( F ∪ { 〈 X , Y 〉 } ) ;;
	hyp 5 : wff = |- E = ( D ∪ { X } ) ;;
	hyp 6 : wff = |- ( ph → ¬ X ∈ D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → G Fn E ) ;;
}

proof of fnunsn {
	step 1 : wff = fnsng () |- ( ( X ∈ _V ∧ Y ∈ _V ) → { 〈 X , Y 〉 } Fn { X } ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → { 〈 X , Y 〉 } Fn { X } ) ;;
	step 3 : wff = disjsn () |- ( ( D ∩ { X } ) = ∅ ↔ ¬ X ∈ D ) ;;
	step 4 : wff = sylibr (hyp 6, step 3) |- ( ph → ( D ∩ { X } ) = ∅ ) ;;
	step 5 : wff = fnun () |- ( ( ( F Fn D ∧ { 〈 X , Y 〉 } Fn { X } ) ∧ ( D ∩ { X } ) = ∅ ) → ( F ∪ { 〈 X , Y 〉 } ) Fn ( D ∪ { X } ) ) ;;
	step 6 : wff = syl21anc (hyp 3, step 2, step 4, step 5) |- ( ph → ( F ∪ { 〈 X , Y 〉 } ) Fn ( D ∪ { X } ) ) ;;
	step 7 : wff = fneq1i (hyp 4) |- ( G Fn E ↔ ( F ∪ { 〈 X , Y 〉 } ) Fn E ) ;;
	step 8 : wff = fneq2i (hyp 5) |- ( ( F ∪ { 〈 X , Y 〉 } ) Fn E ↔ ( F ∪ { 〈 X , Y 〉 } ) Fn ( D ∪ { X } ) ) ;;
	step 9 : wff = bitri (step 7, step 8) |- ( G Fn E ↔ ( F ∪ { 〈 X , Y 〉 } ) Fn ( D ∪ { X } ) ) ;;
	step 10 : wff = sylibr (step 6, step 9) |- ( ph → G Fn E ) ;;
	qed prop 1 = step 10 ;;
}

/*Composition of two functions.  (Contributed by NM, 22-May-2006.) */

theorem fnco (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → ( F ∘ G ) Fn B ) ;;
}

proof of fnco {
	step 1 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 2 : wff = fnfun () |- ( G Fn B → Fun G ) ;;
	step 3 : wff = funco () |- ( ( Fun F ∧ Fun G ) → Fun ( F ∘ G ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( F Fn A ∧ G Fn B ) → Fun ( F ∘ G ) ) ;;
	step 5 : wff = 3adant3 (step 4) |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → Fun ( F ∘ G ) ) ;;
	step 6 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 7 : wff = sseq2d (step 6) |- ( F Fn A → ( ran G ⊆ dom F ↔ ran G ⊆ A ) ) ;;
	step 8 : wff = biimpar (step 7) |- ( ( F Fn A ∧ ran G ⊆ A ) → ran G ⊆ dom F ) ;;
	step 9 : wff = dmcosseq () |- ( ran G ⊆ dom F → dom ( F ∘ G ) = dom G ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ( F Fn A ∧ ran G ⊆ A ) → dom ( F ∘ G ) = dom G ) ;;
	step 11 : wff = 3adant2 (step 10) |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → dom ( F ∘ G ) = dom G ) ;;
	step 12 : wff = fndm () |- ( G Fn B → dom G = B ) ;;
	step 13 : wff = 3ad2ant2 (step 12) |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → dom G = B ) ;;
	step 14 : wff = eqtrd (step 11, step 13) |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → dom ( F ∘ G ) = B ) ;;
	step 15 : wff = df-fn () |- ( ( F ∘ G ) Fn B ↔ ( Fun ( F ∘ G ) ∧ dom ( F ∘ G ) = B ) ) ;;
	step 16 : wff = sylanbrc (step 5, step 14, step 15) |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → ( F ∘ G ) Fn B ) ;;
	qed prop 1 = step 16 ;;
}

/*A function does not change when restricted to its domain.  (Contributed by
     NM, 5-Sep-2004.) */

theorem fnresdm (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( F ↾ A ) = F ) ;;
}

proof of fnresdm {
	step 1 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 2 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 3 : wff = eqimss () |- ( dom F = A → dom F ⊆ A ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( F Fn A → dom F ⊆ A ) ;;
	step 5 : wff = relssres () |- ( ( Rel F ∧ dom F ⊆ A ) → ( F ↾ A ) = F ) ;;
	step 6 : wff = syl2anc (step 1, step 4, step 5) |- ( F Fn A → ( F ↾ A ) = F ) ;;
	qed prop 1 = step 6 ;;
}

/*A function restricted to a class disjoint with its domain is empty.
     (Contributed by NM, 23-Sep-2004.) */

theorem fnresdisj (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( ( A ∩ B ) = ∅ ↔ ( F ↾ B ) = ∅ ) ) ;;
}

proof of fnresdisj {
	step 1 : wff = relres () |- Rel ( F ↾ B ) ;;
	step 2 : wff = reldm0 () |- ( Rel ( F ↾ B ) → ( ( F ↾ B ) = ∅ ↔ dom ( F ↾ B ) = ∅ ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( ( F ↾ B ) = ∅ ↔ dom ( F ↾ B ) = ∅ ) ;;
	step 4 : wff = dmres () |- dom ( F ↾ B ) = ( B ∩ dom F ) ;;
	step 5 : wff = incom () |- ( B ∩ dom F ) = ( dom F ∩ B ) ;;
	step 6 : wff = eqtri (step 4, step 5) |- dom ( F ↾ B ) = ( dom F ∩ B ) ;;
	step 7 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 8 : wff = ineq1d (step 7) |- ( F Fn A → ( dom F ∩ B ) = ( A ∩ B ) ) ;;
	step 9 : wff = syl5eq (step 6, step 8) |- ( F Fn A → dom ( F ↾ B ) = ( A ∩ B ) ) ;;
	step 10 : wff = eqeq1d (step 9) |- ( F Fn A → ( dom ( F ↾ B ) = ∅ ↔ ( A ∩ B ) = ∅ ) ) ;;
	step 11 : wff = syl5rbb (step 3, step 10) |- ( F Fn A → ( ( A ∩ B ) = ∅ ↔ ( F ↾ B ) = ∅ ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Membership in two functions restricted by each other's domain.
     (Contributed by NM, 8-Aug-1994.) */

theorem 2elresin (x : set, y : set, z : set, A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ↔ ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ) ) ;;
}

proof of 2elresin {
	step 1 : wff = fnop () |- ( ( F Fn A ∧ 〈 x , y 〉 ∈ F ) → x ∈ A ) ;;
	step 2 : wff = fnop () |- ( ( G Fn B ∧ 〈 x , z 〉 ∈ G ) → x ∈ B ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( ( F Fn A ∧ 〈 x , y 〉 ∈ F ) ∧ ( G Fn B ∧ 〈 x , z 〉 ∈ G ) ) → ( x ∈ A ∧ x ∈ B ) ) ;;
	step 4 : wff = an4s (step 3) |- ( ( ( F Fn A ∧ G Fn B ) ∧ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) → ( x ∈ A ∧ x ∈ B ) ) ;;
	step 5 : wff = elin () |- ( x ∈ ( A ∩ B ) ↔ ( x ∈ A ∧ x ∈ B ) ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ( ( F Fn A ∧ G Fn B ) ∧ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) → x ∈ ( A ∩ B ) ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = opres (step 7) |- ( x ∈ ( A ∩ B ) → ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ↔ 〈 x , y 〉 ∈ F ) ) ;;
	step 9 : wff = vex () |- z ∈ _V ;;
	step 10 : wff = opres (step 9) |- ( x ∈ ( A ∩ B ) → ( 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ↔ 〈 x , z 〉 ∈ G ) ) ;;
	step 11 : wff = anbi12d (step 8, step 10) |- ( x ∈ ( A ∩ B ) → ( ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ↔ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ) ;;
	step 12 : wff = biimprd (step 11) |- ( x ∈ ( A ∩ B ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ) ) ;;
	step 13 : wff = syl (step 6, step 12) |- ( ( ( F Fn A ∧ G Fn B ) ∧ ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ) ) ;;
	step 14 : wff = ex (step 13) |- ( ( F Fn A ∧ G Fn B ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ) ) ) ;;
	step 15 : wff = pm2.43d (step 14) |- ( ( F Fn A ∧ G Fn B ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) → ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ) ) ;;
	step 16 : wff = resss () |- ( F ↾ ( A ∩ B ) ) ⊆ F ;;
	step 17 : wff = sseli (step 16) |- ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) → 〈 x , y 〉 ∈ F ) ;;
	step 18 : wff = resss () |- ( G ↾ ( A ∩ B ) ) ⊆ G ;;
	step 19 : wff = sseli (step 18) |- ( 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) → 〈 x , z 〉 ∈ G ) ;;
	step 20 : wff = anim12i (step 17, step 19) |- ( ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) → ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ) ;;
	step 21 : wff = impbid1 (step 15, step 20) |- ( ( F Fn A ∧ G Fn B ) → ( ( 〈 x , y 〉 ∈ F ∧ 〈 x , z 〉 ∈ G ) ↔ ( 〈 x , y 〉 ∈ ( F ↾ ( A ∩ B ) ) ∧ 〈 x , z 〉 ∈ ( G ↾ ( A ∩ B ) ) ) ) ) ;;
	qed prop 1 = step 21 ;;
}

/*Restriction of a function with a subclass of its domain.  (Contributed by
     NM, 10-Oct-2007.) */

theorem fnssresb (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( ( F ↾ B ) Fn B ↔ B ⊆ A ) ) ;;
}

proof of fnssresb {
	step 1 : wff = df-fn () |- ( ( F ↾ B ) Fn B ↔ ( Fun ( F ↾ B ) ∧ dom ( F ↾ B ) = B ) ) ;;
	step 2 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 3 : wff = funres () |- ( Fun F → Fun ( F ↾ B ) ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( F Fn A → Fun ( F ↾ B ) ) ;;
	step 5 : wff = biantrurd (step 4) |- ( F Fn A → ( dom ( F ↾ B ) = B ↔ ( Fun ( F ↾ B ) ∧ dom ( F ↾ B ) = B ) ) ) ;;
	step 6 : wff = ssdmres () |- ( B ⊆ dom F ↔ dom ( F ↾ B ) = B ) ;;
	step 7 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 8 : wff = sseq2d (step 7) |- ( F Fn A → ( B ⊆ dom F ↔ B ⊆ A ) ) ;;
	step 9 : wff = syl5bbr (step 6, step 8) |- ( F Fn A → ( dom ( F ↾ B ) = B ↔ B ⊆ A ) ) ;;
	step 10 : wff = bitr3d (step 5, step 9) |- ( F Fn A → ( ( Fun ( F ↾ B ) ∧ dom ( F ↾ B ) = B ) ↔ B ⊆ A ) ) ;;
	step 11 : wff = syl5bb (step 1, step 10) |- ( F Fn A → ( ( F ↾ B ) Fn B ↔ B ⊆ A ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Restriction of a function with a subclass of its domain.  (Contributed by
     NM, 2-Aug-1994.) */

theorem fnssres (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ B ⊆ A ) → ( F ↾ B ) Fn B ) ;;
}

proof of fnssres {
	step 1 : wff = fnssresb () |- ( F Fn A → ( ( F ↾ B ) Fn B ↔ B ⊆ A ) ) ;;
	step 2 : wff = biimpar (step 1) |- ( ( F Fn A ∧ B ⊆ A ) → ( F ↾ B ) Fn B ) ;;
	qed prop 1 = step 2 ;;
}

/*Restriction of a function's domain with an intersection.  (Contributed by
     NM, 9-Aug-1994.) */

theorem fnresin1 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( F ↾ ( A ∩ B ) ) Fn ( A ∩ B ) ) ;;
}

proof of fnresin1 {
	step 1 : wff = inss1 () |- ( A ∩ B ) ⊆ A ;;
	step 2 : wff = fnssres () |- ( ( F Fn A ∧ ( A ∩ B ) ⊆ A ) → ( F ↾ ( A ∩ B ) ) Fn ( A ∩ B ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( F Fn A → ( F ↾ ( A ∩ B ) ) Fn ( A ∩ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Restriction of a function's domain with an intersection.  (Contributed by
     NM, 9-Aug-1994.) */

theorem fnresin2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( F ↾ ( B ∩ A ) ) Fn ( B ∩ A ) ) ;;
}

proof of fnresin2 {
	step 1 : wff = inss2 () |- ( B ∩ A ) ⊆ A ;;
	step 2 : wff = fnssres () |- ( ( F Fn A ∧ ( B ∩ A ) ⊆ A ) → ( F ↾ ( B ∩ A ) ) Fn ( B ∩ A ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( F Fn A → ( F ↾ ( B ∩ A ) ) Fn ( B ∩ A ) ) ;;
	qed prop 1 = step 3 ;;
}

/*An equivalence for functionality of a restriction.  Compare ~ dffun8 .
       (Contributed by Mario Carneiro, 20-May-2015.) */

theorem fnres (x : set, y : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( ( F ↾ A ) Fn A ↔ ∀ x ∈ A ∃! y x F y ) ;;
}

proof of fnres {
	step 1 : wff = ancom () |- ( ( ∀ x ∈ A ∃* y x F y ∧ ∀ x ∈ A ∃ y x F y ) ↔ ( ∀ x ∈ A ∃ y x F y ∧ ∀ x ∈ A ∃* y x F y ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = brres (step 2) |- ( x ( F ↾ A ) y ↔ ( x F y ∧ x ∈ A ) ) ;;
	step 4 : wff = ancom () |- ( ( x F y ∧ x ∈ A ) ↔ ( x ∈ A ∧ x F y ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( x ( F ↾ A ) y ↔ ( x ∈ A ∧ x F y ) ) ;;
	step 6 : wff = mobii (step 5) |- ( ∃* y x ( F ↾ A ) y ↔ ∃* y ( x ∈ A ∧ x F y ) ) ;;
	step 7 : wff = moanimv () |- ( ∃* y ( x ∈ A ∧ x F y ) ↔ ( x ∈ A → ∃* y x F y ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ∃* y x ( F ↾ A ) y ↔ ( x ∈ A → ∃* y x F y ) ) ;;
	step 9 : wff = albii (step 8) |- ( ∀ x ∃* y x ( F ↾ A ) y ↔ ∀ x ( x ∈ A → ∃* y x F y ) ) ;;
	step 10 : wff = relres () |- Rel ( F ↾ A ) ;;
	step 11 : wff = dffun6 () |- ( Fun ( F ↾ A ) ↔ ( Rel ( F ↾ A ) ∧ ∀ x ∃* y x ( F ↾ A ) y ) ) ;;
	step 12 : wff = mpbiran (step 10, step 11) |- ( Fun ( F ↾ A ) ↔ ∀ x ∃* y x ( F ↾ A ) y ) ;;
	step 13 : wff = df-ral () |- ( ∀ x ∈ A ∃* y x F y ↔ ∀ x ( x ∈ A → ∃* y x F y ) ) ;;
	step 14 : wff = 3bitr4i (step 9, step 12, step 13) |- ( Fun ( F ↾ A ) ↔ ∀ x ∈ A ∃* y x F y ) ;;
	step 15 : wff = dmres () |- dom ( F ↾ A ) = ( A ∩ dom F ) ;;
	step 16 : wff = inss1 () |- ( A ∩ dom F ) ⊆ A ;;
	step 17 : wff = eqsstri (step 15, step 16) |- dom ( F ↾ A ) ⊆ A ;;
	step 18 : wff = eqss () |- ( dom ( F ↾ A ) = A ↔ ( dom ( F ↾ A ) ⊆ A ∧ A ⊆ dom ( F ↾ A ) ) ) ;;
	step 19 : wff = mpbiran (step 17, step 18) |- ( dom ( F ↾ A ) = A ↔ A ⊆ dom ( F ↾ A ) ) ;;
	step 20 : wff = dfss3 () |- ( A ⊆ dom ( F ↾ A ) ↔ ∀ x ∈ A x ∈ dom ( F ↾ A ) ) ;;
	step 21 : wff = dmres () |- dom ( F ↾ A ) = ( A ∩ dom F ) ;;
	step 22 : wff = elin2 (step 21) |- ( x ∈ dom ( F ↾ A ) ↔ ( x ∈ A ∧ x ∈ dom F ) ) ;;
	step 23 : wff = baib (step 22) |- ( x ∈ A → ( x ∈ dom ( F ↾ A ) ↔ x ∈ dom F ) ) ;;
	step 24 : wff = vex () |- x ∈ _V ;;
	step 25 : wff = eldm (step 24) |- ( x ∈ dom F ↔ ∃ y x F y ) ;;
	step 26 : wff = syl6bb (step 23, step 25) |- ( x ∈ A → ( x ∈ dom ( F ↾ A ) ↔ ∃ y x F y ) ) ;;
	step 27 : wff = ralbiia (step 26) |- ( ∀ x ∈ A x ∈ dom ( F ↾ A ) ↔ ∀ x ∈ A ∃ y x F y ) ;;
	step 28 : wff = bitri (step 20, step 27) |- ( A ⊆ dom ( F ↾ A ) ↔ ∀ x ∈ A ∃ y x F y ) ;;
	step 29 : wff = bitri (step 19, step 28) |- ( dom ( F ↾ A ) = A ↔ ∀ x ∈ A ∃ y x F y ) ;;
	step 30 : wff = anbi12i (step 14, step 29) |- ( ( Fun ( F ↾ A ) ∧ dom ( F ↾ A ) = A ) ↔ ( ∀ x ∈ A ∃* y x F y ∧ ∀ x ∈ A ∃ y x F y ) ) ;;
	step 31 : wff = r19.26 () |- ( ∀ x ∈ A ( ∃ y x F y ∧ ∃* y x F y ) ↔ ( ∀ x ∈ A ∃ y x F y ∧ ∀ x ∈ A ∃* y x F y ) ) ;;
	step 32 : wff = 3bitr4i (step 1, step 30, step 31) |- ( ( Fun ( F ↾ A ) ∧ dom ( F ↾ A ) = A ) ↔ ∀ x ∈ A ( ∃ y x F y ∧ ∃* y x F y ) ) ;;
	step 33 : wff = df-fn () |- ( ( F ↾ A ) Fn A ↔ ( Fun ( F ↾ A ) ∧ dom ( F ↾ A ) = A ) ) ;;
	step 34 : wff = eu5 () |- ( ∃! y x F y ↔ ( ∃ y x F y ∧ ∃* y x F y ) ) ;;
	step 35 : wff = ralbii (step 34) |- ( ∀ x ∈ A ∃! y x F y ↔ ∀ x ∈ A ( ∃ y x F y ∧ ∃* y x F y ) ) ;;
	step 36 : wff = 3bitr4i (step 32, step 33, step 35) |- ( ( F ↾ A ) Fn A ↔ ∀ x ∈ A ∃! y x F y ) ;;
	qed prop 1 = step 36 ;;
}

/*Functionality and domain of restricted identity.  (Contributed by NM,
     27-Aug-2004.) */

theorem fnresi (A : class)  {
	prop 1 : wff = |- ( _I ↾ A ) Fn A ;;
}

proof of fnresi {
	step 1 : wff = funi () |- Fun _I ;;
	step 2 : wff = funres () |- ( Fun _I → Fun ( _I ↾ A ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- Fun ( _I ↾ A ) ;;
	step 4 : wff = dmresi () |- dom ( _I ↾ A ) = A ;;
	step 5 : wff = df-fn () |- ( ( _I ↾ A ) Fn A ↔ ( Fun ( _I ↾ A ) ∧ dom ( _I ↾ A ) = A ) ) ;;
	step 6 : wff = mpbir2an (step 3, step 4, step 5) |- ( _I ↾ A ) Fn A ;;
	qed prop 1 = step 6 ;;
}

/*The image of a function's domain is its range.  (Contributed by NM,
     4-Nov-2004.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fnima (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( F " A ) = ran F ) ;;
}

proof of fnima {
	step 1 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 2 : wff = fnresdm () |- ( F Fn A → ( F ↾ A ) = F ) ;;
	step 3 : wff = rneqd (step 2) |- ( F Fn A → ran ( F ↾ A ) = ran F ) ;;
	step 4 : wff = syl5eq (step 1, step 3) |- ( F Fn A → ( F " A ) = ran F ) ;;
	qed prop 1 = step 4 ;;
}

/*A function with empty domain is empty.  (Contributed by NM,
       15-Apr-1998.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fn0 (F : class) disjointed(F) {
	prop 1 : wff = |- ( F Fn ∅ ↔ F = ∅ ) ;;
}

proof of fn0 {
	step 1 : wff = fnrel () |- ( F Fn ∅ → Rel F ) ;;
	step 2 : wff = fndm () |- ( F Fn ∅ → dom F = ∅ ) ;;
	step 3 : wff = reldm0 () |- ( Rel F → ( F = ∅ ↔ dom F = ∅ ) ) ;;
	step 4 : wff = biimpar (step 3) |- ( ( Rel F ∧ dom F = ∅ ) → F = ∅ ) ;;
	step 5 : wff = syl2anc (step 1, step 2, step 4) |- ( F Fn ∅ → F = ∅ ) ;;
	step 6 : wff = fun0 () |- Fun ∅ ;;
	step 7 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 8 : wff = df-fn () |- ( ∅ Fn ∅ ↔ ( Fun ∅ ∧ dom ∅ = ∅ ) ) ;;
	step 9 : wff = mpbir2an (step 6, step 7, step 8) |- ∅ Fn ∅ ;;
	step 10 : wff = fneq1 () |- ( F = ∅ → ( F Fn ∅ ↔ ∅ Fn ∅ ) ) ;;
	step 11 : wff = mpbiri (step 9, step 10) |- ( F = ∅ → F Fn ∅ ) ;;
	step 12 : wff = impbii (step 5, step 11) |- ( F Fn ∅ ↔ F = ∅ ) ;;
	qed prop 1 = step 12 ;;
}

/*A class that is disjoint with the domain of a function has an empty image
     under the function.  (Contributed by FL, 24-Jan-2007.) */

theorem fnimadisj (A : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ ( A ∩ C ) = ∅ ) → ( F " C ) = ∅ ) ;;
}

proof of fnimadisj {
	step 1 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 2 : wff = ineq1d (step 1) |- ( F Fn A → ( dom F ∩ C ) = ( A ∩ C ) ) ;;
	step 3 : wff = eqeq1d (step 2) |- ( F Fn A → ( ( dom F ∩ C ) = ∅ ↔ ( A ∩ C ) = ∅ ) ) ;;
	step 4 : wff = biimpar (step 3) |- ( ( F Fn A ∧ ( A ∩ C ) = ∅ ) → ( dom F ∩ C ) = ∅ ) ;;
	step 5 : wff = imadisj () |- ( ( F " C ) = ∅ ↔ ( dom F ∩ C ) = ∅ ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ( F Fn A ∧ ( A ∩ C ) = ∅ ) → ( F " C ) = ∅ ) ;;
	qed prop 1 = step 6 ;;
}

/*Images under a function never map nonempty sets to empty sets.
     _EDITORIAL_: usable in ~ fnwe2lem2 .  (Contributed by Stefan O'Rear,
     21-Jan-2015.) */

theorem fnimaeq0 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ B ⊆ A ) → ( ( F " B ) = ∅ ↔ B = ∅ ) ) ;;
}

proof of fnimaeq0 {
	step 1 : wff = imadisj () |- ( ( F " B ) = ∅ ↔ ( dom F ∩ B ) = ∅ ) ;;
	step 2 : wff = incom () |- ( dom F ∩ B ) = ( B ∩ dom F ) ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = sseq2d (step 3) |- ( F Fn A → ( B ⊆ dom F ↔ B ⊆ A ) ) ;;
	step 5 : wff = biimpar (step 4) |- ( ( F Fn A ∧ B ⊆ A ) → B ⊆ dom F ) ;;
	step 6 : wff = df-ss () |- ( B ⊆ dom F ↔ ( B ∩ dom F ) = B ) ;;
	step 7 : wff = sylib (step 5, step 6) |- ( ( F Fn A ∧ B ⊆ A ) → ( B ∩ dom F ) = B ) ;;
	step 8 : wff = syl5eq (step 2, step 7) |- ( ( F Fn A ∧ B ⊆ A ) → ( dom F ∩ B ) = B ) ;;
	step 9 : wff = eqeq1d (step 8) |- ( ( F Fn A ∧ B ⊆ A ) → ( ( dom F ∩ B ) = ∅ ↔ B = ∅ ) ) ;;
	step 10 : wff = syl5bb (step 1, step 9) |- ( ( F Fn A ∧ B ⊆ A ) → ( ( F " B ) = ∅ ↔ B = ∅ ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Alternate definition for the "maps to" notation ~ df-mpt .  (Contributed
       by Mario Carneiro, 30-Dec-2016.) */

theorem dfmpt3 (x : set, A : class, B : class) disjointed(y z A, y z B, x y z) {
	prop 1 : wff = |- ( x ∈ A ↦ B ) = ⋃_ x ∈ A ( { x } × { B } ) ;;
}

proof of dfmpt3 {
	var y : set, z : set;;
	step 1 : wff = df-mpt () |- ( x ∈ A ↦ B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 2 : wff = elsn () |- ( y ∈ { B } ↔ y = B ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( x ∈ A ∧ y ∈ { B } ) ↔ ( x ∈ A ∧ y = B ) ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ { B } ) ) ↔ ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y = B ) ) ) ;;
	step 5 : wff = 2exbii (step 4) |- ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ { B } ) ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y = B ) ) ) ;;
	step 6 : wff = eliunxp () |- ( z ∈ ⋃_ x ∈ A ( { x } × { B } ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ { B } ) ) ) ;;
	step 7 : wff = elopab () |- ( z ∈ { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y = B ) ) ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( z ∈ ⋃_ x ∈ A ( { x } × { B } ) ↔ z ∈ { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ) ;;
	step 9 : wff = eqriv (step 8) |- ⋃_ x ∈ A ( { x } × { B } ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 10 : wff = eqtr4i (step 1, step 9) |- ( x ∈ A ↦ B ) = ⋃_ x ∈ A ( { x } × { B } ) ;;
	qed prop 1 = step 10 ;;
}

/*Functionality and domain of an ordered-pair class abstraction.
       (Contributed by NM, 30-Jan-2004.)  (Proof shortened by Mario Carneiro,
       4-Dec-2016.) */

theorem fnopabg (ph : wff, x : set, y : set, A : class, F : class) disjointed(x y A, F, x y) {
	hyp 1 : wff = |- F = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∃! y ph ↔ F Fn A ) ;;
}

proof of fnopabg {
	step 1 : wff = moanimv () |- ( ∃* y ( x ∈ A ∧ ph ) ↔ ( x ∈ A → ∃* y ph ) ) ;;
	step 2 : wff = albii (step 1) |- ( ∀ x ∃* y ( x ∈ A ∧ ph ) ↔ ∀ x ( x ∈ A → ∃* y ph ) ) ;;
	step 3 : wff = funopab () |- ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ↔ ∀ x ∃* y ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = df-ral () |- ( ∀ x ∈ A ∃* y ph ↔ ∀ x ( x ∈ A → ∃* y ph ) ) ;;
	step 5 : wff = 3bitr4ri (step 2, step 3, step 4) |- ( ∀ x ∈ A ∃* y ph ↔ Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ) ;;
	step 6 : wff = dmopab3 () |- ( ∀ x ∈ A ∃ y ph ↔ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ) ;;
	step 7 : wff = anbi12i (step 5, step 6) |- ( ( ∀ x ∈ A ∃* y ph ∧ ∀ x ∈ A ∃ y ph ) ↔ ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∧ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ) ) ;;
	step 8 : wff = r19.26 () |- ( ∀ x ∈ A ( ∃* y ph ∧ ∃ y ph ) ↔ ( ∀ x ∈ A ∃* y ph ∧ ∀ x ∈ A ∃ y ph ) ) ;;
	step 9 : wff = df-fn () |- ( { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } Fn A ↔ ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∧ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ) ) ;;
	step 10 : wff = 3bitr4i (step 7, step 8, step 9) |- ( ∀ x ∈ A ( ∃* y ph ∧ ∃ y ph ) ↔ { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } Fn A ) ;;
	step 11 : wff = eu5 () |- ( ∃! y ph ↔ ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 12 : wff = ancom () |- ( ( ∃ y ph ∧ ∃* y ph ) ↔ ( ∃* y ph ∧ ∃ y ph ) ) ;;
	step 13 : wff = bitri (step 11, step 12) |- ( ∃! y ph ↔ ( ∃* y ph ∧ ∃ y ph ) ) ;;
	step 14 : wff = ralbii (step 13) |- ( ∀ x ∈ A ∃! y ph ↔ ∀ x ∈ A ( ∃* y ph ∧ ∃ y ph ) ) ;;
	step 15 : wff = fneq1i (hyp 1) |- ( F Fn A ↔ { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } Fn A ) ;;
	step 16 : wff = 3bitr4i (step 10, step 14, step 15) |- ( ∀ x ∈ A ∃! y ph ↔ F Fn A ) ;;
	qed prop 1 = step 16 ;;
}

/*Functionality and domain of an ordered-pair class abstraction.
       (Contributed by NM, 5-Mar-1996.) */

theorem fnopab (ph : wff, x : set, y : set, A : class, F : class) disjointed(x y A) {
	hyp 1 : wff = |- ( x ∈ A → ∃! y ph ) ;;
	hyp 2 : wff = |- F = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- F Fn A ;;
}

proof of fnopab {
	step 1 : wff = rgen (hyp 1) |- ∀ x ∈ A ∃! y ph ;;
	step 2 : wff = fnopabg (hyp 2) |- ( ∀ x ∈ A ∃! y ph ↔ F Fn A ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- F Fn A ;;
	qed prop 1 = step 3 ;;
}

/*The maps-to notation defines a function with domain.  (Contributed by
       Scott Fenton, 21-Mar-2011.) */

theorem mptfng (x : set, A : class, B : class, F : class) disjointed(x y A, y B) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ _V ↔ F Fn A ) ;;
}

proof of mptfng {
	var y : set;;
	step 1 : wff = eueq () |- ( B ∈ _V ↔ ∃! y y = B ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A B ∈ _V ↔ ∀ x ∈ A ∃! y y = B ) ;;
	step 3 : wff = df-mpt () |- ( x ∈ A ↦ B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 4 : wff = eqtri (hyp 1, step 3) |- F = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 5 : wff = fnopabg (step 4) |- ( ∀ x ∈ A ∃! y y = B ↔ F Fn A ) ;;
	step 6 : wff = bitri (step 2, step 5) |- ( ∀ x ∈ A B ∈ _V ↔ F Fn A ) ;;
	qed prop 1 = step 6 ;;
}

/*The maps-to notation defines a function with domain.  (Contributed by
       NM, 9-Apr-2013.) */

theorem fnmpt (x : set, A : class, B : class, F : class, V : class) disjointed(x A, B) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ V → F Fn A ) ;;
}

proof of fnmpt {
	step 1 : wff = elex () |- ( B ∈ V → B ∈ _V ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ x ∈ A B ∈ V → ∀ x ∈ A B ∈ _V ) ;;
	step 3 : wff = mptfng (hyp 1) |- ( ∀ x ∈ A B ∈ _V ↔ F Fn A ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( ∀ x ∈ A B ∈ V → F Fn A ) ;;
	qed prop 1 = step 4 ;;
}

/*A mapping operation with empty domain.  (Contributed by Mario Carneiro,
     28-Dec-2014.) */

theorem mpt0 (x : set, A : class)  {
	prop 1 : wff = |- ( x ∈ ∅ ↦ A ) = ∅ ;;
}

proof of mpt0 {
	step 1 : wff = ral0 () |- ∀ x ∈ ∅ A ∈ _V ;;
	step 2 : wff = eqid () |- ( x ∈ ∅ ↦ A ) = ( x ∈ ∅ ↦ A ) ;;
	step 3 : wff = fnmpt (step 2) |- ( ∀ x ∈ ∅ A ∈ _V → ( x ∈ ∅ ↦ A ) Fn ∅ ) ;;
	step 4 : wff = ax-mp (step 1, step 3) |- ( x ∈ ∅ ↦ A ) Fn ∅ ;;
	step 5 : wff = fn0 () |- ( ( x ∈ ∅ ↦ A ) Fn ∅ ↔ ( x ∈ ∅ ↦ A ) = ∅ ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- ( x ∈ ∅ ↦ A ) = ∅ ;;
	qed prop 1 = step 6 ;;
}

/*Functionality and domain of an ordered-pair class abstraction.
       (Contributed by NM, 29-Jan-2004.)  (Revised by Mario Carneiro,
       31-Aug-2015.) */

theorem fnmpti (x : set, A : class, B : class, F : class) disjointed(x A, B) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- F Fn A ;;
}

proof of fnmpti {
	step 1 : wff = rgenw (hyp 1) |- ∀ x ∈ A B ∈ _V ;;
	step 2 : wff = mptfng (hyp 2) |- ( ∀ x ∈ A B ∈ _V ↔ F Fn A ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- F Fn A ;;
	qed prop 1 = step 3 ;;
}

/*Domain of an ordered-pair class abstraction that specifies a function.
       (Contributed by NM, 6-Sep-2005.)  (Revised by Mario Carneiro,
       31-Aug-2015.) */

theorem dmmpti (x : set, A : class, B : class, F : class) disjointed(x A, B) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- dom F = A ;;
}

proof of dmmpti {
	step 1 : wff = fnmpti (hyp 1, hyp 2) |- F Fn A ;;
	step 2 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- dom F = A ;;
	qed prop 1 = step 3 ;;
}

/*Union of mappings which are mutually compatible.  (Contributed by Mario
       Carneiro, 31-Aug-2015.) */

theorem mptun (x : set, A : class, B : class, C : class) disjointed(x y, y A, y B, y C) {
	prop 1 : wff = |- ( x ∈ ( A ∪ B ) ↦ C ) = ( ( x ∈ A ↦ C ) ∪ ( x ∈ B ↦ C ) ) ;;
}

proof of mptun {
	var y : set;;
	step 1 : wff = df-mpt () |- ( x ∈ ( A ∪ B ) ↦ C ) = { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y = C ) } ;;
	step 2 : wff = df-mpt () |- ( x ∈ A ↦ C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 3 : wff = df-mpt () |- ( x ∈ B ↦ C ) = { 〈 x , y 〉 | ( x ∈ B ∧ y = C ) } ;;
	step 4 : wff = uneq12i (step 2, step 3) |- ( ( x ∈ A ↦ C ) ∪ ( x ∈ B ↦ C ) ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ∪ { 〈 x , y 〉 | ( x ∈ B ∧ y = C ) } ) ;;
	step 5 : wff = elun () |- ( x ∈ ( A ∪ B ) ↔ ( x ∈ A ∨ x ∈ B ) ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( x ∈ ( A ∪ B ) ∧ y = C ) ↔ ( ( x ∈ A ∨ x ∈ B ) ∧ y = C ) ) ;;
	step 7 : wff = andir () |- ( ( ( x ∈ A ∨ x ∈ B ) ∧ y = C ) ↔ ( ( x ∈ A ∧ y = C ) ∨ ( x ∈ B ∧ y = C ) ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ( x ∈ ( A ∪ B ) ∧ y = C ) ↔ ( ( x ∈ A ∧ y = C ) ∨ ( x ∈ B ∧ y = C ) ) ) ;;
	step 9 : wff = opabbii (step 8) |- { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y = C ) } = { 〈 x , y 〉 | ( ( x ∈ A ∧ y = C ) ∨ ( x ∈ B ∧ y = C ) ) } ;;
	step 10 : wff = unopab () |- ( { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ∪ { 〈 x , y 〉 | ( x ∈ B ∧ y = C ) } ) = { 〈 x , y 〉 | ( ( x ∈ A ∧ y = C ) ∨ ( x ∈ B ∧ y = C ) ) } ;;
	step 11 : wff = eqtr4i (step 9, step 10) |- { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y = C ) } = ( { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ∪ { 〈 x , y 〉 | ( x ∈ B ∧ y = C ) } ) ;;
	step 12 : wff = eqtr4i (step 4, step 11) |- ( ( x ∈ A ↦ C ) ∪ ( x ∈ B ↦ C ) ) = { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y = C ) } ;;
	step 13 : wff = eqtr4i (step 1, step 12) |- ( x ∈ ( A ∪ B ) ↦ C ) = ( ( x ∈ A ↦ C ) ∪ ( x ∈ B ↦ C ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Equality theorem for functions.  (Contributed by NM, 1-Aug-1994.) */

theorem feq1 (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( F = G → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
}

proof of feq1 {
	step 1 : wff = fneq1 () |- ( F = G → ( F Fn A ↔ G Fn A ) ) ;;
	step 2 : wff = rneq () |- ( F = G → ran F = ran G ) ;;
	step 3 : wff = sseq1d (step 2) |- ( F = G → ( ran F ⊆ B ↔ ran G ⊆ B ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( F = G → ( ( F Fn A ∧ ran F ⊆ B ) ↔ ( G Fn A ∧ ran G ⊆ B ) ) ) ;;
	step 5 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 6 : wff = df-f () |- ( G : A ⟶ B ↔ ( G Fn A ∧ ran G ⊆ B ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( F = G → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for functions.  (Contributed by NM, 1-Aug-1994.) */

theorem feq2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
}

proof of feq2 {
	step 1 : wff = fneq2 () |- ( A = B → ( F Fn A ↔ F Fn B ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( A = B → ( ( F Fn A ∧ ran F ⊆ C ) ↔ ( F Fn B ∧ ran F ⊆ C ) ) ) ;;
	step 3 : wff = df-f () |- ( F : A ⟶ C ↔ ( F Fn A ∧ ran F ⊆ C ) ) ;;
	step 4 : wff = df-f () |- ( F : B ⟶ C ↔ ( F Fn B ∧ ran F ⊆ C ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for functions.  (Contributed by NM, 1-Aug-1994.) */

theorem feq3 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : C ⟶ A ↔ F : C ⟶ B ) ) ;;
}

proof of feq3 {
	step 1 : wff = sseq2 () |- ( A = B → ( ran F ⊆ A ↔ ran F ⊆ B ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( A = B → ( ( F Fn C ∧ ran F ⊆ A ) ↔ ( F Fn C ∧ ran F ⊆ B ) ) ) ;;
	step 3 : wff = df-f () |- ( F : C ⟶ A ↔ ( F Fn C ∧ ran F ⊆ A ) ) ;;
	step 4 : wff = df-f () |- ( F : C ⟶ B ↔ ( F Fn C ∧ ran F ⊆ B ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F : C ⟶ A ↔ F : C ⟶ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for functions.  (Contributed by FL, 14-Jul-2007.)  (Proof
     shortened by Andrew Salmon, 17-Sep-2011.) */

theorem feq23 (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( A = C ∧ B = D ) → ( F : A ⟶ B ↔ F : C ⟶ D ) ) ;;
}

proof of feq23 {
	step 1 : wff = feq2 () |- ( A = C → ( F : A ⟶ B ↔ F : C ⟶ B ) ) ;;
	step 2 : wff = feq3 () |- ( B = D → ( F : C ⟶ B ↔ F : C ⟶ D ) ) ;;
	step 3 : wff = sylan9bb (step 1, step 2) |- ( ( A = C ∧ B = D ) → ( F : A ⟶ B ↔ F : C ⟶ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for functions.  (Contributed by NM, 19-Feb-2008.) */

theorem feq1d (ph : wff, A : class, B : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
}

proof of feq1d {
	step 1 : wff = feq1 () |- ( F = G → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for functions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem feq2d (ph : wff, A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
}

proof of feq2d {
	step 1 : wff = feq2 () |- ( A = B → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for functions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem feq12d (ph : wff, A : class, B : class, C : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⟶ C ↔ G : B ⟶ C ) ) ;;
}

proof of feq12d {
	step 1 : wff = feq1d (hyp 1) |- ( ph → ( F : A ⟶ C ↔ G : A ⟶ C ) ) ;;
	step 2 : wff = feq2d (hyp 2) |- ( ph → ( G : A ⟶ C ↔ G : B ⟶ C ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( F : A ⟶ C ↔ G : B ⟶ C ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for functions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem feq123d (ph : wff, A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⟶ C ↔ G : B ⟶ D ) ) ;;
}

proof of feq123d {
	step 1 : wff = feq12d (hyp 1, hyp 2) |- ( ph → ( F : A ⟶ C ↔ G : B ⟶ C ) ) ;;
	step 2 : wff = feq3 () |- ( C = D → ( G : B ⟶ C ↔ G : B ⟶ D ) ) ;;
	step 3 : wff = syl (hyp 3, step 2) |- ( ph → ( G : B ⟶ C ↔ G : B ⟶ D ) ) ;;
	step 4 : wff = bitrd (step 1, step 3) |- ( ph → ( F : A ⟶ C ↔ G : B ⟶ D ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality inference for functions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem feq1i (A : class, B : class, F : class, G : class)  {
	hyp 1 : wff = |- F = G ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ B ↔ G : A ⟶ B ) ;;
}

proof of feq1i {
	step 1 : wff = feq1 () |- ( F = G → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F : A ⟶ B ↔ G : A ⟶ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for functions.  (Contributed by NM, 5-Sep-2011.) */

theorem feq2i (A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ C ↔ F : B ⟶ C ) ;;
}

proof of feq2i {
	step 1 : wff = feq2 () |- ( A = B → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F : A ⟶ C ↔ F : B ⟶ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for functions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem feq23i (A : class, B : class, C : class, D : class, F : class)  {
	hyp 1 : wff = |- A = C ;;
	hyp 2 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ B ↔ F : C ⟶ D ) ;;
}

proof of feq23i {
	step 1 : wff = feq23 () |- ( ( A = C ∧ B = D ) → ( F : A ⟶ B ↔ F : C ⟶ D ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( F : A ⟶ B ↔ F : C ⟶ D ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for functions.  (Contributed by NM, 8-Jun-2013.) */

theorem feq23d (ph : wff, A : class, B : class, C : class, D : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = C ) ;;
	hyp 2 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⟶ B ↔ F : C ⟶ D ) ) ;;
}

proof of feq23d {
	step 1 : wff = eqidd () |- ( ph → F = F ) ;;
	step 2 : wff = feq123d (step 1, hyp 1, hyp 2) |- ( ph → ( F : A ⟶ B ↔ F : C ⟶ D ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for a mapping.  (Contributed by NM,
       29-Jan-2004.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nff (x : set, A : class, B : class, F : class) disjointed(F, A, B, x) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x A ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x F : A ⟶ B ;;
}

proof of nff {
	step 1 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 2 : wff = nffn (hyp 1, hyp 2) |- F/ x F Fn A ;;
	step 3 : wff = nfrn (hyp 1) |- F/_ x ran F ;;
	step 4 : wff = nfss (step 3, hyp 3) |- F/ x ran F ⊆ B ;;
	step 5 : wff = nfan (step 2, step 4) |- F/ x ( F Fn A ∧ ran F ⊆ B ) ;;
	step 6 : wff = nfxfr (step 1, step 5) |- F/ x F : A ⟶ B ;;
	qed prop 1 = step 6 ;;
}

/*Eliminate a mapping hypothesis for the weak deduction theorem ~ dedth ,
       when a special case ` G : A --> B ` is provable, in order to convert
       ` F : A --> B ` from a hypothesis to an antecedent.  (Contributed by NM,
       24-Aug-2006.) */

theorem elimf (A : class, B : class, F : class, G : class)  {
	hyp 1 : wff = |- G : A ⟶ B ;;
	-----------------------
	prop 1 : wff = |- if ( F : A ⟶ B , F , G ) : A ⟶ B ;;
}

proof of elimf {
	step 1 : wff = feq1 () |- ( F = if ( F : A ⟶ B , F , G ) → ( F : A ⟶ B ↔ if ( F : A ⟶ B , F , G ) : A ⟶ B ) ) ;;
	step 2 : wff = feq1 () |- ( G = if ( F : A ⟶ B , F , G ) → ( G : A ⟶ B ↔ if ( F : A ⟶ B , F , G ) : A ⟶ B ) ) ;;
	step 3 : wff = elimhyp (step 1, step 2, hyp 1) |- if ( F : A ⟶ B , F , G ) : A ⟶ B ;;
	qed prop 1 = step 3 ;;
}

/*A mapping is a function.  (Contributed by NM, 2-Aug-1994.) */

theorem ffn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → F Fn A ) ;;
}

proof of ffn {
	step 1 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( F : A ⟶ B → F Fn A ) ;;
	qed prop 1 = step 2 ;;
}

/*Any function is a mapping into ` _V ` .  (Contributed by NM,
     31-Oct-1995.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem dffn2 (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A ↔ F : A ⟶ _V ) ;;
}

proof of dffn2 {
	step 1 : wff = ssv () |- ran F ⊆ _V ;;
	step 2 : wff = biantru (step 1) |- ( F Fn A ↔ ( F Fn A ∧ ran F ⊆ _V ) ) ;;
	step 3 : wff = df-f () |- ( F : A ⟶ _V ↔ ( F Fn A ∧ ran F ⊆ _V ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( F Fn A ↔ F : A ⟶ _V ) ;;
	qed prop 1 = step 4 ;;
}

/*A mapping is a function.  (Contributed by NM, 3-Aug-1994.) */

theorem ffun (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → Fun F ) ;;
}

proof of ffun {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⟶ B → Fun F ) ;;
	qed prop 1 = step 3 ;;
}

/*A mapping is a relation.  (Contributed by NM, 3-Aug-1994.) */

theorem frel (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → Rel F ) ;;
}

proof of frel {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⟶ B → Rel F ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a mapping.  (Contributed by NM, 2-Aug-1994.) */

theorem fdm (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → dom F = A ) ;;
}

proof of fdm {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⟶ B → dom F = A ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a mapping.  (Contributed by NM, 28-Jul-2008.) */

theorem fdmi (A : class, B : class, F : class)  {
	hyp 1 : wff = |- F : A ⟶ B ;;
	-----------------------
	prop 1 : wff = |- dom F = A ;;
}

proof of fdmi {
	step 1 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- dom F = A ;;
	qed prop 1 = step 2 ;;
}

/*The range of a mapping.  (Contributed by NM, 3-Aug-1994.) */

theorem frn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → ran F ⊆ B ) ;;
}

proof of frn {
	step 1 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	qed prop 1 = step 2 ;;
}

/*A function maps to its range.  (Contributed by NM, 1-Sep-1999.) */

theorem dffn3 (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A ↔ F : A ⟶ ran F ) ;;
}

proof of dffn3 {
	step 1 : wff = ssid () |- ran F ⊆ ran F ;;
	step 2 : wff = biantru (step 1) |- ( F Fn A ↔ ( F Fn A ∧ ran F ⊆ ran F ) ) ;;
	step 3 : wff = df-f () |- ( F : A ⟶ ran F ↔ ( F Fn A ∧ ran F ⊆ ran F ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( F Fn A ↔ F : A ⟶ ran F ) ;;
	qed prop 1 = step 4 ;;
}

/*Expanding the codomain of a mapping.  (Contributed by NM, 10-May-1998.)
     (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fss (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ B ⊆ C ) → F : A ⟶ C ) ;;
}

proof of fss {
	step 1 : wff = sstr2 () |- ( ran F ⊆ B → ( B ⊆ C → ran F ⊆ C ) ) ;;
	step 2 : wff = com12 (step 1) |- ( B ⊆ C → ( ran F ⊆ B → ran F ⊆ C ) ) ;;
	step 3 : wff = anim2d (step 2) |- ( B ⊆ C → ( ( F Fn A ∧ ran F ⊆ B ) → ( F Fn A ∧ ran F ⊆ C ) ) ) ;;
	step 4 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 5 : wff = df-f () |- ( F : A ⟶ C ↔ ( F Fn A ∧ ran F ⊆ C ) ) ;;
	step 6 : wff = 3imtr4g (step 3, step 4, step 5) |- ( B ⊆ C → ( F : A ⟶ B → F : A ⟶ C ) ) ;;
	step 7 : wff = impcom (step 6) |- ( ( F : A ⟶ B ∧ B ⊆ C ) → F : A ⟶ C ) ;;
	qed prop 1 = step 7 ;;
}

/*Composition of two mappings.  (Contributed by NM, 29-Aug-1999.)  (Proof
     shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fco (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( F ∘ G ) : A ⟶ C ) ;;
}

proof of fco {
	step 1 : wff = df-f () |- ( F : B ⟶ C ↔ ( F Fn B ∧ ran F ⊆ C ) ) ;;
	step 2 : wff = df-f () |- ( G : A ⟶ B ↔ ( G Fn A ∧ ran G ⊆ B ) ) ;;
	step 3 : wff = fnco () |- ( ( F Fn B ∧ G Fn A ∧ ran G ⊆ B ) → ( F ∘ G ) Fn A ) ;;
	step 4 : wff = 3expib (step 3) |- ( F Fn B → ( ( G Fn A ∧ ran G ⊆ B ) → ( F ∘ G ) Fn A ) ) ;;
	step 5 : wff = adantr (step 4) |- ( ( F Fn B ∧ ran F ⊆ C ) → ( ( G Fn A ∧ ran G ⊆ B ) → ( F ∘ G ) Fn A ) ) ;;
	step 6 : wff = rncoss () |- ran ( F ∘ G ) ⊆ ran F ;;
	step 7 : wff = sstr () |- ( ( ran ( F ∘ G ) ⊆ ran F ∧ ran F ⊆ C ) → ran ( F ∘ G ) ⊆ C ) ;;
	step 8 : wff = mpan (step 6, step 7) |- ( ran F ⊆ C → ran ( F ∘ G ) ⊆ C ) ;;
	step 9 : wff = adantl (step 8) |- ( ( F Fn B ∧ ran F ⊆ C ) → ran ( F ∘ G ) ⊆ C ) ;;
	step 10 : wff = jctird (step 5, step 9) |- ( ( F Fn B ∧ ran F ⊆ C ) → ( ( G Fn A ∧ ran G ⊆ B ) → ( ( F ∘ G ) Fn A ∧ ran ( F ∘ G ) ⊆ C ) ) ) ;;
	step 11 : wff = imp (step 10) |- ( ( ( F Fn B ∧ ran F ⊆ C ) ∧ ( G Fn A ∧ ran G ⊆ B ) ) → ( ( F ∘ G ) Fn A ∧ ran ( F ∘ G ) ⊆ C ) ) ;;
	step 12 : wff = syl2anb (step 1, step 2, step 11) |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( ( F ∘ G ) Fn A ∧ ran ( F ∘ G ) ⊆ C ) ) ;;
	step 13 : wff = df-f () |- ( ( F ∘ G ) : A ⟶ C ↔ ( ( F ∘ G ) Fn A ∧ ran ( F ∘ G ) ⊆ C ) ) ;;
	step 14 : wff = sylibr (step 12, step 13) |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( F ∘ G ) : A ⟶ C ) ;;
	qed prop 1 = step 14 ;;
}

/*Functionality of a composition with weakened out of domain condition on
     the first argument.  (Contributed by Stefan O'Rear, 11-Mar-2015.) */

theorem fco2 (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( F ↾ B ) : B ⟶ C ∧ G : A ⟶ B ) → ( F ∘ G ) : A ⟶ C ) ;;
}

proof of fco2 {
	step 1 : wff = fco () |- ( ( ( F ↾ B ) : B ⟶ C ∧ G : A ⟶ B ) → ( ( F ↾ B ) ∘ G ) : A ⟶ C ) ;;
	step 2 : wff = frn () |- ( G : A ⟶ B → ran G ⊆ B ) ;;
	step 3 : wff = cores () |- ( ran G ⊆ B → ( ( F ↾ B ) ∘ G ) = ( F ∘ G ) ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( G : A ⟶ B → ( ( F ↾ B ) ∘ G ) = ( F ∘ G ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ( F ↾ B ) : B ⟶ C ∧ G : A ⟶ B ) → ( ( F ↾ B ) ∘ G ) = ( F ∘ G ) ) ;;
	step 6 : wff = feq1d (step 5) |- ( ( ( F ↾ B ) : B ⟶ C ∧ G : A ⟶ B ) → ( ( ( F ↾ B ) ∘ G ) : A ⟶ C ↔ ( F ∘ G ) : A ⟶ C ) ) ;;
	step 7 : wff = mpbid (step 1, step 6) |- ( ( ( F ↾ B ) : B ⟶ C ∧ G : A ⟶ B ) → ( F ∘ G ) : A ⟶ C ) ;;
	qed prop 1 = step 7 ;;
}

/*A mapping is a class of ordered pairs.  (Contributed by NM, 3-Aug-1994.)
     (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fssxp (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → F ⊆ ( A × B ) ) ;;
}

proof of fssxp {
	step 1 : wff = frel () |- ( F : A ⟶ B → Rel F ) ;;
	step 2 : wff = relssdmrn () |- ( Rel F → F ⊆ ( dom F × ran F ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⟶ B → F ⊆ ( dom F × ran F ) ) ;;
	step 4 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 5 : wff = eqimss () |- ( dom F = A → dom F ⊆ A ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( F : A ⟶ B → dom F ⊆ A ) ;;
	step 7 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 8 : wff = xpss12 () |- ( ( dom F ⊆ A ∧ ran F ⊆ B ) → ( dom F × ran F ) ⊆ ( A × B ) ) ;;
	step 9 : wff = syl2anc (step 6, step 7, step 8) |- ( F : A ⟶ B → ( dom F × ran F ) ⊆ ( A × B ) ) ;;
	step 10 : wff = sstrd (step 3, step 9) |- ( F : A ⟶ B → F ⊆ ( A × B ) ) ;;
	qed prop 1 = step 10 ;;
}

/*A function with bounded domain and range is a set.  This version of ~ fex
     is proven without the Axiom of Replacement.  (Contributed by Mario
     Carneiro, 24-Jun-2015.) */

theorem fex2 (A : class, B : class, F : class, V : class, W : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ A ∈ V ∧ B ∈ W ) → F ∈ _V ) ;;
}

proof of fex2 {
	step 1 : wff = fssxp () |- ( F : A ⟶ B → F ⊆ ( A × B ) ) ;;
	step 2 : wff = 3ad2ant1 (step 1) |- ( ( F : A ⟶ B ∧ A ∈ V ∧ B ∈ W ) → F ⊆ ( A × B ) ) ;;
	step 3 : wff = xpexg () |- ( ( A ∈ V ∧ B ∈ W ) → ( A × B ) ∈ _V ) ;;
	step 4 : wff = 3adant1 (step 3) |- ( ( F : A ⟶ B ∧ A ∈ V ∧ B ∈ W ) → ( A × B ) ∈ _V ) ;;
	step 5 : wff = ssexg () |- ( ( F ⊆ ( A × B ) ∧ ( A × B ) ∈ _V ) → F ∈ _V ) ;;
	step 6 : wff = syl2anc (step 2, step 4, step 5) |- ( ( F : A ⟶ B ∧ A ∈ V ∧ B ∈ W ) → F ∈ _V ) ;;
	qed prop 1 = step 6 ;;
}

/*Two ways of specifying a partial function from ` A ` to ` B ` .
     (Contributed by NM, 13-Nov-2007.) */

theorem funssxp (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ F ⊆ ( A × B ) ) ↔ ( F : dom F ⟶ B ∧ dom F ⊆ A ) ) ;;
}

proof of funssxp {
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = biimpi (step 1) |- ( Fun F → F Fn dom F ) ;;
	step 3 : wff = rnss () |- ( F ⊆ ( A × B ) → ran F ⊆ ran ( A × B ) ) ;;
	step 4 : wff = rnxpss () |- ran ( A × B ) ⊆ B ;;
	step 5 : wff = syl6ss (step 3, step 4) |- ( F ⊆ ( A × B ) → ran F ⊆ B ) ;;
	step 6 : wff = anim12i (step 2, step 5) |- ( ( Fun F ∧ F ⊆ ( A × B ) ) → ( F Fn dom F ∧ ran F ⊆ B ) ) ;;
	step 7 : wff = df-f () |- ( F : dom F ⟶ B ↔ ( F Fn dom F ∧ ran F ⊆ B ) ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( Fun F ∧ F ⊆ ( A × B ) ) → F : dom F ⟶ B ) ;;
	step 9 : wff = dmss () |- ( F ⊆ ( A × B ) → dom F ⊆ dom ( A × B ) ) ;;
	step 10 : wff = dmxpss () |- dom ( A × B ) ⊆ A ;;
	step 11 : wff = syl6ss (step 9, step 10) |- ( F ⊆ ( A × B ) → dom F ⊆ A ) ;;
	step 12 : wff = adantl (step 11) |- ( ( Fun F ∧ F ⊆ ( A × B ) ) → dom F ⊆ A ) ;;
	step 13 : wff = jca (step 8, step 12) |- ( ( Fun F ∧ F ⊆ ( A × B ) ) → ( F : dom F ⟶ B ∧ dom F ⊆ A ) ) ;;
	step 14 : wff = ffun () |- ( F : dom F ⟶ B → Fun F ) ;;
	step 15 : wff = adantr (step 14) |- ( ( F : dom F ⟶ B ∧ dom F ⊆ A ) → Fun F ) ;;
	step 16 : wff = fssxp () |- ( F : dom F ⟶ B → F ⊆ ( dom F × B ) ) ;;
	step 17 : wff = xpss1 () |- ( dom F ⊆ A → ( dom F × B ) ⊆ ( A × B ) ) ;;
	step 18 : wff = sylan9ss (step 16, step 17) |- ( ( F : dom F ⟶ B ∧ dom F ⊆ A ) → F ⊆ ( A × B ) ) ;;
	step 19 : wff = jca (step 15, step 18) |- ( ( F : dom F ⟶ B ∧ dom F ⊆ A ) → ( Fun F ∧ F ⊆ ( A × B ) ) ) ;;
	step 20 : wff = impbii (step 13, step 19) |- ( ( Fun F ∧ F ⊆ ( A × B ) ) ↔ ( F : dom F ⟶ B ∧ dom F ⊆ A ) ) ;;
	qed prop 1 = step 20 ;;
}

/*A mapping is a partial function.  (Contributed by NM, 25-Nov-2007.) */

theorem ffdm (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → ( F : dom F ⟶ B ∧ dom F ⊆ A ) ) ;;
}

proof of ffdm {
	step 1 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 2 : wff = feq2d (step 1) |- ( F : A ⟶ B → ( F : dom F ⟶ B ↔ F : A ⟶ B ) ) ;;
	step 3 : wff = ibir (step 2) |- ( F : A ⟶ B → F : dom F ⟶ B ) ;;
	step 4 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 5 : wff = eqimss () |- ( dom F = A → dom F ⊆ A ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( F : A ⟶ B → dom F ⊆ A ) ;;
	step 7 : wff = jca (step 3, step 6) |- ( F : A ⟶ B → ( F : dom F ⟶ B ∧ dom F ⊆ A ) ) ;;
	qed prop 1 = step 7 ;;
}

/*The members of an ordered pair element of a mapping belong to the
     mapping's domain and codomain.  (Contributed by NM, 10-Dec-2003.)
     (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem opelf (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ 〈 C , D 〉 ∈ F ) → ( C ∈ A ∧ D ∈ B ) ) ;;
}

proof of opelf {
	step 1 : wff = fssxp () |- ( F : A ⟶ B → F ⊆ ( A × B ) ) ;;
	step 2 : wff = sseld (step 1) |- ( F : A ⟶ B → ( 〈 C , D 〉 ∈ F → 〈 C , D 〉 ∈ ( A × B ) ) ) ;;
	step 3 : wff = opelxp () |- ( 〈 C , D 〉 ∈ ( A × B ) ↔ ( C ∈ A ∧ D ∈ B ) ) ;;
	step 4 : wff = syl6ib (step 2, step 3) |- ( F : A ⟶ B → ( 〈 C , D 〉 ∈ F → ( C ∈ A ∧ D ∈ B ) ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( F : A ⟶ B ∧ 〈 C , D 〉 ∈ F ) → ( C ∈ A ∧ D ∈ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*The union of two functions with disjoint domains.  (Contributed by NM,
     22-Sep-2004.) */

theorem fun (A : class, B : class, C : class, D : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( F : A ⟶ C ∧ G : B ⟶ D ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ D ) ) ;;
}

proof of fun {
	step 1 : wff = fnun () |- ( ( ( F Fn A ∧ G Fn B ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ B ) ) ;;
	step 2 : wff = expcom (step 1) |- ( ( A ∩ B ) = ∅ → ( ( F Fn A ∧ G Fn B ) → ( F ∪ G ) Fn ( A ∪ B ) ) ) ;;
	step 3 : wff = rnun () |- ran ( F ∪ G ) = ( ran F ∪ ran G ) ;;
	step 4 : wff = unss12 () |- ( ( ran F ⊆ C ∧ ran G ⊆ D ) → ( ran F ∪ ran G ) ⊆ ( C ∪ D ) ) ;;
	step 5 : wff = syl5eqss (step 3, step 4) |- ( ( ran F ⊆ C ∧ ran G ⊆ D ) → ran ( F ∪ G ) ⊆ ( C ∪ D ) ) ;;
	step 6 : wff = a1i (step 5) |- ( ( A ∩ B ) = ∅ → ( ( ran F ⊆ C ∧ ran G ⊆ D ) → ran ( F ∪ G ) ⊆ ( C ∪ D ) ) ) ;;
	step 7 : wff = anim12d (step 2, step 6) |- ( ( A ∩ B ) = ∅ → ( ( ( F Fn A ∧ G Fn B ) ∧ ( ran F ⊆ C ∧ ran G ⊆ D ) ) → ( ( F ∪ G ) Fn ( A ∪ B ) ∧ ran ( F ∪ G ) ⊆ ( C ∪ D ) ) ) ) ;;
	step 8 : wff = df-f () |- ( F : A ⟶ C ↔ ( F Fn A ∧ ran F ⊆ C ) ) ;;
	step 9 : wff = df-f () |- ( G : B ⟶ D ↔ ( G Fn B ∧ ran G ⊆ D ) ) ;;
	step 10 : wff = anbi12i (step 8, step 9) |- ( ( F : A ⟶ C ∧ G : B ⟶ D ) ↔ ( ( F Fn A ∧ ran F ⊆ C ) ∧ ( G Fn B ∧ ran G ⊆ D ) ) ) ;;
	step 11 : wff = an4 () |- ( ( ( F Fn A ∧ ran F ⊆ C ) ∧ ( G Fn B ∧ ran G ⊆ D ) ) ↔ ( ( F Fn A ∧ G Fn B ) ∧ ( ran F ⊆ C ∧ ran G ⊆ D ) ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( ( F : A ⟶ C ∧ G : B ⟶ D ) ↔ ( ( F Fn A ∧ G Fn B ) ∧ ( ran F ⊆ C ∧ ran G ⊆ D ) ) ) ;;
	step 13 : wff = df-f () |- ( ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ D ) ↔ ( ( F ∪ G ) Fn ( A ∪ B ) ∧ ran ( F ∪ G ) ⊆ ( C ∪ D ) ) ) ;;
	step 14 : wff = 3imtr4g (step 7, step 12, step 13) |- ( ( A ∩ B ) = ∅ → ( ( F : A ⟶ C ∧ G : B ⟶ D ) → ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ D ) ) ) ;;
	step 15 : wff = impcom (step 14) |- ( ( ( F : A ⟶ C ∧ G : B ⟶ D ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ D ) ) ;;
	qed prop 1 = step 15 ;;
}

/*The union of two functions with disjoint domains.  (Contributed by Mario
     Carneiro, 12-Mar-2015.) */

theorem fun2 (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( F : A ⟶ C ∧ G : B ⟶ C ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ;;
}

proof of fun2 {
	step 1 : wff = fun () |- ( ( ( F : A ⟶ C ∧ G : B ⟶ C ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ C ) ) ;;
	step 2 : wff = unidm () |- ( C ∪ C ) = C ;;
	step 3 : wff = feq3 () |- ( ( C ∪ C ) = C → ( ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ C ) ↔ ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ( F ∪ G ) : ( A ∪ B ) ⟶ ( C ∪ C ) ↔ ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ;;
	step 5 : wff = sylib (step 1, step 4) |- ( ( ( F : A ⟶ C ∧ G : B ⟶ C ) ∧ ( A ∩ B ) = ∅ ) → ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ;;
	qed prop 1 = step 5 ;;
}

/*Composition of two functions.  (Contributed by NM, 22-May-2006.) */

theorem fnfco (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ G : B ⟶ A ) → ( F ∘ G ) Fn B ) ;;
}

proof of fnfco {
	step 1 : wff = df-f () |- ( G : B ⟶ A ↔ ( G Fn B ∧ ran G ⊆ A ) ) ;;
	step 2 : wff = fnco () |- ( ( F Fn A ∧ G Fn B ∧ ran G ⊆ A ) → ( F ∘ G ) Fn B ) ;;
	step 3 : wff = 3expb (step 2) |- ( ( F Fn A ∧ ( G Fn B ∧ ran G ⊆ A ) ) → ( F ∘ G ) Fn B ) ;;
	step 4 : wff = sylan2b (step 1, step 3) |- ( ( F Fn A ∧ G : B ⟶ A ) → ( F ∘ G ) Fn B ) ;;
	qed prop 1 = step 4 ;;
}

/*Restriction of a function with a subclass of its domain.  (Contributed by
     NM, 23-Sep-2004.) */

theorem fssres (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
}

proof of fssres {
	step 1 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 2 : wff = fnssres () |- ( ( F Fn A ∧ C ⊆ A ) → ( F ↾ C ) Fn C ) ;;
	step 3 : wff = resss () |- ( F ↾ C ) ⊆ F ;;
	step 4 : wff = rnss () |- ( ( F ↾ C ) ⊆ F → ran ( F ↾ C ) ⊆ ran F ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- ran ( F ↾ C ) ⊆ ran F ;;
	step 6 : wff = sstr () |- ( ( ran ( F ↾ C ) ⊆ ran F ∧ ran F ⊆ B ) → ran ( F ↾ C ) ⊆ B ) ;;
	step 7 : wff = mpan (step 5, step 6) |- ( ran F ⊆ B → ran ( F ↾ C ) ⊆ B ) ;;
	step 8 : wff = anim12i (step 2, step 7) |- ( ( ( F Fn A ∧ C ⊆ A ) ∧ ran F ⊆ B ) → ( ( F ↾ C ) Fn C ∧ ran ( F ↾ C ) ⊆ B ) ) ;;
	step 9 : wff = an32s (step 8) |- ( ( ( F Fn A ∧ ran F ⊆ B ) ∧ C ⊆ A ) → ( ( F ↾ C ) Fn C ∧ ran ( F ↾ C ) ⊆ B ) ) ;;
	step 10 : wff = sylanb (step 1, step 9) |- ( ( F : A ⟶ B ∧ C ⊆ A ) → ( ( F ↾ C ) Fn C ∧ ran ( F ↾ C ) ⊆ B ) ) ;;
	step 11 : wff = df-f () |- ( ( F ↾ C ) : C ⟶ B ↔ ( ( F ↾ C ) Fn C ∧ ran ( F ↾ C ) ⊆ B ) ) ;;
	step 12 : wff = sylibr (step 10, step 11) |- ( ( F : A ⟶ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
	qed prop 1 = step 12 ;;
}

/*Restriction of a restricted function with a subclass of its domain.
     (Contributed by NM, 21-Jul-2005.) */

theorem fssres2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( ( F ↾ A ) : A ⟶ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
}

proof of fssres2 {
	step 1 : wff = fssres () |- ( ( ( F ↾ A ) : A ⟶ B ∧ C ⊆ A ) → ( ( F ↾ A ) ↾ C ) : C ⟶ B ) ;;
	step 2 : wff = resabs1 () |- ( C ⊆ A → ( ( F ↾ A ) ↾ C ) = ( F ↾ C ) ) ;;
	step 3 : wff = feq1d (step 2) |- ( C ⊆ A → ( ( ( F ↾ A ) ↾ C ) : C ⟶ B ↔ ( F ↾ C ) : C ⟶ B ) ) ;;
	step 4 : wff = adantl (step 3) |- ( ( ( F ↾ A ) : A ⟶ B ∧ C ⊆ A ) → ( ( ( F ↾ A ) ↾ C ) : C ⟶ B ↔ ( F ↾ C ) : C ⟶ B ) ) ;;
	step 5 : wff = mpbid (step 1, step 4) |- ( ( ( F ↾ A ) : A ⟶ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
	qed prop 1 = step 5 ;;
}

/*An identity for the mapping relationship under restriction.  (Contributed
     by Scott Fenton, 4-Sep-2011.)  (Proof shortened by Mario Carneiro,
     26-May-2016.) */

theorem fresin (A : class, B : class, F : class, X : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → ( F ↾ X ) : ( A ∩ X ) ⟶ B ) ;;
}

proof of fresin {
	step 1 : wff = inss1 () |- ( A ∩ X ) ⊆ A ;;
	step 2 : wff = fssres () |- ( ( F : A ⟶ B ∧ ( A ∩ X ) ⊆ A ) → ( F ↾ ( A ∩ X ) ) : ( A ∩ X ) ⟶ B ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( F : A ⟶ B → ( F ↾ ( A ∩ X ) ) : ( A ∩ X ) ⟶ B ) ;;
	step 4 : wff = resres () |- ( ( F ↾ A ) ↾ X ) = ( F ↾ ( A ∩ X ) ) ;;
	step 5 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 6 : wff = fnresdm () |- ( F Fn A → ( F ↾ A ) = F ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( F : A ⟶ B → ( F ↾ A ) = F ) ;;
	step 8 : wff = reseq1d (step 7) |- ( F : A ⟶ B → ( ( F ↾ A ) ↾ X ) = ( F ↾ X ) ) ;;
	step 9 : wff = syl5eqr (step 4, step 8) |- ( F : A ⟶ B → ( F ↾ ( A ∩ X ) ) = ( F ↾ X ) ) ;;
	step 10 : wff = feq1d (step 9) |- ( F : A ⟶ B → ( ( F ↾ ( A ∩ X ) ) : ( A ∩ X ) ⟶ B ↔ ( F ↾ X ) : ( A ∩ X ) ⟶ B ) ) ;;
	step 11 : wff = mpbid (step 3, step 10) |- ( F : A ⟶ B → ( F ↾ X ) : ( A ∩ X ) ⟶ B ) ;;
	qed prop 1 = step 11 ;;
}

/*If two functions agree on their common domain, express their union as a
     union of three functions with pairwise disjoint domains.  (Contributed by
     Stefan O'Rear, 9-Oct-2014.) */

theorem resasplit (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
}

proof of resasplit {
	step 1 : wff = fnresdm () |- ( F Fn A → ( F ↾ A ) = F ) ;;
	step 2 : wff = fnresdm () |- ( G Fn B → ( G ↾ B ) = G ) ;;
	step 3 : wff = uneq12 () |- ( ( ( F ↾ A ) = F ∧ ( G ↾ B ) = G ) → ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( F ∪ G ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( F Fn A ∧ G Fn B ) → ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( F ∪ G ) ) ;;
	step 5 : wff = 3adant3 (step 4) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( F ∪ G ) ) ;;
	step 6 : wff = simp3 () |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) ;;
	step 7 : wff = uneq1d (step 6) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) = ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ;;
	step 8 : wff = uneq2d (step 7) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ∪ ( ( F ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) = ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ∪ ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 9 : wff = inundif () |- ( ( A ∩ B ) ∪ ( A ∖ B ) ) = A ;;
	step 10 : wff = reseq2i (step 9) |- ( F ↾ ( ( A ∩ B ) ∪ ( A ∖ B ) ) ) = ( F ↾ A ) ;;
	step 11 : wff = resundi () |- ( F ↾ ( ( A ∩ B ) ∪ ( A ∖ B ) ) ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ;;
	step 12 : wff = eqtr3i (step 10, step 11) |- ( F ↾ A ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ;;
	step 13 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 14 : wff = uneq1i (step 13) |- ( ( A ∩ B ) ∪ ( B ∖ A ) ) = ( ( B ∩ A ) ∪ ( B ∖ A ) ) ;;
	step 15 : wff = inundif () |- ( ( B ∩ A ) ∪ ( B ∖ A ) ) = B ;;
	step 16 : wff = eqtri (step 14, step 15) |- ( ( A ∩ B ) ∪ ( B ∖ A ) ) = B ;;
	step 17 : wff = reseq2i (step 16) |- ( G ↾ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) = ( G ↾ B ) ;;
	step 18 : wff = resundi () |- ( G ↾ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) = ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ;;
	step 19 : wff = eqtr3i (step 17, step 18) |- ( G ↾ B ) = ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ;;
	step 20 : wff = uneq12i (step 12, step 19) |- ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ∪ ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ;;
	step 21 : wff = syl6reqr (step 8, step 20) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ∪ ( ( F ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 22 : wff = un4 () |- ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∖ B ) ) ) ∪ ( ( F ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) = ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∩ B ) ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ;;
	step 23 : wff = syl6eq (step 21, step 22) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∩ B ) ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 24 : wff = unidm () |- ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∩ B ) ) ) = ( F ↾ ( A ∩ B ) ) ;;
	step 25 : wff = uneq1i (step 24) |- ( ( ( F ↾ ( A ∩ B ) ) ∪ ( F ↾ ( A ∩ B ) ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ;;
	step 26 : wff = syl6eq (step 23, step 25) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ A ) ∪ ( G ↾ B ) ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 27 : wff = eqtr3d (step 5, step 26) |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	qed prop 1 = step 27 ;;
}

/*The union of two functions which agree on their common domain is a
     function.  (Contributed by Stefan O'Rear, 9-Oct-2014.) */

theorem fresaun (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ;;
}

proof of fresaun {
	step 1 : wff = simp1 () |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → F : A ⟶ C ) ;;
	step 2 : wff = inss1 () |- ( A ∩ B ) ⊆ A ;;
	step 3 : wff = fssres () |- ( ( F : A ⟶ C ∧ ( A ∩ B ) ⊆ A ) → ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⟶ C ) ;;
	step 4 : wff = sylancl (step 1, step 2, step 3) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⟶ C ) ;;
	step 5 : wff = simp1 () |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → F : A ⟶ C ) ;;
	step 6 : wff = difss () |- ( A ∖ B ) ⊆ A ;;
	step 7 : wff = fssres () |- ( ( F : A ⟶ C ∧ ( A ∖ B ) ⊆ A ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⟶ C ) ;;
	step 8 : wff = sylancl (step 5, step 6, step 7) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⟶ C ) ;;
	step 9 : wff = simp2 () |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → G : B ⟶ C ) ;;
	step 10 : wff = difss () |- ( B ∖ A ) ⊆ B ;;
	step 11 : wff = fssres () |- ( ( G : B ⟶ C ∧ ( B ∖ A ) ⊆ B ) → ( G ↾ ( B ∖ A ) ) : ( B ∖ A ) ⟶ C ) ;;
	step 12 : wff = sylancl (step 9, step 10, step 11) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( G ↾ ( B ∖ A ) ) : ( B ∖ A ) ⟶ C ) ;;
	step 13 : wff = indifdir () |- ( ( A ∖ B ) ∩ ( B ∖ A ) ) = ( ( A ∩ ( B ∖ A ) ) ∖ ( B ∩ ( B ∖ A ) ) ) ;;
	step 14 : wff = disjdif () |- ( A ∩ ( B ∖ A ) ) = ∅ ;;
	step 15 : wff = difeq1i (step 14) |- ( ( A ∩ ( B ∖ A ) ) ∖ ( B ∩ ( B ∖ A ) ) ) = ( ∅ ∖ ( B ∩ ( B ∖ A ) ) ) ;;
	step 16 : wff = 0dif () |- ( ∅ ∖ ( B ∩ ( B ∖ A ) ) ) = ∅ ;;
	step 17 : wff = 3eqtri (step 13, step 15, step 16) |- ( ( A ∖ B ) ∩ ( B ∖ A ) ) = ∅ ;;
	step 18 : wff = a1i (step 17) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( A ∖ B ) ∩ ( B ∖ A ) ) = ∅ ) ;;
	step 19 : wff = fun2 () |- ( ( ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⟶ C ∧ ( G ↾ ( B ∖ A ) ) : ( B ∖ A ) ⟶ C ) ∧ ( ( A ∖ B ) ∩ ( B ∖ A ) ) = ∅ ) → ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) : ( ( A ∖ B ) ∪ ( B ∖ A ) ) ⟶ C ) ;;
	step 20 : wff = syl21anc (step 8, step 12, step 18, step 19) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) : ( ( A ∖ B ) ∪ ( B ∖ A ) ) ⟶ C ) ;;
	step 21 : wff = indi () |- ( ( A ∩ B ) ∩ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) = ( ( ( A ∩ B ) ∩ ( A ∖ B ) ) ∪ ( ( A ∩ B ) ∩ ( B ∖ A ) ) ) ;;
	step 22 : wff = inass () |- ( ( A ∩ B ) ∩ ( A ∖ B ) ) = ( A ∩ ( B ∩ ( A ∖ B ) ) ) ;;
	step 23 : wff = disjdif () |- ( B ∩ ( A ∖ B ) ) = ∅ ;;
	step 24 : wff = ineq2i (step 23) |- ( A ∩ ( B ∩ ( A ∖ B ) ) ) = ( A ∩ ∅ ) ;;
	step 25 : wff = in0 () |- ( A ∩ ∅ ) = ∅ ;;
	step 26 : wff = 3eqtri (step 22, step 24, step 25) |- ( ( A ∩ B ) ∩ ( A ∖ B ) ) = ∅ ;;
	step 27 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 28 : wff = ineq1i (step 27) |- ( ( A ∩ B ) ∩ ( B ∖ A ) ) = ( ( B ∩ A ) ∩ ( B ∖ A ) ) ;;
	step 29 : wff = inass () |- ( ( B ∩ A ) ∩ ( B ∖ A ) ) = ( B ∩ ( A ∩ ( B ∖ A ) ) ) ;;
	step 30 : wff = disjdif () |- ( A ∩ ( B ∖ A ) ) = ∅ ;;
	step 31 : wff = ineq2i (step 30) |- ( B ∩ ( A ∩ ( B ∖ A ) ) ) = ( B ∩ ∅ ) ;;
	step 32 : wff = in0 () |- ( B ∩ ∅ ) = ∅ ;;
	step 33 : wff = 3eqtri (step 29, step 31, step 32) |- ( ( B ∩ A ) ∩ ( B ∖ A ) ) = ∅ ;;
	step 34 : wff = eqtri (step 28, step 33) |- ( ( A ∩ B ) ∩ ( B ∖ A ) ) = ∅ ;;
	step 35 : wff = uneq12i (step 26, step 34) |- ( ( ( A ∩ B ) ∩ ( A ∖ B ) ) ∪ ( ( A ∩ B ) ∩ ( B ∖ A ) ) ) = ( ∅ ∪ ∅ ) ;;
	step 36 : wff = un0 () |- ( ∅ ∪ ∅ ) = ∅ ;;
	step 37 : wff = 3eqtri (step 21, step 35, step 36) |- ( ( A ∩ B ) ∩ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) = ∅ ;;
	step 38 : wff = a1i (step 37) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( A ∩ B ) ∩ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) = ∅ ) ;;
	step 39 : wff = fun2 () |- ( ( ( ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⟶ C ∧ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) : ( ( A ∖ B ) ∪ ( B ∖ A ) ) ⟶ C ) ∧ ( ( A ∩ B ) ∩ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) = ∅ ) → ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) : ( ( A ∩ B ) ∪ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) ⟶ C ) ;;
	step 40 : wff = syl21anc (step 4, step 20, step 38, step 39) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) : ( ( A ∩ B ) ∪ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) ⟶ C ) ;;
	step 41 : wff = ffn () |- ( F : A ⟶ C → F Fn A ) ;;
	step 42 : wff = ffn () |- ( G : B ⟶ C → G Fn B ) ;;
	step 43 : wff = id () |- ( ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) → ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) ;;
	step 44 : wff = resasplit () |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 45 : wff = syl3an (step 41, step 42, step 43, step 44) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 46 : wff = feq1d (step 45) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ∪ G ) : ( A ∪ B ) ⟶ C ↔ ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) : ( A ∪ B ) ⟶ C ) ) ;;
	step 47 : wff = un12 () |- ( ( A ∩ B ) ∪ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) = ( ( A ∖ B ) ∪ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) ;;
	step 48 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 49 : wff = uneq1i (step 48) |- ( ( A ∩ B ) ∪ ( B ∖ A ) ) = ( ( B ∩ A ) ∪ ( B ∖ A ) ) ;;
	step 50 : wff = inundif () |- ( ( B ∩ A ) ∪ ( B ∖ A ) ) = B ;;
	step 51 : wff = eqtri (step 49, step 50) |- ( ( A ∩ B ) ∪ ( B ∖ A ) ) = B ;;
	step 52 : wff = uneq2i (step 51) |- ( ( A ∖ B ) ∪ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) = ( ( A ∖ B ) ∪ B ) ;;
	step 53 : wff = undif1 () |- ( ( A ∖ B ) ∪ B ) = ( A ∪ B ) ;;
	step 54 : wff = 3eqtri (step 47, step 52, step 53) |- ( ( A ∩ B ) ∪ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) = ( A ∪ B ) ;;
	step 55 : wff = feq2i (step 54) |- ( ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) : ( ( A ∩ B ) ∪ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) ⟶ C ↔ ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) : ( A ∪ B ) ⟶ C ) ;;
	step 56 : wff = syl6rbbr (step 46, step 55) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) : ( ( A ∩ B ) ∪ ( ( A ∖ B ) ∪ ( B ∖ A ) ) ) ⟶ C ↔ ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ) ;;
	step 57 : wff = mpbid (step 40, step 56) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) : ( A ∪ B ) ⟶ C ) ;;
	qed prop 1 = step 57 ;;
}

/*From the union of two functions that agree on the domain overlap, either
     component can be recovered by restriction.  (Contributed by Stefan O'Rear,
     9-Oct-2014.) */

theorem fresaunres2 (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ∪ G ) ↾ B ) = G ) ;;
}

proof of fresaunres2 {
	step 1 : wff = ffn () |- ( F : A ⟶ C → F Fn A ) ;;
	step 2 : wff = ffn () |- ( G : B ⟶ C → G Fn B ) ;;
	step 3 : wff = id () |- ( ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) → ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) ;;
	step 4 : wff = resasplit () |- ( ( F Fn A ∧ G Fn B ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 5 : wff = syl3an (step 1, step 2, step 3, step 4) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ∪ G ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 6 : wff = reseq1d (step 5) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ∪ G ) ↾ B ) = ( ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ↾ B ) ) ;;
	step 7 : wff = resundir () |- ( ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ↾ B ) = ( ( ( F ↾ ( A ∩ B ) ) ↾ B ) ∪ ( ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ↾ B ) ) ;;
	step 8 : wff = inss2 () |- ( A ∩ B ) ⊆ B ;;
	step 9 : wff = resabs2 () |- ( ( A ∩ B ) ⊆ B → ( ( F ↾ ( A ∩ B ) ) ↾ B ) = ( F ↾ ( A ∩ B ) ) ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- ( ( F ↾ ( A ∩ B ) ) ↾ B ) = ( F ↾ ( A ∩ B ) ) ;;
	step 11 : wff = resundir () |- ( ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ↾ B ) = ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) ∪ ( ( G ↾ ( B ∖ A ) ) ↾ B ) ) ;;
	step 12 : wff = uneq12i (step 10, step 11) |- ( ( ( F ↾ ( A ∩ B ) ) ↾ B ) ∪ ( ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ↾ B ) ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) ∪ ( ( G ↾ ( B ∖ A ) ) ↾ B ) ) ) ;;
	step 13 : wff = dmres () |- dom ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ( B ∩ dom ( F ↾ ( A ∖ B ) ) ) ;;
	step 14 : wff = dmres () |- dom ( F ↾ ( A ∖ B ) ) = ( ( A ∖ B ) ∩ dom F ) ;;
	step 15 : wff = ineq2i (step 14) |- ( B ∩ dom ( F ↾ ( A ∖ B ) ) ) = ( B ∩ ( ( A ∖ B ) ∩ dom F ) ) ;;
	step 16 : wff = disjdif () |- ( B ∩ ( A ∖ B ) ) = ∅ ;;
	step 17 : wff = ineq1i (step 16) |- ( ( B ∩ ( A ∖ B ) ) ∩ dom F ) = ( ∅ ∩ dom F ) ;;
	step 18 : wff = inass () |- ( ( B ∩ ( A ∖ B ) ) ∩ dom F ) = ( B ∩ ( ( A ∖ B ) ∩ dom F ) ) ;;
	step 19 : wff = inss1 () |- ( ∅ ∩ dom F ) ⊆ ∅ ;;
	step 20 : wff = 0ss () |- ∅ ⊆ ( ∅ ∩ dom F ) ;;
	step 21 : wff = eqssi (step 19, step 20) |- ( ∅ ∩ dom F ) = ∅ ;;
	step 22 : wff = 3eqtr3i (step 17, step 18, step 21) |- ( B ∩ ( ( A ∖ B ) ∩ dom F ) ) = ∅ ;;
	step 23 : wff = eqtri (step 15, step 22) |- ( B ∩ dom ( F ↾ ( A ∖ B ) ) ) = ∅ ;;
	step 24 : wff = eqtri (step 13, step 23) |- dom ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ∅ ;;
	step 25 : wff = relres () |- Rel ( ( F ↾ ( A ∖ B ) ) ↾ B ) ;;
	step 26 : wff = reldm0 () |- ( Rel ( ( F ↾ ( A ∖ B ) ) ↾ B ) → ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ∅ ↔ dom ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ∅ ) ) ;;
	step 27 : wff = ax-mp (step 25, step 26) |- ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ∅ ↔ dom ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ∅ ) ;;
	step 28 : wff = mpbir (step 24, step 27) |- ( ( F ↾ ( A ∖ B ) ) ↾ B ) = ∅ ;;
	step 29 : wff = difss () |- ( B ∖ A ) ⊆ B ;;
	step 30 : wff = resabs2 () |- ( ( B ∖ A ) ⊆ B → ( ( G ↾ ( B ∖ A ) ) ↾ B ) = ( G ↾ ( B ∖ A ) ) ) ;;
	step 31 : wff = ax-mp (step 29, step 30) |- ( ( G ↾ ( B ∖ A ) ) ↾ B ) = ( G ↾ ( B ∖ A ) ) ;;
	step 32 : wff = uneq12i (step 28, step 31) |- ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) ∪ ( ( G ↾ ( B ∖ A ) ) ↾ B ) ) = ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ;;
	step 33 : wff = uneq2i (step 32) |- ( ( F ↾ ( A ∩ B ) ) ∪ ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) ∪ ( ( G ↾ ( B ∖ A ) ) ↾ B ) ) ) = ( ( F ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) ;;
	step 34 : wff = simp3 () |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) ;;
	step 35 : wff = uneq1d (step 34) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) = ( ( G ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) ) ;;
	step 36 : wff = uncom () |- ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) = ( ( G ↾ ( B ∖ A ) ) ∪ ∅ ) ;;
	step 37 : wff = un0 () |- ( ( G ↾ ( B ∖ A ) ) ∪ ∅ ) = ( G ↾ ( B ∖ A ) ) ;;
	step 38 : wff = eqtri (step 36, step 37) |- ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) = ( G ↾ ( B ∖ A ) ) ;;
	step 39 : wff = uneq2i (step 38) |- ( ( G ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) = ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ;;
	step 40 : wff = resundi () |- ( G ↾ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) = ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ;;
	step 41 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 42 : wff = uneq1i (step 41) |- ( ( A ∩ B ) ∪ ( B ∖ A ) ) = ( ( B ∩ A ) ∪ ( B ∖ A ) ) ;;
	step 43 : wff = inundif () |- ( ( B ∩ A ) ∪ ( B ∖ A ) ) = B ;;
	step 44 : wff = eqtri (step 42, step 43) |- ( ( A ∩ B ) ∪ ( B ∖ A ) ) = B ;;
	step 45 : wff = reseq2i (step 44) |- ( G ↾ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) = ( G ↾ B ) ;;
	step 46 : wff = ffn () |- ( G : B ⟶ C → G Fn B ) ;;
	step 47 : wff = fnresdm () |- ( G Fn B → ( G ↾ B ) = G ) ;;
	step 48 : wff = syl (step 46, step 47) |- ( G : B ⟶ C → ( G ↾ B ) = G ) ;;
	step 49 : wff = adantl (step 48) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ) → ( G ↾ B ) = G ) ;;
	step 50 : wff = syl5eq (step 45, step 49) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ) → ( G ↾ ( ( A ∩ B ) ∪ ( B ∖ A ) ) ) = G ) ;;
	step 51 : wff = syl5eqr (step 40, step 50) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ) → ( ( G ↾ ( A ∩ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) = G ) ;;
	step 52 : wff = syl5eq (step 39, step 51) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ) → ( ( G ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) = G ) ;;
	step 53 : wff = 3adant3 (step 52) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( G ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) = G ) ;;
	step 54 : wff = eqtrd (step 35, step 53) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ ( A ∩ B ) ) ∪ ( ∅ ∪ ( G ↾ ( B ∖ A ) ) ) ) = G ) ;;
	step 55 : wff = syl5eq (step 33, step 54) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ↾ ( A ∩ B ) ) ∪ ( ( ( F ↾ ( A ∖ B ) ) ↾ B ) ∪ ( ( G ↾ ( B ∖ A ) ) ↾ B ) ) ) = G ) ;;
	step 56 : wff = syl5eq (step 12, step 55) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( ( F ↾ ( A ∩ B ) ) ↾ B ) ∪ ( ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ↾ B ) ) = G ) ;;
	step 57 : wff = syl5eq (step 7, step 56) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( ( F ↾ ( A ∩ B ) ) ∪ ( ( F ↾ ( A ∖ B ) ) ∪ ( G ↾ ( B ∖ A ) ) ) ) ↾ B ) = G ) ;;
	step 58 : wff = eqtrd (step 6, step 57) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ∪ G ) ↾ B ) = G ) ;;
	qed prop 1 = step 58 ;;
}

/*From the union of two functions that agree on the domain overlap, either
     component can be recovered by restriction.  (Contributed by Mario
     Carneiro, 16-Feb-2015.) */

theorem fresaunres1 (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ∪ G ) ↾ A ) = F ) ;;
}

proof of fresaunres1 {
	step 1 : wff = uncom () |- ( F ∪ G ) = ( G ∪ F ) ;;
	step 2 : wff = reseq1i (step 1) |- ( ( F ∪ G ) ↾ A ) = ( ( G ∪ F ) ↾ A ) ;;
	step 3 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 4 : wff = reseq2i (step 3) |- ( F ↾ ( A ∩ B ) ) = ( F ↾ ( B ∩ A ) ) ;;
	step 5 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 6 : wff = reseq2i (step 5) |- ( G ↾ ( A ∩ B ) ) = ( G ↾ ( B ∩ A ) ) ;;
	step 7 : wff = eqeq12i (step 4, step 6) |- ( ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ↔ ( F ↾ ( B ∩ A ) ) = ( G ↾ ( B ∩ A ) ) ) ;;
	step 8 : wff = eqcom () |- ( ( F ↾ ( B ∩ A ) ) = ( G ↾ ( B ∩ A ) ) ↔ ( G ↾ ( B ∩ A ) ) = ( F ↾ ( B ∩ A ) ) ) ;;
	step 9 : wff = bitri (step 7, step 8) |- ( ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ↔ ( G ↾ ( B ∩ A ) ) = ( F ↾ ( B ∩ A ) ) ) ;;
	step 10 : wff = fresaunres2 () |- ( ( G : B ⟶ C ∧ F : A ⟶ C ∧ ( G ↾ ( B ∩ A ) ) = ( F ↾ ( B ∩ A ) ) ) → ( ( G ∪ F ) ↾ A ) = F ) ;;
	step 11 : wff = 3com12 (step 10) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( G ↾ ( B ∩ A ) ) = ( F ↾ ( B ∩ A ) ) ) → ( ( G ∪ F ) ↾ A ) = F ) ;;
	step 12 : wff = syl3an3b (step 9, step 11) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( G ∪ F ) ↾ A ) = F ) ;;
	step 13 : wff = syl5eq (step 2, step 12) |- ( ( F : A ⟶ C ∧ G : B ⟶ C ∧ ( F ↾ ( A ∩ B ) ) = ( G ↾ ( A ∩ B ) ) ) → ( ( F ∪ G ) ↾ A ) = F ) ;;
	qed prop 1 = step 13 ;;
}

/*Composition of a mapping and restricted identity.  (Contributed by NM,
       13-Dec-2003.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fcoi1 (A : class, B : class, F : class) disjointed(A, B, F) {
	prop 1 : wff = |- ( F : A ⟶ B → ( F ∘ ( _I ↾ A ) ) = F ) ;;
}

proof of fcoi1 {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 3 : wff = eqimss () |- ( dom F = A → dom F ⊆ A ) ;;
	step 4 : wff = cnvi () |- ⁻¹ _I = _I ;;
	step 5 : wff = reseq1i (step 4) |- ( ⁻¹ _I ↾ A ) = ( _I ↾ A ) ;;
	step 6 : wff = cnveqi (step 5) |- ⁻¹ ( ⁻¹ _I ↾ A ) = ⁻¹ ( _I ↾ A ) ;;
	step 7 : wff = cnvresid () |- ⁻¹ ( _I ↾ A ) = ( _I ↾ A ) ;;
	step 8 : wff = eqtr2i (step 6, step 7) |- ( _I ↾ A ) = ⁻¹ ( ⁻¹ _I ↾ A ) ;;
	step 9 : wff = coeq2i (step 8) |- ( F ∘ ( _I ↾ A ) ) = ( F ∘ ⁻¹ ( ⁻¹ _I ↾ A ) ) ;;
	step 10 : wff = cores2 () |- ( dom F ⊆ A → ( F ∘ ⁻¹ ( ⁻¹ _I ↾ A ) ) = ( F ∘ _I ) ) ;;
	step 11 : wff = syl5eq (step 9, step 10) |- ( dom F ⊆ A → ( F ∘ ( _I ↾ A ) ) = ( F ∘ _I ) ) ;;
	step 12 : wff = syl (step 3, step 11) |- ( dom F = A → ( F ∘ ( _I ↾ A ) ) = ( F ∘ _I ) ) ;;
	step 13 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 14 : wff = coi1 () |- ( Rel F → ( F ∘ _I ) = F ) ;;
	step 15 : wff = syl (step 13, step 14) |- ( Fun F → ( F ∘ _I ) = F ) ;;
	step 16 : wff = sylan9eqr (step 12, step 15) |- ( ( Fun F ∧ dom F = A ) → ( F ∘ ( _I ↾ A ) ) = F ) ;;
	step 17 : wff = sylbi (step 2, step 16) |- ( F Fn A → ( F ∘ ( _I ↾ A ) ) = F ) ;;
	step 18 : wff = syl (step 1, step 17) |- ( F : A ⟶ B → ( F ∘ ( _I ↾ A ) ) = F ) ;;
	qed prop 1 = step 18 ;;
}

/*Composition of restricted identity and a mapping.  (Contributed by NM,
       13-Dec-2003.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fcoi2 (A : class, B : class, F : class) disjointed(A, B, F) {
	prop 1 : wff = |- ( F : A ⟶ B → ( ( _I ↾ B ) ∘ F ) = F ) ;;
}

proof of fcoi2 {
	step 1 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 2 : wff = cores () |- ( ran F ⊆ B → ( ( _I ↾ B ) ∘ F ) = ( _I ∘ F ) ) ;;
	step 3 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 4 : wff = coi2 () |- ( Rel F → ( _I ∘ F ) = F ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( F Fn A → ( _I ∘ F ) = F ) ;;
	step 6 : wff = sylan9eqr (step 2, step 5) |- ( ( F Fn A ∧ ran F ⊆ B ) → ( ( _I ↾ B ) ∘ F ) = F ) ;;
	step 7 : wff = sylbi (step 1, step 6) |- ( F : A ⟶ B → ( ( _I ↾ B ) ∘ F ) = F ) ;;
	qed prop 1 = step 7 ;;
}

/*There is exactly one value of a function in its codomain.  (Contributed
       by NM, 10-Dec-2003.) */

theorem feu (y : set, A : class, B : class, C : class, F : class) disjointed(y F, y A, y B, y C) {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ C ∈ A ) → ∃! y ∈ B 〈 C , y 〉 ∈ F ) ;;
}

proof of feu {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fneu2 () |- ( ( F Fn A ∧ C ∈ A ) → ∃! y 〈 C , y 〉 ∈ F ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ∃! y 〈 C , y 〉 ∈ F ) ;;
	step 4 : wff = opelf () |- ( ( F : A ⟶ B ∧ 〈 C , y 〉 ∈ F ) → ( C ∈ A ∧ y ∈ B ) ) ;;
	step 5 : wff = simprd (step 4) |- ( ( F : A ⟶ B ∧ 〈 C , y 〉 ∈ F ) → y ∈ B ) ;;
	step 6 : wff = ex (step 5) |- ( F : A ⟶ B → ( 〈 C , y 〉 ∈ F → y ∈ B ) ) ;;
	step 7 : wff = pm4.71rd (step 6) |- ( F : A ⟶ B → ( 〈 C , y 〉 ∈ F ↔ ( y ∈ B ∧ 〈 C , y 〉 ∈ F ) ) ) ;;
	step 8 : wff = eubidv (step 7) |- ( F : A ⟶ B → ( ∃! y 〈 C , y 〉 ∈ F ↔ ∃! y ( y ∈ B ∧ 〈 C , y 〉 ∈ F ) ) ) ;;
	step 9 : wff = adantr (step 8) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( ∃! y 〈 C , y 〉 ∈ F ↔ ∃! y ( y ∈ B ∧ 〈 C , y 〉 ∈ F ) ) ) ;;
	step 10 : wff = mpbid (step 3, step 9) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ∃! y ( y ∈ B ∧ 〈 C , y 〉 ∈ F ) ) ;;
	step 11 : wff = df-reu () |- ( ∃! y ∈ B 〈 C , y 〉 ∈ F ↔ ∃! y ( y ∈ B ∧ 〈 C , y 〉 ∈ F ) ) ;;
	step 12 : wff = sylibr (step 10, step 11) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ∃! y ∈ B 〈 C , y 〉 ∈ F ) ;;
	qed prop 1 = step 12 ;;
}

/*The converse of a restriction of a function.  (Contributed by NM,
       26-Mar-1998.) */

theorem fcnvres (A : class, B : class, F : class) disjointed(x y F, x y A, x y B) {
	prop 1 : wff = |- ( F : A ⟶ B → ⁻¹ ( F ↾ A ) = ( ⁻¹ F ↾ B ) ) ;;
}

proof of fcnvres {
	var x : set, y : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ ( F ↾ A ) ;;
	step 2 : wff = relres () |- Rel ( ⁻¹ F ↾ B ) ;;
	step 3 : wff = opelf () |- ( ( F : A ⟶ B ∧ 〈 x , y 〉 ∈ F ) → ( x ∈ A ∧ y ∈ B ) ) ;;
	step 4 : wff = simpld (step 3) |- ( ( F : A ⟶ B ∧ 〈 x , y 〉 ∈ F ) → x ∈ A ) ;;
	step 5 : wff = ex (step 4) |- ( F : A ⟶ B → ( 〈 x , y 〉 ∈ F → x ∈ A ) ) ;;
	step 6 : wff = pm4.71d (step 5) |- ( F : A ⟶ B → ( 〈 x , y 〉 ∈ F ↔ ( 〈 x , y 〉 ∈ F ∧ x ∈ A ) ) ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = opelcnv (step 7, step 8) |- ( 〈 y , x 〉 ∈ ⁻¹ ( F ↾ A ) ↔ 〈 x , y 〉 ∈ ( F ↾ A ) ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = opelres (step 10) |- ( 〈 x , y 〉 ∈ ( F ↾ A ) ↔ ( 〈 x , y 〉 ∈ F ∧ x ∈ A ) ) ;;
	step 12 : wff = bitri (step 9, step 11) |- ( 〈 y , x 〉 ∈ ⁻¹ ( F ↾ A ) ↔ ( 〈 x , y 〉 ∈ F ∧ x ∈ A ) ) ;;
	step 13 : wff = syl6bbr (step 6, step 12) |- ( F : A ⟶ B → ( 〈 x , y 〉 ∈ F ↔ 〈 y , x 〉 ∈ ⁻¹ ( F ↾ A ) ) ) ;;
	step 14 : wff = opelf () |- ( ( F : A ⟶ B ∧ 〈 x , y 〉 ∈ F ) → ( x ∈ A ∧ y ∈ B ) ) ;;
	step 15 : wff = simprd (step 14) |- ( ( F : A ⟶ B ∧ 〈 x , y 〉 ∈ F ) → y ∈ B ) ;;
	step 16 : wff = ex (step 15) |- ( F : A ⟶ B → ( 〈 x , y 〉 ∈ F → y ∈ B ) ) ;;
	step 17 : wff = pm4.71d (step 16) |- ( F : A ⟶ B → ( 〈 x , y 〉 ∈ F ↔ ( 〈 x , y 〉 ∈ F ∧ y ∈ B ) ) ) ;;
	step 18 : wff = vex () |- x ∈ _V ;;
	step 19 : wff = opelres (step 18) |- ( 〈 y , x 〉 ∈ ( ⁻¹ F ↾ B ) ↔ ( 〈 y , x 〉 ∈ ⁻¹ F ∧ y ∈ B ) ) ;;
	step 20 : wff = vex () |- y ∈ _V ;;
	step 21 : wff = vex () |- x ∈ _V ;;
	step 22 : wff = opelcnv (step 20, step 21) |- ( 〈 y , x 〉 ∈ ⁻¹ F ↔ 〈 x , y 〉 ∈ F ) ;;
	step 23 : wff = anbi1i (step 22) |- ( ( 〈 y , x 〉 ∈ ⁻¹ F ∧ y ∈ B ) ↔ ( 〈 x , y 〉 ∈ F ∧ y ∈ B ) ) ;;
	step 24 : wff = bitri (step 19, step 23) |- ( 〈 y , x 〉 ∈ ( ⁻¹ F ↾ B ) ↔ ( 〈 x , y 〉 ∈ F ∧ y ∈ B ) ) ;;
	step 25 : wff = syl6bbr (step 17, step 24) |- ( F : A ⟶ B → ( 〈 x , y 〉 ∈ F ↔ 〈 y , x 〉 ∈ ( ⁻¹ F ↾ B ) ) ) ;;
	step 26 : wff = bitr3d (step 13, step 25) |- ( F : A ⟶ B → ( 〈 y , x 〉 ∈ ⁻¹ ( F ↾ A ) ↔ 〈 y , x 〉 ∈ ( ⁻¹ F ↾ B ) ) ) ;;
	step 27 : wff = eqrelrdv (step 1, step 2, step 26) |- ( F : A ⟶ B → ⁻¹ ( F ↾ A ) = ( ⁻¹ F ↾ B ) ) ;;
	qed prop 1 = step 27 ;;
}

/*The preimage of a class disjoint with a mapping's codomain is empty.
     (Contributed by FL, 24-Jan-2007.) */

theorem fimacnvdisj (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ ( B ∩ C ) = ∅ ) → ( ⁻¹ F " C ) = ∅ ) ;;
}

proof of fimacnvdisj {
	step 1 : wff = df-rn () |- ran F = dom ⁻¹ F ;;
	step 2 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 3 : wff = adantr (step 2) |- ( ( F : A ⟶ B ∧ ( B ∩ C ) = ∅ ) → ran F ⊆ B ) ;;
	step 4 : wff = syl5eqssr (step 1, step 3) |- ( ( F : A ⟶ B ∧ ( B ∩ C ) = ∅ ) → dom ⁻¹ F ⊆ B ) ;;
	step 5 : wff = ssdisj () |- ( ( dom ⁻¹ F ⊆ B ∧ ( B ∩ C ) = ∅ ) → ( dom ⁻¹ F ∩ C ) = ∅ ) ;;
	step 6 : wff = sylancom (step 4, step 5) |- ( ( F : A ⟶ B ∧ ( B ∩ C ) = ∅ ) → ( dom ⁻¹ F ∩ C ) = ∅ ) ;;
	step 7 : wff = imadisj () |- ( ( ⁻¹ F " C ) = ∅ ↔ ( dom ⁻¹ F ∩ C ) = ∅ ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( F : A ⟶ B ∧ ( B ∩ C ) = ∅ ) → ( ⁻¹ F " C ) = ∅ ) ;;
	qed prop 1 = step 8 ;;
}

/*Function into an intersection.  (Contributed by NM, 14-Oct-1999.)
       (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fint (x : set, A : class, B : class, F : class) disjointed(x A, x B, x, x F) {
	hyp 1 : wff = |- B ≠ ∅ ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ ⋂ B ↔ ∀ x ∈ B F : A ⟶ x ) ;;
}

proof of fint {
	step 1 : wff = ssint () |- ( ran F ⊆ ⋂ B ↔ ∀ x ∈ B ran F ⊆ x ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( F Fn A ∧ ran F ⊆ ⋂ B ) ↔ ( F Fn A ∧ ∀ x ∈ B ran F ⊆ x ) ) ;;
	step 3 : wff = r19.28zv () |- ( B ≠ ∅ → ( ∀ x ∈ B ( F Fn A ∧ ran F ⊆ x ) ↔ ( F Fn A ∧ ∀ x ∈ B ran F ⊆ x ) ) ) ;;
	step 4 : wff = ax-mp (hyp 1, step 3) |- ( ∀ x ∈ B ( F Fn A ∧ ran F ⊆ x ) ↔ ( F Fn A ∧ ∀ x ∈ B ran F ⊆ x ) ) ;;
	step 5 : wff = bitr4i (step 2, step 4) |- ( ( F Fn A ∧ ran F ⊆ ⋂ B ) ↔ ∀ x ∈ B ( F Fn A ∧ ran F ⊆ x ) ) ;;
	step 6 : wff = df-f () |- ( F : A ⟶ ⋂ B ↔ ( F Fn A ∧ ran F ⊆ ⋂ B ) ) ;;
	step 7 : wff = df-f () |- ( F : A ⟶ x ↔ ( F Fn A ∧ ran F ⊆ x ) ) ;;
	step 8 : wff = ralbii (step 7) |- ( ∀ x ∈ B F : A ⟶ x ↔ ∀ x ∈ B ( F Fn A ∧ ran F ⊆ x ) ) ;;
	step 9 : wff = 3bitr4i (step 5, step 6, step 8) |- ( F : A ⟶ ⋂ B ↔ ∀ x ∈ B F : A ⟶ x ) ;;
	qed prop 1 = step 9 ;;
}

/*Mapping into an intersection.  (Contributed by NM, 14-Sep-1999.)  (Proof
     shortened by Andrew Salmon, 17-Sep-2011.) */

theorem fin (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ ( B ∩ C ) ↔ ( F : A ⟶ B ∧ F : A ⟶ C ) ) ;;
}

proof of fin {
	step 1 : wff = ssin () |- ( ( ran F ⊆ B ∧ ran F ⊆ C ) ↔ ran F ⊆ ( B ∩ C ) ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( F Fn A ∧ ( ran F ⊆ B ∧ ran F ⊆ C ) ) ↔ ( F Fn A ∧ ran F ⊆ ( B ∩ C ) ) ) ;;
	step 3 : wff = anandi () |- ( ( F Fn A ∧ ( ran F ⊆ B ∧ ran F ⊆ C ) ) ↔ ( ( F Fn A ∧ ran F ⊆ B ) ∧ ( F Fn A ∧ ran F ⊆ C ) ) ) ;;
	step 4 : wff = bitr3i (step 2, step 3) |- ( ( F Fn A ∧ ran F ⊆ ( B ∩ C ) ) ↔ ( ( F Fn A ∧ ran F ⊆ B ) ∧ ( F Fn A ∧ ran F ⊆ C ) ) ) ;;
	step 5 : wff = df-f () |- ( F : A ⟶ ( B ∩ C ) ↔ ( F Fn A ∧ ran F ⊆ ( B ∩ C ) ) ) ;;
	step 6 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 7 : wff = df-f () |- ( F : A ⟶ C ↔ ( F Fn A ∧ ran F ⊆ C ) ) ;;
	step 8 : wff = anbi12i (step 6, step 7) |- ( ( F : A ⟶ B ∧ F : A ⟶ C ) ↔ ( ( F Fn A ∧ ran F ⊆ B ) ∧ ( F Fn A ∧ ran F ⊆ C ) ) ) ;;
	step 9 : wff = 3bitr4i (step 4, step 5, step 8) |- ( F : A ⟶ ( B ∩ C ) ↔ ( F : A ⟶ B ∧ F : A ⟶ C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Existence of a set of functions.  (Contributed by Paul Chapman,
       25-Feb-2008.) */

theorem fabexg (ph : wff, x : set, A : class, B : class, C : class, D : class, F : class) disjointed(A x, B x) {
	hyp 1 : wff = |- F = { x | ( x : A ⟶ B ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → F ∈ _V ) ;;
}

proof of fabexg {
	step 1 : wff = xpexg () |- ( ( A ∈ C ∧ B ∈ D ) → ( A × B ) ∈ _V ) ;;
	step 2 : wff = pwexg () |- ( ( A × B ) ∈ _V → Pow ( A × B ) ∈ _V ) ;;
	step 3 : wff = fssxp () |- ( x : A ⟶ B → x ⊆ ( A × B ) ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = elpw (step 4) |- ( x ∈ Pow ( A × B ) ↔ x ⊆ ( A × B ) ) ;;
	step 6 : wff = sylibr (step 3, step 5) |- ( x : A ⟶ B → x ∈ Pow ( A × B ) ) ;;
	step 7 : wff = anim1i (step 6) |- ( ( x : A ⟶ B ∧ ph ) → ( x ∈ Pow ( A × B ) ∧ ph ) ) ;;
	step 8 : wff = ss2abi (step 7) |- { x | ( x : A ⟶ B ∧ ph ) } ⊆ { x | ( x ∈ Pow ( A × B ) ∧ ph ) } ;;
	step 9 : wff = eqsstri (hyp 1, step 8) |- F ⊆ { x | ( x ∈ Pow ( A × B ) ∧ ph ) } ;;
	step 10 : wff = ssab2 () |- { x | ( x ∈ Pow ( A × B ) ∧ ph ) } ⊆ Pow ( A × B ) ;;
	step 11 : wff = sstri (step 9, step 10) |- F ⊆ Pow ( A × B ) ;;
	step 12 : wff = ssexg () |- ( ( F ⊆ Pow ( A × B ) ∧ Pow ( A × B ) ∈ _V ) → F ∈ _V ) ;;
	step 13 : wff = mpan (step 11, step 12) |- ( Pow ( A × B ) ∈ _V → F ∈ _V ) ;;
	step 14 : wff = 3syl (step 1, step 2, step 13) |- ( ( A ∈ C ∧ B ∈ D ) → F ∈ _V ) ;;
	qed prop 1 = step 14 ;;
}

/*Existence of a set of functions.  (Contributed by NM, 3-Dec-2007.) */

theorem fabex (ph : wff, x : set, A : class, B : class, F : class) disjointed(x A, x B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- F = { x | ( x : A ⟶ B ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- F ∈ _V ;;
}

proof of fabex {
	step 1 : wff = fabexg (hyp 3) |- ( ( A ∈ _V ∧ B ∈ _V ) → F ∈ _V ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- F ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*If a mapping is a set, its domain is a set.  (Contributed by NM,
     27-Aug-2006.)  (Proof shortened by Andrew Salmon, 17-Sep-2011.) */

theorem dmfex (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F ∈ C ∧ F : A ⟶ B ) → A ∈ _V ) ;;
}

proof of dmfex {
	step 1 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 2 : wff = dmexg () |- ( F ∈ C → dom F ∈ _V ) ;;
	step 3 : wff = eleq1 () |- ( dom F = A → ( dom F ∈ _V ↔ A ∈ _V ) ) ;;
	step 4 : wff = syl5ib (step 2, step 3) |- ( dom F = A → ( F ∈ C → A ∈ _V ) ) ;;
	step 5 : wff = syl (step 1, step 4) |- ( F : A ⟶ B → ( F ∈ C → A ∈ _V ) ) ;;
	step 6 : wff = impcom (step 5) |- ( ( F ∈ C ∧ F : A ⟶ B ) → A ∈ _V ) ;;
	qed prop 1 = step 6 ;;
}

/*The empty function.  (Contributed by NM, 14-Aug-1999.) */

theorem f0 (A : class)  {
	prop 1 : wff = |- ∅ : ∅ ⟶ A ;;
}

proof of f0 {
	step 1 : wff = eqid () |- ∅ = ∅ ;;
	step 2 : wff = fn0 () |- ( ∅ Fn ∅ ↔ ∅ = ∅ ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- ∅ Fn ∅ ;;
	step 4 : wff = rn0 () |- ran ∅ = ∅ ;;
	step 5 : wff = 0ss () |- ∅ ⊆ A ;;
	step 6 : wff = eqsstri (step 4, step 5) |- ran ∅ ⊆ A ;;
	step 7 : wff = df-f () |- ( ∅ : ∅ ⟶ A ↔ ( ∅ Fn ∅ ∧ ran ∅ ⊆ A ) ) ;;
	step 8 : wff = mpbir2an (step 3, step 6, step 7) |- ∅ : ∅ ⟶ A ;;
	qed prop 1 = step 8 ;;
}

/*A class is a function with empty codomain iff it and its domain are
     empty.  (Contributed by NM, 10-Dec-2003.) */

theorem f00 (A : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ ∅ ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
}

proof of f00 {
	step 1 : wff = ffun () |- ( F : A ⟶ ∅ → Fun F ) ;;
	step 2 : wff = frn () |- ( F : A ⟶ ∅ → ran F ⊆ ∅ ) ;;
	step 3 : wff = ss0 () |- ( ran F ⊆ ∅ → ran F = ∅ ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( F : A ⟶ ∅ → ran F = ∅ ) ;;
	step 5 : wff = dm0rn0 () |- ( dom F = ∅ ↔ ran F = ∅ ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( F : A ⟶ ∅ → dom F = ∅ ) ;;
	step 7 : wff = df-fn () |- ( F Fn ∅ ↔ ( Fun F ∧ dom F = ∅ ) ) ;;
	step 8 : wff = sylanbrc (step 1, step 6, step 7) |- ( F : A ⟶ ∅ → F Fn ∅ ) ;;
	step 9 : wff = fn0 () |- ( F Fn ∅ ↔ F = ∅ ) ;;
	step 10 : wff = sylib (step 8, step 9) |- ( F : A ⟶ ∅ → F = ∅ ) ;;
	step 11 : wff = fdm () |- ( F : A ⟶ ∅ → dom F = A ) ;;
	step 12 : wff = frn () |- ( F : A ⟶ ∅ → ran F ⊆ ∅ ) ;;
	step 13 : wff = ss0 () |- ( ran F ⊆ ∅ → ran F = ∅ ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( F : A ⟶ ∅ → ran F = ∅ ) ;;
	step 15 : wff = dm0rn0 () |- ( dom F = ∅ ↔ ran F = ∅ ) ;;
	step 16 : wff = sylibr (step 14, step 15) |- ( F : A ⟶ ∅ → dom F = ∅ ) ;;
	step 17 : wff = eqtr3d (step 11, step 16) |- ( F : A ⟶ ∅ → A = ∅ ) ;;
	step 18 : wff = jca (step 10, step 17) |- ( F : A ⟶ ∅ → ( F = ∅ ∧ A = ∅ ) ) ;;
	step 19 : wff = f0 () |- ∅ : ∅ ⟶ ∅ ;;
	step 20 : wff = feq1 () |- ( F = ∅ → ( F : A ⟶ ∅ ↔ ∅ : A ⟶ ∅ ) ) ;;
	step 21 : wff = feq2 () |- ( A = ∅ → ( ∅ : A ⟶ ∅ ↔ ∅ : ∅ ⟶ ∅ ) ) ;;
	step 22 : wff = sylan9bb (step 20, step 21) |- ( ( F = ∅ ∧ A = ∅ ) → ( F : A ⟶ ∅ ↔ ∅ : ∅ ⟶ ∅ ) ) ;;
	step 23 : wff = mpbiri (step 19, step 22) |- ( ( F = ∅ ∧ A = ∅ ) → F : A ⟶ ∅ ) ;;
	step 24 : wff = impbii (step 18, step 23) |- ( F : A ⟶ ∅ ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
	qed prop 1 = step 24 ;;
}

/*A cross product with a singleton is a constant function.  (Contributed
       by NM, 14-Aug-1999.)  (Proof shortened by Andrew Salmon,
       17-Sep-2011.) */

theorem fconst (A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A × { B } ) : A ⟶ { B } ;;
}

proof of fconst {
	var x : set;;
	step 1 : wff = fconstmpt () |- ( A × { B } ) = ( x ∈ A ↦ B ) ;;
	step 2 : wff = fnmpti (hyp 1, step 1) |- ( A × { B } ) Fn A ;;
	step 3 : wff = rnxpss () |- ran ( A × { B } ) ⊆ { B } ;;
	step 4 : wff = df-f () |- ( ( A × { B } ) : A ⟶ { B } ↔ ( ( A × { B } ) Fn A ∧ ran ( A × { B } ) ⊆ { B } ) ) ;;
	step 5 : wff = mpbir2an (step 2, step 3, step 4) |- ( A × { B } ) : A ⟶ { B } ;;
	qed prop 1 = step 5 ;;
}

/*A cross product with a singleton is a constant function.  (Contributed
       by NM, 19-Oct-2004.) */

theorem fconstg (A : class, B : class, V : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( B ∈ V → ( A × { B } ) : A ⟶ { B } ) ;;
}

proof of fconstg {
	var x : set;;
	step 1 : wff = sneq () |- ( x = B → { x } = { B } ) ;;
	step 2 : wff = xpeq2d (step 1) |- ( x = B → ( A × { x } ) = ( A × { B } ) ) ;;
	step 3 : wff = sneq () |- ( x = B → { x } = { B } ) ;;
	step 4 : wff = feq1 () |- ( ( A × { x } ) = ( A × { B } ) → ( ( A × { x } ) : A ⟶ { x } ↔ ( A × { B } ) : A ⟶ { x } ) ) ;;
	step 5 : wff = feq3 () |- ( { x } = { B } → ( ( A × { B } ) : A ⟶ { x } ↔ ( A × { B } ) : A ⟶ { B } ) ) ;;
	step 6 : wff = sylan9bb (step 4, step 5) |- ( ( ( A × { x } ) = ( A × { B } ) ∧ { x } = { B } ) → ( ( A × { x } ) : A ⟶ { x } ↔ ( A × { B } ) : A ⟶ { B } ) ) ;;
	step 7 : wff = syl2anc (step 2, step 3, step 6) |- ( x = B → ( ( A × { x } ) : A ⟶ { x } ↔ ( A × { B } ) : A ⟶ { B } ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = fconst (step 8) |- ( A × { x } ) : A ⟶ { x } ;;
	step 10 : wff = vtoclg (step 7, step 9) |- ( B ∈ V → ( A × { B } ) : A ⟶ { B } ) ;;
	qed prop 1 = step 10 ;;
}

/*A cross product with a singleton is a constant function.  (Contributed by
     NM, 24-Jul-2014.) */

theorem fnconstg (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( B ∈ V → ( A × { B } ) Fn A ) ;;
}

proof of fnconstg {
	step 1 : wff = fconstg () |- ( B ∈ V → ( A × { B } ) : A ⟶ { B } ) ;;
	step 2 : wff = ffn () |- ( ( A × { B } ) : A ⟶ { B } → ( A × { B } ) Fn A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( B ∈ V → ( A × { B } ) Fn A ) ;;
	qed prop 1 = step 3 ;;
}

/*Constant function with loose range.  (Contributed by Stefan O'Rear,
     1-Feb-2015.) */

theorem fconst6g (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( B ∈ C → ( A × { B } ) : A ⟶ C ) ;;
}

proof of fconst6g {
	step 1 : wff = fconstg () |- ( B ∈ C → ( A × { B } ) : A ⟶ { B } ) ;;
	step 2 : wff = snssi () |- ( B ∈ C → { B } ⊆ C ) ;;
	step 3 : wff = fss () |- ( ( ( A × { B } ) : A ⟶ { B } ∧ { B } ⊆ C ) → ( A × { B } ) : A ⟶ C ) ;;
	step 4 : wff = syl2anc (step 1, step 2, step 3) |- ( B ∈ C → ( A × { B } ) : A ⟶ C ) ;;
	qed prop 1 = step 4 ;;
}

/*A constant function as a mapping.  (Contributed by Jeff Madsen,
       30-Nov-2009.)  (Revised by Mario Carneiro, 22-Apr-2015.) */

theorem fconst6 (A : class, B : class, C : class)  {
	hyp 1 : wff = |- B ∈ C ;;
	-----------------------
	prop 1 : wff = |- ( A × { B } ) : A ⟶ C ;;
}

proof of fconst6 {
	step 1 : wff = fconst6g () |- ( B ∈ C → ( A × { B } ) : A ⟶ C ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A × { B } ) : A ⟶ C ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for one-to-one functions.  (Contributed by NM,
     10-Feb-1997.) */

theorem f1eq1 (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( F = G → ( F : A ↣ B ↔ G : A ↣ B ) ) ;;
}

proof of f1eq1 {
	step 1 : wff = feq1 () |- ( F = G → ( F : A ⟶ B ↔ G : A ⟶ B ) ) ;;
	step 2 : wff = cnveq () |- ( F = G → ⁻¹ F = ⁻¹ G ) ;;
	step 3 : wff = funeqd (step 2) |- ( F = G → ( Fun ⁻¹ F ↔ Fun ⁻¹ G ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( F = G → ( ( F : A ⟶ B ∧ Fun ⁻¹ F ) ↔ ( G : A ⟶ B ∧ Fun ⁻¹ G ) ) ) ;;
	step 5 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 6 : wff = df-f1 () |- ( G : A ↣ B ↔ ( G : A ⟶ B ∧ Fun ⁻¹ G ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( F = G → ( F : A ↣ B ↔ G : A ↣ B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for one-to-one functions.  (Contributed by NM,
     10-Feb-1997.) */

theorem f1eq2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : A ↣ C ↔ F : B ↣ C ) ) ;;
}

proof of f1eq2 {
	step 1 : wff = feq2 () |- ( A = B → ( F : A ⟶ C ↔ F : B ⟶ C ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( A = B → ( ( F : A ⟶ C ∧ Fun ⁻¹ F ) ↔ ( F : B ⟶ C ∧ Fun ⁻¹ F ) ) ) ;;
	step 3 : wff = df-f1 () |- ( F : A ↣ C ↔ ( F : A ⟶ C ∧ Fun ⁻¹ F ) ) ;;
	step 4 : wff = df-f1 () |- ( F : B ↣ C ↔ ( F : B ⟶ C ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F : A ↣ C ↔ F : B ↣ C ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for one-to-one functions.  (Contributed by NM,
     10-Feb-1997.) */

theorem f1eq3 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : C ↣ A ↔ F : C ↣ B ) ) ;;
}

proof of f1eq3 {
	step 1 : wff = feq3 () |- ( A = B → ( F : C ⟶ A ↔ F : C ⟶ B ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( A = B → ( ( F : C ⟶ A ∧ Fun ⁻¹ F ) ↔ ( F : C ⟶ B ∧ Fun ⁻¹ F ) ) ) ;;
	step 3 : wff = df-f1 () |- ( F : C ↣ A ↔ ( F : C ⟶ A ∧ Fun ⁻¹ F ) ) ;;
	step 4 : wff = df-f1 () |- ( F : C ↣ B ↔ ( F : C ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F : C ↣ A ↔ F : C ↣ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for a one-to-one function.
       (Contributed by NM, 16-May-2004.) */

theorem nff1 (x : set, A : class, B : class, F : class) disjointed(F, A, B, x) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x A ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x F : A ↣ B ;;
}

proof of nff1 {
	step 1 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 2 : wff = nff (hyp 1, hyp 2, hyp 3) |- F/ x F : A ⟶ B ;;
	step 3 : wff = nfcnv (hyp 1) |- F/_ x ⁻¹ F ;;
	step 4 : wff = nffun (step 3) |- F/ x Fun ⁻¹ F ;;
	step 5 : wff = nfan (step 2, step 4) |- F/ x ( F : A ⟶ B ∧ Fun ⁻¹ F ) ;;
	step 6 : wff = nfxfr (step 1, step 5) |- F/ x F : A ↣ B ;;
	qed prop 1 = step 6 ;;
}

/*Alternate definition of a one-to-one function.  (Contributed by NM,
       31-Dec-1996.) */

theorem dff12 (x : set, y : set, A : class, B : class, F : class) disjointed(x y F) {
	prop 1 : wff = |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ y ∃* x x F y ) ) ;;
}

proof of dff12 {
	step 1 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 2 : wff = funcnv2 () |- ( Fun ⁻¹ F ↔ ∀ y ∃* x x F y ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( F : A ⟶ B ∧ Fun ⁻¹ F ) ↔ ( F : A ⟶ B ∧ ∀ y ∃* x x F y ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ y ∃* x x F y ) ) ;;
	qed prop 1 = step 4 ;;
}

/*A one-to-one mapping is a mapping.  (Contributed by NM, 31-Dec-1996.) */

theorem f1f (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → F : A ⟶ B ) ;;
}

proof of f1f {
	step 1 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( F : A ↣ B → F : A ⟶ B ) ;;
	qed prop 1 = step 2 ;;
}

/*A one-to-one mapping is a function on its domain.  (Contributed by NM,
     8-Mar-2014.) */

theorem f1fn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → F Fn A ) ;;
}

proof of f1fn {
	step 1 : wff = f1f () |- ( F : A ↣ B → F : A ⟶ B ) ;;
	step 2 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → F Fn A ) ;;
	qed prop 1 = step 3 ;;
}

/*A one-to-one mapping is a function.  (Contributed by NM, 8-Mar-2014.) */

theorem f1fun (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → Fun F ) ;;
}

proof of f1fun {
	step 1 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 2 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → Fun F ) ;;
	qed prop 1 = step 3 ;;
}

/*A one-to-one onto mapping is a relation.  (Contributed by NM,
     8-Mar-2014.) */

theorem f1rel (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → Rel F ) ;;
}

proof of f1rel {
	step 1 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 2 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → Rel F ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a one-to-one mapping.  (Contributed by NM, 8-Mar-2014.) */

theorem f1dm (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → dom F = A ) ;;
}

proof of f1dm {
	step 1 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 2 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → dom F = A ) ;;
	qed prop 1 = step 3 ;;
}

/*A function that is one-to-one is also one-to-one on some superset of its
     range.  (Contributed by Mario Carneiro, 12-Jan-2013.) */

theorem f1ss (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ B ⊆ C ) → F : A ↣ C ) ;;
}

proof of f1ss {
	step 1 : wff = f1f () |- ( F : A ↣ B → F : A ⟶ B ) ;;
	step 2 : wff = fss () |- ( ( F : A ⟶ B ∧ B ⊆ C ) → F : A ⟶ C ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F : A ↣ B ∧ B ⊆ C ) → F : A ⟶ C ) ;;
	step 4 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = simprbi (step 4) |- ( F : A ↣ B → Fun ⁻¹ F ) ;;
	step 6 : wff = adantr (step 5) |- ( ( F : A ↣ B ∧ B ⊆ C ) → Fun ⁻¹ F ) ;;
	step 7 : wff = df-f1 () |- ( F : A ↣ C ↔ ( F : A ⟶ C ∧ Fun ⁻¹ F ) ) ;;
	step 8 : wff = sylanbrc (step 3, step 6, step 7) |- ( ( F : A ↣ B ∧ B ⊆ C ) → F : A ↣ C ) ;;
	qed prop 1 = step 8 ;;
}

/*Combine a one-to-one function with a restriction on the domain.
     (Contributed by Stefan O'Rear, 20-Feb-2015.) */

theorem f1ssr (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ ran F ⊆ C ) → F : A ↣ C ) ;;
}

proof of f1ssr {
	step 1 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 2 : wff = adantr (step 1) |- ( ( F : A ↣ B ∧ ran F ⊆ C ) → F Fn A ) ;;
	step 3 : wff = simpr () |- ( ( F : A ↣ B ∧ ran F ⊆ C ) → ran F ⊆ C ) ;;
	step 4 : wff = df-f () |- ( F : A ⟶ C ↔ ( F Fn A ∧ ran F ⊆ C ) ) ;;
	step 5 : wff = sylanbrc (step 2, step 3, step 4) |- ( ( F : A ↣ B ∧ ran F ⊆ C ) → F : A ⟶ C ) ;;
	step 6 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 7 : wff = simprbi (step 6) |- ( F : A ↣ B → Fun ⁻¹ F ) ;;
	step 8 : wff = adantr (step 7) |- ( ( F : A ↣ B ∧ ran F ⊆ C ) → Fun ⁻¹ F ) ;;
	step 9 : wff = df-f1 () |- ( F : A ↣ C ↔ ( F : A ⟶ C ∧ Fun ⁻¹ F ) ) ;;
	step 10 : wff = sylanbrc (step 5, step 8, step 9) |- ( ( F : A ↣ B ∧ ran F ⊆ C ) → F : A ↣ C ) ;;
	qed prop 1 = step 10 ;;
}

/*A function that is one-to-one is also one-to-one on some aubset of its
     domain.  (Contributed by Mario Carneiro, 17-Jan-2015.) */

theorem f1ssres (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ↣ B ) ;;
}

proof of f1ssres {
	step 1 : wff = f1f () |- ( F : A ↣ B → F : A ⟶ B ) ;;
	step 2 : wff = fssres () |- ( ( F : A ⟶ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
	step 4 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = simprbi (step 4) |- ( F : A ↣ B → Fun ⁻¹ F ) ;;
	step 6 : wff = funres11 () |- ( Fun ⁻¹ F → Fun ⁻¹ ( F ↾ C ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( F : A ↣ B → Fun ⁻¹ ( F ↾ C ) ) ;;
	step 8 : wff = adantr (step 7) |- ( ( F : A ↣ B ∧ C ⊆ A ) → Fun ⁻¹ ( F ↾ C ) ) ;;
	step 9 : wff = df-f1 () |- ( ( F ↾ C ) : C ↣ B ↔ ( ( F ↾ C ) : C ⟶ B ∧ Fun ⁻¹ ( F ↾ C ) ) ) ;;
	step 10 : wff = sylanbrc (step 3, step 8, step 9) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ↣ B ) ;;
	qed prop 1 = step 10 ;;
}

/*Two ways to express that a set ` A ` (not necessarily a function) is
     one-to-one.  Each side is equivalent to Definition 6.4(3) of
     [TakeutiZaring] p. 24, who use the notation "Un_2 (A)" for one-to-one.  We
     do not introduce a separate notation since we rarely use it.  (Contributed
     by NM, 13-Aug-2004.) */

theorem f1cnvcnv (A : class)  {
	prop 1 : wff = |- ( ⁻¹ ⁻¹ A : dom A ↣ _V ↔ ( Fun ⁻¹ A ∧ Fun ⁻¹ ⁻¹ A ) ) ;;
}

proof of f1cnvcnv {
	step 1 : wff = df-f1 () |- ( ⁻¹ ⁻¹ A : dom A ↣ _V ↔ ( ⁻¹ ⁻¹ A : dom A ⟶ _V ∧ Fun ⁻¹ ⁻¹ ⁻¹ A ) ) ;;
	step 2 : wff = dffn2 () |- ( ⁻¹ ⁻¹ A Fn dom A ↔ ⁻¹ ⁻¹ A : dom A ⟶ _V ) ;;
	step 3 : wff = dmcnvcnv () |- dom ⁻¹ ⁻¹ A = dom A ;;
	step 4 : wff = df-fn () |- ( ⁻¹ ⁻¹ A Fn dom A ↔ ( Fun ⁻¹ ⁻¹ A ∧ dom ⁻¹ ⁻¹ A = dom A ) ) ;;
	step 5 : wff = mpbiran2 (step 3, step 4) |- ( ⁻¹ ⁻¹ A Fn dom A ↔ Fun ⁻¹ ⁻¹ A ) ;;
	step 6 : wff = bitr3i (step 2, step 5) |- ( ⁻¹ ⁻¹ A : dom A ⟶ _V ↔ Fun ⁻¹ ⁻¹ A ) ;;
	step 7 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 8 : wff = dfrel2 () |- ( Rel ⁻¹ A ↔ ⁻¹ ⁻¹ ⁻¹ A = ⁻¹ A ) ;;
	step 9 : wff = mpbi (step 7, step 8) |- ⁻¹ ⁻¹ ⁻¹ A = ⁻¹ A ;;
	step 10 : wff = funeqi (step 9) |- ( Fun ⁻¹ ⁻¹ ⁻¹ A ↔ Fun ⁻¹ A ) ;;
	step 11 : wff = anbi12ci (step 6, step 10) |- ( ( ⁻¹ ⁻¹ A : dom A ⟶ _V ∧ Fun ⁻¹ ⁻¹ ⁻¹ A ) ↔ ( Fun ⁻¹ A ∧ Fun ⁻¹ ⁻¹ A ) ) ;;
	step 12 : wff = bitri (step 1, step 11) |- ( ⁻¹ ⁻¹ A : dom A ↣ _V ↔ ( Fun ⁻¹ A ∧ Fun ⁻¹ ⁻¹ A ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Composition of one-to-one functions.  Exercise 30 of [TakeutiZaring]
     p. 25.  (Contributed by NM, 28-May-1998.) */

theorem f1co (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : B ↣ C ∧ G : A ↣ B ) → ( F ∘ G ) : A ↣ C ) ;;
}

proof of f1co {
	step 1 : wff = df-f1 () |- ( F : B ↣ C ↔ ( F : B ⟶ C ∧ Fun ⁻¹ F ) ) ;;
	step 2 : wff = df-f1 () |- ( G : A ↣ B ↔ ( G : A ⟶ B ∧ Fun ⁻¹ G ) ) ;;
	step 3 : wff = fco () |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( F ∘ G ) : A ⟶ C ) ;;
	step 4 : wff = funco () |- ( ( Fun ⁻¹ G ∧ Fun ⁻¹ F ) → Fun ( ⁻¹ G ∘ ⁻¹ F ) ) ;;
	step 5 : wff = cnvco () |- ⁻¹ ( F ∘ G ) = ( ⁻¹ G ∘ ⁻¹ F ) ;;
	step 6 : wff = funeqi (step 5) |- ( Fun ⁻¹ ( F ∘ G ) ↔ Fun ( ⁻¹ G ∘ ⁻¹ F ) ) ;;
	step 7 : wff = sylibr (step 4, step 6) |- ( ( Fun ⁻¹ G ∧ Fun ⁻¹ F ) → Fun ⁻¹ ( F ∘ G ) ) ;;
	step 8 : wff = ancoms (step 7) |- ( ( Fun ⁻¹ F ∧ Fun ⁻¹ G ) → Fun ⁻¹ ( F ∘ G ) ) ;;
	step 9 : wff = anim12i (step 3, step 8) |- ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ ( Fun ⁻¹ F ∧ Fun ⁻¹ G ) ) → ( ( F ∘ G ) : A ⟶ C ∧ Fun ⁻¹ ( F ∘ G ) ) ) ;;
	step 10 : wff = an4s (step 9) |- ( ( ( F : B ⟶ C ∧ Fun ⁻¹ F ) ∧ ( G : A ⟶ B ∧ Fun ⁻¹ G ) ) → ( ( F ∘ G ) : A ⟶ C ∧ Fun ⁻¹ ( F ∘ G ) ) ) ;;
	step 11 : wff = syl2anb (step 1, step 2, step 10) |- ( ( F : B ↣ C ∧ G : A ↣ B ) → ( ( F ∘ G ) : A ⟶ C ∧ Fun ⁻¹ ( F ∘ G ) ) ) ;;
	step 12 : wff = df-f1 () |- ( ( F ∘ G ) : A ↣ C ↔ ( ( F ∘ G ) : A ⟶ C ∧ Fun ⁻¹ ( F ∘ G ) ) ) ;;
	step 13 : wff = sylibr (step 11, step 12) |- ( ( F : B ↣ C ∧ G : A ↣ B ) → ( F ∘ G ) : A ↣ C ) ;;
	qed prop 1 = step 13 ;;
}

/*Equality theorem for onto functions.  (Contributed by NM, 1-Aug-1994.) */

theorem foeq1 (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( F = G → ( F : A ↠ B ↔ G : A ↠ B ) ) ;;
}

proof of foeq1 {
	step 1 : wff = fneq1 () |- ( F = G → ( F Fn A ↔ G Fn A ) ) ;;
	step 2 : wff = rneq () |- ( F = G → ran F = ran G ) ;;
	step 3 : wff = eqeq1d (step 2) |- ( F = G → ( ran F = B ↔ ran G = B ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( F = G → ( ( F Fn A ∧ ran F = B ) ↔ ( G Fn A ∧ ran G = B ) ) ) ;;
	step 5 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 6 : wff = df-fo () |- ( G : A ↠ B ↔ ( G Fn A ∧ ran G = B ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( F = G → ( F : A ↠ B ↔ G : A ↠ B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for onto functions.  (Contributed by NM, 1-Aug-1994.) */

theorem foeq2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : A ↠ C ↔ F : B ↠ C ) ) ;;
}

proof of foeq2 {
	step 1 : wff = fneq2 () |- ( A = B → ( F Fn A ↔ F Fn B ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( A = B → ( ( F Fn A ∧ ran F = C ) ↔ ( F Fn B ∧ ran F = C ) ) ) ;;
	step 3 : wff = df-fo () |- ( F : A ↠ C ↔ ( F Fn A ∧ ran F = C ) ) ;;
	step 4 : wff = df-fo () |- ( F : B ↠ C ↔ ( F Fn B ∧ ran F = C ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F : A ↠ C ↔ F : B ↠ C ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for onto functions.  (Contributed by NM, 1-Aug-1994.) */

theorem foeq3 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : C ↠ A ↔ F : C ↠ B ) ) ;;
}

proof of foeq3 {
	step 1 : wff = eqeq2 () |- ( A = B → ( ran F = A ↔ ran F = B ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( A = B → ( ( F Fn C ∧ ran F = A ) ↔ ( F Fn C ∧ ran F = B ) ) ) ;;
	step 3 : wff = df-fo () |- ( F : C ↠ A ↔ ( F Fn C ∧ ran F = A ) ) ;;
	step 4 : wff = df-fo () |- ( F : C ↠ B ↔ ( F Fn C ∧ ran F = B ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( F : C ↠ A ↔ F : C ↠ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for an onto function.  (Contributed by
       NM, 16-May-2004.) */

theorem nffo (x : set, A : class, B : class, F : class) disjointed(F, A, B, x) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x A ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x F : A ↠ B ;;
}

proof of nffo {
	step 1 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 2 : wff = nffn (hyp 1, hyp 2) |- F/ x F Fn A ;;
	step 3 : wff = nfrn (hyp 1) |- F/_ x ran F ;;
	step 4 : wff = nfeq (step 3, hyp 3) |- F/ x ran F = B ;;
	step 5 : wff = nfan (step 2, step 4) |- F/ x ( F Fn A ∧ ran F = B ) ;;
	step 6 : wff = nfxfr (step 1, step 5) |- F/ x F : A ↠ B ;;
	qed prop 1 = step 6 ;;
}

/*An onto mapping is a mapping.  (Contributed by NM, 3-Aug-1994.) */

theorem fof (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B → F : A ⟶ B ) ;;
}

proof of fof {
	step 1 : wff = eqimss () |- ( ran F = B → ran F ⊆ B ) ;;
	step 2 : wff = anim2i (step 1) |- ( ( F Fn A ∧ ran F = B ) → ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 3 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 4 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 5 : wff = 3imtr4i (step 2, step 3, step 4) |- ( F : A ↠ B → F : A ⟶ B ) ;;
	qed prop 1 = step 5 ;;
}

/*An onto mapping is a function.  (Contributed by NM, 29-Mar-2008.) */

theorem fofun (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B → Fun F ) ;;
}

proof of fofun {
	step 1 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 2 : wff = ffun () |- ( F : A ⟶ B → Fun F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↠ B → Fun F ) ;;
	qed prop 1 = step 3 ;;
}

/*An onto mapping is a function on its domain.  (Contributed by NM,
     16-Dec-2008.) */

theorem fofn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B → F Fn A ) ;;
}

proof of fofn {
	step 1 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 2 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↠ B → F Fn A ) ;;
	qed prop 1 = step 3 ;;
}

/*The codomain of an onto function is its range.  (Contributed by NM,
     3-Aug-1994.) */

theorem forn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B → ran F = B ) ;;
}

proof of forn {
	step 1 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( F : A ↠ B → ran F = B ) ;;
	qed prop 1 = step 2 ;;
}

/*Alternate definition of an onto function.  (Contributed by NM,
     22-Mar-2006.) */

theorem dffo2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ran F = B ) ) ;;
}

proof of dffo2 {
	step 1 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 2 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 3 : wff = jca (step 1, step 2) |- ( F : A ↠ B → ( F : A ⟶ B ∧ ran F = B ) ) ;;
	step 4 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 5 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 6 : wff = biimpri (step 5) |- ( ( F Fn A ∧ ran F = B ) → F : A ↠ B ) ;;
	step 7 : wff = sylan (step 4, step 6) |- ( ( F : A ⟶ B ∧ ran F = B ) → F : A ↠ B ) ;;
	step 8 : wff = impbii (step 3, step 7) |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ran F = B ) ) ;;
	qed prop 1 = step 8 ;;
}

/*The image of the domain of an onto function.  (Contributed by NM,
     29-Nov-2002.) */

theorem foima (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B → ( F " A ) = B ) ;;
}

proof of foima {
	step 1 : wff = imadmrn () |- ( F " dom F ) = ran F ;;
	step 2 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 3 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( F : A ↠ B → dom F = A ) ;;
	step 5 : wff = imaeq2d (step 4) |- ( F : A ↠ B → ( F " dom F ) = ( F " A ) ) ;;
	step 6 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 7 : wff = 3eqtr3a (step 1, step 5, step 6) |- ( F : A ↠ B → ( F " A ) = B ) ;;
	qed prop 1 = step 7 ;;
}

/*A function maps onto its range.  (Contributed by NM, 10-May-1998.) */

theorem dffn4 (A : class, F : class)  {
	prop 1 : wff = |- ( F Fn A ↔ F : A ↠ ran F ) ;;
}

proof of dffn4 {
	step 1 : wff = eqid () |- ran F = ran F ;;
	step 2 : wff = biantru (step 1) |- ( F Fn A ↔ ( F Fn A ∧ ran F = ran F ) ) ;;
	step 3 : wff = df-fo () |- ( F : A ↠ ran F ↔ ( F Fn A ∧ ran F = ran F ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( F Fn A ↔ F : A ↠ ran F ) ;;
	qed prop 1 = step 4 ;;
}

/*A function maps its domain onto its range.  (Contributed by NM,
     23-Jul-2004.) */

theorem funforn (A : class)  {
	prop 1 : wff = |- ( Fun A ↔ A : dom A ↠ ran A ) ;;
}

proof of funforn {
	step 1 : wff = funfn () |- ( Fun A ↔ A Fn dom A ) ;;
	step 2 : wff = dffn4 () |- ( A Fn dom A ↔ A : dom A ↠ ran A ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( Fun A ↔ A : dom A ↠ ran A ) ;;
	qed prop 1 = step 3 ;;
}

/*An onto function has unique domain and range.  (Contributed by NM,
     5-Nov-2006.) */

theorem fodmrnu (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↠ B ∧ F : C ↠ D ) → ( A = C ∧ B = D ) ) ;;
}

proof of fodmrnu {
	step 1 : wff = fofn () |- ( F : A ↠ B → F Fn A ) ;;
	step 2 : wff = fofn () |- ( F : C ↠ D → F Fn C ) ;;
	step 3 : wff = fndmu () |- ( ( F Fn A ∧ F Fn C ) → A = C ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( F : A ↠ B ∧ F : C ↠ D ) → A = C ) ;;
	step 5 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 6 : wff = forn () |- ( F : C ↠ D → ran F = D ) ;;
	step 7 : wff = sylan9req (step 5, step 6) |- ( ( F : A ↠ B ∧ F : C ↠ D ) → B = D ) ;;
	step 8 : wff = jca (step 4, step 7) |- ( ( F : A ↠ B ∧ F : C ↠ D ) → ( A = C ∧ B = D ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Restriction of a function.  (Contributed by NM, 4-Mar-1997.) */

theorem fores (A : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( F ↾ A ) : A ↠ ( F " A ) ) ;;
}

proof of fores {
	step 1 : wff = funres () |- ( Fun F → Fun ( F ↾ A ) ) ;;
	step 2 : wff = anim1i (step 1) |- ( ( Fun F ∧ A ⊆ dom F ) → ( Fun ( F ↾ A ) ∧ A ⊆ dom F ) ) ;;
	step 3 : wff = df-fn () |- ( ( F ↾ A ) Fn A ↔ ( Fun ( F ↾ A ) ∧ dom ( F ↾ A ) = A ) ) ;;
	step 4 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 5 : wff = eqcomi (step 4) |- ran ( F ↾ A ) = ( F " A ) ;;
	step 6 : wff = df-fo () |- ( ( F ↾ A ) : A ↠ ( F " A ) ↔ ( ( F ↾ A ) Fn A ∧ ran ( F ↾ A ) = ( F " A ) ) ) ;;
	step 7 : wff = mpbiran2 (step 5, step 6) |- ( ( F ↾ A ) : A ↠ ( F " A ) ↔ ( F ↾ A ) Fn A ) ;;
	step 8 : wff = ssdmres () |- ( A ⊆ dom F ↔ dom ( F ↾ A ) = A ) ;;
	step 9 : wff = anbi2i (step 8) |- ( ( Fun ( F ↾ A ) ∧ A ⊆ dom F ) ↔ ( Fun ( F ↾ A ) ∧ dom ( F ↾ A ) = A ) ) ;;
	step 10 : wff = 3bitr4i (step 3, step 7, step 9) |- ( ( F ↾ A ) : A ↠ ( F " A ) ↔ ( Fun ( F ↾ A ) ∧ A ⊆ dom F ) ) ;;
	step 11 : wff = sylibr (step 2, step 10) |- ( ( Fun F ∧ A ⊆ dom F ) → ( F ↾ A ) : A ↠ ( F " A ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Composition of onto functions.  (Contributed by NM, 22-Mar-2006.) */

theorem foco (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : B ↠ C ∧ G : A ↠ B ) → ( F ∘ G ) : A ↠ C ) ;;
}

proof of foco {
	step 1 : wff = dffo2 () |- ( F : B ↠ C ↔ ( F : B ⟶ C ∧ ran F = C ) ) ;;
	step 2 : wff = dffo2 () |- ( G : A ↠ B ↔ ( G : A ⟶ B ∧ ran G = B ) ) ;;
	step 3 : wff = fco () |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( F ∘ G ) : A ⟶ C ) ;;
	step 4 : wff = ad2ant2r (step 3) |- ( ( ( F : B ⟶ C ∧ ran F = C ) ∧ ( G : A ⟶ B ∧ ran G = B ) ) → ( F ∘ G ) : A ⟶ C ) ;;
	step 5 : wff = fdm () |- ( F : B ⟶ C → dom F = B ) ;;
	step 6 : wff = eqtr3 () |- ( ( dom F = B ∧ ran G = B ) → dom F = ran G ) ;;
	step 7 : wff = sylan (step 5, step 6) |- ( ( F : B ⟶ C ∧ ran G = B ) → dom F = ran G ) ;;
	step 8 : wff = rncoeq () |- ( dom F = ran G → ran ( F ∘ G ) = ran F ) ;;
	step 9 : wff = eqeq1d (step 8) |- ( dom F = ran G → ( ran ( F ∘ G ) = C ↔ ran F = C ) ) ;;
	step 10 : wff = biimpar (step 9) |- ( ( dom F = ran G ∧ ran F = C ) → ran ( F ∘ G ) = C ) ;;
	step 11 : wff = sylan (step 7, step 10) |- ( ( ( F : B ⟶ C ∧ ran G = B ) ∧ ran F = C ) → ran ( F ∘ G ) = C ) ;;
	step 12 : wff = an32s (step 11) |- ( ( ( F : B ⟶ C ∧ ran F = C ) ∧ ran G = B ) → ran ( F ∘ G ) = C ) ;;
	step 13 : wff = adantrl (step 12) |- ( ( ( F : B ⟶ C ∧ ran F = C ) ∧ ( G : A ⟶ B ∧ ran G = B ) ) → ran ( F ∘ G ) = C ) ;;
	step 14 : wff = jca (step 4, step 13) |- ( ( ( F : B ⟶ C ∧ ran F = C ) ∧ ( G : A ⟶ B ∧ ran G = B ) ) → ( ( F ∘ G ) : A ⟶ C ∧ ran ( F ∘ G ) = C ) ) ;;
	step 15 : wff = syl2anb (step 1, step 2, step 14) |- ( ( F : B ↠ C ∧ G : A ↠ B ) → ( ( F ∘ G ) : A ⟶ C ∧ ran ( F ∘ G ) = C ) ) ;;
	step 16 : wff = dffo2 () |- ( ( F ∘ G ) : A ↠ C ↔ ( ( F ∘ G ) : A ⟶ C ∧ ran ( F ∘ G ) = C ) ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ( F : B ↠ C ∧ G : A ↠ B ) → ( F ∘ G ) : A ↠ C ) ;;
	qed prop 1 = step 17 ;;
}

/*A nonzero constant function is onto.  (Contributed by NM, 12-Jan-2007.) */

theorem foconst (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ { B } ∧ F ≠ ∅ ) → F : A ↠ { B } ) ;;
}

proof of foconst {
	step 1 : wff = frel () |- ( F : A ⟶ { B } → Rel F ) ;;
	step 2 : wff = relrn0 () |- ( Rel F → ( F = ∅ ↔ ran F = ∅ ) ) ;;
	step 3 : wff = necon3abid (step 2) |- ( Rel F → ( F ≠ ∅ ↔ ¬ ran F = ∅ ) ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( F : A ⟶ { B } → ( F ≠ ∅ ↔ ¬ ran F = ∅ ) ) ;;
	step 5 : wff = frn () |- ( F : A ⟶ { B } → ran F ⊆ { B } ) ;;
	step 6 : wff = sssn () |- ( ran F ⊆ { B } ↔ ( ran F = ∅ ∨ ran F = { B } ) ) ;;
	step 7 : wff = sylib (step 5, step 6) |- ( F : A ⟶ { B } → ( ran F = ∅ ∨ ran F = { B } ) ) ;;
	step 8 : wff = ord (step 7) |- ( F : A ⟶ { B } → ( ¬ ran F = ∅ → ran F = { B } ) ) ;;
	step 9 : wff = sylbid (step 4, step 8) |- ( F : A ⟶ { B } → ( F ≠ ∅ → ran F = { B } ) ) ;;
	step 10 : wff = imdistani (step 9) |- ( ( F : A ⟶ { B } ∧ F ≠ ∅ ) → ( F : A ⟶ { B } ∧ ran F = { B } ) ) ;;
	step 11 : wff = dffo2 () |- ( F : A ↠ { B } ↔ ( F : A ⟶ { B } ∧ ran F = { B } ) ) ;;
	step 12 : wff = sylibr (step 10, step 11) |- ( ( F : A ⟶ { B } ∧ F ≠ ∅ ) → F : A ↠ { B } ) ;;
	qed prop 1 = step 12 ;;
}

/*Equality theorem for one-to-one onto functions.  (Contributed by NM,
     10-Feb-1997.) */

theorem f1oeq1 (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( F = G → ( F : A ⤖ B ↔ G : A ⤖ B ) ) ;;
}

proof of f1oeq1 {
	step 1 : wff = f1eq1 () |- ( F = G → ( F : A ↣ B ↔ G : A ↣ B ) ) ;;
	step 2 : wff = foeq1 () |- ( F = G → ( F : A ↠ B ↔ G : A ↠ B ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( F = G → ( ( F : A ↣ B ∧ F : A ↠ B ) ↔ ( G : A ↣ B ∧ G : A ↠ B ) ) ) ;;
	step 4 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 5 : wff = df-f1o () |- ( G : A ⤖ B ↔ ( G : A ↣ B ∧ G : A ↠ B ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( F = G → ( F : A ⤖ B ↔ G : A ⤖ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality theorem for one-to-one onto functions.  (Contributed by NM,
     10-Feb-1997.) */

theorem f1oeq2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : A ⤖ C ↔ F : B ⤖ C ) ) ;;
}

proof of f1oeq2 {
	step 1 : wff = f1eq2 () |- ( A = B → ( F : A ↣ C ↔ F : B ↣ C ) ) ;;
	step 2 : wff = foeq2 () |- ( A = B → ( F : A ↠ C ↔ F : B ↠ C ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( A = B → ( ( F : A ↣ C ∧ F : A ↠ C ) ↔ ( F : B ↣ C ∧ F : B ↠ C ) ) ) ;;
	step 4 : wff = df-f1o () |- ( F : A ⤖ C ↔ ( F : A ↣ C ∧ F : A ↠ C ) ) ;;
	step 5 : wff = df-f1o () |- ( F : B ⤖ C ↔ ( F : B ↣ C ∧ F : B ↠ C ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( A = B → ( F : A ⤖ C ↔ F : B ⤖ C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality theorem for one-to-one onto functions.  (Contributed by NM,
     10-Feb-1997.) */

theorem f1oeq3 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A = B → ( F : C ⤖ A ↔ F : C ⤖ B ) ) ;;
}

proof of f1oeq3 {
	step 1 : wff = f1eq3 () |- ( A = B → ( F : C ↣ A ↔ F : C ↣ B ) ) ;;
	step 2 : wff = foeq3 () |- ( A = B → ( F : C ↠ A ↔ F : C ↠ B ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( A = B → ( ( F : C ↣ A ∧ F : C ↠ A ) ↔ ( F : C ↣ B ∧ F : C ↠ B ) ) ) ;;
	step 4 : wff = df-f1o () |- ( F : C ⤖ A ↔ ( F : C ↣ A ∧ F : C ↠ A ) ) ;;
	step 5 : wff = df-f1o () |- ( F : C ⤖ B ↔ ( F : C ↣ B ∧ F : C ↠ B ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( A = B → ( F : C ⤖ A ↔ F : C ⤖ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality theorem for one-to-one onto functions.  (Contributed by FL,
     14-Jul-2012.) */

theorem f1oeq23 (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → ( F : A ⤖ C ↔ F : B ⤖ D ) ) ;;
}

proof of f1oeq23 {
	step 1 : wff = f1oeq2 () |- ( A = B → ( F : A ⤖ C ↔ F : B ⤖ C ) ) ;;
	step 2 : wff = f1oeq3 () |- ( C = D → ( F : B ⤖ C ↔ F : B ⤖ D ) ) ;;
	step 3 : wff = sylan9bb (step 1, step 2) |- ( ( A = B ∧ C = D ) → ( F : A ⤖ C ↔ F : B ⤖ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for one-to-one functions.  (Contributed by Mario
       Carneiro, 27-Jan-2017.) */

theorem f1eq123d (ph : wff, A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ↣ C ↔ G : B ↣ D ) ) ;;
}

proof of f1eq123d {
	step 1 : wff = f1eq1 () |- ( F = G → ( F : A ↣ C ↔ G : A ↣ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F : A ↣ C ↔ G : A ↣ C ) ) ;;
	step 3 : wff = f1eq2 () |- ( A = B → ( G : A ↣ C ↔ G : B ↣ C ) ) ;;
	step 4 : wff = syl (hyp 2, step 3) |- ( ph → ( G : A ↣ C ↔ G : B ↣ C ) ) ;;
	step 5 : wff = f1eq3 () |- ( C = D → ( G : B ↣ C ↔ G : B ↣ D ) ) ;;
	step 6 : wff = syl (hyp 3, step 5) |- ( ph → ( G : B ↣ C ↔ G : B ↣ D ) ) ;;
	step 7 : wff = 3bitrd (step 2, step 4, step 6) |- ( ph → ( F : A ↣ C ↔ G : B ↣ D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality deduction for onto functions.  (Contributed by Mario Carneiro,
       27-Jan-2017.) */

theorem foeq123d (ph : wff, A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ↠ C ↔ G : B ↠ D ) ) ;;
}

proof of foeq123d {
	step 1 : wff = foeq1 () |- ( F = G → ( F : A ↠ C ↔ G : A ↠ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F : A ↠ C ↔ G : A ↠ C ) ) ;;
	step 3 : wff = foeq2 () |- ( A = B → ( G : A ↠ C ↔ G : B ↠ C ) ) ;;
	step 4 : wff = syl (hyp 2, step 3) |- ( ph → ( G : A ↠ C ↔ G : B ↠ C ) ) ;;
	step 5 : wff = foeq3 () |- ( C = D → ( G : B ↠ C ↔ G : B ↠ D ) ) ;;
	step 6 : wff = syl (hyp 3, step 5) |- ( ph → ( G : B ↠ C ↔ G : B ↠ D ) ) ;;
	step 7 : wff = 3bitrd (step 2, step 4, step 6) |- ( ph → ( F : A ↠ C ↔ G : B ↠ D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality deduction for one-to-one onto functions.  (Contributed by Mario
       Carneiro, 27-Jan-2017.) */

theorem f1oeq123d (ph : wff, A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⤖ C ↔ G : B ⤖ D ) ) ;;
}

proof of f1oeq123d {
	step 1 : wff = f1oeq1 () |- ( F = G → ( F : A ⤖ C ↔ G : A ⤖ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F : A ⤖ C ↔ G : A ⤖ C ) ) ;;
	step 3 : wff = f1oeq2 () |- ( A = B → ( G : A ⤖ C ↔ G : B ⤖ C ) ) ;;
	step 4 : wff = syl (hyp 2, step 3) |- ( ph → ( G : A ⤖ C ↔ G : B ⤖ C ) ) ;;
	step 5 : wff = f1oeq3 () |- ( C = D → ( G : B ⤖ C ↔ G : B ⤖ D ) ) ;;
	step 6 : wff = syl (hyp 3, step 5) |- ( ph → ( G : B ⤖ C ↔ G : B ⤖ D ) ) ;;
	step 7 : wff = 3bitrd (step 2, step 4, step 6) |- ( ph → ( F : A ⤖ C ↔ G : B ⤖ D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Bound-variable hypothesis builder for a one-to-one onto function.
       (Contributed by NM, 16-May-2004.) */

theorem nff1o (x : set, A : class, B : class, F : class) disjointed(F, A, B, x) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x A ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x F : A ⤖ B ;;
}

proof of nff1o {
	step 1 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 2 : wff = nff1 (hyp 1, hyp 2, hyp 3) |- F/ x F : A ↣ B ;;
	step 3 : wff = nffo (hyp 1, hyp 2, hyp 3) |- F/ x F : A ↠ B ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ x ( F : A ↣ B ∧ F : A ↠ B ) ;;
	step 5 : wff = nfxfr (step 1, step 4) |- F/ x F : A ⤖ B ;;
	qed prop 1 = step 5 ;;
}

/*A one-to-one onto mapping is a one-to-one mapping.  (Contributed by NM,
     12-Dec-2003.) */

theorem f1of1 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → F : A ↣ B ) ;;
}

proof of f1of1 {
	step 1 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( F : A ⤖ B → F : A ↣ B ) ;;
	qed prop 1 = step 2 ;;
}

/*A one-to-one onto mapping is a mapping.  (Contributed by NM,
     12-Dec-2003.) */

theorem f1of (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → F : A ⟶ B ) ;;
}

proof of f1of {
	step 1 : wff = f1of1 () |- ( F : A ⤖ B → F : A ↣ B ) ;;
	step 2 : wff = f1f () |- ( F : A ↣ B → F : A ⟶ B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → F : A ⟶ B ) ;;
	qed prop 1 = step 3 ;;
}

/*A one-to-one onto mapping is function on its domain.  (Contributed by NM,
     12-Dec-2003.) */

theorem f1ofn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → F Fn A ) ;;
}

proof of f1ofn {
	step 1 : wff = f1of () |- ( F : A ⤖ B → F : A ⟶ B ) ;;
	step 2 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → F Fn A ) ;;
	qed prop 1 = step 3 ;;
}

/*A one-to-one onto mapping is a function.  (Contributed by NM,
     12-Dec-2003.) */

theorem f1ofun (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → Fun F ) ;;
}

proof of f1ofun {
	step 1 : wff = f1ofn () |- ( F : A ⤖ B → F Fn A ) ;;
	step 2 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → Fun F ) ;;
	qed prop 1 = step 3 ;;
}

/*A one-to-one onto mapping is a relation.  (Contributed by NM,
     13-Dec-2003.) */

theorem f1orel (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → Rel F ) ;;
}

proof of f1orel {
	step 1 : wff = f1ofun () |- ( F : A ⤖ B → Fun F ) ;;
	step 2 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → Rel F ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a one-to-one onto mapping.  (Contributed by NM,
     8-Mar-2014.) */

theorem f1odm (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → dom F = A ) ;;
}

proof of f1odm {
	step 1 : wff = f1ofn () |- ( F : A ⤖ B → F Fn A ) ;;
	step 2 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → dom F = A ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of one-to-one onto function.  (Contributed by NM,
     10-Feb-1997.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem dff1o2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
}

proof of dff1o2 {
	step 1 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 2 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 3 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( F : A ↣ B ∧ F : A ↠ B ) ↔ ( ( F : A ⟶ B ∧ Fun ⁻¹ F ) ∧ ( F Fn A ∧ ran F = B ) ) ) ;;
	step 5 : wff = anass () |- ( ( ( F : A ⟶ B ∧ Fun ⁻¹ F ) ∧ ( F Fn A ∧ ran F = B ) ) ↔ ( F : A ⟶ B ∧ ( Fun ⁻¹ F ∧ ( F Fn A ∧ ran F = B ) ) ) ) ;;
	step 6 : wff = 3anan12 () |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ↔ ( Fun ⁻¹ F ∧ ( F Fn A ∧ ran F = B ) ) ) ;;
	step 7 : wff = anbi1i (step 6) |- ( ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ∧ F : A ⟶ B ) ↔ ( ( Fun ⁻¹ F ∧ ( F Fn A ∧ ran F = B ) ) ∧ F : A ⟶ B ) ) ;;
	step 8 : wff = eqimss () |- ( ran F = B → ran F ⊆ B ) ;;
	step 9 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 10 : wff = biimpri (step 9) |- ( ( F Fn A ∧ ran F ⊆ B ) → F : A ⟶ B ) ;;
	step 11 : wff = sylan2 (step 8, step 10) |- ( ( F Fn A ∧ ran F = B ) → F : A ⟶ B ) ;;
	step 12 : wff = 3adant2 (step 11) |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) → F : A ⟶ B ) ;;
	step 13 : wff = pm4.71i (step 12) |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ↔ ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ∧ F : A ⟶ B ) ) ;;
	step 14 : wff = ancom () |- ( ( F : A ⟶ B ∧ ( Fun ⁻¹ F ∧ ( F Fn A ∧ ran F = B ) ) ) ↔ ( ( Fun ⁻¹ F ∧ ( F Fn A ∧ ran F = B ) ) ∧ F : A ⟶ B ) ) ;;
	step 15 : wff = 3bitr4ri (step 7, step 13, step 14) |- ( ( F : A ⟶ B ∧ ( Fun ⁻¹ F ∧ ( F Fn A ∧ ran F = B ) ) ) ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
	step 16 : wff = bitri (step 5, step 15) |- ( ( ( F : A ⟶ B ∧ Fun ⁻¹ F ) ∧ ( F Fn A ∧ ran F = B ) ) ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
	step 17 : wff = bitri (step 4, step 16) |- ( ( F : A ↣ B ∧ F : A ↠ B ) ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
	step 18 : wff = bitri (step 1, step 17) |- ( F : A ⤖ B ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Alternate definition of one-to-one onto function.  (Contributed by NM,
     25-Mar-1998.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem dff1o3 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B ↔ ( F : A ↠ B ∧ Fun ⁻¹ F ) ) ;;
}

proof of dff1o3 {
	step 1 : wff = 3anan32 () |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ↔ ( ( F Fn A ∧ ran F = B ) ∧ Fun ⁻¹ F ) ) ;;
	step 2 : wff = dff1o2 () |- ( F : A ⤖ B ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
	step 3 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( F : A ↠ B ∧ Fun ⁻¹ F ) ↔ ( ( F Fn A ∧ ran F = B ) ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = 3bitr4i (step 1, step 2, step 4) |- ( F : A ⤖ B ↔ ( F : A ↠ B ∧ Fun ⁻¹ F ) ) ;;
	qed prop 1 = step 5 ;;
}

/*A one-to-one onto function is an onto function.  (Contributed by NM,
     28-Apr-2004.) */

theorem f1ofo (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → F : A ↠ B ) ;;
}

proof of f1ofo {
	step 1 : wff = dff1o3 () |- ( F : A ⤖ B ↔ ( F : A ↠ B ∧ Fun ⁻¹ F ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( F : A ⤖ B → F : A ↠ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Alternate definition of one-to-one onto function.  (Contributed by NM,
     25-Mar-1998.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem dff1o4 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
}

proof of dff1o4 {
	step 1 : wff = dff1o2 () |- ( F : A ⤖ B ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ) ;;
	step 2 : wff = 3anass () |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = B ) ↔ ( F Fn A ∧ ( Fun ⁻¹ F ∧ ran F = B ) ) ) ;;
	step 3 : wff = df-rn () |- ran F = dom ⁻¹ F ;;
	step 4 : wff = eqeq1i (step 3) |- ( ran F = B ↔ dom ⁻¹ F = B ) ;;
	step 5 : wff = anbi2i (step 4) |- ( ( Fun ⁻¹ F ∧ ran F = B ) ↔ ( Fun ⁻¹ F ∧ dom ⁻¹ F = B ) ) ;;
	step 6 : wff = df-fn () |- ( ⁻¹ F Fn B ↔ ( Fun ⁻¹ F ∧ dom ⁻¹ F = B ) ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ( Fun ⁻¹ F ∧ ran F = B ) ↔ ⁻¹ F Fn B ) ;;
	step 8 : wff = anbi2i (step 7) |- ( ( F Fn A ∧ ( Fun ⁻¹ F ∧ ran F = B ) ) ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
	step 9 : wff = 3bitri (step 1, step 2, step 8) |- ( F : A ⤖ B ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Alternate definition of one-to-one onto function.  (Contributed by NM,
     10-Dec-2003.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem dff1o5 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ ran F = B ) ) ;;
}

proof of dff1o5 {
	step 1 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 2 : wff = f1f () |- ( F : A ↣ B → F : A ⟶ B ) ;;
	step 3 : wff = biantrurd (step 2) |- ( F : A ↣ B → ( ran F = B ↔ ( F : A ⟶ B ∧ ran F = B ) ) ) ;;
	step 4 : wff = dffo2 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ran F = B ) ) ;;
	step 5 : wff = syl6rbbr (step 3, step 4) |- ( F : A ↣ B → ( F : A ↠ B ↔ ran F = B ) ) ;;
	step 6 : wff = pm5.32i (step 5) |- ( ( F : A ↣ B ∧ F : A ↠ B ) ↔ ( F : A ↣ B ∧ ran F = B ) ) ;;
	step 7 : wff = bitri (step 1, step 6) |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ ran F = B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A one-to-one function maps onto its range.  (Contributed by NM,
     13-Aug-2004.) */

theorem f1orn (A : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ ran F ↔ ( F Fn A ∧ Fun ⁻¹ F ) ) ;;
}

proof of f1orn {
	step 1 : wff = dff1o2 () |- ( F : A ⤖ ran F ↔ ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = ran F ) ) ;;
	step 2 : wff = eqid () |- ran F = ran F ;;
	step 3 : wff = df-3an () |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = ran F ) ↔ ( ( F Fn A ∧ Fun ⁻¹ F ) ∧ ran F = ran F ) ) ;;
	step 4 : wff = mpbiran2 (step 2, step 3) |- ( ( F Fn A ∧ Fun ⁻¹ F ∧ ran F = ran F ) ↔ ( F Fn A ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( F : A ⤖ ran F ↔ ( F Fn A ∧ Fun ⁻¹ F ) ) ;;
	qed prop 1 = step 5 ;;
}

/*A one-to-one function maps one-to-one onto its range.  (Contributed by NM,
     4-Sep-2004.) */

theorem f1f1orn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → F : A ⤖ ran F ) ;;
}

proof of f1f1orn {
	step 1 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 2 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 3 : wff = simprbi (step 2) |- ( F : A ↣ B → Fun ⁻¹ F ) ;;
	step 4 : wff = f1orn () |- ( F : A ⤖ ran F ↔ ( F Fn A ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = sylanbrc (step 1, step 3, step 4) |- ( F : A ↣ B → F : A ⤖ ran F ) ;;
	qed prop 1 = step 5 ;;
}

/*The class of all 1-1-onto functions mapping one set to another is a
       set.  (Contributed by Paul Chapman, 25-Feb-2008.) */

theorem f1oabexg (ph : wff, A : class, B : class, C : class, D : class, f : set, F : class) disjointed(A f, B f) {
	hyp 1 : wff = |- F = { f | ( f : A ⤖ B ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → F ∈ _V ) ;;
}

proof of f1oabexg {
	step 1 : wff = f1of () |- ( f : A ⤖ B → f : A ⟶ B ) ;;
	step 2 : wff = anim1i (step 1) |- ( ( f : A ⤖ B ∧ ph ) → ( f : A ⟶ B ∧ ph ) ) ;;
	step 3 : wff = ss2abi (step 2) |- { f | ( f : A ⤖ B ∧ ph ) } ⊆ { f | ( f : A ⟶ B ∧ ph ) } ;;
	step 4 : wff = eqid () |- { f | ( f : A ⟶ B ∧ ph ) } = { f | ( f : A ⟶ B ∧ ph ) } ;;
	step 5 : wff = fabexg (step 4) |- ( ( A ∈ C ∧ B ∈ D ) → { f | ( f : A ⟶ B ∧ ph ) } ∈ _V ) ;;
	step 6 : wff = ssexg () |- ( ( { f | ( f : A ⤖ B ∧ ph ) } ⊆ { f | ( f : A ⟶ B ∧ ph ) } ∧ { f | ( f : A ⟶ B ∧ ph ) } ∈ _V ) → { f | ( f : A ⤖ B ∧ ph ) } ∈ _V ) ;;
	step 7 : wff = sylancr (step 3, step 5, step 6) |- ( ( A ∈ C ∧ B ∈ D ) → { f | ( f : A ⤖ B ∧ ph ) } ∈ _V ) ;;
	step 8 : wff = syl5eqel (hyp 1, step 7) |- ( ( A ∈ C ∧ B ∈ D ) → F ∈ _V ) ;;
	qed prop 1 = step 8 ;;
}

/*The converse of a one-to-one onto function is also one-to-one onto.
     (Contributed by NM, 11-Feb-1997.)  (Proof shortened by Andrew Salmon,
     22-Oct-2011.) */

theorem f1ocnv (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
}

proof of f1ocnv {
	step 1 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 2 : wff = dfrel2 () |- ( Rel F ↔ ⁻¹ ⁻¹ F = F ) ;;
	step 3 : wff = fneq1 () |- ( ⁻¹ ⁻¹ F = F → ( ⁻¹ ⁻¹ F Fn A ↔ F Fn A ) ) ;;
	step 4 : wff = biimprd (step 3) |- ( ⁻¹ ⁻¹ F = F → ( F Fn A → ⁻¹ ⁻¹ F Fn A ) ) ;;
	step 5 : wff = sylbi (step 2, step 4) |- ( Rel F → ( F Fn A → ⁻¹ ⁻¹ F Fn A ) ) ;;
	step 6 : wff = mpcom (step 1, step 5) |- ( F Fn A → ⁻¹ ⁻¹ F Fn A ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( ⁻¹ F Fn B ∧ F Fn A ) → ( ⁻¹ F Fn B ∧ ⁻¹ ⁻¹ F Fn A ) ) ;;
	step 8 : wff = ancoms (step 7) |- ( ( F Fn A ∧ ⁻¹ F Fn B ) → ( ⁻¹ F Fn B ∧ ⁻¹ ⁻¹ F Fn A ) ) ;;
	step 9 : wff = dff1o4 () |- ( F : A ⤖ B ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
	step 10 : wff = dff1o4 () |- ( ⁻¹ F : B ⤖ A ↔ ( ⁻¹ F Fn B ∧ ⁻¹ ⁻¹ F Fn A ) ) ;;
	step 11 : wff = 3imtr4i (step 8, step 9, step 10) |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	qed prop 1 = step 11 ;;
}

/*A relation is a one-to-one onto function iff its converse is a one-to-one
     onto function with domain and range interchanged.  (Contributed by NM,
     8-Dec-2003.) */

theorem f1ocnvb (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( Rel F → ( F : A ⤖ B ↔ ⁻¹ F : B ⤖ A ) ) ;;
}

proof of f1ocnvb {
	step 1 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 2 : wff = f1ocnv () |- ( ⁻¹ F : B ⤖ A → ⁻¹ ⁻¹ F : A ⤖ B ) ;;
	step 3 : wff = dfrel2 () |- ( Rel F ↔ ⁻¹ ⁻¹ F = F ) ;;
	step 4 : wff = f1oeq1 () |- ( ⁻¹ ⁻¹ F = F → ( ⁻¹ ⁻¹ F : A ⤖ B ↔ F : A ⤖ B ) ) ;;
	step 5 : wff = sylbi (step 3, step 4) |- ( Rel F → ( ⁻¹ ⁻¹ F : A ⤖ B ↔ F : A ⤖ B ) ) ;;
	step 6 : wff = syl5ib (step 2, step 5) |- ( Rel F → ( ⁻¹ F : B ⤖ A → F : A ⤖ B ) ) ;;
	step 7 : wff = impbid2 (step 1, step 6) |- ( Rel F → ( F : A ⤖ B ↔ ⁻¹ F : B ⤖ A ) ) ;;
	qed prop 1 = step 7 ;;
}

/*The restriction of a one-to-one function maps one-to-one onto the image.
     (Contributed by NM, 25-Mar-1998.) */

theorem f1ores (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⤖ ( F " C ) ) ;;
}

proof of f1ores {
	step 1 : wff = f1ssres () |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ↣ B ) ;;
	step 2 : wff = f1f1orn () |- ( ( F ↾ C ) : C ↣ B → ( F ↾ C ) : C ⤖ ran ( F ↾ C ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⤖ ran ( F ↾ C ) ) ;;
	step 4 : wff = df-ima () |- ( F " C ) = ran ( F ↾ C ) ;;
	step 5 : wff = f1oeq3 () |- ( ( F " C ) = ran ( F ↾ C ) → ( ( F ↾ C ) : C ⤖ ( F " C ) ↔ ( F ↾ C ) : C ⤖ ran ( F ↾ C ) ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( ( F ↾ C ) : C ⤖ ( F " C ) ↔ ( F ↾ C ) : C ⤖ ran ( F ↾ C ) ) ;;
	step 7 : wff = sylibr (step 3, step 6) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⤖ ( F " C ) ) ;;
	qed prop 1 = step 7 ;;
}

/*The converse of a one-to-one-onto restricted function.  (Contributed by
     Paul Chapman, 21-Apr-2008.) */

theorem f1orescnv (P : class, R : class, F : class)  {
	prop 1 : wff = |- ( ( Fun ⁻¹ F ∧ ( F ↾ R ) : R ⤖ P ) → ( ⁻¹ F ↾ P ) : P ⤖ R ) ;;
}

proof of f1orescnv {
	step 1 : wff = f1ocnv () |- ( ( F ↾ R ) : R ⤖ P → ⁻¹ ( F ↾ R ) : P ⤖ R ) ;;
	step 2 : wff = adantl (step 1) |- ( ( Fun ⁻¹ F ∧ ( F ↾ R ) : R ⤖ P ) → ⁻¹ ( F ↾ R ) : P ⤖ R ) ;;
	step 3 : wff = funcnvres () |- ( Fun ⁻¹ F → ⁻¹ ( F ↾ R ) = ( ⁻¹ F ↾ ( F " R ) ) ) ;;
	step 4 : wff = df-ima () |- ( F " R ) = ran ( F ↾ R ) ;;
	step 5 : wff = dff1o5 () |- ( ( F ↾ R ) : R ⤖ P ↔ ( ( F ↾ R ) : R ↣ P ∧ ran ( F ↾ R ) = P ) ) ;;
	step 6 : wff = simprbi (step 5) |- ( ( F ↾ R ) : R ⤖ P → ran ( F ↾ R ) = P ) ;;
	step 7 : wff = syl5eq (step 4, step 6) |- ( ( F ↾ R ) : R ⤖ P → ( F " R ) = P ) ;;
	step 8 : wff = reseq2d (step 7) |- ( ( F ↾ R ) : R ⤖ P → ( ⁻¹ F ↾ ( F " R ) ) = ( ⁻¹ F ↾ P ) ) ;;
	step 9 : wff = sylan9eq (step 3, step 8) |- ( ( Fun ⁻¹ F ∧ ( F ↾ R ) : R ⤖ P ) → ⁻¹ ( F ↾ R ) = ( ⁻¹ F ↾ P ) ) ;;
	step 10 : wff = f1oeq1 () |- ( ⁻¹ ( F ↾ R ) = ( ⁻¹ F ↾ P ) → ( ⁻¹ ( F ↾ R ) : P ⤖ R ↔ ( ⁻¹ F ↾ P ) : P ⤖ R ) ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( ( Fun ⁻¹ F ∧ ( F ↾ R ) : R ⤖ P ) → ( ⁻¹ ( F ↾ R ) : P ⤖ R ↔ ( ⁻¹ F ↾ P ) : P ⤖ R ) ) ;;
	step 12 : wff = mpbid (step 2, step 11) |- ( ( Fun ⁻¹ F ∧ ( F ↾ R ) : R ⤖ P ) → ( ⁻¹ F ↾ P ) : P ⤖ R ) ;;
	qed prop 1 = step 12 ;;
}

/*Preimage of an image.  (Contributed by NM, 30-Sep-2004.) */

theorem f1imacnv (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( ⁻¹ F " ( F " C ) ) = C ) ;;
}

proof of f1imacnv {
	step 1 : wff = resima () |- ( ( ⁻¹ F ↾ ( F " C ) ) " ( F " C ) ) = ( ⁻¹ F " ( F " C ) ) ;;
	step 2 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 3 : wff = simprbi (step 2) |- ( F : A ↣ B → Fun ⁻¹ F ) ;;
	step 4 : wff = adantr (step 3) |- ( ( F : A ↣ B ∧ C ⊆ A ) → Fun ⁻¹ F ) ;;
	step 5 : wff = funcnvres () |- ( Fun ⁻¹ F → ⁻¹ ( F ↾ C ) = ( ⁻¹ F ↾ ( F " C ) ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ⁻¹ ( F ↾ C ) = ( ⁻¹ F ↾ ( F " C ) ) ) ;;
	step 7 : wff = imaeq1d (step 6) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( ⁻¹ ( F ↾ C ) " ( F " C ) ) = ( ( ⁻¹ F ↾ ( F " C ) ) " ( F " C ) ) ) ;;
	step 8 : wff = f1ores () |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⤖ ( F " C ) ) ;;
	step 9 : wff = f1ocnv () |- ( ( F ↾ C ) : C ⤖ ( F " C ) → ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C ) ;;
	step 11 : wff = imadmrn () |- ( ⁻¹ ( F ↾ C ) " dom ⁻¹ ( F ↾ C ) ) = ran ⁻¹ ( F ↾ C ) ;;
	step 12 : wff = f1odm () |- ( ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C → dom ⁻¹ ( F ↾ C ) = ( F " C ) ) ;;
	step 13 : wff = imaeq2d (step 12) |- ( ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C → ( ⁻¹ ( F ↾ C ) " dom ⁻¹ ( F ↾ C ) ) = ( ⁻¹ ( F ↾ C ) " ( F " C ) ) ) ;;
	step 14 : wff = f1ofo () |- ( ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C → ⁻¹ ( F ↾ C ) : ( F " C ) ↠ C ) ;;
	step 15 : wff = forn () |- ( ⁻¹ ( F ↾ C ) : ( F " C ) ↠ C → ran ⁻¹ ( F ↾ C ) = C ) ;;
	step 16 : wff = syl (step 14, step 15) |- ( ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C → ran ⁻¹ ( F ↾ C ) = C ) ;;
	step 17 : wff = 3eqtr3a (step 11, step 13, step 16) |- ( ⁻¹ ( F ↾ C ) : ( F " C ) ⤖ C → ( ⁻¹ ( F ↾ C ) " ( F " C ) ) = C ) ;;
	step 18 : wff = syl (step 10, step 17) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( ⁻¹ ( F ↾ C ) " ( F " C ) ) = C ) ;;
	step 19 : wff = eqtr3d (step 7, step 18) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( ( ⁻¹ F ↾ ( F " C ) ) " ( F " C ) ) = C ) ;;
	step 20 : wff = syl5eqr (step 1, step 19) |- ( ( F : A ↣ B ∧ C ⊆ A ) → ( ⁻¹ F " ( F " C ) ) = C ) ;;
	qed prop 1 = step 20 ;;
}

/*A reverse version of ~ f1imacnv .  (Contributed by Jeffrey Hankins,
     16-Jul-2009.) */

theorem foimacnv (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↠ B ∧ C ⊆ B ) → ( F " ( ⁻¹ F " C ) ) = C ) ;;
}

proof of foimacnv {
	step 1 : wff = resima () |- ( ( F ↾ ( ⁻¹ F " C ) ) " ( ⁻¹ F " C ) ) = ( F " ( ⁻¹ F " C ) ) ;;
	step 2 : wff = fofun () |- ( F : A ↠ B → Fun F ) ;;
	step 3 : wff = adantr (step 2) |- ( ( F : A ↠ B ∧ C ⊆ B ) → Fun F ) ;;
	step 4 : wff = funcnvres2 () |- ( Fun F → ⁻¹ ( ⁻¹ F ↾ C ) = ( F ↾ ( ⁻¹ F " C ) ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ⁻¹ ( ⁻¹ F ↾ C ) = ( F ↾ ( ⁻¹ F " C ) ) ) ;;
	step 6 : wff = imaeq1d (step 5) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ( ⁻¹ ( ⁻¹ F ↾ C ) " ( ⁻¹ F " C ) ) = ( ( F ↾ ( ⁻¹ F " C ) ) " ( ⁻¹ F " C ) ) ) ;;
	step 7 : wff = resss () |- ( ⁻¹ F ↾ C ) ⊆ ⁻¹ F ;;
	step 8 : wff = cnvss () |- ( ( ⁻¹ F ↾ C ) ⊆ ⁻¹ F → ⁻¹ ( ⁻¹ F ↾ C ) ⊆ ⁻¹ ⁻¹ F ) ;;
	step 9 : wff = ax-mp (step 7, step 8) |- ⁻¹ ( ⁻¹ F ↾ C ) ⊆ ⁻¹ ⁻¹ F ;;
	step 10 : wff = cnvcnvss () |- ⁻¹ ⁻¹ F ⊆ F ;;
	step 11 : wff = sstri (step 9, step 10) |- ⁻¹ ( ⁻¹ F ↾ C ) ⊆ F ;;
	step 12 : wff = fofun () |- ( F : A ↠ B → Fun F ) ;;
	step 13 : wff = funss () |- ( ⁻¹ ( ⁻¹ F ↾ C ) ⊆ F → ( Fun F → Fun ⁻¹ ( ⁻¹ F ↾ C ) ) ) ;;
	step 14 : wff = mpsyl (step 11, step 12, step 13) |- ( F : A ↠ B → Fun ⁻¹ ( ⁻¹ F ↾ C ) ) ;;
	step 15 : wff = adantr (step 14) |- ( ( F : A ↠ B ∧ C ⊆ B ) → Fun ⁻¹ ( ⁻¹ F ↾ C ) ) ;;
	step 16 : wff = df-ima () |- ( ⁻¹ F " C ) = ran ( ⁻¹ F ↾ C ) ;;
	step 17 : wff = df-rn () |- ran ( ⁻¹ F ↾ C ) = dom ⁻¹ ( ⁻¹ F ↾ C ) ;;
	step 18 : wff = eqtr2i (step 16, step 17) |- dom ⁻¹ ( ⁻¹ F ↾ C ) = ( ⁻¹ F " C ) ;;
	step 19 : wff = jctir (step 15, step 18) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ( Fun ⁻¹ ( ⁻¹ F ↾ C ) ∧ dom ⁻¹ ( ⁻¹ F ↾ C ) = ( ⁻¹ F " C ) ) ) ;;
	step 20 : wff = df-fn () |- ( ⁻¹ ( ⁻¹ F ↾ C ) Fn ( ⁻¹ F " C ) ↔ ( Fun ⁻¹ ( ⁻¹ F ↾ C ) ∧ dom ⁻¹ ( ⁻¹ F ↾ C ) = ( ⁻¹ F " C ) ) ) ;;
	step 21 : wff = sylibr (step 19, step 20) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ⁻¹ ( ⁻¹ F ↾ C ) Fn ( ⁻¹ F " C ) ) ;;
	step 22 : wff = dfdm4 () |- dom ( ⁻¹ F ↾ C ) = ran ⁻¹ ( ⁻¹ F ↾ C ) ;;
	step 23 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 24 : wff = sseq2d (step 23) |- ( F : A ↠ B → ( C ⊆ ran F ↔ C ⊆ B ) ) ;;
	step 25 : wff = biimpar (step 24) |- ( ( F : A ↠ B ∧ C ⊆ B ) → C ⊆ ran F ) ;;
	step 26 : wff = df-rn () |- ran F = dom ⁻¹ F ;;
	step 27 : wff = syl6sseq (step 25, step 26) |- ( ( F : A ↠ B ∧ C ⊆ B ) → C ⊆ dom ⁻¹ F ) ;;
	step 28 : wff = ssdmres () |- ( C ⊆ dom ⁻¹ F ↔ dom ( ⁻¹ F ↾ C ) = C ) ;;
	step 29 : wff = sylib (step 27, step 28) |- ( ( F : A ↠ B ∧ C ⊆ B ) → dom ( ⁻¹ F ↾ C ) = C ) ;;
	step 30 : wff = syl5eqr (step 22, step 29) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ran ⁻¹ ( ⁻¹ F ↾ C ) = C ) ;;
	step 31 : wff = df-fo () |- ( ⁻¹ ( ⁻¹ F ↾ C ) : ( ⁻¹ F " C ) ↠ C ↔ ( ⁻¹ ( ⁻¹ F ↾ C ) Fn ( ⁻¹ F " C ) ∧ ran ⁻¹ ( ⁻¹ F ↾ C ) = C ) ) ;;
	step 32 : wff = sylanbrc (step 21, step 30, step 31) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ⁻¹ ( ⁻¹ F ↾ C ) : ( ⁻¹ F " C ) ↠ C ) ;;
	step 33 : wff = foima () |- ( ⁻¹ ( ⁻¹ F ↾ C ) : ( ⁻¹ F " C ) ↠ C → ( ⁻¹ ( ⁻¹ F ↾ C ) " ( ⁻¹ F " C ) ) = C ) ;;
	step 34 : wff = syl (step 32, step 33) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ( ⁻¹ ( ⁻¹ F ↾ C ) " ( ⁻¹ F " C ) ) = C ) ;;
	step 35 : wff = eqtr3d (step 6, step 34) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ( ( F ↾ ( ⁻¹ F " C ) ) " ( ⁻¹ F " C ) ) = C ) ;;
	step 36 : wff = syl5eqr (step 1, step 35) |- ( ( F : A ↠ B ∧ C ⊆ B ) → ( F " ( ⁻¹ F " C ) ) = C ) ;;
	qed prop 1 = step 36 ;;
}

/*The union of two onto functions with disjoint domains is an onto
     function.  (Contributed by Mario Carneiro, 22-Jun-2016.) */

theorem foun (A : class, B : class, C : class, D : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ( F ∪ G ) : ( A ∪ C ) ↠ ( B ∪ D ) ) ;;
}

proof of foun {
	step 1 : wff = fofn () |- ( F : A ↠ B → F Fn A ) ;;
	step 2 : wff = fofn () |- ( G : C ↠ D → G Fn C ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( F : A ↠ B ∧ G : C ↠ D ) → ( F Fn A ∧ G Fn C ) ) ;;
	step 4 : wff = fnun () |- ( ( ( F Fn A ∧ G Fn C ) ∧ ( A ∩ C ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ C ) ) ;;
	step 5 : wff = sylan (step 3, step 4) |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ C ) ) ;;
	step 6 : wff = rnun () |- ran ( F ∪ G ) = ( ran F ∪ ran G ) ;;
	step 7 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 8 : wff = ad2antrr (step 7) |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ran F = B ) ;;
	step 9 : wff = forn () |- ( G : C ↠ D → ran G = D ) ;;
	step 10 : wff = ad2antlr (step 9) |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ran G = D ) ;;
	step 11 : wff = uneq12d (step 8, step 10) |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ( ran F ∪ ran G ) = ( B ∪ D ) ) ;;
	step 12 : wff = syl5eq (step 6, step 11) |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ran ( F ∪ G ) = ( B ∪ D ) ) ;;
	step 13 : wff = df-fo () |- ( ( F ∪ G ) : ( A ∪ C ) ↠ ( B ∪ D ) ↔ ( ( F ∪ G ) Fn ( A ∪ C ) ∧ ran ( F ∪ G ) = ( B ∪ D ) ) ) ;;
	step 14 : wff = sylanbrc (step 5, step 12, step 13) |- ( ( ( F : A ↠ B ∧ G : C ↠ D ) ∧ ( A ∩ C ) = ∅ ) → ( F ∪ G ) : ( A ∪ C ) ↠ ( B ∪ D ) ) ;;
	qed prop 1 = step 14 ;;
}

/*The union of two one-to-one onto functions with disjoint domains and
     ranges.  (Contributed by NM, 26-Mar-1998.) */

theorem f1oun (A : class, B : class, C : class, D : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( F : A ⤖ B ∧ G : C ⤖ D ) ∧ ( ( A ∩ C ) = ∅ ∧ ( B ∩ D ) = ∅ ) ) → ( F ∪ G ) : ( A ∪ C ) ⤖ ( B ∪ D ) ) ;;
}

proof of f1oun {
	step 1 : wff = dff1o4 () |- ( F : A ⤖ B ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
	step 2 : wff = dff1o4 () |- ( G : C ⤖ D ↔ ( G Fn C ∧ ⁻¹ G Fn D ) ) ;;
	step 3 : wff = fnun () |- ( ( ( F Fn A ∧ G Fn C ) ∧ ( A ∩ C ) = ∅ ) → ( F ∪ G ) Fn ( A ∪ C ) ) ;;
	step 4 : wff = ex (step 3) |- ( ( F Fn A ∧ G Fn C ) → ( ( A ∩ C ) = ∅ → ( F ∪ G ) Fn ( A ∪ C ) ) ) ;;
	step 5 : wff = fnun () |- ( ( ( ⁻¹ F Fn B ∧ ⁻¹ G Fn D ) ∧ ( B ∩ D ) = ∅ ) → ( ⁻¹ F ∪ ⁻¹ G ) Fn ( B ∪ D ) ) ;;
	step 6 : wff = cnvun () |- ⁻¹ ( F ∪ G ) = ( ⁻¹ F ∪ ⁻¹ G ) ;;
	step 7 : wff = fneq1i (step 6) |- ( ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ↔ ( ⁻¹ F ∪ ⁻¹ G ) Fn ( B ∪ D ) ) ;;
	step 8 : wff = sylibr (step 5, step 7) |- ( ( ( ⁻¹ F Fn B ∧ ⁻¹ G Fn D ) ∧ ( B ∩ D ) = ∅ ) → ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ) ;;
	step 9 : wff = ex (step 8) |- ( ( ⁻¹ F Fn B ∧ ⁻¹ G Fn D ) → ( ( B ∩ D ) = ∅ → ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ) ) ;;
	step 10 : wff = im2anan9 (step 4, step 9) |- ( ( ( F Fn A ∧ G Fn C ) ∧ ( ⁻¹ F Fn B ∧ ⁻¹ G Fn D ) ) → ( ( ( A ∩ C ) = ∅ ∧ ( B ∩ D ) = ∅ ) → ( ( F ∪ G ) Fn ( A ∪ C ) ∧ ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ) ) ) ;;
	step 11 : wff = an4s (step 10) |- ( ( ( F Fn A ∧ ⁻¹ F Fn B ) ∧ ( G Fn C ∧ ⁻¹ G Fn D ) ) → ( ( ( A ∩ C ) = ∅ ∧ ( B ∩ D ) = ∅ ) → ( ( F ∪ G ) Fn ( A ∪ C ) ∧ ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ) ) ) ;;
	step 12 : wff = syl2anb (step 1, step 2, step 11) |- ( ( F : A ⤖ B ∧ G : C ⤖ D ) → ( ( ( A ∩ C ) = ∅ ∧ ( B ∩ D ) = ∅ ) → ( ( F ∪ G ) Fn ( A ∪ C ) ∧ ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ) ) ) ;;
	step 13 : wff = dff1o4 () |- ( ( F ∪ G ) : ( A ∪ C ) ⤖ ( B ∪ D ) ↔ ( ( F ∪ G ) Fn ( A ∪ C ) ∧ ⁻¹ ( F ∪ G ) Fn ( B ∪ D ) ) ) ;;
	step 14 : wff = syl6ibr (step 12, step 13) |- ( ( F : A ⤖ B ∧ G : C ⤖ D ) → ( ( ( A ∩ C ) = ∅ ∧ ( B ∩ D ) = ∅ ) → ( F ∪ G ) : ( A ∪ C ) ⤖ ( B ∪ D ) ) ) ;;
	step 15 : wff = imp (step 14) |- ( ( ( F : A ⤖ B ∧ G : C ⤖ D ) ∧ ( ( A ∩ C ) = ∅ ∧ ( B ∩ D ) = ∅ ) ) → ( F ∪ G ) : ( A ∪ C ) ⤖ ( B ∪ D ) ) ;;
	qed prop 1 = step 15 ;;
}

/*The union of a chain (with respect to inclusion) of one-to-one functions
       is a one-to-one function.  (Contributed by Mario Carneiro,
       20-May-2013.)  (Revised by Mario Carneiro, 24-Jun-2015.) */

theorem fun11iun (x : set, y : set, A : class, B : class, C : class, D : class, S : class) disjointed(A u v x z, A u v y, B u v y, B u v z, C u v x, D u v, S u v x) {
	hyp 1 : wff = |- ( x = y → B = C ) ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ⋃_ x ∈ A B : ⋃_ x ∈ A D ↣ S ) ;;
}

proof of fun11iun {
	var z : set, v : set, u : set;;
	step 1 : wff = vex () |- u ∈ _V ;;
	step 2 : wff = eqeq1 () |- ( z = u → ( z = B ↔ u = B ) ) ;;
	step 3 : wff = rexbidv (step 2) |- ( z = u → ( ∃ x ∈ A z = B ↔ ∃ x ∈ A u = B ) ) ;;
	step 4 : wff = elab (step 1, step 3) |- ( u ∈ { z | ∃ x ∈ A z = B } ↔ ∃ x ∈ A u = B ) ;;
	step 5 : wff = r19.29 () |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ ∃ x ∈ A u = B ) → ∃ x ∈ A ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ) ;;
	step 6 : wff = nfv () |- F/ x ( Fun u ∧ Fun ⁻¹ u ) ;;
	step 7 : wff = nfre1 () |- F/ x ∃ x ∈ A z = B ;;
	step 8 : wff = nfab (step 7) |- F/_ x { z | ∃ x ∈ A z = B } ;;
	step 9 : wff = nfv () |- F/ x ( u ⊆ v ∨ v ⊆ u ) ;;
	step 10 : wff = nfral (step 8, step 9) |- F/ x ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ;;
	step 11 : wff = nfan (step 6, step 10) |- F/ x ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 12 : wff = f1eq1 () |- ( u = B → ( u : D ↣ S ↔ B : D ↣ S ) ) ;;
	step 13 : wff = biimparc (step 12) |- ( ( B : D ↣ S ∧ u = B ) → u : D ↣ S ) ;;
	step 14 : wff = df-f1 () |- ( u : D ↣ S ↔ ( u : D ⟶ S ∧ Fun ⁻¹ u ) ) ;;
	step 15 : wff = ffun () |- ( u : D ⟶ S → Fun u ) ;;
	step 16 : wff = anim1i (step 15) |- ( ( u : D ⟶ S ∧ Fun ⁻¹ u ) → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 17 : wff = sylbi (step 14, step 16) |- ( u : D ↣ S → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 18 : wff = syl (step 13, step 17) |- ( ( B : D ↣ S ∧ u = B ) → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 19 : wff = adantlr (step 18) |- ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 20 : wff = vex () |- v ∈ _V ;;
	step 21 : wff = eqeq1 () |- ( z = v → ( z = B ↔ v = B ) ) ;;
	step 22 : wff = rexbidv (step 21) |- ( z = v → ( ∃ x ∈ A z = B ↔ ∃ x ∈ A v = B ) ) ;;
	step 23 : wff = elab (step 20, step 22) |- ( v ∈ { z | ∃ x ∈ A z = B } ↔ ∃ x ∈ A v = B ) ;;
	step 24 : wff = eqeq2d (hyp 1) |- ( x = y → ( v = B ↔ v = C ) ) ;;
	step 25 : wff = cbvrexv (step 24) |- ( ∃ x ∈ A v = B ↔ ∃ y ∈ A v = C ) ;;
	step 26 : wff = r19.29 () |- ( ( ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ∧ ∃ y ∈ A v = C ) → ∃ y ∈ A ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) ) ;;
	step 27 : wff = sseq12 () |- ( ( u = B ∧ v = C ) → ( u ⊆ v ↔ B ⊆ C ) ) ;;
	step 28 : wff = ancoms (step 27) |- ( ( v = C ∧ u = B ) → ( u ⊆ v ↔ B ⊆ C ) ) ;;
	step 29 : wff = sseq12 () |- ( ( v = C ∧ u = B ) → ( v ⊆ u ↔ C ⊆ B ) ) ;;
	step 30 : wff = orbi12d (step 28, step 29) |- ( ( v = C ∧ u = B ) → ( ( u ⊆ v ∨ v ⊆ u ) ↔ ( B ⊆ C ∨ C ⊆ B ) ) ) ;;
	step 31 : wff = biimprcd (step 30) |- ( ( B ⊆ C ∨ C ⊆ B ) → ( ( v = C ∧ u = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 32 : wff = expdimp (step 31) |- ( ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) → ( u = B → ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 33 : wff = rexlimivw (step 32) |- ( ∃ y ∈ A ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) → ( u = B → ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 34 : wff = imp (step 33) |- ( ( ∃ y ∈ A ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) ∧ u = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 35 : wff = sylan (step 26, step 34) |- ( ( ( ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ∧ ∃ y ∈ A v = C ) ∧ u = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 36 : wff = an32s (step 35) |- ( ( ( ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ∧ u = B ) ∧ ∃ y ∈ A v = C ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 37 : wff = adantlll (step 36) |- ( ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ∧ ∃ y ∈ A v = C ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 38 : wff = sylan2b (step 25, step 37) |- ( ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ∧ ∃ x ∈ A v = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 39 : wff = sylan2b (step 23, step 38) |- ( ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ∧ v ∈ { z | ∃ x ∈ A z = B } ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 40 : wff = ralrimiva (step 39) |- ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 41 : wff = jca (step 19, step 40) |- ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 42 : wff = a1i (step 41) |- ( x ∈ A → ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ) ;;
	step 43 : wff = rexlimi (step 11, step 42) |- ( ∃ x ∈ A ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 44 : wff = syl (step 5, step 43) |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ ∃ x ∈ A u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 45 : wff = sylan2b (step 4, step 44) |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u ∈ { z | ∃ x ∈ A z = B } ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 46 : wff = ralrimiva (step 45) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ∀ u ∈ { z | ∃ x ∈ A z = B } ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 47 : wff = fun11uni () |- ( ∀ u ∈ { z | ∃ x ∈ A z = B } ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) → ( Fun ⋃ { z | ∃ x ∈ A z = B } ∧ Fun ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ) ) ;;
	step 48 : wff = syl (step 46, step 47) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( Fun ⋃ { z | ∃ x ∈ A z = B } ∧ Fun ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ) ) ;;
	step 49 : wff = simpld (step 48) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → Fun ⋃ { z | ∃ x ∈ A z = B } ) ;;
	step 50 : wff = dfiun2 (hyp 2) |- ⋃_ x ∈ A B = ⋃ { z | ∃ x ∈ A z = B } ;;
	step 51 : wff = funeqi (step 50) |- ( Fun ⋃_ x ∈ A B ↔ Fun ⋃ { z | ∃ x ∈ A z = B } ) ;;
	step 52 : wff = sylibr (step 49, step 51) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → Fun ⋃_ x ∈ A B ) ;;
	step 53 : wff = nfra1 () |- F/ x ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ;;
	step 54 : wff = rsp () |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( x ∈ A → ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ) ) ;;
	step 55 : wff = vex () |- u ∈ _V ;;
	step 56 : wff = eldm2 (step 55) |- ( u ∈ dom B ↔ ∃ v 〈 u , v 〉 ∈ B ) ;;
	step 57 : wff = f1dm () |- ( B : D ↣ S → dom B = D ) ;;
	step 58 : wff = eleq2d (step 57) |- ( B : D ↣ S → ( u ∈ dom B ↔ u ∈ D ) ) ;;
	step 59 : wff = syl5bbr (step 56, step 58) |- ( B : D ↣ S → ( ∃ v 〈 u , v 〉 ∈ B ↔ u ∈ D ) ) ;;
	step 60 : wff = adantr (step 59) |- ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( ∃ v 〈 u , v 〉 ∈ B ↔ u ∈ D ) ) ;;
	step 61 : wff = syl6 (step 54, step 60) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( x ∈ A → ( ∃ v 〈 u , v 〉 ∈ B ↔ u ∈ D ) ) ) ;;
	step 62 : wff = imp (step 61) |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ x ∈ A ) → ( ∃ v 〈 u , v 〉 ∈ B ↔ u ∈ D ) ) ;;
	step 63 : wff = rexbida (step 53, step 62) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( ∃ x ∈ A ∃ v 〈 u , v 〉 ∈ B ↔ ∃ x ∈ A u ∈ D ) ) ;;
	step 64 : wff = eliun () |- ( 〈 u , v 〉 ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A 〈 u , v 〉 ∈ B ) ;;
	step 65 : wff = exbii (step 64) |- ( ∃ v 〈 u , v 〉 ∈ ⋃_ x ∈ A B ↔ ∃ v ∃ x ∈ A 〈 u , v 〉 ∈ B ) ;;
	step 66 : wff = vex () |- u ∈ _V ;;
	step 67 : wff = eldm2 (step 66) |- ( u ∈ dom ⋃_ x ∈ A B ↔ ∃ v 〈 u , v 〉 ∈ ⋃_ x ∈ A B ) ;;
	step 68 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ v 〈 u , v 〉 ∈ B ↔ ∃ v ∃ x ∈ A 〈 u , v 〉 ∈ B ) ;;
	step 69 : wff = 3bitr4i (step 65, step 67, step 68) |- ( u ∈ dom ⋃_ x ∈ A B ↔ ∃ x ∈ A ∃ v 〈 u , v 〉 ∈ B ) ;;
	step 70 : wff = eliun () |- ( u ∈ ⋃_ x ∈ A D ↔ ∃ x ∈ A u ∈ D ) ;;
	step 71 : wff = 3bitr4g (step 63, step 69, step 70) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( u ∈ dom ⋃_ x ∈ A B ↔ u ∈ ⋃_ x ∈ A D ) ) ;;
	step 72 : wff = eqrdv (step 71) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → dom ⋃_ x ∈ A B = ⋃_ x ∈ A D ) ;;
	step 73 : wff = df-fn () |- ( ⋃_ x ∈ A B Fn ⋃_ x ∈ A D ↔ ( Fun ⋃_ x ∈ A B ∧ dom ⋃_ x ∈ A B = ⋃_ x ∈ A D ) ) ;;
	step 74 : wff = sylanbrc (step 52, step 72, step 73) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ⋃_ x ∈ A B Fn ⋃_ x ∈ A D ) ;;
	step 75 : wff = rniun () |- ran ⋃_ x ∈ A B = ⋃_ x ∈ A ran B ;;
	step 76 : wff = f1f () |- ( B : D ↣ S → B : D ⟶ S ) ;;
	step 77 : wff = frn () |- ( B : D ⟶ S → ran B ⊆ S ) ;;
	step 78 : wff = syl (step 76, step 77) |- ( B : D ↣ S → ran B ⊆ S ) ;;
	step 79 : wff = adantr (step 78) |- ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ran B ⊆ S ) ;;
	step 80 : wff = ralimi (step 79) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ∀ x ∈ A ran B ⊆ S ) ;;
	step 81 : wff = iunss () |- ( ⋃_ x ∈ A ran B ⊆ S ↔ ∀ x ∈ A ran B ⊆ S ) ;;
	step 82 : wff = sylibr (step 80, step 81) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ⋃_ x ∈ A ran B ⊆ S ) ;;
	step 83 : wff = syl5eqss (step 75, step 82) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ran ⋃_ x ∈ A B ⊆ S ) ;;
	step 84 : wff = df-f () |- ( ⋃_ x ∈ A B : ⋃_ x ∈ A D ⟶ S ↔ ( ⋃_ x ∈ A B Fn ⋃_ x ∈ A D ∧ ran ⋃_ x ∈ A B ⊆ S ) ) ;;
	step 85 : wff = sylanbrc (step 74, step 83, step 84) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ⋃_ x ∈ A B : ⋃_ x ∈ A D ⟶ S ) ;;
	step 86 : wff = vex () |- u ∈ _V ;;
	step 87 : wff = eqeq1 () |- ( z = u → ( z = B ↔ u = B ) ) ;;
	step 88 : wff = rexbidv (step 87) |- ( z = u → ( ∃ x ∈ A z = B ↔ ∃ x ∈ A u = B ) ) ;;
	step 89 : wff = elab (step 86, step 88) |- ( u ∈ { z | ∃ x ∈ A z = B } ↔ ∃ x ∈ A u = B ) ;;
	step 90 : wff = r19.29 () |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ ∃ x ∈ A u = B ) → ∃ x ∈ A ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ) ;;
	step 91 : wff = nfv () |- F/ x ( Fun u ∧ Fun ⁻¹ u ) ;;
	step 92 : wff = nfre1 () |- F/ x ∃ x ∈ A z = B ;;
	step 93 : wff = nfab (step 92) |- F/_ x { z | ∃ x ∈ A z = B } ;;
	step 94 : wff = nfv () |- F/ x ( u ⊆ v ∨ v ⊆ u ) ;;
	step 95 : wff = nfral (step 93, step 94) |- F/ x ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ;;
	step 96 : wff = nfan (step 91, step 95) |- F/ x ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 97 : wff = f1eq1 () |- ( u = B → ( u : D ↣ S ↔ B : D ↣ S ) ) ;;
	step 98 : wff = biimparc (step 97) |- ( ( B : D ↣ S ∧ u = B ) → u : D ↣ S ) ;;
	step 99 : wff = df-f1 () |- ( u : D ↣ S ↔ ( u : D ⟶ S ∧ Fun ⁻¹ u ) ) ;;
	step 100 : wff = ffun () |- ( u : D ⟶ S → Fun u ) ;;
	step 101 : wff = anim1i (step 100) |- ( ( u : D ⟶ S ∧ Fun ⁻¹ u ) → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 102 : wff = sylbi (step 99, step 101) |- ( u : D ↣ S → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 103 : wff = syl (step 98, step 102) |- ( ( B : D ↣ S ∧ u = B ) → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 104 : wff = adantlr (step 103) |- ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( Fun u ∧ Fun ⁻¹ u ) ) ;;
	step 105 : wff = vex () |- v ∈ _V ;;
	step 106 : wff = eqeq1 () |- ( z = v → ( z = B ↔ v = B ) ) ;;
	step 107 : wff = rexbidv (step 106) |- ( z = v → ( ∃ x ∈ A z = B ↔ ∃ x ∈ A v = B ) ) ;;
	step 108 : wff = elab (step 105, step 107) |- ( v ∈ { z | ∃ x ∈ A z = B } ↔ ∃ x ∈ A v = B ) ;;
	step 109 : wff = eqeq2d (hyp 1) |- ( x = y → ( v = B ↔ v = C ) ) ;;
	step 110 : wff = cbvrexv (step 109) |- ( ∃ x ∈ A v = B ↔ ∃ y ∈ A v = C ) ;;
	step 111 : wff = r19.29 () |- ( ( ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ∧ ∃ y ∈ A v = C ) → ∃ y ∈ A ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) ) ;;
	step 112 : wff = sseq12 () |- ( ( u = B ∧ v = C ) → ( u ⊆ v ↔ B ⊆ C ) ) ;;
	step 113 : wff = ancoms (step 112) |- ( ( v = C ∧ u = B ) → ( u ⊆ v ↔ B ⊆ C ) ) ;;
	step 114 : wff = sseq12 () |- ( ( v = C ∧ u = B ) → ( v ⊆ u ↔ C ⊆ B ) ) ;;
	step 115 : wff = orbi12d (step 113, step 114) |- ( ( v = C ∧ u = B ) → ( ( u ⊆ v ∨ v ⊆ u ) ↔ ( B ⊆ C ∨ C ⊆ B ) ) ) ;;
	step 116 : wff = biimprcd (step 115) |- ( ( B ⊆ C ∨ C ⊆ B ) → ( ( v = C ∧ u = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 117 : wff = expdimp (step 116) |- ( ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) → ( u = B → ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 118 : wff = rexlimivw (step 117) |- ( ∃ y ∈ A ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) → ( u = B → ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 119 : wff = imp (step 118) |- ( ( ∃ y ∈ A ( ( B ⊆ C ∨ C ⊆ B ) ∧ v = C ) ∧ u = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 120 : wff = sylan (step 111, step 119) |- ( ( ( ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ∧ ∃ y ∈ A v = C ) ∧ u = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 121 : wff = an32s (step 120) |- ( ( ( ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ∧ u = B ) ∧ ∃ y ∈ A v = C ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 122 : wff = adantlll (step 121) |- ( ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ∧ ∃ y ∈ A v = C ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 123 : wff = sylan2b (step 110, step 122) |- ( ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ∧ ∃ x ∈ A v = B ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 124 : wff = sylan2b (step 108, step 123) |- ( ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) ∧ v ∈ { z | ∃ x ∈ A z = B } ) → ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 125 : wff = ralrimiva (step 124) |- ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ;;
	step 126 : wff = jca (step 104, step 125) |- ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 127 : wff = a1i (step 126) |- ( x ∈ A → ( ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ) ;;
	step 128 : wff = rexlimi (step 96, step 127) |- ( ∃ x ∈ A ( ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 129 : wff = syl (step 90, step 128) |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ ∃ x ∈ A u = B ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 130 : wff = sylan2b (step 89, step 129) |- ( ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) ∧ u ∈ { z | ∃ x ∈ A z = B } ) → ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 131 : wff = ralrimiva (step 130) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ∀ u ∈ { z | ∃ x ∈ A z = B } ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) ) ;;
	step 132 : wff = fun11uni () |- ( ∀ u ∈ { z | ∃ x ∈ A z = B } ( ( Fun u ∧ Fun ⁻¹ u ) ∧ ∀ v ∈ { z | ∃ x ∈ A z = B } ( u ⊆ v ∨ v ⊆ u ) ) → ( Fun ⋃ { z | ∃ x ∈ A z = B } ∧ Fun ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ) ) ;;
	step 133 : wff = syl (step 131, step 132) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ( Fun ⋃ { z | ∃ x ∈ A z = B } ∧ Fun ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ) ) ;;
	step 134 : wff = simprd (step 133) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → Fun ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ) ;;
	step 135 : wff = dfiun2 (hyp 2) |- ⋃_ x ∈ A B = ⋃ { z | ∃ x ∈ A z = B } ;;
	step 136 : wff = cnveqi (step 135) |- ⁻¹ ⋃_ x ∈ A B = ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ;;
	step 137 : wff = funeqi (step 136) |- ( Fun ⁻¹ ⋃_ x ∈ A B ↔ Fun ⁻¹ ⋃ { z | ∃ x ∈ A z = B } ) ;;
	step 138 : wff = sylibr (step 134, step 137) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → Fun ⁻¹ ⋃_ x ∈ A B ) ;;
	step 139 : wff = df-f1 () |- ( ⋃_ x ∈ A B : ⋃_ x ∈ A D ↣ S ↔ ( ⋃_ x ∈ A B : ⋃_ x ∈ A D ⟶ S ∧ Fun ⁻¹ ⋃_ x ∈ A B ) ) ;;
	step 140 : wff = sylanbrc (step 85, step 138, step 139) |- ( ∀ x ∈ A ( B : D ↣ S ∧ ∀ y ∈ A ( B ⊆ C ∨ C ⊆ B ) ) → ⋃_ x ∈ A B : ⋃_ x ∈ A D ↣ S ) ;;
	qed prop 1 = step 140 ;;
}

/*The restriction of a one-to-one onto function to a difference maps onto
     the difference of the images.  (Contributed by Paul Chapman,
     11-Apr-2009.) */

theorem resdif (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( C ∖ D ) ) ;;
}

proof of resdif {
	step 1 : wff = fofun () |- ( ( F ↾ A ) : A ↠ C → Fun ( F ↾ A ) ) ;;
	step 2 : wff = difss () |- ( A ∖ B ) ⊆ A ;;
	step 3 : wff = fof () |- ( ( F ↾ A ) : A ↠ C → ( F ↾ A ) : A ⟶ C ) ;;
	step 4 : wff = fdm () |- ( ( F ↾ A ) : A ⟶ C → dom ( F ↾ A ) = A ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ( F ↾ A ) : A ↠ C → dom ( F ↾ A ) = A ) ;;
	step 6 : wff = syl5sseqr (step 2, step 5) |- ( ( F ↾ A ) : A ↠ C → ( A ∖ B ) ⊆ dom ( F ↾ A ) ) ;;
	step 7 : wff = fores () |- ( ( Fun ( F ↾ A ) ∧ ( A ∖ B ) ⊆ dom ( F ↾ A ) ) → ( ( F ↾ A ) ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ) ;;
	step 8 : wff = syl2anc (step 1, step 6, step 7) |- ( ( F ↾ A ) : A ↠ C → ( ( F ↾ A ) ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ) ;;
	step 9 : wff = resres () |- ( ( F ↾ A ) ↾ ( A ∖ B ) ) = ( F ↾ ( A ∩ ( A ∖ B ) ) ) ;;
	step 10 : wff = indif () |- ( A ∩ ( A ∖ B ) ) = ( A ∖ B ) ;;
	step 11 : wff = reseq2i (step 10) |- ( F ↾ ( A ∩ ( A ∖ B ) ) ) = ( F ↾ ( A ∖ B ) ) ;;
	step 12 : wff = eqtri (step 9, step 11) |- ( ( F ↾ A ) ↾ ( A ∖ B ) ) = ( F ↾ ( A ∖ B ) ) ;;
	step 13 : wff = foeq1 () |- ( ( ( F ↾ A ) ↾ ( A ∖ B ) ) = ( F ↾ ( A ∖ B ) ) → ( ( ( F ↾ A ) ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ) ) ;;
	step 14 : wff = ax-mp (step 12, step 13) |- ( ( ( F ↾ A ) ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ) ;;
	step 15 : wff = resres () |- ( ( F ↾ A ) ↾ ( A ∖ B ) ) = ( F ↾ ( A ∩ ( A ∖ B ) ) ) ;;
	step 16 : wff = indif () |- ( A ∩ ( A ∖ B ) ) = ( A ∖ B ) ;;
	step 17 : wff = reseq2i (step 16) |- ( F ↾ ( A ∩ ( A ∖ B ) ) ) = ( F ↾ ( A ∖ B ) ) ;;
	step 18 : wff = eqtri (step 15, step 17) |- ( ( F ↾ A ) ↾ ( A ∖ B ) ) = ( F ↾ ( A ∖ B ) ) ;;
	step 19 : wff = rneqi (step 18) |- ran ( ( F ↾ A ) ↾ ( A ∖ B ) ) = ran ( F ↾ ( A ∖ B ) ) ;;
	step 20 : wff = df-ima () |- ( ( F ↾ A ) " ( A ∖ B ) ) = ran ( ( F ↾ A ) ↾ ( A ∖ B ) ) ;;
	step 21 : wff = df-ima () |- ( F " ( A ∖ B ) ) = ran ( F ↾ ( A ∖ B ) ) ;;
	step 22 : wff = 3eqtr4i (step 19, step 20, step 21) |- ( ( F ↾ A ) " ( A ∖ B ) ) = ( F " ( A ∖ B ) ) ;;
	step 23 : wff = foeq3 () |- ( ( ( F ↾ A ) " ( A ∖ B ) ) = ( F " ( A ∖ B ) ) → ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( F " ( A ∖ B ) ) ) ) ;;
	step 24 : wff = ax-mp (step 22, step 23) |- ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( F " ( A ∖ B ) ) ) ;;
	step 25 : wff = bitri (step 14, step 24) |- ( ( ( F ↾ A ) ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( ( F ↾ A ) " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( F " ( A ∖ B ) ) ) ;;
	step 26 : wff = sylib (step 8, step 25) |- ( ( F ↾ A ) : A ↠ C → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( F " ( A ∖ B ) ) ) ;;
	step 27 : wff = funres11 () |- ( Fun ⁻¹ F → Fun ⁻¹ ( F ↾ ( A ∖ B ) ) ) ;;
	step 28 : wff = dff1o3 () |- ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( F " ( A ∖ B ) ) ↔ ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( F " ( A ∖ B ) ) ∧ Fun ⁻¹ ( F ↾ ( A ∖ B ) ) ) ) ;;
	step 29 : wff = biimpri (step 28) |- ( ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( F " ( A ∖ B ) ) ∧ Fun ⁻¹ ( F ↾ ( A ∖ B ) ) ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( F " ( A ∖ B ) ) ) ;;
	step 30 : wff = syl2anr (step 26, step 27, step 29) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( F " ( A ∖ B ) ) ) ;;
	step 31 : wff = 3adant3 (step 30) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( F " ( A ∖ B ) ) ) ;;
	step 32 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 33 : wff = forn () |- ( ( F ↾ A ) : A ↠ C → ran ( F ↾ A ) = C ) ;;
	step 34 : wff = syl5eq (step 32, step 33) |- ( ( F ↾ A ) : A ↠ C → ( F " A ) = C ) ;;
	step 35 : wff = df-ima () |- ( F " B ) = ran ( F ↾ B ) ;;
	step 36 : wff = forn () |- ( ( F ↾ B ) : B ↠ D → ran ( F ↾ B ) = D ) ;;
	step 37 : wff = syl5eq (step 35, step 36) |- ( ( F ↾ B ) : B ↠ D → ( F " B ) = D ) ;;
	step 38 : wff = anim12i (step 34, step 37) |- ( ( ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( ( F " A ) = C ∧ ( F " B ) = D ) ) ;;
	step 39 : wff = imadif () |- ( Fun ⁻¹ F → ( F " ( A ∖ B ) ) = ( ( F " A ) ∖ ( F " B ) ) ) ;;
	step 40 : wff = difeq12 () |- ( ( ( F " A ) = C ∧ ( F " B ) = D ) → ( ( F " A ) ∖ ( F " B ) ) = ( C ∖ D ) ) ;;
	step 41 : wff = sylan9eq (step 39, step 40) |- ( ( Fun ⁻¹ F ∧ ( ( F " A ) = C ∧ ( F " B ) = D ) ) → ( F " ( A ∖ B ) ) = ( C ∖ D ) ) ;;
	step 42 : wff = sylan2 (step 38, step 41) |- ( ( Fun ⁻¹ F ∧ ( ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) ) → ( F " ( A ∖ B ) ) = ( C ∖ D ) ) ;;
	step 43 : wff = 3impb (step 42) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F " ( A ∖ B ) ) = ( C ∖ D ) ) ;;
	step 44 : wff = f1oeq3 () |- ( ( F " ( A ∖ B ) ) = ( C ∖ D ) → ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( F " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( C ∖ D ) ) ) ;;
	step 45 : wff = syl (step 43, step 44) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( F " ( A ∖ B ) ) ↔ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( C ∖ D ) ) ) ;;
	step 46 : wff = mpbid (step 31, step 45) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( C ∖ D ) ) ;;
	qed prop 1 = step 46 ;;
}

/*The restriction of a one-to-one onto function to an intersection maps onto
     the intersection of the images.  (Contributed by Paul Chapman,
     11-Apr-2009.) */

theorem resin (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∩ D ) ) ;;
}

proof of resin {
	step 1 : wff = resdif () |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( C ∖ D ) ) ;;
	step 2 : wff = f1ofo () |- ( ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ⤖ ( C ∖ D ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( C ∖ D ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( C ∖ D ) ) ;;
	step 4 : wff = resdif () |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ ( A ∖ B ) ) : ( A ∖ B ) ↠ ( C ∖ D ) ) → ( F ↾ ( A ∖ ( A ∖ B ) ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ) ;;
	step 5 : wff = syld3an3 (step 3, step 4) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∖ ( A ∖ B ) ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ) ;;
	step 6 : wff = dfin4 () |- ( C ∩ D ) = ( C ∖ ( C ∖ D ) ) ;;
	step 7 : wff = f1oeq3 () |- ( ( C ∩ D ) = ( C ∖ ( C ∖ D ) ) → ( ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∩ D ) ↔ ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∖ ( C ∖ D ) ) ) ) ;;
	step 8 : wff = ax-mp (step 6, step 7) |- ( ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∩ D ) ↔ ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∖ ( C ∖ D ) ) ) ;;
	step 9 : wff = dfin4 () |- ( A ∩ B ) = ( A ∖ ( A ∖ B ) ) ;;
	step 10 : wff = f1oeq2 () |- ( ( A ∩ B ) = ( A ∖ ( A ∖ B ) ) → ( ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∖ ( C ∖ D ) ) ↔ ( F ↾ ( A ∩ B ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ) ) ;;
	step 11 : wff = ax-mp (step 9, step 10) |- ( ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∖ ( C ∖ D ) ) ↔ ( F ↾ ( A ∩ B ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ) ;;
	step 12 : wff = dfin4 () |- ( A ∩ B ) = ( A ∖ ( A ∖ B ) ) ;;
	step 13 : wff = reseq2i (step 12) |- ( F ↾ ( A ∩ B ) ) = ( F ↾ ( A ∖ ( A ∖ B ) ) ) ;;
	step 14 : wff = f1oeq1 () |- ( ( F ↾ ( A ∩ B ) ) = ( F ↾ ( A ∖ ( A ∖ B ) ) ) → ( ( F ↾ ( A ∩ B ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ↔ ( F ↾ ( A ∖ ( A ∖ B ) ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ) ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- ( ( F ↾ ( A ∩ B ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ↔ ( F ↾ ( A ∖ ( A ∖ B ) ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ) ;;
	step 16 : wff = 3bitrri (step 8, step 11, step 15) |- ( ( F ↾ ( A ∖ ( A ∖ B ) ) ) : ( A ∖ ( A ∖ B ) ) ⤖ ( C ∖ ( C ∖ D ) ) ↔ ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∩ D ) ) ;;
	step 17 : wff = sylib (step 5, step 16) |- ( ( Fun ⁻¹ F ∧ ( F ↾ A ) : A ↠ C ∧ ( F ↾ B ) : B ↠ D ) → ( F ↾ ( A ∩ B ) ) : ( A ∩ B ) ⤖ ( C ∩ D ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Composition of one-to-one onto functions.  (Contributed by NM,
     19-Mar-1998.) */

theorem f1oco (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F : B ⤖ C ∧ G : A ⤖ B ) → ( F ∘ G ) : A ⤖ C ) ;;
}

proof of f1oco {
	step 1 : wff = df-f1o () |- ( F : B ⤖ C ↔ ( F : B ↣ C ∧ F : B ↠ C ) ) ;;
	step 2 : wff = df-f1o () |- ( G : A ⤖ B ↔ ( G : A ↣ B ∧ G : A ↠ B ) ) ;;
	step 3 : wff = f1co () |- ( ( F : B ↣ C ∧ G : A ↣ B ) → ( F ∘ G ) : A ↣ C ) ;;
	step 4 : wff = foco () |- ( ( F : B ↠ C ∧ G : A ↠ B ) → ( F ∘ G ) : A ↠ C ) ;;
	step 5 : wff = anim12i (step 3, step 4) |- ( ( ( F : B ↣ C ∧ G : A ↣ B ) ∧ ( F : B ↠ C ∧ G : A ↠ B ) ) → ( ( F ∘ G ) : A ↣ C ∧ ( F ∘ G ) : A ↠ C ) ) ;;
	step 6 : wff = an4s (step 5) |- ( ( ( F : B ↣ C ∧ F : B ↠ C ) ∧ ( G : A ↣ B ∧ G : A ↠ B ) ) → ( ( F ∘ G ) : A ↣ C ∧ ( F ∘ G ) : A ↠ C ) ) ;;
	step 7 : wff = syl2anb (step 1, step 2, step 6) |- ( ( F : B ⤖ C ∧ G : A ⤖ B ) → ( ( F ∘ G ) : A ↣ C ∧ ( F ∘ G ) : A ↠ C ) ) ;;
	step 8 : wff = df-f1o () |- ( ( F ∘ G ) : A ⤖ C ↔ ( ( F ∘ G ) : A ↣ C ∧ ( F ∘ G ) : A ↠ C ) ) ;;
	step 9 : wff = sylibr (step 7, step 8) |- ( ( F : B ⤖ C ∧ G : A ⤖ B ) → ( F ∘ G ) : A ⤖ C ) ;;
	qed prop 1 = step 9 ;;
}

/*The converse of an injective function is bijective.  (Contributed by FL,
     11-Nov-2011.) */

theorem f1cnv (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → ⁻¹ F : ran F ⤖ A ) ;;
}

proof of f1cnv {
	step 1 : wff = f1f1orn () |- ( F : A ↣ B → F : A ⤖ ran F ) ;;
	step 2 : wff = f1ocnv () |- ( F : A ⤖ ran F → ⁻¹ F : ran F ⤖ A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → ⁻¹ F : ran F ⤖ A ) ;;
	qed prop 1 = step 3 ;;
}

/*Composition with the converse.  (Contributed by Jeff Madsen,
     2-Sep-2009.) */

theorem funcocnv2 (F : class)  {
	prop 1 : wff = |- ( Fun F → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
}

proof of funcocnv2 {
	step 1 : wff = df-fun () |- ( Fun F ↔ ( Rel F ∧ ( F ∘ ⁻¹ F ) ⊆ _I ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( Fun F → ( F ∘ ⁻¹ F ) ⊆ _I ) ;;
	step 3 : wff = iss () |- ( ( F ∘ ⁻¹ F ) ⊆ _I ↔ ( F ∘ ⁻¹ F ) = ( _I ↾ dom ( F ∘ ⁻¹ F ) ) ) ;;
	step 4 : wff = dfdm4 () |- dom F = ran ⁻¹ F ;;
	step 5 : wff = dmcoeq () |- ( dom F = ran ⁻¹ F → dom ( F ∘ ⁻¹ F ) = dom ⁻¹ F ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- dom ( F ∘ ⁻¹ F ) = dom ⁻¹ F ;;
	step 7 : wff = df-rn () |- ran F = dom ⁻¹ F ;;
	step 8 : wff = eqtr4i (step 6, step 7) |- dom ( F ∘ ⁻¹ F ) = ran F ;;
	step 9 : wff = a1i (step 8) |- ( Fun F → dom ( F ∘ ⁻¹ F ) = ran F ) ;;
	step 10 : wff = reseq2d (step 9) |- ( Fun F → ( _I ↾ dom ( F ∘ ⁻¹ F ) ) = ( _I ↾ ran F ) ) ;;
	step 11 : wff = eqeq2d (step 10) |- ( Fun F → ( ( F ∘ ⁻¹ F ) = ( _I ↾ dom ( F ∘ ⁻¹ F ) ) ↔ ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ) ;;
	step 12 : wff = syl5bb (step 3, step 11) |- ( Fun F → ( ( F ∘ ⁻¹ F ) ⊆ _I ↔ ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ) ;;
	step 13 : wff = mpbid (step 2, step 12) |- ( Fun F → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
	qed prop 1 = step 13 ;;
}

/*The composition of an onto function and its converse.  (Contributed by
     Stefan O'Rear, 12-Feb-2015.) */

theorem fococnv2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↠ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
}

proof of fococnv2 {
	step 1 : wff = fofun () |- ( F : A ↠ B → Fun F ) ;;
	step 2 : wff = funcocnv2 () |- ( Fun F → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↠ B → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
	step 4 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 5 : wff = reseq2d (step 4) |- ( F : A ↠ B → ( _I ↾ ran F ) = ( _I ↾ B ) ) ;;
	step 6 : wff = eqtrd (step 3, step 5) |- ( F : A ↠ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The composition of a one-to-one onto function and its converse equals the
     identity relation restricted to the function's range.  (Contributed by NM,
     13-Dec-2003.)  (Proof shortened by Stefan O'Rear, 12-Feb-2015.) */

theorem f1ococnv2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
}

proof of f1ococnv2 {
	step 1 : wff = f1ofo () |- ( F : A ⤖ B → F : A ↠ B ) ;;
	step 2 : wff = fococnv2 () |- ( F : A ↠ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Composition of an injective function with its converse.  (Contributed by
     FL, 11-Nov-2011.) */

theorem f1cocnv2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
}

proof of f1cocnv2 {
	step 1 : wff = f1fun () |- ( F : A ↣ B → Fun F ) ;;
	step 2 : wff = funcocnv2 () |- ( Fun F → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → ( F ∘ ⁻¹ F ) = ( _I ↾ ran F ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The composition of a one-to-one onto function's converse and itself equals
     the identity relation restricted to the function's domain.  (Contributed
     by NM, 13-Dec-2003.) */

theorem f1ococnv1 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⤖ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
}

proof of f1ococnv1 {
	step 1 : wff = f1orel () |- ( F : A ⤖ B → Rel F ) ;;
	step 2 : wff = dfrel2 () |- ( Rel F ↔ ⁻¹ ⁻¹ F = F ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( F : A ⤖ B → ⁻¹ ⁻¹ F = F ) ;;
	step 4 : wff = coeq2d (step 3) |- ( F : A ⤖ B → ( ⁻¹ F ∘ ⁻¹ ⁻¹ F ) = ( ⁻¹ F ∘ F ) ) ;;
	step 5 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 6 : wff = f1ococnv2 () |- ( ⁻¹ F : B ⤖ A → ( ⁻¹ F ∘ ⁻¹ ⁻¹ F ) = ( _I ↾ A ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( F : A ⤖ B → ( ⁻¹ F ∘ ⁻¹ ⁻¹ F ) = ( _I ↾ A ) ) ;;
	step 8 : wff = eqtr3d (step 4, step 7) |- ( F : A ⤖ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Composition of an injective function with its converse.  (Contributed by
     FL, 11-Nov-2011.) */

theorem f1cocnv1 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ↣ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
}

proof of f1cocnv1 {
	step 1 : wff = f1f1orn () |- ( F : A ↣ B → F : A ⤖ ran F ) ;;
	step 2 : wff = f1ococnv1 () |- ( F : A ⤖ ran F → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Re-express a constraint on a composition as a constraint on the
     composand.  (Contributed by Stefan O'Rear, 7-Mar-2015.) */

theorem funcoeqres (F : class, G : class, H : class)  {
	prop 1 : wff = |- ( ( Fun G ∧ ( F ∘ G ) = H ) → ( F ↾ ran G ) = ( H ∘ ⁻¹ G ) ) ;;
}

proof of funcoeqres {
	step 1 : wff = funcocnv2 () |- ( Fun G → ( G ∘ ⁻¹ G ) = ( _I ↾ ran G ) ) ;;
	step 2 : wff = coeq2d (step 1) |- ( Fun G → ( F ∘ ( G ∘ ⁻¹ G ) ) = ( F ∘ ( _I ↾ ran G ) ) ) ;;
	step 3 : wff = coass () |- ( ( F ∘ G ) ∘ ⁻¹ G ) = ( F ∘ ( G ∘ ⁻¹ G ) ) ;;
	step 4 : wff = eqcomi (step 3) |- ( F ∘ ( G ∘ ⁻¹ G ) ) = ( ( F ∘ G ) ∘ ⁻¹ G ) ;;
	step 5 : wff = coires1 () |- ( F ∘ ( _I ↾ ran G ) ) = ( F ↾ ran G ) ;;
	step 6 : wff = 3eqtr3g (step 2, step 4, step 5) |- ( Fun G → ( ( F ∘ G ) ∘ ⁻¹ G ) = ( F ↾ ran G ) ) ;;
	step 7 : wff = coeq1 () |- ( ( F ∘ G ) = H → ( ( F ∘ G ) ∘ ⁻¹ G ) = ( H ∘ ⁻¹ G ) ) ;;
	step 8 : wff = sylan9req (step 6, step 7) |- ( ( Fun G ∧ ( F ∘ G ) = H ) → ( F ↾ ran G ) = ( H ∘ ⁻¹ G ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Relationship between a mapping and an onto mapping.  Figure 38 of
       [Enderton] p. 145.  (Contributed by NM, 10-May-1998.) */

theorem ffoss (x : set, A : class, B : class, F : class) disjointed(x F, x A, x B) {
	hyp 1 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ B ↔ ∃ x ( F : A ↠ x ∧ x ⊆ B ) ) ;;
}

proof of ffoss {
	step 1 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 2 : wff = dffn4 () |- ( F Fn A ↔ F : A ↠ ran F ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( F Fn A ∧ ran F ⊆ B ) ↔ ( F : A ↠ ran F ∧ ran F ⊆ B ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( F : A ⟶ B ↔ ( F : A ↠ ran F ∧ ran F ⊆ B ) ) ;;
	step 5 : wff = rnex (hyp 1) |- ran F ∈ _V ;;
	step 6 : wff = foeq3 () |- ( x = ran F → ( F : A ↠ x ↔ F : A ↠ ran F ) ) ;;
	step 7 : wff = sseq1 () |- ( x = ran F → ( x ⊆ B ↔ ran F ⊆ B ) ) ;;
	step 8 : wff = anbi12d (step 6, step 7) |- ( x = ran F → ( ( F : A ↠ x ∧ x ⊆ B ) ↔ ( F : A ↠ ran F ∧ ran F ⊆ B ) ) ) ;;
	step 9 : wff = spcev (step 5, step 8) |- ( ( F : A ↠ ran F ∧ ran F ⊆ B ) → ∃ x ( F : A ↠ x ∧ x ⊆ B ) ) ;;
	step 10 : wff = sylbi (step 4, step 9) |- ( F : A ⟶ B → ∃ x ( F : A ↠ x ∧ x ⊆ B ) ) ;;
	step 11 : wff = fof () |- ( F : A ↠ x → F : A ⟶ x ) ;;
	step 12 : wff = fss () |- ( ( F : A ⟶ x ∧ x ⊆ B ) → F : A ⟶ B ) ;;
	step 13 : wff = sylan (step 11, step 12) |- ( ( F : A ↠ x ∧ x ⊆ B ) → F : A ⟶ B ) ;;
	step 14 : wff = exlimiv (step 13) |- ( ∃ x ( F : A ↠ x ∧ x ⊆ B ) → F : A ⟶ B ) ;;
	step 15 : wff = impbii (step 10, step 14) |- ( F : A ⟶ B ↔ ∃ x ( F : A ↠ x ∧ x ⊆ B ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Relationship between one-to-one and one-to-one onto function.
       (Contributed by NM, 4-Apr-1998.) */

theorem f11o (x : set, A : class, B : class, F : class) disjointed(x F, x A, x B) {
	hyp 1 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( F : A ↣ B ↔ ∃ x ( F : A ⤖ x ∧ x ⊆ B ) ) ;;
}

proof of f11o {
	step 1 : wff = ffoss (hyp 1) |- ( F : A ⟶ B ↔ ∃ x ( F : A ↠ x ∧ x ⊆ B ) ) ;;
	step 2 : wff = anbi1i (step 1) |- ( ( F : A ⟶ B ∧ Fun ⁻¹ F ) ↔ ( ∃ x ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ) ;;
	step 3 : wff = df-f1 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ Fun ⁻¹ F ) ) ;;
	step 4 : wff = dff1o3 () |- ( F : A ⤖ x ↔ ( F : A ↠ x ∧ Fun ⁻¹ F ) ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( F : A ⤖ x ∧ x ⊆ B ) ↔ ( ( F : A ↠ x ∧ Fun ⁻¹ F ) ∧ x ⊆ B ) ) ;;
	step 6 : wff = an32 () |- ( ( ( F : A ↠ x ∧ Fun ⁻¹ F ) ∧ x ⊆ B ) ↔ ( ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ) ;;
	step 7 : wff = bitri (step 5, step 6) |- ( ( F : A ⤖ x ∧ x ⊆ B ) ↔ ( ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ x ( F : A ⤖ x ∧ x ⊆ B ) ↔ ∃ x ( ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ) ;;
	step 9 : wff = 19.41v () |- ( ∃ x ( ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ↔ ( ∃ x ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ) ;;
	step 10 : wff = bitri (step 8, step 9) |- ( ∃ x ( F : A ⤖ x ∧ x ⊆ B ) ↔ ( ∃ x ( F : A ↠ x ∧ x ⊆ B ) ∧ Fun ⁻¹ F ) ) ;;
	step 11 : wff = 3bitr4i (step 2, step 3, step 10) |- ( F : A ↣ B ↔ ∃ x ( F : A ⤖ x ∧ x ⊆ B ) ) ;;
	qed prop 1 = step 11 ;;
}

/*The empty set maps one-to-one into any class.  (Contributed by NM,
     7-Apr-1998.) */

theorem f10 (A : class)  {
	prop 1 : wff = |- ∅ : ∅ ↣ A ;;
}

proof of f10 {
	step 1 : wff = f0 () |- ∅ : ∅ ⟶ A ;;
	step 2 : wff = fun0 () |- Fun ∅ ;;
	step 3 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 4 : wff = funeqi (step 3) |- ( Fun ⁻¹ ∅ ↔ Fun ∅ ) ;;
	step 5 : wff = mpbir (step 2, step 4) |- Fun ⁻¹ ∅ ;;
	step 6 : wff = df-f1 () |- ( ∅ : ∅ ↣ A ↔ ( ∅ : ∅ ⟶ A ∧ Fun ⁻¹ ∅ ) ) ;;
	step 7 : wff = mpbir2an (step 1, step 5, step 6) |- ∅ : ∅ ↣ A ;;
	qed prop 1 = step 7 ;;
}

/*One-to-one onto mapping of the empty set.  (Contributed by NM,
     15-Apr-1998.) */

theorem f1o00 (A : class, F : class)  {
	prop 1 : wff = |- ( F : ∅ ⤖ A ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
}

proof of f1o00 {
	step 1 : wff = dff1o4 () |- ( F : ∅ ⤖ A ↔ ( F Fn ∅ ∧ ⁻¹ F Fn A ) ) ;;
	step 2 : wff = fn0 () |- ( F Fn ∅ ↔ F = ∅ ) ;;
	step 3 : wff = biimpi (step 2) |- ( F Fn ∅ → F = ∅ ) ;;
	step 4 : wff = adantr (step 3) |- ( ( F Fn ∅ ∧ ⁻¹ F Fn A ) → F = ∅ ) ;;
	step 5 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 6 : wff = fn0 () |- ( F Fn ∅ ↔ F = ∅ ) ;;
	step 7 : wff = cnveq () |- ( F = ∅ → ⁻¹ F = ⁻¹ ∅ ) ;;
	step 8 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 9 : wff = syl6eq (step 7, step 8) |- ( F = ∅ → ⁻¹ F = ∅ ) ;;
	step 10 : wff = sylbi (step 6, step 9) |- ( F Fn ∅ → ⁻¹ F = ∅ ) ;;
	step 11 : wff = fneq1d (step 10) |- ( F Fn ∅ → ( ⁻¹ F Fn A ↔ ∅ Fn A ) ) ;;
	step 12 : wff = biimpa (step 11) |- ( ( F Fn ∅ ∧ ⁻¹ F Fn A ) → ∅ Fn A ) ;;
	step 13 : wff = fndm () |- ( ∅ Fn A → dom ∅ = A ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( ( F Fn ∅ ∧ ⁻¹ F Fn A ) → dom ∅ = A ) ;;
	step 15 : wff = syl5reqr (step 5, step 14) |- ( ( F Fn ∅ ∧ ⁻¹ F Fn A ) → A = ∅ ) ;;
	step 16 : wff = jca (step 4, step 15) |- ( ( F Fn ∅ ∧ ⁻¹ F Fn A ) → ( F = ∅ ∧ A = ∅ ) ) ;;
	step 17 : wff = fn0 () |- ( F Fn ∅ ↔ F = ∅ ) ;;
	step 18 : wff = biimpri (step 17) |- ( F = ∅ → F Fn ∅ ) ;;
	step 19 : wff = adantr (step 18) |- ( ( F = ∅ ∧ A = ∅ ) → F Fn ∅ ) ;;
	step 20 : wff = eqid () |- ∅ = ∅ ;;
	step 21 : wff = fn0 () |- ( ∅ Fn ∅ ↔ ∅ = ∅ ) ;;
	step 22 : wff = mpbir (step 20, step 21) |- ∅ Fn ∅ ;;
	step 23 : wff = cnveq () |- ( F = ∅ → ⁻¹ F = ⁻¹ ∅ ) ;;
	step 24 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 25 : wff = syl6eq (step 23, step 24) |- ( F = ∅ → ⁻¹ F = ∅ ) ;;
	step 26 : wff = fneq1d (step 25) |- ( F = ∅ → ( ⁻¹ F Fn A ↔ ∅ Fn A ) ) ;;
	step 27 : wff = fneq2 () |- ( A = ∅ → ( ∅ Fn A ↔ ∅ Fn ∅ ) ) ;;
	step 28 : wff = sylan9bb (step 26, step 27) |- ( ( F = ∅ ∧ A = ∅ ) → ( ⁻¹ F Fn A ↔ ∅ Fn ∅ ) ) ;;
	step 29 : wff = mpbiri (step 22, step 28) |- ( ( F = ∅ ∧ A = ∅ ) → ⁻¹ F Fn A ) ;;
	step 30 : wff = jca (step 19, step 29) |- ( ( F = ∅ ∧ A = ∅ ) → ( F Fn ∅ ∧ ⁻¹ F Fn A ) ) ;;
	step 31 : wff = impbii (step 16, step 30) |- ( ( F Fn ∅ ∧ ⁻¹ F Fn A ) ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
	step 32 : wff = bitri (step 1, step 31) |- ( F : ∅ ⤖ A ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
	qed prop 1 = step 32 ;;
}

/*Onto mapping of the empty set.  (Contributed by NM, 22-Mar-2006.) */

theorem fo00 (A : class, F : class)  {
	prop 1 : wff = |- ( F : ∅ ↠ A ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
}

proof of fo00 {
	step 1 : wff = fofn () |- ( F : ∅ ↠ A → F Fn ∅ ) ;;
	step 2 : wff = fn0 () |- ( F Fn ∅ ↔ F = ∅ ) ;;
	step 3 : wff = f10 () |- ∅ : ∅ ↣ A ;;
	step 4 : wff = f1eq1 () |- ( F = ∅ → ( F : ∅ ↣ A ↔ ∅ : ∅ ↣ A ) ) ;;
	step 5 : wff = mpbiri (step 3, step 4) |- ( F = ∅ → F : ∅ ↣ A ) ;;
	step 6 : wff = sylbi (step 2, step 5) |- ( F Fn ∅ → F : ∅ ↣ A ) ;;
	step 7 : wff = syl (step 1, step 6) |- ( F : ∅ ↠ A → F : ∅ ↣ A ) ;;
	step 8 : wff = ancri (step 7) |- ( F : ∅ ↠ A → ( F : ∅ ↣ A ∧ F : ∅ ↠ A ) ) ;;
	step 9 : wff = df-f1o () |- ( F : ∅ ⤖ A ↔ ( F : ∅ ↣ A ∧ F : ∅ ↠ A ) ) ;;
	step 10 : wff = sylibr (step 8, step 9) |- ( F : ∅ ↠ A → F : ∅ ⤖ A ) ;;
	step 11 : wff = f1ofo () |- ( F : ∅ ⤖ A → F : ∅ ↠ A ) ;;
	step 12 : wff = impbii (step 10, step 11) |- ( F : ∅ ↠ A ↔ F : ∅ ⤖ A ) ;;
	step 13 : wff = f1o00 () |- ( F : ∅ ⤖ A ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
	step 14 : wff = bitri (step 12, step 13) |- ( F : ∅ ↠ A ↔ ( F = ∅ ∧ A = ∅ ) ) ;;
	qed prop 1 = step 14 ;;
}

/*One-to-one onto mapping of the empty set.  (Contributed by NM,
     10-Sep-2004.) */

theorem f1o0 ()  {
	prop 1 : wff = |- ∅ : ∅ ⤖ ∅ ;;
}

proof of f1o0 {
	step 1 : wff = eqid () |- ∅ = ∅ ;;
	step 2 : wff = eqid () |- ∅ = ∅ ;;
	step 3 : wff = f1o00 () |- ( ∅ : ∅ ⤖ ∅ ↔ ( ∅ = ∅ ∧ ∅ = ∅ ) ) ;;
	step 4 : wff = mpbir2an (step 1, step 2, step 3) |- ∅ : ∅ ⤖ ∅ ;;
	qed prop 1 = step 4 ;;
}

/*A restriction of the identity relation is a one-to-one onto function.
     (Contributed by NM, 30-Apr-1998.)  (Proof shortened by Andrew Salmon,
     22-Oct-2011.) */

theorem f1oi (A : class)  {
	prop 1 : wff = |- ( _I ↾ A ) : A ⤖ A ;;
}

proof of f1oi {
	step 1 : wff = fnresi () |- ( _I ↾ A ) Fn A ;;
	step 2 : wff = fnresi () |- ( _I ↾ A ) Fn A ;;
	step 3 : wff = cnvresid () |- ⁻¹ ( _I ↾ A ) = ( _I ↾ A ) ;;
	step 4 : wff = fneq1i (step 3) |- ( ⁻¹ ( _I ↾ A ) Fn A ↔ ( _I ↾ A ) Fn A ) ;;
	step 5 : wff = mpbir (step 2, step 4) |- ⁻¹ ( _I ↾ A ) Fn A ;;
	step 6 : wff = dff1o4 () |- ( ( _I ↾ A ) : A ⤖ A ↔ ( ( _I ↾ A ) Fn A ∧ ⁻¹ ( _I ↾ A ) Fn A ) ) ;;
	step 7 : wff = mpbir2an (step 1, step 5, step 6) |- ( _I ↾ A ) : A ⤖ A ;;
	qed prop 1 = step 7 ;;
}

/*The identity relation is a one-to-one onto function on the universe.
     (Contributed by NM, 16-May-2004.) */

theorem f1ovi ()  {
	prop 1 : wff = |- _I : _V ⤖ _V ;;
}

proof of f1ovi {
	step 1 : wff = f1oi () |- ( _I ↾ _V ) : _V ⤖ _V ;;
	step 2 : wff = reli () |- Rel _I ;;
	step 3 : wff = dfrel3 () |- ( Rel _I ↔ ( _I ↾ _V ) = _I ) ;;
	step 4 : wff = mpbi (step 2, step 3) |- ( _I ↾ _V ) = _I ;;
	step 5 : wff = f1oeq1 () |- ( ( _I ↾ _V ) = _I → ( ( _I ↾ _V ) : _V ⤖ _V ↔ _I : _V ⤖ _V ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( ( _I ↾ _V ) : _V ⤖ _V ↔ _I : _V ⤖ _V ) ;;
	step 7 : wff = mpbi (step 1, step 6) |- _I : _V ⤖ _V ;;
	qed prop 1 = step 7 ;;
}

/*A singleton of an ordered pair is one-to-one onto function.
       (Contributed by NM, 18-May-1998.)  (Proof shortened by Andrew Salmon,
       22-Oct-2011.) */

theorem f1osn (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { 〈 A , B 〉 } : { A } ⤖ { B } ;;
}

proof of f1osn {
	step 1 : wff = fnsn (hyp 1, hyp 2) |- { 〈 A , B 〉 } Fn { A } ;;
	step 2 : wff = fnsn (hyp 2, hyp 1) |- { 〈 B , A 〉 } Fn { B } ;;
	step 3 : wff = cnvsn (hyp 1, hyp 2) |- ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ;;
	step 4 : wff = fneq1i (step 3) |- ( ⁻¹ { 〈 A , B 〉 } Fn { B } ↔ { 〈 B , A 〉 } Fn { B } ) ;;
	step 5 : wff = mpbir (step 2, step 4) |- ⁻¹ { 〈 A , B 〉 } Fn { B } ;;
	step 6 : wff = dff1o4 () |- ( { 〈 A , B 〉 } : { A } ⤖ { B } ↔ ( { 〈 A , B 〉 } Fn { A } ∧ ⁻¹ { 〈 A , B 〉 } Fn { B } ) ) ;;
	step 7 : wff = mpbir2an (step 1, step 5, step 6) |- { 〈 A , B 〉 } : { A } ⤖ { B } ;;
	qed prop 1 = step 7 ;;
}

/*A singleton of an ordered pair is one-to-one onto function.
       (Contributed by Mario Carneiro, 12-Jan-2013.) */

theorem f1osng (A : class, B : class, V : class, W : class) disjointed(A a b, B b) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 } : { A } ⤖ { B } ) ;;
}

proof of f1osng {
	var a : set, b : set;;
	step 1 : wff = sneq () |- ( a = A → { a } = { A } ) ;;
	step 2 : wff = f1oeq2 () |- ( { a } = { A } → ( { 〈 a , b 〉 } : { a } ⤖ { b } ↔ { 〈 a , b 〉 } : { A } ⤖ { b } ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( a = A → ( { 〈 a , b 〉 } : { a } ⤖ { b } ↔ { 〈 a , b 〉 } : { A } ⤖ { b } ) ) ;;
	step 4 : wff = opeq1 () |- ( a = A → 〈 a , b 〉 = 〈 A , b 〉 ) ;;
	step 5 : wff = sneqd (step 4) |- ( a = A → { 〈 a , b 〉 } = { 〈 A , b 〉 } ) ;;
	step 6 : wff = f1oeq1 () |- ( { 〈 a , b 〉 } = { 〈 A , b 〉 } → ( { 〈 a , b 〉 } : { A } ⤖ { b } ↔ { 〈 A , b 〉 } : { A } ⤖ { b } ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( a = A → ( { 〈 a , b 〉 } : { A } ⤖ { b } ↔ { 〈 A , b 〉 } : { A } ⤖ { b } ) ) ;;
	step 8 : wff = bitrd (step 3, step 7) |- ( a = A → ( { 〈 a , b 〉 } : { a } ⤖ { b } ↔ { 〈 A , b 〉 } : { A } ⤖ { b } ) ) ;;
	step 9 : wff = sneq () |- ( b = B → { b } = { B } ) ;;
	step 10 : wff = f1oeq3 () |- ( { b } = { B } → ( { 〈 A , b 〉 } : { A } ⤖ { b } ↔ { 〈 A , b 〉 } : { A } ⤖ { B } ) ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( b = B → ( { 〈 A , b 〉 } : { A } ⤖ { b } ↔ { 〈 A , b 〉 } : { A } ⤖ { B } ) ) ;;
	step 12 : wff = opeq2 () |- ( b = B → 〈 A , b 〉 = 〈 A , B 〉 ) ;;
	step 13 : wff = sneqd (step 12) |- ( b = B → { 〈 A , b 〉 } = { 〈 A , B 〉 } ) ;;
	step 14 : wff = f1oeq1 () |- ( { 〈 A , b 〉 } = { 〈 A , B 〉 } → ( { 〈 A , b 〉 } : { A } ⤖ { B } ↔ { 〈 A , B 〉 } : { A } ⤖ { B } ) ) ;;
	step 15 : wff = syl (step 13, step 14) |- ( b = B → ( { 〈 A , b 〉 } : { A } ⤖ { B } ↔ { 〈 A , B 〉 } : { A } ⤖ { B } ) ) ;;
	step 16 : wff = bitrd (step 11, step 15) |- ( b = B → ( { 〈 A , b 〉 } : { A } ⤖ { b } ↔ { 〈 A , B 〉 } : { A } ⤖ { B } ) ) ;;
	step 17 : wff = vex () |- a ∈ _V ;;
	step 18 : wff = vex () |- b ∈ _V ;;
	step 19 : wff = f1osn (step 17, step 18) |- { 〈 a , b 〉 } : { a } ⤖ { b } ;;
	step 20 : wff = vtocl2g (step 8, step 16, step 19) |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 } : { A } ⤖ { B } ) ;;
	qed prop 1 = step 20 ;;
}

/*A two-element swap is a bijection on a pair.  (Contributed by Mario
       Carneiro, 23-Jan-2015.) */

theorem f1oprswap (A : class, B : class, V : class, W : class) disjointed(A, B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ;;
}

proof of f1oprswap {
	step 1 : wff = f1osng () |- ( ( A ∈ V ∧ A ∈ V ) → { 〈 A , A 〉 } : { A } ⤖ { A } ) ;;
	step 2 : wff = anidms (step 1) |- ( A ∈ V → { 〈 A , A 〉 } : { A } ⤖ { A } ) ;;
	step 3 : wff = ad2antrr (step 2) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A = B ) → { 〈 A , A 〉 } : { A } ⤖ { A } ) ;;
	step 4 : wff = dfsn2 () |- { 〈 A , A 〉 } = { 〈 A , A 〉 , 〈 A , A 〉 } ;;
	step 5 : wff = opeq2 () |- ( A = B → 〈 A , A 〉 = 〈 A , B 〉 ) ;;
	step 6 : wff = opeq1 () |- ( A = B → 〈 A , A 〉 = 〈 B , A 〉 ) ;;
	step 7 : wff = preq12d (step 5, step 6) |- ( A = B → { 〈 A , A 〉 , 〈 A , A 〉 } = { 〈 A , B 〉 , 〈 B , A 〉 } ) ;;
	step 8 : wff = syl5eq (step 4, step 7) |- ( A = B → { 〈 A , A 〉 } = { 〈 A , B 〉 , 〈 B , A 〉 } ) ;;
	step 9 : wff = f1oeq1 () |- ( { 〈 A , A 〉 } = { 〈 A , B 〉 , 〈 B , A 〉 } → ( { 〈 A , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A } ⤖ { A } ) ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( A = B → ( { 〈 A , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A } ⤖ { A } ) ) ;;
	step 11 : wff = dfsn2 () |- { A } = { A , A } ;;
	step 12 : wff = preq2 () |- ( A = B → { A , A } = { A , B } ) ;;
	step 13 : wff = syl5eq (step 11, step 12) |- ( A = B → { A } = { A , B } ) ;;
	step 14 : wff = f1oeq2 () |- ( { A } = { A , B } → ( { 〈 A , B 〉 , 〈 B , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A } ) ) ;;
	step 15 : wff = f1oeq3 () |- ( { A } = { A , B } → ( { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ) ;;
	step 16 : wff = bitrd (step 14, step 15) |- ( { A } = { A , B } → ( { 〈 A , B 〉 , 〈 B , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ) ;;
	step 17 : wff = syl (step 13, step 16) |- ( A = B → ( { 〈 A , B 〉 , 〈 B , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ) ;;
	step 18 : wff = bitrd (step 10, step 17) |- ( A = B → ( { 〈 A , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ) ;;
	step 19 : wff = adantl (step 18) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A = B ) → ( { 〈 A , A 〉 } : { A } ⤖ { A } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ) ;;
	step 20 : wff = mpbid (step 3, step 19) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A = B ) → { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ;;
	step 21 : wff = simpll () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → A ∈ V ) ;;
	step 22 : wff = simplr () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → B ∈ W ) ;;
	step 23 : wff = simplr () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → B ∈ W ) ;;
	step 24 : wff = simpll () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → A ∈ V ) ;;
	step 25 : wff = simpr () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → A ≠ B ) ;;
	step 26 : wff = fnprg () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( B ∈ W ∧ A ∈ V ) ∧ A ≠ B ) → { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ;;
	step 27 : wff = syl221anc (step 21, step 22, step 23, step 24, step 25, step 26) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ;;
	step 28 : wff = simpll () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → A ∈ V ) ;;
	step 29 : wff = simplr () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → B ∈ W ) ;;
	step 30 : wff = simplr () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → B ∈ W ) ;;
	step 31 : wff = simpll () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → A ∈ V ) ;;
	step 32 : wff = simpr () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → A ≠ B ) ;;
	step 33 : wff = fnprg () |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ ( B ∈ W ∧ A ∈ V ) ∧ A ≠ B ) → { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ;;
	step 34 : wff = syl221anc (step 28, step 29, step 30, step 31, step 32, step 33) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ;;
	step 35 : wff = cnvsng () |- ( ( A ∈ V ∧ B ∈ W ) → ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ) ;;
	step 36 : wff = cnvsng () |- ( ( B ∈ W ∧ A ∈ V ) → ⁻¹ { 〈 B , A 〉 } = { 〈 A , B 〉 } ) ;;
	step 37 : wff = ancoms (step 36) |- ( ( A ∈ V ∧ B ∈ W ) → ⁻¹ { 〈 B , A 〉 } = { 〈 A , B 〉 } ) ;;
	step 38 : wff = uneq12d (step 35, step 37) |- ( ( A ∈ V ∧ B ∈ W ) → ( ⁻¹ { 〈 A , B 〉 } ∪ ⁻¹ { 〈 B , A 〉 } ) = ( { 〈 B , A 〉 } ∪ { 〈 A , B 〉 } ) ) ;;
	step 39 : wff = uncom () |- ( { 〈 B , A 〉 } ∪ { 〈 A , B 〉 } ) = ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) ;;
	step 40 : wff = syl6eq (step 38, step 39) |- ( ( A ∈ V ∧ B ∈ W ) → ( ⁻¹ { 〈 A , B 〉 } ∪ ⁻¹ { 〈 B , A 〉 } ) = ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) ) ;;
	step 41 : wff = adantr (step 40) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → ( ⁻¹ { 〈 A , B 〉 } ∪ ⁻¹ { 〈 B , A 〉 } ) = ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) ) ;;
	step 42 : wff = df-pr () |- { 〈 A , B 〉 , 〈 B , A 〉 } = ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) ;;
	step 43 : wff = cnveqi (step 42) |- ⁻¹ { 〈 A , B 〉 , 〈 B , A 〉 } = ⁻¹ ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) ;;
	step 44 : wff = cnvun () |- ⁻¹ ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) = ( ⁻¹ { 〈 A , B 〉 } ∪ ⁻¹ { 〈 B , A 〉 } ) ;;
	step 45 : wff = eqtri (step 43, step 44) |- ⁻¹ { 〈 A , B 〉 , 〈 B , A 〉 } = ( ⁻¹ { 〈 A , B 〉 } ∪ ⁻¹ { 〈 B , A 〉 } ) ;;
	step 46 : wff = df-pr () |- { 〈 A , B 〉 , 〈 B , A 〉 } = ( { 〈 A , B 〉 } ∪ { 〈 B , A 〉 } ) ;;
	step 47 : wff = 3eqtr4g (step 41, step 45, step 46) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → ⁻¹ { 〈 A , B 〉 , 〈 B , A 〉 } = { 〈 A , B 〉 , 〈 B , A 〉 } ) ;;
	step 48 : wff = fneq1d (step 47) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → ( ⁻¹ { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ↔ { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ) ;;
	step 49 : wff = mpbird (step 34, step 48) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → ⁻¹ { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ;;
	step 50 : wff = dff1o4 () |- ( { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ↔ ( { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ∧ ⁻¹ { 〈 A , B 〉 , 〈 B , A 〉 } Fn { A , B } ) ) ;;
	step 51 : wff = sylanbrc (step 27, step 49, step 50) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ A ≠ B ) → { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ;;
	step 52 : wff = pm2.61dane (step 20, step 51) |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 , 〈 B , A 〉 } : { A , B } ⤖ { A , B } ) ;;
	qed prop 1 = step 52 ;;
}

/*Function value when ` F ` is not a function.  Theorem 6.12(2) of
       [TakeutiZaring] p. 27.  (Contributed by NM, 30-Apr-2004.)  (Proof
       shortened by Mario Carneiro, 31-Aug-2015.) */

theorem tz6.12-2 (x : set, A : class, F : class) disjointed(x F, x A) {
	prop 1 : wff = |- ( ¬ ∃! x A F x → ( F ` A ) = ∅ ) ;;
}

proof of tz6.12-2 {
	step 1 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 2 : wff = iotanul () |- ( ¬ ∃! x A F x → ( iota x A F x ) = ∅ ) ;;
	step 3 : wff = syl5eq (step 1, step 2) |- ( ¬ ∃! x A F x → ( F ` A ) = ∅ ) ;;
	qed prop 1 = step 3 ;;
}

/*The value of a function at a unique point.  (Contributed by Scott
       Fenton, 6-Oct-2017.) */

theorem fveu (x : set, A : class, F : class) disjointed(x F, x A) {
	prop 1 : wff = |- ( ∃! x A F x → ( F ` A ) = ⋃ { x | A F x } ) ;;
}

proof of fveu {
	step 1 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 2 : wff = iotauni () |- ( ∃! x A F x → ( iota x A F x ) = ⋃ { x | A F x } ) ;;
	step 3 : wff = syl5eq (step 1, step 2) |- ( ∃! x A F x → ( F ` A ) = ⋃ { x | A F x } ) ;;
	qed prop 1 = step 3 ;;
}

/*If ` A ` is a proper class, then there is no unique binary relationship
       with ` A ` as the first element.  (Contributed by Scott Fenton,
       7-Oct-2017.) */

theorem brprcneu (x : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( ¬ A ∈ _V → ¬ ∃! x A F x ) ;;
}

proof of brprcneu {
	var y : set;;
	step 1 : wff = dtru () |- ¬ ∀ y y = x ;;
	step 2 : wff = exnal () |- ( ∃ y ¬ x = y ↔ ¬ ∀ y x = y ) ;;
	step 3 : wff = equcom () |- ( x = y ↔ y = x ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ y x = y ↔ ∀ y y = x ) ;;
	step 5 : wff = xchbinx (step 2, step 4) |- ( ∃ y ¬ x = y ↔ ¬ ∀ y y = x ) ;;
	step 6 : wff = mpbir (step 1, step 5) |- ∃ y ¬ x = y ;;
	step 7 : wff = jctr (step 6) |- ( ∅ ∈ F → ( ∅ ∈ F ∧ ∃ y ¬ x = y ) ) ;;
	step 8 : wff = 19.42v () |- ( ∃ y ( ∅ ∈ F ∧ ¬ x = y ) ↔ ( ∅ ∈ F ∧ ∃ y ¬ x = y ) ) ;;
	step 9 : wff = sylibr (step 7, step 8) |- ( ∅ ∈ F → ∃ y ( ∅ ∈ F ∧ ¬ x = y ) ) ;;
	step 10 : wff = opprc1 () |- ( ¬ A ∈ _V → 〈 A , x 〉 = ∅ ) ;;
	step 11 : wff = eleq1d (step 10) |- ( ¬ A ∈ _V → ( 〈 A , x 〉 ∈ F ↔ ∅ ∈ F ) ) ;;
	step 12 : wff = opprc1 () |- ( ¬ A ∈ _V → 〈 A , x 〉 = ∅ ) ;;
	step 13 : wff = eleq1d (step 12) |- ( ¬ A ∈ _V → ( 〈 A , x 〉 ∈ F ↔ ∅ ∈ F ) ) ;;
	step 14 : wff = opprc1 () |- ( ¬ A ∈ _V → 〈 A , y 〉 = ∅ ) ;;
	step 15 : wff = eleq1d (step 14) |- ( ¬ A ∈ _V → ( 〈 A , y 〉 ∈ F ↔ ∅ ∈ F ) ) ;;
	step 16 : wff = anbi12d (step 13, step 15) |- ( ¬ A ∈ _V → ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ↔ ( ∅ ∈ F ∧ ∅ ∈ F ) ) ) ;;
	step 17 : wff = anidm () |- ( ( ∅ ∈ F ∧ ∅ ∈ F ) ↔ ∅ ∈ F ) ;;
	step 18 : wff = syl6bb (step 16, step 17) |- ( ¬ A ∈ _V → ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ↔ ∅ ∈ F ) ) ;;
	step 19 : wff = anbi1d (step 18) |- ( ¬ A ∈ _V → ( ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ∧ ¬ x = y ) ↔ ( ∅ ∈ F ∧ ¬ x = y ) ) ) ;;
	step 20 : wff = exbidv (step 19) |- ( ¬ A ∈ _V → ( ∃ y ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ∧ ¬ x = y ) ↔ ∃ y ( ∅ ∈ F ∧ ¬ x = y ) ) ) ;;
	step 21 : wff = imbi12d (step 11, step 20) |- ( ¬ A ∈ _V → ( ( 〈 A , x 〉 ∈ F → ∃ y ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ∧ ¬ x = y ) ) ↔ ( ∅ ∈ F → ∃ y ( ∅ ∈ F ∧ ¬ x = y ) ) ) ) ;;
	step 22 : wff = mpbiri (step 9, step 21) |- ( ¬ A ∈ _V → ( 〈 A , x 〉 ∈ F → ∃ y ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ∧ ¬ x = y ) ) ) ;;
	step 23 : wff = df-br () |- ( A F x ↔ 〈 A , x 〉 ∈ F ) ;;
	step 24 : wff = df-br () |- ( A F x ↔ 〈 A , x 〉 ∈ F ) ;;
	step 25 : wff = df-br () |- ( A F y ↔ 〈 A , y 〉 ∈ F ) ;;
	step 26 : wff = anbi12i (step 24, step 25) |- ( ( A F x ∧ A F y ) ↔ ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ) ;;
	step 27 : wff = anbi1i (step 26) |- ( ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ↔ ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ∧ ¬ x = y ) ) ;;
	step 28 : wff = exbii (step 27) |- ( ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ↔ ∃ y ( ( 〈 A , x 〉 ∈ F ∧ 〈 A , y 〉 ∈ F ) ∧ ¬ x = y ) ) ;;
	step 29 : wff = 3imtr4g (step 22, step 23, step 28) |- ( ¬ A ∈ _V → ( A F x → ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ) ) ;;
	step 30 : wff = eximdv (step 29) |- ( ¬ A ∈ _V → ( ∃ x A F x → ∃ x ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ) ) ;;
	step 31 : wff = breq2 () |- ( x = y → ( A F x ↔ A F y ) ) ;;
	step 32 : wff = mo4 (step 31) |- ( ∃* x A F x ↔ ∀ x ∀ y ( ( A F x ∧ A F y ) → x = y ) ) ;;
	step 33 : wff = notbii (step 32) |- ( ¬ ∃* x A F x ↔ ¬ ∀ x ∀ y ( ( A F x ∧ A F y ) → x = y ) ) ;;
	step 34 : wff = exanali () |- ( ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ↔ ¬ ∀ y ( ( A F x ∧ A F y ) → x = y ) ) ;;
	step 35 : wff = exbii (step 34) |- ( ∃ x ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ↔ ∃ x ¬ ∀ y ( ( A F x ∧ A F y ) → x = y ) ) ;;
	step 36 : wff = exnal () |- ( ∃ x ¬ ∀ y ( ( A F x ∧ A F y ) → x = y ) ↔ ¬ ∀ x ∀ y ( ( A F x ∧ A F y ) → x = y ) ) ;;
	step 37 : wff = bitri (step 35, step 36) |- ( ∃ x ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ↔ ¬ ∀ x ∀ y ( ( A F x ∧ A F y ) → x = y ) ) ;;
	step 38 : wff = bitr4i (step 33, step 37) |- ( ¬ ∃* x A F x ↔ ∃ x ∃ y ( ( A F x ∧ A F y ) ∧ ¬ x = y ) ) ;;
	step 39 : wff = syl6ibr (step 30, step 38) |- ( ¬ A ∈ _V → ( ∃ x A F x → ¬ ∃* x A F x ) ) ;;
	step 40 : wff = eu5 () |- ( ∃! x A F x ↔ ( ∃ x A F x ∧ ∃* x A F x ) ) ;;
	step 41 : wff = notbii (step 40) |- ( ¬ ∃! x A F x ↔ ¬ ( ∃ x A F x ∧ ∃* x A F x ) ) ;;
	step 42 : wff = imnan () |- ( ( ∃ x A F x → ¬ ∃* x A F x ) ↔ ¬ ( ∃ x A F x ∧ ∃* x A F x ) ) ;;
	step 43 : wff = bitr4i (step 41, step 42) |- ( ¬ ∃! x A F x ↔ ( ∃ x A F x → ¬ ∃* x A F x ) ) ;;
	step 44 : wff = sylibr (step 39, step 43) |- ( ¬ A ∈ _V → ¬ ∃! x A F x ) ;;
	qed prop 1 = step 44 ;;
}

/*A function's value at a proper class is the empty set.  (Contributed by
       NM, 20-May-1998.) */

theorem fvprc (A : class, F : class) disjointed(x A, x F) {
	prop 1 : wff = |- ( ¬ A ∈ _V → ( F ` A ) = ∅ ) ;;
}

proof of fvprc {
	var x : set;;
	step 1 : wff = brprcneu () |- ( ¬ A ∈ _V → ¬ ∃! x A F x ) ;;
	step 2 : wff = tz6.12-2 () |- ( ¬ ∃! x A F x → ( F ` A ) = ∅ ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ¬ A ∈ _V → ( F ` A ) = ∅ ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of function value.  Definition 10.11 of [Quine]
       p. 68.  (Contributed by NM, 30-Apr-2004.)  (Proof shortened by Andrew
       Salmon, 17-Sep-2011.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fv2 (x : set, y : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( F ` A ) = ⋃ { x | ∀ y ( A F y ↔ y = x ) } ;;
}

proof of fv2 {
	step 1 : wff = df-fv () |- ( F ` A ) = ( iota y A F y ) ;;
	step 2 : wff = dfiota2 () |- ( iota y A F y ) = ⋃ { x | ∀ y ( A F y ↔ y = x ) } ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( F ` A ) = ⋃ { x | ∀ y ( A F y ↔ y = x ) } ;;
	qed prop 1 = step 3 ;;
}

/*A definition of function value in terms of iota.  (Contributed by Scott
       Fenton, 19-Feb-2013.) */

theorem dffv3 (x : set, A : class, F : class) disjointed(F x, A x) {
	prop 1 : wff = |- ( F ` A ) = ( iota x x ∈ ( F " { A } ) ) ;;
}

proof of dffv3 {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = elimasng () |- ( ( A ∈ _V ∧ x ∈ _V ) → ( x ∈ ( F " { A } ) ↔ 〈 A , x 〉 ∈ F ) ) ;;
	step 3 : wff = df-br () |- ( A F x ↔ 〈 A , x 〉 ∈ F ) ;;
	step 4 : wff = syl6bbr (step 2, step 3) |- ( ( A ∈ _V ∧ x ∈ _V ) → ( x ∈ ( F " { A } ) ↔ A F x ) ) ;;
	step 5 : wff = mpan2 (step 1, step 4) |- ( A ∈ _V → ( x ∈ ( F " { A } ) ↔ A F x ) ) ;;
	step 6 : wff = iotabidv (step 5) |- ( A ∈ _V → ( iota x x ∈ ( F " { A } ) ) = ( iota x A F x ) ) ;;
	step 7 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 8 : wff = syl6reqr (step 6, step 7) |- ( A ∈ _V → ( F ` A ) = ( iota x x ∈ ( F " { A } ) ) ) ;;
	step 9 : wff = fvprc () |- ( ¬ A ∈ _V → ( F ` A ) = ∅ ) ;;
	step 10 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 11 : wff = biimpi (step 10) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 12 : wff = imaeq2d (step 11) |- ( ¬ A ∈ _V → ( F " { A } ) = ( F " ∅ ) ) ;;
	step 13 : wff = ima0 () |- ( F " ∅ ) = ∅ ;;
	step 14 : wff = syl6eq (step 12, step 13) |- ( ¬ A ∈ _V → ( F " { A } ) = ∅ ) ;;
	step 15 : wff = eleq2d (step 14) |- ( ¬ A ∈ _V → ( x ∈ ( F " { A } ) ↔ x ∈ ∅ ) ) ;;
	step 16 : wff = iotabidv (step 15) |- ( ¬ A ∈ _V → ( iota x x ∈ ( F " { A } ) ) = ( iota x x ∈ ∅ ) ) ;;
	step 17 : wff = noel () |- ¬ x ∈ ∅ ;;
	step 18 : wff = nex (step 17) |- ¬ ∃ x x ∈ ∅ ;;
	step 19 : wff = euex () |- ( ∃! x x ∈ ∅ → ∃ x x ∈ ∅ ) ;;
	step 20 : wff = mto (step 18, step 19) |- ¬ ∃! x x ∈ ∅ ;;
	step 21 : wff = iotanul () |- ( ¬ ∃! x x ∈ ∅ → ( iota x x ∈ ∅ ) = ∅ ) ;;
	step 22 : wff = ax-mp (step 20, step 21) |- ( iota x x ∈ ∅ ) = ∅ ;;
	step 23 : wff = syl6eq (step 16, step 22) |- ( ¬ A ∈ _V → ( iota x x ∈ ( F " { A } ) ) = ∅ ) ;;
	step 24 : wff = eqtr4d (step 9, step 23) |- ( ¬ A ∈ _V → ( F ` A ) = ( iota x x ∈ ( F " { A } ) ) ) ;;
	step 25 : wff = pm2.61i (step 8, step 24) |- ( F ` A ) = ( iota x x ∈ ( F " { A } ) ) ;;
	qed prop 1 = step 25 ;;
}

/*The previous definition of function value, from before the ` iota `
       operator was introduced.  Although based on the idea embodied by
       Definition 10.2 of [Quine] p. 65 (see ~ args ), this definition
       apparently does not appear in the literature.  (Contributed by NM,
       1-Aug-1994.) */

theorem dffv4 (x : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( F ` A ) = ⋃ { x | ( F " { A } ) = { x } } ;;
}

proof of dffv4 {
	var y : set;;
	step 1 : wff = dffv3 () |- ( F ` A ) = ( iota y y ∈ ( F " { A } ) ) ;;
	step 2 : wff = df-iota () |- ( iota y y ∈ ( F " { A } ) ) = ⋃ { x | { y | y ∈ ( F " { A } ) } = { x } } ;;
	step 3 : wff = abid2 () |- { y | y ∈ ( F " { A } ) } = ( F " { A } ) ;;
	step 4 : wff = eqeq1i (step 3) |- ( { y | y ∈ ( F " { A } ) } = { x } ↔ ( F " { A } ) = { x } ) ;;
	step 5 : wff = abbii (step 4) |- { x | { y | y ∈ ( F " { A } ) } = { x } } = { x | ( F " { A } ) = { x } } ;;
	step 6 : wff = unieqi (step 5) |- ⋃ { x | { y | y ∈ ( F " { A } ) } = { x } } = ⋃ { x | ( F " { A } ) = { x } } ;;
	step 7 : wff = 3eqtri (step 1, step 2, step 6) |- ( F ` A ) = ⋃ { x | ( F " { A } ) = { x } } ;;
	qed prop 1 = step 7 ;;
}

/*Membership in a function value.  (Contributed by NM, 30-Apr-2004.) */

theorem elfv (x : set, y : set, A : class, B : class, F : class) disjointed(x A, x y B, x y F) {
	prop 1 : wff = |- ( A ∈ ( F ` B ) ↔ ∃ x ( A ∈ x ∧ ∀ y ( B F y ↔ y = x ) ) ) ;;
}

proof of elfv {
	step 1 : wff = fv2 () |- ( F ` B ) = ⋃ { x | ∀ y ( B F y ↔ y = x ) } ;;
	step 2 : wff = eleq2i (step 1) |- ( A ∈ ( F ` B ) ↔ A ∈ ⋃ { x | ∀ y ( B F y ↔ y = x ) } ) ;;
	step 3 : wff = eluniab () |- ( A ∈ ⋃ { x | ∀ y ( B F y ↔ y = x ) } ↔ ∃ x ( A ∈ x ∧ ∀ y ( B F y ↔ y = x ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( A ∈ ( F ` B ) ↔ ∃ x ( A ∈ x ∧ ∀ y ( B F y ↔ y = x ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality theorem for function value.  (Contributed by NM,
       29-Dec-1996.) */

theorem fveq1 (A : class, F : class, G : class) disjointed(x A, x, x F, x G) {
	prop 1 : wff = |- ( F = G → ( F ` A ) = ( G ` A ) ) ;;
}

proof of fveq1 {
	var x : set;;
	step 1 : wff = breq () |- ( F = G → ( A F x ↔ A G x ) ) ;;
	step 2 : wff = iotabidv (step 1) |- ( F = G → ( iota x A F x ) = ( iota x A G x ) ) ;;
	step 3 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 4 : wff = df-fv () |- ( G ` A ) = ( iota x A G x ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( F = G → ( F ` A ) = ( G ` A ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for function value.  (Contributed by NM,
       29-Dec-1996.) */

theorem fveq2 (A : class, B : class, F : class) disjointed(x A, x B, x F, x) {
	prop 1 : wff = |- ( A = B → ( F ` A ) = ( F ` B ) ) ;;
}

proof of fveq2 {
	var x : set;;
	step 1 : wff = breq1 () |- ( A = B → ( A F x ↔ B F x ) ) ;;
	step 2 : wff = iotabidv (step 1) |- ( A = B → ( iota x A F x ) = ( iota x B F x ) ) ;;
	step 3 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 4 : wff = df-fv () |- ( F ` B ) = ( iota x B F x ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ( F ` A ) = ( F ` B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality inference for function value.  (Contributed by NM,
       2-Sep-2003.) */

theorem fveq1i (A : class, F : class, G : class)  {
	hyp 1 : wff = |- F = G ;;
	-----------------------
	prop 1 : wff = |- ( F ` A ) = ( G ` A ) ;;
}

proof of fveq1i {
	step 1 : wff = fveq1 () |- ( F = G → ( F ` A ) = ( G ` A ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F ` A ) = ( G ` A ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for function value.  (Contributed by NM,
       2-Sep-2003.) */

theorem fveq1d (ph : wff, A : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F ` A ) = ( G ` A ) ) ;;
}

proof of fveq1d {
	step 1 : wff = fveq1 () |- ( F = G → ( F ` A ) = ( G ` A ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F ` A ) = ( G ` A ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for function value.  (Contributed by NM,
       28-Jul-1999.) */

theorem fveq2i (A : class, B : class, F : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( F ` A ) = ( F ` B ) ;;
}

proof of fveq2i {
	step 1 : wff = fveq2 () |- ( A = B → ( F ` A ) = ( F ` B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F ` A ) = ( F ` B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for function value.  (Contributed by NM,
       29-May-1999.) */

theorem fveq2d (ph : wff, A : class, B : class, F : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F ` A ) = ( F ` B ) ) ;;
}

proof of fveq2d {
	step 1 : wff = fveq2 () |- ( A = B → ( F ` A ) = ( F ` B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( F ` A ) = ( F ` B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for function value.  (Contributed by FL,
       27-Jun-2014.) */

theorem fveq12i (A : class, B : class, F : class, G : class)  {
	hyp 1 : wff = |- F = G ;;
	hyp 2 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( F ` A ) = ( G ` B ) ;;
}

proof of fveq12i {
	step 1 : wff = fveq1i (hyp 1) |- ( F ` A ) = ( G ` A ) ;;
	step 2 : wff = fveq2i (hyp 2) |- ( G ` A ) = ( G ` B ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( F ` A ) = ( G ` B ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for function value.  (Contributed by FL,
       22-Dec-2008.) */

theorem fveq12d (ph : wff, A : class, B : class, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F ` A ) = ( G ` B ) ) ;;
}

proof of fveq12d {
	step 1 : wff = fveq1d (hyp 1) |- ( ph → ( F ` A ) = ( G ` A ) ) ;;
	step 2 : wff = fveq2d (hyp 2) |- ( ph → ( G ` A ) = ( G ` B ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → ( F ` A ) = ( G ` B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for function value.  (Contributed by
       NM, 14-Nov-1995.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nffv (x : set, A : class, F : class) disjointed(y F, y A, x y) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x ( F ` A ) ;;
}

proof of nffv {
	var y : set;;
	step 1 : wff = df-fv () |- ( F ` A ) = ( iota y A F y ) ;;
	step 2 : wff = nfcv () |- F/_ x y ;;
	step 3 : wff = nfbr (hyp 2, hyp 1, step 2) |- F/ x A F y ;;
	step 4 : wff = nfiota (step 3) |- F/_ x ( iota y A F y ) ;;
	step 5 : wff = nfcxfr (step 1, step 4) |- F/_ x ( F ` A ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for mapping, special case.
       (Contributed by Mario Carneiro, 25-Dec-2016.) */

theorem nffvmpt1 (x : set, A : class, B : class, C : class) disjointed(x C) {
	prop 1 : wff = |- F/_ x ( ( x ∈ A ↦ B ) ` C ) ;;
}

proof of nffvmpt1 {
	step 1 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ B ) ;;
	step 2 : wff = nfcv () |- F/_ x C ;;
	step 3 : wff = nffv (step 1, step 2) |- F/_ x ( ( x ∈ A ↦ B ) ` C ) ;;
	qed prop 1 = step 3 ;;
}

/*Deduction version of bound-variable hypothesis builder ~ nffv .
       (Contributed by NM, 10-Nov-2005.)  (Revised by Mario Carneiro,
       15-Oct-2016.) */

theorem nffvd (ph : wff, x : set, A : class, F : class) disjointed(z A, z F, ph, x z) {
	hyp 1 : wff = |- ( ph → F/_ x F ) ;;
	hyp 2 : wff = |- ( ph → F/_ x A ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x ( F ` A ) ) ;;
}

proof of nffvd {
	var z : set;;
	step 1 : wff = nfaba1 () |- F/_ x { z | ∀ x z ∈ F } ;;
	step 2 : wff = nfaba1 () |- F/_ x { z | ∀ x z ∈ A } ;;
	step 3 : wff = nffv (step 1, step 2) |- F/_ x ( { z | ∀ x z ∈ F } ` { z | ∀ x z ∈ A } ) ;;
	step 4 : wff = nfnfc1 () |- F/ x F/_ x F ;;
	step 5 : wff = nfnfc1 () |- F/ x F/_ x A ;;
	step 6 : wff = nfan (step 4, step 5) |- F/ x ( F/_ x F ∧ F/_ x A ) ;;
	step 7 : wff = abidnf () |- ( F/_ x F → { z | ∀ x z ∈ F } = F ) ;;
	step 8 : wff = adantr (step 7) |- ( ( F/_ x F ∧ F/_ x A ) → { z | ∀ x z ∈ F } = F ) ;;
	step 9 : wff = abidnf () |- ( F/_ x A → { z | ∀ x z ∈ A } = A ) ;;
	step 10 : wff = adantl (step 9) |- ( ( F/_ x F ∧ F/_ x A ) → { z | ∀ x z ∈ A } = A ) ;;
	step 11 : wff = fveq12d (step 8, step 10) |- ( ( F/_ x F ∧ F/_ x A ) → ( { z | ∀ x z ∈ F } ` { z | ∀ x z ∈ A } ) = ( F ` A ) ) ;;
	step 12 : wff = nfceqdf (step 6, step 11) |- ( ( F/_ x F ∧ F/_ x A ) → ( F/_ x ( { z | ∀ x z ∈ F } ` { z | ∀ x z ∈ A } ) ↔ F/_ x ( F ` A ) ) ) ;;
	step 13 : wff = syl2anc (hyp 1, hyp 2, step 12) |- ( ph → ( F/_ x ( { z | ∀ x z ∈ F } ` { z | ∀ x z ∈ A } ) ↔ F/_ x ( F ` A ) ) ) ;;
	step 14 : wff = mpbii (step 3, step 13) |- ( ph → F/_ x ( F ` A ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Move class substitution in and out of a function value.  (Contributed by
       NM, 11-Nov-2005.) */

theorem csbfv12g (x : set, A : class, B : class, C : class, F : class) disjointed(y A, y B, y C, y F, x y) {
	prop 1 : wff = |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( [_ A / x ]_ F ` [_ A / x ]_ B ) ) ;;
}

proof of csbfv12g {
	var y : set;;
	step 1 : wff = csbiotag () |- ( A ∈ C → [_ A / x ]_ ( iota y B F y ) = ( iota y [. A / x ]. B F y ) ) ;;
	step 2 : wff = sbcbrg () |- ( A ∈ C → ( [. A / x ]. B F y ↔ [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ y ) ) ;;
	step 3 : wff = csbconstg () |- ( A ∈ C → [_ A / x ]_ y = y ) ;;
	step 4 : wff = breq2d (step 3) |- ( A ∈ C → ( [_ A / x ]_ B [_ A / x ]_ F [_ A / x ]_ y ↔ [_ A / x ]_ B [_ A / x ]_ F y ) ) ;;
	step 5 : wff = bitrd (step 2, step 4) |- ( A ∈ C → ( [. A / x ]. B F y ↔ [_ A / x ]_ B [_ A / x ]_ F y ) ) ;;
	step 6 : wff = iotabidv (step 5) |- ( A ∈ C → ( iota y [. A / x ]. B F y ) = ( iota y [_ A / x ]_ B [_ A / x ]_ F y ) ) ;;
	step 7 : wff = eqtrd (step 1, step 6) |- ( A ∈ C → [_ A / x ]_ ( iota y B F y ) = ( iota y [_ A / x ]_ B [_ A / x ]_ F y ) ) ;;
	step 8 : wff = df-fv () |- ( F ` B ) = ( iota y B F y ) ;;
	step 9 : wff = csbeq2i (step 8) |- [_ A / x ]_ ( F ` B ) = [_ A / x ]_ ( iota y B F y ) ;;
	step 10 : wff = df-fv () |- ( [_ A / x ]_ F ` [_ A / x ]_ B ) = ( iota y [_ A / x ]_ B [_ A / x ]_ F y ) ;;
	step 11 : wff = 3eqtr4g (step 7, step 9, step 10) |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( [_ A / x ]_ F ` [_ A / x ]_ B ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Move class substitution in and out of a function value.(This is
       ~ csbfv12g with a shortened proof, shortened by Alan Sare,
       10-Nov-2012.)  The proof is derived from the virtual deduction proof
       ~ csbfv12gALTVD .  Although the proof is shorter, the total number of
       steps of all theorems used in the proof is probably longer.
       (Contributed by NM, 10-Nov-2012.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem csbfv12gALT (x : set, A : class, B : class, C : class, F : class) disjointed(A y, F y, B y, C y, x y) {
	prop 1 : wff = |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( [_ A / x ]_ F ` [_ A / x ]_ B ) ) ;;
}

proof of csbfv12gALT {
	var y : set;;
	step 1 : wff = csbunig () |- ( A ∈ C → [_ A / x ]_ ⋃ { y | ( F " { B } ) = { y } } = ⋃ [_ A / x ]_ { y | ( F " { B } ) = { y } } ) ;;
	step 2 : wff = csbabg () |- ( A ∈ C → [_ A / x ]_ { y | ( F " { B } ) = { y } } = { y | [. A / x ]. ( F " { B } ) = { y } } ) ;;
	step 3 : wff = sbceqg () |- ( A ∈ C → ( [. A / x ]. ( F " { B } ) = { y } ↔ [_ A / x ]_ ( F " { B } ) = [_ A / x ]_ { y } ) ) ;;
	step 4 : wff = csbima12g () |- ( A ∈ C → [_ A / x ]_ ( F " { B } ) = ( [_ A / x ]_ F " [_ A / x ]_ { B } ) ) ;;
	step 5 : wff = csbsng () |- ( A ∈ C → [_ A / x ]_ { B } = { [_ A / x ]_ B } ) ;;
	step 6 : wff = imaeq2d (step 5) |- ( A ∈ C → ( [_ A / x ]_ F " [_ A / x ]_ { B } ) = ( [_ A / x ]_ F " { [_ A / x ]_ B } ) ) ;;
	step 7 : wff = eqtrd (step 4, step 6) |- ( A ∈ C → [_ A / x ]_ ( F " { B } ) = ( [_ A / x ]_ F " { [_ A / x ]_ B } ) ) ;;
	step 8 : wff = csbconstg () |- ( A ∈ C → [_ A / x ]_ { y } = { y } ) ;;
	step 9 : wff = eqeq12d (step 7, step 8) |- ( A ∈ C → ( [_ A / x ]_ ( F " { B } ) = [_ A / x ]_ { y } ↔ ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } ) ) ;;
	step 10 : wff = bitrd (step 3, step 9) |- ( A ∈ C → ( [. A / x ]. ( F " { B } ) = { y } ↔ ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } ) ) ;;
	step 11 : wff = abbidv (step 10) |- ( A ∈ C → { y | [. A / x ]. ( F " { B } ) = { y } } = { y | ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } } ) ;;
	step 12 : wff = eqtrd (step 2, step 11) |- ( A ∈ C → [_ A / x ]_ { y | ( F " { B } ) = { y } } = { y | ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } } ) ;;
	step 13 : wff = unieqd (step 12) |- ( A ∈ C → ⋃ [_ A / x ]_ { y | ( F " { B } ) = { y } } = ⋃ { y | ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } } ) ;;
	step 14 : wff = eqtrd (step 1, step 13) |- ( A ∈ C → [_ A / x ]_ ⋃ { y | ( F " { B } ) = { y } } = ⋃ { y | ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } } ) ;;
	step 15 : wff = dffv4 () |- ( F ` B ) = ⋃ { y | ( F " { B } ) = { y } } ;;
	step 16 : wff = csbeq2i (step 15) |- [_ A / x ]_ ( F ` B ) = [_ A / x ]_ ⋃ { y | ( F " { B } ) = { y } } ;;
	step 17 : wff = dffv4 () |- ( [_ A / x ]_ F ` [_ A / x ]_ B ) = ⋃ { y | ( [_ A / x ]_ F " { [_ A / x ]_ B } ) = { y } } ;;
	step 18 : wff = 3eqtr4g (step 14, step 16, step 17) |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( [_ A / x ]_ F ` [_ A / x ]_ B ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Move class substitution in and out of a function value.  (Contributed by
       NM, 10-Nov-2005.) */

theorem csbfv2g (x : set, A : class, B : class, C : class, F : class) disjointed(A, C, x F) {
	prop 1 : wff = |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( F ` [_ A / x ]_ B ) ) ;;
}

proof of csbfv2g {
	step 1 : wff = csbfv12g () |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( [_ A / x ]_ F ` [_ A / x ]_ B ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ C → [_ A / x ]_ F = F ) ;;
	step 3 : wff = fveq1d (step 2) |- ( A ∈ C → ( [_ A / x ]_ F ` [_ A / x ]_ B ) = ( F ` [_ A / x ]_ B ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( A ∈ C → [_ A / x ]_ ( F ` B ) = ( F ` [_ A / x ]_ B ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Substitution for a function value.  (Contributed by NM, 1-Jan-2006.) */

theorem csbfvg (x : set, A : class, C : class, F : class) disjointed(A, C, x F) {
	prop 1 : wff = |- ( A ∈ C → [_ A / x ]_ ( F ` x ) = ( F ` A ) ) ;;
}

proof of csbfvg {
	step 1 : wff = csbfv2g () |- ( A ∈ C → [_ A / x ]_ ( F ` x ) = ( F ` [_ A / x ]_ x ) ) ;;
	step 2 : wff = csbvarg () |- ( A ∈ C → [_ A / x ]_ x = A ) ;;
	step 3 : wff = fveq2d (step 2) |- ( A ∈ C → ( F ` [_ A / x ]_ x ) = ( F ` A ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( A ∈ C → [_ A / x ]_ ( F ` x ) = ( F ` A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*The value of a class exists.  Corollary 6.13 of [TakeutiZaring] p. 27.
       (Contributed by NM, 30-Dec-1996.) */

theorem fvex (A : class, F : class) disjointed(x A, x F) {
	prop 1 : wff = |- ( F ` A ) ∈ _V ;;
}

proof of fvex {
	var x : set;;
	step 1 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 2 : wff = iotaex () |- ( iota x A F x ) ∈ _V ;;
	step 3 : wff = eqeltri (step 1, step 2) |- ( F ` A ) ∈ _V ;;
	qed prop 1 = step 3 ;;
}

/*Move a conditional outside of a function.  (Contributed by Jeff Madsen,
     2-Sep-2009.) */

theorem fvif (ph : wff, A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F ` if ( ph , A , B ) ) = if ( ph , ( F ` A ) , ( F ` B ) ) ;;
}

proof of fvif {
	step 1 : wff = fveq2 () |- ( if ( ph , A , B ) = A → ( F ` if ( ph , A , B ) ) = ( F ` A ) ) ;;
	step 2 : wff = fveq2 () |- ( if ( ph , A , B ) = B → ( F ` if ( ph , A , B ) ) = ( F ` B ) ) ;;
	step 3 : wff = ifsb (step 1, step 2) |- ( F ` if ( ph , A , B ) ) = if ( ph , ( F ` A ) , ( F ` B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of the value of a function.  Definition 6.11 of
       [TakeutiZaring] p. 26.  (Contributed by NM, 30-Apr-2004.)  (Revised by
       Mario Carneiro, 31-Aug-2015.) */

theorem fv3 (x : set, y : set, A : class, F : class) disjointed(x y z F, x y z A) {
	prop 1 : wff = |- ( F ` A ) = { x | ( ∃ y ( x ∈ y ∧ A F y ) ∧ ∃! y A F y ) } ;;
}

proof of fv3 {
	var z : set;;
	step 1 : wff = elfv () |- ( x ∈ ( F ` A ) ↔ ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ;;
	step 2 : wff = bi2 () |- ( ( A F y ↔ y = z ) → ( y = z → A F y ) ) ;;
	step 3 : wff = alimi (step 2) |- ( ∀ y ( A F y ↔ y = z ) → ∀ y ( y = z → A F y ) ) ;;
	step 4 : wff = vex () |- z ∈ _V ;;
	step 5 : wff = breq2 () |- ( y = z → ( A F y ↔ A F z ) ) ;;
	step 6 : wff = ceqsalv (step 4, step 5) |- ( ∀ y ( y = z → A F y ) ↔ A F z ) ;;
	step 7 : wff = sylib (step 3, step 6) |- ( ∀ y ( A F y ↔ y = z ) → A F z ) ;;
	step 8 : wff = anim2i (step 7) |- ( ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ( x ∈ z ∧ A F z ) ) ;;
	step 9 : wff = eximi (step 8) |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ∃ z ( x ∈ z ∧ A F z ) ) ;;
	step 10 : wff = elequ2 () |- ( z = y → ( x ∈ z ↔ x ∈ y ) ) ;;
	step 11 : wff = breq2 () |- ( z = y → ( A F z ↔ A F y ) ) ;;
	step 12 : wff = anbi12d (step 10, step 11) |- ( z = y → ( ( x ∈ z ∧ A F z ) ↔ ( x ∈ y ∧ A F y ) ) ) ;;
	step 13 : wff = cbvexv (step 12) |- ( ∃ z ( x ∈ z ∧ A F z ) ↔ ∃ y ( x ∈ y ∧ A F y ) ) ;;
	step 14 : wff = sylib (step 9, step 13) |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ∃ y ( x ∈ y ∧ A F y ) ) ;;
	step 15 : wff = 19.40 () |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ( ∃ z x ∈ z ∧ ∃ z ∀ y ( A F y ↔ y = z ) ) ) ;;
	step 16 : wff = simprd (step 15) |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ∃ z ∀ y ( A F y ↔ y = z ) ) ;;
	step 17 : wff = df-eu () |- ( ∃! y A F y ↔ ∃ z ∀ y ( A F y ↔ y = z ) ) ;;
	step 18 : wff = sylibr (step 16, step 17) |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ∃! y A F y ) ;;
	step 19 : wff = jca (step 14, step 18) |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) → ( ∃ y ( x ∈ y ∧ A F y ) ∧ ∃! y A F y ) ) ;;
	step 20 : wff = nfeu1 () |- F/ y ∃! y A F y ;;
	step 21 : wff = nfv () |- F/ y x ∈ z ;;
	step 22 : wff = nfa1 () |- F/ y ∀ y ( A F y ↔ y = z ) ;;
	step 23 : wff = nfan (step 21, step 22) |- F/ y ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ;;
	step 24 : wff = nfex (step 23) |- F/ y ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ;;
	step 25 : wff = nfim (step 20, step 24) |- F/ y ( ∃! y A F y → ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ;;
	step 26 : wff = df-eu () |- ( ∃! y A F y ↔ ∃ z ∀ y ( A F y ↔ y = z ) ) ;;
	step 27 : wff = bi1 () |- ( ( A F y ↔ y = z ) → ( A F y → y = z ) ) ;;
	step 28 : wff = ax-14 () |- ( y = z → ( x ∈ y → x ∈ z ) ) ;;
	step 29 : wff = syl6 (step 27, step 28) |- ( ( A F y ↔ y = z ) → ( A F y → ( x ∈ y → x ∈ z ) ) ) ;;
	step 30 : wff = com23 (step 29) |- ( ( A F y ↔ y = z ) → ( x ∈ y → ( A F y → x ∈ z ) ) ) ;;
	step 31 : wff = imp3a (step 30) |- ( ( A F y ↔ y = z ) → ( ( x ∈ y ∧ A F y ) → x ∈ z ) ) ;;
	step 32 : wff = sps (step 31) |- ( ∀ y ( A F y ↔ y = z ) → ( ( x ∈ y ∧ A F y ) → x ∈ z ) ) ;;
	step 33 : wff = anc2ri (step 32) |- ( ∀ y ( A F y ↔ y = z ) → ( ( x ∈ y ∧ A F y ) → ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ) ;;
	step 34 : wff = com12 (step 33) |- ( ( x ∈ y ∧ A F y ) → ( ∀ y ( A F y ↔ y = z ) → ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ) ;;
	step 35 : wff = eximdv (step 34) |- ( ( x ∈ y ∧ A F y ) → ( ∃ z ∀ y ( A F y ↔ y = z ) → ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ) ;;
	step 36 : wff = syl5bi (step 26, step 35) |- ( ( x ∈ y ∧ A F y ) → ( ∃! y A F y → ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ) ;;
	step 37 : wff = exlimi (step 25, step 36) |- ( ∃ y ( x ∈ y ∧ A F y ) → ( ∃! y A F y → ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ) ;;
	step 38 : wff = imp (step 37) |- ( ( ∃ y ( x ∈ y ∧ A F y ) ∧ ∃! y A F y ) → ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ) ;;
	step 39 : wff = impbii (step 19, step 38) |- ( ∃ z ( x ∈ z ∧ ∀ y ( A F y ↔ y = z ) ) ↔ ( ∃ y ( x ∈ y ∧ A F y ) ∧ ∃! y A F y ) ) ;;
	step 40 : wff = bitri (step 1, step 39) |- ( x ∈ ( F ` A ) ↔ ( ∃ y ( x ∈ y ∧ A F y ) ∧ ∃! y A F y ) ) ;;
	step 41 : wff = abbi2i (step 40) |- ( F ` A ) = { x | ( ∃ y ( x ∈ y ∧ A F y ) ∧ ∃! y A F y ) } ;;
	qed prop 1 = step 41 ;;
}

/*The value of a restricted function.  (Contributed by NM, 2-Aug-1994.) */

theorem fvres (A : class, B : class, F : class) disjointed(x F, x A, x B) {
	prop 1 : wff = |- ( A ∈ B → ( ( F ↾ B ) ` A ) = ( F ` A ) ) ;;
}

proof of fvres {
	var x : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = brres (step 1) |- ( A ( F ↾ B ) x ↔ ( A F x ∧ A ∈ B ) ) ;;
	step 3 : wff = rbaib (step 2) |- ( A ∈ B → ( A ( F ↾ B ) x ↔ A F x ) ) ;;
	step 4 : wff = iotabidv (step 3) |- ( A ∈ B → ( iota x A ( F ↾ B ) x ) = ( iota x A F x ) ) ;;
	step 5 : wff = df-fv () |- ( ( F ↾ B ) ` A ) = ( iota x A ( F ↾ B ) x ) ;;
	step 6 : wff = df-fv () |- ( F ` A ) = ( iota x A F x ) ;;
	step 7 : wff = 3eqtr4g (step 4, step 5, step 6) |- ( A ∈ B → ( ( F ↾ B ) ` A ) = ( F ` A ) ) ;;
	qed prop 1 = step 7 ;;
}

/*The value of a member of the domain of a subclass of a function.
     (Contributed by NM, 15-Aug-1994.) */

theorem funssfv (A : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ G ⊆ F ∧ A ∈ dom G ) → ( F ` A ) = ( G ` A ) ) ;;
}

proof of funssfv {
	step 1 : wff = fvres () |- ( A ∈ dom G → ( ( F ↾ dom G ) ` A ) = ( F ` A ) ) ;;
	step 2 : wff = eqcomd (step 1) |- ( A ∈ dom G → ( F ` A ) = ( ( F ↾ dom G ) ` A ) ) ;;
	step 3 : wff = funssres () |- ( ( Fun F ∧ G ⊆ F ) → ( F ↾ dom G ) = G ) ;;
	step 4 : wff = fveq1d (step 3) |- ( ( Fun F ∧ G ⊆ F ) → ( ( F ↾ dom G ) ` A ) = ( G ` A ) ) ;;
	step 5 : wff = sylan9eqr (step 2, step 4) |- ( ( ( Fun F ∧ G ⊆ F ) ∧ A ∈ dom G ) → ( F ` A ) = ( G ` A ) ) ;;
	step 6 : wff = 3impa (step 5) |- ( ( Fun F ∧ G ⊆ F ∧ A ∈ dom G ) → ( F ` A ) = ( G ` A ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Function value.  Theorem 6.12(1) of [TakeutiZaring] p. 27.  (Contributed
       by NM, 30-Apr-2004.) */

theorem tz6.12-1 (y : set, A : class, F : class) disjointed(y F, y A) {
	prop 1 : wff = |- ( ( A F y ∧ ∃! y A F y ) → ( F ` A ) = y ) ;;
}

proof of tz6.12-1 {
	step 1 : wff = df-fv () |- ( F ` A ) = ( iota y A F y ) ;;
	step 2 : wff = iota1 () |- ( ∃! y A F y → ( A F y ↔ ( iota y A F y ) = y ) ) ;;
	step 3 : wff = biimpd (step 2) |- ( ∃! y A F y → ( A F y → ( iota y A F y ) = y ) ) ;;
	step 4 : wff = impcom (step 3) |- ( ( A F y ∧ ∃! y A F y ) → ( iota y A F y ) = y ) ;;
	step 5 : wff = syl5eq (step 1, step 4) |- ( ( A F y ∧ ∃! y A F y ) → ( F ` A ) = y ) ;;
	qed prop 1 = step 5 ;;
}

/*Function value.  Theorem 6.12(1) of [TakeutiZaring] p. 27.  (Contributed
       by NM, 10-Jul-1994.) */

theorem tz6.12 (y : set, A : class, F : class) disjointed(y F, y A) {
	prop 1 : wff = |- ( ( 〈 A , y 〉 ∈ F ∧ ∃! y 〈 A , y 〉 ∈ F ) → ( F ` A ) = y ) ;;
}

proof of tz6.12 {
	step 1 : wff = df-br () |- ( A F y ↔ 〈 A , y 〉 ∈ F ) ;;
	step 2 : wff = df-br () |- ( A F y ↔ 〈 A , y 〉 ∈ F ) ;;
	step 3 : wff = eubii (step 2) |- ( ∃! y A F y ↔ ∃! y 〈 A , y 〉 ∈ F ) ;;
	step 4 : wff = tz6.12-1 () |- ( ( A F y ∧ ∃! y A F y ) → ( F ` A ) = y ) ;;
	step 5 : wff = syl2anbr (step 1, step 3, step 4) |- ( ( 〈 A , y 〉 ∈ F ∧ ∃! y 〈 A , y 〉 ∈ F ) → ( F ` A ) = y ) ;;
	qed prop 1 = step 5 ;;
}

/*Function value, using bound-variable hypotheses instead of distinct
       variable conditions.  (Contributed by NM, 30-Aug-1999.) */

theorem tz6.12f (y : set, A : class, F : class) disjointed(A y z, z F) {
	hyp 1 : wff = |- F/_ y F ;;
	-----------------------
	prop 1 : wff = |- ( ( 〈 A , y 〉 ∈ F ∧ ∃! y 〈 A , y 〉 ∈ F ) → ( F ` A ) = y ) ;;
}

proof of tz6.12f {
	var z : set;;
	step 1 : wff = opeq2 () |- ( z = y → 〈 A , z 〉 = 〈 A , y 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( z = y → ( 〈 A , z 〉 ∈ F ↔ 〈 A , y 〉 ∈ F ) ) ;;
	step 3 : wff = nfel2 (hyp 1) |- F/ y 〈 A , z 〉 ∈ F ;;
	step 4 : wff = nfv () |- F/ z 〈 A , y 〉 ∈ F ;;
	step 5 : wff = opeq2 () |- ( z = y → 〈 A , z 〉 = 〈 A , y 〉 ) ;;
	step 6 : wff = eleq1d (step 5) |- ( z = y → ( 〈 A , z 〉 ∈ F ↔ 〈 A , y 〉 ∈ F ) ) ;;
	step 7 : wff = cbveu (step 3, step 4, step 6) |- ( ∃! z 〈 A , z 〉 ∈ F ↔ ∃! y 〈 A , y 〉 ∈ F ) ;;
	step 8 : wff = a1i (step 7) |- ( z = y → ( ∃! z 〈 A , z 〉 ∈ F ↔ ∃! y 〈 A , y 〉 ∈ F ) ) ;;
	step 9 : wff = anbi12d (step 2, step 8) |- ( z = y → ( ( 〈 A , z 〉 ∈ F ∧ ∃! z 〈 A , z 〉 ∈ F ) ↔ ( 〈 A , y 〉 ∈ F ∧ ∃! y 〈 A , y 〉 ∈ F ) ) ) ;;
	step 10 : wff = eqeq2 () |- ( z = y → ( ( F ` A ) = z ↔ ( F ` A ) = y ) ) ;;
	step 11 : wff = imbi12d (step 9, step 10) |- ( z = y → ( ( ( 〈 A , z 〉 ∈ F ∧ ∃! z 〈 A , z 〉 ∈ F ) → ( F ` A ) = z ) ↔ ( ( 〈 A , y 〉 ∈ F ∧ ∃! y 〈 A , y 〉 ∈ F ) → ( F ` A ) = y ) ) ) ;;
	step 12 : wff = tz6.12 () |- ( ( 〈 A , z 〉 ∈ F ∧ ∃! z 〈 A , z 〉 ∈ F ) → ( F ` A ) = z ) ;;
	step 13 : wff = chvarv (step 11, step 12) |- ( ( 〈 A , y 〉 ∈ F ∧ ∃! y 〈 A , y 〉 ∈ F ) → ( F ` A ) = y ) ;;
	qed prop 1 = step 13 ;;
}

/*Corollary of Theorem 6.12(1) of [TakeutiZaring] p. 27.  (Contributed by
       NM, 30-Apr-2004.) */

theorem tz6.12c (y : set, A : class, F : class) disjointed(y F, y A) {
	prop 1 : wff = |- ( ∃! y A F y → ( ( F ` A ) = y ↔ A F y ) ) ;;
}

proof of tz6.12c {
	step 1 : wff = euex () |- ( ∃! y A F y → ∃ y A F y ) ;;
	step 2 : wff = nfeu1 () |- F/ y ∃! y A F y ;;
	step 3 : wff = nfv () |- F/ y A F ( F ` A ) ;;
	step 4 : wff = nfim (step 2, step 3) |- F/ y ( ∃! y A F y → A F ( F ` A ) ) ;;
	step 5 : wff = tz6.12-1 () |- ( ( A F y ∧ ∃! y A F y ) → ( F ` A ) = y ) ;;
	step 6 : wff = expcom (step 5) |- ( ∃! y A F y → ( A F y → ( F ` A ) = y ) ) ;;
	step 7 : wff = breq2 () |- ( ( F ` A ) = y → ( A F ( F ` A ) ↔ A F y ) ) ;;
	step 8 : wff = biimprd (step 7) |- ( ( F ` A ) = y → ( A F y → A F ( F ` A ) ) ) ;;
	step 9 : wff = syli (step 6, step 8) |- ( ∃! y A F y → ( A F y → A F ( F ` A ) ) ) ;;
	step 10 : wff = com12 (step 9) |- ( A F y → ( ∃! y A F y → A F ( F ` A ) ) ) ;;
	step 11 : wff = exlimi (step 4, step 10) |- ( ∃ y A F y → ( ∃! y A F y → A F ( F ` A ) ) ) ;;
	step 12 : wff = mpcom (step 1, step 11) |- ( ∃! y A F y → A F ( F ` A ) ) ;;
	step 13 : wff = breq2 () |- ( ( F ` A ) = y → ( A F ( F ` A ) ↔ A F y ) ) ;;
	step 14 : wff = syl5ibcom (step 12, step 13) |- ( ∃! y A F y → ( ( F ` A ) = y → A F y ) ) ;;
	step 15 : wff = tz6.12-1 () |- ( ( A F y ∧ ∃! y A F y ) → ( F ` A ) = y ) ;;
	step 16 : wff = expcom (step 15) |- ( ∃! y A F y → ( A F y → ( F ` A ) = y ) ) ;;
	step 17 : wff = impbid (step 14, step 16) |- ( ∃! y A F y → ( ( F ` A ) = y ↔ A F y ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Corollary of Theorem 6.12(2) of [TakeutiZaring] p. 27.  (Contributed by
       Mario Carneiro, 17-Nov-2014.) */

theorem tz6.12i (A : class, B : class, F : class) disjointed(y F, y A, y B) {
	prop 1 : wff = |- ( B ≠ ∅ → ( ( F ` A ) = B → A F B ) ) ;;
}

proof of tz6.12i {
	var y : set;;
	step 1 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 2 : wff = neeq1 () |- ( ( F ` A ) = y → ( ( F ` A ) ≠ ∅ ↔ y ≠ ∅ ) ) ;;
	step 3 : wff = tz6.12-2 () |- ( ¬ ∃! y A F y → ( F ` A ) = ∅ ) ;;
	step 4 : wff = necon1ai (step 3) |- ( ( F ` A ) ≠ ∅ → ∃! y A F y ) ;;
	step 5 : wff = tz6.12c () |- ( ∃! y A F y → ( ( F ` A ) = y ↔ A F y ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ( F ` A ) ≠ ∅ → ( ( F ` A ) = y ↔ A F y ) ) ;;
	step 7 : wff = biimpcd (step 6) |- ( ( F ` A ) = y → ( ( F ` A ) ≠ ∅ → A F y ) ) ;;
	step 8 : wff = sylbird (step 2, step 7) |- ( ( F ` A ) = y → ( y ≠ ∅ → A F y ) ) ;;
	step 9 : wff = eqcoms (step 8) |- ( y = ( F ` A ) → ( y ≠ ∅ → A F y ) ) ;;
	step 10 : wff = neeq1 () |- ( y = ( F ` A ) → ( y ≠ ∅ ↔ ( F ` A ) ≠ ∅ ) ) ;;
	step 11 : wff = breq2 () |- ( y = ( F ` A ) → ( A F y ↔ A F ( F ` A ) ) ) ;;
	step 12 : wff = 3imtr3d (step 9, step 10, step 11) |- ( y = ( F ` A ) → ( ( F ` A ) ≠ ∅ → A F ( F ` A ) ) ) ;;
	step 13 : wff = vtocle (step 1, step 12) |- ( ( F ` A ) ≠ ∅ → A F ( F ` A ) ) ;;
	step 14 : wff = a1i (step 13) |- ( ( F ` A ) = B → ( ( F ` A ) ≠ ∅ → A F ( F ` A ) ) ) ;;
	step 15 : wff = neeq1 () |- ( ( F ` A ) = B → ( ( F ` A ) ≠ ∅ ↔ B ≠ ∅ ) ) ;;
	step 16 : wff = breq2 () |- ( ( F ` A ) = B → ( A F ( F ` A ) ↔ A F B ) ) ;;
	step 17 : wff = 3imtr3d (step 14, step 15, step 16) |- ( ( F ` A ) = B → ( B ≠ ∅ → A F B ) ) ;;
	step 18 : wff = com12 (step 17) |- ( B ≠ ∅ → ( ( F ` A ) = B → A F B ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Two possibilities for the behavior of a function value.  (Contributed by
     Stefan O'Rear, 2-Nov-2014.)  (Proof shortened by Mario Carneiro,
     31-Aug-2015.) */

theorem fvbr0 (F : class, X : class)  {
	prop 1 : wff = |- ( X F ( F ` X ) ∨ ( F ` X ) = ∅ ) ;;
}

proof of fvbr0 {
	step 1 : wff = eqid () |- ( F ` X ) = ( F ` X ) ;;
	step 2 : wff = tz6.12i () |- ( ( F ` X ) ≠ ∅ → ( ( F ` X ) = ( F ` X ) → X F ( F ` X ) ) ) ;;
	step 3 : wff = mpi (step 1, step 2) |- ( ( F ` X ) ≠ ∅ → X F ( F ` X ) ) ;;
	step 4 : wff = necon1bi (step 3) |- ( ¬ X F ( F ` X ) → ( F ` X ) = ∅ ) ;;
	step 5 : wff = orri (step 4) |- ( X F ( F ` X ) ∨ ( F ` X ) = ∅ ) ;;
	qed prop 1 = step 5 ;;
}

/*A function value is a member of the range plus null.  (Contributed by
     Scott Fenton, 8-Jun-2011.)  (Revised by Stefan O'Rear, 3-Jan-2015.) */

theorem fvrn0 (F : class, X : class)  {
	prop 1 : wff = |- ( F ` X ) ∈ ( ran F ∪ { ∅ } ) ;;
}

proof of fvrn0 {
	step 1 : wff = id () |- ( ( F ` X ) = ∅ → ( F ` X ) = ∅ ) ;;
	step 2 : wff = ssun2 () |- { ∅ } ⊆ ( ran F ∪ { ∅ } ) ;;
	step 3 : wff = 0ex () |- ∅ ∈ _V ;;
	step 4 : wff = snid (step 3) |- ∅ ∈ { ∅ } ;;
	step 5 : wff = sselii (step 2, step 4) |- ∅ ∈ ( ran F ∪ { ∅ } ) ;;
	step 6 : wff = syl6eqel (step 1, step 5) |- ( ( F ` X ) = ∅ → ( F ` X ) ∈ ( ran F ∪ { ∅ } ) ) ;;
	step 7 : wff = ssun1 () |- ran F ⊆ ( ran F ∪ { ∅ } ) ;;
	step 8 : wff = fvprc () |- ( ¬ X ∈ _V → ( F ` X ) = ∅ ) ;;
	step 9 : wff = con1i (step 8) |- ( ¬ ( F ` X ) = ∅ → X ∈ _V ) ;;
	step 10 : wff = fvex () |- ( F ` X ) ∈ _V ;;
	step 11 : wff = a1i (step 10) |- ( ¬ ( F ` X ) = ∅ → ( F ` X ) ∈ _V ) ;;
	step 12 : wff = fvbr0 () |- ( X F ( F ` X ) ∨ ( F ` X ) = ∅ ) ;;
	step 13 : wff = ori (step 12) |- ( ¬ X F ( F ` X ) → ( F ` X ) = ∅ ) ;;
	step 14 : wff = con1i (step 13) |- ( ¬ ( F ` X ) = ∅ → X F ( F ` X ) ) ;;
	step 15 : wff = brelrng () |- ( ( X ∈ _V ∧ ( F ` X ) ∈ _V ∧ X F ( F ` X ) ) → ( F ` X ) ∈ ran F ) ;;
	step 16 : wff = syl3anc (step 9, step 11, step 14, step 15) |- ( ¬ ( F ` X ) = ∅ → ( F ` X ) ∈ ran F ) ;;
	step 17 : wff = sseldi (step 7, step 16) |- ( ¬ ( F ` X ) = ∅ → ( F ` X ) ∈ ( ran F ∪ { ∅ } ) ) ;;
	step 18 : wff = pm2.61i (step 6, step 17) |- ( F ` X ) ∈ ( ran F ∪ { ∅ } ) ;;
	qed prop 1 = step 18 ;;
}

/*The result of a function value is always a subset of the union of the
     range, even if it is invalid and thus empty.  (Contributed by Stefan
     O'Rear, 2-Nov-2014.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fvssunirn (F : class, X : class)  {
	prop 1 : wff = |- ( F ` X ) ⊆ ⋃ ran F ;;
}

proof of fvssunirn {
	step 1 : wff = fvrn0 () |- ( F ` X ) ∈ ( ran F ∪ { ∅ } ) ;;
	step 2 : wff = elssuni () |- ( ( F ` X ) ∈ ( ran F ∪ { ∅ } ) → ( F ` X ) ⊆ ⋃ ( ran F ∪ { ∅ } ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( F ` X ) ⊆ ⋃ ( ran F ∪ { ∅ } ) ;;
	step 4 : wff = uniun () |- ⋃ ( ran F ∪ { ∅ } ) = ( ⋃ ran F ∪ ⋃ { ∅ } ) ;;
	step 5 : wff = 0ex () |- ∅ ∈ _V ;;
	step 6 : wff = unisn (step 5) |- ⋃ { ∅ } = ∅ ;;
	step 7 : wff = uneq2i (step 6) |- ( ⋃ ran F ∪ ⋃ { ∅ } ) = ( ⋃ ran F ∪ ∅ ) ;;
	step 8 : wff = un0 () |- ( ⋃ ran F ∪ ∅ ) = ⋃ ran F ;;
	step 9 : wff = 3eqtri (step 4, step 7, step 8) |- ⋃ ( ran F ∪ { ∅ } ) = ⋃ ran F ;;
	step 10 : wff = sseqtri (step 3, step 9) |- ( F ` X ) ⊆ ⋃ ran F ;;
	qed prop 1 = step 10 ;;
}

/*The value of a class outside its domain is the empty set.  (Contributed
       by NM, 24-Aug-1995.) */

theorem ndmfv (A : class, F : class) disjointed(x A, x F) {
	prop 1 : wff = |- ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ;;
}

proof of ndmfv {
	var x : set;;
	step 1 : wff = euex () |- ( ∃! x A F x → ∃ x A F x ) ;;
	step 2 : wff = eldmg () |- ( A ∈ _V → ( A ∈ dom F ↔ ∃ x A F x ) ) ;;
	step 3 : wff = syl5ibr (step 1, step 2) |- ( A ∈ _V → ( ∃! x A F x → A ∈ dom F ) ) ;;
	step 4 : wff = con3d (step 3) |- ( A ∈ _V → ( ¬ A ∈ dom F → ¬ ∃! x A F x ) ) ;;
	step 5 : wff = tz6.12-2 () |- ( ¬ ∃! x A F x → ( F ` A ) = ∅ ) ;;
	step 6 : wff = syl6 (step 4, step 5) |- ( A ∈ _V → ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ) ;;
	step 7 : wff = fvprc () |- ( ¬ A ∈ _V → ( F ` A ) = ∅ ) ;;
	step 8 : wff = a1d (step 7) |- ( ¬ A ∈ _V → ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ) ;;
	step 9 : wff = pm2.61i (step 6, step 8) |- ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ;;
	qed prop 1 = step 9 ;;
}

/*Reverse closure law for function with the empty set not in its domain.
       (Contributed by NM, 26-Apr-1996.) */

theorem ndmfvrcl (A : class, S : class, F : class)  {
	hyp 1 : wff = |- dom F = S ;;
	hyp 2 : wff = |- ¬ ∅ ∈ S ;;
	-----------------------
	prop 1 : wff = |- ( ( F ` A ) ∈ S → A ∈ S ) ;;
}

proof of ndmfvrcl {
	step 1 : wff = ndmfv () |- ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ;;
	step 2 : wff = eleq1d (step 1) |- ( ¬ A ∈ dom F → ( ( F ` A ) ∈ S ↔ ∅ ∈ S ) ) ;;
	step 3 : wff = mtbiri (hyp 2, step 2) |- ( ¬ A ∈ dom F → ¬ ( F ` A ) ∈ S ) ;;
	step 4 : wff = con4i (step 3) |- ( ( F ` A ) ∈ S → A ∈ dom F ) ;;
	step 5 : wff = syl6eleq (step 4, hyp 1) |- ( ( F ` A ) ∈ S → A ∈ S ) ;;
	qed prop 1 = step 5 ;;
}

/*If a function value has a member, the argument belongs to the domain.
     (Contributed by NM, 12-Feb-2007.) */

theorem elfvdm (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( A ∈ ( F ` B ) → B ∈ dom F ) ;;
}

proof of elfvdm {
	step 1 : wff = ne0i () |- ( A ∈ ( F ` B ) → ( F ` B ) ≠ ∅ ) ;;
	step 2 : wff = ndmfv () |- ( ¬ B ∈ dom F → ( F ` B ) = ∅ ) ;;
	step 3 : wff = necon1ai (step 2) |- ( ( F ` B ) ≠ ∅ → B ∈ dom F ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( A ∈ ( F ` B ) → B ∈ dom F ) ;;
	qed prop 1 = step 4 ;;
}

/*If a function value has a member, the argument is a set.  (Contributed by
     Mario Carneiro, 6-Nov-2015.) */

theorem elfvex (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( A ∈ ( F ` B ) → B ∈ _V ) ;;
}

proof of elfvex {
	step 1 : wff = elfvdm () |- ( A ∈ ( F ` B ) → B ∈ dom F ) ;;
	step 2 : wff = elex () |- ( B ∈ dom F → B ∈ _V ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ∈ ( F ` B ) → B ∈ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*If a function value is nonempty, its argument is a set.  Deduction form
       of ~ elfvex .  (Contributed by David Moews, 1-May-2017.) */

theorem elfvexd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ ( B ` C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C ∈ _V ) ;;
}

proof of elfvexd {
	step 1 : wff = elfvex () |- ( A ∈ ( B ` C ) → C ∈ _V ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → C ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/*The value of a non-member of a restriction is the empty set.  (Contributed
     by NM, 13-Nov-1995.) */

theorem nfvres (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ¬ A ∈ B → ( ( F ↾ B ) ` A ) = ∅ ) ;;
}

proof of nfvres {
	step 1 : wff = dmres () |- dom ( F ↾ B ) = ( B ∩ dom F ) ;;
	step 2 : wff = inss1 () |- ( B ∩ dom F ) ⊆ B ;;
	step 3 : wff = eqsstri (step 1, step 2) |- dom ( F ↾ B ) ⊆ B ;;
	step 4 : wff = sseli (step 3) |- ( A ∈ dom ( F ↾ B ) → A ∈ B ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ A ∈ B → ¬ A ∈ dom ( F ↾ B ) ) ;;
	step 6 : wff = ndmfv () |- ( ¬ A ∈ dom ( F ↾ B ) → ( ( F ↾ B ) ` A ) = ∅ ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ¬ A ∈ B → ( ( F ↾ B ) ` A ) = ∅ ) ;;
	qed prop 1 = step 7 ;;
}

/*If the restriction of a class to a singleton is not a function, its
       value is the empty set.  (Contributed by NM, 8-Aug-2010.)  (Proof
       shortened by Andrew Salmon, 22-Oct-2011.) */

theorem nfunsn (A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( ¬ Fun ( F ↾ { A } ) → ( F ` A ) = ∅ ) ;;
}

proof of nfunsn {
	var x : set, y : set;;
	step 1 : wff = eumo () |- ( ∃! y A F y → ∃* y A F y ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = brres (step 2) |- ( x ( F ↾ { A } ) y ↔ ( x F y ∧ x ∈ { A } ) ) ;;
	step 4 : wff = elsn () |- ( x ∈ { A } ↔ x = A ) ;;
	step 5 : wff = breq1 () |- ( x = A → ( x F y ↔ A F y ) ) ;;
	step 6 : wff = sylbi (step 4, step 5) |- ( x ∈ { A } → ( x F y ↔ A F y ) ) ;;
	step 7 : wff = biimpac (step 6) |- ( ( x F y ∧ x ∈ { A } ) → A F y ) ;;
	step 8 : wff = sylbi (step 3, step 7) |- ( x ( F ↾ { A } ) y → A F y ) ;;
	step 9 : wff = moimi (step 8) |- ( ∃* y A F y → ∃* y x ( F ↾ { A } ) y ) ;;
	step 10 : wff = syl (step 1, step 9) |- ( ∃! y A F y → ∃* y x ( F ↾ { A } ) y ) ;;
	step 11 : wff = tz6.12-2 () |- ( ¬ ∃! y A F y → ( F ` A ) = ∅ ) ;;
	step 12 : wff = nsyl4 (step 10, step 11) |- ( ¬ ( F ` A ) = ∅ → ∃* y x ( F ↾ { A } ) y ) ;;
	step 13 : wff = alrimiv (step 12) |- ( ¬ ( F ` A ) = ∅ → ∀ x ∃* y x ( F ↾ { A } ) y ) ;;
	step 14 : wff = relres () |- Rel ( F ↾ { A } ) ;;
	step 15 : wff = jctil (step 13, step 14) |- ( ¬ ( F ` A ) = ∅ → ( Rel ( F ↾ { A } ) ∧ ∀ x ∃* y x ( F ↾ { A } ) y ) ) ;;
	step 16 : wff = dffun6 () |- ( Fun ( F ↾ { A } ) ↔ ( Rel ( F ↾ { A } ) ∧ ∀ x ∃* y x ( F ↾ { A } ) y ) ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ¬ ( F ` A ) = ∅ → Fun ( F ↾ { A } ) ) ;;
	step 18 : wff = con1i (step 17) |- ( ¬ Fun ( F ↾ { A } ) → ( F ` A ) = ∅ ) ;;
	qed prop 1 = step 18 ;;
}

/*Function value of the empty set.  (Contributed by Stefan O'Rear,
     26-Nov-2014.) */

theorem fv01 (A : class)  {
	prop 1 : wff = |- ( ∅ ` A ) = ∅ ;;
}

proof of fv01 {
	step 1 : wff = noel () |- ¬ A ∈ ∅ ;;
	step 2 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 3 : wff = eleq2i (step 2) |- ( A ∈ dom ∅ ↔ A ∈ ∅ ) ;;
	step 4 : wff = mtbir (step 1, step 3) |- ¬ A ∈ dom ∅ ;;
	step 5 : wff = ndmfv () |- ( ¬ A ∈ dom ∅ → ( ∅ ` A ) = ∅ ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( ∅ ` A ) = ∅ ;;
	qed prop 1 = step 6 ;;
}

/*Equal values imply equal values in a restriction.  (Contributed by NM,
     13-Nov-1995.) */

theorem fveqres (A : class, B : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( F ` A ) = ( G ` A ) → ( ( F ↾ B ) ` A ) = ( ( G ↾ B ) ` A ) ) ;;
}

proof of fveqres {
	step 1 : wff = fvres () |- ( A ∈ B → ( ( F ↾ B ) ` A ) = ( F ` A ) ) ;;
	step 2 : wff = fvres () |- ( A ∈ B → ( ( G ↾ B ) ` A ) = ( G ` A ) ) ;;
	step 3 : wff = eqeq12d (step 1, step 2) |- ( A ∈ B → ( ( ( F ↾ B ) ` A ) = ( ( G ↾ B ) ` A ) ↔ ( F ` A ) = ( G ` A ) ) ) ;;
	step 4 : wff = biimprd (step 3) |- ( A ∈ B → ( ( F ` A ) = ( G ` A ) → ( ( F ↾ B ) ` A ) = ( ( G ↾ B ) ` A ) ) ) ;;
	step 5 : wff = nfvres () |- ( ¬ A ∈ B → ( ( F ↾ B ) ` A ) = ∅ ) ;;
	step 6 : wff = nfvres () |- ( ¬ A ∈ B → ( ( G ↾ B ) ` A ) = ∅ ) ;;
	step 7 : wff = eqtr4d (step 5, step 6) |- ( ¬ A ∈ B → ( ( F ↾ B ) ` A ) = ( ( G ↾ B ) ` A ) ) ;;
	step 8 : wff = a1d (step 7) |- ( ¬ A ∈ B → ( ( F ` A ) = ( G ` A ) → ( ( F ↾ B ) ` A ) = ( ( G ↾ B ) ` A ) ) ) ;;
	step 9 : wff = pm2.61i (step 4, step 8) |- ( ( F ` A ) = ( G ` A ) → ( ( F ↾ B ) ` A ) = ( ( G ↾ B ) ` A ) ) ;;
	qed prop 1 = step 9 ;;
}

/*The second argument of a binary relation on a function is the function's
       value.  (Contributed by NM, 30-Apr-2004.)  (Revised by Mario Carneiro,
       28-Apr-2015.) */

theorem funbrfv (A : class, B : class, F : class) disjointed(y A, y F, y B) {
	prop 1 : wff = |- ( Fun F → ( A F B → ( F ` A ) = B ) ) ;;
}

proof of funbrfv {
	var y : set;;
	step 1 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 2 : wff = brrelex2 () |- ( ( Rel F ∧ A F B ) → B ∈ _V ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( Fun F ∧ A F B ) → B ∈ _V ) ;;
	step 4 : wff = breq2 () |- ( y = B → ( A F y ↔ A F B ) ) ;;
	step 5 : wff = anbi2d (step 4) |- ( y = B → ( ( Fun F ∧ A F y ) ↔ ( Fun F ∧ A F B ) ) ) ;;
	step 6 : wff = eqeq2 () |- ( y = B → ( ( F ` A ) = y ↔ ( F ` A ) = B ) ) ;;
	step 7 : wff = imbi12d (step 5, step 6) |- ( y = B → ( ( ( Fun F ∧ A F y ) → ( F ` A ) = y ) ↔ ( ( Fun F ∧ A F B ) → ( F ` A ) = B ) ) ) ;;
	step 8 : wff = funeu () |- ( ( Fun F ∧ A F y ) → ∃! y A F y ) ;;
	step 9 : wff = tz6.12-1 () |- ( ( A F y ∧ ∃! y A F y ) → ( F ` A ) = y ) ;;
	step 10 : wff = sylan2 (step 8, step 9) |- ( ( A F y ∧ ( Fun F ∧ A F y ) ) → ( F ` A ) = y ) ;;
	step 11 : wff = anabss7 (step 10) |- ( ( Fun F ∧ A F y ) → ( F ` A ) = y ) ;;
	step 12 : wff = vtoclg (step 7, step 11) |- ( B ∈ _V → ( ( Fun F ∧ A F B ) → ( F ` A ) = B ) ) ;;
	step 13 : wff = mpcom (step 3, step 12) |- ( ( Fun F ∧ A F B ) → ( F ` A ) = B ) ;;
	step 14 : wff = ex (step 13) |- ( Fun F → ( A F B → ( F ` A ) = B ) ) ;;
	qed prop 1 = step 14 ;;
}

/*The second element in an ordered pair member of a function is the
       function's value.  (Contributed by NM, 19-Jul-1996.) */

theorem funopfv (A : class, B : class, F : class) disjointed(A, F, B) {
	prop 1 : wff = |- ( Fun F → ( 〈 A , B 〉 ∈ F → ( F ` A ) = B ) ) ;;
}

proof of funopfv {
	step 1 : wff = df-br () |- ( A F B ↔ 〈 A , B 〉 ∈ F ) ;;
	step 2 : wff = funbrfv () |- ( Fun F → ( A F B → ( F ` A ) = B ) ) ;;
	step 3 : wff = syl5bir (step 1, step 2) |- ( Fun F → ( 〈 A , B 〉 ∈ F → ( F ` A ) = B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalence of function value and binary relation.  (Contributed by NM,
       19-Apr-2004.)  (Revised by Mario Carneiro, 28-Apr-2015.) */

theorem fnbrfvb (A : class, B : class, C : class, F : class) disjointed(x F, x A, x B, x C) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = C ↔ B F C ) ) ;;
}

proof of fnbrfvb {
	var x : set;;
	step 1 : wff = eqid () |- ( F ` B ) = ( F ` B ) ;;
	step 2 : wff = fvex () |- ( F ` B ) ∈ _V ;;
	step 3 : wff = eqeq2 () |- ( x = ( F ` B ) → ( ( F ` B ) = x ↔ ( F ` B ) = ( F ` B ) ) ) ;;
	step 4 : wff = breq2 () |- ( x = ( F ` B ) → ( B F x ↔ B F ( F ` B ) ) ) ;;
	step 5 : wff = bibi12d (step 3, step 4) |- ( x = ( F ` B ) → ( ( ( F ` B ) = x ↔ B F x ) ↔ ( ( F ` B ) = ( F ` B ) ↔ B F ( F ` B ) ) ) ) ;;
	step 6 : wff = imbi2d (step 5) |- ( x = ( F ` B ) → ( ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = x ↔ B F x ) ) ↔ ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = ( F ` B ) ↔ B F ( F ` B ) ) ) ) ) ;;
	step 7 : wff = fneu () |- ( ( F Fn A ∧ B ∈ A ) → ∃! x B F x ) ;;
	step 8 : wff = tz6.12c () |- ( ∃! x B F x → ( ( F ` B ) = x ↔ B F x ) ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = x ↔ B F x ) ) ;;
	step 10 : wff = vtocl (step 2, step 6, step 9) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = ( F ` B ) ↔ B F ( F ` B ) ) ) ;;
	step 11 : wff = mpbii (step 1, step 10) |- ( ( F Fn A ∧ B ∈ A ) → B F ( F ` B ) ) ;;
	step 12 : wff = breq2 () |- ( ( F ` B ) = C → ( B F ( F ` B ) ↔ B F C ) ) ;;
	step 13 : wff = syl5ibcom (step 11, step 12) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = C → B F C ) ) ;;
	step 14 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 15 : wff = funbrfv () |- ( Fun F → ( B F C → ( F ` B ) = C ) ) ;;
	step 16 : wff = syl (step 14, step 15) |- ( F Fn A → ( B F C → ( F ` B ) = C ) ) ;;
	step 17 : wff = adantr (step 16) |- ( ( F Fn A ∧ B ∈ A ) → ( B F C → ( F ` B ) = C ) ) ;;
	step 18 : wff = impbid (step 13, step 17) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = C ↔ B F C ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Equivalence of function value and ordered pair membership.  (Contributed
       by NM, 7-Nov-1995.) */

theorem fnopfvb (A : class, B : class, C : class, F : class) disjointed(F, A, B, C) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = C ↔ 〈 B , C 〉 ∈ F ) ) ;;
}

proof of fnopfvb {
	step 1 : wff = fnbrfvb () |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = C ↔ B F C ) ) ;;
	step 2 : wff = df-br () |- ( B F C ↔ 〈 B , C 〉 ∈ F ) ;;
	step 3 : wff = syl6bb (step 1, step 2) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = C ↔ 〈 B , C 〉 ∈ F ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalence of function value and binary relation.  (Contributed by NM,
       26-Mar-2006.) */

theorem funbrfvb (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ A F B ) ) ;;
}

proof of funbrfvb {
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = fnbrfvb () |- ( ( F Fn dom F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ A F B ) ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ A F B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalence of function value and ordered pair membership.  Theorem
       4.3(ii) of [Monk1] p. 42.  (Contributed by NM, 26-Jan-1997.) */

theorem funopfvb (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ F ) ) ;;
}

proof of funopfvb {
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = fnopfvb () |- ( ( F Fn dom F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ F ) ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ F ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Function value in terms of a binary relation.  (Contributed by Mario
       Carneiro, 19-Mar-2014.) */

theorem funbrfv2b (A : class, B : class, F : class) disjointed(A, B, F) {
	prop 1 : wff = |- ( Fun F → ( A F B ↔ ( A ∈ dom F ∧ ( F ` A ) = B ) ) ) ;;
}

proof of funbrfv2b {
	step 1 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 2 : wff = releldm () |- ( ( Rel F ∧ A F B ) → A ∈ dom F ) ;;
	step 3 : wff = ex (step 2) |- ( Rel F → ( A F B → A ∈ dom F ) ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( Fun F → ( A F B → A ∈ dom F ) ) ;;
	step 5 : wff = pm4.71rd (step 4) |- ( Fun F → ( A F B ↔ ( A ∈ dom F ∧ A F B ) ) ) ;;
	step 6 : wff = funbrfvb () |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) = B ↔ A F B ) ) ;;
	step 7 : wff = pm5.32da (step 6) |- ( Fun F → ( ( A ∈ dom F ∧ ( F ` A ) = B ) ↔ ( A ∈ dom F ∧ A F B ) ) ) ;;
	step 8 : wff = bitr4d (step 5, step 7) |- ( Fun F → ( A F B ↔ ( A ∈ dom F ∧ ( F ` A ) = B ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Representation of a function in terms of its values.  (Contributed by
       FL, 14-Sep-2013.)  (Proof shortened by Mario Carneiro, 31-Aug-2015.) */

theorem dffn5 (x : set, A : class, F : class) disjointed(x y A, x y, x y F, x y) {
	prop 1 : wff = |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
}

proof of dffn5 {
	var y : set;;
	step 1 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 2 : wff = dfrel4v () |- ( Rel F ↔ F = { 〈 x , y 〉 | x F y } ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( F Fn A → F = { 〈 x , y 〉 | x F y } ) ;;
	step 4 : wff = fnbr () |- ( ( F Fn A ∧ x F y ) → x ∈ A ) ;;
	step 5 : wff = ex (step 4) |- ( F Fn A → ( x F y → x ∈ A ) ) ;;
	step 6 : wff = pm4.71rd (step 5) |- ( F Fn A → ( x F y ↔ ( x ∈ A ∧ x F y ) ) ) ;;
	step 7 : wff = eqcom () |- ( y = ( F ` x ) ↔ ( F ` x ) = y ) ;;
	step 8 : wff = fnbrfvb () |- ( ( F Fn A ∧ x ∈ A ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 9 : wff = syl5bb (step 7, step 8) |- ( ( F Fn A ∧ x ∈ A ) → ( y = ( F ` x ) ↔ x F y ) ) ;;
	step 10 : wff = pm5.32da (step 9) |- ( F Fn A → ( ( x ∈ A ∧ y = ( F ` x ) ) ↔ ( x ∈ A ∧ x F y ) ) ) ;;
	step 11 : wff = bitr4d (step 6, step 10) |- ( F Fn A → ( x F y ↔ ( x ∈ A ∧ y = ( F ` x ) ) ) ) ;;
	step 12 : wff = opabbidv (step 11) |- ( F Fn A → { 〈 x , y 〉 | x F y } = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ) ;;
	step 13 : wff = eqtrd (step 3, step 12) |- ( F Fn A → F = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ) ;;
	step 14 : wff = df-mpt () |- ( x ∈ A ↦ ( F ` x ) ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ;;
	step 15 : wff = syl6eqr (step 13, step 14) |- ( F Fn A → F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 16 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 17 : wff = eqid () |- ( x ∈ A ↦ ( F ` x ) ) = ( x ∈ A ↦ ( F ` x ) ) ;;
	step 18 : wff = fnmpti (step 16, step 17) |- ( x ∈ A ↦ ( F ` x ) ) Fn A ;;
	step 19 : wff = fneq1 () |- ( F = ( x ∈ A ↦ ( F ` x ) ) → ( F Fn A ↔ ( x ∈ A ↦ ( F ` x ) ) Fn A ) ) ;;
	step 20 : wff = mpbiri (step 18, step 19) |- ( F = ( x ∈ A ↦ ( F ` x ) ) → F Fn A ) ;;
	step 21 : wff = impbii (step 15, step 20) |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	qed prop 1 = step 21 ;;
}

/*The range of a function expressed as a collection of the function's
       values.  (Contributed by NM, 20-Oct-2005.)  (Proof shortened by Mario
       Carneiro, 31-Aug-2015.) */

theorem fnrnfv (x : set, y : set, A : class, F : class) disjointed(x y A, x y, x y F, x y) {
	prop 1 : wff = |- ( F Fn A → ran F = { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
}

proof of fnrnfv {
	step 1 : wff = dffn5 () |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 2 : wff = rneq () |- ( F = ( x ∈ A ↦ ( F ` x ) ) → ran F = ran ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( F Fn A → ran F = ran ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 4 : wff = eqid () |- ( x ∈ A ↦ ( F ` x ) ) = ( x ∈ A ↦ ( F ` x ) ) ;;
	step 5 : wff = rnmpt (step 4) |- ran ( x ∈ A ↦ ( F ` x ) ) = { y | ∃ x ∈ A y = ( F ` x ) } ;;
	step 6 : wff = syl6eq (step 3, step 5) |- ( F Fn A → ran F = { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	qed prop 1 = step 6 ;;
}

/*A member of a function's range is a value of the function.  (Contributed
       by NM, 31-Oct-1995.) */

theorem fvelrnb (x : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F, x y) {
	prop 1 : wff = |- ( F Fn A → ( B ∈ ran F ↔ ∃ x ∈ A ( F ` x ) = B ) ) ;;
}

proof of fvelrnb {
	var y : set;;
	step 1 : wff = fnrnfv () |- ( F Fn A → ran F = { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	step 2 : wff = eleq2d (step 1) |- ( F Fn A → ( B ∈ ran F ↔ B ∈ { y | ∃ x ∈ A y = ( F ` x ) } ) ) ;;
	step 3 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 4 : wff = eleq1 () |- ( ( F ` x ) = B → ( ( F ` x ) ∈ _V ↔ B ∈ _V ) ) ;;
	step 5 : wff = mpbii (step 3, step 4) |- ( ( F ` x ) = B → B ∈ _V ) ;;
	step 6 : wff = rexlimivw (step 5) |- ( ∃ x ∈ A ( F ` x ) = B → B ∈ _V ) ;;
	step 7 : wff = eqeq1 () |- ( y = B → ( y = ( F ` x ) ↔ B = ( F ` x ) ) ) ;;
	step 8 : wff = eqcom () |- ( B = ( F ` x ) ↔ ( F ` x ) = B ) ;;
	step 9 : wff = syl6bb (step 7, step 8) |- ( y = B → ( y = ( F ` x ) ↔ ( F ` x ) = B ) ) ;;
	step 10 : wff = rexbidv (step 9) |- ( y = B → ( ∃ x ∈ A y = ( F ` x ) ↔ ∃ x ∈ A ( F ` x ) = B ) ) ;;
	step 11 : wff = elab3 (step 6, step 10) |- ( B ∈ { y | ∃ x ∈ A y = ( F ` x ) } ↔ ∃ x ∈ A ( F ` x ) = B ) ;;
	step 12 : wff = syl6bb (step 2, step 11) |- ( F Fn A → ( B ∈ ran F ↔ ∃ x ∈ A ( F ` x ) = B ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Alternate definition of the image of a function.  (Contributed by Raph
       Levien, 20-Nov-2006.) */

theorem dfimafn (x : set, y : set, A : class, F : class) disjointed(x y A, x y, x y F, x y) {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( F " A ) = { y | ∃ x ∈ A ( F ` x ) = y } ) ;;
}

proof of dfimafn {
	step 1 : wff = ssel () |- ( A ⊆ dom F → ( x ∈ A → x ∈ dom F ) ) ;;
	step 2 : wff = funbrfvb () |- ( ( Fun F ∧ x ∈ dom F ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 3 : wff = ex (step 2) |- ( Fun F → ( x ∈ dom F → ( ( F ` x ) = y ↔ x F y ) ) ) ;;
	step 4 : wff = syl9r (step 1, step 3) |- ( Fun F → ( A ⊆ dom F → ( x ∈ A → ( ( F ` x ) = y ↔ x F y ) ) ) ) ;;
	step 5 : wff = imp31 (step 4) |- ( ( ( Fun F ∧ A ⊆ dom F ) ∧ x ∈ A ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 6 : wff = rexbidva (step 5) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ∃ x ∈ A ( F ` x ) = y ↔ ∃ x ∈ A x F y ) ) ;;
	step 7 : wff = abbidv (step 6) |- ( ( Fun F ∧ A ⊆ dom F ) → { y | ∃ x ∈ A ( F ` x ) = y } = { y | ∃ x ∈ A x F y } ) ;;
	step 8 : wff = dfima2 () |- ( F " A ) = { y | ∃ x ∈ A x F y } ;;
	step 9 : wff = syl6reqr (step 7, step 8) |- ( ( Fun F ∧ A ⊆ dom F ) → ( F " A ) = { y | ∃ x ∈ A ( F ` x ) = y } ) ;;
	qed prop 1 = step 9 ;;
}

/*Alternate definition of the image of a function as an indexed union of
       singletons of function values.  (Contributed by Raph Levien,
       20-Nov-2006.) */

theorem dfimafn2 (x : set, A : class, F : class) disjointed(x y A, x y, x y F, x y) {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( F " A ) = ⋃_ x ∈ A { ( F ` x ) } ) ;;
}

proof of dfimafn2 {
	var y : set;;
	step 1 : wff = dfimafn () |- ( ( Fun F ∧ A ⊆ dom F ) → ( F " A ) = { y | ∃ x ∈ A ( F ` x ) = y } ) ;;
	step 2 : wff = iunab () |- ⋃_ x ∈ A { y | ( F ` x ) = y } = { y | ∃ x ∈ A ( F ` x ) = y } ;;
	step 3 : wff = syl6eqr (step 1, step 2) |- ( ( Fun F ∧ A ⊆ dom F ) → ( F " A ) = ⋃_ x ∈ A { y | ( F ` x ) = y } ) ;;
	step 4 : wff = df-sn () |- { ( F ` x ) } = { y | y = ( F ` x ) } ;;
	step 5 : wff = eqcom () |- ( y = ( F ` x ) ↔ ( F ` x ) = y ) ;;
	step 6 : wff = abbii (step 5) |- { y | y = ( F ` x ) } = { y | ( F ` x ) = y } ;;
	step 7 : wff = eqtri (step 4, step 6) |- { ( F ` x ) } = { y | ( F ` x ) = y } ;;
	step 8 : wff = a1i (step 7) |- ( x ∈ A → { ( F ` x ) } = { y | ( F ` x ) = y } ) ;;
	step 9 : wff = iuneq2i (step 8) |- ⋃_ x ∈ A { ( F ` x ) } = ⋃_ x ∈ A { y | ( F ` x ) = y } ;;
	step 10 : wff = syl6eqr (step 3, step 9) |- ( ( Fun F ∧ A ⊆ dom F ) → ( F " A ) = ⋃_ x ∈ A { ( F ` x ) } ) ;;
	qed prop 1 = step 10 ;;
}

/*Membership relation for the values of a function whose image is a
       subclass.  (Contributed by Raph Levien, 20-Nov-2006.) */

theorem funimass4 (x : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F, x y) {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
}

proof of funimass4 {
	var y : set;;
	step 1 : wff = dfss2 () |- ( ( F " A ) ⊆ B ↔ ∀ y ( y ∈ ( F " A ) → y ∈ B ) ) ;;
	step 2 : wff = eqcom () |- ( y = ( F ` x ) ↔ ( F ` x ) = y ) ;;
	step 3 : wff = ssel () |- ( A ⊆ dom F → ( x ∈ A → x ∈ dom F ) ) ;;
	step 4 : wff = funbrfvb () |- ( ( Fun F ∧ x ∈ dom F ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 5 : wff = ex (step 4) |- ( Fun F → ( x ∈ dom F → ( ( F ` x ) = y ↔ x F y ) ) ) ;;
	step 6 : wff = syl9 (step 3, step 5) |- ( A ⊆ dom F → ( Fun F → ( x ∈ A → ( ( F ` x ) = y ↔ x F y ) ) ) ) ;;
	step 7 : wff = imp31 (step 6) |- ( ( ( A ⊆ dom F ∧ Fun F ) ∧ x ∈ A ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 8 : wff = syl5bb (step 2, step 7) |- ( ( ( A ⊆ dom F ∧ Fun F ) ∧ x ∈ A ) → ( y = ( F ` x ) ↔ x F y ) ) ;;
	step 9 : wff = rexbidva (step 8) |- ( ( A ⊆ dom F ∧ Fun F ) → ( ∃ x ∈ A y = ( F ` x ) ↔ ∃ x ∈ A x F y ) ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = elima (step 10) |- ( y ∈ ( F " A ) ↔ ∃ x ∈ A x F y ) ;;
	step 12 : wff = syl6rbbr (step 9, step 11) |- ( ( A ⊆ dom F ∧ Fun F ) → ( y ∈ ( F " A ) ↔ ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 13 : wff = imbi1d (step 12) |- ( ( A ⊆ dom F ∧ Fun F ) → ( ( y ∈ ( F " A ) → y ∈ B ) ↔ ( ∃ x ∈ A y = ( F ` x ) → y ∈ B ) ) ) ;;
	step 14 : wff = r19.23v () |- ( ∀ x ∈ A ( y = ( F ` x ) → y ∈ B ) ↔ ( ∃ x ∈ A y = ( F ` x ) → y ∈ B ) ) ;;
	step 15 : wff = syl6bbr (step 13, step 14) |- ( ( A ⊆ dom F ∧ Fun F ) → ( ( y ∈ ( F " A ) → y ∈ B ) ↔ ∀ x ∈ A ( y = ( F ` x ) → y ∈ B ) ) ) ;;
	step 16 : wff = albidv (step 15) |- ( ( A ⊆ dom F ∧ Fun F ) → ( ∀ y ( y ∈ ( F " A ) → y ∈ B ) ↔ ∀ y ∀ x ∈ A ( y = ( F ` x ) → y ∈ B ) ) ) ;;
	step 17 : wff = ralcom4 () |- ( ∀ x ∈ A ∀ y ( y = ( F ` x ) → y ∈ B ) ↔ ∀ y ∀ x ∈ A ( y = ( F ` x ) → y ∈ B ) ) ;;
	step 18 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 19 : wff = eleq1 () |- ( y = ( F ` x ) → ( y ∈ B ↔ ( F ` x ) ∈ B ) ) ;;
	step 20 : wff = ceqsalv (step 18, step 19) |- ( ∀ y ( y = ( F ` x ) → y ∈ B ) ↔ ( F ` x ) ∈ B ) ;;
	step 21 : wff = ralbii (step 20) |- ( ∀ x ∈ A ∀ y ( y = ( F ` x ) → y ∈ B ) ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ;;
	step 22 : wff = bitr3i (step 17, step 21) |- ( ∀ y ∀ x ∈ A ( y = ( F ` x ) → y ∈ B ) ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ;;
	step 23 : wff = syl6bb (step 16, step 22) |- ( ( A ⊆ dom F ∧ Fun F ) → ( ∀ y ( y ∈ ( F " A ) → y ∈ B ) ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 24 : wff = syl5bb (step 1, step 23) |- ( ( A ⊆ dom F ∧ Fun F ) → ( ( F " A ) ⊆ B ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 25 : wff = ancoms (step 24) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	qed prop 1 = step 25 ;;
}

/*Function value in an image.  Part of Theorem 4.4(iii) of [Monk1] p. 42.
       (Contributed by NM, 29-Apr-2004.)  (Proof shortened by Andrew Salmon,
       22-Oct-2011.) */

theorem fvelima (x : set, A : class, B : class, F : class) disjointed(x A, x B, x F, x) {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ ( F " B ) ) → ∃ x ∈ B ( F ` x ) = A ) ;;
}

proof of fvelima {
	step 1 : wff = elimag () |- ( A ∈ ( F " B ) → ( A ∈ ( F " B ) ↔ ∃ x ∈ B x F A ) ) ;;
	step 2 : wff = ibi (step 1) |- ( A ∈ ( F " B ) → ∃ x ∈ B x F A ) ;;
	step 3 : wff = funbrfv () |- ( Fun F → ( x F A → ( F ` x ) = A ) ) ;;
	step 4 : wff = reximdv (step 3) |- ( Fun F → ( ∃ x ∈ B x F A → ∃ x ∈ B ( F ` x ) = A ) ) ;;
	step 5 : wff = syl5 (step 2, step 4) |- ( Fun F → ( A ∈ ( F " B ) → ∃ x ∈ B ( F ` x ) = A ) ) ;;
	step 6 : wff = imp (step 5) |- ( ( Fun F ∧ A ∈ ( F " B ) ) → ∃ x ∈ B ( F ` x ) = A ) ;;
	qed prop 1 = step 6 ;;
}

/*Deduction form of ~ dffn5 .  (Contributed by Mario Carneiro,
       8-Jan-2015.) */

theorem feqmptd (ph : wff, x : set, A : class, B : class, F : class) disjointed(x A, x, x F) {
	hyp 1 : wff = |- ( ph → F : A ⟶ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
}

proof of feqmptd {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → F Fn A ) ;;
	step 3 : wff = dffn5 () |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( ph → F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Express a restricted function as a mapping.  (Contributed by Mario
       Carneiro, 18-May-2016.) */

theorem feqresmpt (ph : wff, x : set, A : class, B : class, C : class, F : class) disjointed(x A, x C, x F) {
	hyp 1 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 2 : wff = |- ( ph → C ⊆ A ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F ↾ C ) = ( x ∈ C ↦ ( F ` x ) ) ) ;;
}

proof of feqresmpt {
	step 1 : wff = fssres () |- ( ( F : A ⟶ B ∧ C ⊆ A ) → ( F ↾ C ) : C ⟶ B ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → ( F ↾ C ) : C ⟶ B ) ;;
	step 3 : wff = feqmptd (step 2) |- ( ph → ( F ↾ C ) = ( x ∈ C ↦ ( ( F ↾ C ) ` x ) ) ) ;;
	step 4 : wff = fvres () |- ( x ∈ C → ( ( F ↾ C ) ` x ) = ( F ` x ) ) ;;
	step 5 : wff = mpteq2ia (step 4) |- ( x ∈ C ↦ ( ( F ↾ C ) ` x ) ) = ( x ∈ C ↦ ( F ` x ) ) ;;
	step 6 : wff = syl6eq (step 3, step 5) |- ( ph → ( F ↾ C ) = ( x ∈ C ↦ ( F ` x ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Representation of a function in terms of its values.  (Contributed by
       Mario Carneiro, 3-Jul-2015.) */

theorem dffn5f (x : set, A : class, F : class) disjointed(x z, x z A, z F) {
	hyp 1 : wff = |- F/_ x F ;;
	-----------------------
	prop 1 : wff = |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
}

proof of dffn5f {
	var z : set;;
	step 1 : wff = dffn5 () |- ( F Fn A ↔ F = ( z ∈ A ↦ ( F ` z ) ) ) ;;
	step 2 : wff = nfcv () |- F/_ x z ;;
	step 3 : wff = nffv (hyp 1, step 2) |- F/_ x ( F ` z ) ;;
	step 4 : wff = nfcv () |- F/_ z ( F ` x ) ;;
	step 5 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 6 : wff = cbvmpt (step 3, step 4, step 5) |- ( z ∈ A ↦ ( F ` z ) ) = ( x ∈ A ↦ ( F ` x ) ) ;;
	step 7 : wff = eqeq2i (step 6) |- ( F = ( z ∈ A ↦ ( F ` z ) ) ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 8 : wff = bitri (step 1, step 7) |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Function value in an image.  (Contributed by NM, 20-Jan-2007.)  (Proof
       shortened by Andrew Salmon, 22-Oct-2011.)  (Revised by David Abernethy,
       17-Dec-2011.) */

theorem fvelimab (x : set, A : class, B : class, C : class, F : class) disjointed(y A, x y B, x y C, x y F) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ⊆ A ) → ( C ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = C ) ) ;;
}

proof of fvelimab {
	var y : set;;
	step 1 : wff = elex () |- ( C ∈ ( F " B ) → C ∈ _V ) ;;
	step 2 : wff = anim2i (step 1) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ C ∈ ( F " B ) ) → ( ( F Fn A ∧ B ⊆ A ) ∧ C ∈ _V ) ) ;;
	step 3 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 4 : wff = eleq1 () |- ( ( F ` x ) = C → ( ( F ` x ) ∈ _V ↔ C ∈ _V ) ) ;;
	step 5 : wff = mpbii (step 3, step 4) |- ( ( F ` x ) = C → C ∈ _V ) ;;
	step 6 : wff = rexlimivw (step 5) |- ( ∃ x ∈ B ( F ` x ) = C → C ∈ _V ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ ∃ x ∈ B ( F ` x ) = C ) → ( ( F Fn A ∧ B ⊆ A ) ∧ C ∈ _V ) ) ;;
	step 8 : wff = eleq1 () |- ( y = C → ( y ∈ ( F " B ) ↔ C ∈ ( F " B ) ) ) ;;
	step 9 : wff = eqeq2 () |- ( y = C → ( ( F ` x ) = y ↔ ( F ` x ) = C ) ) ;;
	step 10 : wff = rexbidv (step 9) |- ( y = C → ( ∃ x ∈ B ( F ` x ) = y ↔ ∃ x ∈ B ( F ` x ) = C ) ) ;;
	step 11 : wff = bibi12d (step 8, step 10) |- ( y = C → ( ( y ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = y ) ↔ ( C ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = C ) ) ) ;;
	step 12 : wff = imbi2d (step 11) |- ( y = C → ( ( ( F Fn A ∧ B ⊆ A ) → ( y ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = y ) ) ↔ ( ( F Fn A ∧ B ⊆ A ) → ( C ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = C ) ) ) ) ;;
	step 13 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 14 : wff = adantr (step 13) |- ( ( F Fn A ∧ B ⊆ A ) → Fun F ) ;;
	step 15 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 16 : wff = sseq2d (step 15) |- ( F Fn A → ( B ⊆ dom F ↔ B ⊆ A ) ) ;;
	step 17 : wff = biimpar (step 16) |- ( ( F Fn A ∧ B ⊆ A ) → B ⊆ dom F ) ;;
	step 18 : wff = dfimafn () |- ( ( Fun F ∧ B ⊆ dom F ) → ( F " B ) = { y | ∃ x ∈ B ( F ` x ) = y } ) ;;
	step 19 : wff = syl2anc (step 14, step 17, step 18) |- ( ( F Fn A ∧ B ⊆ A ) → ( F " B ) = { y | ∃ x ∈ B ( F ` x ) = y } ) ;;
	step 20 : wff = abeq2d (step 19) |- ( ( F Fn A ∧ B ⊆ A ) → ( y ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = y ) ) ;;
	step 21 : wff = vtoclg (step 12, step 20) |- ( C ∈ _V → ( ( F Fn A ∧ B ⊆ A ) → ( C ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = C ) ) ) ;;
	step 22 : wff = impcom (step 21) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ C ∈ _V ) → ( C ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = C ) ) ;;
	step 23 : wff = pm5.21nd (step 2, step 7, step 22) |- ( ( F Fn A ∧ B ⊆ A ) → ( C ∈ ( F " B ) ↔ ∃ x ∈ B ( F ` x ) = C ) ) ;;
	qed prop 1 = step 23 ;;
}

/*The value of the identity function.  (Contributed by NM, 1-May-2004.)
     (Revised by Mario Carneiro, 28-Apr-2015.) */

theorem fvi (A : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ( _I ` A ) = A ) ;;
}

proof of fvi {
	step 1 : wff = funi () |- Fun _I ;;
	step 2 : wff = ididg () |- ( A ∈ V → A _I A ) ;;
	step 3 : wff = funbrfv () |- ( Fun _I → ( A _I A → ( _I ` A ) = A ) ) ;;
	step 4 : wff = mpsyl (step 1, step 2, step 3) |- ( A ∈ V → ( _I ` A ) = A ) ;;
	qed prop 1 = step 4 ;;
}

/*The value of the identity function is a subset of the argument.
       (Contributed by Mario Carneiro, 27-Feb-2016.) */

theorem fviss (A : class) disjointed(x A, x) {
	prop 1 : wff = |- ( _I ` A ) ⊆ A ;;
}

proof of fviss {
	var x : set;;
	step 1 : wff = id () |- ( x ∈ ( _I ` A ) → x ∈ ( _I ` A ) ) ;;
	step 2 : wff = elfvex () |- ( x ∈ ( _I ` A ) → A ∈ _V ) ;;
	step 3 : wff = fvi () |- ( A ∈ _V → ( _I ` A ) = A ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( x ∈ ( _I ` A ) → ( _I ` A ) = A ) ;;
	step 5 : wff = eleqtrd (step 1, step 4) |- ( x ∈ ( _I ` A ) → x ∈ A ) ;;
	step 6 : wff = ssriv (step 5) |- ( _I ` A ) ⊆ A ;;
	qed prop 1 = step 6 ;;
}

/*The indexed intersection of a function's values is the intersection of
       its range.  (Contributed by NM, 20-Oct-2005.) */

theorem fniinfv (x : set, A : class, F : class) disjointed(x y A, y, x y F) {
	prop 1 : wff = |- ( F Fn A → ⋂_ x ∈ A ( F ` x ) = ⋂ ran F ) ;;
}

proof of fniinfv {
	var y : set;;
	step 1 : wff = fnrnfv () |- ( F Fn A → ran F = { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	step 2 : wff = inteqd (step 1) |- ( F Fn A → ⋂ ran F = ⋂ { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	step 3 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 4 : wff = dfiin2 (step 3) |- ⋂_ x ∈ A ( F ` x ) = ⋂ { y | ∃ x ∈ A y = ( F ` x ) } ;;
	step 5 : wff = syl6reqr (step 2, step 4) |- ( F Fn A → ⋂_ x ∈ A ( F ` x ) = ⋂ ran F ) ;;
	qed prop 1 = step 5 ;;
}

/*Singleton of function value.  (Contributed by NM, 22-May-1998.) */

theorem fnsnfv (A : class, B : class, F : class) disjointed(y A, y B, y F) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → { ( F ` B ) } = ( F " { B } ) ) ;;
}

proof of fnsnfv {
	var y : set;;
	step 1 : wff = eqcom () |- ( y = ( F ` B ) ↔ ( F ` B ) = y ) ;;
	step 2 : wff = fnbrfvb () |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) = y ↔ B F y ) ) ;;
	step 3 : wff = syl5bb (step 1, step 2) |- ( ( F Fn A ∧ B ∈ A ) → ( y = ( F ` B ) ↔ B F y ) ) ;;
	step 4 : wff = abbidv (step 3) |- ( ( F Fn A ∧ B ∈ A ) → { y | y = ( F ` B ) } = { y | B F y } ) ;;
	step 5 : wff = df-sn () |- { ( F ` B ) } = { y | y = ( F ` B ) } ;;
	step 6 : wff = a1i (step 5) |- ( ( F Fn A ∧ B ∈ A ) → { ( F ` B ) } = { y | y = ( F ` B ) } ) ;;
	step 7 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 8 : wff = relimasn () |- ( Rel F → ( F " { B } ) = { y | B F y } ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( F Fn A → ( F " { B } ) = { y | B F y } ) ;;
	step 10 : wff = adantr (step 9) |- ( ( F Fn A ∧ B ∈ A ) → ( F " { B } ) = { y | B F y } ) ;;
	step 11 : wff = 3eqtr4d (step 4, step 6, step 10) |- ( ( F Fn A ∧ B ∈ A ) → { ( F ` B ) } = ( F " { B } ) ) ;;
	qed prop 1 = step 11 ;;
}

/*The image of a pair under a funtion.  (Contributed by Jeff Madsen,
     6-Jan-2011.) */

theorem fnimapr (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ∧ C ∈ A ) → ( F " { B , C } ) = { ( F ` B ) , ( F ` C ) } ) ;;
}

proof of fnimapr {
	step 1 : wff = fnsnfv () |- ( ( F Fn A ∧ B ∈ A ) → { ( F ` B ) } = ( F " { B } ) ) ;;
	step 2 : wff = 3adant3 (step 1) |- ( ( F Fn A ∧ B ∈ A ∧ C ∈ A ) → { ( F ` B ) } = ( F " { B } ) ) ;;
	step 3 : wff = fnsnfv () |- ( ( F Fn A ∧ C ∈ A ) → { ( F ` C ) } = ( F " { C } ) ) ;;
	step 4 : wff = 3adant2 (step 3) |- ( ( F Fn A ∧ B ∈ A ∧ C ∈ A ) → { ( F ` C ) } = ( F " { C } ) ) ;;
	step 5 : wff = uneq12d (step 2, step 4) |- ( ( F Fn A ∧ B ∈ A ∧ C ∈ A ) → ( { ( F ` B ) } ∪ { ( F ` C ) } ) = ( ( F " { B } ) ∪ ( F " { C } ) ) ) ;;
	step 6 : wff = eqcomd (step 5) |- ( ( F Fn A ∧ B ∈ A ∧ C ∈ A ) → ( ( F " { B } ) ∪ ( F " { C } ) ) = ( { ( F ` B ) } ∪ { ( F ` C ) } ) ) ;;
	step 7 : wff = df-pr () |- { B , C } = ( { B } ∪ { C } ) ;;
	step 8 : wff = imaeq2i (step 7) |- ( F " { B , C } ) = ( F " ( { B } ∪ { C } ) ) ;;
	step 9 : wff = imaundi () |- ( F " ( { B } ∪ { C } ) ) = ( ( F " { B } ) ∪ ( F " { C } ) ) ;;
	step 10 : wff = eqtri (step 8, step 9) |- ( F " { B , C } ) = ( ( F " { B } ) ∪ ( F " { C } ) ) ;;
	step 11 : wff = df-pr () |- { ( F ` B ) , ( F ` C ) } = ( { ( F ` B ) } ∪ { ( F ` C ) } ) ;;
	step 12 : wff = 3eqtr4g (step 6, step 10, step 11) |- ( ( F Fn A ∧ B ∈ A ∧ C ∈ A ) → ( F " { B , C } ) = { ( F ` B ) , ( F ` C ) } ) ;;
	qed prop 1 = step 12 ;;
}

/*The existence of a subimage.  (Contributed by NM, 8-Apr-2007.) */

theorem ssimaex (x : set, A : class, B : class, F : class) disjointed(w x y z A, w x y z B, w x y z F) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( Fun F ∧ B ⊆ ( F " A ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
}

proof of ssimaex {
	var y : set, z : set, w : set;;
	step 1 : wff = dmres () |- dom ( F ↾ A ) = ( A ∩ dom F ) ;;
	step 2 : wff = imaeq2i (step 1) |- ( F " dom ( F ↾ A ) ) = ( F " ( A ∩ dom F ) ) ;;
	step 3 : wff = imadmres () |- ( F " dom ( F ↾ A ) ) = ( F " A ) ;;
	step 4 : wff = eqtr3i (step 2, step 3) |- ( F " ( A ∩ dom F ) ) = ( F " A ) ;;
	step 5 : wff = sseq2i (step 4) |- ( B ⊆ ( F " ( A ∩ dom F ) ) ↔ B ⊆ ( F " A ) ) ;;
	step 6 : wff = ssrab2 () |- { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ ( A ∩ dom F ) ;;
	step 7 : wff = ssel2 () |- ( ( B ⊆ ( F " ( A ∩ dom F ) ) ∧ z ∈ B ) → z ∈ ( F " ( A ∩ dom F ) ) ) ;;
	step 8 : wff = adantll (step 7) |- ( ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) ∧ z ∈ B ) → z ∈ ( F " ( A ∩ dom F ) ) ) ;;
	step 9 : wff = fvelima () |- ( ( Fun F ∧ z ∈ ( F " ( A ∩ dom F ) ) ) → ∃ w ∈ ( A ∩ dom F ) ( F ` w ) = z ) ;;
	step 10 : wff = ex (step 9) |- ( Fun F → ( z ∈ ( F " ( A ∩ dom F ) ) → ∃ w ∈ ( A ∩ dom F ) ( F ` w ) = z ) ) ;;
	step 11 : wff = adantr (step 10) |- ( ( Fun F ∧ z ∈ B ) → ( z ∈ ( F " ( A ∩ dom F ) ) → ∃ w ∈ ( A ∩ dom F ) ( F ` w ) = z ) ) ;;
	step 12 : wff = eleq1a () |- ( z ∈ B → ( ( F ` w ) = z → ( F ` w ) ∈ B ) ) ;;
	step 13 : wff = anim2d (step 12) |- ( z ∈ B → ( ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) = z ) → ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) ∈ B ) ) ) ;;
	step 14 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 15 : wff = eleq1d (step 14) |- ( y = w → ( ( F ` y ) ∈ B ↔ ( F ` w ) ∈ B ) ) ;;
	step 16 : wff = elrab (step 15) |- ( w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ↔ ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) ∈ B ) ) ;;
	step 17 : wff = syl6ibr (step 13, step 16) |- ( z ∈ B → ( ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) = z ) → w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ;;
	step 18 : wff = simpr () |- ( ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) = z ) → ( F ` w ) = z ) ;;
	step 19 : wff = a1i (step 18) |- ( z ∈ B → ( ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) = z ) → ( F ` w ) = z ) ) ;;
	step 20 : wff = jcad (step 17, step 19) |- ( z ∈ B → ( ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) = z ) → ( w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ∧ ( F ` w ) = z ) ) ) ;;
	step 21 : wff = reximdv2 (step 20) |- ( z ∈ B → ( ∃ w ∈ ( A ∩ dom F ) ( F ` w ) = z → ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 22 : wff = adantl (step 21) |- ( ( Fun F ∧ z ∈ B ) → ( ∃ w ∈ ( A ∩ dom F ) ( F ` w ) = z → ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 23 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 24 : wff = ssrab2 () |- { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ ( A ∩ dom F ) ;;
	step 25 : wff = inss2 () |- ( A ∩ dom F ) ⊆ dom F ;;
	step 26 : wff = sstri (step 24, step 25) |- { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ dom F ;;
	step 27 : wff = fvelimab () |- ( ( F Fn dom F ∧ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ dom F ) → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ↔ ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 28 : wff = mpan2 (step 26, step 27) |- ( F Fn dom F → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ↔ ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 29 : wff = sylbi (step 23, step 28) |- ( Fun F → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ↔ ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 30 : wff = adantr (step 29) |- ( ( Fun F ∧ z ∈ B ) → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ↔ ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 31 : wff = sylibrd (step 22, step 30) |- ( ( Fun F ∧ z ∈ B ) → ( ∃ w ∈ ( A ∩ dom F ) ( F ` w ) = z → z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ;;
	step 32 : wff = syld (step 11, step 31) |- ( ( Fun F ∧ z ∈ B ) → ( z ∈ ( F " ( A ∩ dom F ) ) → z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ;;
	step 33 : wff = adantlr (step 32) |- ( ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) ∧ z ∈ B ) → ( z ∈ ( F " ( A ∩ dom F ) ) → z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ;;
	step 34 : wff = mpd (step 8, step 33) |- ( ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) ∧ z ∈ B ) → z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ;;
	step 35 : wff = ex (step 34) |- ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) → ( z ∈ B → z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ;;
	step 36 : wff = fvelima () |- ( ( Fun F ∧ z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) → ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ;;
	step 37 : wff = ex (step 36) |- ( Fun F → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) → ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z ) ) ;;
	step 38 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 39 : wff = eleq1d (step 38) |- ( y = w → ( ( F ` y ) ∈ B ↔ ( F ` w ) ∈ B ) ) ;;
	step 40 : wff = elrab (step 39) |- ( w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ↔ ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) ∈ B ) ) ;;
	step 41 : wff = eleq1 () |- ( ( F ` w ) = z → ( ( F ` w ) ∈ B ↔ z ∈ B ) ) ;;
	step 42 : wff = biimpcd (step 41) |- ( ( F ` w ) ∈ B → ( ( F ` w ) = z → z ∈ B ) ) ;;
	step 43 : wff = adantl (step 42) |- ( ( w ∈ ( A ∩ dom F ) ∧ ( F ` w ) ∈ B ) → ( ( F ` w ) = z → z ∈ B ) ) ;;
	step 44 : wff = sylbi (step 40, step 43) |- ( w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } → ( ( F ` w ) = z → z ∈ B ) ) ;;
	step 45 : wff = rexlimiv (step 44) |- ( ∃ w ∈ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ( F ` w ) = z → z ∈ B ) ;;
	step 46 : wff = syl6 (step 37, step 45) |- ( Fun F → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) → z ∈ B ) ) ;;
	step 47 : wff = adantr (step 46) |- ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) → ( z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) → z ∈ B ) ) ;;
	step 48 : wff = impbid (step 35, step 47) |- ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) → ( z ∈ B ↔ z ∈ ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ;;
	step 49 : wff = eqrdv (step 48) |- ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) → B = ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ;;
	step 50 : wff = inex1 (hyp 1) |- ( A ∩ dom F ) ∈ _V ;;
	step 51 : wff = rabex (step 50) |- { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ∈ _V ;;
	step 52 : wff = sseq1 () |- ( x = { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } → ( x ⊆ ( A ∩ dom F ) ↔ { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ ( A ∩ dom F ) ) ) ;;
	step 53 : wff = imaeq2 () |- ( x = { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } → ( F " x ) = ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ;;
	step 54 : wff = eqeq2d (step 53) |- ( x = { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } → ( B = ( F " x ) ↔ B = ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ;;
	step 55 : wff = anbi12d (step 52, step 54) |- ( x = { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } → ( ( x ⊆ ( A ∩ dom F ) ∧ B = ( F " x ) ) ↔ ( { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ ( A ∩ dom F ) ∧ B = ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) ) ) ;;
	step 56 : wff = spcev (step 51, step 55) |- ( ( { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ⊆ ( A ∩ dom F ) ∧ B = ( F " { y ∈ ( A ∩ dom F ) | ( F ` y ) ∈ B } ) ) → ∃ x ( x ⊆ ( A ∩ dom F ) ∧ B = ( F " x ) ) ) ;;
	step 57 : wff = sylancr (step 6, step 49, step 56) |- ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) → ∃ x ( x ⊆ ( A ∩ dom F ) ∧ B = ( F " x ) ) ) ;;
	step 58 : wff = inss1 () |- ( A ∩ dom F ) ⊆ A ;;
	step 59 : wff = sstr () |- ( ( x ⊆ ( A ∩ dom F ) ∧ ( A ∩ dom F ) ⊆ A ) → x ⊆ A ) ;;
	step 60 : wff = mpan2 (step 58, step 59) |- ( x ⊆ ( A ∩ dom F ) → x ⊆ A ) ;;
	step 61 : wff = anim1i (step 60) |- ( ( x ⊆ ( A ∩ dom F ) ∧ B = ( F " x ) ) → ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
	step 62 : wff = eximi (step 61) |- ( ∃ x ( x ⊆ ( A ∩ dom F ) ∧ B = ( F " x ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
	step 63 : wff = syl (step 57, step 62) |- ( ( Fun F ∧ B ⊆ ( F " ( A ∩ dom F ) ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
	step 64 : wff = sylan2br (step 5, step 63) |- ( ( Fun F ∧ B ⊆ ( F " A ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
	qed prop 1 = step 64 ;;
}

/*The existence of a subimage.  (Contributed by FL, 15-Apr-2007.) */

theorem ssimaexg (x : set, A : class, B : class, C : class, F : class) disjointed(A x y, B x y, F x y) {
	prop 1 : wff = |- ( ( A ∈ C ∧ Fun F ∧ B ⊆ ( F " A ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
}

proof of ssimaexg {
	var y : set;;
	step 1 : wff = imaeq2 () |- ( y = A → ( F " y ) = ( F " A ) ) ;;
	step 2 : wff = sseq2d (step 1) |- ( y = A → ( B ⊆ ( F " y ) ↔ B ⊆ ( F " A ) ) ) ;;
	step 3 : wff = anbi2d (step 2) |- ( y = A → ( ( Fun F ∧ B ⊆ ( F " y ) ) ↔ ( Fun F ∧ B ⊆ ( F " A ) ) ) ) ;;
	step 4 : wff = sseq2 () |- ( y = A → ( x ⊆ y ↔ x ⊆ A ) ) ;;
	step 5 : wff = anbi1d (step 4) |- ( y = A → ( ( x ⊆ y ∧ B = ( F " x ) ) ↔ ( x ⊆ A ∧ B = ( F " x ) ) ) ) ;;
	step 6 : wff = exbidv (step 5) |- ( y = A → ( ∃ x ( x ⊆ y ∧ B = ( F " x ) ) ↔ ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ) ;;
	step 7 : wff = imbi12d (step 3, step 6) |- ( y = A → ( ( ( Fun F ∧ B ⊆ ( F " y ) ) → ∃ x ( x ⊆ y ∧ B = ( F " x ) ) ) ↔ ( ( Fun F ∧ B ⊆ ( F " A ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ) ) ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = ssimaex (step 8) |- ( ( Fun F ∧ B ⊆ ( F " y ) ) → ∃ x ( x ⊆ y ∧ B = ( F " x ) ) ) ;;
	step 10 : wff = vtoclg (step 7, step 9) |- ( A ∈ C → ( ( Fun F ∧ B ⊆ ( F " A ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ) ;;
	step 11 : wff = 3impib (step 10) |- ( ( A ∈ C ∧ Fun F ∧ B ⊆ ( F " A ) ) → ∃ x ( x ⊆ A ∧ B = ( F " x ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/*A simplified expression for the value of a function when we know it's a
     function.  (Contributed by NM, 22-May-1998.) */

theorem funfv (A : class, F : class)  {
	prop 1 : wff = |- ( Fun F → ( F ` A ) = ⋃ ( F " { A } ) ) ;;
}

proof of funfv {
	step 1 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 2 : wff = unisn (step 1) |- ⋃ { ( F ` A ) } = ( F ` A ) ;;
	step 3 : wff = eqid () |- dom F = dom F ;;
	step 4 : wff = df-fn () |- ( F Fn dom F ↔ ( Fun F ∧ dom F = dom F ) ) ;;
	step 5 : wff = mpbiran2 (step 3, step 4) |- ( F Fn dom F ↔ Fun F ) ;;
	step 6 : wff = fnsnfv () |- ( ( F Fn dom F ∧ A ∈ dom F ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 7 : wff = sylanbr (step 5, step 6) |- ( ( Fun F ∧ A ∈ dom F ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 8 : wff = unieqd (step 7) |- ( ( Fun F ∧ A ∈ dom F ) → ⋃ { ( F ` A ) } = ⋃ ( F " { A } ) ) ;;
	step 9 : wff = syl5eqr (step 2, step 8) |- ( ( Fun F ∧ A ∈ dom F ) → ( F ` A ) = ⋃ ( F " { A } ) ) ;;
	step 10 : wff = ex (step 9) |- ( Fun F → ( A ∈ dom F → ( F ` A ) = ⋃ ( F " { A } ) ) ) ;;
	step 11 : wff = ndmfv () |- ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ;;
	step 12 : wff = ndmima () |- ( ¬ A ∈ dom F → ( F " { A } ) = ∅ ) ;;
	step 13 : wff = unieqd (step 12) |- ( ¬ A ∈ dom F → ⋃ ( F " { A } ) = ⋃ ∅ ) ;;
	step 14 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 15 : wff = syl6eq (step 13, step 14) |- ( ¬ A ∈ dom F → ⋃ ( F " { A } ) = ∅ ) ;;
	step 16 : wff = eqtr4d (step 11, step 15) |- ( ¬ A ∈ dom F → ( F ` A ) = ⋃ ( F " { A } ) ) ;;
	step 17 : wff = pm2.61d1 (step 10, step 16) |- ( Fun F → ( F ` A ) = ⋃ ( F " { A } ) ) ;;
	qed prop 1 = step 17 ;;
}

/*The value of a function.  Definition of function value in [Enderton]
       p. 43.  (Contributed by NM, 22-May-1998.) */

theorem funfv2 (y : set, A : class, F : class) disjointed(y A, y F) {
	prop 1 : wff = |- ( Fun F → ( F ` A ) = ⋃ { y | A F y } ) ;;
}

proof of funfv2 {
	step 1 : wff = funfv () |- ( Fun F → ( F ` A ) = ⋃ ( F " { A } ) ) ;;
	step 2 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 3 : wff = relimasn () |- ( Rel F → ( F " { A } ) = { y | A F y } ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( Fun F → ( F " { A } ) = { y | A F y } ) ;;
	step 5 : wff = unieqd (step 4) |- ( Fun F → ⋃ ( F " { A } ) = ⋃ { y | A F y } ) ;;
	step 6 : wff = eqtrd (step 1, step 5) |- ( Fun F → ( F ` A ) = ⋃ { y | A F y } ) ;;
	qed prop 1 = step 6 ;;
}

/*The value of a function.  Version of ~ funfv2 using a bound-variable
       hypotheses instead of distinct variable conditions.  (Contributed by NM,
       19-Feb-2006.) */

theorem funfv2f (y : set, A : class, F : class) disjointed(w A, w F, w y) {
	hyp 1 : wff = |- F/_ y A ;;
	hyp 2 : wff = |- F/_ y F ;;
	-----------------------
	prop 1 : wff = |- ( Fun F → ( F ` A ) = ⋃ { y | A F y } ) ;;
}

proof of funfv2f {
	var w : set;;
	step 1 : wff = funfv2 () |- ( Fun F → ( F ` A ) = ⋃ { w | A F w } ) ;;
	step 2 : wff = nfcv () |- F/_ y w ;;
	step 3 : wff = nfbr (hyp 1, hyp 2, step 2) |- F/ y A F w ;;
	step 4 : wff = nfv () |- F/ w A F y ;;
	step 5 : wff = breq2 () |- ( w = y → ( A F w ↔ A F y ) ) ;;
	step 6 : wff = cbvab (step 3, step 4, step 5) |- { w | A F w } = { y | A F y } ;;
	step 7 : wff = unieqi (step 6) |- ⋃ { w | A F w } = ⋃ { y | A F y } ;;
	step 8 : wff = syl6eq (step 1, step 7) |- ( Fun F → ( F ` A ) = ⋃ { y | A F y } ) ;;
	qed prop 1 = step 8 ;;
}

/*Value of the union of two functions when the domains are separate.
     (Contributed by FL, 7-Nov-2011.) */

theorem fvun (A : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( F ∪ G ) ` A ) = ( ( F ` A ) ∪ ( G ` A ) ) ) ;;
}

proof of fvun {
	step 1 : wff = funun () |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → Fun ( F ∪ G ) ) ;;
	step 2 : wff = funfv () |- ( Fun ( F ∪ G ) → ( ( F ∪ G ) ` A ) = ⋃ ( ( F ∪ G ) " { A } ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( F ∪ G ) ` A ) = ⋃ ( ( F ∪ G ) " { A } ) ) ;;
	step 4 : wff = imaundir () |- ( ( F ∪ G ) " { A } ) = ( ( F " { A } ) ∪ ( G " { A } ) ) ;;
	step 5 : wff = a1i (step 4) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( F ∪ G ) " { A } ) = ( ( F " { A } ) ∪ ( G " { A } ) ) ) ;;
	step 6 : wff = unieqd (step 5) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ⋃ ( ( F ∪ G ) " { A } ) = ⋃ ( ( F " { A } ) ∪ ( G " { A } ) ) ) ;;
	step 7 : wff = uniun () |- ⋃ ( ( F " { A } ) ∪ ( G " { A } ) ) = ( ⋃ ( F " { A } ) ∪ ⋃ ( G " { A } ) ) ;;
	step 8 : wff = funfv () |- ( Fun F → ( F ` A ) = ⋃ ( F " { A } ) ) ;;
	step 9 : wff = eqcomd (step 8) |- ( Fun F → ⋃ ( F " { A } ) = ( F ` A ) ) ;;
	step 10 : wff = funfv () |- ( Fun G → ( G ` A ) = ⋃ ( G " { A } ) ) ;;
	step 11 : wff = eqcomd (step 10) |- ( Fun G → ⋃ ( G " { A } ) = ( G ` A ) ) ;;
	step 12 : wff = anim12i (step 9, step 11) |- ( ( Fun F ∧ Fun G ) → ( ⋃ ( F " { A } ) = ( F ` A ) ∧ ⋃ ( G " { A } ) = ( G ` A ) ) ) ;;
	step 13 : wff = adantr (step 12) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ⋃ ( F " { A } ) = ( F ` A ) ∧ ⋃ ( G " { A } ) = ( G ` A ) ) ) ;;
	step 14 : wff = uneq12 () |- ( ( ⋃ ( F " { A } ) = ( F ` A ) ∧ ⋃ ( G " { A } ) = ( G ` A ) ) → ( ⋃ ( F " { A } ) ∪ ⋃ ( G " { A } ) ) = ( ( F ` A ) ∪ ( G ` A ) ) ) ;;
	step 15 : wff = syl (step 13, step 14) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ⋃ ( F " { A } ) ∪ ⋃ ( G " { A } ) ) = ( ( F ` A ) ∪ ( G ` A ) ) ) ;;
	step 16 : wff = syl5eq (step 7, step 15) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ⋃ ( ( F " { A } ) ∪ ( G " { A } ) ) = ( ( F ` A ) ∪ ( G ` A ) ) ) ;;
	step 17 : wff = 3eqtrd (step 3, step 6, step 16) |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( F ∪ G ) ` A ) = ( ( F ` A ) ∪ ( G ` A ) ) ) ;;
	qed prop 1 = step 17 ;;
}

/*The value of a union when the argument is in the first domain.
       (Contributed by Scott Fenton, 29-Jun-2013.) */

theorem fvun1 (A : class, B : class, F : class, G : class, X : class) disjointed(A, B, X) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( ( F ∪ G ) ` X ) = ( F ` X ) ) ;;
}

proof of fvun1 {
	step 1 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 2 : wff = 3ad2ant1 (step 1) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → Fun F ) ;;
	step 3 : wff = fnfun () |- ( G Fn B → Fun G ) ;;
	step 4 : wff = 3ad2ant2 (step 3) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → Fun G ) ;;
	step 5 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 6 : wff = fndm () |- ( G Fn B → dom G = B ) ;;
	step 7 : wff = ineqan12d (step 5, step 6) |- ( ( F Fn A ∧ G Fn B ) → ( dom F ∩ dom G ) = ( A ∩ B ) ) ;;
	step 8 : wff = eqeq1d (step 7) |- ( ( F Fn A ∧ G Fn B ) → ( ( dom F ∩ dom G ) = ∅ ↔ ( A ∩ B ) = ∅ ) ) ;;
	step 9 : wff = biimprd (step 8) |- ( ( F Fn A ∧ G Fn B ) → ( ( A ∩ B ) = ∅ → ( dom F ∩ dom G ) = ∅ ) ) ;;
	step 10 : wff = adantrd (step 9) |- ( ( F Fn A ∧ G Fn B ) → ( ( ( A ∩ B ) = ∅ ∧ X ∈ A ) → ( dom F ∩ dom G ) = ∅ ) ) ;;
	step 11 : wff = 3impia (step 10) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( dom F ∩ dom G ) = ∅ ) ;;
	step 12 : wff = fvun () |- ( ( ( Fun F ∧ Fun G ) ∧ ( dom F ∩ dom G ) = ∅ ) → ( ( F ∪ G ) ` X ) = ( ( F ` X ) ∪ ( G ` X ) ) ) ;;
	step 13 : wff = syl21anc (step 2, step 4, step 11, step 12) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( ( F ∪ G ) ` X ) = ( ( F ` X ) ∪ ( G ` X ) ) ) ;;
	step 14 : wff = disjel () |- ( ( ( A ∩ B ) = ∅ ∧ X ∈ A ) → ¬ X ∈ B ) ;;
	step 15 : wff = adantl (step 14) |- ( ( G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ¬ X ∈ B ) ;;
	step 16 : wff = fndm () |- ( G Fn B → dom G = B ) ;;
	step 17 : wff = eleq2d (step 16) |- ( G Fn B → ( X ∈ dom G ↔ X ∈ B ) ) ;;
	step 18 : wff = adantr (step 17) |- ( ( G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( X ∈ dom G ↔ X ∈ B ) ) ;;
	step 19 : wff = mtbird (step 15, step 18) |- ( ( G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ¬ X ∈ dom G ) ;;
	step 20 : wff = 3adant1 (step 19) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ¬ X ∈ dom G ) ;;
	step 21 : wff = ndmfv () |- ( ¬ X ∈ dom G → ( G ` X ) = ∅ ) ;;
	step 22 : wff = syl (step 20, step 21) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( G ` X ) = ∅ ) ;;
	step 23 : wff = uneq2d (step 22) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( ( F ` X ) ∪ ( G ` X ) ) = ( ( F ` X ) ∪ ∅ ) ) ;;
	step 24 : wff = un0 () |- ( ( F ` X ) ∪ ∅ ) = ( F ` X ) ;;
	step 25 : wff = syl6eq (step 23, step 24) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( ( F ` X ) ∪ ( G ` X ) ) = ( F ` X ) ) ;;
	step 26 : wff = eqtrd (step 13, step 25) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ A ) ) → ( ( F ∪ G ) ` X ) = ( F ` X ) ) ;;
	qed prop 1 = step 26 ;;
}

/*The value of a union when the argument is in the second domain.
     (Contributed by Scott Fenton, 29-Jun-2013.) */

theorem fvun2 (A : class, B : class, F : class, G : class, X : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ B ) ) → ( ( F ∪ G ) ` X ) = ( G ` X ) ) ;;
}

proof of fvun2 {
	step 1 : wff = uncom () |- ( F ∪ G ) = ( G ∪ F ) ;;
	step 2 : wff = fveq1i (step 1) |- ( ( F ∪ G ) ` X ) = ( ( G ∪ F ) ` X ) ;;
	step 3 : wff = incom () |- ( A ∩ B ) = ( B ∩ A ) ;;
	step 4 : wff = eqeq1i (step 3) |- ( ( A ∩ B ) = ∅ ↔ ( B ∩ A ) = ∅ ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( ( A ∩ B ) = ∅ ∧ X ∈ B ) ↔ ( ( B ∩ A ) = ∅ ∧ X ∈ B ) ) ;;
	step 6 : wff = fvun1 () |- ( ( G Fn B ∧ F Fn A ∧ ( ( B ∩ A ) = ∅ ∧ X ∈ B ) ) → ( ( G ∪ F ) ` X ) = ( G ` X ) ) ;;
	step 7 : wff = syl3an3b (step 5, step 6) |- ( ( G Fn B ∧ F Fn A ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ B ) ) → ( ( G ∪ F ) ` X ) = ( G ` X ) ) ;;
	step 8 : wff = 3com12 (step 7) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ B ) ) → ( ( G ∪ F ) ` X ) = ( G ` X ) ) ;;
	step 9 : wff = syl5eq (step 2, step 8) |- ( ( F Fn A ∧ G Fn B ∧ ( ( A ∩ B ) = ∅ ∧ X ∈ B ) ) → ( ( F ∪ G ) ` X ) = ( G ` X ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Alternate definition of function value ~ df-fv that doesn't require
       dummy variables.  (Contributed by NM, 4-Aug-2010.) */

theorem dffv2 (A : class, F : class) disjointed(x y z A, x y z F) {
	prop 1 : wff = |- ( F ` A ) = ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
}

proof of dffv2 {
	var x : set, y : set, z : set;;
	step 1 : wff = snidb () |- ( A ∈ _V ↔ A ∈ { A } ) ;;
	step 2 : wff = fvres () |- ( A ∈ { A } → ( ( F ↾ { A } ) ` A ) = ( F ` A ) ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( A ∈ _V → ( ( F ↾ { A } ) ` A ) = ( F ` A ) ) ;;
	step 4 : wff = fvprc () |- ( ¬ A ∈ _V → ( ( F ↾ { A } ) ` A ) = ∅ ) ;;
	step 5 : wff = fvprc () |- ( ¬ A ∈ _V → ( F ` A ) = ∅ ) ;;
	step 6 : wff = eqtr4d (step 4, step 5) |- ( ¬ A ∈ _V → ( ( F ↾ { A } ) ` A ) = ( F ` A ) ) ;;
	step 7 : wff = pm2.61i (step 3, step 6) |- ( ( F ↾ { A } ) ` A ) = ( F ` A ) ;;
	step 8 : wff = funfv () |- ( Fun ( F ↾ { A } ) → ( ( F ↾ { A } ) ` A ) = ⋃ ( ( F ↾ { A } ) " { A } ) ) ;;
	step 9 : wff = df-fun () |- ( Fun ( F ↾ { A } ) ↔ ( Rel ( F ↾ { A } ) ∧ ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ⊆ _I ) ) ;;
	step 10 : wff = simprbi (step 9) |- ( Fun ( F ↾ { A } ) → ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ⊆ _I ) ;;
	step 11 : wff = ssdif0 () |- ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ⊆ _I ↔ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) = ∅ ) ;;
	step 12 : wff = sylib (step 10, step 11) |- ( Fun ( F ↾ { A } ) → ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) = ∅ ) ;;
	step 13 : wff = unieqd (step 12) |- ( Fun ( F ↾ { A } ) → ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) = ⋃ ∅ ) ;;
	step 14 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 15 : wff = syl6eq (step 13, step 14) |- ( Fun ( F ↾ { A } ) → ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) = ∅ ) ;;
	step 16 : wff = unieqd (step 15) |- ( Fun ( F ↾ { A } ) → ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) = ⋃ ∅ ) ;;
	step 17 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 18 : wff = syl6eq (step 16, step 17) |- ( Fun ( F ↾ { A } ) → ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) = ∅ ) ;;
	step 19 : wff = difeq2d (step 18) |- ( Fun ( F ↾ { A } ) → ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ( ( F " { A } ) ∖ ∅ ) ) ;;
	step 20 : wff = resima () |- ( ( F ↾ { A } ) " { A } ) = ( F " { A } ) ;;
	step 21 : wff = dif0 () |- ( ( F " { A } ) ∖ ∅ ) = ( F " { A } ) ;;
	step 22 : wff = eqtr4i (step 20, step 21) |- ( ( F ↾ { A } ) " { A } ) = ( ( F " { A } ) ∖ ∅ ) ;;
	step 23 : wff = syl6reqr (step 19, step 22) |- ( Fun ( F ↾ { A } ) → ( ( F ↾ { A } ) " { A } ) = ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 24 : wff = unieqd (step 23) |- ( Fun ( F ↾ { A } ) → ⋃ ( ( F ↾ { A } ) " { A } ) = ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 25 : wff = eqtrd (step 8, step 24) |- ( Fun ( F ↾ { A } ) → ( ( F ↾ { A } ) ` A ) = ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 26 : wff = syl5eqr (step 7, step 25) |- ( Fun ( F ↾ { A } ) → ( F ` A ) = ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 27 : wff = nfunsn () |- ( ¬ Fun ( F ↾ { A } ) → ( F ` A ) = ∅ ) ;;
	step 28 : wff = relres () |- Rel ( F ↾ { A } ) ;;
	step 29 : wff = dffun3 () |- ( Fun ( F ↾ { A } ) ↔ ( Rel ( F ↾ { A } ) ∧ ∀ x ∃ y ∀ z ( x ( F ↾ { A } ) z → z = y ) ) ) ;;
	step 30 : wff = mpbiran (step 28, step 29) |- ( Fun ( F ↾ { A } ) ↔ ∀ x ∃ y ∀ z ( x ( F ↾ { A } ) z → z = y ) ) ;;
	step 31 : wff = iman () |- ( ( x ( F ↾ { A } ) z → z = y ) ↔ ¬ ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 32 : wff = albii (step 31) |- ( ∀ z ( x ( F ↾ { A } ) z → z = y ) ↔ ∀ z ¬ ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 33 : wff = alnex () |- ( ∀ z ¬ ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ↔ ¬ ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 34 : wff = bitri (step 32, step 33) |- ( ∀ z ( x ( F ↾ { A } ) z → z = y ) ↔ ¬ ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 35 : wff = exbii (step 34) |- ( ∃ y ∀ z ( x ( F ↾ { A } ) z → z = y ) ↔ ∃ y ¬ ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 36 : wff = exnal () |- ( ∃ y ¬ ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ↔ ¬ ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 37 : wff = bitri (step 35, step 36) |- ( ∃ y ∀ z ( x ( F ↾ { A } ) z → z = y ) ↔ ¬ ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 38 : wff = albii (step 37) |- ( ∀ x ∃ y ∀ z ( x ( F ↾ { A } ) z → z = y ) ↔ ∀ x ¬ ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 39 : wff = alnex () |- ( ∀ x ¬ ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ↔ ¬ ∃ x ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 40 : wff = 3bitrri (step 30, step 38, step 39) |- ( ¬ ∃ x ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ↔ Fun ( F ↾ { A } ) ) ;;
	step 41 : wff = con1bii (step 40) |- ( ¬ Fun ( F ↾ { A } ) ↔ ∃ x ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 42 : wff = sp () |- ( ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) → ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 43 : wff = eximi (step 42) |- ( ∃ x ∀ y ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) → ∃ x ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 44 : wff = sylbi (step 41, step 43) |- ( ¬ Fun ( F ↾ { A } ) → ∃ x ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 45 : wff = snssi () |- ( A ∈ dom ( F ↾ { A } ) → { A } ⊆ dom ( F ↾ { A } ) ) ;;
	step 46 : wff = residm () |- ( ( F ↾ { A } ) ↾ { A } ) = ( F ↾ { A } ) ;;
	step 47 : wff = dmeqi (step 46) |- dom ( ( F ↾ { A } ) ↾ { A } ) = dom ( F ↾ { A } ) ;;
	step 48 : wff = ssdmres () |- ( { A } ⊆ dom ( F ↾ { A } ) ↔ dom ( ( F ↾ { A } ) ↾ { A } ) = { A } ) ;;
	step 49 : wff = biimpi (step 48) |- ( { A } ⊆ dom ( F ↾ { A } ) → dom ( ( F ↾ { A } ) ↾ { A } ) = { A } ) ;;
	step 50 : wff = syl5eqr (step 47, step 49) |- ( { A } ⊆ dom ( F ↾ { A } ) → dom ( F ↾ { A } ) = { A } ) ;;
	step 51 : wff = syl (step 45, step 50) |- ( A ∈ dom ( F ↾ { A } ) → dom ( F ↾ { A } ) = { A } ) ;;
	step 52 : wff = vex () |- x ∈ _V ;;
	step 53 : wff = vex () |- z ∈ _V ;;
	step 54 : wff = breldm (step 52, step 53) |- ( x ( F ↾ { A } ) z → x ∈ dom ( F ↾ { A } ) ) ;;
	step 55 : wff = eleq2 () |- ( dom ( F ↾ { A } ) = { A } → ( x ∈ dom ( F ↾ { A } ) ↔ x ∈ { A } ) ) ;;
	step 56 : wff = elsn () |- ( x ∈ { A } ↔ x = A ) ;;
	step 57 : wff = syl6bb (step 55, step 56) |- ( dom ( F ↾ { A } ) = { A } → ( x ∈ dom ( F ↾ { A } ) ↔ x = A ) ) ;;
	step 58 : wff = biimpa (step 57) |- ( ( dom ( F ↾ { A } ) = { A } ∧ x ∈ dom ( F ↾ { A } ) ) → x = A ) ;;
	step 59 : wff = syl2an (step 51, step 54, step 58) |- ( ( A ∈ dom ( F ↾ { A } ) ∧ x ( F ↾ { A } ) z ) → x = A ) ;;
	step 60 : wff = breq1d (step 59) |- ( ( A ∈ dom ( F ↾ { A } ) ∧ x ( F ↾ { A } ) z ) → ( x ( F ↾ { A } ) z ↔ A ( F ↾ { A } ) z ) ) ;;
	step 61 : wff = biimpd (step 60) |- ( ( A ∈ dom ( F ↾ { A } ) ∧ x ( F ↾ { A } ) z ) → ( x ( F ↾ { A } ) z → A ( F ↾ { A } ) z ) ) ;;
	step 62 : wff = ex (step 61) |- ( A ∈ dom ( F ↾ { A } ) → ( x ( F ↾ { A } ) z → ( x ( F ↾ { A } ) z → A ( F ↾ { A } ) z ) ) ) ;;
	step 63 : wff = pm2.43d (step 62) |- ( A ∈ dom ( F ↾ { A } ) → ( x ( F ↾ { A } ) z → A ( F ↾ { A } ) z ) ) ;;
	step 64 : wff = anim1d (step 63) |- ( A ∈ dom ( F ↾ { A } ) → ( ( x ( F ↾ { A } ) z ∧ ¬ z = y ) → ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ) ) ;;
	step 65 : wff = eximdv (step 64) |- ( A ∈ dom ( F ↾ { A } ) → ( ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) → ∃ z ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ) ) ;;
	step 66 : wff = exlimdv (step 65) |- ( A ∈ dom ( F ↾ { A } ) → ( ∃ x ∃ z ( x ( F ↾ { A } ) z ∧ ¬ z = y ) → ∃ z ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ) ) ;;
	step 67 : wff = mpan9 (step 44, step 66) |- ( ( ¬ Fun ( F ↾ { A } ) ∧ A ∈ dom ( F ↾ { A } ) ) → ∃ z ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ) ;;
	step 68 : wff = resima () |- ( ( F ↾ { A } ) " { A } ) = ( F " { A } ) ;;
	step 69 : wff = eleq2i (step 68) |- ( y ∈ ( ( F ↾ { A } ) " { A } ) ↔ y ∈ ( F " { A } ) ) ;;
	step 70 : wff = elimasni () |- ( y ∈ ( ( F ↾ { A } ) " { A } ) → A ( F ↾ { A } ) y ) ;;
	step 71 : wff = sylbir (step 69, step 70) |- ( y ∈ ( F " { A } ) → A ( F ↾ { A } ) y ) ;;
	step 72 : wff = vex () |- y ∈ _V ;;
	step 73 : wff = vex () |- z ∈ _V ;;
	step 74 : wff = uniop (step 72, step 73) |- ⋃ 〈 y , z 〉 = { y , z } ;;
	step 75 : wff = opex () |- 〈 y , z 〉 ∈ _V ;;
	step 76 : wff = unisn (step 75) |- ⋃ { 〈 y , z 〉 } = 〈 y , z 〉 ;;
	step 77 : wff = vex () |- y ∈ _V ;;
	step 78 : wff = relres () |- Rel ( F ↾ { A } ) ;;
	step 79 : wff = brrelexi (step 78) |- ( A ( F ↾ { A } ) z → A ∈ _V ) ;;
	step 80 : wff = brcnvg () |- ( ( y ∈ _V ∧ A ∈ _V ) → ( y ⁻¹ ( F ↾ { A } ) A ↔ A ( F ↾ { A } ) y ) ) ;;
	step 81 : wff = sylancr (step 77, step 79, step 80) |- ( A ( F ↾ { A } ) z → ( y ⁻¹ ( F ↾ { A } ) A ↔ A ( F ↾ { A } ) y ) ) ;;
	step 82 : wff = biimpar (step 81) |- ( ( A ( F ↾ { A } ) z ∧ A ( F ↾ { A } ) y ) → y ⁻¹ ( F ↾ { A } ) A ) ;;
	step 83 : wff = relres () |- Rel ( F ↾ { A } ) ;;
	step 84 : wff = brrelexi (step 83) |- ( A ( F ↾ { A } ) z → A ∈ _V ) ;;
	step 85 : wff = adantl (step 84) |- ( ( y ⁻¹ ( F ↾ { A } ) A ∧ A ( F ↾ { A } ) z ) → A ∈ _V ) ;;
	step 86 : wff = breq2 () |- ( x = A → ( y ⁻¹ ( F ↾ { A } ) x ↔ y ⁻¹ ( F ↾ { A } ) A ) ) ;;
	step 87 : wff = breq1 () |- ( x = A → ( x ( F ↾ { A } ) z ↔ A ( F ↾ { A } ) z ) ) ;;
	step 88 : wff = anbi12d (step 86, step 87) |- ( x = A → ( ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ↔ ( y ⁻¹ ( F ↾ { A } ) A ∧ A ( F ↾ { A } ) z ) ) ) ;;
	step 89 : wff = rspcev (step 88) |- ( ( A ∈ _V ∧ ( y ⁻¹ ( F ↾ { A } ) A ∧ A ( F ↾ { A } ) z ) ) → ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 90 : wff = mpancom (step 85, step 89) |- ( ( y ⁻¹ ( F ↾ { A } ) A ∧ A ( F ↾ { A } ) z ) → ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 91 : wff = ancoms (step 90) |- ( ( A ( F ↾ { A } ) z ∧ y ⁻¹ ( F ↾ { A } ) A ) → ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 92 : wff = syldan (step 82, step 91) |- ( ( A ( F ↾ { A } ) z ∧ A ( F ↾ { A } ) y ) → ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 93 : wff = anim1i (step 92) |- ( ( ( A ( F ↾ { A } ) z ∧ A ( F ↾ { A } ) y ) ∧ ¬ z = y ) → ( ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ∧ ¬ z = y ) ) ;;
	step 94 : wff = an32s (step 93) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → ( ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ∧ ¬ z = y ) ) ;;
	step 95 : wff = eldif () |- ( 〈 y , z 〉 ∈ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ↔ ( 〈 y , z 〉 ∈ ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∧ ¬ 〈 y , z 〉 ∈ _I ) ) ;;
	step 96 : wff = rexv () |- ( ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ↔ ∃ x ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 97 : wff = vex () |- y ∈ _V ;;
	step 98 : wff = vex () |- z ∈ _V ;;
	step 99 : wff = brco (step 97, step 98) |- ( y ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) z ↔ ∃ x ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 100 : wff = df-br () |- ( y ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) z ↔ 〈 y , z 〉 ∈ ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ) ;;
	step 101 : wff = 3bitr2ri (step 96, step 99, step 100) |- ( 〈 y , z 〉 ∈ ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ↔ ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ) ;;
	step 102 : wff = vex () |- z ∈ _V ;;
	step 103 : wff = ideq (step 102) |- ( y _I z ↔ y = z ) ;;
	step 104 : wff = df-br () |- ( y _I z ↔ 〈 y , z 〉 ∈ _I ) ;;
	step 105 : wff = equcom () |- ( y = z ↔ z = y ) ;;
	step 106 : wff = 3bitr3i (step 103, step 104, step 105) |- ( 〈 y , z 〉 ∈ _I ↔ z = y ) ;;
	step 107 : wff = notbii (step 106) |- ( ¬ 〈 y , z 〉 ∈ _I ↔ ¬ z = y ) ;;
	step 108 : wff = anbi12i (step 101, step 107) |- ( ( 〈 y , z 〉 ∈ ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∧ ¬ 〈 y , z 〉 ∈ _I ) ↔ ( ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ∧ ¬ z = y ) ) ;;
	step 109 : wff = bitr2i (step 95, step 108) |- ( ( ∃ x ∈ _V ( y ⁻¹ ( F ↾ { A } ) x ∧ x ( F ↾ { A } ) z ) ∧ ¬ z = y ) ↔ 〈 y , z 〉 ∈ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 110 : wff = sylib (step 94, step 109) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → 〈 y , z 〉 ∈ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 111 : wff = snssi () |- ( 〈 y , z 〉 ∈ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) → { 〈 y , z 〉 } ⊆ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 112 : wff = uniss () |- ( { 〈 y , z 〉 } ⊆ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) → ⋃ { 〈 y , z 〉 } ⊆ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 113 : wff = 3syl (step 110, step 111, step 112) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → ⋃ { 〈 y , z 〉 } ⊆ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 114 : wff = syl5eqssr (step 76, step 113) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → 〈 y , z 〉 ⊆ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 115 : wff = uniss () |- ( 〈 y , z 〉 ⊆ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) → ⋃ 〈 y , z 〉 ⊆ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 116 : wff = syl (step 114, step 115) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → ⋃ 〈 y , z 〉 ⊆ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 117 : wff = syl5eqssr (step 74, step 116) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → { y , z } ⊆ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 118 : wff = vex () |- y ∈ _V ;;
	step 119 : wff = vex () |- z ∈ _V ;;
	step 120 : wff = prss (step 118, step 119) |- ( ( y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ∧ z ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ↔ { y , z } ⊆ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 121 : wff = sylibr (step 117, step 120) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → ( y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ∧ z ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 122 : wff = simpld (step 121) |- ( ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) ∧ A ( F ↾ { A } ) y ) → y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 123 : wff = ex (step 122) |- ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) → ( A ( F ↾ { A } ) y → y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 124 : wff = syl5 (step 71, step 123) |- ( ( A ( F ↾ { A } ) z ∧ ¬ z = y ) → ( y ∈ ( F " { A } ) → y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 125 : wff = exlimiv (step 124) |- ( ∃ z ( A ( F ↾ { A } ) z ∧ ¬ z = y ) → ( y ∈ ( F " { A } ) → y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 126 : wff = syl (step 67, step 125) |- ( ( ¬ Fun ( F ↾ { A } ) ∧ A ∈ dom ( F ↾ { A } ) ) → ( y ∈ ( F " { A } ) → y ∈ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 127 : wff = ssrdv (step 126) |- ( ( ¬ Fun ( F ↾ { A } ) ∧ A ∈ dom ( F ↾ { A } ) ) → ( F " { A } ) ⊆ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	step 128 : wff = ssdif0 () |- ( ( F " { A } ) ⊆ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ↔ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ) ;;
	step 129 : wff = sylib (step 127, step 128) |- ( ( ¬ Fun ( F ↾ { A } ) ∧ A ∈ dom ( F ↾ { A } ) ) → ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ) ;;
	step 130 : wff = ex (step 129) |- ( ¬ Fun ( F ↾ { A } ) → ( A ∈ dom ( F ↾ { A } ) → ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ) ) ;;
	step 131 : wff = resima () |- ( ( F ↾ { A } ) " { A } ) = ( F " { A } ) ;;
	step 132 : wff = ndmima () |- ( ¬ A ∈ dom ( F ↾ { A } ) → ( ( F ↾ { A } ) " { A } ) = ∅ ) ;;
	step 133 : wff = syl5eqr (step 131, step 132) |- ( ¬ A ∈ dom ( F ↾ { A } ) → ( F " { A } ) = ∅ ) ;;
	step 134 : wff = difeq1d (step 133) |- ( ¬ A ∈ dom ( F ↾ { A } ) → ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ( ∅ ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 135 : wff = 0dif () |- ( ∅ ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ;;
	step 136 : wff = syl6eq (step 134, step 135) |- ( ¬ A ∈ dom ( F ↾ { A } ) → ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ) ;;
	step 137 : wff = pm2.61d1 (step 130, step 136) |- ( ¬ Fun ( F ↾ { A } ) → ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ) ;;
	step 138 : wff = unieqd (step 137) |- ( ¬ Fun ( F ↾ { A } ) → ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ⋃ ∅ ) ;;
	step 139 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 140 : wff = syl6eq (step 138, step 139) |- ( ¬ Fun ( F ↾ { A } ) → ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) = ∅ ) ;;
	step 141 : wff = eqtr4d (step 27, step 140) |- ( ¬ Fun ( F ↾ { A } ) → ( F ` A ) = ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ) ;;
	step 142 : wff = pm2.61i (step 26, step 141) |- ( F ` A ) = ⋃ ( ( F " { A } ) ∖ ⋃ ⋃ ( ( ( F ↾ { A } ) ∘ ⁻¹ ( F ↾ { A } ) ) ∖ _I ) ) ;;
	qed prop 1 = step 142 ;;
}

/*Domains of a function composition.  (Contributed by NM, 27-Jan-1997.) */

theorem dmfco (A : class, F : class, G : class) disjointed(x y A, x y F, x y G, x) {
	prop 1 : wff = |- ( ( Fun G ∧ A ∈ dom G ) → ( A ∈ dom ( F ∘ G ) ↔ ( G ` A ) ∈ dom F ) ) ;;
}

proof of dmfco {
	var x : set, y : set;;
	step 1 : wff = eldm2g () |- ( A ∈ dom G → ( A ∈ dom ( F ∘ G ) ↔ ∃ y 〈 A , y 〉 ∈ ( F ∘ G ) ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = opelco2g () |- ( ( A ∈ dom G ∧ y ∈ _V ) → ( 〈 A , y 〉 ∈ ( F ∘ G ) ↔ ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 4 : wff = mpan2 (step 2, step 3) |- ( A ∈ dom G → ( 〈 A , y 〉 ∈ ( F ∘ G ) ↔ ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 5 : wff = exbidv (step 4) |- ( A ∈ dom G → ( ∃ y 〈 A , y 〉 ∈ ( F ∘ G ) ↔ ∃ y ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 6 : wff = bitrd (step 1, step 5) |- ( A ∈ dom G → ( A ∈ dom ( F ∘ G ) ↔ ∃ y ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 7 : wff = adantl (step 6) |- ( ( Fun G ∧ A ∈ dom G ) → ( A ∈ dom ( F ∘ G ) ↔ ∃ y ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 8 : wff = fvex () |- ( G ` A ) ∈ _V ;;
	step 9 : wff = eldm2 (step 8) |- ( ( G ` A ) ∈ dom F ↔ ∃ y 〈 ( G ` A ) , y 〉 ∈ F ) ;;
	step 10 : wff = fvex () |- ( G ` A ) ∈ _V ;;
	step 11 : wff = opeq1 () |- ( x = ( G ` A ) → 〈 x , y 〉 = 〈 ( G ` A ) , y 〉 ) ;;
	step 12 : wff = eleq1d (step 11) |- ( x = ( G ` A ) → ( 〈 x , y 〉 ∈ F ↔ 〈 ( G ` A ) , y 〉 ∈ F ) ) ;;
	step 13 : wff = ceqsexv (step 10, step 12) |- ( ∃ x ( x = ( G ` A ) ∧ 〈 x , y 〉 ∈ F ) ↔ 〈 ( G ` A ) , y 〉 ∈ F ) ;;
	step 14 : wff = eqcom () |- ( x = ( G ` A ) ↔ ( G ` A ) = x ) ;;
	step 15 : wff = funopfvb () |- ( ( Fun G ∧ A ∈ dom G ) → ( ( G ` A ) = x ↔ 〈 A , x 〉 ∈ G ) ) ;;
	step 16 : wff = syl5bb (step 14, step 15) |- ( ( Fun G ∧ A ∈ dom G ) → ( x = ( G ` A ) ↔ 〈 A , x 〉 ∈ G ) ) ;;
	step 17 : wff = anbi1d (step 16) |- ( ( Fun G ∧ A ∈ dom G ) → ( ( x = ( G ` A ) ∧ 〈 x , y 〉 ∈ F ) ↔ ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 18 : wff = exbidv (step 17) |- ( ( Fun G ∧ A ∈ dom G ) → ( ∃ x ( x = ( G ` A ) ∧ 〈 x , y 〉 ∈ F ) ↔ ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 19 : wff = syl5bbr (step 13, step 18) |- ( ( Fun G ∧ A ∈ dom G ) → ( 〈 ( G ` A ) , y 〉 ∈ F ↔ ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 20 : wff = exbidv (step 19) |- ( ( Fun G ∧ A ∈ dom G ) → ( ∃ y 〈 ( G ` A ) , y 〉 ∈ F ↔ ∃ y ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 21 : wff = syl5bb (step 9, step 20) |- ( ( Fun G ∧ A ∈ dom G ) → ( ( G ` A ) ∈ dom F ↔ ∃ y ∃ x ( 〈 A , x 〉 ∈ G ∧ 〈 x , y 〉 ∈ F ) ) ) ;;
	step 22 : wff = bitr4d (step 7, step 21) |- ( ( Fun G ∧ A ∈ dom G ) → ( A ∈ dom ( F ∘ G ) ↔ ( G ` A ) ∈ dom F ) ) ;;
	qed prop 1 = step 22 ;;
}

/*Value of a function composition.  Similar to second part of Theorem 3H
       of [Enderton] p. 47.  (Contributed by NM, 9-Oct-2004.)  (Proof shortened
       by Andrew Salmon, 22-Oct-2011.)  (Revised by Stefan O'Rear,
       16-Oct-2014.) */

theorem fvco2 (A : class, F : class, G : class, X : class) disjointed(x A, x F, x G, x X) {
	prop 1 : wff = |- ( ( G Fn A ∧ X ∈ A ) → ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ) ;;
}

proof of fvco2 {
	var x : set;;
	step 1 : wff = fnsnfv () |- ( ( G Fn A ∧ X ∈ A ) → { ( G ` X ) } = ( G " { X } ) ) ;;
	step 2 : wff = imaeq2d (step 1) |- ( ( G Fn A ∧ X ∈ A ) → ( F " { ( G ` X ) } ) = ( F " ( G " { X } ) ) ) ;;
	step 3 : wff = imaco () |- ( ( F ∘ G ) " { X } ) = ( F " ( G " { X } ) ) ;;
	step 4 : wff = syl6reqr (step 2, step 3) |- ( ( G Fn A ∧ X ∈ A ) → ( ( F ∘ G ) " { X } ) = ( F " { ( G ` X ) } ) ) ;;
	step 5 : wff = eleq2d (step 4) |- ( ( G Fn A ∧ X ∈ A ) → ( x ∈ ( ( F ∘ G ) " { X } ) ↔ x ∈ ( F " { ( G ` X ) } ) ) ) ;;
	step 6 : wff = iotabidv (step 5) |- ( ( G Fn A ∧ X ∈ A ) → ( iota x x ∈ ( ( F ∘ G ) " { X } ) ) = ( iota x x ∈ ( F " { ( G ` X ) } ) ) ) ;;
	step 7 : wff = dffv3 () |- ( ( F ∘ G ) ` X ) = ( iota x x ∈ ( ( F ∘ G ) " { X } ) ) ;;
	step 8 : wff = dffv3 () |- ( F ` ( G ` X ) ) = ( iota x x ∈ ( F " { ( G ` X ) } ) ) ;;
	step 9 : wff = 3eqtr4g (step 6, step 7, step 8) |- ( ( G Fn A ∧ X ∈ A ) → ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Value of a function composition.  Similar to Exercise 5 of [TakeutiZaring]
     p. 28.  (Contributed by NM, 22-Apr-2006.)  (Proof shortened by Mario
     Carneiro, 26-Dec-2014.) */

theorem fvco (A : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( Fun G ∧ A ∈ dom G ) → ( ( F ∘ G ) ` A ) = ( F ` ( G ` A ) ) ) ;;
}

proof of fvco {
	step 1 : wff = funfn () |- ( Fun G ↔ G Fn dom G ) ;;
	step 2 : wff = fvco2 () |- ( ( G Fn dom G ∧ A ∈ dom G ) → ( ( F ∘ G ) ` A ) = ( F ` ( G ` A ) ) ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( Fun G ∧ A ∈ dom G ) → ( ( F ∘ G ) ` A ) = ( F ` ( G ` A ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Value of a function composition.  (Contributed by NM, 3-Jan-2004.)
     (Revised by Mario Carneiro, 26-Dec-2014.) */

theorem fvco3 (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( G : A ⟶ B ∧ C ∈ A ) → ( ( F ∘ G ) ` C ) = ( F ` ( G ` C ) ) ) ;;
}

proof of fvco3 {
	step 1 : wff = ffn () |- ( G : A ⟶ B → G Fn A ) ;;
	step 2 : wff = fvco2 () |- ( ( G Fn A ∧ C ∈ A ) → ( ( F ∘ G ) ` C ) = ( F ` ( G ` C ) ) ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( G : A ⟶ B ∧ C ∈ A ) → ( ( F ∘ G ) ` C ) = ( F ` ( G ` C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Conditions for a composition to be expandable without conditions on the
       argument.  (Contributed by Stefan O'Rear, 31-Mar-2015.) */

theorem fvco4i (F : class, G : class, X : class)  {
	hyp 1 : wff = |- ∅ = ( F ` ∅ ) ;;
	hyp 2 : wff = |- Fun G ;;
	-----------------------
	prop 1 : wff = |- ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ;;
}

proof of fvco4i {
	step 1 : wff = funfn () |- ( Fun G ↔ G Fn dom G ) ;;
	step 2 : wff = mpbi (hyp 2, step 1) |- G Fn dom G ;;
	step 3 : wff = fvco2 () |- ( ( G Fn dom G ∧ X ∈ dom G ) → ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( X ∈ dom G → ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ) ;;
	step 5 : wff = dmcoss () |- dom ( F ∘ G ) ⊆ dom G ;;
	step 6 : wff = sseli (step 5) |- ( X ∈ dom ( F ∘ G ) → X ∈ dom G ) ;;
	step 7 : wff = con3i (step 6) |- ( ¬ X ∈ dom G → ¬ X ∈ dom ( F ∘ G ) ) ;;
	step 8 : wff = ndmfv () |- ( ¬ X ∈ dom ( F ∘ G ) → ( ( F ∘ G ) ` X ) = ∅ ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( ¬ X ∈ dom G → ( ( F ∘ G ) ` X ) = ∅ ) ;;
	step 10 : wff = ndmfv () |- ( ¬ X ∈ dom G → ( G ` X ) = ∅ ) ;;
	step 11 : wff = fveq2d (step 10) |- ( ¬ X ∈ dom G → ( F ` ( G ` X ) ) = ( F ` ∅ ) ) ;;
	step 12 : wff = 3eqtr4a (hyp 1, step 9, step 11) |- ( ¬ X ∈ dom G → ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ) ;;
	step 13 : wff = pm2.61i (step 4, step 12) |- ( ( F ∘ G ) ` X ) = ( F ` ( G ` X ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Value of a function given by ordered-pair class abstraction.
       (Contributed by NM, 6-Mar-1996.)  (Revised by Mario Carneiro,
       28-Apr-2015.) */

theorem fvopab3g (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y A, x y B, x y C, x y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( x ∈ C → ∃! y ph ) ;;
	hyp 4 : wff = |- F = { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( ( F ` A ) = B ↔ ch ) ) ;;
}

proof of fvopab3g {
	step 1 : wff = eleq1 () |- ( x = A → ( x ∈ C ↔ A ∈ C ) ) ;;
	step 2 : wff = anbi12d (step 1, hyp 1) |- ( x = A → ( ( x ∈ C ∧ ph ) ↔ ( A ∈ C ∧ ps ) ) ) ;;
	step 3 : wff = anbi2d (hyp 2) |- ( y = B → ( ( A ∈ C ∧ ps ) ↔ ( A ∈ C ∧ ch ) ) ) ;;
	step 4 : wff = opelopabg (step 2, step 3) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ↔ ( A ∈ C ∧ ch ) ) ) ;;
	step 5 : wff = fnopab (hyp 3, hyp 4) |- F Fn C ;;
	step 6 : wff = fnopfvb () |- ( ( F Fn C ∧ A ∈ C ) → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ F ) ) ;;
	step 7 : wff = mpan (step 5, step 6) |- ( A ∈ C → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ F ) ) ;;
	step 8 : wff = eleq2i (hyp 4) |- ( 〈 A , B 〉 ∈ F ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ;;
	step 9 : wff = syl6bb (step 7, step 8) |- ( A ∈ C → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ) ;;
	step 10 : wff = adantr (step 9) |- ( ( A ∈ C ∧ B ∈ D ) → ( ( F ` A ) = B ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ) ;;
	step 11 : wff = ibar () |- ( A ∈ C → ( ch ↔ ( A ∈ C ∧ ch ) ) ) ;;
	step 12 : wff = adantr (step 11) |- ( ( A ∈ C ∧ B ∈ D ) → ( ch ↔ ( A ∈ C ∧ ch ) ) ) ;;
	step 13 : wff = 3bitr4d (step 4, step 10, step 12) |- ( ( A ∈ C ∧ B ∈ D ) → ( ( F ` A ) = B ↔ ch ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Value of a function given by ordered-pair class abstraction.
       (Contributed by NM, 23-Oct-1999.) */

theorem fvopab3ig (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y A, x y B, x y C, x y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( x ∈ C → ∃* y ph ) ;;
	hyp 4 : wff = |- F = { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( ch → ( F ` A ) = B ) ) ;;
}

proof of fvopab3ig {
	step 1 : wff = eleq1 () |- ( x = A → ( x ∈ C ↔ A ∈ C ) ) ;;
	step 2 : wff = anbi12d (step 1, hyp 1) |- ( x = A → ( ( x ∈ C ∧ ph ) ↔ ( A ∈ C ∧ ps ) ) ) ;;
	step 3 : wff = anbi2d (hyp 2) |- ( y = B → ( ( A ∈ C ∧ ps ) ↔ ( A ∈ C ∧ ch ) ) ) ;;
	step 4 : wff = opelopabg (step 2, step 3) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ↔ ( A ∈ C ∧ ch ) ) ) ;;
	step 5 : wff = biimpar (step 4) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ( A ∈ C ∧ ch ) ) → 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ;;
	step 6 : wff = exp43 (step 5) |- ( A ∈ C → ( B ∈ D → ( A ∈ C → ( ch → 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ) ) ) ;;
	step 7 : wff = pm2.43a (step 6) |- ( A ∈ C → ( B ∈ D → ( ch → 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ) ) ;;
	step 8 : wff = imp (step 7) |- ( ( A ∈ C ∧ B ∈ D ) → ( ch → 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ) ) ;;
	step 9 : wff = fveq1i (hyp 4) |- ( F ` A ) = ( { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ` A ) ;;
	step 10 : wff = funopab () |- ( Fun { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ↔ ∀ x ∃* y ( x ∈ C ∧ ph ) ) ;;
	step 11 : wff = moanimv () |- ( ∃* y ( x ∈ C ∧ ph ) ↔ ( x ∈ C → ∃* y ph ) ) ;;
	step 12 : wff = mpbir (hyp 3, step 11) |- ∃* y ( x ∈ C ∧ ph ) ;;
	step 13 : wff = mpgbir (step 10, step 12) |- Fun { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ;;
	step 14 : wff = funopfv () |- ( Fun { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } → ( { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ` A ) = B ) ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } → ( { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } ` A ) = B ) ;;
	step 16 : wff = syl5eq (step 9, step 15) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( x ∈ C ∧ ph ) } → ( F ` A ) = B ) ;;
	step 17 : wff = syl6 (step 8, step 16) |- ( ( A ∈ C ∧ B ∈ D ) → ( ch → ( F ` A ) = B ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Value of a function given in maps-to notation.  (Contributed by NM,
       2-Oct-2007.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fvmptg (x : set, A : class, B : class, C : class, D : class, R : class, F : class) disjointed(x y A, y B, x C y, x D y) {
	hyp 1 : wff = |- ( x = A → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ D ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ D ∧ C ∈ R ) → ( F ` A ) = C ) ;;
}

proof of fvmptg {
	var y : set;;
	step 1 : wff = eqid () |- C = C ;;
	step 2 : wff = eqeq2d (hyp 1) |- ( x = A → ( y = B ↔ y = C ) ) ;;
	step 3 : wff = eqeq1 () |- ( y = C → ( y = C ↔ C = C ) ) ;;
	step 4 : wff = moeq () |- ∃* y y = B ;;
	step 5 : wff = a1i (step 4) |- ( x ∈ D → ∃* y y = B ) ;;
	step 6 : wff = df-mpt () |- ( x ∈ D ↦ B ) = { 〈 x , y 〉 | ( x ∈ D ∧ y = B ) } ;;
	step 7 : wff = eqtri (hyp 2, step 6) |- F = { 〈 x , y 〉 | ( x ∈ D ∧ y = B ) } ;;
	step 8 : wff = fvopab3ig (step 2, step 3, step 5, step 7) |- ( ( A ∈ D ∧ C ∈ R ) → ( C = C → ( F ` A ) = C ) ) ;;
	step 9 : wff = mpi (step 1, step 8) |- ( ( A ∈ D ∧ C ∈ R ) → ( F ` A ) = C ) ;;
	qed prop 1 = step 9 ;;
}

/*Value of a function given in maps-to notation.  (Contributed by Mario
       Carneiro, 23-Apr-2014.) */

theorem fvmpti (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x A, B, x C, x D) {
	hyp 1 : wff = |- ( x = A → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ D ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ D → ( F ` A ) = ( _I ` C ) ) ;;
}

proof of fvmpti {
	step 1 : wff = fvmptg (hyp 1, hyp 2) |- ( ( A ∈ D ∧ C ∈ _V ) → ( F ` A ) = C ) ;;
	step 2 : wff = fvi () |- ( C ∈ _V → ( _I ` C ) = C ) ;;
	step 3 : wff = adantl (step 2) |- ( ( A ∈ D ∧ C ∈ _V ) → ( _I ` C ) = C ) ;;
	step 4 : wff = eqtr4d (step 1, step 3) |- ( ( A ∈ D ∧ C ∈ _V ) → ( F ` A ) = ( _I ` C ) ) ;;
	step 5 : wff = eleq1d (hyp 1) |- ( x = A → ( B ∈ _V ↔ C ∈ _V ) ) ;;
	step 6 : wff = dmmpt (hyp 2) |- dom F = { x ∈ D | B ∈ _V } ;;
	step 7 : wff = elrab2 (step 5, step 6) |- ( A ∈ dom F ↔ ( A ∈ D ∧ C ∈ _V ) ) ;;
	step 8 : wff = baib (step 7) |- ( A ∈ D → ( A ∈ dom F ↔ C ∈ _V ) ) ;;
	step 9 : wff = notbid (step 8) |- ( A ∈ D → ( ¬ A ∈ dom F ↔ ¬ C ∈ _V ) ) ;;
	step 10 : wff = ndmfv () |- ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ;;
	step 11 : wff = syl6bir (step 9, step 10) |- ( A ∈ D → ( ¬ C ∈ _V → ( F ` A ) = ∅ ) ) ;;
	step 12 : wff = imp (step 11) |- ( ( A ∈ D ∧ ¬ C ∈ _V ) → ( F ` A ) = ∅ ) ;;
	step 13 : wff = fvprc () |- ( ¬ C ∈ _V → ( _I ` C ) = ∅ ) ;;
	step 14 : wff = adantl (step 13) |- ( ( A ∈ D ∧ ¬ C ∈ _V ) → ( _I ` C ) = ∅ ) ;;
	step 15 : wff = eqtr4d (step 12, step 14) |- ( ( A ∈ D ∧ ¬ C ∈ _V ) → ( F ` A ) = ( _I ` C ) ) ;;
	step 16 : wff = pm2.61dan (step 4, step 15) |- ( A ∈ D → ( F ` A ) = ( _I ` C ) ) ;;
	qed prop 1 = step 16 ;;
}

/*Value of a function given in maps-to notation.  (Contributed by NM,
         17-Aug-2011.) */

theorem fvmpt (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x A, B, x C, x D) {
	hyp 1 : wff = |- ( x = A → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ D ↦ B ) ;;
	hyp 3 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ D → ( F ` A ) = C ) ;;
}

proof of fvmpt {
	step 1 : wff = fvmptg (hyp 1, hyp 2) |- ( ( A ∈ D ∧ C ∈ _V ) → ( F ` A ) = C ) ;;
	step 2 : wff = mpan2 (hyp 3, step 1) |- ( A ∈ D → ( F ` A ) = C ) ;;
	qed prop 1 = step 2 ;;
}

/*Value of a function given in maps-to notation, using explicit class
       substitution.  (Contributed by Scott Fenton, 17-Jul-2013.)  (Revised by
       Mario Carneiro, 31-Aug-2015.) */

theorem fvmpts (x : set, A : class, B : class, C : class, F : class, V : class) disjointed(y A, y B, x y C) {
	hyp 1 : wff = |- F = ( x ∈ C ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ [_ A / x ]_ B ∈ V ) → ( F ` A ) = [_ A / x ]_ B ) ;;
}

proof of fvmpts {
	var y : set;;
	step 1 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ B = [_ A / x ]_ B ) ;;
	step 2 : wff = nfcv () |- F/_ y B ;;
	step 3 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 4 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 5 : wff = cbvmpt (step 2, step 3, step 4) |- ( x ∈ C ↦ B ) = ( y ∈ C ↦ [_ y / x ]_ B ) ;;
	step 6 : wff = eqtri (hyp 1, step 5) |- F = ( y ∈ C ↦ [_ y / x ]_ B ) ;;
	step 7 : wff = fvmptg (step 1, step 6) |- ( ( A ∈ C ∧ [_ A / x ]_ B ∈ V ) → ( F ` A ) = [_ A / x ]_ B ) ;;
	qed prop 1 = step 7 ;;
}

/*Value of a function given in maps-to notation, with a slightly
         different sethood condition.  (Contributed by Stefan O'Rear,
         30-Jan-2015.) */

theorem fvmpt3 (x : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(x A, x C, x D, x V) {
	hyp 1 : wff = |- ( x = A → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ D ↦ B ) ;;
	hyp 3 : wff = |- ( x ∈ D → B ∈ V ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ D → ( F ` A ) = C ) ;;
}

proof of fvmpt3 {
	step 1 : wff = eleq1d (hyp 1) |- ( x = A → ( B ∈ V ↔ C ∈ V ) ) ;;
	step 2 : wff = vtoclga (step 1, hyp 3) |- ( A ∈ D → C ∈ V ) ;;
	step 3 : wff = fvmptg (hyp 1, hyp 2) |- ( ( A ∈ D ∧ C ∈ V ) → ( F ` A ) = C ) ;;
	step 4 : wff = mpdan (step 2, step 3) |- ( A ∈ D → ( F ` A ) = C ) ;;
	qed prop 1 = step 4 ;;
}

/*Value of a function given in maps-to notation, with a slightly different
       sethood condition.  (Contributed by Mario Carneiro, 11-Sep-2015.) */

theorem fvmpt3i (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x A, x C, x D, x) {
	hyp 1 : wff = |- ( x = A → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ D ↦ B ) ;;
	hyp 3 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ D → ( F ` A ) = C ) ;;
}

proof of fvmpt3i {
	step 1 : wff = a1i (hyp 3) |- ( x ∈ D → B ∈ _V ) ;;
	step 2 : wff = fvmpt3 (hyp 1, hyp 2, step 1) |- ( A ∈ D → ( F ` A ) = C ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction version of ~ fvmpt .  (Contributed by Scott Fenton,
       18-Feb-2013.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fvmptd (ph : wff, x : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(x A, x C, x D, x ph) {
	hyp 1 : wff = |- ( ph → F = ( x ∈ D ↦ B ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B = C ) ;;
	hyp 3 : wff = |- ( ph → A ∈ D ) ;;
	hyp 4 : wff = |- ( ph → C ∈ V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F ` A ) = C ) ;;
}

proof of fvmptd {
	step 1 : wff = fveq1d (hyp 1) |- ( ph → ( F ` A ) = ( ( x ∈ D ↦ B ) ` A ) ) ;;
	step 2 : wff = csbied (hyp 3, hyp 2) |- ( ph → [_ A / x ]_ B = C ) ;;
	step 3 : wff = eqeltrd (step 2, hyp 4) |- ( ph → [_ A / x ]_ B ∈ V ) ;;
	step 4 : wff = eqid () |- ( x ∈ D ↦ B ) = ( x ∈ D ↦ B ) ;;
	step 5 : wff = fvmpts (step 4) |- ( ( A ∈ D ∧ [_ A / x ]_ B ∈ V ) → ( ( x ∈ D ↦ B ) ` A ) = [_ A / x ]_ B ) ;;
	step 6 : wff = syl2anc (hyp 3, step 3, step 5) |- ( ph → ( ( x ∈ D ↦ B ) ` A ) = [_ A / x ]_ B ) ;;
	step 7 : wff = csbied (hyp 3, hyp 2) |- ( ph → [_ A / x ]_ B = C ) ;;
	step 8 : wff = 3eqtrd (step 1, step 6, step 7) |- ( ph → ( F ` A ) = C ) ;;
	qed prop 1 = step 8 ;;
}

/*Value of a function given by the "maps to" notation.  (Contributed by
       Mario Carneiro, 23-Apr-2014.) */

theorem fvmpt2i (x : set, A : class, B : class, F : class) disjointed(x y A, y B, y, y F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A → ( F ` x ) = ( _I ` B ) ) ;;
}

proof of fvmpt2i {
	var y : set;;
	step 1 : wff = csbeq1 () |- ( y = x → [_ y / x ]_ B = [_ x / x ]_ B ) ;;
	step 2 : wff = csbid () |- [_ x / x ]_ B = B ;;
	step 3 : wff = syl6eq (step 1, step 2) |- ( y = x → [_ y / x ]_ B = B ) ;;
	step 4 : wff = nfcv () |- F/_ y B ;;
	step 5 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 6 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 7 : wff = cbvmpt (step 4, step 5, step 6) |- ( x ∈ A ↦ B ) = ( y ∈ A ↦ [_ y / x ]_ B ) ;;
	step 8 : wff = eqtri (hyp 1, step 7) |- F = ( y ∈ A ↦ [_ y / x ]_ B ) ;;
	step 9 : wff = fvmpti (step 3, step 8) |- ( x ∈ A → ( F ` x ) = ( _I ` B ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Value of a function given by the "maps to" notation.  (Contributed by
       FL, 21-Jun-2010.) */

theorem fvmpt2 (x : set, A : class, B : class, C : class, F : class) disjointed(x A, B, F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ A ∧ B ∈ C ) → ( F ` x ) = B ) ;;
}

proof of fvmpt2 {
	step 1 : wff = fvmpt2i (hyp 1) |- ( x ∈ A → ( F ` x ) = ( _I ` B ) ) ;;
	step 2 : wff = fvi () |- ( B ∈ C → ( _I ` B ) = B ) ;;
	step 3 : wff = sylan9eq (step 1, step 2) |- ( ( x ∈ A ∧ B ∈ C ) → ( F ` x ) = B ) ;;
	qed prop 1 = step 3 ;;
}

/*If all the values of the mapping are subsets of a class ` C ` , then so
       is any evaluation of the mapping, even if ` D ` is not in the base set
       ` A ` .  (Contributed by Mario Carneiro, 13-Feb-2015.) */

theorem fvmptss (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y A, y B, y D, y F, x y C) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A B ⊆ C → ( F ` D ) ⊆ C ) ;;
}

proof of fvmptss {
	var y : set;;
	step 1 : wff = dmmptss (hyp 1) |- dom F ⊆ A ;;
	step 2 : wff = sseli (step 1) |- ( D ∈ dom F → D ∈ A ) ;;
	step 3 : wff = fveq2 () |- ( y = D → ( F ` y ) = ( F ` D ) ) ;;
	step 4 : wff = sseq1d (step 3) |- ( y = D → ( ( F ` y ) ⊆ C ↔ ( F ` D ) ⊆ C ) ) ;;
	step 5 : wff = imbi2d (step 4) |- ( y = D → ( ( ∀ x ∈ A B ⊆ C → ( F ` y ) ⊆ C ) ↔ ( ∀ x ∈ A B ⊆ C → ( F ` D ) ⊆ C ) ) ) ;;
	step 6 : wff = nfcv () |- F/_ x y ;;
	step 7 : wff = nfra1 () |- F/ x ∀ x ∈ A B ⊆ C ;;
	step 8 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ B ) ;;
	step 9 : wff = nfcxfr (hyp 1, step 8) |- F/_ x F ;;
	step 10 : wff = nfcv () |- F/_ x y ;;
	step 11 : wff = nffv (step 9, step 10) |- F/_ x ( F ` y ) ;;
	step 12 : wff = nfcv () |- F/_ x C ;;
	step 13 : wff = nfss (step 11, step 12) |- F/ x ( F ` y ) ⊆ C ;;
	step 14 : wff = nfim (step 7, step 13) |- F/ x ( ∀ x ∈ A B ⊆ C → ( F ` y ) ⊆ C ) ;;
	step 15 : wff = fveq2 () |- ( x = y → ( F ` x ) = ( F ` y ) ) ;;
	step 16 : wff = sseq1d (step 15) |- ( x = y → ( ( F ` x ) ⊆ C ↔ ( F ` y ) ⊆ C ) ) ;;
	step 17 : wff = imbi2d (step 16) |- ( x = y → ( ( ∀ x ∈ A B ⊆ C → ( F ` x ) ⊆ C ) ↔ ( ∀ x ∈ A B ⊆ C → ( F ` y ) ⊆ C ) ) ) ;;
	step 18 : wff = dmmpt (hyp 1) |- dom F = { x ∈ A | B ∈ _V } ;;
	step 19 : wff = rabeq2i (step 18) |- ( x ∈ dom F ↔ ( x ∈ A ∧ B ∈ _V ) ) ;;
	step 20 : wff = fvmpt2 (hyp 1) |- ( ( x ∈ A ∧ B ∈ _V ) → ( F ` x ) = B ) ;;
	step 21 : wff = eqimss () |- ( ( F ` x ) = B → ( F ` x ) ⊆ B ) ;;
	step 22 : wff = syl (step 20, step 21) |- ( ( x ∈ A ∧ B ∈ _V ) → ( F ` x ) ⊆ B ) ;;
	step 23 : wff = sylbi (step 19, step 22) |- ( x ∈ dom F → ( F ` x ) ⊆ B ) ;;
	step 24 : wff = ndmfv () |- ( ¬ x ∈ dom F → ( F ` x ) = ∅ ) ;;
	step 25 : wff = 0ss () |- ∅ ⊆ B ;;
	step 26 : wff = a1i (step 25) |- ( ¬ x ∈ dom F → ∅ ⊆ B ) ;;
	step 27 : wff = eqsstrd (step 24, step 26) |- ( ¬ x ∈ dom F → ( F ` x ) ⊆ B ) ;;
	step 28 : wff = pm2.61i (step 23, step 27) |- ( F ` x ) ⊆ B ;;
	step 29 : wff = rsp () |- ( ∀ x ∈ A B ⊆ C → ( x ∈ A → B ⊆ C ) ) ;;
	step 30 : wff = impcom (step 29) |- ( ( x ∈ A ∧ ∀ x ∈ A B ⊆ C ) → B ⊆ C ) ;;
	step 31 : wff = syl5ss (step 28, step 30) |- ( ( x ∈ A ∧ ∀ x ∈ A B ⊆ C ) → ( F ` x ) ⊆ C ) ;;
	step 32 : wff = ex (step 31) |- ( x ∈ A → ( ∀ x ∈ A B ⊆ C → ( F ` x ) ⊆ C ) ) ;;
	step 33 : wff = vtoclgaf (step 6, step 14, step 17, step 32) |- ( y ∈ A → ( ∀ x ∈ A B ⊆ C → ( F ` y ) ⊆ C ) ) ;;
	step 34 : wff = vtoclga (step 5, step 33) |- ( D ∈ A → ( ∀ x ∈ A B ⊆ C → ( F ` D ) ⊆ C ) ) ;;
	step 35 : wff = impcom (step 34) |- ( ( ∀ x ∈ A B ⊆ C ∧ D ∈ A ) → ( F ` D ) ⊆ C ) ;;
	step 36 : wff = sylan2 (step 2, step 35) |- ( ( ∀ x ∈ A B ⊆ C ∧ D ∈ dom F ) → ( F ` D ) ⊆ C ) ;;
	step 37 : wff = ndmfv () |- ( ¬ D ∈ dom F → ( F ` D ) = ∅ ) ;;
	step 38 : wff = adantl (step 37) |- ( ( ∀ x ∈ A B ⊆ C ∧ ¬ D ∈ dom F ) → ( F ` D ) = ∅ ) ;;
	step 39 : wff = 0ss () |- ∅ ⊆ C ;;
	step 40 : wff = a1i (step 39) |- ( ( ∀ x ∈ A B ⊆ C ∧ ¬ D ∈ dom F ) → ∅ ⊆ C ) ;;
	step 41 : wff = eqsstrd (step 38, step 40) |- ( ( ∀ x ∈ A B ⊆ C ∧ ¬ D ∈ dom F ) → ( F ` D ) ⊆ C ) ;;
	step 42 : wff = pm2.61dan (step 36, step 41) |- ( ∀ x ∈ A B ⊆ C → ( F ` D ) ⊆ C ) ;;
	qed prop 1 = step 42 ;;
}

/*Express a function ` F ` whose value ` B ` may not always be a set in
       terms of another function ` G ` for which sethood is guaranteed.  (Note
       that ` ( _I `` B ) ` is just shorthand for
       ` if ( B e. _V , B , (/) ) ` , and it is always a set by ~ fvex .)  Note
       also that these functions are not the same; wherever ` B ( C ) ` is not
       a set, ` C ` is not in the domain of ` F ` (so it evaluates to the empty
       set), but ` C ` is in the domain of ` G ` , and ` G ( C ) ` is defined
       to be the empty set.  (Contributed by Mario Carneiro, 14-Jul-2013.)
       (Revised by Mario Carneiro, 23-Apr-2014.) */

theorem fvmptex (x : set, A : class, B : class, C : class, F : class, G : class) disjointed(x, x y A, y B, y C) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	hyp 2 : wff = |- G = ( x ∈ A ↦ ( _I ` B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( F ` C ) = ( G ` C ) ;;
}

proof of fvmptex {
	var y : set;;
	step 1 : wff = csbeq1 () |- ( y = C → [_ y / x ]_ B = [_ C / x ]_ B ) ;;
	step 2 : wff = nfcv () |- F/_ y B ;;
	step 3 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 4 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 5 : wff = cbvmpt (step 2, step 3, step 4) |- ( x ∈ A ↦ B ) = ( y ∈ A ↦ [_ y / x ]_ B ) ;;
	step 6 : wff = eqtri (hyp 1, step 5) |- F = ( y ∈ A ↦ [_ y / x ]_ B ) ;;
	step 7 : wff = fvmpti (step 1, step 6) |- ( C ∈ A → ( F ` C ) = ( _I ` [_ C / x ]_ B ) ) ;;
	step 8 : wff = csbeq1 () |- ( y = C → [_ y / x ]_ B = [_ C / x ]_ B ) ;;
	step 9 : wff = fveq2d (step 8) |- ( y = C → ( _I ` [_ y / x ]_ B ) = ( _I ` [_ C / x ]_ B ) ) ;;
	step 10 : wff = nfcv () |- F/_ y ( _I ` B ) ;;
	step 11 : wff = nfcv () |- F/_ x _I ;;
	step 12 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 13 : wff = nffv (step 11, step 12) |- F/_ x ( _I ` [_ y / x ]_ B ) ;;
	step 14 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 15 : wff = fveq2d (step 14) |- ( x = y → ( _I ` B ) = ( _I ` [_ y / x ]_ B ) ) ;;
	step 16 : wff = cbvmpt (step 10, step 13, step 15) |- ( x ∈ A ↦ ( _I ` B ) ) = ( y ∈ A ↦ ( _I ` [_ y / x ]_ B ) ) ;;
	step 17 : wff = eqtri (hyp 2, step 16) |- G = ( y ∈ A ↦ ( _I ` [_ y / x ]_ B ) ) ;;
	step 18 : wff = fvex () |- ( _I ` [_ C / x ]_ B ) ∈ _V ;;
	step 19 : wff = fvmpt (step 9, step 17, step 18) |- ( C ∈ A → ( G ` C ) = ( _I ` [_ C / x ]_ B ) ) ;;
	step 20 : wff = eqtr4d (step 7, step 19) |- ( C ∈ A → ( F ` C ) = ( G ` C ) ) ;;
	step 21 : wff = dmmptss (hyp 1) |- dom F ⊆ A ;;
	step 22 : wff = sseli (step 21) |- ( C ∈ dom F → C ∈ A ) ;;
	step 23 : wff = con3i (step 22) |- ( ¬ C ∈ A → ¬ C ∈ dom F ) ;;
	step 24 : wff = ndmfv () |- ( ¬ C ∈ dom F → ( F ` C ) = ∅ ) ;;
	step 25 : wff = syl (step 23, step 24) |- ( ¬ C ∈ A → ( F ` C ) = ∅ ) ;;
	step 26 : wff = fvex () |- ( _I ` B ) ∈ _V ;;
	step 27 : wff = dmmpti (step 26, hyp 2) |- dom G = A ;;
	step 28 : wff = eleq2i (step 27) |- ( C ∈ dom G ↔ C ∈ A ) ;;
	step 29 : wff = ndmfv () |- ( ¬ C ∈ dom G → ( G ` C ) = ∅ ) ;;
	step 30 : wff = sylnbir (step 28, step 29) |- ( ¬ C ∈ A → ( G ` C ) = ∅ ) ;;
	step 31 : wff = eqtr4d (step 25, step 30) |- ( ¬ C ∈ A → ( F ` C ) = ( G ` C ) ) ;;
	step 32 : wff = pm2.61i (step 20, step 31) |- ( F ` C ) = ( G ` C ) ;;
	qed prop 1 = step 32 ;;
}

/*Alternate deduction version of ~ fvmpt , suitable for iteration.
         (Contributed by Mario Carneiro, 7-Jan-2017.) */

theorem fvmptdf (ph : wff, ps : wff, x : set, A : class, B : class, D : class, F : class, V : class) disjointed(x A, x D, x ph) {
	hyp 1 : wff = |- ( ph → A ∈ D ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B ∈ V ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x = A ) → ( ( F ` A ) = B → ps ) ) ;;
	hyp 4 : wff = |- F/_ x F ;;
	hyp 5 : wff = |- F/ x ps ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F = ( x ∈ D ↦ B ) → ps ) ) ;;
}

proof of fvmptdf {
	step 1 : wff = elex () |- ( A ∈ D → A ∈ _V ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → A ∈ _V ) ;;
	step 3 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( ph → ∃ x x = A ) ;;
	step 5 : wff = nfv () |- F/ x ph ;;
	step 6 : wff = nfmpt1 () |- F/_ x ( x ∈ D ↦ B ) ;;
	step 7 : wff = nfeq (hyp 4, step 6) |- F/ x F = ( x ∈ D ↦ B ) ;;
	step 8 : wff = nfim (step 7, hyp 5) |- F/ x ( F = ( x ∈ D ↦ B ) → ps ) ;;
	step 9 : wff = fveq1 () |- ( F = ( x ∈ D ↦ B ) → ( F ` A ) = ( ( x ∈ D ↦ B ) ` A ) ) ;;
	step 10 : wff = simpr () |- ( ( ph ∧ x = A ) → x = A ) ;;
	step 11 : wff = fveq2d (step 10) |- ( ( ph ∧ x = A ) → ( ( x ∈ D ↦ B ) ` x ) = ( ( x ∈ D ↦ B ) ` A ) ) ;;
	step 12 : wff = simpr () |- ( ( ph ∧ x = A ) → x = A ) ;;
	step 13 : wff = adantr (hyp 1) |- ( ( ph ∧ x = A ) → A ∈ D ) ;;
	step 14 : wff = eqeltrd (step 12, step 13) |- ( ( ph ∧ x = A ) → x ∈ D ) ;;
	step 15 : wff = eqid () |- ( x ∈ D ↦ B ) = ( x ∈ D ↦ B ) ;;
	step 16 : wff = fvmpt2 (step 15) |- ( ( x ∈ D ∧ B ∈ V ) → ( ( x ∈ D ↦ B ) ` x ) = B ) ;;
	step 17 : wff = syl2anc (step 14, hyp 2, step 16) |- ( ( ph ∧ x = A ) → ( ( x ∈ D ↦ B ) ` x ) = B ) ;;
	step 18 : wff = eqtr3d (step 11, step 17) |- ( ( ph ∧ x = A ) → ( ( x ∈ D ↦ B ) ` A ) = B ) ;;
	step 19 : wff = eqeq2d (step 18) |- ( ( ph ∧ x = A ) → ( ( F ` A ) = ( ( x ∈ D ↦ B ) ` A ) ↔ ( F ` A ) = B ) ) ;;
	step 20 : wff = sylbid (step 19, hyp 3) |- ( ( ph ∧ x = A ) → ( ( F ` A ) = ( ( x ∈ D ↦ B ) ` A ) → ps ) ) ;;
	step 21 : wff = syl5 (step 9, step 20) |- ( ( ph ∧ x = A ) → ( F = ( x ∈ D ↦ B ) → ps ) ) ;;
	step 22 : wff = ex (step 21) |- ( ph → ( x = A → ( F = ( x ∈ D ↦ B ) → ps ) ) ) ;;
	step 23 : wff = exlimd (step 5, step 8, step 22) |- ( ph → ( ∃ x x = A → ( F = ( x ∈ D ↦ B ) → ps ) ) ) ;;
	step 24 : wff = mpd (step 4, step 23) |- ( ph → ( F = ( x ∈ D ↦ B ) → ps ) ) ;;
	qed prop 1 = step 24 ;;
}

/*Alternate deduction version of ~ fvmpt , suitable for iteration.
       (Contributed by Mario Carneiro, 7-Jan-2017.) */

theorem fvmptdv (ph : wff, ps : wff, x : set, A : class, B : class, D : class, F : class, V : class) disjointed(x A, x D, x ph, x F, x ps) {
	hyp 1 : wff = |- ( ph → A ∈ D ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B ∈ V ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x = A ) → ( ( F ` A ) = B → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F = ( x ∈ D ↦ B ) → ps ) ) ;;
}

proof of fvmptdv {
	step 1 : wff = nfcv () |- F/_ x F ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = fvmptdf (hyp 1, hyp 2, hyp 3, step 1, step 2) |- ( ph → ( F = ( x ∈ D ↦ B ) → ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate deduction version of ~ fvmpt , suitable for iteration.
       (Contributed by Mario Carneiro, 7-Jan-2017.) */

theorem fvmptdv2 (ph : wff, x : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(x A, x C, x D, x ph) {
	hyp 1 : wff = |- ( ph → A ∈ D ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → B ∈ V ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x = A ) → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F = ( x ∈ D ↦ B ) → ( F ` A ) = C ) ) ;;
}

proof of fvmptdv2 {
	step 1 : wff = eqidd () |- ( ph → ( x ∈ D ↦ B ) = ( x ∈ D ↦ B ) ) ;;
	step 2 : wff = elex () |- ( A ∈ D → A ∈ _V ) ;;
	step 3 : wff = syl (hyp 1, step 2) |- ( ph → A ∈ _V ) ;;
	step 4 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 5 : wff = sylib (step 3, step 4) |- ( ph → ∃ x x = A ) ;;
	step 6 : wff = elex () |- ( B ∈ V → B ∈ _V ) ;;
	step 7 : wff = syl (hyp 2, step 6) |- ( ( ph ∧ x = A ) → B ∈ _V ) ;;
	step 8 : wff = eqeltrrd (hyp 3, step 7) |- ( ( ph ∧ x = A ) → C ∈ _V ) ;;
	step 9 : wff = ex (step 8) |- ( ph → ( x = A → C ∈ _V ) ) ;;
	step 10 : wff = exlimdv (step 9) |- ( ph → ( ∃ x x = A → C ∈ _V ) ) ;;
	step 11 : wff = mpd (step 5, step 10) |- ( ph → C ∈ _V ) ;;
	step 12 : wff = fvmptd (step 1, hyp 3, hyp 1, step 11) |- ( ph → ( ( x ∈ D ↦ B ) ` A ) = C ) ;;
	step 13 : wff = fveq1 () |- ( F = ( x ∈ D ↦ B ) → ( F ` A ) = ( ( x ∈ D ↦ B ) ` A ) ) ;;
	step 14 : wff = eqeq1d (step 13) |- ( F = ( x ∈ D ↦ B ) → ( ( F ` A ) = C ↔ ( ( x ∈ D ↦ B ) ` A ) = C ) ) ;;
	step 15 : wff = syl5ibrcom (step 12, step 14) |- ( ph → ( F = ( x ∈ D ↦ B ) → ( F ` A ) = C ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Bidirectional equality theorem for a mapping abstraction.  Equivalent to
       ~ eqfnfv .  (Contributed by Mario Carneiro, 14-Nov-2014.) */

theorem mpteqb (x : set, A : class, B : class, C : class, V : class) disjointed(x A, B, C) {
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ V → ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ↔ ∀ x ∈ A B = C ) ) ;;
}

proof of mpteqb {
	step 1 : wff = elex () |- ( B ∈ V → B ∈ _V ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ x ∈ A B ∈ V → ∀ x ∈ A B ∈ _V ) ;;
	step 3 : wff = fneq1 () |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ( x ∈ A ↦ B ) Fn A ↔ ( x ∈ A ↦ C ) Fn A ) ) ;;
	step 4 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 5 : wff = mptfng (step 4) |- ( ∀ x ∈ A B ∈ _V ↔ ( x ∈ A ↦ B ) Fn A ) ;;
	step 6 : wff = eqid () |- ( x ∈ A ↦ C ) = ( x ∈ A ↦ C ) ;;
	step 7 : wff = mptfng (step 6) |- ( ∀ x ∈ A C ∈ _V ↔ ( x ∈ A ↦ C ) Fn A ) ;;
	step 8 : wff = 3bitr4g (step 3, step 5, step 7) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ∀ x ∈ A B ∈ _V ↔ ∀ x ∈ A C ∈ _V ) ) ;;
	step 9 : wff = biimpd (step 8) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ∀ x ∈ A B ∈ _V → ∀ x ∈ A C ∈ _V ) ) ;;
	step 10 : wff = r19.26 () |- ( ∀ x ∈ A ( B ∈ _V ∧ C ∈ _V ) ↔ ( ∀ x ∈ A B ∈ _V ∧ ∀ x ∈ A C ∈ _V ) ) ;;
	step 11 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ B ) ;;
	step 12 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ C ) ;;
	step 13 : wff = nfeq (step 11, step 12) |- F/ x ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ;;
	step 14 : wff = simpll () |- ( ( ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ∧ x ∈ A ) ∧ ( B ∈ _V ∧ C ∈ _V ) ) → ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ) ;;
	step 15 : wff = fveq1d (step 14) |- ( ( ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ∧ x ∈ A ) ∧ ( B ∈ _V ∧ C ∈ _V ) ) → ( ( x ∈ A ↦ B ) ` x ) = ( ( x ∈ A ↦ C ) ` x ) ) ;;
	step 16 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 17 : wff = fvmpt2 (step 16) |- ( ( x ∈ A ∧ B ∈ _V ) → ( ( x ∈ A ↦ B ) ` x ) = B ) ;;
	step 18 : wff = ad2ant2lr (step 17) |- ( ( ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ∧ x ∈ A ) ∧ ( B ∈ _V ∧ C ∈ _V ) ) → ( ( x ∈ A ↦ B ) ` x ) = B ) ;;
	step 19 : wff = eqid () |- ( x ∈ A ↦ C ) = ( x ∈ A ↦ C ) ;;
	step 20 : wff = fvmpt2 (step 19) |- ( ( x ∈ A ∧ C ∈ _V ) → ( ( x ∈ A ↦ C ) ` x ) = C ) ;;
	step 21 : wff = ad2ant2l (step 20) |- ( ( ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ∧ x ∈ A ) ∧ ( B ∈ _V ∧ C ∈ _V ) ) → ( ( x ∈ A ↦ C ) ` x ) = C ) ;;
	step 22 : wff = 3eqtr3d (step 15, step 18, step 21) |- ( ( ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ∧ x ∈ A ) ∧ ( B ∈ _V ∧ C ∈ _V ) ) → B = C ) ;;
	step 23 : wff = exp31 (step 22) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( x ∈ A → ( ( B ∈ _V ∧ C ∈ _V ) → B = C ) ) ) ;;
	step 24 : wff = ralrimi (step 13, step 23) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ∀ x ∈ A ( ( B ∈ _V ∧ C ∈ _V ) → B = C ) ) ;;
	step 25 : wff = ralim () |- ( ∀ x ∈ A ( ( B ∈ _V ∧ C ∈ _V ) → B = C ) → ( ∀ x ∈ A ( B ∈ _V ∧ C ∈ _V ) → ∀ x ∈ A B = C ) ) ;;
	step 26 : wff = syl (step 24, step 25) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ∀ x ∈ A ( B ∈ _V ∧ C ∈ _V ) → ∀ x ∈ A B = C ) ) ;;
	step 27 : wff = syl5bir (step 10, step 26) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ( ∀ x ∈ A B ∈ _V ∧ ∀ x ∈ A C ∈ _V ) → ∀ x ∈ A B = C ) ) ;;
	step 28 : wff = exp3a (step 27) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ∀ x ∈ A B ∈ _V → ( ∀ x ∈ A C ∈ _V → ∀ x ∈ A B = C ) ) ) ;;
	step 29 : wff = mpdd (step 9, step 28) |- ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ( ∀ x ∈ A B ∈ _V → ∀ x ∈ A B = C ) ) ;;
	step 30 : wff = com12 (step 29) |- ( ∀ x ∈ A B ∈ _V → ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) → ∀ x ∈ A B = C ) ) ;;
	step 31 : wff = eqid () |- A = A ;;
	step 32 : wff = mpteq12 () |- ( ( A = A ∧ ∀ x ∈ A B = C ) → ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ) ;;
	step 33 : wff = mpan (step 31, step 32) |- ( ∀ x ∈ A B = C → ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ) ;;
	step 34 : wff = impbid1 (step 30, step 33) |- ( ∀ x ∈ A B ∈ _V → ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ↔ ∀ x ∈ A B = C ) ) ;;
	step 35 : wff = syl (step 2, step 34) |- ( ∀ x ∈ A B ∈ V → ( ( x ∈ A ↦ B ) = ( x ∈ A ↦ C ) ↔ ∀ x ∈ A B = C ) ) ;;
	qed prop 1 = step 35 ;;
}

/*Closed theorem form of ~ fvmpt .  (Contributed by Scott Fenton,
       21-Feb-2013.)  (Revised by Mario Carneiro, 11-Sep-2015.) */

theorem fvmptt (x : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(x A, B, x C, x D) {
	prop 1 : wff = |- ( ( ∀ x ( x = A → B = C ) ∧ F = ( x ∈ D ↦ B ) ∧ ( A ∈ D ∧ C ∈ V ) ) → ( F ` A ) = C ) ;;
}

proof of fvmptt {
	step 1 : wff = simp2 () |- ( ( ∀ x ( x = A → B = C ) ∧ F = ( x ∈ D ↦ B ) ∧ ( A ∈ D ∧ C ∈ V ) ) → F = ( x ∈ D ↦ B ) ) ;;
	step 2 : wff = fveq1d (step 1) |- ( ( ∀ x ( x = A → B = C ) ∧ F = ( x ∈ D ↦ B ) ∧ ( A ∈ D ∧ C ∈ V ) ) → ( F ` A ) = ( ( x ∈ D ↦ B ) ` A ) ) ;;
	step 3 : wff = risset () |- ( A ∈ D ↔ ∃ x ∈ D x = A ) ;;
	step 4 : wff = elex () |- ( C ∈ V → C ∈ _V ) ;;
	step 5 : wff = nfa1 () |- F/ x ∀ x ( x = A → B = C ) ;;
	step 6 : wff = nfv () |- F/ x C ∈ _V ;;
	step 7 : wff = nfmpt1 () |- F/_ x ( x ∈ D ↦ B ) ;;
	step 8 : wff = nfcv () |- F/_ x A ;;
	step 9 : wff = nffv (step 7, step 8) |- F/_ x ( ( x ∈ D ↦ B ) ` A ) ;;
	step 10 : wff = nfeq1 (step 9) |- F/ x ( ( x ∈ D ↦ B ) ` A ) = C ;;
	step 11 : wff = nfim (step 6, step 10) |- F/ x ( C ∈ _V → ( ( x ∈ D ↦ B ) ` A ) = C ) ;;
	step 12 : wff = simprl () |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → x ∈ D ) ;;
	step 13 : wff = simplr () |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → B = C ) ;;
	step 14 : wff = simprr () |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → C ∈ _V ) ;;
	step 15 : wff = eqeltrd (step 13, step 14) |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → B ∈ _V ) ;;
	step 16 : wff = eqid () |- ( x ∈ D ↦ B ) = ( x ∈ D ↦ B ) ;;
	step 17 : wff = fvmpt2 (step 16) |- ( ( x ∈ D ∧ B ∈ _V ) → ( ( x ∈ D ↦ B ) ` x ) = B ) ;;
	step 18 : wff = syl2anc (step 12, step 15, step 17) |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → ( ( x ∈ D ↦ B ) ` x ) = B ) ;;
	step 19 : wff = simpll () |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → x = A ) ;;
	step 20 : wff = fveq2d (step 19) |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → ( ( x ∈ D ↦ B ) ` x ) = ( ( x ∈ D ↦ B ) ` A ) ) ;;
	step 21 : wff = simplr () |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → B = C ) ;;
	step 22 : wff = 3eqtr3d (step 18, step 20, step 21) |- ( ( ( x = A ∧ B = C ) ∧ ( x ∈ D ∧ C ∈ _V ) ) → ( ( x ∈ D ↦ B ) ` A ) = C ) ;;
	step 23 : wff = exp43 (step 22) |- ( x = A → ( B = C → ( x ∈ D → ( C ∈ _V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ) ;;
	step 24 : wff = a2i (step 23) |- ( ( x = A → B = C ) → ( x = A → ( x ∈ D → ( C ∈ _V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ) ;;
	step 25 : wff = com23 (step 24) |- ( ( x = A → B = C ) → ( x ∈ D → ( x = A → ( C ∈ _V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ) ;;
	step 26 : wff = sps (step 25) |- ( ∀ x ( x = A → B = C ) → ( x ∈ D → ( x = A → ( C ∈ _V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ) ;;
	step 27 : wff = rexlimd (step 5, step 11, step 26) |- ( ∀ x ( x = A → B = C ) → ( ∃ x ∈ D x = A → ( C ∈ _V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ;;
	step 28 : wff = syl7 (step 4, step 27) |- ( ∀ x ( x = A → B = C ) → ( ∃ x ∈ D x = A → ( C ∈ V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ;;
	step 29 : wff = syl5bi (step 3, step 28) |- ( ∀ x ( x = A → B = C ) → ( A ∈ D → ( C ∈ V → ( ( x ∈ D ↦ B ) ` A ) = C ) ) ) ;;
	step 30 : wff = imp32 (step 29) |- ( ( ∀ x ( x = A → B = C ) ∧ ( A ∈ D ∧ C ∈ V ) ) → ( ( x ∈ D ↦ B ) ` A ) = C ) ;;
	step 31 : wff = 3adant2 (step 30) |- ( ( ∀ x ( x = A → B = C ) ∧ F = ( x ∈ D ↦ B ) ∧ ( A ∈ D ∧ C ∈ V ) ) → ( ( x ∈ D ↦ B ) ` A ) = C ) ;;
	step 32 : wff = eqtrd (step 2, step 31) |- ( ( ∀ x ( x = A → B = C ) ∧ F = ( x ∈ D ↦ B ) ∧ ( A ∈ D ∧ C ∈ V ) ) → ( F ` A ) = C ) ;;
	qed prop 1 = step 32 ;;
}

/*Value of a function given by an ordered-pair class abstraction.  This
       version of ~ fvmptg uses bound-variable hypotheses instead of distinct
       variable conditions.  (Contributed by NM, 8-Nov-2005.)  (Revised by
       Mario Carneiro, 15-Oct-2016.) */

theorem fvmptf (x : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(x, A, B, C, x D, F) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x C ;;
	hyp 3 : wff = |- ( x = A → B = C ) ;;
	hyp 4 : wff = |- F = ( x ∈ D ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ D ∧ C ∈ V ) → ( F ` A ) = C ) ;;
}

proof of fvmptf {
	step 1 : wff = elex () |- ( C ∈ V → C ∈ _V ) ;;
	step 2 : wff = nfel1 (hyp 2) |- F/ x C ∈ _V ;;
	step 3 : wff = nfmpt1 () |- F/_ x ( x ∈ D ↦ B ) ;;
	step 4 : wff = nfcxfr (hyp 4, step 3) |- F/_ x F ;;
	step 5 : wff = nffv (step 4, hyp 1) |- F/_ x ( F ` A ) ;;
	step 6 : wff = nfeq (step 5, hyp 2) |- F/ x ( F ` A ) = C ;;
	step 7 : wff = nfim (step 2, step 6) |- F/ x ( C ∈ _V → ( F ` A ) = C ) ;;
	step 8 : wff = eleq1d (hyp 3) |- ( x = A → ( B ∈ _V ↔ C ∈ _V ) ) ;;
	step 9 : wff = fveq2 () |- ( x = A → ( F ` x ) = ( F ` A ) ) ;;
	step 10 : wff = eqeq12d (step 9, hyp 3) |- ( x = A → ( ( F ` x ) = B ↔ ( F ` A ) = C ) ) ;;
	step 11 : wff = imbi12d (step 8, step 10) |- ( x = A → ( ( B ∈ _V → ( F ` x ) = B ) ↔ ( C ∈ _V → ( F ` A ) = C ) ) ) ;;
	step 12 : wff = fvmpt2 (hyp 4) |- ( ( x ∈ D ∧ B ∈ _V ) → ( F ` x ) = B ) ;;
	step 13 : wff = ex (step 12) |- ( x ∈ D → ( B ∈ _V → ( F ` x ) = B ) ) ;;
	step 14 : wff = vtoclgaf (hyp 1, step 7, step 11, step 13) |- ( A ∈ D → ( C ∈ _V → ( F ` A ) = C ) ) ;;
	step 15 : wff = syl5 (step 1, step 14) |- ( A ∈ D → ( C ∈ V → ( F ` A ) = C ) ) ;;
	step 16 : wff = imp (step 15) |- ( ( A ∈ D ∧ C ∈ V ) → ( F ` A ) = C ) ;;
	qed prop 1 = step 16 ;;
}

/*The value of a function given by an ordered-pair class abstraction is
       the empty set when the class it would otherwise map to is a proper
       class.  This version of ~ fvmptn uses bound-variable hypotheses instead
       of distinct variable conditions.  (Contributed by NM, 21-Oct-2003.)
       (Revised by Mario Carneiro, 11-Sep-2015.) */

theorem fvmptnf (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x, A, B, C, x D, F) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x C ;;
	hyp 3 : wff = |- ( x = A → B = C ) ;;
	hyp 4 : wff = |- F = ( x ∈ D ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ C ∈ _V → ( F ` A ) = ∅ ) ;;
}

proof of fvmptnf {
	step 1 : wff = dmmptss (hyp 4) |- dom F ⊆ D ;;
	step 2 : wff = sseli (step 1) |- ( A ∈ dom F → A ∈ D ) ;;
	step 3 : wff = eqid () |- ( x ∈ D ↦ ( _I ` B ) ) = ( x ∈ D ↦ ( _I ` B ) ) ;;
	step 4 : wff = fvmptex (hyp 4, step 3) |- ( F ` A ) = ( ( x ∈ D ↦ ( _I ` B ) ) ` A ) ;;
	step 5 : wff = fvex () |- ( _I ` C ) ∈ _V ;;
	step 6 : wff = nfcv () |- F/_ x _I ;;
	step 7 : wff = nffv (step 6, hyp 2) |- F/_ x ( _I ` C ) ;;
	step 8 : wff = fveq2d (hyp 3) |- ( x = A → ( _I ` B ) = ( _I ` C ) ) ;;
	step 9 : wff = eqid () |- ( x ∈ D ↦ ( _I ` B ) ) = ( x ∈ D ↦ ( _I ` B ) ) ;;
	step 10 : wff = fvmptf (hyp 1, step 7, step 8, step 9) |- ( ( A ∈ D ∧ ( _I ` C ) ∈ _V ) → ( ( x ∈ D ↦ ( _I ` B ) ) ` A ) = ( _I ` C ) ) ;;
	step 11 : wff = mpan2 (step 5, step 10) |- ( A ∈ D → ( ( x ∈ D ↦ ( _I ` B ) ) ` A ) = ( _I ` C ) ) ;;
	step 12 : wff = syl5eq (step 4, step 11) |- ( A ∈ D → ( F ` A ) = ( _I ` C ) ) ;;
	step 13 : wff = fvprc () |- ( ¬ C ∈ _V → ( _I ` C ) = ∅ ) ;;
	step 14 : wff = sylan9eq (step 12, step 13) |- ( ( A ∈ D ∧ ¬ C ∈ _V ) → ( F ` A ) = ∅ ) ;;
	step 15 : wff = expcom (step 14) |- ( ¬ C ∈ _V → ( A ∈ D → ( F ` A ) = ∅ ) ) ;;
	step 16 : wff = syl5 (step 2, step 15) |- ( ¬ C ∈ _V → ( A ∈ dom F → ( F ` A ) = ∅ ) ) ;;
	step 17 : wff = ndmfv () |- ( ¬ A ∈ dom F → ( F ` A ) = ∅ ) ;;
	step 18 : wff = pm2.61d1 (step 16, step 17) |- ( ¬ C ∈ _V → ( F ` A ) = ∅ ) ;;
	qed prop 1 = step 18 ;;
}

/*This somewhat non-intuitive theorem tells us the value of its function
       is the empty set when the class ` C ` it would otherwise map to is a
       proper class.  This is a technical lemma that can help eliminate
       redundant sethood antecedents otherwise required by ~ fvmptg .
       (Contributed by NM, 21-Oct-2003.)  (Revised by Mario Carneiro,
       9-Sep-2013.) */

theorem fvmptn (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x A, B, x C, x D, F) {
	hyp 1 : wff = |- ( x = D → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ C ∈ _V → ( F ` D ) = ∅ ) ;;
}

proof of fvmptn {
	step 1 : wff = nfcv () |- F/_ x D ;;
	step 2 : wff = nfcv () |- F/_ x C ;;
	step 3 : wff = fvmptnf (step 1, step 2, hyp 1, hyp 2) |- ( ¬ C ∈ _V → ( F ` D ) = ∅ ) ;;
	qed prop 1 = step 3 ;;
}

/*A mapping always evaluates to a subset of the substituted expression in
       the mapping, even if this is a proper class, or we are out of the
       domain.  (Contributed by Mario Carneiro, 13-Feb-2015.) */

theorem fvmptss2 (x : set, A : class, B : class, C : class, D : class, F : class) disjointed(x A, B, x C, x D, F) {
	hyp 1 : wff = |- ( x = D → B = C ) ;;
	hyp 2 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( F ` D ) ⊆ C ;;
}

proof of fvmptss2 {
	step 1 : wff = eleq1d (hyp 1) |- ( x = D → ( B ∈ _V ↔ C ∈ _V ) ) ;;
	step 2 : wff = dmmpt (hyp 2) |- dom F = { x ∈ A | B ∈ _V } ;;
	step 3 : wff = elrab2 (step 1, step 2) |- ( D ∈ dom F ↔ ( D ∈ A ∧ C ∈ _V ) ) ;;
	step 4 : wff = fvmptg (hyp 1, hyp 2) |- ( ( D ∈ A ∧ C ∈ _V ) → ( F ` D ) = C ) ;;
	step 5 : wff = eqimss () |- ( ( F ` D ) = C → ( F ` D ) ⊆ C ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ( D ∈ A ∧ C ∈ _V ) → ( F ` D ) ⊆ C ) ;;
	step 7 : wff = sylbi (step 3, step 6) |- ( D ∈ dom F → ( F ` D ) ⊆ C ) ;;
	step 8 : wff = ndmfv () |- ( ¬ D ∈ dom F → ( F ` D ) = ∅ ) ;;
	step 9 : wff = 0ss () |- ∅ ⊆ C ;;
	step 10 : wff = a1i (step 9) |- ( ¬ D ∈ dom F → ∅ ⊆ C ) ;;
	step 11 : wff = eqsstrd (step 8, step 10) |- ( ¬ D ∈ dom F → ( F ` D ) ⊆ C ) ;;
	step 12 : wff = pm2.61i (step 7, step 11) |- ( F ` D ) ⊆ C ;;
	qed prop 1 = step 12 ;;
}

/*Value of a function given by an ordered-pair class abstraction, outside
       of its domain.  (Contributed by NM, 28-Mar-2008.) */

theorem fvopab4ndm (ph : wff, x : set, y : set, A : class, B : class, F : class) disjointed(x y A) {
	hyp 1 : wff = |- F = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( ¬ B ∈ A → ( F ` B ) = ∅ ) ;;
}

proof of fvopab4ndm {
	step 1 : wff = dmeqi (hyp 1) |- dom F = dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 2 : wff = dmopabss () |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ⊆ A ;;
	step 3 : wff = eqsstri (step 1, step 2) |- dom F ⊆ A ;;
	step 4 : wff = sseli (step 3) |- ( B ∈ dom F → B ∈ A ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ B ∈ A → ¬ B ∈ dom F ) ;;
	step 6 : wff = ndmfv () |- ( ¬ B ∈ dom F → ( F ` B ) = ∅ ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ¬ B ∈ A → ( F ` B ) = ∅ ) ;;
	qed prop 1 = step 7 ;;
}

/*Value of a function given by ordered-pair class abstraction.
       (Contributed by Jeff Madsen, 2-Sep-2009.)  (Revised by Mario Carneiro,
       11-Sep-2015.) */

theorem fvopab6 (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, F : class) disjointed(A x y, ps x y, B y, C x y) {
	hyp 1 : wff = |- F = { 〈 x , y 〉 | ( ph ∧ y = B ) } ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( x = A → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ D ∧ C ∈ R ∧ ps ) → ( F ` A ) = C ) ;;
}

proof of fvopab6 {
	step 1 : wff = elex () |- ( A ∈ D → A ∈ _V ) ;;
	step 2 : wff = eqeq2d (hyp 3) |- ( x = A → ( y = B ↔ y = C ) ) ;;
	step 3 : wff = anbi12d (hyp 2, step 2) |- ( x = A → ( ( ph ∧ y = B ) ↔ ( ps ∧ y = C ) ) ) ;;
	step 4 : wff = iba () |- ( y = C → ( ps ↔ ( ps ∧ y = C ) ) ) ;;
	step 5 : wff = bicomd (step 4) |- ( y = C → ( ( ps ∧ y = C ) ↔ ps ) ) ;;
	step 6 : wff = moeq () |- ∃* y y = B ;;
	step 7 : wff = moani (step 6) |- ∃* y ( ph ∧ y = B ) ;;
	step 8 : wff = a1i (step 7) |- ( x ∈ _V → ∃* y ( ph ∧ y = B ) ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = biantrur (step 9) |- ( ( ph ∧ y = B ) ↔ ( x ∈ _V ∧ ( ph ∧ y = B ) ) ) ;;
	step 11 : wff = opabbii (step 10) |- { 〈 x , y 〉 | ( ph ∧ y = B ) } = { 〈 x , y 〉 | ( x ∈ _V ∧ ( ph ∧ y = B ) ) } ;;
	step 12 : wff = eqtri (hyp 1, step 11) |- F = { 〈 x , y 〉 | ( x ∈ _V ∧ ( ph ∧ y = B ) ) } ;;
	step 13 : wff = fvopab3ig (step 3, step 5, step 8, step 12) |- ( ( A ∈ _V ∧ C ∈ R ) → ( ps → ( F ` A ) = C ) ) ;;
	step 14 : wff = sylan (step 1, step 13) |- ( ( A ∈ D ∧ C ∈ R ) → ( ps → ( F ` A ) = C ) ) ;;
	step 15 : wff = 3impia (step 14) |- ( ( A ∈ D ∧ C ∈ R ∧ ps ) → ( F ` A ) = C ) ;;
	qed prop 1 = step 15 ;;
}

/*Equality of functions is determined by their values.  Special case of
       Exercise 4 of [TakeutiZaring] p. 28 (with domain equality omitted).
       (Contributed by NM, 3-Aug-1994.)  (Proof shortened by Andrew Salmon,
       22-Oct-2011.)  (Proof shortened by Mario Carneiro, 31-Aug-2015.) */

theorem eqfnfv (x : set, A : class, F : class, G : class) disjointed(x A, x F, x G, x) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
}

proof of eqfnfv {
	step 1 : wff = dffn5 () |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 2 : wff = dffn5 () |- ( G Fn A ↔ G = ( x ∈ A ↦ ( G ` x ) ) ) ;;
	step 3 : wff = eqeq12 () |- ( ( F = ( x ∈ A ↦ ( F ` x ) ) ∧ G = ( x ∈ A ↦ ( G ` x ) ) ) → ( F = G ↔ ( x ∈ A ↦ ( F ` x ) ) = ( x ∈ A ↦ ( G ` x ) ) ) ) ;;
	step 4 : wff = syl2anb (step 1, step 2, step 3) |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ( x ∈ A ↦ ( F ` x ) ) = ( x ∈ A ↦ ( G ` x ) ) ) ) ;;
	step 5 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 6 : wff = rgenw (step 5) |- ∀ x ∈ A ( F ` x ) ∈ _V ;;
	step 7 : wff = mpteqb () |- ( ∀ x ∈ A ( F ` x ) ∈ _V → ( ( x ∈ A ↦ ( F ` x ) ) = ( x ∈ A ↦ ( G ` x ) ) ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 8 : wff = ax-mp (step 6, step 7) |- ( ( x ∈ A ↦ ( F ` x ) ) = ( x ∈ A ↦ ( G ` x ) ) ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 9 : wff = syl6bb (step 4, step 8) |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Equality of functions is determined by their values.  Exercise 4 of
       [TakeutiZaring] p. 28.  (Contributed by NM, 3-Aug-1994.)  (Revised by
       Mario Carneiro, 31-Aug-2015.) */

theorem eqfnfv2 (x : set, A : class, B : class, F : class, G : class) disjointed(x A, B, x F, x G, x) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ) → ( F = G ↔ ( A = B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ) ;;
}

proof of eqfnfv2 {
	step 1 : wff = dmeq () |- ( F = G → dom F = dom G ) ;;
	step 2 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 3 : wff = fndm () |- ( G Fn B → dom G = B ) ;;
	step 4 : wff = eqeqan12d (step 2, step 3) |- ( ( F Fn A ∧ G Fn B ) → ( dom F = dom G ↔ A = B ) ) ;;
	step 5 : wff = syl5ib (step 1, step 4) |- ( ( F Fn A ∧ G Fn B ) → ( F = G → A = B ) ) ;;
	step 6 : wff = pm4.71rd (step 5) |- ( ( F Fn A ∧ G Fn B ) → ( F = G ↔ ( A = B ∧ F = G ) ) ) ;;
	step 7 : wff = fneq2 () |- ( A = B → ( G Fn A ↔ G Fn B ) ) ;;
	step 8 : wff = biimparc (step 7) |- ( ( G Fn B ∧ A = B ) → G Fn A ) ;;
	step 9 : wff = eqfnfv () |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 10 : wff = sylan2 (step 8, step 9) |- ( ( F Fn A ∧ ( G Fn B ∧ A = B ) ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 11 : wff = anassrs (step 10) |- ( ( ( F Fn A ∧ G Fn B ) ∧ A = B ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 12 : wff = pm5.32da (step 11) |- ( ( F Fn A ∧ G Fn B ) → ( ( A = B ∧ F = G ) ↔ ( A = B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 13 : wff = bitrd (step 6, step 12) |- ( ( F Fn A ∧ G Fn B ) → ( F = G ↔ ( A = B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Derive equality of functions from equality of their values.
       (Contributed by Jeff Madsen, 2-Sep-2009.) */

theorem eqfnfv3 (x : set, A : class, B : class, F : class, G : class) disjointed(x A, B, x F, x G, x, x B) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ) → ( F = G ↔ ( B ⊆ A ∧ ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ) ) ) ;;
}

proof of eqfnfv3 {
	step 1 : wff = eqfnfv2 () |- ( ( F Fn A ∧ G Fn B ) → ( F = G ↔ ( A = B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 2 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 3 : wff = ancom () |- ( ( A ⊆ B ∧ B ⊆ A ) ↔ ( B ⊆ A ∧ A ⊆ B ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( A = B ↔ ( B ⊆ A ∧ A ⊆ B ) ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( A = B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ↔ ( ( B ⊆ A ∧ A ⊆ B ) ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 6 : wff = anass () |- ( ( ( B ⊆ A ∧ A ⊆ B ) ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ↔ ( B ⊆ A ∧ ( A ⊆ B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 7 : wff = dfss3 () |- ( A ⊆ B ↔ ∀ x ∈ A x ∈ B ) ;;
	step 8 : wff = anbi1i (step 7) |- ( ( A ⊆ B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ↔ ( ∀ x ∈ A x ∈ B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 9 : wff = r19.26 () |- ( ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ↔ ( ∀ x ∈ A x ∈ B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 10 : wff = bitr4i (step 8, step 9) |- ( ( A ⊆ B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ↔ ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ) ;;
	step 11 : wff = anbi2i (step 10) |- ( ( B ⊆ A ∧ ( A ⊆ B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ↔ ( B ⊆ A ∧ ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 12 : wff = bitri (step 6, step 11) |- ( ( ( B ⊆ A ∧ A ⊆ B ) ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ↔ ( B ⊆ A ∧ ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 13 : wff = bitri (step 5, step 12) |- ( ( A = B ∧ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ↔ ( B ⊆ A ∧ ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 14 : wff = syl6bb (step 1, step 13) |- ( ( F Fn A ∧ G Fn B ) → ( F = G ↔ ( B ⊆ A ∧ ∀ x ∈ A ( x ∈ B ∧ ( F ` x ) = ( G ` x ) ) ) ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Deduction for equality of functions.  (Contributed by Mario Carneiro,
       24-Jul-2014.) */

theorem eqfnfvd (ph : wff, x : set, A : class, F : class, G : class) disjointed(x A, x F, x G, x ph, x) {
	hyp 1 : wff = |- ( ph → F Fn A ) ;;
	hyp 2 : wff = |- ( ph → G Fn A ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ A ) → ( F ` x ) = ( G ` x ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F = G ) ;;
}

proof of eqfnfvd {
	step 1 : wff = ralrimiva (hyp 3) |- ( ph → ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 2 : wff = eqfnfv () |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 3 : wff = syl2anc (hyp 1, hyp 2, step 2) |- ( ph → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 4 : wff = mpbird (step 1, step 3) |- ( ph → F = G ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality of functions is determined by their values.  Special case of
       Exercise 4 of [TakeutiZaring] p. 28 (with domain equality omitted).
       This version of ~ eqfnfv uses bound-variable hypotheses instead of
       distinct variable conditions.  (Contributed by NM, 29-Jan-2004.) */

theorem eqfnfv2f (x : set, A : class, F : class, G : class) disjointed(x z A, z F, z G, x) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ x G ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
}

proof of eqfnfv2f {
	var z : set;;
	step 1 : wff = eqfnfv () |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ z ∈ A ( F ` z ) = ( G ` z ) ) ) ;;
	step 2 : wff = nfcv () |- F/_ x z ;;
	step 3 : wff = nffv (hyp 1, step 2) |- F/_ x ( F ` z ) ;;
	step 4 : wff = nfcv () |- F/_ x z ;;
	step 5 : wff = nffv (hyp 2, step 4) |- F/_ x ( G ` z ) ;;
	step 6 : wff = nfeq (step 3, step 5) |- F/ x ( F ` z ) = ( G ` z ) ;;
	step 7 : wff = nfv () |- F/ z ( F ` x ) = ( G ` x ) ;;
	step 8 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 9 : wff = fveq2 () |- ( z = x → ( G ` z ) = ( G ` x ) ) ;;
	step 10 : wff = eqeq12d (step 8, step 9) |- ( z = x → ( ( F ` z ) = ( G ` z ) ↔ ( F ` x ) = ( G ` x ) ) ) ;;
	step 11 : wff = cbvral (step 6, step 7, step 10) |- ( ∀ z ∈ A ( F ` z ) = ( G ` z ) ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 12 : wff = syl6bb (step 1, step 11) |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Equality of functions is determined by their values.  (Contributed by
       Scott Fenton, 19-Jun-2011.) */

theorem eqfunfv (x : set, F : class, G : class) disjointed(F x, G x) {
	prop 1 : wff = |- ( ( Fun F ∧ Fun G ) → ( F = G ↔ ( dom F = dom G ∧ ∀ x ∈ dom F ( F ` x ) = ( G ` x ) ) ) ) ;;
}

proof of eqfunfv {
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = funfn () |- ( Fun G ↔ G Fn dom G ) ;;
	step 3 : wff = eqfnfv2 () |- ( ( F Fn dom F ∧ G Fn dom G ) → ( F = G ↔ ( dom F = dom G ∧ ∀ x ∈ dom F ( F ` x ) = ( G ` x ) ) ) ) ;;
	step 4 : wff = syl2anb (step 1, step 2, step 3) |- ( ( Fun F ∧ Fun G ) → ( F = G ↔ ( dom F = dom G ∧ ∀ x ∈ dom F ( F ` x ) = ( G ` x ) ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality of restricted functions is determined by their values.
       (Contributed by NM, 3-Aug-1994.) */

theorem fvreseq (x : set, A : class, B : class, F : class, G : class) disjointed(x B, x F, x G) {
	prop 1 : wff = |- ( ( ( F Fn A ∧ G Fn A ) ∧ B ⊆ A ) → ( ( F ↾ B ) = ( G ↾ B ) ↔ ∀ x ∈ B ( F ` x ) = ( G ` x ) ) ) ;;
}

proof of fvreseq {
	step 1 : wff = fnssres () |- ( ( F Fn A ∧ B ⊆ A ) → ( F ↾ B ) Fn B ) ;;
	step 2 : wff = fnssres () |- ( ( G Fn A ∧ B ⊆ A ) → ( G ↾ B ) Fn B ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ ( G Fn A ∧ B ⊆ A ) ) → ( ( F ↾ B ) Fn B ∧ ( G ↾ B ) Fn B ) ) ;;
	step 4 : wff = anandirs (step 3) |- ( ( ( F Fn A ∧ G Fn A ) ∧ B ⊆ A ) → ( ( F ↾ B ) Fn B ∧ ( G ↾ B ) Fn B ) ) ;;
	step 5 : wff = eqfnfv () |- ( ( ( F ↾ B ) Fn B ∧ ( G ↾ B ) Fn B ) → ( ( F ↾ B ) = ( G ↾ B ) ↔ ∀ x ∈ B ( ( F ↾ B ) ` x ) = ( ( G ↾ B ) ` x ) ) ) ;;
	step 6 : wff = fvres () |- ( x ∈ B → ( ( F ↾ B ) ` x ) = ( F ` x ) ) ;;
	step 7 : wff = fvres () |- ( x ∈ B → ( ( G ↾ B ) ` x ) = ( G ` x ) ) ;;
	step 8 : wff = eqeq12d (step 6, step 7) |- ( x ∈ B → ( ( ( F ↾ B ) ` x ) = ( ( G ↾ B ) ` x ) ↔ ( F ` x ) = ( G ` x ) ) ) ;;
	step 9 : wff = ralbiia (step 8) |- ( ∀ x ∈ B ( ( F ↾ B ) ` x ) = ( ( G ↾ B ) ` x ) ↔ ∀ x ∈ B ( F ` x ) = ( G ` x ) ) ;;
	step 10 : wff = syl6bb (step 5, step 9) |- ( ( ( F ↾ B ) Fn B ∧ ( G ↾ B ) Fn B ) → ( ( F ↾ B ) = ( G ↾ B ) ↔ ∀ x ∈ B ( F ` x ) = ( G ` x ) ) ) ;;
	step 11 : wff = syl (step 4, step 10) |- ( ( ( F Fn A ∧ G Fn A ) ∧ B ⊆ A ) → ( ( F ↾ B ) = ( G ↾ B ) ↔ ∀ x ∈ B ( F ` x ) = ( G ` x ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Two ways to express the locus of differences between two functions.
       (Contributed by Stefan O'Rear, 17-Jan-2015.) */

theorem fndmdif (x : set, A : class, F : class, G : class) disjointed(F x y, G x y, A x y) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) = { x ∈ A | ( F ` x ) ≠ ( G ` x ) } ) ;;
}

proof of fndmdif {
	var y : set;;
	step 1 : wff = difss () |- ( F ∖ G ) ⊆ F ;;
	step 2 : wff = dmss () |- ( ( F ∖ G ) ⊆ F → dom ( F ∖ G ) ⊆ dom F ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- dom ( F ∖ G ) ⊆ dom F ;;
	step 4 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 5 : wff = adantr (step 4) |- ( ( F Fn A ∧ G Fn A ) → dom F = A ) ;;
	step 6 : wff = syl5sseq (step 3, step 5) |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) ⊆ A ) ;;
	step 7 : wff = dfss1 () |- ( dom ( F ∖ G ) ⊆ A ↔ ( A ∩ dom ( F ∖ G ) ) = dom ( F ∖ G ) ) ;;
	step 8 : wff = sylib (step 6, step 7) |- ( ( F Fn A ∧ G Fn A ) → ( A ∩ dom ( F ∖ G ) ) = dom ( F ∖ G ) ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = eldm (step 9) |- ( x ∈ dom ( F ∖ G ) ↔ ∃ y x ( F ∖ G ) y ) ;;
	step 11 : wff = eqcom () |- ( ( F ` x ) = ( G ` x ) ↔ ( G ` x ) = ( F ` x ) ) ;;
	step 12 : wff = fnbrfvb () |- ( ( G Fn A ∧ x ∈ A ) → ( ( G ` x ) = ( F ` x ) ↔ x G ( F ` x ) ) ) ;;
	step 13 : wff = syl5bb (step 11, step 12) |- ( ( G Fn A ∧ x ∈ A ) → ( ( F ` x ) = ( G ` x ) ↔ x G ( F ` x ) ) ) ;;
	step 14 : wff = adantll (step 13) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ( F ` x ) = ( G ` x ) ↔ x G ( F ` x ) ) ) ;;
	step 15 : wff = necon3abid (step 14) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ( F ` x ) ≠ ( G ` x ) ↔ ¬ x G ( F ` x ) ) ) ;;
	step 16 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 17 : wff = breq2 () |- ( y = ( F ` x ) → ( x G y ↔ x G ( F ` x ) ) ) ;;
	step 18 : wff = notbid (step 17) |- ( y = ( F ` x ) → ( ¬ x G y ↔ ¬ x G ( F ` x ) ) ) ;;
	step 19 : wff = ceqsexv (step 16, step 18) |- ( ∃ y ( y = ( F ` x ) ∧ ¬ x G y ) ↔ ¬ x G ( F ` x ) ) ;;
	step 20 : wff = syl6bbr (step 15, step 19) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ( F ` x ) ≠ ( G ` x ) ↔ ∃ y ( y = ( F ` x ) ∧ ¬ x G y ) ) ) ;;
	step 21 : wff = eqcom () |- ( y = ( F ` x ) ↔ ( F ` x ) = y ) ;;
	step 22 : wff = fnbrfvb () |- ( ( F Fn A ∧ x ∈ A ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 23 : wff = syl5bb (step 21, step 22) |- ( ( F Fn A ∧ x ∈ A ) → ( y = ( F ` x ) ↔ x F y ) ) ;;
	step 24 : wff = adantlr (step 23) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( y = ( F ` x ) ↔ x F y ) ) ;;
	step 25 : wff = anbi1d (step 24) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ( y = ( F ` x ) ∧ ¬ x G y ) ↔ ( x F y ∧ ¬ x G y ) ) ) ;;
	step 26 : wff = brdif () |- ( x ( F ∖ G ) y ↔ ( x F y ∧ ¬ x G y ) ) ;;
	step 27 : wff = syl6bbr (step 25, step 26) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ( y = ( F ` x ) ∧ ¬ x G y ) ↔ x ( F ∖ G ) y ) ) ;;
	step 28 : wff = exbidv (step 27) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ∃ y ( y = ( F ` x ) ∧ ¬ x G y ) ↔ ∃ y x ( F ∖ G ) y ) ) ;;
	step 29 : wff = bitr2d (step 20, step 28) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( ∃ y x ( F ∖ G ) y ↔ ( F ` x ) ≠ ( G ` x ) ) ) ;;
	step 30 : wff = syl5bb (step 10, step 29) |- ( ( ( F Fn A ∧ G Fn A ) ∧ x ∈ A ) → ( x ∈ dom ( F ∖ G ) ↔ ( F ` x ) ≠ ( G ` x ) ) ) ;;
	step 31 : wff = rabbi2dva (step 30) |- ( ( F Fn A ∧ G Fn A ) → ( A ∩ dom ( F ∖ G ) ) = { x ∈ A | ( F ` x ) ≠ ( G ` x ) } ) ;;
	step 32 : wff = eqtr3d (step 8, step 31) |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) = { x ∈ A | ( F ` x ) ≠ ( G ` x ) } ) ;;
	qed prop 1 = step 32 ;;
}

/*The difference set between two functions is commutative.  (Contributed
       by Stefan O'Rear, 17-Jan-2015.) */

theorem fndmdifcom (A : class, F : class, G : class) disjointed(F x, G x, A x) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) = dom ( G ∖ F ) ) ;;
}

proof of fndmdifcom {
	var x : set;;
	step 1 : wff = necom () |- ( ( F ` x ) ≠ ( G ` x ) ↔ ( G ` x ) ≠ ( F ` x ) ) ;;
	step 2 : wff = a1i (step 1) |- ( x ∈ A → ( ( F ` x ) ≠ ( G ` x ) ↔ ( G ` x ) ≠ ( F ` x ) ) ) ;;
	step 3 : wff = rabbiia (step 2) |- { x ∈ A | ( F ` x ) ≠ ( G ` x ) } = { x ∈ A | ( G ` x ) ≠ ( F ` x ) } ;;
	step 4 : wff = fndmdif () |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) = { x ∈ A | ( F ` x ) ≠ ( G ` x ) } ) ;;
	step 5 : wff = fndmdif () |- ( ( G Fn A ∧ F Fn A ) → dom ( G ∖ F ) = { x ∈ A | ( G ` x ) ≠ ( F ` x ) } ) ;;
	step 6 : wff = ancoms (step 5) |- ( ( F Fn A ∧ G Fn A ) → dom ( G ∖ F ) = { x ∈ A | ( G ` x ) ≠ ( F ` x ) } ) ;;
	step 7 : wff = 3eqtr4a (step 3, step 4, step 6) |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) = dom ( G ∖ F ) ) ;;
	qed prop 1 = step 7 ;;
}

/*The difference set of two functions is empty if and only if the
       functions are equal.  (Contributed by Stefan O'Rear, 17-Jan-2015.) */

theorem fndmdifeq0 (A : class, F : class, G : class) disjointed(F x, G x, A x) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → ( dom ( F ∖ G ) = ∅ ↔ F = G ) ) ;;
}

proof of fndmdifeq0 {
	var x : set;;
	step 1 : wff = fndmdif () |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∖ G ) = { x ∈ A | ( F ` x ) ≠ ( G ` x ) } ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( ( F Fn A ∧ G Fn A ) → ( dom ( F ∖ G ) = ∅ ↔ { x ∈ A | ( F ` x ) ≠ ( G ` x ) } = ∅ ) ) ;;
	step 3 : wff = eqfnfv () |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 4 : wff = rabeq0 () |- ( { x ∈ A | ( F ` x ) ≠ ( G ` x ) } = ∅ ↔ ∀ x ∈ A ¬ ( F ` x ) ≠ ( G ` x ) ) ;;
	step 5 : wff = nne () |- ( ¬ ( F ` x ) ≠ ( G ` x ) ↔ ( F ` x ) = ( G ` x ) ) ;;
	step 6 : wff = ralbii (step 5) |- ( ∀ x ∈ A ¬ ( F ` x ) ≠ ( G ` x ) ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 7 : wff = bitri (step 4, step 6) |- ( { x ∈ A | ( F ` x ) ≠ ( G ` x ) } = ∅ ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 8 : wff = syl6rbbr (step 3, step 7) |- ( ( F Fn A ∧ G Fn A ) → ( { x ∈ A | ( F ` x ) ≠ ( G ` x ) } = ∅ ↔ F = G ) ) ;;
	step 9 : wff = bitrd (step 2, step 8) |- ( ( F Fn A ∧ G Fn A ) → ( dom ( F ∖ G ) = ∅ ↔ F = G ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Two ways to express the locus of equality between two functions.
       (Contributed by Stefan O'Rear, 17-Jan-2015.) */

theorem fndmin (x : set, A : class, F : class, G : class) disjointed(F x y, G x y, A x y) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∩ G ) = { x ∈ A | ( F ` x ) = ( G ` x ) } ) ;;
}

proof of fndmin {
	var y : set;;
	step 1 : wff = dffn5 () |- ( F Fn A ↔ F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( F Fn A → F = ( x ∈ A ↦ ( F ` x ) ) ) ;;
	step 3 : wff = df-mpt () |- ( x ∈ A ↦ ( F ` x ) ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( F Fn A → F = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ) ;;
	step 5 : wff = dffn5 () |- ( G Fn A ↔ G = ( x ∈ A ↦ ( G ` x ) ) ) ;;
	step 6 : wff = biimpi (step 5) |- ( G Fn A → G = ( x ∈ A ↦ ( G ` x ) ) ) ;;
	step 7 : wff = df-mpt () |- ( x ∈ A ↦ ( G ` x ) ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( G ` x ) ) } ;;
	step 8 : wff = syl6eq (step 6, step 7) |- ( G Fn A → G = { 〈 x , y 〉 | ( x ∈ A ∧ y = ( G ` x ) ) } ) ;;
	step 9 : wff = ineqan12d (step 4, step 8) |- ( ( F Fn A ∧ G Fn A ) → ( F ∩ G ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ∩ { 〈 x , y 〉 | ( x ∈ A ∧ y = ( G ` x ) ) } ) ) ;;
	step 10 : wff = inopab () |- ( { 〈 x , y 〉 | ( x ∈ A ∧ y = ( F ` x ) ) } ∩ { 〈 x , y 〉 | ( x ∈ A ∧ y = ( G ` x ) ) } ) = { 〈 x , y 〉 | ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } ;;
	step 11 : wff = syl6eq (step 9, step 10) |- ( ( F Fn A ∧ G Fn A ) → ( F ∩ G ) = { 〈 x , y 〉 | ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } ) ;;
	step 12 : wff = dmeqd (step 11) |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∩ G ) = dom { 〈 x , y 〉 | ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } ) ;;
	step 13 : wff = 19.42v () |- ( ∃ y ( x ∈ A ∧ ( y = ( F ` x ) ∧ y = ( G ` x ) ) ) ↔ ( x ∈ A ∧ ∃ y ( y = ( F ` x ) ∧ y = ( G ` x ) ) ) ) ;;
	step 14 : wff = anandi () |- ( ( x ∈ A ∧ ( y = ( F ` x ) ∧ y = ( G ` x ) ) ) ↔ ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) ) ;;
	step 15 : wff = exbii (step 14) |- ( ∃ y ( x ∈ A ∧ ( y = ( F ` x ) ∧ y = ( G ` x ) ) ) ↔ ∃ y ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) ) ;;
	step 16 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 17 : wff = eqeq1 () |- ( y = ( F ` x ) → ( y = ( G ` x ) ↔ ( F ` x ) = ( G ` x ) ) ) ;;
	step 18 : wff = ceqsexv (step 16, step 17) |- ( ∃ y ( y = ( F ` x ) ∧ y = ( G ` x ) ) ↔ ( F ` x ) = ( G ` x ) ) ;;
	step 19 : wff = anbi2i (step 18) |- ( ( x ∈ A ∧ ∃ y ( y = ( F ` x ) ∧ y = ( G ` x ) ) ) ↔ ( x ∈ A ∧ ( F ` x ) = ( G ` x ) ) ) ;;
	step 20 : wff = 3bitr3i (step 13, step 15, step 19) |- ( ∃ y ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) ↔ ( x ∈ A ∧ ( F ` x ) = ( G ` x ) ) ) ;;
	step 21 : wff = abbii (step 20) |- { x | ∃ y ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } = { x | ( x ∈ A ∧ ( F ` x ) = ( G ` x ) ) } ;;
	step 22 : wff = dmopab () |- dom { 〈 x , y 〉 | ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } = { x | ∃ y ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } ;;
	step 23 : wff = df-rab () |- { x ∈ A | ( F ` x ) = ( G ` x ) } = { x | ( x ∈ A ∧ ( F ` x ) = ( G ` x ) ) } ;;
	step 24 : wff = 3eqtr4i (step 21, step 22, step 23) |- dom { 〈 x , y 〉 | ( ( x ∈ A ∧ y = ( F ` x ) ) ∧ ( x ∈ A ∧ y = ( G ` x ) ) ) } = { x ∈ A | ( F ` x ) = ( G ` x ) } ;;
	step 25 : wff = syl6eq (step 12, step 24) |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∩ G ) = { x ∈ A | ( F ` x ) = ( G ` x ) } ) ;;
	qed prop 1 = step 25 ;;
}

/*Two functions are equal iff their equalizer is the whole domain.
       (Contributed by Stefan O'Rear, 7-Mar-2015.) */

theorem fneqeql (A : class, F : class, G : class) disjointed(F x, G x, A x) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ dom ( F ∩ G ) = A ) ) ;;
}

proof of fneqeql {
	var x : set;;
	step 1 : wff = eqfnfv () |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ) ;;
	step 2 : wff = eqcom () |- ( { x ∈ A | ( F ` x ) = ( G ` x ) } = A ↔ A = { x ∈ A | ( F ` x ) = ( G ` x ) } ) ;;
	step 3 : wff = rabid2 () |- ( A = { x ∈ A | ( F ` x ) = ( G ` x ) } ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( { x ∈ A | ( F ` x ) = ( G ` x ) } = A ↔ ∀ x ∈ A ( F ` x ) = ( G ` x ) ) ;;
	step 5 : wff = syl6bbr (step 1, step 4) |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ { x ∈ A | ( F ` x ) = ( G ` x ) } = A ) ) ;;
	step 6 : wff = fndmin () |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∩ G ) = { x ∈ A | ( F ` x ) = ( G ` x ) } ) ;;
	step 7 : wff = eqeq1d (step 6) |- ( ( F Fn A ∧ G Fn A ) → ( dom ( F ∩ G ) = A ↔ { x ∈ A | ( F ` x ) = ( G ` x ) } = A ) ) ;;
	step 8 : wff = bitr4d (step 5, step 7) |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ dom ( F ∩ G ) = A ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Two functions are equal iff their equalizer contains the whole domain.
       (Contributed by Stefan O'Rear, 9-Mar-2015.) */

theorem fneqeql2 (A : class, F : class, G : class) disjointed(F, G, A) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ A ⊆ dom ( F ∩ G ) ) ) ;;
}

proof of fneqeql2 {
	step 1 : wff = fneqeql () |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ dom ( F ∩ G ) = A ) ) ;;
	step 2 : wff = inss1 () |- ( F ∩ G ) ⊆ F ;;
	step 3 : wff = dmss () |- ( ( F ∩ G ) ⊆ F → dom ( F ∩ G ) ⊆ dom F ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- dom ( F ∩ G ) ⊆ dom F ;;
	step 5 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 6 : wff = adantr (step 5) |- ( ( F Fn A ∧ G Fn A ) → dom F = A ) ;;
	step 7 : wff = syl5sseq (step 4, step 6) |- ( ( F Fn A ∧ G Fn A ) → dom ( F ∩ G ) ⊆ A ) ;;
	step 8 : wff = biantrurd (step 7) |- ( ( F Fn A ∧ G Fn A ) → ( A ⊆ dom ( F ∩ G ) ↔ ( dom ( F ∩ G ) ⊆ A ∧ A ⊆ dom ( F ∩ G ) ) ) ) ;;
	step 9 : wff = eqss () |- ( dom ( F ∩ G ) = A ↔ ( dom ( F ∩ G ) ⊆ A ∧ A ⊆ dom ( F ∩ G ) ) ) ;;
	step 10 : wff = syl6rbbr (step 8, step 9) |- ( ( F Fn A ∧ G Fn A ) → ( dom ( F ∩ G ) = A ↔ A ⊆ dom ( F ∩ G ) ) ) ;;
	step 11 : wff = bitrd (step 1, step 10) |- ( ( F Fn A ∧ G Fn A ) → ( F = G ↔ A ⊆ dom ( F ∩ G ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Two functions are equal on a subset iff their equalizer contains that
       subset.  (Contributed by Stefan O'Rear, 7-Mar-2015.) */

theorem fnreseql (A : class, F : class, G : class, X : class) disjointed(F, G, A) {
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn A ∧ X ⊆ A ) → ( ( F ↾ X ) = ( G ↾ X ) ↔ X ⊆ dom ( F ∩ G ) ) ) ;;
}

proof of fnreseql {
	step 1 : wff = fnssres () |- ( ( F Fn A ∧ X ⊆ A ) → ( F ↾ X ) Fn X ) ;;
	step 2 : wff = 3adant2 (step 1) |- ( ( F Fn A ∧ G Fn A ∧ X ⊆ A ) → ( F ↾ X ) Fn X ) ;;
	step 3 : wff = fnssres () |- ( ( G Fn A ∧ X ⊆ A ) → ( G ↾ X ) Fn X ) ;;
	step 4 : wff = 3adant1 (step 3) |- ( ( F Fn A ∧ G Fn A ∧ X ⊆ A ) → ( G ↾ X ) Fn X ) ;;
	step 5 : wff = fneqeql () |- ( ( ( F ↾ X ) Fn X ∧ ( G ↾ X ) Fn X ) → ( ( F ↾ X ) = ( G ↾ X ) ↔ dom ( ( F ↾ X ) ∩ ( G ↾ X ) ) = X ) ) ;;
	step 6 : wff = syl2anc (step 2, step 4, step 5) |- ( ( F Fn A ∧ G Fn A ∧ X ⊆ A ) → ( ( F ↾ X ) = ( G ↾ X ) ↔ dom ( ( F ↾ X ) ∩ ( G ↾ X ) ) = X ) ) ;;
	step 7 : wff = resindir () |- ( ( F ∩ G ) ↾ X ) = ( ( F ↾ X ) ∩ ( G ↾ X ) ) ;;
	step 8 : wff = dmeqi (step 7) |- dom ( ( F ∩ G ) ↾ X ) = dom ( ( F ↾ X ) ∩ ( G ↾ X ) ) ;;
	step 9 : wff = dmres () |- dom ( ( F ∩ G ) ↾ X ) = ( X ∩ dom ( F ∩ G ) ) ;;
	step 10 : wff = eqtr3i (step 8, step 9) |- dom ( ( F ↾ X ) ∩ ( G ↾ X ) ) = ( X ∩ dom ( F ∩ G ) ) ;;
	step 11 : wff = eqeq1i (step 10) |- ( dom ( ( F ↾ X ) ∩ ( G ↾ X ) ) = X ↔ ( X ∩ dom ( F ∩ G ) ) = X ) ;;
	step 12 : wff = df-ss () |- ( X ⊆ dom ( F ∩ G ) ↔ ( X ∩ dom ( F ∩ G ) ) = X ) ;;
	step 13 : wff = bitr4i (step 11, step 12) |- ( dom ( ( F ↾ X ) ∩ ( G ↾ X ) ) = X ↔ X ⊆ dom ( F ∩ G ) ) ;;
	step 14 : wff = syl6bb (step 6, step 13) |- ( ( F Fn A ∧ G Fn A ∧ X ⊆ A ) → ( ( F ↾ X ) = ( G ↾ X ) ↔ X ⊆ dom ( F ∩ G ) ) ) ;;
	qed prop 1 = step 14 ;;
}

/*The range of a choice function (a function that chooses an element from
       each member of its domain) is included in the union of its domain.
       (Contributed by NM, 31-Aug-1999.) */

theorem chfnrn (x : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ x ) → ran F ⊆ ⋃ A ) ;;
}

proof of chfnrn {
	var y : set;;
	step 1 : wff = fvelrnb () |- ( F Fn A → ( y ∈ ran F ↔ ∃ x ∈ A ( F ` x ) = y ) ) ;;
	step 2 : wff = biimpd (step 1) |- ( F Fn A → ( y ∈ ran F → ∃ x ∈ A ( F ` x ) = y ) ) ;;
	step 3 : wff = eleq1 () |- ( ( F ` x ) = y → ( ( F ` x ) ∈ x ↔ y ∈ x ) ) ;;
	step 4 : wff = biimpcd (step 3) |- ( ( F ` x ) ∈ x → ( ( F ` x ) = y → y ∈ x ) ) ;;
	step 5 : wff = ralimi (step 4) |- ( ∀ x ∈ A ( F ` x ) ∈ x → ∀ x ∈ A ( ( F ` x ) = y → y ∈ x ) ) ;;
	step 6 : wff = rexim () |- ( ∀ x ∈ A ( ( F ` x ) = y → y ∈ x ) → ( ∃ x ∈ A ( F ` x ) = y → ∃ x ∈ A y ∈ x ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ∀ x ∈ A ( F ` x ) ∈ x → ( ∃ x ∈ A ( F ` x ) = y → ∃ x ∈ A y ∈ x ) ) ;;
	step 8 : wff = sylan9 (step 2, step 7) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ x ) → ( y ∈ ran F → ∃ x ∈ A y ∈ x ) ) ;;
	step 9 : wff = eluni2 () |- ( y ∈ ⋃ A ↔ ∃ x ∈ A y ∈ x ) ;;
	step 10 : wff = syl6ibr (step 8, step 9) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ x ) → ( y ∈ ran F → y ∈ ⋃ A ) ) ;;
	step 11 : wff = ssrdv (step 10) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ x ) → ran F ⊆ ⋃ A ) ;;
	qed prop 1 = step 11 ;;
}

/*Ordered pair with function value.  Part of Theorem 4.3(i) of [Monk1]
       p. 41.  (Contributed by NM, 14-Oct-1996.) */

theorem funfvop (A : class, F : class) disjointed(F, A) {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ dom F ) → 〈 A , ( F ` A ) 〉 ∈ F ) ;;
}

proof of funfvop {
	step 1 : wff = eqid () |- ( F ` A ) = ( F ` A ) ;;
	step 2 : wff = funopfvb () |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) = ( F ` A ) ↔ 〈 A , ( F ` A ) 〉 ∈ F ) ) ;;
	step 3 : wff = mpbii (step 1, step 2) |- ( ( Fun F ∧ A ∈ dom F ) → 〈 A , ( F ` A ) 〉 ∈ F ) ;;
	qed prop 1 = step 3 ;;
}

/*Two ways to say that ` A ` is in the domain of ` F ` .  (Contributed by
     Mario Carneiro, 1-May-2014.) */

theorem funfvbrb (A : class, F : class)  {
	prop 1 : wff = |- ( Fun F → ( A ∈ dom F ↔ A F ( F ` A ) ) ) ;;
}

proof of funfvbrb {
	step 1 : wff = funfvop () |- ( ( Fun F ∧ A ∈ dom F ) → 〈 A , ( F ` A ) 〉 ∈ F ) ;;
	step 2 : wff = df-br () |- ( A F ( F ` A ) ↔ 〈 A , ( F ` A ) 〉 ∈ F ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ( Fun F ∧ A ∈ dom F ) → A F ( F ` A ) ) ;;
	step 4 : wff = funrel () |- ( Fun F → Rel F ) ;;
	step 5 : wff = releldm () |- ( ( Rel F ∧ A F ( F ` A ) ) → A ∈ dom F ) ;;
	step 6 : wff = sylan (step 4, step 5) |- ( ( Fun F ∧ A F ( F ` A ) ) → A ∈ dom F ) ;;
	step 7 : wff = impbida (step 3, step 6) |- ( Fun F → ( A ∈ dom F ↔ A F ( F ` A ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A member of a preimage is a function value argument.  (Contributed by NM,
     4-May-2007.) */

theorem fvimacnvi (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → ( F ` A ) ∈ B ) ;;
}

proof of fvimacnvi {
	step 1 : wff = snssi () |- ( A ∈ ( ⁻¹ F " B ) → { A } ⊆ ( ⁻¹ F " B ) ) ;;
	step 2 : wff = funimass2 () |- ( ( Fun F ∧ { A } ⊆ ( ⁻¹ F " B ) ) → ( F " { A } ) ⊆ B ) ;;
	step 3 : wff = sylan2 (step 1, step 2) |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → ( F " { A } ) ⊆ B ) ;;
	step 4 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 5 : wff = snss (step 4) |- ( ( F ` A ) ∈ B ↔ { ( F ` A ) } ⊆ B ) ;;
	step 6 : wff = cnvimass () |- ( ⁻¹ F " B ) ⊆ dom F ;;
	step 7 : wff = sseli (step 6) |- ( A ∈ ( ⁻¹ F " B ) → A ∈ dom F ) ;;
	step 8 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 9 : wff = fnsnfv () |- ( ( F Fn dom F ∧ A ∈ dom F ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 10 : wff = sylanb (step 8, step 9) |- ( ( Fun F ∧ A ∈ dom F ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 11 : wff = sylan2 (step 7, step 10) |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 12 : wff = sseq1d (step 11) |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → ( { ( F ` A ) } ⊆ B ↔ ( F " { A } ) ⊆ B ) ) ;;
	step 13 : wff = syl5bb (step 5, step 12) |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → ( ( F ` A ) ∈ B ↔ ( F " { A } ) ⊆ B ) ) ;;
	step 14 : wff = mpbird (step 3, step 13) |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → ( F ` A ) ∈ B ) ;;
	qed prop 1 = step 14 ;;
}

/*The argument of a function value belongs to the preimage of any class
     containing the function value.  Raph Levien remarks:  "This proof is
     unsatisfying, because it seems to me that ~ funimass2 could probably be
     strengthened to a biconditional."  (Contributed by Raph Levien,
     20-Nov-2006.) */

theorem fvimacnv (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) ∈ B ↔ A ∈ ( ⁻¹ F " B ) ) ) ;;
}

proof of fvimacnv {
	step 1 : wff = funfvop () |- ( ( Fun F ∧ A ∈ dom F ) → 〈 A , ( F ` A ) 〉 ∈ F ) ;;
	step 2 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 3 : wff = opelcnvg () |- ( ( ( F ` A ) ∈ _V ∧ A ∈ dom F ) → ( 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ↔ 〈 A , ( F ` A ) 〉 ∈ F ) ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( A ∈ dom F → ( 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ↔ 〈 A , ( F ` A ) 〉 ∈ F ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( Fun F ∧ A ∈ dom F ) → ( 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ↔ 〈 A , ( F ` A ) 〉 ∈ F ) ) ;;
	step 6 : wff = mpbird (step 1, step 5) |- ( ( Fun F ∧ A ∈ dom F ) → 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ) ;;
	step 7 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 8 : wff = elimasng () |- ( ( ( F ` A ) ∈ _V ∧ A ∈ dom F ) → ( A ∈ ( ⁻¹ F " { ( F ` A ) } ) ↔ 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ) ) ;;
	step 9 : wff = mpan (step 7, step 8) |- ( A ∈ dom F → ( A ∈ ( ⁻¹ F " { ( F ` A ) } ) ↔ 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ) ) ;;
	step 10 : wff = adantl (step 9) |- ( ( Fun F ∧ A ∈ dom F ) → ( A ∈ ( ⁻¹ F " { ( F ` A ) } ) ↔ 〈 ( F ` A ) , A 〉 ∈ ⁻¹ F ) ) ;;
	step 11 : wff = mpbird (step 6, step 10) |- ( ( Fun F ∧ A ∈ dom F ) → A ∈ ( ⁻¹ F " { ( F ` A ) } ) ) ;;
	step 12 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 13 : wff = snss (step 12) |- ( ( F ` A ) ∈ B ↔ { ( F ` A ) } ⊆ B ) ;;
	step 14 : wff = imass2 () |- ( { ( F ` A ) } ⊆ B → ( ⁻¹ F " { ( F ` A ) } ) ⊆ ( ⁻¹ F " B ) ) ;;
	step 15 : wff = sylbi (step 13, step 14) |- ( ( F ` A ) ∈ B → ( ⁻¹ F " { ( F ` A ) } ) ⊆ ( ⁻¹ F " B ) ) ;;
	step 16 : wff = sseld (step 15) |- ( ( F ` A ) ∈ B → ( A ∈ ( ⁻¹ F " { ( F ` A ) } ) → A ∈ ( ⁻¹ F " B ) ) ) ;;
	step 17 : wff = syl5com (step 11, step 16) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) ∈ B → A ∈ ( ⁻¹ F " B ) ) ) ;;
	step 18 : wff = fvimacnvi () |- ( ( Fun F ∧ A ∈ ( ⁻¹ F " B ) ) → ( F ` A ) ∈ B ) ;;
	step 19 : wff = ex (step 18) |- ( Fun F → ( A ∈ ( ⁻¹ F " B ) → ( F ` A ) ∈ B ) ) ;;
	step 20 : wff = adantr (step 19) |- ( ( Fun F ∧ A ∈ dom F ) → ( A ∈ ( ⁻¹ F " B ) → ( F ` A ) ∈ B ) ) ;;
	step 21 : wff = impbid (step 17, step 20) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) ∈ B ↔ A ∈ ( ⁻¹ F " B ) ) ) ;;
	qed prop 1 = step 21 ;;
}

/*A kind of contraposition law that infers an image subclass from a
       subclass of a preimage.  Raph Levien remarks:  "Likely this could be
       proved directly, and ~ fvimacnv would be the special case of ` A ` being
       a singleton, but it works this way round too."  (Contributed by Raph
       Levien, 20-Nov-2006.) */

theorem funimass3 (A : class, B : class, F : class) disjointed(F x, A x, B x) {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ A ⊆ ( ⁻¹ F " B ) ) ) ;;
}

proof of funimass3 {
	var x : set;;
	step 1 : wff = funimass4 () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 2 : wff = ssel () |- ( A ⊆ dom F → ( x ∈ A → x ∈ dom F ) ) ;;
	step 3 : wff = fvimacnv () |- ( ( Fun F ∧ x ∈ dom F ) → ( ( F ` x ) ∈ B ↔ x ∈ ( ⁻¹ F " B ) ) ) ;;
	step 4 : wff = ex (step 3) |- ( Fun F → ( x ∈ dom F → ( ( F ` x ) ∈ B ↔ x ∈ ( ⁻¹ F " B ) ) ) ) ;;
	step 5 : wff = syl9r (step 2, step 4) |- ( Fun F → ( A ⊆ dom F → ( x ∈ A → ( ( F ` x ) ∈ B ↔ x ∈ ( ⁻¹ F " B ) ) ) ) ) ;;
	step 6 : wff = imp31 (step 5) |- ( ( ( Fun F ∧ A ⊆ dom F ) ∧ x ∈ A ) → ( ( F ` x ) ∈ B ↔ x ∈ ( ⁻¹ F " B ) ) ) ;;
	step 7 : wff = ralbidva (step 6) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ∀ x ∈ A ( F ` x ) ∈ B ↔ ∀ x ∈ A x ∈ ( ⁻¹ F " B ) ) ) ;;
	step 8 : wff = bitrd (step 1, step 7) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ ∀ x ∈ A x ∈ ( ⁻¹ F " B ) ) ) ;;
	step 9 : wff = dfss3 () |- ( A ⊆ ( ⁻¹ F " B ) ↔ ∀ x ∈ A x ∈ ( ⁻¹ F " B ) ) ;;
	step 10 : wff = syl6bbr (step 8, step 9) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ A ⊆ ( ⁻¹ F " B ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*A subclass of a preimage in terms of function values.  (Contributed by
       NM, 15-May-2007.) */

theorem funimass5 (x : set, A : class, B : class, F : class) disjointed(F x, A x, B x) {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( A ⊆ ( ⁻¹ F " B ) ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
}

proof of funimass5 {
	step 1 : wff = funimass3 () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ A ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 2 : wff = funimass4 () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 3 : wff = bitr3d (step 1, step 2) |- ( ( Fun F ∧ A ⊆ dom F ) → ( A ⊆ ( ⁻¹ F " B ) ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Two ways of specifying that a function is constant on a subdomain.
       (Contributed by NM, 8-Mar-2007.) */

theorem funconstss (x : set, A : class, B : class, F : class) disjointed(F x, A x, B x) {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( ∀ x ∈ A ( F ` x ) = B ↔ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
}

proof of funconstss {
	step 1 : wff = funimass4 () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ { B } ↔ ∀ x ∈ A ( F ` x ) ∈ { B } ) ) ;;
	step 2 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 3 : wff = elsnc (step 2) |- ( ( F ` x ) ∈ { B } ↔ ( F ` x ) = B ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ x ∈ A ( F ` x ) ∈ { B } ↔ ∀ x ∈ A ( F ` x ) = B ) ;;
	step 5 : wff = syl6rbb (step 1, step 4) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ∀ x ∈ A ( F ` x ) = B ↔ ( F " A ) ⊆ { B } ) ) ;;
	step 6 : wff = funimass3 () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ { B } ↔ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	step 7 : wff = bitrd (step 5, step 6) |- ( ( Fun F ∧ A ⊆ dom F ) → ( ∀ x ∈ A ( F ` x ) = B ↔ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Another proof of ~ fvimacnv , based on ~ funimass3 .  If ~ funimass3 is
     ever proved directly, as opposed to using ~ funimacnv pointwise, then the
     proof of ~ funimacnv should be replaced with this one.  (Contributed by
     Raph Levien, 20-Nov-2006.)  (Proof modification is discouraged.)
     (New usage is discouraged.) */

theorem fvimacnvALT (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) ∈ B ↔ A ∈ ( ⁻¹ F " B ) ) ) ;;
}

proof of fvimacnvALT {
	step 1 : wff = snssi () |- ( A ∈ dom F → { A } ⊆ dom F ) ;;
	step 2 : wff = funimass3 () |- ( ( Fun F ∧ { A } ⊆ dom F ) → ( ( F " { A } ) ⊆ B ↔ { A } ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 3 : wff = sylan2 (step 1, step 2) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F " { A } ) ⊆ B ↔ { A } ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 4 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 5 : wff = snss (step 4) |- ( ( F ` A ) ∈ B ↔ { ( F ` A ) } ⊆ B ) ;;
	step 6 : wff = eqid () |- dom F = dom F ;;
	step 7 : wff = df-fn () |- ( F Fn dom F ↔ ( Fun F ∧ dom F = dom F ) ) ;;
	step 8 : wff = biimpri (step 7) |- ( ( Fun F ∧ dom F = dom F ) → F Fn dom F ) ;;
	step 9 : wff = mpan2 (step 6, step 8) |- ( Fun F → F Fn dom F ) ;;
	step 10 : wff = fnsnfv () |- ( ( F Fn dom F ∧ A ∈ dom F ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 11 : wff = sylan (step 9, step 10) |- ( ( Fun F ∧ A ∈ dom F ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 12 : wff = sseq1d (step 11) |- ( ( Fun F ∧ A ∈ dom F ) → ( { ( F ` A ) } ⊆ B ↔ ( F " { A } ) ⊆ B ) ) ;;
	step 13 : wff = syl5bb (step 5, step 12) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) ∈ B ↔ ( F " { A } ) ⊆ B ) ) ;;
	step 14 : wff = snssg () |- ( A ∈ dom F → ( A ∈ ( ⁻¹ F " B ) ↔ { A } ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 15 : wff = adantl (step 14) |- ( ( Fun F ∧ A ∈ dom F ) → ( A ∈ ( ⁻¹ F " B ) ↔ { A } ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 16 : wff = 3bitr4d (step 3, step 13, step 15) |- ( ( Fun F ∧ A ∈ dom F ) → ( ( F ` A ) ∈ B ↔ A ∈ ( ⁻¹ F " B ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/*Membership in the preimage of a set under a function.  (Contributed by
     Jeff Madsen, 2-Sep-2009.) */

theorem elpreima (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( F Fn A → ( B ∈ ( ⁻¹ F " C ) ↔ ( B ∈ A ∧ ( F ` B ) ∈ C ) ) ) ;;
}

proof of elpreima {
	step 1 : wff = cnvimass () |- ( ⁻¹ F " C ) ⊆ dom F ;;
	step 2 : wff = sseli (step 1) |- ( B ∈ ( ⁻¹ F " C ) → B ∈ dom F ) ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = eleq2d (step 3) |- ( F Fn A → ( B ∈ dom F ↔ B ∈ A ) ) ;;
	step 5 : wff = syl5ib (step 2, step 4) |- ( F Fn A → ( B ∈ ( ⁻¹ F " C ) → B ∈ A ) ) ;;
	step 6 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 7 : wff = fvimacnvi () |- ( ( Fun F ∧ B ∈ ( ⁻¹ F " C ) ) → ( F ` B ) ∈ C ) ;;
	step 8 : wff = sylan (step 6, step 7) |- ( ( F Fn A ∧ B ∈ ( ⁻¹ F " C ) ) → ( F ` B ) ∈ C ) ;;
	step 9 : wff = ex (step 8) |- ( F Fn A → ( B ∈ ( ⁻¹ F " C ) → ( F ` B ) ∈ C ) ) ;;
	step 10 : wff = jcad (step 5, step 9) |- ( F Fn A → ( B ∈ ( ⁻¹ F " C ) → ( B ∈ A ∧ ( F ` B ) ∈ C ) ) ) ;;
	step 11 : wff = fvimacnv () |- ( ( Fun F ∧ B ∈ dom F ) → ( ( F ` B ) ∈ C ↔ B ∈ ( ⁻¹ F " C ) ) ) ;;
	step 12 : wff = funfni (step 11) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) ∈ C ↔ B ∈ ( ⁻¹ F " C ) ) ) ;;
	step 13 : wff = biimpd (step 12) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ` B ) ∈ C → B ∈ ( ⁻¹ F " C ) ) ) ;;
	step 14 : wff = expimpd (step 13) |- ( F Fn A → ( ( B ∈ A ∧ ( F ` B ) ∈ C ) → B ∈ ( ⁻¹ F " C ) ) ) ;;
	step 15 : wff = impbid (step 10, step 14) |- ( F Fn A → ( B ∈ ( ⁻¹ F " C ) ↔ ( B ∈ A ∧ ( F ` B ) ∈ C ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Membership in the preimage of a singleton, under a function.
       (Contributed by Mario Carneiro, 12-May-2014.)  (Proof shortened by Mario
       Carneiro, 28-Apr-2015.) */

theorem fniniseg (A : class, B : class, C : class, F : class) disjointed(B, C, F) {
	prop 1 : wff = |- ( F Fn A → ( C ∈ ( ⁻¹ F " { B } ) ↔ ( C ∈ A ∧ ( F ` C ) = B ) ) ) ;;
}

proof of fniniseg {
	step 1 : wff = elpreima () |- ( F Fn A → ( C ∈ ( ⁻¹ F " { B } ) ↔ ( C ∈ A ∧ ( F ` C ) ∈ { B } ) ) ) ;;
	step 2 : wff = fvex () |- ( F ` C ) ∈ _V ;;
	step 3 : wff = elsnc (step 2) |- ( ( F ` C ) ∈ { B } ↔ ( F ` C ) = B ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( C ∈ A ∧ ( F ` C ) ∈ { B } ) ↔ ( C ∈ A ∧ ( F ` C ) = B ) ) ;;
	step 5 : wff = syl6bb (step 1, step 4) |- ( F Fn A → ( C ∈ ( ⁻¹ F " { B } ) ↔ ( C ∈ A ∧ ( F ` C ) = B ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Inverse images under functions expressed as abstractions.  (Contributed
       by Stefan O'Rear, 1-Feb-2015.) */

theorem fncnvima2 (x : set, A : class, B : class, F : class) disjointed(x A, x F, x B) {
	prop 1 : wff = |- ( F Fn A → ( ⁻¹ F " B ) = { x ∈ A | ( F ` x ) ∈ B } ) ;;
}

proof of fncnvima2 {
	step 1 : wff = elpreima () |- ( F Fn A → ( x ∈ ( ⁻¹ F " B ) ↔ ( x ∈ A ∧ ( F ` x ) ∈ B ) ) ) ;;
	step 2 : wff = abbi2dv (step 1) |- ( F Fn A → ( ⁻¹ F " B ) = { x | ( x ∈ A ∧ ( F ` x ) ∈ B ) } ) ;;
	step 3 : wff = df-rab () |- { x ∈ A | ( F ` x ) ∈ B } = { x | ( x ∈ A ∧ ( F ` x ) ∈ B ) } ;;
	step 4 : wff = syl6eqr (step 2, step 3) |- ( F Fn A → ( ⁻¹ F " B ) = { x ∈ A | ( F ` x ) ∈ B } ) ;;
	qed prop 1 = step 4 ;;
}

/*Inverse point images under functions expressed as abstractions.
       (Contributed by Stefan O'Rear, 1-Feb-2015.) */

theorem fniniseg2 (x : set, A : class, B : class, F : class) disjointed(x A, x F, x B) {
	prop 1 : wff = |- ( F Fn A → ( ⁻¹ F " { B } ) = { x ∈ A | ( F ` x ) = B } ) ;;
}

proof of fniniseg2 {
	step 1 : wff = fncnvima2 () |- ( F Fn A → ( ⁻¹ F " { B } ) = { x ∈ A | ( F ` x ) ∈ { B } } ) ;;
	step 2 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 3 : wff = elsnc (step 2) |- ( ( F ` x ) ∈ { B } ↔ ( F ` x ) = B ) ;;
	step 4 : wff = a1i (step 3) |- ( x ∈ A → ( ( F ` x ) ∈ { B } ↔ ( F ` x ) = B ) ) ;;
	step 5 : wff = rabbiia (step 4) |- { x ∈ A | ( F ` x ) ∈ { B } } = { x ∈ A | ( F ` x ) = B } ;;
	step 6 : wff = syl6eq (step 1, step 5) |- ( F Fn A → ( ⁻¹ F " { B } ) = { x ∈ A | ( F ` x ) = B } ) ;;
	qed prop 1 = step 6 ;;
}

/*Support sets of functions expressed as abstractions.  (Contributed by
       Stefan O'Rear, 1-Feb-2015.) */

theorem fnniniseg2 (x : set, A : class, B : class, F : class) disjointed(x A, x F, x B) {
	prop 1 : wff = |- ( F Fn A → ( ⁻¹ F " ( _V ∖ { B } ) ) = { x ∈ A | ( F ` x ) ≠ B } ) ;;
}

proof of fnniniseg2 {
	step 1 : wff = fncnvima2 () |- ( F Fn A → ( ⁻¹ F " ( _V ∖ { B } ) ) = { x ∈ A | ( F ` x ) ∈ ( _V ∖ { B } ) } ) ;;
	step 2 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 3 : wff = eldifsn () |- ( ( F ` x ) ∈ ( _V ∖ { B } ) ↔ ( ( F ` x ) ∈ _V ∧ ( F ` x ) ≠ B ) ) ;;
	step 4 : wff = mpbiran (step 2, step 3) |- ( ( F ` x ) ∈ ( _V ∖ { B } ) ↔ ( F ` x ) ≠ B ) ;;
	step 5 : wff = a1i (step 4) |- ( x ∈ A → ( ( F ` x ) ∈ ( _V ∖ { B } ) ↔ ( F ` x ) ≠ B ) ) ;;
	step 6 : wff = rabbiia (step 5) |- { x ∈ A | ( F ` x ) ∈ ( _V ∖ { B } ) } = { x ∈ A | ( F ` x ) ≠ B } ;;
	step 7 : wff = syl6eq (step 1, step 6) |- ( F Fn A → ( ⁻¹ F " ( _V ∖ { B } ) ) = { x ∈ A | ( F ` x ) ≠ B } ) ;;
	qed prop 1 = step 7 ;;
}

/*Existential quantification restricted to a support.  (Contributed by
       Stefan O'Rear, 23-Mar-2015.) */

theorem rexsupp (ph : wff, x : set, A : class, F : class, Z : class) disjointed(F x, A x) {
	prop 1 : wff = |- ( F Fn A → ( ∃ x ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ph ↔ ∃ x ∈ A ( ( F ` x ) ≠ Z ∧ ph ) ) ) ;;
}

proof of rexsupp {
	step 1 : wff = elpreima () |- ( F Fn A → ( x ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ↔ ( x ∈ A ∧ ( F ` x ) ∈ ( _V ∖ { Z } ) ) ) ) ;;
	step 2 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 3 : wff = eldifsn () |- ( ( F ` x ) ∈ ( _V ∖ { Z } ) ↔ ( ( F ` x ) ∈ _V ∧ ( F ` x ) ≠ Z ) ) ;;
	step 4 : wff = mpbiran (step 2, step 3) |- ( ( F ` x ) ∈ ( _V ∖ { Z } ) ↔ ( F ` x ) ≠ Z ) ;;
	step 5 : wff = anbi2i (step 4) |- ( ( x ∈ A ∧ ( F ` x ) ∈ ( _V ∖ { Z } ) ) ↔ ( x ∈ A ∧ ( F ` x ) ≠ Z ) ) ;;
	step 6 : wff = syl6bb (step 1, step 5) |- ( F Fn A → ( x ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ↔ ( x ∈ A ∧ ( F ` x ) ≠ Z ) ) ) ;;
	step 7 : wff = anbi1d (step 6) |- ( F Fn A → ( ( x ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ∧ ph ) ↔ ( ( x ∈ A ∧ ( F ` x ) ≠ Z ) ∧ ph ) ) ) ;;
	step 8 : wff = anass () |- ( ( ( x ∈ A ∧ ( F ` x ) ≠ Z ) ∧ ph ) ↔ ( x ∈ A ∧ ( ( F ` x ) ≠ Z ∧ ph ) ) ) ;;
	step 9 : wff = syl6bb (step 7, step 8) |- ( F Fn A → ( ( x ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ∧ ph ) ↔ ( x ∈ A ∧ ( ( F ` x ) ≠ Z ∧ ph ) ) ) ) ;;
	step 10 : wff = rexbidv2 (step 9) |- ( F Fn A → ( ∃ x ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ph ↔ ∃ x ∈ A ( ( F ` x ) ≠ Z ∧ ph ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Preimage of a union.  (Contributed by Jeff Madsen, 2-Sep-2009.) */

theorem unpreima (A : class, B : class, F : class) disjointed(x F, x A, x B) {
	prop 1 : wff = |- ( Fun F → ( ⁻¹ F " ( A ∪ B ) ) = ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ) ;;
}

proof of unpreima {
	var x : set;;
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = elpreima () |- ( F Fn dom F → ( x ∈ ( ⁻¹ F " ( A ∪ B ) ) ↔ ( x ∈ dom F ∧ ( F ` x ) ∈ ( A ∪ B ) ) ) ) ;;
	step 3 : wff = elun () |- ( x ∈ ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ↔ ( x ∈ ( ⁻¹ F " A ) ∨ x ∈ ( ⁻¹ F " B ) ) ) ;;
	step 4 : wff = elpreima () |- ( F Fn dom F → ( x ∈ ( ⁻¹ F " A ) ↔ ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ) ) ;;
	step 5 : wff = elpreima () |- ( F Fn dom F → ( x ∈ ( ⁻¹ F " B ) ↔ ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ;;
	step 6 : wff = orbi12d (step 4, step 5) |- ( F Fn dom F → ( ( x ∈ ( ⁻¹ F " A ) ∨ x ∈ ( ⁻¹ F " B ) ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∨ ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ) ;;
	step 7 : wff = syl5bb (step 3, step 6) |- ( F Fn dom F → ( x ∈ ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∨ ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ) ;;
	step 8 : wff = elun () |- ( ( F ` x ) ∈ ( A ∪ B ) ↔ ( ( F ` x ) ∈ A ∨ ( F ` x ) ∈ B ) ) ;;
	step 9 : wff = anbi2i (step 8) |- ( ( x ∈ dom F ∧ ( F ` x ) ∈ ( A ∪ B ) ) ↔ ( x ∈ dom F ∧ ( ( F ` x ) ∈ A ∨ ( F ` x ) ∈ B ) ) ) ;;
	step 10 : wff = andi () |- ( ( x ∈ dom F ∧ ( ( F ` x ) ∈ A ∨ ( F ` x ) ∈ B ) ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∨ ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ;;
	step 11 : wff = bitri (step 9, step 10) |- ( ( x ∈ dom F ∧ ( F ` x ) ∈ ( A ∪ B ) ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∨ ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ;;
	step 12 : wff = syl6rbbr (step 7, step 11) |- ( F Fn dom F → ( ( x ∈ dom F ∧ ( F ` x ) ∈ ( A ∪ B ) ) ↔ x ∈ ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ) ) ;;
	step 13 : wff = bitrd (step 2, step 12) |- ( F Fn dom F → ( x ∈ ( ⁻¹ F " ( A ∪ B ) ) ↔ x ∈ ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ) ) ;;
	step 14 : wff = eqrdv (step 13) |- ( F Fn dom F → ( ⁻¹ F " ( A ∪ B ) ) = ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ) ;;
	step 15 : wff = sylbi (step 1, step 14) |- ( Fun F → ( ⁻¹ F " ( A ∪ B ) ) = ( ( ⁻¹ F " A ) ∪ ( ⁻¹ F " B ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Preimage of an intersection.  (Contributed by Jeff Madsen, 2-Sep-2009.)
       (Proof shortened by Mario Carneiro, 14-Jun-2016.) */

theorem inpreima (A : class, B : class, F : class) disjointed(F, A, B) {
	prop 1 : wff = |- ( Fun F → ( ⁻¹ F " ( A ∩ B ) ) = ( ( ⁻¹ F " A ) ∩ ( ⁻¹ F " B ) ) ) ;;
}

proof of inpreima {
	step 1 : wff = funcnvcnv () |- ( Fun F → Fun ⁻¹ ⁻¹ F ) ;;
	step 2 : wff = imain () |- ( Fun ⁻¹ ⁻¹ F → ( ⁻¹ F " ( A ∩ B ) ) = ( ( ⁻¹ F " A ) ∩ ( ⁻¹ F " B ) ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( Fun F → ( ⁻¹ F " ( A ∩ B ) ) = ( ( ⁻¹ F " A ) ∩ ( ⁻¹ F " B ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Preimage of a difference.  (Contributed by Mario Carneiro,
       14-Jun-2016.) */

theorem difpreima (A : class, B : class, F : class) disjointed(F, A, B) {
	prop 1 : wff = |- ( Fun F → ( ⁻¹ F " ( A ∖ B ) ) = ( ( ⁻¹ F " A ) ∖ ( ⁻¹ F " B ) ) ) ;;
}

proof of difpreima {
	step 1 : wff = funcnvcnv () |- ( Fun F → Fun ⁻¹ ⁻¹ F ) ;;
	step 2 : wff = imadif () |- ( Fun ⁻¹ ⁻¹ F → ( ⁻¹ F " ( A ∖ B ) ) = ( ( ⁻¹ F " A ) ∖ ( ⁻¹ F " B ) ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( Fun F → ( ⁻¹ F " ( A ∖ B ) ) = ( ( ⁻¹ F " A ) ∖ ( ⁻¹ F " B ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The preimage of a restricted function.  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem respreima (A : class, B : class, F : class) disjointed(x F, x A, x B) {
	prop 1 : wff = |- ( Fun F → ( ⁻¹ ( F ↾ B ) " A ) = ( ( ⁻¹ F " A ) ∩ B ) ) ;;
}

proof of respreima {
	var x : set;;
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = elin () |- ( x ∈ ( B ∩ dom F ) ↔ ( x ∈ B ∧ x ∈ dom F ) ) ;;
	step 3 : wff = ancom () |- ( ( x ∈ B ∧ x ∈ dom F ) ↔ ( x ∈ dom F ∧ x ∈ B ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( x ∈ ( B ∩ dom F ) ↔ ( x ∈ dom F ∧ x ∈ B ) ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( x ∈ ( B ∩ dom F ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ↔ ( ( x ∈ dom F ∧ x ∈ B ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ) ;;
	step 6 : wff = fvres () |- ( x ∈ B → ( ( F ↾ B ) ` x ) = ( F ` x ) ) ;;
	step 7 : wff = eleq1d (step 6) |- ( x ∈ B → ( ( ( F ↾ B ) ` x ) ∈ A ↔ ( F ` x ) ∈ A ) ) ;;
	step 8 : wff = adantl (step 7) |- ( ( x ∈ dom F ∧ x ∈ B ) → ( ( ( F ↾ B ) ` x ) ∈ A ↔ ( F ` x ) ∈ A ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( ( x ∈ dom F ∧ x ∈ B ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ↔ ( ( x ∈ dom F ∧ x ∈ B ) ∧ ( F ` x ) ∈ A ) ) ;;
	step 10 : wff = bitri (step 5, step 9) |- ( ( x ∈ ( B ∩ dom F ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ↔ ( ( x ∈ dom F ∧ x ∈ B ) ∧ ( F ` x ) ∈ A ) ) ;;
	step 11 : wff = a1i (step 10) |- ( F Fn dom F → ( ( x ∈ ( B ∩ dom F ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ↔ ( ( x ∈ dom F ∧ x ∈ B ) ∧ ( F ` x ) ∈ A ) ) ) ;;
	step 12 : wff = an32 () |- ( ( ( x ∈ dom F ∧ x ∈ B ) ∧ ( F ` x ) ∈ A ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∧ x ∈ B ) ) ;;
	step 13 : wff = syl6bb (step 11, step 12) |- ( F Fn dom F → ( ( x ∈ ( B ∩ dom F ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∧ x ∈ B ) ) ) ;;
	step 14 : wff = fnfun () |- ( F Fn dom F → Fun F ) ;;
	step 15 : wff = funres () |- ( Fun F → Fun ( F ↾ B ) ) ;;
	step 16 : wff = syl (step 14, step 15) |- ( F Fn dom F → Fun ( F ↾ B ) ) ;;
	step 17 : wff = dmres () |- dom ( F ↾ B ) = ( B ∩ dom F ) ;;
	step 18 : wff = jctir (step 16, step 17) |- ( F Fn dom F → ( Fun ( F ↾ B ) ∧ dom ( F ↾ B ) = ( B ∩ dom F ) ) ) ;;
	step 19 : wff = df-fn () |- ( ( F ↾ B ) Fn ( B ∩ dom F ) ↔ ( Fun ( F ↾ B ) ∧ dom ( F ↾ B ) = ( B ∩ dom F ) ) ) ;;
	step 20 : wff = sylibr (step 18, step 19) |- ( F Fn dom F → ( F ↾ B ) Fn ( B ∩ dom F ) ) ;;
	step 21 : wff = elpreima () |- ( ( F ↾ B ) Fn ( B ∩ dom F ) → ( x ∈ ( ⁻¹ ( F ↾ B ) " A ) ↔ ( x ∈ ( B ∩ dom F ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ) ) ;;
	step 22 : wff = syl (step 20, step 21) |- ( F Fn dom F → ( x ∈ ( ⁻¹ ( F ↾ B ) " A ) ↔ ( x ∈ ( B ∩ dom F ) ∧ ( ( F ↾ B ) ` x ) ∈ A ) ) ) ;;
	step 23 : wff = elin () |- ( x ∈ ( ( ⁻¹ F " A ) ∩ B ) ↔ ( x ∈ ( ⁻¹ F " A ) ∧ x ∈ B ) ) ;;
	step 24 : wff = elpreima () |- ( F Fn dom F → ( x ∈ ( ⁻¹ F " A ) ↔ ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ) ) ;;
	step 25 : wff = anbi1d (step 24) |- ( F Fn dom F → ( ( x ∈ ( ⁻¹ F " A ) ∧ x ∈ B ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∧ x ∈ B ) ) ) ;;
	step 26 : wff = syl5bb (step 23, step 25) |- ( F Fn dom F → ( x ∈ ( ( ⁻¹ F " A ) ∩ B ) ↔ ( ( x ∈ dom F ∧ ( F ` x ) ∈ A ) ∧ x ∈ B ) ) ) ;;
	step 27 : wff = 3bitr4d (step 13, step 22, step 26) |- ( F Fn dom F → ( x ∈ ( ⁻¹ ( F ↾ B ) " A ) ↔ x ∈ ( ( ⁻¹ F " A ) ∩ B ) ) ) ;;
	step 28 : wff = sylbi (step 1, step 27) |- ( Fun F → ( x ∈ ( ⁻¹ ( F ↾ B ) " A ) ↔ x ∈ ( ( ⁻¹ F " A ) ∩ B ) ) ) ;;
	step 29 : wff = eqrdv (step 28) |- ( Fun F → ( ⁻¹ ( F ↾ B ) " A ) = ( ( ⁻¹ F " A ) ∩ B ) ) ;;
	qed prop 1 = step 29 ;;
}

/*Preimage of an intersection.  (Contributed by FL, 16-Apr-2012.) */

theorem iinpreima (x : set, A : class, B : class, F : class) disjointed(A x y, B y, F x y) {
	prop 1 : wff = |- ( ( Fun F ∧ A ≠ ∅ ) → ( ⁻¹ F " ⋂_ x ∈ A B ) = ⋂_ x ∈ A ( ⁻¹ F " B ) ) ;;
}

proof of iinpreima {
	var y : set;;
	step 1 : wff = simpll () |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → Fun F ) ;;
	step 2 : wff = cnvimass () |- ( ⁻¹ F " ⋂_ x ∈ A B ) ⊆ dom F ;;
	step 3 : wff = sseli (step 2) |- ( y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) → y ∈ dom F ) ;;
	step 4 : wff = adantl (step 3) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → y ∈ dom F ) ;;
	step 5 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 6 : wff = fvimacnvi () |- ( ( Fun F ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → ( F ` y ) ∈ ⋂_ x ∈ A B ) ;;
	step 7 : wff = adantlr (step 6) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → ( F ` y ) ∈ ⋂_ x ∈ A B ) ;;
	step 8 : wff = eliin () |- ( ( F ` y ) ∈ _V → ( ( F ` y ) ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A ( F ` y ) ∈ B ) ) ;;
	step 9 : wff = biimpa (step 8) |- ( ( ( F ` y ) ∈ _V ∧ ( F ` y ) ∈ ⋂_ x ∈ A B ) → ∀ x ∈ A ( F ` y ) ∈ B ) ;;
	step 10 : wff = sylancr (step 5, step 7, step 9) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → ∀ x ∈ A ( F ` y ) ∈ B ) ;;
	step 11 : wff = fvimacnv () |- ( ( Fun F ∧ y ∈ dom F ) → ( ( F ` y ) ∈ B ↔ y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 12 : wff = ralbidv (step 11) |- ( ( Fun F ∧ y ∈ dom F ) → ( ∀ x ∈ A ( F ` y ) ∈ B ↔ ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 13 : wff = biimpa (step 12) |- ( ( ( Fun F ∧ y ∈ dom F ) ∧ ∀ x ∈ A ( F ` y ) ∈ B ) → ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ;;
	step 14 : wff = syl21anc (step 1, step 4, step 10, step 13) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = eliin () |- ( y ∈ _V → ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ↔ ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 17 : wff = ax-mp (step 15, step 16) |- ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ↔ ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ;;
	step 18 : wff = sylibr (step 14, step 17) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) → y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) ;;
	step 19 : wff = simpll () |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → Fun F ) ;;
	step 20 : wff = vex () |- y ∈ _V ;;
	step 21 : wff = eliin () |- ( y ∈ _V → ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ↔ ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 22 : wff = biimpd (step 21) |- ( y ∈ _V → ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) → ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 23 : wff = ax-mp (step 20, step 22) |- ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) → ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ;;
	step 24 : wff = adantl (step 23) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ;;
	step 25 : wff = fvimacnvi () |- ( ( Fun F ∧ y ∈ ( ⁻¹ F " B ) ) → ( F ` y ) ∈ B ) ;;
	step 26 : wff = ex (step 25) |- ( Fun F → ( y ∈ ( ⁻¹ F " B ) → ( F ` y ) ∈ B ) ) ;;
	step 27 : wff = ralimdv (step 26) |- ( Fun F → ( ∀ x ∈ A y ∈ ( ⁻¹ F " B ) → ∀ x ∈ A ( F ` y ) ∈ B ) ) ;;
	step 28 : wff = sylc (step 19, step 24, step 27) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → ∀ x ∈ A ( F ` y ) ∈ B ) ;;
	step 29 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 30 : wff = eliin () |- ( ( F ` y ) ∈ _V → ( ( F ` y ) ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A ( F ` y ) ∈ B ) ) ;;
	step 31 : wff = ax-mp (step 29, step 30) |- ( ( F ` y ) ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A ( F ` y ) ∈ B ) ;;
	step 32 : wff = sylibr (step 28, step 31) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → ( F ` y ) ∈ ⋂_ x ∈ A B ) ;;
	step 33 : wff = simpll () |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → Fun F ) ;;
	step 34 : wff = vex () |- y ∈ _V ;;
	step 35 : wff = eliin () |- ( y ∈ _V → ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ↔ ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 36 : wff = ax-mp (step 34, step 35) |- ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ↔ ∀ x ∈ A y ∈ ( ⁻¹ F " B ) ) ;;
	step 37 : wff = r19.2zb () |- ( A ≠ ∅ ↔ ( ∀ x ∈ A y ∈ ( ⁻¹ F " B ) → ∃ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 38 : wff = biimpi (step 37) |- ( A ≠ ∅ → ( ∀ x ∈ A y ∈ ( ⁻¹ F " B ) → ∃ x ∈ A y ∈ ( ⁻¹ F " B ) ) ) ;;
	step 39 : wff = cnvimass () |- ( ⁻¹ F " B ) ⊆ dom F ;;
	step 40 : wff = sseli (step 39) |- ( y ∈ ( ⁻¹ F " B ) → y ∈ dom F ) ;;
	step 41 : wff = rexlimivw (step 40) |- ( ∃ x ∈ A y ∈ ( ⁻¹ F " B ) → y ∈ dom F ) ;;
	step 42 : wff = syl6 (step 38, step 41) |- ( A ≠ ∅ → ( ∀ x ∈ A y ∈ ( ⁻¹ F " B ) → y ∈ dom F ) ) ;;
	step 43 : wff = syl5bi (step 36, step 42) |- ( A ≠ ∅ → ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) → y ∈ dom F ) ) ;;
	step 44 : wff = adantl (step 43) |- ( ( Fun F ∧ A ≠ ∅ ) → ( y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) → y ∈ dom F ) ) ;;
	step 45 : wff = imp (step 44) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → y ∈ dom F ) ;;
	step 46 : wff = fvimacnv () |- ( ( Fun F ∧ y ∈ dom F ) → ( ( F ` y ) ∈ ⋂_ x ∈ A B ↔ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) ) ;;
	step 47 : wff = syl2anc (step 33, step 45, step 46) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → ( ( F ` y ) ∈ ⋂_ x ∈ A B ↔ y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) ) ;;
	step 48 : wff = mpbid (step 32, step 47) |- ( ( ( Fun F ∧ A ≠ ∅ ) ∧ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) → y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ) ;;
	step 49 : wff = impbida (step 18, step 48) |- ( ( Fun F ∧ A ≠ ∅ ) → ( y ∈ ( ⁻¹ F " ⋂_ x ∈ A B ) ↔ y ∈ ⋂_ x ∈ A ( ⁻¹ F " B ) ) ) ;;
	step 50 : wff = eqrdv (step 49) |- ( ( Fun F ∧ A ≠ ∅ ) → ( ⁻¹ F " ⋂_ x ∈ A B ) = ⋂_ x ∈ A ( ⁻¹ F " B ) ) ;;
	qed prop 1 = step 50 ;;
}

/*Preimage of an intersection.  (Contributed by FL, 28-Apr-2012.) */

theorem intpreima (x : set, A : class, F : class) disjointed(A x, F x) {
	prop 1 : wff = |- ( ( Fun F ∧ A ≠ ∅ ) → ( ⁻¹ F " ⋂ A ) = ⋂_ x ∈ A ( ⁻¹ F " x ) ) ;;
}

proof of intpreima {
	step 1 : wff = intiin () |- ⋂ A = ⋂_ x ∈ A x ;;
	step 2 : wff = imaeq2i (step 1) |- ( ⁻¹ F " ⋂ A ) = ( ⁻¹ F " ⋂_ x ∈ A x ) ;;
	step 3 : wff = iinpreima () |- ( ( Fun F ∧ A ≠ ∅ ) → ( ⁻¹ F " ⋂_ x ∈ A x ) = ⋂_ x ∈ A ( ⁻¹ F " x ) ) ;;
	step 4 : wff = syl5eq (step 2, step 3) |- ( ( Fun F ∧ A ≠ ∅ ) → ( ⁻¹ F " ⋂ A ) = ⋂_ x ∈ A ( ⁻¹ F " x ) ) ;;
	qed prop 1 = step 4 ;;
}

/*The preimage of the codomain of a mapping is the mapping's domain.
     (Contributed by FL, 25-Jan-2007.) */

theorem fimacnv (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B → ( ⁻¹ F " B ) = A ) ;;
}

proof of fimacnv {
	step 1 : wff = imassrn () |- ( ⁻¹ F " B ) ⊆ ran ⁻¹ F ;;
	step 2 : wff = dfdm4 () |- dom F = ran ⁻¹ F ;;
	step 3 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 4 : wff = ssid () |- A ⊆ A ;;
	step 5 : wff = a1i (step 4) |- ( F : A ⟶ B → A ⊆ A ) ;;
	step 6 : wff = eqsstrd (step 3, step 5) |- ( F : A ⟶ B → dom F ⊆ A ) ;;
	step 7 : wff = syl5eqssr (step 2, step 6) |- ( F : A ⟶ B → ran ⁻¹ F ⊆ A ) ;;
	step 8 : wff = syl5ss (step 1, step 7) |- ( F : A ⟶ B → ( ⁻¹ F " B ) ⊆ A ) ;;
	step 9 : wff = imassrn () |- ( F " A ) ⊆ ran F ;;
	step 10 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 11 : wff = syl5ss (step 9, step 10) |- ( F : A ⟶ B → ( F " A ) ⊆ B ) ;;
	step 12 : wff = ffun () |- ( F : A ⟶ B → Fun F ) ;;
	step 13 : wff = ssid () |- A ⊆ A ;;
	step 14 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 15 : wff = syl5sseqr (step 13, step 14) |- ( F : A ⟶ B → A ⊆ dom F ) ;;
	step 16 : wff = funimass3 () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ( F " A ) ⊆ B ↔ A ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 17 : wff = syl2anc (step 12, step 15, step 16) |- ( F : A ⟶ B → ( ( F " A ) ⊆ B ↔ A ⊆ ( ⁻¹ F " B ) ) ) ;;
	step 18 : wff = mpbid (step 11, step 17) |- ( F : A ⟶ B → A ⊆ ( ⁻¹ F " B ) ) ;;
	step 19 : wff = eqssd (step 8, step 18) |- ( F : A ⟶ B → ( ⁻¹ F " B ) = A ) ;;
	qed prop 1 = step 19 ;;
}

/*Show that the support of a function is contained in a set.  (Contributed
       by Mario Carneiro, 19-Dec-2014.) */

theorem suppss (ph : wff, A : class, B : class, k : set, F : class, W : class, Z : class) disjointed(k F, k ph, k W, k Z) {
	hyp 1 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ k ∈ ( A ∖ W ) ) → ( F ` k ) = Z ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ W ) ;;
}

proof of suppss {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = elpreima () |- ( F Fn A → ( k ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ↔ ( k ∈ A ∧ ( F ` k ) ∈ ( _V ∖ { Z } ) ) ) ) ;;
	step 3 : wff = 3syl (hyp 1, step 1, step 2) |- ( ph → ( k ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ↔ ( k ∈ A ∧ ( F ` k ) ∈ ( _V ∖ { Z } ) ) ) ) ;;
	step 4 : wff = fvex () |- ( F ` k ) ∈ _V ;;
	step 5 : wff = eldifsn () |- ( ( F ` k ) ∈ ( _V ∖ { Z } ) ↔ ( ( F ` k ) ∈ _V ∧ ( F ` k ) ≠ Z ) ) ;;
	step 6 : wff = mpbiran (step 4, step 5) |- ( ( F ` k ) ∈ ( _V ∖ { Z } ) ↔ ( F ` k ) ≠ Z ) ;;
	step 7 : wff = eldif () |- ( k ∈ ( A ∖ W ) ↔ ( k ∈ A ∧ ¬ k ∈ W ) ) ;;
	step 8 : wff = sylan2br (step 7, hyp 2) |- ( ( ph ∧ ( k ∈ A ∧ ¬ k ∈ W ) ) → ( F ` k ) = Z ) ;;
	step 9 : wff = expr (step 8) |- ( ( ph ∧ k ∈ A ) → ( ¬ k ∈ W → ( F ` k ) = Z ) ) ;;
	step 10 : wff = necon1ad (step 9) |- ( ( ph ∧ k ∈ A ) → ( ( F ` k ) ≠ Z → k ∈ W ) ) ;;
	step 11 : wff = syl5bi (step 6, step 10) |- ( ( ph ∧ k ∈ A ) → ( ( F ` k ) ∈ ( _V ∖ { Z } ) → k ∈ W ) ) ;;
	step 12 : wff = expimpd (step 11) |- ( ph → ( ( k ∈ A ∧ ( F ` k ) ∈ ( _V ∖ { Z } ) ) → k ∈ W ) ) ;;
	step 13 : wff = sylbid (step 3, step 12) |- ( ph → ( k ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) → k ∈ W ) ) ;;
	step 14 : wff = ssrdv (step 13) |- ( ph → ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ W ) ;;
	qed prop 1 = step 14 ;;
}

/*A function is zero outside its support.  (Contributed by Mario Carneiro,
       19-Dec-2014.) */

theorem suppssr (ph : wff, A : class, B : class, F : class, W : class, X : class, Z : class)  {
	hyp 1 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 2 : wff = |- ( ph → ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ W ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ X ∈ ( A ∖ W ) ) → ( F ` X ) = Z ) ;;
}

proof of suppssr {
	step 1 : wff = eldif () |- ( X ∈ ( A ∖ W ) ↔ ( X ∈ A ∧ ¬ X ∈ W ) ) ;;
	step 2 : wff = fvex () |- ( F ` X ) ∈ _V ;;
	step 3 : wff = eldifsn () |- ( ( F ` X ) ∈ ( _V ∖ { Z } ) ↔ ( ( F ` X ) ∈ _V ∧ ( F ` X ) ≠ Z ) ) ;;
	step 4 : wff = mpbiran (step 2, step 3) |- ( ( F ` X ) ∈ ( _V ∖ { Z } ) ↔ ( F ` X ) ≠ Z ) ;;
	step 5 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 6 : wff = elpreima () |- ( F Fn A → ( X ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ↔ ( X ∈ A ∧ ( F ` X ) ∈ ( _V ∖ { Z } ) ) ) ) ;;
	step 7 : wff = 3syl (hyp 1, step 5, step 6) |- ( ph → ( X ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) ↔ ( X ∈ A ∧ ( F ` X ) ∈ ( _V ∖ { Z } ) ) ) ) ;;
	step 8 : wff = sseld (hyp 2) |- ( ph → ( X ∈ ( ⁻¹ F " ( _V ∖ { Z } ) ) → X ∈ W ) ) ;;
	step 9 : wff = sylbird (step 7, step 8) |- ( ph → ( ( X ∈ A ∧ ( F ` X ) ∈ ( _V ∖ { Z } ) ) → X ∈ W ) ) ;;
	step 10 : wff = expdimp (step 9) |- ( ( ph ∧ X ∈ A ) → ( ( F ` X ) ∈ ( _V ∖ { Z } ) → X ∈ W ) ) ;;
	step 11 : wff = syl5bir (step 4, step 10) |- ( ( ph ∧ X ∈ A ) → ( ( F ` X ) ≠ Z → X ∈ W ) ) ;;
	step 12 : wff = necon1bd (step 11) |- ( ( ph ∧ X ∈ A ) → ( ¬ X ∈ W → ( F ` X ) = Z ) ) ;;
	step 13 : wff = impr (step 12) |- ( ( ph ∧ ( X ∈ A ∧ ¬ X ∈ W ) ) → ( F ` X ) = Z ) ;;
	step 14 : wff = sylan2b (step 1, step 13) |- ( ( ph ∧ X ∈ ( A ∖ W ) ) → ( F ` X ) = Z ) ;;
	qed prop 1 = step 14 ;;
}

/*Ordered pair with function value.  Part of Theorem 4.3(i) of [Monk1]
     p. 41.  (Contributed by NM, 30-Sep-2004.) */

theorem fnopfv (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → 〈 B , ( F ` B ) 〉 ∈ F ) ;;
}

proof of fnopfv {
	step 1 : wff = funfvop () |- ( ( Fun F ∧ B ∈ dom F ) → 〈 B , ( F ` B ) 〉 ∈ F ) ;;
	step 2 : wff = funfni (step 1) |- ( ( F Fn A ∧ B ∈ A ) → 〈 B , ( F ` B ) 〉 ∈ F ) ;;
	qed prop 1 = step 2 ;;
}

/*A function's value belongs to its range.  (Contributed by NM,
       14-Oct-1996.) */

theorem fvelrn (A : class, F : class) disjointed(x y F, x A) {
	prop 1 : wff = |- ( ( Fun F ∧ A ∈ dom F ) → ( F ` A ) ∈ ran F ) ;;
}

proof of fvelrn {
	var x : set, y : set;;
	step 1 : wff = eleq1 () |- ( x = A → ( x ∈ dom F ↔ A ∈ dom F ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( x = A → ( ( Fun F ∧ x ∈ dom F ) ↔ ( Fun F ∧ A ∈ dom F ) ) ) ;;
	step 3 : wff = fveq2 () |- ( x = A → ( F ` x ) = ( F ` A ) ) ;;
	step 4 : wff = eleq1d (step 3) |- ( x = A → ( ( F ` x ) ∈ ran F ↔ ( F ` A ) ∈ ran F ) ) ;;
	step 5 : wff = imbi12d (step 2, step 4) |- ( x = A → ( ( ( Fun F ∧ x ∈ dom F ) → ( F ` x ) ∈ ran F ) ↔ ( ( Fun F ∧ A ∈ dom F ) → ( F ` A ) ∈ ran F ) ) ) ;;
	step 6 : wff = funfvop () |- ( ( Fun F ∧ x ∈ dom F ) → 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = opeq1 () |- ( y = x → 〈 y , ( F ` x ) 〉 = 〈 x , ( F ` x ) 〉 ) ;;
	step 9 : wff = eleq1d (step 8) |- ( y = x → ( 〈 y , ( F ` x ) 〉 ∈ F ↔ 〈 x , ( F ` x ) 〉 ∈ F ) ) ;;
	step 10 : wff = spcev (step 7, step 9) |- ( 〈 x , ( F ` x ) 〉 ∈ F → ∃ y 〈 y , ( F ` x ) 〉 ∈ F ) ;;
	step 11 : wff = syl (step 6, step 10) |- ( ( Fun F ∧ x ∈ dom F ) → ∃ y 〈 y , ( F ` x ) 〉 ∈ F ) ;;
	step 12 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 13 : wff = elrn2 (step 12) |- ( ( F ` x ) ∈ ran F ↔ ∃ y 〈 y , ( F ` x ) 〉 ∈ F ) ;;
	step 14 : wff = sylibr (step 11, step 13) |- ( ( Fun F ∧ x ∈ dom F ) → ( F ` x ) ∈ ran F ) ;;
	step 15 : wff = vtoclg (step 5, step 14) |- ( A ∈ dom F → ( ( Fun F ∧ A ∈ dom F ) → ( F ` A ) ∈ ran F ) ) ;;
	step 16 : wff = anabsi7 (step 15) |- ( ( Fun F ∧ A ∈ dom F ) → ( F ` A ) ∈ ran F ) ;;
	qed prop 1 = step 16 ;;
}

/*A function's value belongs to its range.  (Contributed by NM,
     15-Oct-1996.) */

theorem fnfvelrn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ( F ` B ) ∈ ran F ) ;;
}

proof of fnfvelrn {
	step 1 : wff = fvelrn () |- ( ( Fun F ∧ B ∈ dom F ) → ( F ` B ) ∈ ran F ) ;;
	step 2 : wff = funfni (step 1) |- ( ( F Fn A ∧ B ∈ A ) → ( F ` B ) ∈ ran F ) ;;
	qed prop 1 = step 2 ;;
}

/*A function's value belongs to its codomain.  (Contributed by NM,
     12-Aug-1999.) */

theorem ffvelrn (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
}

proof of ffvelrn {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fnfvelrn () |- ( ( F Fn A ∧ C ∈ A ) → ( F ` C ) ∈ ran F ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( F ` C ) ∈ ran F ) ;;
	step 4 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 5 : wff = sseld (step 4) |- ( F : A ⟶ B → ( ( F ` C ) ∈ ran F → ( F ` C ) ∈ B ) ) ;;
	step 6 : wff = adantr (step 5) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( ( F ` C ) ∈ ran F → ( F ` C ) ∈ B ) ) ;;
	step 7 : wff = mpd (step 3, step 6) |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
	qed prop 1 = step 7 ;;
}

/*A function's value belongs to its codomain.  (Contributed by NM,
       6-Apr-2005.) */

theorem ffvelrni (A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- F : A ⟶ B ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ A → ( F ` C ) ∈ B ) ;;
}

proof of ffvelrni {
	step 1 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( C ∈ A → ( F ` C ) ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*A function's value belongs to its codomain.  (Contributed by Mario
       Carneiro, 29-Dec-2016.) */

theorem ffvelrnda (ph : wff, A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- ( ph → F : A ⟶ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
}

proof of ffvelrnda {
	step 1 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
	step 2 : wff = sylan (hyp 1, step 1) |- ( ( ph ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*A function's value belongs to its codomain.  (Contributed by Mario
       Carneiro, 29-Dec-2016.) */

theorem ffvelrnd (ph : wff, A : class, B : class, C : class, F : class)  {
	hyp 1 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 2 : wff = |- ( ph → C ∈ A ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F ` C ) ∈ B ) ;;
}

proof of ffvelrnd {
	step 1 : wff = ffvelrnda (hyp 1) |- ( ( ph ∧ C ∈ A ) → ( F ` C ) ∈ B ) ;;
	step 2 : wff = mpdan (hyp 2, step 1) |- ( ph → ( F ` C ) ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Restricted existential quantification over the range of a function.
       (Contributed by Mario Carneiro, 24-Dec-2013.)  (Revised by Mario
       Carneiro, 20-Aug-2014.) */

theorem rexrn (ph : wff, ps : wff, x : set, y : set, A : class, F : class) disjointed(x y A, x y F, x ps, y ph) {
	hyp 1 : wff = |- ( x = ( F ` y ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( F Fn A → ( ∃ x ∈ ran F ph ↔ ∃ y ∈ A ps ) ) ;;
}

proof of rexrn {
	step 1 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 2 : wff = a1i (step 1) |- ( ( F Fn A ∧ y ∈ A ) → ( F ` y ) ∈ _V ) ;;
	step 3 : wff = fvelrnb () |- ( F Fn A → ( x ∈ ran F ↔ ∃ y ∈ A ( F ` y ) = x ) ) ;;
	step 4 : wff = eqcom () |- ( ( F ` y ) = x ↔ x = ( F ` y ) ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ y ∈ A ( F ` y ) = x ↔ ∃ y ∈ A x = ( F ` y ) ) ;;
	step 6 : wff = syl6bb (step 3, step 5) |- ( F Fn A → ( x ∈ ran F ↔ ∃ y ∈ A x = ( F ` y ) ) ) ;;
	step 7 : wff = adantl (hyp 1) |- ( ( F Fn A ∧ x = ( F ` y ) ) → ( ph ↔ ps ) ) ;;
	step 8 : wff = rexxfr2d (step 2, step 6, step 7) |- ( F Fn A → ( ∃ x ∈ ran F ph ↔ ∃ y ∈ A ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Restricted universal quantification over the range of a function.
       (Contributed by Mario Carneiro, 24-Dec-2013.)  (Revised by Mario
       Carneiro, 20-Aug-2014.) */

theorem ralrn (ph : wff, ps : wff, x : set, y : set, A : class, F : class) disjointed(x y A, x y F, x ps, y ph) {
	hyp 1 : wff = |- ( x = ( F ` y ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( F Fn A → ( ∀ x ∈ ran F ph ↔ ∀ y ∈ A ps ) ) ;;
}

proof of ralrn {
	step 1 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 2 : wff = a1i (step 1) |- ( ( F Fn A ∧ y ∈ A ) → ( F ` y ) ∈ _V ) ;;
	step 3 : wff = fvelrnb () |- ( F Fn A → ( x ∈ ran F ↔ ∃ y ∈ A ( F ` y ) = x ) ) ;;
	step 4 : wff = eqcom () |- ( ( F ` y ) = x ↔ x = ( F ` y ) ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ y ∈ A ( F ` y ) = x ↔ ∃ y ∈ A x = ( F ` y ) ) ;;
	step 6 : wff = syl6bb (step 3, step 5) |- ( F Fn A → ( x ∈ ran F ↔ ∃ y ∈ A x = ( F ` y ) ) ) ;;
	step 7 : wff = adantl (hyp 1) |- ( ( F Fn A ∧ x = ( F ` y ) ) → ( ph ↔ ps ) ) ;;
	step 8 : wff = ralxfr2d (step 2, step 6, step 7) |- ( F Fn A → ( ∀ x ∈ ran F ph ↔ ∀ y ∈ A ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*A restricted quantifier over an image set.  (Contributed by Mario
       Carneiro, 20-Aug-2015.) */

theorem ralrnmpt (ps : wff, ch : wff, x : set, y : set, A : class, B : class, F : class, V : class) disjointed(w x z A, y B, y ch, w y z F, w x z ps) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ V → ( ∀ y ∈ ran F ps ↔ ∀ x ∈ A ch ) ) ;;
}

proof of ralrnmpt {
	var z : set, w : set;;
	step 1 : wff = fnmpt (hyp 1) |- ( ∀ x ∈ A B ∈ V → F Fn A ) ;;
	step 2 : wff = dfsbcq () |- ( w = ( F ` z ) → ( [. w / y ]. ps ↔ [. ( F ` z ) / y ]. ps ) ) ;;
	step 3 : wff = ralrn (step 2) |- ( F Fn A → ( ∀ w ∈ ran F [. w / y ]. ps ↔ ∀ z ∈ A [. ( F ` z ) / y ]. ps ) ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( ∀ x ∈ A B ∈ V → ( ∀ w ∈ ran F [. w / y ]. ps ↔ ∀ z ∈ A [. ( F ` z ) / y ]. ps ) ) ;;
	step 5 : wff = nfv () |- F/ w ps ;;
	step 6 : wff = nfsbc1v () |- F/ y [. w / y ]. ps ;;
	step 7 : wff = sbceq1a () |- ( y = w → ( ps ↔ [. w / y ]. ps ) ) ;;
	step 8 : wff = cbvral (step 5, step 6, step 7) |- ( ∀ y ∈ ran F ps ↔ ∀ w ∈ ran F [. w / y ]. ps ) ;;
	step 9 : wff = bicomi (step 8) |- ( ∀ w ∈ ran F [. w / y ]. ps ↔ ∀ y ∈ ran F ps ) ;;
	step 10 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ B ) ;;
	step 11 : wff = nfcxfr (hyp 1, step 10) |- F/_ x F ;;
	step 12 : wff = nfcv () |- F/_ x z ;;
	step 13 : wff = nffv (step 11, step 12) |- F/_ x ( F ` z ) ;;
	step 14 : wff = nfv () |- F/ x ps ;;
	step 15 : wff = nfsbc (step 13, step 14) |- F/ x [. ( F ` z ) / y ]. ps ;;
	step 16 : wff = nfv () |- F/ z [. ( F ` x ) / y ]. ps ;;
	step 17 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 18 : wff = dfsbcq () |- ( ( F ` z ) = ( F ` x ) → ( [. ( F ` z ) / y ]. ps ↔ [. ( F ` x ) / y ]. ps ) ) ;;
	step 19 : wff = syl (step 17, step 18) |- ( z = x → ( [. ( F ` z ) / y ]. ps ↔ [. ( F ` x ) / y ]. ps ) ) ;;
	step 20 : wff = cbvral (step 15, step 16, step 19) |- ( ∀ z ∈ A [. ( F ` z ) / y ]. ps ↔ ∀ x ∈ A [. ( F ` x ) / y ]. ps ) ;;
	step 21 : wff = 3bitr3g (step 4, step 9, step 20) |- ( ∀ x ∈ A B ∈ V → ( ∀ y ∈ ran F ps ↔ ∀ x ∈ A [. ( F ` x ) / y ]. ps ) ) ;;
	step 22 : wff = fvmpt2 (hyp 1) |- ( ( x ∈ A ∧ B ∈ V ) → ( F ` x ) = B ) ;;
	step 23 : wff = dfsbcq () |- ( ( F ` x ) = B → ( [. ( F ` x ) / y ]. ps ↔ [. B / y ]. ps ) ) ;;
	step 24 : wff = syl (step 22, step 23) |- ( ( x ∈ A ∧ B ∈ V ) → ( [. ( F ` x ) / y ]. ps ↔ [. B / y ]. ps ) ) ;;
	step 25 : wff = sbcieg (hyp 2) |- ( B ∈ V → ( [. B / y ]. ps ↔ ch ) ) ;;
	step 26 : wff = adantl (step 25) |- ( ( x ∈ A ∧ B ∈ V ) → ( [. B / y ]. ps ↔ ch ) ) ;;
	step 27 : wff = bitrd (step 24, step 26) |- ( ( x ∈ A ∧ B ∈ V ) → ( [. ( F ` x ) / y ]. ps ↔ ch ) ) ;;
	step 28 : wff = ralimiaa (step 27) |- ( ∀ x ∈ A B ∈ V → ∀ x ∈ A ( [. ( F ` x ) / y ]. ps ↔ ch ) ) ;;
	step 29 : wff = ralbi () |- ( ∀ x ∈ A ( [. ( F ` x ) / y ]. ps ↔ ch ) → ( ∀ x ∈ A [. ( F ` x ) / y ]. ps ↔ ∀ x ∈ A ch ) ) ;;
	step 30 : wff = syl (step 28, step 29) |- ( ∀ x ∈ A B ∈ V → ( ∀ x ∈ A [. ( F ` x ) / y ]. ps ↔ ∀ x ∈ A ch ) ) ;;
	step 31 : wff = bitrd (step 21, step 30) |- ( ∀ x ∈ A B ∈ V → ( ∀ y ∈ ran F ps ↔ ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 31 ;;
}

/*A restricted quantifier over an image set.  (Contributed by Mario
       Carneiro, 20-Aug-2015.) */

theorem rexrnmpt (ps : wff, ch : wff, x : set, y : set, A : class, B : class, F : class, V : class) disjointed(x A, y B, y ch, y F, x ps) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ V → ( ∃ y ∈ ran F ps ↔ ∃ x ∈ A ch ) ) ;;
}

proof of rexrnmpt {
	step 1 : wff = notbid (hyp 2) |- ( y = B → ( ¬ ps ↔ ¬ ch ) ) ;;
	step 2 : wff = ralrnmpt (hyp 1, step 1) |- ( ∀ x ∈ A B ∈ V → ( ∀ y ∈ ran F ¬ ps ↔ ∀ x ∈ A ¬ ch ) ) ;;
	step 3 : wff = notbid (step 2) |- ( ∀ x ∈ A B ∈ V → ( ¬ ∀ y ∈ ran F ¬ ps ↔ ¬ ∀ x ∈ A ¬ ch ) ) ;;
	step 4 : wff = dfrex2 () |- ( ∃ y ∈ ran F ps ↔ ¬ ∀ y ∈ ran F ¬ ps ) ;;
	step 5 : wff = dfrex2 () |- ( ∃ x ∈ A ch ↔ ¬ ∀ x ∈ A ¬ ch ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ∀ x ∈ A B ∈ V → ( ∃ y ∈ ran F ps ↔ ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Unconditional closure of a function when the range includes the empty
       set.  (Contributed by Mario Carneiro, 12-Sep-2013.) */

theorem f0cli (A : class, B : class, C : class, F : class) disjointed(A, C, B) {
	hyp 1 : wff = |- F : A ⟶ B ;;
	hyp 2 : wff = |- ∅ ∈ B ;;
	-----------------------
	prop 1 : wff = |- ( F ` C ) ∈ B ;;
}

proof of f0cli {
	step 1 : wff = ffvelrni (hyp 1) |- ( C ∈ A → ( F ` C ) ∈ B ) ;;
	step 2 : wff = fdmi (hyp 1) |- dom F = A ;;
	step 3 : wff = eleq2i (step 2) |- ( C ∈ dom F ↔ C ∈ A ) ;;
	step 4 : wff = ndmfv () |- ( ¬ C ∈ dom F → ( F ` C ) = ∅ ) ;;
	step 5 : wff = syl6eqel (step 4, hyp 2) |- ( ¬ C ∈ dom F → ( F ` C ) ∈ B ) ;;
	step 6 : wff = sylnbir (step 3, step 5) |- ( ¬ C ∈ A → ( F ` C ) ∈ B ) ;;
	step 7 : wff = pm2.61i (step 1, step 6) |- ( F ` C ) ∈ B ;;
	qed prop 1 = step 7 ;;
}

/*Alternate definition of a mapping.  (Contributed by NM, 14-Nov-2007.) */

theorem dff2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ B ↔ ( F Fn A ∧ F ⊆ ( A × B ) ) ) ;;
}

proof of dff2 {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fssxp () |- ( F : A ⟶ B → F ⊆ ( A × B ) ) ;;
	step 3 : wff = jca (step 1, step 2) |- ( F : A ⟶ B → ( F Fn A ∧ F ⊆ ( A × B ) ) ) ;;
	step 4 : wff = rnss () |- ( F ⊆ ( A × B ) → ran F ⊆ ran ( A × B ) ) ;;
	step 5 : wff = rnxpss () |- ran ( A × B ) ⊆ B ;;
	step 6 : wff = syl6ss (step 4, step 5) |- ( F ⊆ ( A × B ) → ran F ⊆ B ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( F Fn A ∧ F ⊆ ( A × B ) ) → ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 8 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 9 : wff = sylibr (step 7, step 8) |- ( ( F Fn A ∧ F ⊆ ( A × B ) ) → F : A ⟶ B ) ;;
	step 10 : wff = impbii (step 3, step 9) |- ( F : A ⟶ B ↔ ( F Fn A ∧ F ⊆ ( A × B ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Alternate definition of a mapping.  (Contributed by NM, 20-Mar-2007.) */

theorem dff3 (x : set, y : set, A : class, B : class, F : class) disjointed(x y z A, x y z B, x y z F) {
	prop 1 : wff = |- ( F : A ⟶ B ↔ ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) ) ;;
}

proof of dff3 {
	var z : set;;
	step 1 : wff = fssxp () |- ( F : A ⟶ B → F ⊆ ( A × B ) ) ;;
	step 2 : wff = ffun () |- ( F : A ⟶ B → Fun F ) ;;
	step 3 : wff = adantr (step 2) |- ( ( F : A ⟶ B ∧ x ∈ A ) → Fun F ) ;;
	step 4 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 5 : wff = eleq2d (step 4) |- ( F : A ⟶ B → ( x ∈ dom F ↔ x ∈ A ) ) ;;
	step 6 : wff = biimpar (step 5) |- ( ( F : A ⟶ B ∧ x ∈ A ) → x ∈ dom F ) ;;
	step 7 : wff = funfvop () |- ( ( Fun F ∧ x ∈ dom F ) → 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 8 : wff = syl2anc (step 3, step 6, step 7) |- ( ( F : A ⟶ B ∧ x ∈ A ) → 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 9 : wff = df-br () |- ( x F ( F ` x ) ↔ 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 10 : wff = sylibr (step 8, step 9) |- ( ( F : A ⟶ B ∧ x ∈ A ) → x F ( F ` x ) ) ;;
	step 11 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 12 : wff = breq2 () |- ( y = ( F ` x ) → ( x F y ↔ x F ( F ` x ) ) ) ;;
	step 13 : wff = spcev (step 11, step 12) |- ( x F ( F ` x ) → ∃ y x F y ) ;;
	step 14 : wff = syl (step 10, step 13) |- ( ( F : A ⟶ B ∧ x ∈ A ) → ∃ y x F y ) ;;
	step 15 : wff = ffun () |- ( F : A ⟶ B → Fun F ) ;;
	step 16 : wff = funmo () |- ( Fun F → ∃* y x F y ) ;;
	step 17 : wff = syl (step 15, step 16) |- ( F : A ⟶ B → ∃* y x F y ) ;;
	step 18 : wff = adantr (step 17) |- ( ( F : A ⟶ B ∧ x ∈ A ) → ∃* y x F y ) ;;
	step 19 : wff = eu5 () |- ( ∃! y x F y ↔ ( ∃ y x F y ∧ ∃* y x F y ) ) ;;
	step 20 : wff = sylanbrc (step 14, step 18, step 19) |- ( ( F : A ⟶ B ∧ x ∈ A ) → ∃! y x F y ) ;;
	step 21 : wff = ralrimiva (step 20) |- ( F : A ⟶ B → ∀ x ∈ A ∃! y x F y ) ;;
	step 22 : wff = jca (step 1, step 21) |- ( F : A ⟶ B → ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) ) ;;
	step 23 : wff = xpss () |- ( A × B ) ⊆ ( _V × _V ) ;;
	step 24 : wff = sstr () |- ( ( F ⊆ ( A × B ) ∧ ( A × B ) ⊆ ( _V × _V ) ) → F ⊆ ( _V × _V ) ) ;;
	step 25 : wff = mpan2 (step 23, step 24) |- ( F ⊆ ( A × B ) → F ⊆ ( _V × _V ) ) ;;
	step 26 : wff = df-rel () |- ( Rel F ↔ F ⊆ ( _V × _V ) ) ;;
	step 27 : wff = sylibr (step 25, step 26) |- ( F ⊆ ( A × B ) → Rel F ) ;;
	step 28 : wff = adantr (step 27) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → Rel F ) ;;
	step 29 : wff = df-ral () |- ( ∀ x ∈ A ∃! y x F y ↔ ∀ x ( x ∈ A → ∃! y x F y ) ) ;;
	step 30 : wff = eumo () |- ( ∃! y x F y → ∃* y x F y ) ;;
	step 31 : wff = imim2i (step 30) |- ( ( x ∈ A → ∃! y x F y ) → ( x ∈ A → ∃* y x F y ) ) ;;
	step 32 : wff = adantl (step 31) |- ( ( F ⊆ ( A × B ) ∧ ( x ∈ A → ∃! y x F y ) ) → ( x ∈ A → ∃* y x F y ) ) ;;
	step 33 : wff = df-br () |- ( x F y ↔ 〈 x , y 〉 ∈ F ) ;;
	step 34 : wff = ssel () |- ( F ⊆ ( A × B ) → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 35 : wff = syl5bi (step 33, step 34) |- ( F ⊆ ( A × B ) → ( x F y → 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 36 : wff = opelxp1 () |- ( 〈 x , y 〉 ∈ ( A × B ) → x ∈ A ) ;;
	step 37 : wff = syl6 (step 35, step 36) |- ( F ⊆ ( A × B ) → ( x F y → x ∈ A ) ) ;;
	step 38 : wff = exlimdv (step 37) |- ( F ⊆ ( A × B ) → ( ∃ y x F y → x ∈ A ) ) ;;
	step 39 : wff = con3d (step 38) |- ( F ⊆ ( A × B ) → ( ¬ x ∈ A → ¬ ∃ y x F y ) ) ;;
	step 40 : wff = exmo () |- ( ∃ y x F y ∨ ∃* y x F y ) ;;
	step 41 : wff = ori (step 40) |- ( ¬ ∃ y x F y → ∃* y x F y ) ;;
	step 42 : wff = syl6 (step 39, step 41) |- ( F ⊆ ( A × B ) → ( ¬ x ∈ A → ∃* y x F y ) ) ;;
	step 43 : wff = adantr (step 42) |- ( ( F ⊆ ( A × B ) ∧ ( x ∈ A → ∃! y x F y ) ) → ( ¬ x ∈ A → ∃* y x F y ) ) ;;
	step 44 : wff = pm2.61d (step 32, step 43) |- ( ( F ⊆ ( A × B ) ∧ ( x ∈ A → ∃! y x F y ) ) → ∃* y x F y ) ;;
	step 45 : wff = ex (step 44) |- ( F ⊆ ( A × B ) → ( ( x ∈ A → ∃! y x F y ) → ∃* y x F y ) ) ;;
	step 46 : wff = alimdv (step 45) |- ( F ⊆ ( A × B ) → ( ∀ x ( x ∈ A → ∃! y x F y ) → ∀ x ∃* y x F y ) ) ;;
	step 47 : wff = syl5bi (step 29, step 46) |- ( F ⊆ ( A × B ) → ( ∀ x ∈ A ∃! y x F y → ∀ x ∃* y x F y ) ) ;;
	step 48 : wff = imp (step 47) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → ∀ x ∃* y x F y ) ;;
	step 49 : wff = dffun6 () |- ( Fun F ↔ ( Rel F ∧ ∀ x ∃* y x F y ) ) ;;
	step 50 : wff = sylanbrc (step 28, step 48, step 49) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → Fun F ) ;;
	step 51 : wff = dmss () |- ( F ⊆ ( A × B ) → dom F ⊆ dom ( A × B ) ) ;;
	step 52 : wff = dmxpss () |- dom ( A × B ) ⊆ A ;;
	step 53 : wff = syl6ss (step 51, step 52) |- ( F ⊆ ( A × B ) → dom F ⊆ A ) ;;
	step 54 : wff = breq1 () |- ( x = z → ( x F y ↔ z F y ) ) ;;
	step 55 : wff = eubidv (step 54) |- ( x = z → ( ∃! y x F y ↔ ∃! y z F y ) ) ;;
	step 56 : wff = rspccv (step 55) |- ( ∀ x ∈ A ∃! y x F y → ( z ∈ A → ∃! y z F y ) ) ;;
	step 57 : wff = euex () |- ( ∃! y z F y → ∃ y z F y ) ;;
	step 58 : wff = vex () |- z ∈ _V ;;
	step 59 : wff = eldm (step 58) |- ( z ∈ dom F ↔ ∃ y z F y ) ;;
	step 60 : wff = sylibr (step 57, step 59) |- ( ∃! y z F y → z ∈ dom F ) ;;
	step 61 : wff = syl6 (step 56, step 60) |- ( ∀ x ∈ A ∃! y x F y → ( z ∈ A → z ∈ dom F ) ) ;;
	step 62 : wff = ssrdv (step 61) |- ( ∀ x ∈ A ∃! y x F y → A ⊆ dom F ) ;;
	step 63 : wff = anim12i (step 53, step 62) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → ( dom F ⊆ A ∧ A ⊆ dom F ) ) ;;
	step 64 : wff = eqss () |- ( dom F = A ↔ ( dom F ⊆ A ∧ A ⊆ dom F ) ) ;;
	step 65 : wff = sylibr (step 63, step 64) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → dom F = A ) ;;
	step 66 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 67 : wff = sylanbrc (step 50, step 65, step 66) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → F Fn A ) ;;
	step 68 : wff = rnss () |- ( F ⊆ ( A × B ) → ran F ⊆ ran ( A × B ) ) ;;
	step 69 : wff = rnxpss () |- ran ( A × B ) ⊆ B ;;
	step 70 : wff = syl6ss (step 68, step 69) |- ( F ⊆ ( A × B ) → ran F ⊆ B ) ;;
	step 71 : wff = adantr (step 70) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → ran F ⊆ B ) ;;
	step 72 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 73 : wff = sylanbrc (step 67, step 71, step 72) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) → F : A ⟶ B ) ;;
	step 74 : wff = impbii (step 22, step 73) |- ( F : A ⟶ B ↔ ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) ) ;;
	qed prop 1 = step 74 ;;
}

/*Alternate definition of a mapping.  (Contributed by NM, 20-Mar-2007.) */

theorem dff4 (x : set, y : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( F : A ⟶ B ↔ ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y ∈ B x F y ) ) ;;
}

proof of dff4 {
	step 1 : wff = dff3 () |- ( F : A ⟶ B ↔ ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) ) ;;
	step 2 : wff = df-br () |- ( x F y ↔ 〈 x , y 〉 ∈ F ) ;;
	step 3 : wff = ssel () |- ( F ⊆ ( A × B ) → ( 〈 x , y 〉 ∈ F → 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 4 : wff = opelxp2 () |- ( 〈 x , y 〉 ∈ ( A × B ) → y ∈ B ) ;;
	step 5 : wff = syl6 (step 3, step 4) |- ( F ⊆ ( A × B ) → ( 〈 x , y 〉 ∈ F → y ∈ B ) ) ;;
	step 6 : wff = syl5bi (step 2, step 5) |- ( F ⊆ ( A × B ) → ( x F y → y ∈ B ) ) ;;
	step 7 : wff = pm4.71rd (step 6) |- ( F ⊆ ( A × B ) → ( x F y ↔ ( y ∈ B ∧ x F y ) ) ) ;;
	step 8 : wff = eubidv (step 7) |- ( F ⊆ ( A × B ) → ( ∃! y x F y ↔ ∃! y ( y ∈ B ∧ x F y ) ) ) ;;
	step 9 : wff = df-reu () |- ( ∃! y ∈ B x F y ↔ ∃! y ( y ∈ B ∧ x F y ) ) ;;
	step 10 : wff = syl6bbr (step 8, step 9) |- ( F ⊆ ( A × B ) → ( ∃! y x F y ↔ ∃! y ∈ B x F y ) ) ;;
	step 11 : wff = ralbidv (step 10) |- ( F ⊆ ( A × B ) → ( ∀ x ∈ A ∃! y x F y ↔ ∀ x ∈ A ∃! y ∈ B x F y ) ) ;;
	step 12 : wff = pm5.32i (step 11) |- ( ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y x F y ) ↔ ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y ∈ B x F y ) ) ;;
	step 13 : wff = bitri (step 1, step 12) |- ( F : A ⟶ B ↔ ( F ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y ∈ B x F y ) ) ;;
	qed prop 1 = step 13 ;;
}

/*An onto mapping expressed in terms of function values.  (Contributed by
       NM, 29-Oct-2006.) */

theorem dffo3 (x : set, y : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
}

proof of dffo3 {
	step 1 : wff = dffo2 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ran F = B ) ) ;;
	step 2 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 3 : wff = fnrnfv () |- ( F Fn A → ran F = { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	step 4 : wff = eqeq1d (step 3) |- ( F Fn A → ( ran F = B ↔ { y | ∃ x ∈ A y = ( F ` x ) } = B ) ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( F : A ⟶ B → ( ran F = B ↔ { y | ∃ x ∈ A y = ( F ` x ) } = B ) ) ;;
	step 6 : wff = simpr () |- ( ( ( F : A ⟶ B ∧ x ∈ A ) ∧ y = ( F ` x ) ) → y = ( F ` x ) ) ;;
	step 7 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( F ` x ) ∈ B ) ;;
	step 8 : wff = adantr (step 7) |- ( ( ( F : A ⟶ B ∧ x ∈ A ) ∧ y = ( F ` x ) ) → ( F ` x ) ∈ B ) ;;
	step 9 : wff = eqeltrd (step 6, step 8) |- ( ( ( F : A ⟶ B ∧ x ∈ A ) ∧ y = ( F ` x ) ) → y ∈ B ) ;;
	step 10 : wff = exp31 (step 9) |- ( F : A ⟶ B → ( x ∈ A → ( y = ( F ` x ) → y ∈ B ) ) ) ;;
	step 11 : wff = rexlimdv (step 10) |- ( F : A ⟶ B → ( ∃ x ∈ A y = ( F ` x ) → y ∈ B ) ) ;;
	step 12 : wff = biantrurd (step 11) |- ( F : A ⟶ B → ( ( y ∈ B → ∃ x ∈ A y = ( F ` x ) ) ↔ ( ( ∃ x ∈ A y = ( F ` x ) → y ∈ B ) ∧ ( y ∈ B → ∃ x ∈ A y = ( F ` x ) ) ) ) ) ;;
	step 13 : wff = dfbi2 () |- ( ( ∃ x ∈ A y = ( F ` x ) ↔ y ∈ B ) ↔ ( ( ∃ x ∈ A y = ( F ` x ) → y ∈ B ) ∧ ( y ∈ B → ∃ x ∈ A y = ( F ` x ) ) ) ) ;;
	step 14 : wff = syl6rbbr (step 12, step 13) |- ( F : A ⟶ B → ( ( ∃ x ∈ A y = ( F ` x ) ↔ y ∈ B ) ↔ ( y ∈ B → ∃ x ∈ A y = ( F ` x ) ) ) ) ;;
	step 15 : wff = albidv (step 14) |- ( F : A ⟶ B → ( ∀ y ( ∃ x ∈ A y = ( F ` x ) ↔ y ∈ B ) ↔ ∀ y ( y ∈ B → ∃ x ∈ A y = ( F ` x ) ) ) ) ;;
	step 16 : wff = abeq1 () |- ( { y | ∃ x ∈ A y = ( F ` x ) } = B ↔ ∀ y ( ∃ x ∈ A y = ( F ` x ) ↔ y ∈ B ) ) ;;
	step 17 : wff = df-ral () |- ( ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ↔ ∀ y ( y ∈ B → ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 18 : wff = 3bitr4g (step 15, step 16, step 17) |- ( F : A ⟶ B → ( { y | ∃ x ∈ A y = ( F ` x ) } = B ↔ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 19 : wff = bitrd (step 5, step 18) |- ( F : A ⟶ B → ( ran F = B ↔ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 20 : wff = pm5.32i (step 19) |- ( ( F : A ⟶ B ∧ ran F = B ) ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 21 : wff = bitri (step 1, step 20) |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	qed prop 1 = step 21 ;;
}

/*Alternate definition of an onto mapping.  (Contributed by NM,
       20-Mar-2007.) */

theorem dffo4 (x : set, y : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
}

proof of dffo4 {
	step 1 : wff = dffo2 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ran F = B ) ) ;;
	step 2 : wff = simpl () |- ( ( F : A ⟶ B ∧ ran F = B ) → F : A ⟶ B ) ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = elrn (step 3) |- ( y ∈ ran F ↔ ∃ x x F y ) ;;
	step 5 : wff = eleq2 () |- ( ran F = B → ( y ∈ ran F ↔ y ∈ B ) ) ;;
	step 6 : wff = syl5bbr (step 4, step 5) |- ( ran F = B → ( ∃ x x F y ↔ y ∈ B ) ) ;;
	step 7 : wff = biimpar (step 6) |- ( ( ran F = B ∧ y ∈ B ) → ∃ x x F y ) ;;
	step 8 : wff = adantll (step 7) |- ( ( ( F : A ⟶ B ∧ ran F = B ) ∧ y ∈ B ) → ∃ x x F y ) ;;
	step 9 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 10 : wff = fnbr () |- ( ( F Fn A ∧ x F y ) → x ∈ A ) ;;
	step 11 : wff = ex (step 10) |- ( F Fn A → ( x F y → x ∈ A ) ) ;;
	step 12 : wff = syl (step 9, step 11) |- ( F : A ⟶ B → ( x F y → x ∈ A ) ) ;;
	step 13 : wff = ancrd (step 12) |- ( F : A ⟶ B → ( x F y → ( x ∈ A ∧ x F y ) ) ) ;;
	step 14 : wff = eximdv (step 13) |- ( F : A ⟶ B → ( ∃ x x F y → ∃ x ( x ∈ A ∧ x F y ) ) ) ;;
	step 15 : wff = df-rex () |- ( ∃ x ∈ A x F y ↔ ∃ x ( x ∈ A ∧ x F y ) ) ;;
	step 16 : wff = syl6ibr (step 14, step 15) |- ( F : A ⟶ B → ( ∃ x x F y → ∃ x ∈ A x F y ) ) ;;
	step 17 : wff = ad2antrr (step 16) |- ( ( ( F : A ⟶ B ∧ ran F = B ) ∧ y ∈ B ) → ( ∃ x x F y → ∃ x ∈ A x F y ) ) ;;
	step 18 : wff = mpd (step 8, step 17) |- ( ( ( F : A ⟶ B ∧ ran F = B ) ∧ y ∈ B ) → ∃ x ∈ A x F y ) ;;
	step 19 : wff = ralrimiva (step 18) |- ( ( F : A ⟶ B ∧ ran F = B ) → ∀ y ∈ B ∃ x ∈ A x F y ) ;;
	step 20 : wff = jca (step 2, step 19) |- ( ( F : A ⟶ B ∧ ran F = B ) → ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
	step 21 : wff = sylbi (step 1, step 20) |- ( F : A ↠ B → ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
	step 22 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 23 : wff = fnbrfvb () |- ( ( F Fn A ∧ x ∈ A ) → ( ( F ` x ) = y ↔ x F y ) ) ;;
	step 24 : wff = biimprd (step 23) |- ( ( F Fn A ∧ x ∈ A ) → ( x F y → ( F ` x ) = y ) ) ;;
	step 25 : wff = eqcom () |- ( ( F ` x ) = y ↔ y = ( F ` x ) ) ;;
	step 26 : wff = syl6ib (step 24, step 25) |- ( ( F Fn A ∧ x ∈ A ) → ( x F y → y = ( F ` x ) ) ) ;;
	step 27 : wff = sylan (step 22, step 26) |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( x F y → y = ( F ` x ) ) ) ;;
	step 28 : wff = reximdva (step 27) |- ( F : A ⟶ B → ( ∃ x ∈ A x F y → ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 29 : wff = ralimdv (step 28) |- ( F : A ⟶ B → ( ∀ y ∈ B ∃ x ∈ A x F y → ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 30 : wff = imdistani (step 29) |- ( ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) → ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 31 : wff = dffo3 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 32 : wff = sylibr (step 30, step 31) |- ( ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) → F : A ↠ B ) ;;
	step 33 : wff = impbii (step 21, step 32) |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
	qed prop 1 = step 33 ;;
}

/*Alternate definition of an onto mapping.  (Contributed by NM,
       20-Mar-2007.) */

theorem dffo5 (x : set, y : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x x F y ) ) ;;
}

proof of dffo5 {
	step 1 : wff = dffo4 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
	step 2 : wff = rexex () |- ( ∃ x ∈ A x F y → ∃ x x F y ) ;;
	step 3 : wff = ralimi (step 2) |- ( ∀ y ∈ B ∃ x ∈ A x F y → ∀ y ∈ B ∃ x x F y ) ;;
	step 4 : wff = anim2i (step 3) |- ( ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) → ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x x F y ) ) ;;
	step 5 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 6 : wff = fnbr () |- ( ( F Fn A ∧ x F y ) → x ∈ A ) ;;
	step 7 : wff = ex (step 6) |- ( F Fn A → ( x F y → x ∈ A ) ) ;;
	step 8 : wff = syl (step 5, step 7) |- ( F : A ⟶ B → ( x F y → x ∈ A ) ) ;;
	step 9 : wff = ancrd (step 8) |- ( F : A ⟶ B → ( x F y → ( x ∈ A ∧ x F y ) ) ) ;;
	step 10 : wff = eximdv (step 9) |- ( F : A ⟶ B → ( ∃ x x F y → ∃ x ( x ∈ A ∧ x F y ) ) ) ;;
	step 11 : wff = df-rex () |- ( ∃ x ∈ A x F y ↔ ∃ x ( x ∈ A ∧ x F y ) ) ;;
	step 12 : wff = syl6ibr (step 10, step 11) |- ( F : A ⟶ B → ( ∃ x x F y → ∃ x ∈ A x F y ) ) ;;
	step 13 : wff = ralimdv (step 12) |- ( F : A ⟶ B → ( ∀ y ∈ B ∃ x x F y → ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
	step 14 : wff = imdistani (step 13) |- ( ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x x F y ) → ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ) ;;
	step 15 : wff = impbii (step 4, step 14) |- ( ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A x F y ) ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x x F y ) ) ;;
	step 16 : wff = bitri (step 1, step 15) |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x x F y ) ) ;;
	qed prop 1 = step 16 ;;
}

/*A relation equivalent to the existence of an onto mapping.  The
       right-hand ` f ` is not necessarily a function.  (Contributed by NM,
       20-Mar-2007.) */

theorem exfo (x : set, y : set, A : class, B : class, f : set) disjointed(f g x y A, f g x y B, x y) {
	prop 1 : wff = |- ( ∃ f f : A ↠ B ↔ ∃ f ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) ) ;;
}

proof of exfo {
	var g : set;;
	step 1 : wff = dffo4 () |- ( f : A ↠ B ↔ ( f : A ⟶ B ∧ ∀ x ∈ B ∃ y ∈ A y f x ) ) ;;
	step 2 : wff = dff4 () |- ( f : A ⟶ B ↔ ( f ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y ∈ B x f y ) ) ;;
	step 3 : wff = simprbi (step 2) |- ( f : A ⟶ B → ∀ x ∈ A ∃! y ∈ B x f y ) ;;
	step 4 : wff = anim1i (step 3) |- ( ( f : A ⟶ B ∧ ∀ x ∈ B ∃ y ∈ A y f x ) → ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( f : A ↠ B → ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) ) ;;
	step 6 : wff = eximi (step 5) |- ( ∃ f f : A ↠ B → ∃ f ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) ) ;;
	step 7 : wff = brinxp () |- ( ( x ∈ A ∧ y ∈ B ) → ( x f y ↔ x ( f ∩ ( A × B ) ) y ) ) ;;
	step 8 : wff = reubidva (step 7) |- ( x ∈ A → ( ∃! y ∈ B x f y ↔ ∃! y ∈ B x ( f ∩ ( A × B ) ) y ) ) ;;
	step 9 : wff = biimpd (step 8) |- ( x ∈ A → ( ∃! y ∈ B x f y → ∃! y ∈ B x ( f ∩ ( A × B ) ) y ) ) ;;
	step 10 : wff = ralimia (step 9) |- ( ∀ x ∈ A ∃! y ∈ B x f y → ∀ x ∈ A ∃! y ∈ B x ( f ∩ ( A × B ) ) y ) ;;
	step 11 : wff = inss2 () |- ( f ∩ ( A × B ) ) ⊆ ( A × B ) ;;
	step 12 : wff = jctil (step 10, step 11) |- ( ∀ x ∈ A ∃! y ∈ B x f y → ( ( f ∩ ( A × B ) ) ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y ∈ B x ( f ∩ ( A × B ) ) y ) ) ;;
	step 13 : wff = dff4 () |- ( ( f ∩ ( A × B ) ) : A ⟶ B ↔ ( ( f ∩ ( A × B ) ) ⊆ ( A × B ) ∧ ∀ x ∈ A ∃! y ∈ B x ( f ∩ ( A × B ) ) y ) ) ;;
	step 14 : wff = sylibr (step 12, step 13) |- ( ∀ x ∈ A ∃! y ∈ B x f y → ( f ∩ ( A × B ) ) : A ⟶ B ) ;;
	step 15 : wff = rninxp () |- ( ran ( f ∩ ( A × B ) ) = B ↔ ∀ x ∈ B ∃ y ∈ A y f x ) ;;
	step 16 : wff = biimpri (step 15) |- ( ∀ x ∈ B ∃ y ∈ A y f x → ran ( f ∩ ( A × B ) ) = B ) ;;
	step 17 : wff = anim12i (step 14, step 16) |- ( ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) → ( ( f ∩ ( A × B ) ) : A ⟶ B ∧ ran ( f ∩ ( A × B ) ) = B ) ) ;;
	step 18 : wff = dffo2 () |- ( ( f ∩ ( A × B ) ) : A ↠ B ↔ ( ( f ∩ ( A × B ) ) : A ⟶ B ∧ ran ( f ∩ ( A × B ) ) = B ) ) ;;
	step 19 : wff = sylibr (step 17, step 18) |- ( ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) → ( f ∩ ( A × B ) ) : A ↠ B ) ;;
	step 20 : wff = vex () |- f ∈ _V ;;
	step 21 : wff = inex1 (step 20) |- ( f ∩ ( A × B ) ) ∈ _V ;;
	step 22 : wff = foeq1 () |- ( g = ( f ∩ ( A × B ) ) → ( g : A ↠ B ↔ ( f ∩ ( A × B ) ) : A ↠ B ) ) ;;
	step 23 : wff = spcev (step 21, step 22) |- ( ( f ∩ ( A × B ) ) : A ↠ B → ∃ g g : A ↠ B ) ;;
	step 24 : wff = syl (step 19, step 23) |- ( ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) → ∃ g g : A ↠ B ) ;;
	step 25 : wff = exlimiv (step 24) |- ( ∃ f ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) → ∃ g g : A ↠ B ) ;;
	step 26 : wff = foeq1 () |- ( g = f → ( g : A ↠ B ↔ f : A ↠ B ) ) ;;
	step 27 : wff = cbvexv (step 26) |- ( ∃ g g : A ↠ B ↔ ∃ f f : A ↠ B ) ;;
	step 28 : wff = sylib (step 25, step 27) |- ( ∃ f ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) → ∃ f f : A ↠ B ) ;;
	step 29 : wff = impbii (step 6, step 28) |- ( ∃ f f : A ↠ B ↔ ∃ f ( ∀ x ∈ A ∃! y ∈ B x f y ∧ ∀ x ∈ B ∃ y ∈ A y f x ) ) ;;
	qed prop 1 = step 29 ;;
}

/*Property of a surjective function.  (Contributed by Jeff Madsen,
       4-Jan-2011.) */

theorem foelrn (x : set, A : class, B : class, C : class, F : class) disjointed(F x y, A x y, B x y, C x y) {
	prop 1 : wff = |- ( ( F : A ↠ B ∧ C ∈ B ) → ∃ x ∈ A C = ( F ` x ) ) ;;
}

proof of foelrn {
	var y : set;;
	step 1 : wff = dffo3 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( F : A ↠ B → ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ;;
	step 3 : wff = eqeq1 () |- ( y = C → ( y = ( F ` x ) ↔ C = ( F ` x ) ) ) ;;
	step 4 : wff = rexbidv (step 3) |- ( y = C → ( ∃ x ∈ A y = ( F ` x ) ↔ ∃ x ∈ A C = ( F ` x ) ) ) ;;
	step 5 : wff = rspccva (step 4) |- ( ( ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ∧ C ∈ B ) → ∃ x ∈ A C = ( F ` x ) ) ;;
	step 6 : wff = sylan (step 2, step 5) |- ( ( F : A ↠ B ∧ C ∈ B ) → ∃ x ∈ A C = ( F ` x ) ) ;;
	qed prop 1 = step 6 ;;
}

/*If a composition of two functions is surjective, then the function on
       the left is surjective.  (Contributed by Jeff Madsen, 16-Jun-2011.) */

theorem foco2 (A : class, B : class, C : class, F : class, G : class) disjointed(F x y z, G x y z, A y z, B x y z, C x y z) {
	prop 1 : wff = |- ( ( F : B ⟶ C ∧ G : A ⟶ B ∧ ( F ∘ G ) : A ↠ C ) → F : B ↠ C ) ;;
}

proof of foco2 {
	var x : set, y : set, z : set;;
	step 1 : wff = simp1 () |- ( ( F : B ⟶ C ∧ G : A ⟶ B ∧ ( F ∘ G ) : A ↠ C ) → F : B ⟶ C ) ;;
	step 2 : wff = foelrn () |- ( ( ( F ∘ G ) : A ↠ C ∧ y ∈ C ) → ∃ z ∈ A y = ( ( F ∘ G ) ` z ) ) ;;
	step 3 : wff = ffvelrn () |- ( ( G : A ⟶ B ∧ z ∈ A ) → ( G ` z ) ∈ B ) ;;
	step 4 : wff = adantll (step 3) |- ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ z ∈ A ) → ( G ` z ) ∈ B ) ;;
	step 5 : wff = fvco3 () |- ( ( G : A ⟶ B ∧ z ∈ A ) → ( ( F ∘ G ) ` z ) = ( F ` ( G ` z ) ) ) ;;
	step 6 : wff = adantll (step 5) |- ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ z ∈ A ) → ( ( F ∘ G ) ` z ) = ( F ` ( G ` z ) ) ) ;;
	step 7 : wff = fveq2 () |- ( x = ( G ` z ) → ( F ` x ) = ( F ` ( G ` z ) ) ) ;;
	step 8 : wff = eqeq2d (step 7) |- ( x = ( G ` z ) → ( ( ( F ∘ G ) ` z ) = ( F ` x ) ↔ ( ( F ∘ G ) ` z ) = ( F ` ( G ` z ) ) ) ) ;;
	step 9 : wff = rspcev (step 8) |- ( ( ( G ` z ) ∈ B ∧ ( ( F ∘ G ) ` z ) = ( F ` ( G ` z ) ) ) → ∃ x ∈ B ( ( F ∘ G ) ` z ) = ( F ` x ) ) ;;
	step 10 : wff = syl2anc (step 4, step 6, step 9) |- ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ z ∈ A ) → ∃ x ∈ B ( ( F ∘ G ) ` z ) = ( F ` x ) ) ;;
	step 11 : wff = eqeq1 () |- ( y = ( ( F ∘ G ) ` z ) → ( y = ( F ` x ) ↔ ( ( F ∘ G ) ` z ) = ( F ` x ) ) ) ;;
	step 12 : wff = rexbidv (step 11) |- ( y = ( ( F ∘ G ) ` z ) → ( ∃ x ∈ B y = ( F ` x ) ↔ ∃ x ∈ B ( ( F ∘ G ) ` z ) = ( F ` x ) ) ) ;;
	step 13 : wff = syl5ibrcom (step 10, step 12) |- ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ z ∈ A ) → ( y = ( ( F ∘ G ) ` z ) → ∃ x ∈ B y = ( F ` x ) ) ) ;;
	step 14 : wff = rexlimdva (step 13) |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( ∃ z ∈ A y = ( ( F ∘ G ) ` z ) → ∃ x ∈ B y = ( F ` x ) ) ) ;;
	step 15 : wff = syl5 (step 2, step 14) |- ( ( F : B ⟶ C ∧ G : A ⟶ B ) → ( ( ( F ∘ G ) : A ↠ C ∧ y ∈ C ) → ∃ x ∈ B y = ( F ` x ) ) ) ;;
	step 16 : wff = impl (step 15) |- ( ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ ( F ∘ G ) : A ↠ C ) ∧ y ∈ C ) → ∃ x ∈ B y = ( F ` x ) ) ;;
	step 17 : wff = ralrimiva (step 16) |- ( ( ( F : B ⟶ C ∧ G : A ⟶ B ) ∧ ( F ∘ G ) : A ↠ C ) → ∀ y ∈ C ∃ x ∈ B y = ( F ` x ) ) ;;
	step 18 : wff = 3impa (step 17) |- ( ( F : B ⟶ C ∧ G : A ⟶ B ∧ ( F ∘ G ) : A ↠ C ) → ∀ y ∈ C ∃ x ∈ B y = ( F ` x ) ) ;;
	step 19 : wff = dffo3 () |- ( F : B ↠ C ↔ ( F : B ⟶ C ∧ ∀ y ∈ C ∃ x ∈ B y = ( F ` x ) ) ) ;;
	step 20 : wff = sylanbrc (step 1, step 18, step 19) |- ( ( F : B ⟶ C ∧ G : A ⟶ B ∧ ( F ∘ G ) : A ↠ C ) → F : B ↠ C ) ;;
	qed prop 1 = step 20 ;;
}

/*Functionality of the mapping operation.  (Contributed by Mario Carneiro,
       26-Jul-2013.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fmpt (x : set, A : class, B : class, C : class, F : class) disjointed(x y A, x y B, y C, y F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A C ∈ B ↔ F : A ⟶ B ) ;;
}

proof of fmpt {
	var y : set;;
	step 1 : wff = fnmpt (hyp 1) |- ( ∀ x ∈ A C ∈ B → F Fn A ) ;;
	step 2 : wff = rnmpt (hyp 1) |- ran F = { y | ∃ x ∈ A y = C } ;;
	step 3 : wff = r19.29 () |- ( ( ∀ x ∈ A C ∈ B ∧ ∃ x ∈ A y = C ) → ∃ x ∈ A ( C ∈ B ∧ y = C ) ) ;;
	step 4 : wff = eleq1 () |- ( y = C → ( y ∈ B ↔ C ∈ B ) ) ;;
	step 5 : wff = biimparc (step 4) |- ( ( C ∈ B ∧ y = C ) → y ∈ B ) ;;
	step 6 : wff = rexlimivw (step 5) |- ( ∃ x ∈ A ( C ∈ B ∧ y = C ) → y ∈ B ) ;;
	step 7 : wff = syl (step 3, step 6) |- ( ( ∀ x ∈ A C ∈ B ∧ ∃ x ∈ A y = C ) → y ∈ B ) ;;
	step 8 : wff = ex (step 7) |- ( ∀ x ∈ A C ∈ B → ( ∃ x ∈ A y = C → y ∈ B ) ) ;;
	step 9 : wff = abssdv (step 8) |- ( ∀ x ∈ A C ∈ B → { y | ∃ x ∈ A y = C } ⊆ B ) ;;
	step 10 : wff = syl5eqss (step 2, step 9) |- ( ∀ x ∈ A C ∈ B → ran F ⊆ B ) ;;
	step 11 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 12 : wff = sylanbrc (step 1, step 10, step 11) |- ( ∀ x ∈ A C ∈ B → F : A ⟶ B ) ;;
	step 13 : wff = mptpreima (hyp 1) |- ( ⁻¹ F " B ) = { x ∈ A | C ∈ B } ;;
	step 14 : wff = fimacnv () |- ( F : A ⟶ B → ( ⁻¹ F " B ) = A ) ;;
	step 15 : wff = syl5reqr (step 13, step 14) |- ( F : A ⟶ B → A = { x ∈ A | C ∈ B } ) ;;
	step 16 : wff = rabid2 () |- ( A = { x ∈ A | C ∈ B } ↔ ∀ x ∈ A C ∈ B ) ;;
	step 17 : wff = sylib (step 15, step 16) |- ( F : A ⟶ B → ∀ x ∈ A C ∈ B ) ;;
	step 18 : wff = impbii (step 12, step 17) |- ( ∀ x ∈ A C ∈ B ↔ F : A ⟶ B ) ;;
	qed prop 1 = step 18 ;;
}

/*Express bijection for a mapping operation.  (Contributed by Mario
       Carneiro, 30-May-2015.)  (Revised by Mario Carneiro, 4-Dec-2016.) */

theorem f1ompt (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(x y z A, x y z B, y z C, y z F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⤖ B ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ y ∈ B ∃! x ∈ A y = C ) ) ;;
}

proof of f1ompt {
	var z : set;;
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = dff1o4 () |- ( F : A ⤖ B ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
	step 3 : wff = baib (step 2) |- ( F Fn A → ( F : A ⤖ B ↔ ⁻¹ F Fn B ) ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( F : A ⟶ B → ( F : A ⤖ B ↔ ⁻¹ F Fn B ) ) ;;
	step 5 : wff = fnres () |- ( ( ⁻¹ F ↾ B ) Fn B ↔ ∀ y ∈ B ∃! z y ⁻¹ F z ) ;;
	step 6 : wff = nfcv () |- F/_ x z ;;
	step 7 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ C ) ;;
	step 8 : wff = nfcxfr (hyp 1, step 7) |- F/_ x F ;;
	step 9 : wff = nfcv () |- F/_ x y ;;
	step 10 : wff = nfbr (step 6, step 8, step 9) |- F/ x z F y ;;
	step 11 : wff = nfv () |- F/ z ( x ∈ A ∧ y = C ) ;;
	step 12 : wff = breq1 () |- ( z = x → ( z F y ↔ x F y ) ) ;;
	step 13 : wff = df-mpt () |- ( x ∈ A ↦ C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 14 : wff = eqtri (hyp 1, step 13) |- F = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 15 : wff = breqi (step 14) |- ( x F y ↔ x { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } y ) ;;
	step 16 : wff = df-br () |- ( x { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } y ↔ 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ) ;;
	step 17 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ↔ ( x ∈ A ∧ y = C ) ) ;;
	step 18 : wff = bitri (step 16, step 17) |- ( x { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } y ↔ ( x ∈ A ∧ y = C ) ) ;;
	step 19 : wff = bitri (step 15, step 18) |- ( x F y ↔ ( x ∈ A ∧ y = C ) ) ;;
	step 20 : wff = syl6bb (step 12, step 19) |- ( z = x → ( z F y ↔ ( x ∈ A ∧ y = C ) ) ) ;;
	step 21 : wff = cbveu (step 10, step 11, step 20) |- ( ∃! z z F y ↔ ∃! x ( x ∈ A ∧ y = C ) ) ;;
	step 22 : wff = vex () |- y ∈ _V ;;
	step 23 : wff = vex () |- z ∈ _V ;;
	step 24 : wff = brcnv (step 22, step 23) |- ( y ⁻¹ F z ↔ z F y ) ;;
	step 25 : wff = eubii (step 24) |- ( ∃! z y ⁻¹ F z ↔ ∃! z z F y ) ;;
	step 26 : wff = df-reu () |- ( ∃! x ∈ A y = C ↔ ∃! x ( x ∈ A ∧ y = C ) ) ;;
	step 27 : wff = 3bitr4i (step 21, step 25, step 26) |- ( ∃! z y ⁻¹ F z ↔ ∃! x ∈ A y = C ) ;;
	step 28 : wff = ralbii (step 27) |- ( ∀ y ∈ B ∃! z y ⁻¹ F z ↔ ∀ y ∈ B ∃! x ∈ A y = C ) ;;
	step 29 : wff = bitri (step 5, step 28) |- ( ( ⁻¹ F ↾ B ) Fn B ↔ ∀ y ∈ B ∃! x ∈ A y = C ) ;;
	step 30 : wff = relcnv () |- Rel ⁻¹ F ;;
	step 31 : wff = df-rn () |- ran F = dom ⁻¹ F ;;
	step 32 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 33 : wff = syl5eqssr (step 31, step 32) |- ( F : A ⟶ B → dom ⁻¹ F ⊆ B ) ;;
	step 34 : wff = relssres () |- ( ( Rel ⁻¹ F ∧ dom ⁻¹ F ⊆ B ) → ( ⁻¹ F ↾ B ) = ⁻¹ F ) ;;
	step 35 : wff = sylancr (step 30, step 33, step 34) |- ( F : A ⟶ B → ( ⁻¹ F ↾ B ) = ⁻¹ F ) ;;
	step 36 : wff = fneq1d (step 35) |- ( F : A ⟶ B → ( ( ⁻¹ F ↾ B ) Fn B ↔ ⁻¹ F Fn B ) ) ;;
	step 37 : wff = syl5bbr (step 29, step 36) |- ( F : A ⟶ B → ( ∀ y ∈ B ∃! x ∈ A y = C ↔ ⁻¹ F Fn B ) ) ;;
	step 38 : wff = bitr4d (step 4, step 37) |- ( F : A ⟶ B → ( F : A ⤖ B ↔ ∀ y ∈ B ∃! x ∈ A y = C ) ) ;;
	step 39 : wff = pm5.32i (step 38) |- ( ( F : A ⟶ B ∧ F : A ⤖ B ) ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃! x ∈ A y = C ) ) ;;
	step 40 : wff = f1of () |- ( F : A ⤖ B → F : A ⟶ B ) ;;
	step 41 : wff = pm4.71ri (step 40) |- ( F : A ⤖ B ↔ ( F : A ⟶ B ∧ F : A ⤖ B ) ) ;;
	step 42 : wff = fmpt (hyp 1) |- ( ∀ x ∈ A C ∈ B ↔ F : A ⟶ B ) ;;
	step 43 : wff = anbi1i (step 42) |- ( ( ∀ x ∈ A C ∈ B ∧ ∀ y ∈ B ∃! x ∈ A y = C ) ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃! x ∈ A y = C ) ) ;;
	step 44 : wff = 3bitr4i (step 39, step 41, step 43) |- ( F : A ⤖ B ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ y ∈ B ∃! x ∈ A y = C ) ) ;;
	qed prop 1 = step 44 ;;
}

/*Functionality of the mapping operation.  (Contributed by NM,
       19-Mar-2005.)  (Revised by Mario Carneiro, 1-Sep-2015.) */

theorem fmpti (x : set, A : class, B : class, C : class, F : class) disjointed(x A, x B, C, F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	hyp 2 : wff = |- ( x ∈ A → C ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- F : A ⟶ B ;;
}

proof of fmpti {
	step 1 : wff = rgen (hyp 2) |- ∀ x ∈ A C ∈ B ;;
	step 2 : wff = fmpt (hyp 1) |- ( ∀ x ∈ A C ∈ B ↔ F : A ⟶ B ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- F : A ⟶ B ;;
	qed prop 1 = step 3 ;;
}

/*Domain and codomain of the mapping operation; deduction form.
       (Contributed by Mario Carneiro, 13-Jan-2013.) */

theorem fmptd (ph : wff, x : set, A : class, B : class, C : class, F : class) disjointed(x A, B, x C, x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → B ∈ C ) ;;
	hyp 2 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F : A ⟶ C ) ;;
}

proof of fmptd {
	step 1 : wff = ralrimiva (hyp 1) |- ( ph → ∀ x ∈ A B ∈ C ) ;;
	step 2 : wff = fmpt (hyp 2) |- ( ∀ x ∈ A B ∈ C ↔ F : A ⟶ C ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ph → F : A ⟶ C ) ;;
	qed prop 1 = step 3 ;;
}

/*A function maps to a class to which all values belong.  (Contributed by
       NM, 3-Dec-2003.) */

theorem ffnfv (x : set, A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( F : A ⟶ B ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
}

proof of ffnfv {
	var y : set;;
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( F ` x ) ∈ B ) ;;
	step 3 : wff = ralrimiva (step 2) |- ( F : A ⟶ B → ∀ x ∈ A ( F ` x ) ∈ B ) ;;
	step 4 : wff = jca (step 1, step 3) |- ( F : A ⟶ B → ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 5 : wff = simpl () |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) → F Fn A ) ;;
	step 6 : wff = fvelrnb () |- ( F Fn A → ( y ∈ ran F ↔ ∃ x ∈ A ( F ` x ) = y ) ) ;;
	step 7 : wff = biimpd (step 6) |- ( F Fn A → ( y ∈ ran F → ∃ x ∈ A ( F ` x ) = y ) ) ;;
	step 8 : wff = nfra1 () |- F/ x ∀ x ∈ A ( F ` x ) ∈ B ;;
	step 9 : wff = nfv () |- F/ x y ∈ B ;;
	step 10 : wff = rsp () |- ( ∀ x ∈ A ( F ` x ) ∈ B → ( x ∈ A → ( F ` x ) ∈ B ) ) ;;
	step 11 : wff = eleq1 () |- ( ( F ` x ) = y → ( ( F ` x ) ∈ B ↔ y ∈ B ) ) ;;
	step 12 : wff = biimpcd (step 11) |- ( ( F ` x ) ∈ B → ( ( F ` x ) = y → y ∈ B ) ) ;;
	step 13 : wff = syl6 (step 10, step 12) |- ( ∀ x ∈ A ( F ` x ) ∈ B → ( x ∈ A → ( ( F ` x ) = y → y ∈ B ) ) ) ;;
	step 14 : wff = rexlimd (step 8, step 9, step 13) |- ( ∀ x ∈ A ( F ` x ) ∈ B → ( ∃ x ∈ A ( F ` x ) = y → y ∈ B ) ) ;;
	step 15 : wff = sylan9 (step 7, step 14) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) → ( y ∈ ran F → y ∈ B ) ) ;;
	step 16 : wff = ssrdv (step 15) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) → ran F ⊆ B ) ;;
	step 17 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 18 : wff = sylanbrc (step 5, step 16, step 17) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) → F : A ⟶ B ) ;;
	step 19 : wff = impbii (step 4, step 18) |- ( F : A ⟶ B ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	qed prop 1 = step 19 ;;
}

/*A function maps to a class to which all values belong.  This version of
       ~ ffnfv uses bound-variable hypotheses instead of distinct variable
       conditions.  (Contributed by NM, 28-Sep-2006.) */

theorem ffnfvf (x : set, A : class, B : class, F : class) disjointed(z A, z B, z F, x z) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	hyp 3 : wff = |- F/_ x F ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ B ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
}

proof of ffnfvf {
	var z : set;;
	step 1 : wff = ffnfv () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ∀ z ∈ A ( F ` z ) ∈ B ) ) ;;
	step 2 : wff = nfcv () |- F/_ z A ;;
	step 3 : wff = nfcv () |- F/_ x z ;;
	step 4 : wff = nffv (hyp 3, step 3) |- F/_ x ( F ` z ) ;;
	step 5 : wff = nfel (step 4, hyp 2) |- F/ x ( F ` z ) ∈ B ;;
	step 6 : wff = nfv () |- F/ z ( F ` x ) ∈ B ;;
	step 7 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 8 : wff = eleq1d (step 7) |- ( z = x → ( ( F ` z ) ∈ B ↔ ( F ` x ) ∈ B ) ) ;;
	step 9 : wff = cbvralf (step 2, hyp 1, step 5, step 6, step 8) |- ( ∀ z ∈ A ( F ` z ) ∈ B ↔ ∀ x ∈ A ( F ` x ) ∈ B ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( F Fn A ∧ ∀ z ∈ A ( F ` z ) ∈ B ) ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( F : A ⟶ B ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	qed prop 1 = step 11 ;;
}

/*An upper bound for range determined by function values.  (Contributed by
       NM, 8-Oct-2004.) */

theorem fnfvrnss (x : set, A : class, B : class, F : class) disjointed(x A, x B, x F) {
	prop 1 : wff = |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) → ran F ⊆ B ) ;;
}

proof of fnfvrnss {
	step 1 : wff = ffnfv () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) ) ;;
	step 2 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 3 : wff = sylbir (step 1, step 2) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) ∈ B ) → ran F ⊆ B ) ;;
	qed prop 1 = step 3 ;;
}

/*Domain and codomain of the mapping operation; deduction form.
       (Contributed by NM, 27-Dec-2014.) */

theorem fmpt2d (ph : wff, x : set, y : set, A : class, B : class, C : class, F : class, V : class) disjointed(x A, y A, y C, y F, x ph, y ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → B ∈ V ) ;;
	hyp 2 : wff = |- ( ph → F = ( x ∈ A ↦ B ) ) ;;
	hyp 3 : wff = |- ( ( ph ∧ y ∈ A ) → ( F ` y ) ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F : A ⟶ C ) ;;
}

proof of fmpt2d {
	step 1 : wff = ralrimiva (hyp 1) |- ( ph → ∀ x ∈ A B ∈ V ) ;;
	step 2 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 3 : wff = fnmpt (step 2) |- ( ∀ x ∈ A B ∈ V → ( x ∈ A ↦ B ) Fn A ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( ph → ( x ∈ A ↦ B ) Fn A ) ;;
	step 5 : wff = fneq1d (hyp 2) |- ( ph → ( F Fn A ↔ ( x ∈ A ↦ B ) Fn A ) ) ;;
	step 6 : wff = mpbird (step 4, step 5) |- ( ph → F Fn A ) ;;
	step 7 : wff = ralrimiva (hyp 3) |- ( ph → ∀ y ∈ A ( F ` y ) ∈ C ) ;;
	step 8 : wff = ffnfv () |- ( F : A ⟶ C ↔ ( F Fn A ∧ ∀ y ∈ A ( F ` y ) ∈ C ) ) ;;
	step 9 : wff = sylanbrc (step 6, step 7, step 8) |- ( ph → F : A ⟶ C ) ;;
	qed prop 1 = step 9 ;;
}

/*Domain and codomain of the mapping operation; deduction form.
       (Contributed by NM, 9-Apr-2013.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem fmpt2dOLD (ph : wff, x : set, y : set, A : class, B : class, C : class, F : class, V : class) disjointed(x y A, y C, y F, x y ph) {
	hyp 1 : wff = |- ( ph → ( x ∈ A → B ∈ V ) ) ;;
	hyp 2 : wff = |- F = ( x ∈ A ↦ B ) ;;
	hyp 3 : wff = |- ( ph → ( y ∈ A → ( F ` y ) ∈ C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F : A ⟶ C ) ;;
}

proof of fmpt2dOLD {
	step 1 : wff = imp (hyp 1) |- ( ( ph ∧ x ∈ A ) → B ∈ V ) ;;
	step 2 : wff = a1i (hyp 2) |- ( ph → F = ( x ∈ A ↦ B ) ) ;;
	step 3 : wff = imp (hyp 3) |- ( ( ph ∧ y ∈ A ) → ( F ` y ) ∈ C ) ;;
	step 4 : wff = fmpt2d (step 1, step 2, step 3) |- ( ph → F : A ⟶ C ) ;;
	qed prop 1 = step 4 ;;
}

/*A necessary and sufficient condition for a restricted function.
       (Contributed by Mario Carneiro, 14-Nov-2013.) */

theorem ffvresb (x : set, A : class, B : class, F : class) disjointed(x A, x B, x F) {
	prop 1 : wff = |- ( Fun F → ( ( F ↾ A ) : A ⟶ B ↔ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ;;
}

proof of ffvresb {
	step 1 : wff = fdm () |- ( ( F ↾ A ) : A ⟶ B → dom ( F ↾ A ) = A ) ;;
	step 2 : wff = dmres () |- dom ( F ↾ A ) = ( A ∩ dom F ) ;;
	step 3 : wff = inss2 () |- ( A ∩ dom F ) ⊆ dom F ;;
	step 4 : wff = eqsstri (step 2, step 3) |- dom ( F ↾ A ) ⊆ dom F ;;
	step 5 : wff = a1i (step 4) |- ( ( F ↾ A ) : A ⟶ B → dom ( F ↾ A ) ⊆ dom F ) ;;
	step 6 : wff = eqsstr3d (step 1, step 5) |- ( ( F ↾ A ) : A ⟶ B → A ⊆ dom F ) ;;
	step 7 : wff = sselda (step 6) |- ( ( ( F ↾ A ) : A ⟶ B ∧ x ∈ A ) → x ∈ dom F ) ;;
	step 8 : wff = fvres () |- ( x ∈ A → ( ( F ↾ A ) ` x ) = ( F ` x ) ) ;;
	step 9 : wff = adantl (step 8) |- ( ( ( F ↾ A ) : A ⟶ B ∧ x ∈ A ) → ( ( F ↾ A ) ` x ) = ( F ` x ) ) ;;
	step 10 : wff = ffvelrn () |- ( ( ( F ↾ A ) : A ⟶ B ∧ x ∈ A ) → ( ( F ↾ A ) ` x ) ∈ B ) ;;
	step 11 : wff = eqeltrrd (step 9, step 10) |- ( ( ( F ↾ A ) : A ⟶ B ∧ x ∈ A ) → ( F ` x ) ∈ B ) ;;
	step 12 : wff = jca (step 7, step 11) |- ( ( ( F ↾ A ) : A ⟶ B ∧ x ∈ A ) → ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ;;
	step 13 : wff = ralrimiva (step 12) |- ( ( F ↾ A ) : A ⟶ B → ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ;;
	step 14 : wff = simpl () |- ( ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → x ∈ dom F ) ;;
	step 15 : wff = ralimi (step 14) |- ( ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → ∀ x ∈ A x ∈ dom F ) ;;
	step 16 : wff = dfss3 () |- ( A ⊆ dom F ↔ ∀ x ∈ A x ∈ dom F ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → A ⊆ dom F ) ;;
	step 18 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 19 : wff = fnssres () |- ( ( F Fn dom F ∧ A ⊆ dom F ) → ( F ↾ A ) Fn A ) ;;
	step 20 : wff = sylanb (step 18, step 19) |- ( ( Fun F ∧ A ⊆ dom F ) → ( F ↾ A ) Fn A ) ;;
	step 21 : wff = sylan2 (step 17, step 20) |- ( ( Fun F ∧ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) → ( F ↾ A ) Fn A ) ;;
	step 22 : wff = simpl () |- ( ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → x ∈ dom F ) ;;
	step 23 : wff = ralimi (step 22) |- ( ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → ∀ x ∈ A x ∈ dom F ) ;;
	step 24 : wff = dfss3 () |- ( A ⊆ dom F ↔ ∀ x ∈ A x ∈ dom F ) ;;
	step 25 : wff = sylibr (step 23, step 24) |- ( ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → A ⊆ dom F ) ;;
	step 26 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 27 : wff = fnssres () |- ( ( F Fn dom F ∧ A ⊆ dom F ) → ( F ↾ A ) Fn A ) ;;
	step 28 : wff = sylanb (step 26, step 27) |- ( ( Fun F ∧ A ⊆ dom F ) → ( F ↾ A ) Fn A ) ;;
	step 29 : wff = sylan2 (step 25, step 28) |- ( ( Fun F ∧ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) → ( F ↾ A ) Fn A ) ;;
	step 30 : wff = simpr () |- ( ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → ( F ` x ) ∈ B ) ;;
	step 31 : wff = fvres () |- ( x ∈ A → ( ( F ↾ A ) ` x ) = ( F ` x ) ) ;;
	step 32 : wff = eleq1d (step 31) |- ( x ∈ A → ( ( ( F ↾ A ) ` x ) ∈ B ↔ ( F ` x ) ∈ B ) ) ;;
	step 33 : wff = syl5ibr (step 30, step 32) |- ( x ∈ A → ( ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → ( ( F ↾ A ) ` x ) ∈ B ) ) ;;
	step 34 : wff = ralimia (step 33) |- ( ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → ∀ x ∈ A ( ( F ↾ A ) ` x ) ∈ B ) ;;
	step 35 : wff = adantl (step 34) |- ( ( Fun F ∧ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) → ∀ x ∈ A ( ( F ↾ A ) ` x ) ∈ B ) ;;
	step 36 : wff = fnfvrnss () |- ( ( ( F ↾ A ) Fn A ∧ ∀ x ∈ A ( ( F ↾ A ) ` x ) ∈ B ) → ran ( F ↾ A ) ⊆ B ) ;;
	step 37 : wff = syl2anc (step 29, step 35, step 36) |- ( ( Fun F ∧ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) → ran ( F ↾ A ) ⊆ B ) ;;
	step 38 : wff = df-f () |- ( ( F ↾ A ) : A ⟶ B ↔ ( ( F ↾ A ) Fn A ∧ ran ( F ↾ A ) ⊆ B ) ) ;;
	step 39 : wff = sylanbrc (step 21, step 37, step 38) |- ( ( Fun F ∧ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) → ( F ↾ A ) : A ⟶ B ) ;;
	step 40 : wff = ex (step 39) |- ( Fun F → ( ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) → ( F ↾ A ) : A ⟶ B ) ) ;;
	step 41 : wff = impbid2 (step 13, step 40) |- ( Fun F → ( ( F ↾ A ) : A ⟶ B ↔ ∀ x ∈ A ( x ∈ dom F ∧ ( F ` x ) ∈ B ) ) ) ;;
	qed prop 1 = step 41 ;;
}

/*Composition of two functions expressed as ordered-pair class
       abstractions.  If ` F ` has the equation ` ( x + 2 ) ` and ` G ` the
       equation ` ( 3 * z ) ` then ` ( G o. F ) ` has the equation
       ` ( 3 * ( x + 2 ) ) ` .  (Contributed by FL, 21-Jun-2012.)  (Revised by
       Mario Carneiro, 24-Jul-2014.) */

theorem fmptco (ph : wff, x : set, y : set, A : class, B : class, R : class, S : class, T : class, F : class, G : class) disjointed(u v w x z A, u x y B, u w z F, u w z G, u y R, u w x z ph, u x S, u v w y z T) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → R ∈ B ) ;;
	hyp 2 : wff = |- ( ph → F = ( x ∈ A ↦ R ) ) ;;
	hyp 3 : wff = |- ( ph → G = ( y ∈ B ↦ S ) ) ;;
	hyp 4 : wff = |- ( y = R → S = T ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ T ) ) ;;
}

proof of fmptco {
	var z : set, w : set, v : set, u : set;;
	step 1 : wff = relco () |- Rel ( G ∘ F ) ;;
	step 2 : wff = funmpt () |- Fun ( x ∈ A ↦ T ) ;;
	step 3 : wff = funrel () |- ( Fun ( x ∈ A ↦ T ) → Rel ( x ∈ A ↦ T ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- Rel ( x ∈ A ↦ T ) ;;
	step 5 : wff = eqid () |- ( x ∈ A ↦ R ) = ( x ∈ A ↦ R ) ;;
	step 6 : wff = fmptd (hyp 1, step 5) |- ( ph → ( x ∈ A ↦ R ) : A ⟶ B ) ;;
	step 7 : wff = feq1d (hyp 2) |- ( ph → ( F : A ⟶ B ↔ ( x ∈ A ↦ R ) : A ⟶ B ) ) ;;
	step 8 : wff = mpbird (step 6, step 7) |- ( ph → F : A ⟶ B ) ;;
	step 9 : wff = ffun () |- ( F : A ⟶ B → Fun F ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ph → Fun F ) ;;
	step 11 : wff = funbrfv () |- ( Fun F → ( z F u → ( F ` z ) = u ) ) ;;
	step 12 : wff = imp (step 11) |- ( ( Fun F ∧ z F u ) → ( F ` z ) = u ) ;;
	step 13 : wff = sylan (step 10, step 12) |- ( ( ph ∧ z F u ) → ( F ` z ) = u ) ;;
	step 14 : wff = eqcomd (step 13) |- ( ( ph ∧ z F u ) → u = ( F ` z ) ) ;;
	step 15 : wff = a1d (step 14) |- ( ( ph ∧ z F u ) → ( u G w → u = ( F ` z ) ) ) ;;
	step 16 : wff = expimpd (step 15) |- ( ph → ( ( z F u ∧ u G w ) → u = ( F ` z ) ) ) ;;
	step 17 : wff = pm4.71rd (step 16) |- ( ph → ( ( z F u ∧ u G w ) ↔ ( u = ( F ` z ) ∧ ( z F u ∧ u G w ) ) ) ) ;;
	step 18 : wff = exbidv (step 17) |- ( ph → ( ∃ u ( z F u ∧ u G w ) ↔ ∃ u ( u = ( F ` z ) ∧ ( z F u ∧ u G w ) ) ) ) ;;
	step 19 : wff = fvex () |- ( F ` z ) ∈ _V ;;
	step 20 : wff = breq2 () |- ( u = ( F ` z ) → ( z F u ↔ z F ( F ` z ) ) ) ;;
	step 21 : wff = breq1 () |- ( u = ( F ` z ) → ( u G w ↔ ( F ` z ) G w ) ) ;;
	step 22 : wff = anbi12d (step 20, step 21) |- ( u = ( F ` z ) → ( ( z F u ∧ u G w ) ↔ ( z F ( F ` z ) ∧ ( F ` z ) G w ) ) ) ;;
	step 23 : wff = ceqsexv (step 19, step 22) |- ( ∃ u ( u = ( F ` z ) ∧ ( z F u ∧ u G w ) ) ↔ ( z F ( F ` z ) ∧ ( F ` z ) G w ) ) ;;
	step 24 : wff = eqid () |- ( x ∈ A ↦ R ) = ( x ∈ A ↦ R ) ;;
	step 25 : wff = fmptd (hyp 1, step 24) |- ( ph → ( x ∈ A ↦ R ) : A ⟶ B ) ;;
	step 26 : wff = feq1d (hyp 2) |- ( ph → ( F : A ⟶ B ↔ ( x ∈ A ↦ R ) : A ⟶ B ) ) ;;
	step 27 : wff = mpbird (step 25, step 26) |- ( ph → F : A ⟶ B ) ;;
	step 28 : wff = ffun () |- ( F : A ⟶ B → Fun F ) ;;
	step 29 : wff = syl (step 27, step 28) |- ( ph → Fun F ) ;;
	step 30 : wff = funfvbrb () |- ( Fun F → ( z ∈ dom F ↔ z F ( F ` z ) ) ) ;;
	step 31 : wff = syl (step 29, step 30) |- ( ph → ( z ∈ dom F ↔ z F ( F ` z ) ) ) ;;
	step 32 : wff = eqid () |- ( x ∈ A ↦ R ) = ( x ∈ A ↦ R ) ;;
	step 33 : wff = fmptd (hyp 1, step 32) |- ( ph → ( x ∈ A ↦ R ) : A ⟶ B ) ;;
	step 34 : wff = feq1d (hyp 2) |- ( ph → ( F : A ⟶ B ↔ ( x ∈ A ↦ R ) : A ⟶ B ) ) ;;
	step 35 : wff = mpbird (step 33, step 34) |- ( ph → F : A ⟶ B ) ;;
	step 36 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 37 : wff = syl (step 35, step 36) |- ( ph → dom F = A ) ;;
	step 38 : wff = eleq2d (step 37) |- ( ph → ( z ∈ dom F ↔ z ∈ A ) ) ;;
	step 39 : wff = bitr3d (step 31, step 38) |- ( ph → ( z F ( F ` z ) ↔ z ∈ A ) ) ;;
	step 40 : wff = fveq1d (hyp 2) |- ( ph → ( F ` z ) = ( ( x ∈ A ↦ R ) ` z ) ) ;;
	step 41 : wff = eqidd () |- ( ph → w = w ) ;;
	step 42 : wff = breq123d (step 40, hyp 3, step 41) |- ( ph → ( ( F ` z ) G w ↔ ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ) ) ;;
	step 43 : wff = anbi12d (step 39, step 42) |- ( ph → ( ( z F ( F ` z ) ∧ ( F ` z ) G w ) ↔ ( z ∈ A ∧ ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ) ) ) ;;
	step 44 : wff = nfcv () |- F/_ x z ;;
	step 45 : wff = nfv () |- F/ x ph ;;
	step 46 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ R ) ;;
	step 47 : wff = nfcv () |- F/_ x z ;;
	step 48 : wff = nffv (step 46, step 47) |- F/_ x ( ( x ∈ A ↦ R ) ` z ) ;;
	step 49 : wff = nfcv () |- F/_ x ( y ∈ B ↦ S ) ;;
	step 50 : wff = nfcv () |- F/_ x w ;;
	step 51 : wff = nfbr (step 48, step 49, step 50) |- F/ x ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ;;
	step 52 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ T ;;
	step 53 : wff = nfeq2 (step 52) |- F/ x w = [_ z / x ]_ T ;;
	step 54 : wff = nfbi (step 51, step 53) |- F/ x ( ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ↔ w = [_ z / x ]_ T ) ;;
	step 55 : wff = nfim (step 45, step 54) |- F/ x ( ph → ( ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ↔ w = [_ z / x ]_ T ) ) ;;
	step 56 : wff = fveq2 () |- ( x = z → ( ( x ∈ A ↦ R ) ` x ) = ( ( x ∈ A ↦ R ) ` z ) ) ;;
	step 57 : wff = breq1d (step 56) |- ( x = z → ( ( ( x ∈ A ↦ R ) ` x ) ( y ∈ B ↦ S ) w ↔ ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ) ) ;;
	step 58 : wff = csbeq1a () |- ( x = z → T = [_ z / x ]_ T ) ;;
	step 59 : wff = eqeq2d (step 58) |- ( x = z → ( w = T ↔ w = [_ z / x ]_ T ) ) ;;
	step 60 : wff = bibi12d (step 57, step 59) |- ( x = z → ( ( ( ( x ∈ A ↦ R ) ` x ) ( y ∈ B ↦ S ) w ↔ w = T ) ↔ ( ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ↔ w = [_ z / x ]_ T ) ) ) ;;
	step 61 : wff = imbi2d (step 60) |- ( x = z → ( ( ph → ( ( ( x ∈ A ↦ R ) ` x ) ( y ∈ B ↦ S ) w ↔ w = T ) ) ↔ ( ph → ( ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ↔ w = [_ z / x ]_ T ) ) ) ) ;;
	step 62 : wff = vex () |- w ∈ _V ;;
	step 63 : wff = simpl () |- ( ( y = R ∧ u = w ) → y = R ) ;;
	step 64 : wff = eleq1d (step 63) |- ( ( y = R ∧ u = w ) → ( y ∈ B ↔ R ∈ B ) ) ;;
	step 65 : wff = simpr () |- ( ( y = R ∧ u = w ) → u = w ) ;;
	step 66 : wff = adantr (hyp 4) |- ( ( y = R ∧ u = w ) → S = T ) ;;
	step 67 : wff = eqeq12d (step 65, step 66) |- ( ( y = R ∧ u = w ) → ( u = S ↔ w = T ) ) ;;
	step 68 : wff = anbi12d (step 64, step 67) |- ( ( y = R ∧ u = w ) → ( ( y ∈ B ∧ u = S ) ↔ ( R ∈ B ∧ w = T ) ) ) ;;
	step 69 : wff = df-mpt () |- ( y ∈ B ↦ S ) = { 〈 y , u 〉 | ( y ∈ B ∧ u = S ) } ;;
	step 70 : wff = brabga (step 68, step 69) |- ( ( R ∈ B ∧ w ∈ _V ) → ( R ( y ∈ B ↦ S ) w ↔ ( R ∈ B ∧ w = T ) ) ) ;;
	step 71 : wff = sylancl (hyp 1, step 62, step 70) |- ( ( ph ∧ x ∈ A ) → ( R ( y ∈ B ↦ S ) w ↔ ( R ∈ B ∧ w = T ) ) ) ;;
	step 72 : wff = simpr () |- ( ( ph ∧ x ∈ A ) → x ∈ A ) ;;
	step 73 : wff = eqid () |- ( x ∈ A ↦ R ) = ( x ∈ A ↦ R ) ;;
	step 74 : wff = fvmpt2 (step 73) |- ( ( x ∈ A ∧ R ∈ B ) → ( ( x ∈ A ↦ R ) ` x ) = R ) ;;
	step 75 : wff = syl2anc (step 72, hyp 1, step 74) |- ( ( ph ∧ x ∈ A ) → ( ( x ∈ A ↦ R ) ` x ) = R ) ;;
	step 76 : wff = breq1d (step 75) |- ( ( ph ∧ x ∈ A ) → ( ( ( x ∈ A ↦ R ) ` x ) ( y ∈ B ↦ S ) w ↔ R ( y ∈ B ↦ S ) w ) ) ;;
	step 77 : wff = biantrurd (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( w = T ↔ ( R ∈ B ∧ w = T ) ) ) ;;
	step 78 : wff = 3bitr4d (step 71, step 76, step 77) |- ( ( ph ∧ x ∈ A ) → ( ( ( x ∈ A ↦ R ) ` x ) ( y ∈ B ↦ S ) w ↔ w = T ) ) ;;
	step 79 : wff = expcom (step 78) |- ( x ∈ A → ( ph → ( ( ( x ∈ A ↦ R ) ` x ) ( y ∈ B ↦ S ) w ↔ w = T ) ) ) ;;
	step 80 : wff = vtoclgaf (step 44, step 55, step 61, step 79) |- ( z ∈ A → ( ph → ( ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ↔ w = [_ z / x ]_ T ) ) ) ;;
	step 81 : wff = impcom (step 80) |- ( ( ph ∧ z ∈ A ) → ( ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ↔ w = [_ z / x ]_ T ) ) ;;
	step 82 : wff = pm5.32da (step 81) |- ( ph → ( ( z ∈ A ∧ ( ( x ∈ A ↦ R ) ` z ) ( y ∈ B ↦ S ) w ) ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ) ;;
	step 83 : wff = bitrd (step 43, step 82) |- ( ph → ( ( z F ( F ` z ) ∧ ( F ` z ) G w ) ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ) ;;
	step 84 : wff = syl5bb (step 23, step 83) |- ( ph → ( ∃ u ( u = ( F ` z ) ∧ ( z F u ∧ u G w ) ) ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ) ;;
	step 85 : wff = bitrd (step 18, step 84) |- ( ph → ( ∃ u ( z F u ∧ u G w ) ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ) ;;
	step 86 : wff = vex () |- z ∈ _V ;;
	step 87 : wff = vex () |- w ∈ _V ;;
	step 88 : wff = opelco (step 86, step 87) |- ( 〈 z , w 〉 ∈ ( G ∘ F ) ↔ ∃ u ( z F u ∧ u G w ) ) ;;
	step 89 : wff = df-mpt () |- ( x ∈ A ↦ T ) = { 〈 x , v 〉 | ( x ∈ A ∧ v = T ) } ;;
	step 90 : wff = eleq2i (step 89) |- ( 〈 z , w 〉 ∈ ( x ∈ A ↦ T ) ↔ 〈 z , w 〉 ∈ { 〈 x , v 〉 | ( x ∈ A ∧ v = T ) } ) ;;
	step 91 : wff = nfv () |- F/ x z ∈ A ;;
	step 92 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ T ;;
	step 93 : wff = nfeq2 (step 92) |- F/ x v = [_ z / x ]_ T ;;
	step 94 : wff = nfan (step 91, step 93) |- F/ x ( z ∈ A ∧ v = [_ z / x ]_ T ) ;;
	step 95 : wff = nfv () |- F/ v ( z ∈ A ∧ w = [_ z / x ]_ T ) ;;
	step 96 : wff = vex () |- z ∈ _V ;;
	step 97 : wff = vex () |- w ∈ _V ;;
	step 98 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 99 : wff = csbeq1a () |- ( x = z → T = [_ z / x ]_ T ) ;;
	step 100 : wff = eqeq2d (step 99) |- ( x = z → ( v = T ↔ v = [_ z / x ]_ T ) ) ;;
	step 101 : wff = anbi12d (step 98, step 100) |- ( x = z → ( ( x ∈ A ∧ v = T ) ↔ ( z ∈ A ∧ v = [_ z / x ]_ T ) ) ) ;;
	step 102 : wff = eqeq1 () |- ( v = w → ( v = [_ z / x ]_ T ↔ w = [_ z / x ]_ T ) ) ;;
	step 103 : wff = anbi2d (step 102) |- ( v = w → ( ( z ∈ A ∧ v = [_ z / x ]_ T ) ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ) ;;
	step 104 : wff = opelopabf (step 94, step 95, step 96, step 97, step 101, step 103) |- ( 〈 z , w 〉 ∈ { 〈 x , v 〉 | ( x ∈ A ∧ v = T ) } ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ;;
	step 105 : wff = bitri (step 90, step 104) |- ( 〈 z , w 〉 ∈ ( x ∈ A ↦ T ) ↔ ( z ∈ A ∧ w = [_ z / x ]_ T ) ) ;;
	step 106 : wff = 3bitr4g (step 85, step 88, step 105) |- ( ph → ( 〈 z , w 〉 ∈ ( G ∘ F ) ↔ 〈 z , w 〉 ∈ ( x ∈ A ↦ T ) ) ) ;;
	step 107 : wff = eqrelrdv (step 1, step 4, step 106) |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ T ) ) ;;
	qed prop 1 = step 107 ;;
}

/*Version of ~ fmptco where ` ph ` needn't be distinct from ` x ` .
         (Contributed by NM, 27-Dec-2014.) */

theorem fmptcof (ph : wff, x : set, y : set, A : class, B : class, R : class, S : class, T : class, F : class, G : class) disjointed(w x y z B, w y z R, w x z S, x z A, y z T, z ph) {
	hyp 1 : wff = |- ( ph → ∀ x ∈ A R ∈ B ) ;;
	hyp 2 : wff = |- ( ph → F = ( x ∈ A ↦ R ) ) ;;
	hyp 3 : wff = |- ( ph → G = ( y ∈ B ↦ S ) ) ;;
	hyp 4 : wff = |- ( y = R → S = T ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ T ) ) ;;
}

proof of fmptcof {
	var z : set, w : set;;
	step 1 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ R ;;
	step 2 : wff = nfel1 (step 1) |- F/ x [_ z / x ]_ R ∈ B ;;
	step 3 : wff = csbeq1a () |- ( x = z → R = [_ z / x ]_ R ) ;;
	step 4 : wff = eleq1d (step 3) |- ( x = z → ( R ∈ B ↔ [_ z / x ]_ R ∈ B ) ) ;;
	step 5 : wff = rspc (step 2, step 4) |- ( z ∈ A → ( ∀ x ∈ A R ∈ B → [_ z / x ]_ R ∈ B ) ) ;;
	step 6 : wff = mpan9 (hyp 1, step 5) |- ( ( ph ∧ z ∈ A ) → [_ z / x ]_ R ∈ B ) ;;
	step 7 : wff = nfcv () |- F/_ z R ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ R ;;
	step 9 : wff = csbeq1a () |- ( x = z → R = [_ z / x ]_ R ) ;;
	step 10 : wff = cbvmpt (step 7, step 8, step 9) |- ( x ∈ A ↦ R ) = ( z ∈ A ↦ [_ z / x ]_ R ) ;;
	step 11 : wff = syl6eq (hyp 2, step 10) |- ( ph → F = ( z ∈ A ↦ [_ z / x ]_ R ) ) ;;
	step 12 : wff = nfcv () |- F/_ w S ;;
	step 13 : wff = nfcsb1v () |- F/_ y [_ w / y ]_ S ;;
	step 14 : wff = csbeq1a () |- ( y = w → S = [_ w / y ]_ S ) ;;
	step 15 : wff = cbvmpt (step 12, step 13, step 14) |- ( y ∈ B ↦ S ) = ( w ∈ B ↦ [_ w / y ]_ S ) ;;
	step 16 : wff = syl6eq (hyp 3, step 15) |- ( ph → G = ( w ∈ B ↦ [_ w / y ]_ S ) ) ;;
	step 17 : wff = csbeq1 () |- ( w = [_ z / x ]_ R → [_ w / y ]_ S = [_ [_ z / x ]_ R / y ]_ S ) ;;
	step 18 : wff = fmptco (step 6, step 11, step 16, step 17) |- ( ph → ( G ∘ F ) = ( z ∈ A ↦ [_ [_ z / x ]_ R / y ]_ S ) ) ;;
	step 19 : wff = nfcv () |- F/_ z [_ R / y ]_ S ;;
	step 20 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ R ;;
	step 21 : wff = nfcv () |- F/_ x S ;;
	step 22 : wff = nfcsb (step 20, step 21) |- F/_ x [_ [_ z / x ]_ R / y ]_ S ;;
	step 23 : wff = csbeq1a () |- ( x = z → R = [_ z / x ]_ R ) ;;
	step 24 : wff = csbeq1d (step 23) |- ( x = z → [_ R / y ]_ S = [_ [_ z / x ]_ R / y ]_ S ) ;;
	step 25 : wff = cbvmpt (step 19, step 22, step 24) |- ( x ∈ A ↦ [_ R / y ]_ S ) = ( z ∈ A ↦ [_ [_ z / x ]_ R / y ]_ S ) ;;
	step 26 : wff = syl6eqr (step 18, step 25) |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ [_ R / y ]_ S ) ) ;;
	step 27 : wff = eqid () |- A = A ;;
	step 28 : wff = nfcvd () |- ( R ∈ B → F/_ y T ) ;;
	step 29 : wff = csbiegf (step 28, hyp 4) |- ( R ∈ B → [_ R / y ]_ S = T ) ;;
	step 30 : wff = ralimi (step 29) |- ( ∀ x ∈ A R ∈ B → ∀ x ∈ A [_ R / y ]_ S = T ) ;;
	step 31 : wff = mpteq12 () |- ( ( A = A ∧ ∀ x ∈ A [_ R / y ]_ S = T ) → ( x ∈ A ↦ [_ R / y ]_ S ) = ( x ∈ A ↦ T ) ) ;;
	step 32 : wff = sylancr (step 27, step 30, step 31) |- ( ∀ x ∈ A R ∈ B → ( x ∈ A ↦ [_ R / y ]_ S ) = ( x ∈ A ↦ T ) ) ;;
	step 33 : wff = syl (hyp 1, step 32) |- ( ph → ( x ∈ A ↦ [_ R / y ]_ S ) = ( x ∈ A ↦ T ) ) ;;
	step 34 : wff = eqtrd (step 26, step 33) |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ T ) ) ;;
	qed prop 1 = step 34 ;;
}

/*Composition of two functions expressed as mapping abstractions.
       (Contributed by NM, 22-May-2006.)  (Revised by Mario Carneiro,
       31-Aug-2015.) */

theorem fmptcos (ph : wff, x : set, y : set, A : class, B : class, R : class, S : class, F : class, G : class) disjointed(x y z B, y z R, x z S, x z A, y z, z ph) {
	hyp 1 : wff = |- ( ph → ∀ x ∈ A R ∈ B ) ;;
	hyp 2 : wff = |- ( ph → F = ( x ∈ A ↦ R ) ) ;;
	hyp 3 : wff = |- ( ph → G = ( y ∈ B ↦ S ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ [_ R / y ]_ S ) ) ;;
}

proof of fmptcos {
	var z : set;;
	step 1 : wff = nfcv () |- F/_ z S ;;
	step 2 : wff = nfcsb1v () |- F/_ y [_ z / y ]_ S ;;
	step 3 : wff = csbeq1a () |- ( y = z → S = [_ z / y ]_ S ) ;;
	step 4 : wff = cbvmpt (step 1, step 2, step 3) |- ( y ∈ B ↦ S ) = ( z ∈ B ↦ [_ z / y ]_ S ) ;;
	step 5 : wff = syl6eq (hyp 3, step 4) |- ( ph → G = ( z ∈ B ↦ [_ z / y ]_ S ) ) ;;
	step 6 : wff = csbeq1 () |- ( z = R → [_ z / y ]_ S = [_ R / y ]_ S ) ;;
	step 7 : wff = fmptcof (hyp 1, hyp 2, step 5, step 6) |- ( ph → ( G ∘ F ) = ( x ∈ A ↦ [_ R / y ]_ S ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Express composition of two functions as a maps-to applying both in
       sequence.  (Contributed by Stefan O'Rear, 5-Oct-2014.)  (Proof shortened
       by Mario Carneiro, 27-Dec-2014.) */

theorem fcompt (x : set, A : class, B : class, C : class, D : class, E : class) disjointed(x y A, x y B, x C, x y D, x E) {
	prop 1 : wff = |- ( ( A : D ⟶ E ∧ B : C ⟶ D ) → ( A ∘ B ) = ( x ∈ C ↦ ( A ` ( B ` x ) ) ) ) ;;
}

proof of fcompt {
	var y : set;;
	step 1 : wff = ffvelrn () |- ( ( B : C ⟶ D ∧ x ∈ C ) → ( B ` x ) ∈ D ) ;;
	step 2 : wff = adantll (step 1) |- ( ( ( A : D ⟶ E ∧ B : C ⟶ D ) ∧ x ∈ C ) → ( B ` x ) ∈ D ) ;;
	step 3 : wff = ffn () |- ( B : C ⟶ D → B Fn C ) ;;
	step 4 : wff = adantl (step 3) |- ( ( A : D ⟶ E ∧ B : C ⟶ D ) → B Fn C ) ;;
	step 5 : wff = dffn5 () |- ( B Fn C ↔ B = ( x ∈ C ↦ ( B ` x ) ) ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( ( A : D ⟶ E ∧ B : C ⟶ D ) → B = ( x ∈ C ↦ ( B ` x ) ) ) ;;
	step 7 : wff = ffn () |- ( A : D ⟶ E → A Fn D ) ;;
	step 8 : wff = adantr (step 7) |- ( ( A : D ⟶ E ∧ B : C ⟶ D ) → A Fn D ) ;;
	step 9 : wff = dffn5 () |- ( A Fn D ↔ A = ( y ∈ D ↦ ( A ` y ) ) ) ;;
	step 10 : wff = sylib (step 8, step 9) |- ( ( A : D ⟶ E ∧ B : C ⟶ D ) → A = ( y ∈ D ↦ ( A ` y ) ) ) ;;
	step 11 : wff = fveq2 () |- ( y = ( B ` x ) → ( A ` y ) = ( A ` ( B ` x ) ) ) ;;
	step 12 : wff = fmptco (step 2, step 6, step 10, step 11) |- ( ( A : D ⟶ E ∧ B : C ⟶ D ) → ( A ∘ B ) = ( x ∈ C ↦ ( A ` ( B ` x ) ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Composition with a constant function.  (Contributed by Stefan O'Rear,
       11-Mar-2015.) */

theorem fcoconst (F : class, I : class, X : class, Y : class) disjointed(F x y, I x, X x y, Y x y) {
	prop 1 : wff = |- ( ( F Fn X ∧ Y ∈ X ) → ( F ∘ ( I × { Y } ) ) = ( I × { ( F ` Y ) } ) ) ;;
}

proof of fcoconst {
	var x : set, y : set;;
	step 1 : wff = simplr () |- ( ( ( F Fn X ∧ Y ∈ X ) ∧ x ∈ I ) → Y ∈ X ) ;;
	step 2 : wff = fconstmpt () |- ( I × { Y } ) = ( x ∈ I ↦ Y ) ;;
	step 3 : wff = a1i (step 2) |- ( ( F Fn X ∧ Y ∈ X ) → ( I × { Y } ) = ( x ∈ I ↦ Y ) ) ;;
	step 4 : wff = simpl () |- ( ( F Fn X ∧ Y ∈ X ) → F Fn X ) ;;
	step 5 : wff = dffn2 () |- ( F Fn X ↔ F : X ⟶ _V ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( ( F Fn X ∧ Y ∈ X ) → F : X ⟶ _V ) ;;
	step 7 : wff = feqmptd (step 6) |- ( ( F Fn X ∧ Y ∈ X ) → F = ( y ∈ X ↦ ( F ` y ) ) ) ;;
	step 8 : wff = fveq2 () |- ( y = Y → ( F ` y ) = ( F ` Y ) ) ;;
	step 9 : wff = fmptco (step 1, step 3, step 7, step 8) |- ( ( F Fn X ∧ Y ∈ X ) → ( F ∘ ( I × { Y } ) ) = ( x ∈ I ↦ ( F ` Y ) ) ) ;;
	step 10 : wff = fconstmpt () |- ( I × { ( F ` Y ) } ) = ( x ∈ I ↦ ( F ` Y ) ) ;;
	step 11 : wff = syl6eqr (step 9, step 10) |- ( ( F Fn X ∧ Y ∈ X ) → ( F ∘ ( I × { Y } ) ) = ( I × { ( F ` Y ) } ) ) ;;
	qed prop 1 = step 11 ;;
}

/*A function maps a singleton to a singleton iff it is the singleton of an
       ordered pair.  (Contributed by NM, 10-Dec-2003.) */

theorem fsn (A : class, B : class, F : class) disjointed(x y A, x y B, x y F) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( F : { A } ⟶ { B } ↔ F = { 〈 A , B 〉 } ) ;;
}

proof of fsn {
	var x : set, y : set;;
	step 1 : wff = opelf () |- ( ( F : { A } ⟶ { B } ∧ 〈 x , y 〉 ∈ F ) → ( x ∈ { A } ∧ y ∈ { B } ) ) ;;
	step 2 : wff = elsn () |- ( x ∈ { A } ↔ x = A ) ;;
	step 3 : wff = elsn () |- ( y ∈ { B } ↔ y = B ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( x ∈ { A } ∧ y ∈ { B } ) ↔ ( x = A ∧ y = B ) ) ;;
	step 5 : wff = sylib (step 1, step 4) |- ( ( F : { A } ⟶ { B } ∧ 〈 x , y 〉 ∈ F ) → ( x = A ∧ y = B ) ) ;;
	step 6 : wff = ex (step 5) |- ( F : { A } ⟶ { B } → ( 〈 x , y 〉 ∈ F → ( x = A ∧ y = B ) ) ) ;;
	step 7 : wff = snid (hyp 1) |- A ∈ { A } ;;
	step 8 : wff = feu () |- ( ( F : { A } ⟶ { B } ∧ A ∈ { A } ) → ∃! y ∈ { B } 〈 A , y 〉 ∈ F ) ;;
	step 9 : wff = mpan2 (step 7, step 8) |- ( F : { A } ⟶ { B } → ∃! y ∈ { B } 〈 A , y 〉 ∈ F ) ;;
	step 10 : wff = elsn () |- ( y ∈ { B } ↔ y = B ) ;;
	step 11 : wff = anbi1i (step 10) |- ( ( y ∈ { B } ∧ 〈 A , y 〉 ∈ F ) ↔ ( y = B ∧ 〈 A , y 〉 ∈ F ) ) ;;
	step 12 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 13 : wff = eleq1d (step 12) |- ( y = B → ( 〈 A , y 〉 ∈ F ↔ 〈 A , B 〉 ∈ F ) ) ;;
	step 14 : wff = pm5.32i (step 13) |- ( ( y = B ∧ 〈 A , y 〉 ∈ F ) ↔ ( y = B ∧ 〈 A , B 〉 ∈ F ) ) ;;
	step 15 : wff = ancom () |- ( ( 〈 A , B 〉 ∈ F ∧ y = B ) ↔ ( y = B ∧ 〈 A , B 〉 ∈ F ) ) ;;
	step 16 : wff = bitr4i (step 14, step 15) |- ( ( y = B ∧ 〈 A , y 〉 ∈ F ) ↔ ( 〈 A , B 〉 ∈ F ∧ y = B ) ) ;;
	step 17 : wff = bitr2i (step 11, step 16) |- ( ( 〈 A , B 〉 ∈ F ∧ y = B ) ↔ ( y ∈ { B } ∧ 〈 A , y 〉 ∈ F ) ) ;;
	step 18 : wff = eubii (step 17) |- ( ∃! y ( 〈 A , B 〉 ∈ F ∧ y = B ) ↔ ∃! y ( y ∈ { B } ∧ 〈 A , y 〉 ∈ F ) ) ;;
	step 19 : wff = eueq1 (hyp 2) |- ∃! y y = B ;;
	step 20 : wff = biantru (step 19) |- ( 〈 A , B 〉 ∈ F ↔ ( 〈 A , B 〉 ∈ F ∧ ∃! y y = B ) ) ;;
	step 21 : wff = euanv () |- ( ∃! y ( 〈 A , B 〉 ∈ F ∧ y = B ) ↔ ( 〈 A , B 〉 ∈ F ∧ ∃! y y = B ) ) ;;
	step 22 : wff = bitr4i (step 20, step 21) |- ( 〈 A , B 〉 ∈ F ↔ ∃! y ( 〈 A , B 〉 ∈ F ∧ y = B ) ) ;;
	step 23 : wff = df-reu () |- ( ∃! y ∈ { B } 〈 A , y 〉 ∈ F ↔ ∃! y ( y ∈ { B } ∧ 〈 A , y 〉 ∈ F ) ) ;;
	step 24 : wff = 3bitr4i (step 18, step 22, step 23) |- ( 〈 A , B 〉 ∈ F ↔ ∃! y ∈ { B } 〈 A , y 〉 ∈ F ) ;;
	step 25 : wff = sylibr (step 9, step 24) |- ( F : { A } ⟶ { B } → 〈 A , B 〉 ∈ F ) ;;
	step 26 : wff = opeq12 () |- ( ( x = A ∧ y = B ) → 〈 x , y 〉 = 〈 A , B 〉 ) ;;
	step 27 : wff = eleq1d (step 26) |- ( ( x = A ∧ y = B ) → ( 〈 x , y 〉 ∈ F ↔ 〈 A , B 〉 ∈ F ) ) ;;
	step 28 : wff = syl5ibrcom (step 25, step 27) |- ( F : { A } ⟶ { B } → ( ( x = A ∧ y = B ) → 〈 x , y 〉 ∈ F ) ) ;;
	step 29 : wff = impbid (step 6, step 28) |- ( F : { A } ⟶ { B } → ( 〈 x , y 〉 ∈ F ↔ ( x = A ∧ y = B ) ) ) ;;
	step 30 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 31 : wff = elsnc (step 30) |- ( 〈 x , y 〉 ∈ { 〈 A , B 〉 } ↔ 〈 x , y 〉 = 〈 A , B 〉 ) ;;
	step 32 : wff = opth2 (hyp 1, hyp 2) |- ( 〈 x , y 〉 = 〈 A , B 〉 ↔ ( x = A ∧ y = B ) ) ;;
	step 33 : wff = bitr2i (step 31, step 32) |- ( ( x = A ∧ y = B ) ↔ 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ;;
	step 34 : wff = syl6bb (step 29, step 33) |- ( F : { A } ⟶ { B } → ( 〈 x , y 〉 ∈ F ↔ 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ) ;;
	step 35 : wff = alrimivv (step 34) |- ( F : { A } ⟶ { B } → ∀ x ∀ y ( 〈 x , y 〉 ∈ F ↔ 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ) ;;
	step 36 : wff = frel () |- ( F : { A } ⟶ { B } → Rel F ) ;;
	step 37 : wff = relsnop (hyp 1, hyp 2) |- Rel { 〈 A , B 〉 } ;;
	step 38 : wff = eqrel () |- ( ( Rel F ∧ Rel { 〈 A , B 〉 } ) → ( F = { 〈 A , B 〉 } ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ F ↔ 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ) ) ;;
	step 39 : wff = sylancl (step 36, step 37, step 38) |- ( F : { A } ⟶ { B } → ( F = { 〈 A , B 〉 } ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ F ↔ 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ) ) ;;
	step 40 : wff = mpbird (step 35, step 39) |- ( F : { A } ⟶ { B } → F = { 〈 A , B 〉 } ) ;;
	step 41 : wff = f1osn (hyp 1, hyp 2) |- { 〈 A , B 〉 } : { A } ⤖ { B } ;;
	step 42 : wff = f1oeq1 () |- ( F = { 〈 A , B 〉 } → ( F : { A } ⤖ { B } ↔ { 〈 A , B 〉 } : { A } ⤖ { B } ) ) ;;
	step 43 : wff = mpbiri (step 41, step 42) |- ( F = { 〈 A , B 〉 } → F : { A } ⤖ { B } ) ;;
	step 44 : wff = f1of () |- ( F : { A } ⤖ { B } → F : { A } ⟶ { B } ) ;;
	step 45 : wff = syl (step 43, step 44) |- ( F = { 〈 A , B 〉 } → F : { A } ⟶ { B } ) ;;
	step 46 : wff = impbii (step 40, step 45) |- ( F : { A } ⟶ { B } ↔ F = { 〈 A , B 〉 } ) ;;
	qed prop 1 = step 46 ;;
}

/*A function maps a singleton to a singleton iff it is the singleton of an
       ordered pair.  (Contributed by NM, 26-Oct-2012.) */

theorem fsng (A : class, B : class, C : class, D : class, F : class) disjointed(A a b, B b, F a b) {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( F : { A } ⟶ { B } ↔ F = { 〈 A , B 〉 } ) ) ;;
}

proof of fsng {
	var a : set, b : set;;
	step 1 : wff = sneq () |- ( a = A → { a } = { A } ) ;;
	step 2 : wff = feq2d (step 1) |- ( a = A → ( F : { a } ⟶ { b } ↔ F : { A } ⟶ { b } ) ) ;;
	step 3 : wff = opeq1 () |- ( a = A → 〈 a , b 〉 = 〈 A , b 〉 ) ;;
	step 4 : wff = sneqd (step 3) |- ( a = A → { 〈 a , b 〉 } = { 〈 A , b 〉 } ) ;;
	step 5 : wff = eqeq2d (step 4) |- ( a = A → ( F = { 〈 a , b 〉 } ↔ F = { 〈 A , b 〉 } ) ) ;;
	step 6 : wff = bibi12d (step 2, step 5) |- ( a = A → ( ( F : { a } ⟶ { b } ↔ F = { 〈 a , b 〉 } ) ↔ ( F : { A } ⟶ { b } ↔ F = { 〈 A , b 〉 } ) ) ) ;;
	step 7 : wff = sneq () |- ( b = B → { b } = { B } ) ;;
	step 8 : wff = feq3 () |- ( { b } = { B } → ( F : { A } ⟶ { b } ↔ F : { A } ⟶ { B } ) ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( b = B → ( F : { A } ⟶ { b } ↔ F : { A } ⟶ { B } ) ) ;;
	step 10 : wff = opeq2 () |- ( b = B → 〈 A , b 〉 = 〈 A , B 〉 ) ;;
	step 11 : wff = sneqd (step 10) |- ( b = B → { 〈 A , b 〉 } = { 〈 A , B 〉 } ) ;;
	step 12 : wff = eqeq2d (step 11) |- ( b = B → ( F = { 〈 A , b 〉 } ↔ F = { 〈 A , B 〉 } ) ) ;;
	step 13 : wff = bibi12d (step 9, step 12) |- ( b = B → ( ( F : { A } ⟶ { b } ↔ F = { 〈 A , b 〉 } ) ↔ ( F : { A } ⟶ { B } ↔ F = { 〈 A , B 〉 } ) ) ) ;;
	step 14 : wff = vex () |- a ∈ _V ;;
	step 15 : wff = vex () |- b ∈ _V ;;
	step 16 : wff = fsn (step 14, step 15) |- ( F : { a } ⟶ { b } ↔ F = { 〈 a , b 〉 } ) ;;
	step 17 : wff = vtocl2g (step 6, step 13, step 16) |- ( ( A ∈ C ∧ B ∈ D ) → ( F : { A } ⟶ { B } ↔ F = { 〈 A , B 〉 } ) ) ;;
	qed prop 1 = step 17 ;;
}

/*A function that maps a singleton to a class is the singleton of an
       ordered pair.  (Contributed by NM, 19-May-2004.) */

theorem fsn2 (A : class, B : class, F : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( F : { A } ⟶ B ↔ ( ( F ` A ) ∈ B ∧ F = { 〈 A , ( F ` A ) 〉 } ) ) ;;
}

proof of fsn2 {
	step 1 : wff = snid (hyp 1) |- A ∈ { A } ;;
	step 2 : wff = ffvelrn () |- ( ( F : { A } ⟶ B ∧ A ∈ { A } ) → ( F ` A ) ∈ B ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( F : { A } ⟶ B → ( F ` A ) ∈ B ) ;;
	step 4 : wff = ffn () |- ( F : { A } ⟶ B → F Fn { A } ) ;;
	step 5 : wff = dffn3 () |- ( F Fn { A } ↔ F : { A } ⟶ ran F ) ;;
	step 6 : wff = biimpi (step 5) |- ( F Fn { A } → F : { A } ⟶ ran F ) ;;
	step 7 : wff = imadmrn () |- ( F " dom F ) = ran F ;;
	step 8 : wff = fndm () |- ( F Fn { A } → dom F = { A } ) ;;
	step 9 : wff = imaeq2d (step 8) |- ( F Fn { A } → ( F " dom F ) = ( F " { A } ) ) ;;
	step 10 : wff = syl5eqr (step 7, step 9) |- ( F Fn { A } → ran F = ( F " { A } ) ) ;;
	step 11 : wff = snid (hyp 1) |- A ∈ { A } ;;
	step 12 : wff = fnsnfv () |- ( ( F Fn { A } ∧ A ∈ { A } ) → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 13 : wff = mpan2 (step 11, step 12) |- ( F Fn { A } → { ( F ` A ) } = ( F " { A } ) ) ;;
	step 14 : wff = eqtr4d (step 10, step 13) |- ( F Fn { A } → ran F = { ( F ` A ) } ) ;;
	step 15 : wff = feq3 () |- ( ran F = { ( F ` A ) } → ( F : { A } ⟶ ran F ↔ F : { A } ⟶ { ( F ` A ) } ) ) ;;
	step 16 : wff = syl (step 14, step 15) |- ( F Fn { A } → ( F : { A } ⟶ ran F ↔ F : { A } ⟶ { ( F ` A ) } ) ) ;;
	step 17 : wff = mpbid (step 6, step 16) |- ( F Fn { A } → F : { A } ⟶ { ( F ` A ) } ) ;;
	step 18 : wff = syl (step 4, step 17) |- ( F : { A } ⟶ B → F : { A } ⟶ { ( F ` A ) } ) ;;
	step 19 : wff = jca (step 3, step 18) |- ( F : { A } ⟶ B → ( ( F ` A ) ∈ B ∧ F : { A } ⟶ { ( F ` A ) } ) ) ;;
	step 20 : wff = snssi () |- ( ( F ` A ) ∈ B → { ( F ` A ) } ⊆ B ) ;;
	step 21 : wff = fss () |- ( ( F : { A } ⟶ { ( F ` A ) } ∧ { ( F ` A ) } ⊆ B ) → F : { A } ⟶ B ) ;;
	step 22 : wff = ancoms (step 21) |- ( ( { ( F ` A ) } ⊆ B ∧ F : { A } ⟶ { ( F ` A ) } ) → F : { A } ⟶ B ) ;;
	step 23 : wff = sylan (step 20, step 22) |- ( ( ( F ` A ) ∈ B ∧ F : { A } ⟶ { ( F ` A ) } ) → F : { A } ⟶ B ) ;;
	step 24 : wff = impbii (step 19, step 23) |- ( F : { A } ⟶ B ↔ ( ( F ` A ) ∈ B ∧ F : { A } ⟶ { ( F ` A ) } ) ) ;;
	step 25 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 26 : wff = fsn (hyp 1, step 25) |- ( F : { A } ⟶ { ( F ` A ) } ↔ F = { 〈 A , ( F ` A ) 〉 } ) ;;
	step 27 : wff = anbi2i (step 26) |- ( ( ( F ` A ) ∈ B ∧ F : { A } ⟶ { ( F ` A ) } ) ↔ ( ( F ` A ) ∈ B ∧ F = { 〈 A , ( F ` A ) 〉 } ) ) ;;
	step 28 : wff = bitri (step 24, step 27) |- ( F : { A } ⟶ B ↔ ( ( F ` A ) ∈ B ∧ F = { 〈 A , ( F ` A ) 〉 } ) ) ;;
	qed prop 1 = step 28 ;;
}

/*The cross product of two singletons.  (Contributed by Mario Carneiro,
     30-Apr-2015.) */

theorem xpsng (A : class, B : class, V : class, W : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( { A } × { B } ) = { 〈 A , B 〉 } ) ;;
}

proof of xpsng {
	step 1 : wff = fconstg () |- ( B ∈ W → ( { A } × { B } ) : { A } ⟶ { B } ) ;;
	step 2 : wff = adantl (step 1) |- ( ( A ∈ V ∧ B ∈ W ) → ( { A } × { B } ) : { A } ⟶ { B } ) ;;
	step 3 : wff = fsng () |- ( ( A ∈ V ∧ B ∈ W ) → ( ( { A } × { B } ) : { A } ⟶ { B } ↔ ( { A } × { B } ) = { 〈 A , B 〉 } ) ) ;;
	step 4 : wff = mpbid (step 2, step 3) |- ( ( A ∈ V ∧ B ∈ W ) → ( { A } × { B } ) = { 〈 A , B 〉 } ) ;;
	qed prop 1 = step 4 ;;
}

/*The cross product of two singletons.  (Contributed by NM,
       4-Nov-2006.) */

theorem xpsn (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( { A } × { B } ) = { 〈 A , B 〉 } ;;
}

proof of xpsn {
	step 1 : wff = xpsng () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( { A } × { B } ) = { 〈 A , B 〉 } ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( { A } × { B } ) = { 〈 A , B 〉 } ;;
	qed prop 1 = step 2 ;;
}

/*Alternate definition for the "maps to" notation ~ df-mpt (although it
       requires that ` B ` be a set).  (Contributed by NM, 24-Aug-2010.)
       (Revised by Mario Carneiro, 30-Dec-2016.) */

theorem dfmpt (x : set, A : class, B : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A ↦ B ) = ⋃_ x ∈ A { 〈 x , B 〉 } ;;
}

proof of dfmpt {
	step 1 : wff = dfmpt3 () |- ( x ∈ A ↦ B ) = ⋃_ x ∈ A ( { x } × { B } ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = xpsn (step 2, hyp 1) |- ( { x } × { B } ) = { 〈 x , B 〉 } ;;
	step 4 : wff = a1i (step 3) |- ( x ∈ A → ( { x } × { B } ) = { 〈 x , B 〉 } ) ;;
	step 5 : wff = iuneq2i (step 4) |- ⋃_ x ∈ A ( { x } × { B } ) = ⋃_ x ∈ A { 〈 x , B 〉 } ;;
	step 6 : wff = eqtri (step 1, step 5) |- ( x ∈ A ↦ B ) = ⋃_ x ∈ A { 〈 x , B 〉 } ;;
	qed prop 1 = step 6 ;;
}

/*A function expressed as the range of another function.  (Contributed by
       Mario Carneiro, 22-Jun-2013.)  (Proof shortened by Mario Carneiro,
       31-Aug-2015.) */

theorem fnasrn (x : set, A : class, B : class) disjointed(x y, y A, y B) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A ↦ B ) = ran ( x ∈ A ↦ 〈 x , B 〉 ) ;;
}

proof of fnasrn {
	var y : set;;
	step 1 : wff = dfmpt (hyp 1) |- ( x ∈ A ↦ B ) = ⋃_ x ∈ A { 〈 x , B 〉 } ;;
	step 2 : wff = eqid () |- ( x ∈ A ↦ 〈 x , B 〉 ) = ( x ∈ A ↦ 〈 x , B 〉 ) ;;
	step 3 : wff = rnmpt (step 2) |- ran ( x ∈ A ↦ 〈 x , B 〉 ) = { y | ∃ x ∈ A y = 〈 x , B 〉 } ;;
	step 4 : wff = elsn () |- ( y ∈ { 〈 x , B 〉 } ↔ y = 〈 x , B 〉 ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ x ∈ A y ∈ { 〈 x , B 〉 } ↔ ∃ x ∈ A y = 〈 x , B 〉 ) ;;
	step 6 : wff = abbii (step 5) |- { y | ∃ x ∈ A y ∈ { 〈 x , B 〉 } } = { y | ∃ x ∈ A y = 〈 x , B 〉 } ;;
	step 7 : wff = eqtr4i (step 3, step 6) |- ran ( x ∈ A ↦ 〈 x , B 〉 ) = { y | ∃ x ∈ A y ∈ { 〈 x , B 〉 } } ;;
	step 8 : wff = df-iun () |- ⋃_ x ∈ A { 〈 x , B 〉 } = { y | ∃ x ∈ A y ∈ { 〈 x , B 〉 } } ;;
	step 9 : wff = eqtr4i (step 7, step 8) |- ran ( x ∈ A ↦ 〈 x , B 〉 ) = ⋃_ x ∈ A { 〈 x , B 〉 } ;;
	step 10 : wff = eqtr4i (step 1, step 9) |- ( x ∈ A ↦ B ) = ran ( x ∈ A ↦ 〈 x , B 〉 ) ;;
	qed prop 1 = step 10 ;;
}

/*If ` A ` is not in ` C ` , then the restriction of a singleton of
     ` <. A , B >. ` to ` C ` is null.  (Contributed by Scott Fenton,
     15-Apr-2011.) */

theorem ressnop0 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ¬ A ∈ C → ( { 〈 A , B 〉 } ↾ C ) = ∅ ) ;;
}

proof of ressnop0 {
	step 1 : wff = opelxp1 () |- ( 〈 A , B 〉 ∈ ( C × _V ) → A ∈ C ) ;;
	step 2 : wff = con3i (step 1) |- ( ¬ A ∈ C → ¬ 〈 A , B 〉 ∈ ( C × _V ) ) ;;
	step 3 : wff = df-res () |- ( { 〈 A , B 〉 } ↾ C ) = ( { 〈 A , B 〉 } ∩ ( C × _V ) ) ;;
	step 4 : wff = incom () |- ( { 〈 A , B 〉 } ∩ ( C × _V ) ) = ( ( C × _V ) ∩ { 〈 A , B 〉 } ) ;;
	step 5 : wff = eqtri (step 3, step 4) |- ( { 〈 A , B 〉 } ↾ C ) = ( ( C × _V ) ∩ { 〈 A , B 〉 } ) ;;
	step 6 : wff = disjsn () |- ( ( ( C × _V ) ∩ { 〈 A , B 〉 } ) = ∅ ↔ ¬ 〈 A , B 〉 ∈ ( C × _V ) ) ;;
	step 7 : wff = biimpri (step 6) |- ( ¬ 〈 A , B 〉 ∈ ( C × _V ) → ( ( C × _V ) ∩ { 〈 A , B 〉 } ) = ∅ ) ;;
	step 8 : wff = syl5eq (step 5, step 7) |- ( ¬ 〈 A , B 〉 ∈ ( C × _V ) → ( { 〈 A , B 〉 } ↾ C ) = ∅ ) ;;
	step 9 : wff = syl (step 2, step 8) |- ( ¬ A ∈ C → ( { 〈 A , B 〉 } ↾ C ) = ∅ ) ;;
	qed prop 1 = step 9 ;;
}

/*A function with a domain of two elements.  (Contributed by Jeff Madsen,
       20-Jun-2010.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem fpr (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ≠ B → { 〈 A , C 〉 , 〈 B , D 〉 } : { A , B } ⟶ { C , D } ) ;;
}

proof of fpr {
	step 1 : wff = funpr (hyp 1, hyp 2, hyp 3, hyp 4) |- ( A ≠ B → Fun { 〈 A , C 〉 , 〈 B , D 〉 } ) ;;
	step 2 : wff = dmprop (hyp 3, hyp 4) |- dom { 〈 A , C 〉 , 〈 B , D 〉 } = { A , B } ;;
	step 3 : wff = jctir (step 1, step 2) |- ( A ≠ B → ( Fun { 〈 A , C 〉 , 〈 B , D 〉 } ∧ dom { 〈 A , C 〉 , 〈 B , D 〉 } = { A , B } ) ) ;;
	step 4 : wff = df-fn () |- ( { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ↔ ( Fun { 〈 A , C 〉 , 〈 B , D 〉 } ∧ dom { 〈 A , C 〉 , 〈 B , D 〉 } = { A , B } ) ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( A ≠ B → { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ) ;;
	step 6 : wff = df-pr () |- { 〈 A , C 〉 , 〈 B , D 〉 } = ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ;;
	step 7 : wff = rneqi (step 6) |- ran { 〈 A , C 〉 , 〈 B , D 〉 } = ran ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ;;
	step 8 : wff = rnun () |- ran ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) = ( ran { 〈 A , C 〉 } ∪ ran { 〈 B , D 〉 } ) ;;
	step 9 : wff = rnsnop (hyp 1) |- ran { 〈 A , C 〉 } = { C } ;;
	step 10 : wff = rnsnop (hyp 2) |- ran { 〈 B , D 〉 } = { D } ;;
	step 11 : wff = uneq12i (step 9, step 10) |- ( ran { 〈 A , C 〉 } ∪ ran { 〈 B , D 〉 } ) = ( { C } ∪ { D } ) ;;
	step 12 : wff = df-pr () |- { C , D } = ( { C } ∪ { D } ) ;;
	step 13 : wff = eqtr4i (step 11, step 12) |- ( ran { 〈 A , C 〉 } ∪ ran { 〈 B , D 〉 } ) = { C , D } ;;
	step 14 : wff = 3eqtri (step 7, step 8, step 13) |- ran { 〈 A , C 〉 , 〈 B , D 〉 } = { C , D } ;;
	step 15 : wff = eqimssi (step 14) |- ran { 〈 A , C 〉 , 〈 B , D 〉 } ⊆ { C , D } ;;
	step 16 : wff = jctir (step 5, step 15) |- ( A ≠ B → ( { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ∧ ran { 〈 A , C 〉 , 〈 B , D 〉 } ⊆ { C , D } ) ) ;;
	step 17 : wff = df-f () |- ( { 〈 A , C 〉 , 〈 B , D 〉 } : { A , B } ⟶ { C , D } ↔ ( { 〈 A , C 〉 , 〈 B , D 〉 } Fn { A , B } ∧ ran { 〈 A , C 〉 , 〈 B , D 〉 } ⊆ { C , D } ) ) ;;
	step 18 : wff = sylibr (step 16, step 17) |- ( A ≠ B → { 〈 A , C 〉 , 〈 B , D 〉 } : { A , B } ⟶ { C , D } ) ;;
	qed prop 1 = step 18 ;;
}

/*A function restricted to a singleton.  (Contributed by NM,
       9-Oct-2004.) */

theorem fnressn (A : class, B : class, F : class) disjointed(x A, x B, x, x F) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ;;
}

proof of fnressn {
	var x : set;;
	step 1 : wff = sneq () |- ( x = B → { x } = { B } ) ;;
	step 2 : wff = reseq2d (step 1) |- ( x = B → ( F ↾ { x } ) = ( F ↾ { B } ) ) ;;
	step 3 : wff = fveq2 () |- ( x = B → ( F ` x ) = ( F ` B ) ) ;;
	step 4 : wff = opeq12 () |- ( ( x = B ∧ ( F ` x ) = ( F ` B ) ) → 〈 x , ( F ` x ) 〉 = 〈 B , ( F ` B ) 〉 ) ;;
	step 5 : wff = mpdan (step 3, step 4) |- ( x = B → 〈 x , ( F ` x ) 〉 = 〈 B , ( F ` B ) 〉 ) ;;
	step 6 : wff = sneqd (step 5) |- ( x = B → { 〈 x , ( F ` x ) 〉 } = { 〈 B , ( F ` B ) 〉 } ) ;;
	step 7 : wff = eqeq12d (step 2, step 6) |- ( x = B → ( ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ↔ ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ) ;;
	step 8 : wff = imbi2d (step 7) |- ( x = B → ( ( F Fn A → ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ↔ ( F Fn A → ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ) ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = snss (step 9) |- ( x ∈ A ↔ { x } ⊆ A ) ;;
	step 11 : wff = fnssres () |- ( ( F Fn A ∧ { x } ⊆ A ) → ( F ↾ { x } ) Fn { x } ) ;;
	step 12 : wff = sylan2b (step 10, step 11) |- ( ( F Fn A ∧ x ∈ A ) → ( F ↾ { x } ) Fn { x } ) ;;
	step 13 : wff = dffn2 () |- ( ( F ↾ { x } ) Fn { x } ↔ ( F ↾ { x } ) : { x } ⟶ _V ) ;;
	step 14 : wff = vex () |- x ∈ _V ;;
	step 15 : wff = fsn2 (step 14) |- ( ( F ↾ { x } ) : { x } ⟶ _V ↔ ( ( ( F ↾ { x } ) ` x ) ∈ _V ∧ ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ) ) ;;
	step 16 : wff = fvex () |- ( ( F ↾ { x } ) ` x ) ∈ _V ;;
	step 17 : wff = biantrur (step 16) |- ( ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ↔ ( ( ( F ↾ { x } ) ` x ) ∈ _V ∧ ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ) ) ;;
	step 18 : wff = vex () |- x ∈ _V ;;
	step 19 : wff = snid (step 18) |- x ∈ { x } ;;
	step 20 : wff = fvres () |- ( x ∈ { x } → ( ( F ↾ { x } ) ` x ) = ( F ` x ) ) ;;
	step 21 : wff = ax-mp (step 19, step 20) |- ( ( F ↾ { x } ) ` x ) = ( F ` x ) ;;
	step 22 : wff = opeq2i (step 21) |- 〈 x , ( ( F ↾ { x } ) ` x ) 〉 = 〈 x , ( F ` x ) 〉 ;;
	step 23 : wff = sneqi (step 22) |- { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } = { 〈 x , ( F ` x ) 〉 } ;;
	step 24 : wff = eqeq2i (step 23) |- ( ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ↔ ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ;;
	step 25 : wff = bitr3i (step 17, step 24) |- ( ( ( ( F ↾ { x } ) ` x ) ∈ _V ∧ ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ) ↔ ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ;;
	step 26 : wff = 3bitri (step 13, step 15, step 25) |- ( ( F ↾ { x } ) Fn { x } ↔ ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ;;
	step 27 : wff = sylib (step 12, step 26) |- ( ( F Fn A ∧ x ∈ A ) → ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ;;
	step 28 : wff = expcom (step 27) |- ( x ∈ A → ( F Fn A → ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ) ;;
	step 29 : wff = vtoclga (step 8, step 28) |- ( B ∈ A → ( F Fn A → ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ) ;;
	step 30 : wff = impcom (step 29) |- ( ( F Fn A ∧ B ∈ A ) → ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ;;
	qed prop 1 = step 30 ;;
}

/*A function restricted to a singleton.  (Contributed by Mario Carneiro,
       16-Nov-2014.) */

theorem funressn (B : class, F : class) disjointed(B, F) {
	prop 1 : wff = |- ( Fun F → ( F ↾ { B } ) ⊆ { 〈 B , ( F ` B ) 〉 } ) ;;
}

proof of funressn {
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = fnressn () |- ( ( F Fn dom F ∧ B ∈ dom F ) → ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( Fun F ∧ B ∈ dom F ) → ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } ) ;;
	step 4 : wff = eqimss () |- ( ( F ↾ { B } ) = { 〈 B , ( F ` B ) 〉 } → ( F ↾ { B } ) ⊆ { 〈 B , ( F ` B ) 〉 } ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ( Fun F ∧ B ∈ dom F ) → ( F ↾ { B } ) ⊆ { 〈 B , ( F ` B ) 〉 } ) ;;
	step 6 : wff = disjsn () |- ( ( dom F ∩ { B } ) = ∅ ↔ ¬ B ∈ dom F ) ;;
	step 7 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 8 : wff = fnresdisj () |- ( F Fn dom F → ( ( dom F ∩ { B } ) = ∅ ↔ ( F ↾ { B } ) = ∅ ) ) ;;
	step 9 : wff = sylbi (step 7, step 8) |- ( Fun F → ( ( dom F ∩ { B } ) = ∅ ↔ ( F ↾ { B } ) = ∅ ) ) ;;
	step 10 : wff = syl5bbr (step 6, step 9) |- ( Fun F → ( ¬ B ∈ dom F ↔ ( F ↾ { B } ) = ∅ ) ) ;;
	step 11 : wff = biimpa (step 10) |- ( ( Fun F ∧ ¬ B ∈ dom F ) → ( F ↾ { B } ) = ∅ ) ;;
	step 12 : wff = 0ss () |- ∅ ⊆ { 〈 B , ( F ` B ) 〉 } ;;
	step 13 : wff = a1i (step 12) |- ( ( Fun F ∧ ¬ B ∈ dom F ) → ∅ ⊆ { 〈 B , ( F ` B ) 〉 } ) ;;
	step 14 : wff = eqsstrd (step 11, step 13) |- ( ( Fun F ∧ ¬ B ∈ dom F ) → ( F ↾ { B } ) ⊆ { 〈 B , ( F ` B ) 〉 } ) ;;
	step 15 : wff = pm2.61dan (step 5, step 14) |- ( Fun F → ( F ↾ { B } ) ⊆ { 〈 B , ( F ` B ) 〉 } ) ;;
	qed prop 1 = step 15 ;;
}

/*The value of a function restricted to a singleton.  (Contributed by NM,
       9-Oct-2004.) */

theorem fressnfv (A : class, B : class, C : class, F : class) disjointed(x A, x B, x C, x F) {
	prop 1 : wff = |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ↾ { B } ) : { B } ⟶ C ↔ ( F ` B ) ∈ C ) ) ;;
}

proof of fressnfv {
	var x : set;;
	step 1 : wff = sneq () |- ( x = B → { x } = { B } ) ;;
	step 2 : wff = reseq2 () |- ( { x } = { B } → ( F ↾ { x } ) = ( F ↾ { B } ) ) ;;
	step 3 : wff = feq1d (step 2) |- ( { x } = { B } → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ↾ { B } ) : { x } ⟶ C ) ) ;;
	step 4 : wff = feq2 () |- ( { x } = { B } → ( ( F ↾ { B } ) : { x } ⟶ C ↔ ( F ↾ { B } ) : { B } ⟶ C ) ) ;;
	step 5 : wff = bitrd (step 3, step 4) |- ( { x } = { B } → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ↾ { B } ) : { B } ⟶ C ) ) ;;
	step 6 : wff = syl (step 1, step 5) |- ( x = B → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ↾ { B } ) : { B } ⟶ C ) ) ;;
	step 7 : wff = fveq2 () |- ( x = B → ( F ` x ) = ( F ` B ) ) ;;
	step 8 : wff = eleq1d (step 7) |- ( x = B → ( ( F ` x ) ∈ C ↔ ( F ` B ) ∈ C ) ) ;;
	step 9 : wff = bibi12d (step 6, step 8) |- ( x = B → ( ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ` x ) ∈ C ) ↔ ( ( F ↾ { B } ) : { B } ⟶ C ↔ ( F ` B ) ∈ C ) ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( x = B → ( ( F Fn A → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ` x ) ∈ C ) ) ↔ ( F Fn A → ( ( F ↾ { B } ) : { B } ⟶ C ↔ ( F ` B ) ∈ C ) ) ) ) ;;
	step 11 : wff = fnressn () |- ( ( F Fn A ∧ x ∈ A ) → ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = snid (step 12) |- x ∈ { x } ;;
	step 14 : wff = fvres () |- ( x ∈ { x } → ( ( F ↾ { x } ) ` x ) = ( F ` x ) ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- ( ( F ↾ { x } ) ` x ) = ( F ` x ) ;;
	step 16 : wff = opeq2i (step 15) |- 〈 x , ( ( F ↾ { x } ) ` x ) 〉 = 〈 x , ( F ` x ) 〉 ;;
	step 17 : wff = sneqi (step 16) |- { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } = { 〈 x , ( F ` x ) 〉 } ;;
	step 18 : wff = eqeq2i (step 17) |- ( ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ↔ ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } ) ;;
	step 19 : wff = vex () |- x ∈ _V ;;
	step 20 : wff = fsn2 (step 19) |- ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( ( ( F ↾ { x } ) ` x ) ∈ C ∧ ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ) ) ;;
	step 21 : wff = vex () |- x ∈ _V ;;
	step 22 : wff = snid (step 21) |- x ∈ { x } ;;
	step 23 : wff = fvres () |- ( x ∈ { x } → ( ( F ↾ { x } ) ` x ) = ( F ` x ) ) ;;
	step 24 : wff = ax-mp (step 22, step 23) |- ( ( F ↾ { x } ) ` x ) = ( F ` x ) ;;
	step 25 : wff = eleq1i (step 24) |- ( ( ( F ↾ { x } ) ` x ) ∈ C ↔ ( F ` x ) ∈ C ) ;;
	step 26 : wff = iba () |- ( ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } → ( ( ( F ↾ { x } ) ` x ) ∈ C ↔ ( ( ( F ↾ { x } ) ` x ) ∈ C ∧ ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ) ) ) ;;
	step 27 : wff = syl5rbbr (step 25, step 26) |- ( ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } → ( ( ( ( F ↾ { x } ) ` x ) ∈ C ∧ ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } ) ↔ ( F ` x ) ∈ C ) ) ;;
	step 28 : wff = syl5bb (step 20, step 27) |- ( ( F ↾ { x } ) = { 〈 x , ( ( F ↾ { x } ) ` x ) 〉 } → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ` x ) ∈ C ) ) ;;
	step 29 : wff = sylbir (step 18, step 28) |- ( ( F ↾ { x } ) = { 〈 x , ( F ` x ) 〉 } → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ` x ) ∈ C ) ) ;;
	step 30 : wff = syl (step 11, step 29) |- ( ( F Fn A ∧ x ∈ A ) → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ` x ) ∈ C ) ) ;;
	step 31 : wff = expcom (step 30) |- ( x ∈ A → ( F Fn A → ( ( F ↾ { x } ) : { x } ⟶ C ↔ ( F ` x ) ∈ C ) ) ) ;;
	step 32 : wff = vtoclga (step 10, step 31) |- ( B ∈ A → ( F Fn A → ( ( F ↾ { B } ) : { B } ⟶ C ↔ ( F ` B ) ∈ C ) ) ) ;;
	step 33 : wff = impcom (step 32) |- ( ( F Fn A ∧ B ∈ A ) → ( ( F ↾ { B } ) : { B } ⟶ C ↔ ( F ` B ) ∈ C ) ) ;;
	qed prop 1 = step 33 ;;
}

/*The value of a constant function.  (Contributed by NM, 30-May-1999.) */

theorem fvconst (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ { B } ∧ C ∈ A ) → ( F ` C ) = B ) ;;
}

proof of fvconst {
	step 1 : wff = ffvelrn () |- ( ( F : A ⟶ { B } ∧ C ∈ A ) → ( F ` C ) ∈ { B } ) ;;
	step 2 : wff = elsni () |- ( ( F ` C ) ∈ { B } → ( F ` C ) = B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ( F : A ⟶ { B } ∧ C ∈ A ) → ( F ` C ) = B ) ;;
	qed prop 1 = step 3 ;;
}

/*Express a singleton function in maps-to notation.  (Contributed by NM,
       6-Jun-2006.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.)  (Revised
       by Stefan O'Rear, 28-Feb-2015.) */

theorem fmptsn (x : set, A : class, B : class, V : class, W : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 } = ( x ∈ { A } ↦ B ) ) ;;
}

proof of fmptsn {
	step 1 : wff = fconstmpt () |- ( { A } × { B } ) = ( x ∈ { A } ↦ B ) ;;
	step 2 : wff = xpsng () |- ( ( A ∈ V ∧ B ∈ W ) → ( { A } × { B } ) = { 〈 A , B 〉 } ) ;;
	step 3 : wff = syl5reqr (step 1, step 2) |- ( ( A ∈ V ∧ B ∈ W ) → { 〈 A , B 〉 } = ( x ∈ { A } ↦ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Append an additional value to a function.  (Contributed by NM,
       6-Jun-2006.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem fmptap (x : set, A : class, B : class, C : class, R : class, S : class) disjointed(x A, x B, x R, x S) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( R ∪ { A } ) = S ;;
	hyp 4 : wff = |- ( x = A → C = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ R ↦ C ) ∪ { 〈 A , B 〉 } ) = ( x ∈ S ↦ C ) ;;
}

proof of fmptap {
	step 1 : wff = fmptsn () |- ( ( A ∈ _V ∧ B ∈ _V ) → { 〈 A , B 〉 } = ( x ∈ { A } ↦ B ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- { 〈 A , B 〉 } = ( x ∈ { A } ↦ B ) ;;
	step 3 : wff = elsni () |- ( x ∈ { A } → x = A ) ;;
	step 4 : wff = syl (step 3, hyp 4) |- ( x ∈ { A } → C = B ) ;;
	step 5 : wff = mpteq2ia (step 4) |- ( x ∈ { A } ↦ C ) = ( x ∈ { A } ↦ B ) ;;
	step 6 : wff = eqtr4i (step 2, step 5) |- { 〈 A , B 〉 } = ( x ∈ { A } ↦ C ) ;;
	step 7 : wff = uneq2i (step 6) |- ( ( x ∈ R ↦ C ) ∪ { 〈 A , B 〉 } ) = ( ( x ∈ R ↦ C ) ∪ ( x ∈ { A } ↦ C ) ) ;;
	step 8 : wff = mptun () |- ( x ∈ ( R ∪ { A } ) ↦ C ) = ( ( x ∈ R ↦ C ) ∪ ( x ∈ { A } ↦ C ) ) ;;
	step 9 : wff = mpteq1 () |- ( ( R ∪ { A } ) = S → ( x ∈ ( R ∪ { A } ) ↦ C ) = ( x ∈ S ↦ C ) ) ;;
	step 10 : wff = ax-mp (hyp 3, step 9) |- ( x ∈ ( R ∪ { A } ) ↦ C ) = ( x ∈ S ↦ C ) ;;
	step 11 : wff = 3eqtr2i (step 7, step 8, step 10) |- ( ( x ∈ R ↦ C ) ∪ { 〈 A , B 〉 } ) = ( x ∈ S ↦ C ) ;;
	qed prop 1 = step 11 ;;
}

/*The value of a restricted identity function.  (Contributed by NM,
     19-May-2004.) */

theorem fvresi (A : class, B : class)  {
	prop 1 : wff = |- ( B ∈ A → ( ( _I ↾ A ) ` B ) = B ) ;;
}

proof of fvresi {
	step 1 : wff = fvres () |- ( B ∈ A → ( ( _I ↾ A ) ` B ) = ( _I ` B ) ) ;;
	step 2 : wff = fvi () |- ( B ∈ A → ( _I ` B ) = B ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( B ∈ A → ( ( _I ↾ A ) ` B ) = B ) ;;
	qed prop 1 = step 3 ;;
}

/*Remove an ordered pair not participating in a function value.
     (Contributed by NM, 1-Oct-2013.)  (Revised by Mario Carneiro,
     28-May-2014.) */

theorem fvunsn (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( B ≠ D → ( ( A ∪ { 〈 B , C 〉 } ) ` D ) = ( A ` D ) ) ;;
}

proof of fvunsn {
	step 1 : wff = resundir () |- ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) = ( ( A ↾ { D } ) ∪ ( { 〈 B , C 〉 } ↾ { D } ) ) ;;
	step 2 : wff = elsni () |- ( B ∈ { D } → B = D ) ;;
	step 3 : wff = necon3ai (step 2) |- ( B ≠ D → ¬ B ∈ { D } ) ;;
	step 4 : wff = ressnop0 () |- ( ¬ B ∈ { D } → ( { 〈 B , C 〉 } ↾ { D } ) = ∅ ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( B ≠ D → ( { 〈 B , C 〉 } ↾ { D } ) = ∅ ) ;;
	step 6 : wff = uneq2d (step 5) |- ( B ≠ D → ( ( A ↾ { D } ) ∪ ( { 〈 B , C 〉 } ↾ { D } ) ) = ( ( A ↾ { D } ) ∪ ∅ ) ) ;;
	step 7 : wff = un0 () |- ( ( A ↾ { D } ) ∪ ∅ ) = ( A ↾ { D } ) ;;
	step 8 : wff = syl6eq (step 6, step 7) |- ( B ≠ D → ( ( A ↾ { D } ) ∪ ( { 〈 B , C 〉 } ↾ { D } ) ) = ( A ↾ { D } ) ) ;;
	step 9 : wff = syl5eq (step 1, step 8) |- ( B ≠ D → ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) = ( A ↾ { D } ) ) ;;
	step 10 : wff = fveq1d (step 9) |- ( B ≠ D → ( ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) ` D ) = ( ( A ↾ { D } ) ` D ) ) ;;
	step 11 : wff = snidg () |- ( D ∈ _V → D ∈ { D } ) ;;
	step 12 : wff = fvres () |- ( D ∈ { D } → ( ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) ` D ) = ( ( A ∪ { 〈 B , C 〉 } ) ` D ) ) ;;
	step 13 : wff = syl (step 11, step 12) |- ( D ∈ _V → ( ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) ` D ) = ( ( A ∪ { 〈 B , C 〉 } ) ` D ) ) ;;
	step 14 : wff = fvprc () |- ( ¬ D ∈ _V → ( ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) ` D ) = ∅ ) ;;
	step 15 : wff = fvprc () |- ( ¬ D ∈ _V → ( ( A ∪ { 〈 B , C 〉 } ) ` D ) = ∅ ) ;;
	step 16 : wff = eqtr4d (step 14, step 15) |- ( ¬ D ∈ _V → ( ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) ` D ) = ( ( A ∪ { 〈 B , C 〉 } ) ` D ) ) ;;
	step 17 : wff = pm2.61i (step 13, step 16) |- ( ( ( A ∪ { 〈 B , C 〉 } ) ↾ { D } ) ` D ) = ( ( A ∪ { 〈 B , C 〉 } ) ` D ) ;;
	step 18 : wff = snidg () |- ( D ∈ _V → D ∈ { D } ) ;;
	step 19 : wff = fvres () |- ( D ∈ { D } → ( ( A ↾ { D } ) ` D ) = ( A ` D ) ) ;;
	step 20 : wff = syl (step 18, step 19) |- ( D ∈ _V → ( ( A ↾ { D } ) ` D ) = ( A ` D ) ) ;;
	step 21 : wff = fvprc () |- ( ¬ D ∈ _V → ( ( A ↾ { D } ) ` D ) = ∅ ) ;;
	step 22 : wff = fvprc () |- ( ¬ D ∈ _V → ( A ` D ) = ∅ ) ;;
	step 23 : wff = eqtr4d (step 21, step 22) |- ( ¬ D ∈ _V → ( ( A ↾ { D } ) ` D ) = ( A ` D ) ) ;;
	step 24 : wff = pm2.61i (step 20, step 23) |- ( ( A ↾ { D } ) ` D ) = ( A ` D ) ;;
	step 25 : wff = 3eqtr3g (step 10, step 17, step 24) |- ( B ≠ D → ( ( A ∪ { 〈 B , C 〉 } ) ` D ) = ( A ` D ) ) ;;
	qed prop 1 = step 25 ;;
}

/*The value of a singleton of an ordered pair is the second member.
       (Contributed by NM, 12-Aug-1994.) */

theorem fvsn (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( { 〈 A , B 〉 } ` A ) = B ;;
}

proof of fvsn {
	step 1 : wff = funsn (hyp 1, hyp 2) |- Fun { 〈 A , B 〉 } ;;
	step 2 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 3 : wff = snid (step 2) |- 〈 A , B 〉 ∈ { 〈 A , B 〉 } ;;
	step 4 : wff = funopfv () |- ( Fun { 〈 A , B 〉 } → ( 〈 A , B 〉 ∈ { 〈 A , B 〉 } → ( { 〈 A , B 〉 } ` A ) = B ) ) ;;
	step 5 : wff = mp2 (step 1, step 3, step 4) |- ( { 〈 A , B 〉 } ` A ) = B ;;
	qed prop 1 = step 5 ;;
}

/*The value of a singleton of an ordered pair is the second member.
       (Contributed by NM, 26-Oct-2012.) */

theorem fvsng (A : class, B : class, V : class, W : class) disjointed(A a b, B b) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( { 〈 A , B 〉 } ` A ) = B ) ;;
}

proof of fvsng {
	var a : set, b : set;;
	step 1 : wff = opeq1 () |- ( a = A → 〈 a , b 〉 = 〈 A , b 〉 ) ;;
	step 2 : wff = sneqd (step 1) |- ( a = A → { 〈 a , b 〉 } = { 〈 A , b 〉 } ) ;;
	step 3 : wff = id () |- ( a = A → a = A ) ;;
	step 4 : wff = fveq12d (step 2, step 3) |- ( a = A → ( { 〈 a , b 〉 } ` a ) = ( { 〈 A , b 〉 } ` A ) ) ;;
	step 5 : wff = eqeq1d (step 4) |- ( a = A → ( ( { 〈 a , b 〉 } ` a ) = b ↔ ( { 〈 A , b 〉 } ` A ) = b ) ) ;;
	step 6 : wff = opeq2 () |- ( b = B → 〈 A , b 〉 = 〈 A , B 〉 ) ;;
	step 7 : wff = sneqd (step 6) |- ( b = B → { 〈 A , b 〉 } = { 〈 A , B 〉 } ) ;;
	step 8 : wff = fveq1d (step 7) |- ( b = B → ( { 〈 A , b 〉 } ` A ) = ( { 〈 A , B 〉 } ` A ) ) ;;
	step 9 : wff = id () |- ( b = B → b = B ) ;;
	step 10 : wff = eqeq12d (step 8, step 9) |- ( b = B → ( ( { 〈 A , b 〉 } ` A ) = b ↔ ( { 〈 A , B 〉 } ` A ) = B ) ) ;;
	step 11 : wff = vex () |- a ∈ _V ;;
	step 12 : wff = vex () |- b ∈ _V ;;
	step 13 : wff = fvsn (step 11, step 12) |- ( { 〈 a , b 〉 } ` a ) = b ;;
	step 14 : wff = vtocl2g (step 5, step 10, step 13) |- ( ( A ∈ V ∧ B ∈ W ) → ( { 〈 A , B 〉 } ` A ) = B ) ;;
	qed prop 1 = step 14 ;;
}

/*The value of a function with one of its ordered pairs replaced, at the
       replaced ordered pair.  See also ~ fvsnun2 .  (Contributed by NM,
       23-Sep-2007.) */

theorem fvsnun1 (A : class, B : class, C : class, F : class, G : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- G = ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( G ` A ) = B ;;
}

proof of fvsnun1 {
	step 1 : wff = reseq1i (hyp 3) |- ( G ↾ { A } ) = ( ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ↾ { A } ) ;;
	step 2 : wff = resundir () |- ( ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ↾ { A } ) = ( ( { 〈 A , B 〉 } ↾ { A } ) ∪ ( ( F ↾ ( C ∖ { A } ) ) ↾ { A } ) ) ;;
	step 3 : wff = incom () |- ( ( C ∖ { A } ) ∩ { A } ) = ( { A } ∩ ( C ∖ { A } ) ) ;;
	step 4 : wff = disjdif () |- ( { A } ∩ ( C ∖ { A } ) ) = ∅ ;;
	step 5 : wff = eqtri (step 3, step 4) |- ( ( C ∖ { A } ) ∩ { A } ) = ∅ ;;
	step 6 : wff = resdisj () |- ( ( ( C ∖ { A } ) ∩ { A } ) = ∅ → ( ( F ↾ ( C ∖ { A } ) ) ↾ { A } ) = ∅ ) ;;
	step 7 : wff = ax-mp (step 5, step 6) |- ( ( F ↾ ( C ∖ { A } ) ) ↾ { A } ) = ∅ ;;
	step 8 : wff = uneq2i (step 7) |- ( ( { 〈 A , B 〉 } ↾ { A } ) ∪ ( ( F ↾ ( C ∖ { A } ) ) ↾ { A } ) ) = ( ( { 〈 A , B 〉 } ↾ { A } ) ∪ ∅ ) ;;
	step 9 : wff = un0 () |- ( ( { 〈 A , B 〉 } ↾ { A } ) ∪ ∅ ) = ( { 〈 A , B 〉 } ↾ { A } ) ;;
	step 10 : wff = eqtri (step 8, step 9) |- ( ( { 〈 A , B 〉 } ↾ { A } ) ∪ ( ( F ↾ ( C ∖ { A } ) ) ↾ { A } ) ) = ( { 〈 A , B 〉 } ↾ { A } ) ;;
	step 11 : wff = eqtri (step 2, step 10) |- ( ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ↾ { A } ) = ( { 〈 A , B 〉 } ↾ { A } ) ;;
	step 12 : wff = eqtri (step 1, step 11) |- ( G ↾ { A } ) = ( { 〈 A , B 〉 } ↾ { A } ) ;;
	step 13 : wff = fveq1i (step 12) |- ( ( G ↾ { A } ) ` A ) = ( ( { 〈 A , B 〉 } ↾ { A } ) ` A ) ;;
	step 14 : wff = snid (hyp 1) |- A ∈ { A } ;;
	step 15 : wff = fvres () |- ( A ∈ { A } → ( ( G ↾ { A } ) ` A ) = ( G ` A ) ) ;;
	step 16 : wff = ax-mp (step 14, step 15) |- ( ( G ↾ { A } ) ` A ) = ( G ` A ) ;;
	step 17 : wff = snid (hyp 1) |- A ∈ { A } ;;
	step 18 : wff = fvres () |- ( A ∈ { A } → ( ( { 〈 A , B 〉 } ↾ { A } ) ` A ) = ( { 〈 A , B 〉 } ` A ) ) ;;
	step 19 : wff = ax-mp (step 17, step 18) |- ( ( { 〈 A , B 〉 } ↾ { A } ) ` A ) = ( { 〈 A , B 〉 } ` A ) ;;
	step 20 : wff = fvsn (hyp 1, hyp 2) |- ( { 〈 A , B 〉 } ` A ) = B ;;
	step 21 : wff = eqtri (step 19, step 20) |- ( ( { 〈 A , B 〉 } ↾ { A } ) ` A ) = B ;;
	step 22 : wff = 3eqtr3i (step 13, step 16, step 21) |- ( G ` A ) = B ;;
	qed prop 1 = step 22 ;;
}

/*The value of a function with one of its ordered pairs replaced, at
       arguments other than the replaced one.  See also ~ fvsnun1 .
       (Contributed by NM, 23-Sep-2007.) */

theorem fvsnun2 (A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- G = ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( D ∈ ( C ∖ { A } ) → ( G ` D ) = ( F ` D ) ) ;;
}

proof of fvsnun2 {
	step 1 : wff = reseq1i (hyp 3) |- ( G ↾ ( C ∖ { A } ) ) = ( ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ↾ ( C ∖ { A } ) ) ;;
	step 2 : wff = resundir () |- ( ( { 〈 A , B 〉 } ∪ ( F ↾ ( C ∖ { A } ) ) ) ↾ ( C ∖ { A } ) ) = ( ( { 〈 A , B 〉 } ↾ ( C ∖ { A } ) ) ∪ ( ( F ↾ ( C ∖ { A } ) ) ↾ ( C ∖ { A } ) ) ) ;;
	step 3 : wff = disjdif () |- ( { A } ∩ ( C ∖ { A } ) ) = ∅ ;;
	step 4 : wff = fnsn (hyp 1, hyp 2) |- { 〈 A , B 〉 } Fn { A } ;;
	step 5 : wff = fnresdisj () |- ( { 〈 A , B 〉 } Fn { A } → ( ( { A } ∩ ( C ∖ { A } ) ) = ∅ ↔ ( { 〈 A , B 〉 } ↾ ( C ∖ { A } ) ) = ∅ ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( ( { A } ∩ ( C ∖ { A } ) ) = ∅ ↔ ( { 〈 A , B 〉 } ↾ ( C ∖ { A } ) ) = ∅ ) ;;
	step 7 : wff = mpbi (step 3, step 6) |- ( { 〈 A , B 〉 } ↾ ( C ∖ { A } ) ) = ∅ ;;
	step 8 : wff = residm () |- ( ( F ↾ ( C ∖ { A } ) ) ↾ ( C ∖ { A } ) ) = ( F ↾ ( C ∖ { A } ) ) ;;
	step 9 : wff = uneq12i (step 7, step 8) |- ( ( { 〈 A , B 〉 } ↾ ( C ∖ { A } ) ) ∪ ( ( F ↾ ( C ∖ { A } ) ) ↾ ( C ∖ { A } ) ) ) = ( ∅ ∪ ( F ↾ ( C ∖ { A } ) ) ) ;;
	step 10 : wff = uncom () |- ( ∅ ∪ ( F ↾ ( C ∖ { A } ) ) ) = ( ( F ↾ ( C ∖ { A } ) ) ∪ ∅ ) ;;
	step 11 : wff = un0 () |- ( ( F ↾ ( C ∖ { A } ) ) ∪ ∅ ) = ( F ↾ ( C ∖ { A } ) ) ;;
	step 12 : wff = 3eqtri (step 9, step 10, step 11) |- ( ( { 〈 A , B 〉 } ↾ ( C ∖ { A } ) ) ∪ ( ( F ↾ ( C ∖ { A } ) ) ↾ ( C ∖ { A } ) ) ) = ( F ↾ ( C ∖ { A } ) ) ;;
	step 13 : wff = 3eqtri (step 1, step 2, step 12) |- ( G ↾ ( C ∖ { A } ) ) = ( F ↾ ( C ∖ { A } ) ) ;;
	step 14 : wff = fveq1i (step 13) |- ( ( G ↾ ( C ∖ { A } ) ) ` D ) = ( ( F ↾ ( C ∖ { A } ) ) ` D ) ;;
	step 15 : wff = fvres () |- ( D ∈ ( C ∖ { A } ) → ( ( G ↾ ( C ∖ { A } ) ) ` D ) = ( G ` D ) ) ;;
	step 16 : wff = fvres () |- ( D ∈ ( C ∖ { A } ) → ( ( F ↾ ( C ∖ { A } ) ) ` D ) = ( F ` D ) ) ;;
	step 17 : wff = 3eqtr3a (step 14, step 15, step 16) |- ( D ∈ ( C ∖ { A } ) → ( G ` D ) = ( F ` D ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Split a function into a single point and all the rest.  (Contributed by
     Stefan O'Rear, 27-Feb-2015.) */

theorem fnsnsplit (A : class, F : class, X : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ X ∈ A ) → F = ( ( F ↾ ( A ∖ { X } ) ) ∪ { 〈 X , ( F ` X ) 〉 } ) ) ;;
}

proof of fnsnsplit {
	step 1 : wff = fnresdm () |- ( F Fn A → ( F ↾ A ) = F ) ;;
	step 2 : wff = adantr (step 1) |- ( ( F Fn A ∧ X ∈ A ) → ( F ↾ A ) = F ) ;;
	step 3 : wff = resundi () |- ( F ↾ ( ( A ∖ { X } ) ∪ { X } ) ) = ( ( F ↾ ( A ∖ { X } ) ) ∪ ( F ↾ { X } ) ) ;;
	step 4 : wff = difsnid () |- ( X ∈ A → ( ( A ∖ { X } ) ∪ { X } ) = A ) ;;
	step 5 : wff = adantl (step 4) |- ( ( F Fn A ∧ X ∈ A ) → ( ( A ∖ { X } ) ∪ { X } ) = A ) ;;
	step 6 : wff = reseq2d (step 5) |- ( ( F Fn A ∧ X ∈ A ) → ( F ↾ ( ( A ∖ { X } ) ∪ { X } ) ) = ( F ↾ A ) ) ;;
	step 7 : wff = fnressn () |- ( ( F Fn A ∧ X ∈ A ) → ( F ↾ { X } ) = { 〈 X , ( F ` X ) 〉 } ) ;;
	step 8 : wff = uneq2d (step 7) |- ( ( F Fn A ∧ X ∈ A ) → ( ( F ↾ ( A ∖ { X } ) ) ∪ ( F ↾ { X } ) ) = ( ( F ↾ ( A ∖ { X } ) ) ∪ { 〈 X , ( F ` X ) 〉 } ) ) ;;
	step 9 : wff = 3eqtr3a (step 3, step 6, step 8) |- ( ( F Fn A ∧ X ∈ A ) → ( F ↾ A ) = ( ( F ↾ ( A ∖ { X } ) ) ∪ { 〈 X , ( F ` X ) 〉 } ) ) ;;
	step 10 : wff = eqtr3d (step 2, step 9) |- ( ( F Fn A ∧ X ∈ A ) → F = ( ( F ↾ ( A ∖ { X } ) ) ∪ { 〈 X , ( F ` X ) 〉 } ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Adjoining a point to a function gives a function.  (Contributed by Stefan
     O'Rear, 28-Feb-2015.) */

theorem fsnunf (S : class, T : class, F : class, V : class, X : class, Y : class)  {
	prop 1 : wff = |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ T ) ;;
}

proof of fsnunf {
	step 1 : wff = simp1 () |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → F : S ⟶ T ) ;;
	step 2 : wff = simp2l () |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → X ∈ V ) ;;
	step 3 : wff = simp3 () |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → Y ∈ T ) ;;
	step 4 : wff = f1osng () |- ( ( X ∈ V ∧ Y ∈ T ) → { 〈 X , Y 〉 } : { X } ⤖ { Y } ) ;;
	step 5 : wff = syl2anc (step 2, step 3, step 4) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → { 〈 X , Y 〉 } : { X } ⤖ { Y } ) ;;
	step 6 : wff = f1of () |- ( { 〈 X , Y 〉 } : { X } ⤖ { Y } → { 〈 X , Y 〉 } : { X } ⟶ { Y } ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → { 〈 X , Y 〉 } : { X } ⟶ { Y } ) ;;
	step 8 : wff = simp2r () |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ¬ X ∈ S ) ;;
	step 9 : wff = disjsn () |- ( ( S ∩ { X } ) = ∅ ↔ ¬ X ∈ S ) ;;
	step 10 : wff = sylibr (step 8, step 9) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ( S ∩ { X } ) = ∅ ) ;;
	step 11 : wff = fun () |- ( ( ( F : S ⟶ T ∧ { 〈 X , Y 〉 } : { X } ⟶ { Y } ) ∧ ( S ∩ { X } ) = ∅ ) → ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ ( T ∪ { Y } ) ) ;;
	step 12 : wff = syl21anc (step 1, step 7, step 10, step 11) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ ( T ∪ { Y } ) ) ;;
	step 13 : wff = snssi () |- ( Y ∈ T → { Y } ⊆ T ) ;;
	step 14 : wff = 3ad2ant3 (step 13) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → { Y } ⊆ T ) ;;
	step 15 : wff = ssequn2 () |- ( { Y } ⊆ T ↔ ( T ∪ { Y } ) = T ) ;;
	step 16 : wff = sylib (step 14, step 15) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ( T ∪ { Y } ) = T ) ;;
	step 17 : wff = feq3 () |- ( ( T ∪ { Y } ) = T → ( ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ ( T ∪ { Y } ) ↔ ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ T ) ) ;;
	step 18 : wff = syl (step 16, step 17) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ( ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ ( T ∪ { Y } ) ↔ ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ T ) ) ;;
	step 19 : wff = mpbid (step 12, step 18) |- ( ( F : S ⟶ T ∧ ( X ∈ V ∧ ¬ X ∈ S ) ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : ( S ∪ { X } ) ⟶ T ) ;;
	qed prop 1 = step 19 ;;
}

/*Adjoining a point to a punctured function gives a function.  (Contributed
     by Stefan O'Rear, 28-Feb-2015.) */

theorem fsnunf2 (S : class, T : class, F : class, X : class, Y : class)  {
	prop 1 : wff = |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : S ⟶ T ) ;;
}

proof of fsnunf2 {
	step 1 : wff = simp1 () |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → F : ( S ∖ { X } ) ⟶ T ) ;;
	step 2 : wff = simp2 () |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → X ∈ S ) ;;
	step 3 : wff = snidg () |- ( X ∈ S → X ∈ { X } ) ;;
	step 4 : wff = elndif () |- ( X ∈ { X } → ¬ X ∈ ( S ∖ { X } ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( X ∈ S → ¬ X ∈ ( S ∖ { X } ) ) ;;
	step 6 : wff = 3ad2ant2 (step 5) |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → ¬ X ∈ ( S ∖ { X } ) ) ;;
	step 7 : wff = simp3 () |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → Y ∈ T ) ;;
	step 8 : wff = fsnunf () |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ ( X ∈ S ∧ ¬ X ∈ ( S ∖ { X } ) ) ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : ( ( S ∖ { X } ) ∪ { X } ) ⟶ T ) ;;
	step 9 : wff = syl121anc (step 1, step 2, step 6, step 7, step 8) |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : ( ( S ∖ { X } ) ∪ { X } ) ⟶ T ) ;;
	step 10 : wff = difsnid () |- ( X ∈ S → ( ( S ∖ { X } ) ∪ { X } ) = S ) ;;
	step 11 : wff = 3ad2ant2 (step 10) |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → ( ( S ∖ { X } ) ∪ { X } ) = S ) ;;
	step 12 : wff = feq2d (step 11) |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → ( ( F ∪ { 〈 X , Y 〉 } ) : ( ( S ∖ { X } ) ∪ { X } ) ⟶ T ↔ ( F ∪ { 〈 X , Y 〉 } ) : S ⟶ T ) ) ;;
	step 13 : wff = mpbid (step 9, step 12) |- ( ( F : ( S ∖ { X } ) ⟶ T ∧ X ∈ S ∧ Y ∈ T ) → ( F ∪ { 〈 X , Y 〉 } ) : S ⟶ T ) ;;
	qed prop 1 = step 13 ;;
}

/*Recover the added point from a point-added function.  (Contributed by
     Stefan O'Rear, 28-Feb-2015.)  (Revised by NM, 18-May-2017.) */

theorem fsnunfv (F : class, V : class, W : class, X : class, Y : class)  {
	prop 1 : wff = |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( ( F ∪ { 〈 X , Y 〉 } ) ` X ) = Y ) ;;
}

proof of fsnunfv {
	step 1 : wff = dmres () |- dom ( F ↾ { X } ) = ( { X } ∩ dom F ) ;;
	step 2 : wff = incom () |- ( { X } ∩ dom F ) = ( dom F ∩ { X } ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- dom ( F ↾ { X } ) = ( dom F ∩ { X } ) ;;
	step 4 : wff = disjsn () |- ( ( dom F ∩ { X } ) = ∅ ↔ ¬ X ∈ dom F ) ;;
	step 5 : wff = biimpri (step 4) |- ( ¬ X ∈ dom F → ( dom F ∩ { X } ) = ∅ ) ;;
	step 6 : wff = syl5eq (step 3, step 5) |- ( ¬ X ∈ dom F → dom ( F ↾ { X } ) = ∅ ) ;;
	step 7 : wff = 3ad2ant3 (step 6) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → dom ( F ↾ { X } ) = ∅ ) ;;
	step 8 : wff = relres () |- Rel ( F ↾ { X } ) ;;
	step 9 : wff = reldm0 () |- ( Rel ( F ↾ { X } ) → ( ( F ↾ { X } ) = ∅ ↔ dom ( F ↾ { X } ) = ∅ ) ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- ( ( F ↾ { X } ) = ∅ ↔ dom ( F ↾ { X } ) = ∅ ) ;;
	step 11 : wff = sylibr (step 7, step 10) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( F ↾ { X } ) = ∅ ) ;;
	step 12 : wff = fnsng () |- ( ( X ∈ V ∧ Y ∈ W ) → { 〈 X , Y 〉 } Fn { X } ) ;;
	step 13 : wff = 3adant3 (step 12) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → { 〈 X , Y 〉 } Fn { X } ) ;;
	step 14 : wff = fnresdm () |- ( { 〈 X , Y 〉 } Fn { X } → ( { 〈 X , Y 〉 } ↾ { X } ) = { 〈 X , Y 〉 } ) ;;
	step 15 : wff = syl (step 13, step 14) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( { 〈 X , Y 〉 } ↾ { X } ) = { 〈 X , Y 〉 } ) ;;
	step 16 : wff = uneq12d (step 11, step 15) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( ( F ↾ { X } ) ∪ ( { 〈 X , Y 〉 } ↾ { X } ) ) = ( ∅ ∪ { 〈 X , Y 〉 } ) ) ;;
	step 17 : wff = resundir () |- ( ( F ∪ { 〈 X , Y 〉 } ) ↾ { X } ) = ( ( F ↾ { X } ) ∪ ( { 〈 X , Y 〉 } ↾ { X } ) ) ;;
	step 18 : wff = uncom () |- ( ∅ ∪ { 〈 X , Y 〉 } ) = ( { 〈 X , Y 〉 } ∪ ∅ ) ;;
	step 19 : wff = un0 () |- ( { 〈 X , Y 〉 } ∪ ∅ ) = { 〈 X , Y 〉 } ;;
	step 20 : wff = eqtr2i (step 18, step 19) |- { 〈 X , Y 〉 } = ( ∅ ∪ { 〈 X , Y 〉 } ) ;;
	step 21 : wff = 3eqtr4g (step 16, step 17, step 20) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( ( F ∪ { 〈 X , Y 〉 } ) ↾ { X } ) = { 〈 X , Y 〉 } ) ;;
	step 22 : wff = fveq1d (step 21) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( ( ( F ∪ { 〈 X , Y 〉 } ) ↾ { X } ) ` X ) = ( { 〈 X , Y 〉 } ` X ) ) ;;
	step 23 : wff = snidg () |- ( X ∈ V → X ∈ { X } ) ;;
	step 24 : wff = 3ad2ant1 (step 23) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → X ∈ { X } ) ;;
	step 25 : wff = fvres () |- ( X ∈ { X } → ( ( ( F ∪ { 〈 X , Y 〉 } ) ↾ { X } ) ` X ) = ( ( F ∪ { 〈 X , Y 〉 } ) ` X ) ) ;;
	step 26 : wff = syl (step 24, step 25) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( ( ( F ∪ { 〈 X , Y 〉 } ) ↾ { X } ) ` X ) = ( ( F ∪ { 〈 X , Y 〉 } ) ` X ) ) ;;
	step 27 : wff = fvsng () |- ( ( X ∈ V ∧ Y ∈ W ) → ( { 〈 X , Y 〉 } ` X ) = Y ) ;;
	step 28 : wff = 3adant3 (step 27) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( { 〈 X , Y 〉 } ` X ) = Y ) ;;
	step 29 : wff = 3eqtr3d (step 22, step 26, step 28) |- ( ( X ∈ V ∧ Y ∈ W ∧ ¬ X ∈ dom F ) → ( ( F ∪ { 〈 X , Y 〉 } ) ` X ) = Y ) ;;
	qed prop 1 = step 29 ;;
}

/*Recover the original function from a point-added function.  (Contributed
     by Stefan O'Rear, 28-Feb-2015.) */

theorem fsnunres (S : class, F : class, X : class, Y : class)  {
	prop 1 : wff = |- ( ( F Fn S ∧ ¬ X ∈ S ) → ( ( F ∪ { 〈 X , Y 〉 } ) ↾ S ) = F ) ;;
}

proof of fsnunres {
	step 1 : wff = fnresdm () |- ( F Fn S → ( F ↾ S ) = F ) ;;
	step 2 : wff = adantr (step 1) |- ( ( F Fn S ∧ ¬ X ∈ S ) → ( F ↾ S ) = F ) ;;
	step 3 : wff = ressnop0 () |- ( ¬ X ∈ S → ( { 〈 X , Y 〉 } ↾ S ) = ∅ ) ;;
	step 4 : wff = adantl (step 3) |- ( ( F Fn S ∧ ¬ X ∈ S ) → ( { 〈 X , Y 〉 } ↾ S ) = ∅ ) ;;
	step 5 : wff = uneq12d (step 2, step 4) |- ( ( F Fn S ∧ ¬ X ∈ S ) → ( ( F ↾ S ) ∪ ( { 〈 X , Y 〉 } ↾ S ) ) = ( F ∪ ∅ ) ) ;;
	step 6 : wff = resundir () |- ( ( F ∪ { 〈 X , Y 〉 } ) ↾ S ) = ( ( F ↾ S ) ∪ ( { 〈 X , Y 〉 } ↾ S ) ) ;;
	step 7 : wff = un0 () |- ( F ∪ ∅ ) = F ;;
	step 8 : wff = eqcomi (step 7) |- F = ( F ∪ ∅ ) ;;
	step 9 : wff = 3eqtr4g (step 5, step 6, step 8) |- ( ( F Fn S ∧ ¬ X ∈ S ) → ( ( F ∪ { 〈 X , Y 〉 } ) ↾ S ) = F ) ;;
	qed prop 1 = step 9 ;;
}

/*The value of a function with a domain of two elements.  (Contributed by
       Jeff Madsen, 20-Jun-2010.) */

theorem fvpr1 (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ≠ B → ( { 〈 A , C 〉 , 〈 B , D 〉 } ` A ) = C ) ;;
}

proof of fvpr1 {
	step 1 : wff = df-pr () |- { 〈 A , C 〉 , 〈 B , D 〉 } = ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ;;
	step 2 : wff = fveq1i (step 1) |- ( { 〈 A , C 〉 , 〈 B , D 〉 } ` A ) = ( ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ` A ) ;;
	step 3 : wff = necom () |- ( A ≠ B ↔ B ≠ A ) ;;
	step 4 : wff = fvunsn () |- ( B ≠ A → ( ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ` A ) = ( { 〈 A , C 〉 } ` A ) ) ;;
	step 5 : wff = sylbi (step 3, step 4) |- ( A ≠ B → ( ( { 〈 A , C 〉 } ∪ { 〈 B , D 〉 } ) ` A ) = ( { 〈 A , C 〉 } ` A ) ) ;;
	step 6 : wff = syl5eq (step 2, step 5) |- ( A ≠ B → ( { 〈 A , C 〉 , 〈 B , D 〉 } ` A ) = ( { 〈 A , C 〉 } ` A ) ) ;;
	step 7 : wff = fvsn (hyp 1, hyp 2) |- ( { 〈 A , C 〉 } ` A ) = C ;;
	step 8 : wff = syl6eq (step 6, step 7) |- ( A ≠ B → ( { 〈 A , C 〉 , 〈 B , D 〉 } ` A ) = C ) ;;
	qed prop 1 = step 8 ;;
}

/*The value of a function with a domain of two elements.  (Contributed by
       Jeff Madsen, 20-Jun-2010.) */

theorem fvpr2 (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ≠ B → ( { 〈 A , C 〉 , 〈 B , D 〉 } ` B ) = D ) ;;
}

proof of fvpr2 {
	step 1 : wff = prcom () |- { 〈 A , C 〉 , 〈 B , D 〉 } = { 〈 B , D 〉 , 〈 A , C 〉 } ;;
	step 2 : wff = fveq1i (step 1) |- ( { 〈 A , C 〉 , 〈 B , D 〉 } ` B ) = ( { 〈 B , D 〉 , 〈 A , C 〉 } ` B ) ;;
	step 3 : wff = necom () |- ( A ≠ B ↔ B ≠ A ) ;;
	step 4 : wff = fvpr1 (hyp 1, hyp 2) |- ( B ≠ A → ( { 〈 B , D 〉 , 〈 A , C 〉 } ` B ) = D ) ;;
	step 5 : wff = sylbi (step 3, step 4) |- ( A ≠ B → ( { 〈 B , D 〉 , 〈 A , C 〉 } ` B ) = D ) ;;
	step 6 : wff = syl5eq (step 2, step 5) |- ( A ≠ B → ( { 〈 A , C 〉 , 〈 B , D 〉 } ` B ) = D ) ;;
	qed prop 1 = step 6 ;;
}

/*The first value of a function with a domain of three elements.
       (Contributed by NM, 14-Sep-2011.) */

theorem fvtp1 (A : class, B : class, C : class, D : class, E : class, F : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ≠ B ∧ A ≠ C ) → ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` A ) = D ) ;;
}

proof of fvtp1 {
	step 1 : wff = df-tp () |- { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ;;
	step 2 : wff = fveq1i (step 1) |- ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` A ) = ( ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ` A ) ;;
	step 3 : wff = necom () |- ( A ≠ C ↔ C ≠ A ) ;;
	step 4 : wff = fvunsn () |- ( C ≠ A → ( ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ` A ) = ( { 〈 A , D 〉 , 〈 B , E 〉 } ` A ) ) ;;
	step 5 : wff = sylbi (step 3, step 4) |- ( A ≠ C → ( ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ` A ) = ( { 〈 A , D 〉 , 〈 B , E 〉 } ` A ) ) ;;
	step 6 : wff = fvpr1 (hyp 1, hyp 2) |- ( A ≠ B → ( { 〈 A , D 〉 , 〈 B , E 〉 } ` A ) = D ) ;;
	step 7 : wff = sylan9eqr (step 5, step 6) |- ( ( A ≠ B ∧ A ≠ C ) → ( ( { 〈 A , D 〉 , 〈 B , E 〉 } ∪ { 〈 C , F 〉 } ) ` A ) = D ) ;;
	step 8 : wff = syl5eq (step 2, step 7) |- ( ( A ≠ B ∧ A ≠ C ) → ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` A ) = D ) ;;
	qed prop 1 = step 8 ;;
}

/*The second value of a function with a domain of three elements.
       (Contributed by NM, 14-Sep-2011.) */

theorem fvtp2 (A : class, B : class, C : class, D : class, E : class, F : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- E ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ≠ B ∧ B ≠ C ) → ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` B ) = E ) ;;
}

proof of fvtp2 {
	step 1 : wff = tprot () |- { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ;;
	step 2 : wff = fveq1i (step 1) |- ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` B ) = ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` B ) ;;
	step 3 : wff = necom () |- ( A ≠ B ↔ B ≠ A ) ;;
	step 4 : wff = fvtp1 (hyp 1, hyp 2) |- ( ( B ≠ C ∧ B ≠ A ) → ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` B ) = E ) ;;
	step 5 : wff = ancoms (step 4) |- ( ( B ≠ A ∧ B ≠ C ) → ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` B ) = E ) ;;
	step 6 : wff = sylanb (step 3, step 5) |- ( ( A ≠ B ∧ B ≠ C ) → ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` B ) = E ) ;;
	step 7 : wff = syl5eq (step 2, step 6) |- ( ( A ≠ B ∧ B ≠ C ) → ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` B ) = E ) ;;
	qed prop 1 = step 7 ;;
}

/*The third value of a function with a domain of three elements.
       (Contributed by NM, 14-Sep-2011.) */

theorem fvtp3 (A : class, B : class, C : class, D : class, E : class, F : class)  {
	hyp 1 : wff = |- C ∈ _V ;;
	hyp 2 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A ≠ C ∧ B ≠ C ) → ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` C ) = F ) ;;
}

proof of fvtp3 {
	step 1 : wff = tprot () |- { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } = { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ;;
	step 2 : wff = fveq1i (step 1) |- ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` C ) = ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` C ) ;;
	step 3 : wff = necom () |- ( A ≠ C ↔ C ≠ A ) ;;
	step 4 : wff = fvtp2 (hyp 1, hyp 2) |- ( ( B ≠ C ∧ C ≠ A ) → ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` C ) = F ) ;;
	step 5 : wff = sylan2b (step 3, step 4) |- ( ( B ≠ C ∧ A ≠ C ) → ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` C ) = F ) ;;
	step 6 : wff = ancoms (step 5) |- ( ( A ≠ C ∧ B ≠ C ) → ( { 〈 B , E 〉 , 〈 C , F 〉 , 〈 A , D 〉 } ` C ) = F ) ;;
	step 7 : wff = syl5eq (step 2, step 6) |- ( ( A ≠ C ∧ B ≠ C ) → ( { 〈 A , D 〉 , 〈 B , E 〉 , 〈 C , F 〉 } ` C ) = F ) ;;
	qed prop 1 = step 7 ;;
}

/*The value of a constant function.  (Contributed by NM, 20-Aug-2005.) */

theorem fvconst2g (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( B ∈ D ∧ C ∈ A ) → ( ( A × { B } ) ` C ) = B ) ;;
}

proof of fvconst2g {
	step 1 : wff = fconstg () |- ( B ∈ D → ( A × { B } ) : A ⟶ { B } ) ;;
	step 2 : wff = fvconst () |- ( ( ( A × { B } ) : A ⟶ { B } ∧ C ∈ A ) → ( ( A × { B } ) ` C ) = B ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( B ∈ D ∧ C ∈ A ) → ( ( A × { B } ) ` C ) = B ) ;;
	qed prop 1 = step 3 ;;
}

/*A constant function expressed as a cross product.  (Contributed by NM,
       27-Nov-2007.) */

theorem fconst2g (A : class, B : class, C : class, F : class) disjointed(x A, x B, x C, x F) {
	prop 1 : wff = |- ( B ∈ C → ( F : A ⟶ { B } ↔ F = ( A × { B } ) ) ) ;;
}

proof of fconst2g {
	var x : set;;
	step 1 : wff = fvconst () |- ( ( F : A ⟶ { B } ∧ x ∈ A ) → ( F ` x ) = B ) ;;
	step 2 : wff = adantlr (step 1) |- ( ( ( F : A ⟶ { B } ∧ B ∈ C ) ∧ x ∈ A ) → ( F ` x ) = B ) ;;
	step 3 : wff = fvconst2g () |- ( ( B ∈ C ∧ x ∈ A ) → ( ( A × { B } ) ` x ) = B ) ;;
	step 4 : wff = adantll (step 3) |- ( ( ( F : A ⟶ { B } ∧ B ∈ C ) ∧ x ∈ A ) → ( ( A × { B } ) ` x ) = B ) ;;
	step 5 : wff = eqtr4d (step 2, step 4) |- ( ( ( F : A ⟶ { B } ∧ B ∈ C ) ∧ x ∈ A ) → ( F ` x ) = ( ( A × { B } ) ` x ) ) ;;
	step 6 : wff = ralrimiva (step 5) |- ( ( F : A ⟶ { B } ∧ B ∈ C ) → ∀ x ∈ A ( F ` x ) = ( ( A × { B } ) ` x ) ) ;;
	step 7 : wff = ffn () |- ( F : A ⟶ { B } → F Fn A ) ;;
	step 8 : wff = fnconstg () |- ( B ∈ C → ( A × { B } ) Fn A ) ;;
	step 9 : wff = eqfnfv () |- ( ( F Fn A ∧ ( A × { B } ) Fn A ) → ( F = ( A × { B } ) ↔ ∀ x ∈ A ( F ` x ) = ( ( A × { B } ) ` x ) ) ) ;;
	step 10 : wff = syl2an (step 7, step 8, step 9) |- ( ( F : A ⟶ { B } ∧ B ∈ C ) → ( F = ( A × { B } ) ↔ ∀ x ∈ A ( F ` x ) = ( ( A × { B } ) ` x ) ) ) ;;
	step 11 : wff = mpbird (step 6, step 10) |- ( ( F : A ⟶ { B } ∧ B ∈ C ) → F = ( A × { B } ) ) ;;
	step 12 : wff = expcom (step 11) |- ( B ∈ C → ( F : A ⟶ { B } → F = ( A × { B } ) ) ) ;;
	step 13 : wff = fconstg () |- ( B ∈ C → ( A × { B } ) : A ⟶ { B } ) ;;
	step 14 : wff = feq1 () |- ( F = ( A × { B } ) → ( F : A ⟶ { B } ↔ ( A × { B } ) : A ⟶ { B } ) ) ;;
	step 15 : wff = syl5ibrcom (step 13, step 14) |- ( B ∈ C → ( F = ( A × { B } ) → F : A ⟶ { B } ) ) ;;
	step 16 : wff = impbid (step 12, step 15) |- ( B ∈ C → ( F : A ⟶ { B } ↔ F = ( A × { B } ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/*The value of a constant function.  (Contributed by NM, 16-Apr-2005.) */

theorem fvconst2 (A : class, B : class, C : class) disjointed(A, B) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ A → ( ( A × { B } ) ` C ) = B ) ;;
}

proof of fvconst2 {
	step 1 : wff = fvconst2g () |- ( ( B ∈ _V ∧ C ∈ A ) → ( ( A × { B } ) ` C ) = B ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( C ∈ A → ( ( A × { B } ) ` C ) = B ) ;;
	qed prop 1 = step 2 ;;
}

/*A constant function expressed as a cross product.  (Contributed by NM,
       20-Aug-1999.) */

theorem fconst2 (A : class, B : class, F : class) disjointed(A, B, F) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⟶ { B } ↔ F = ( A × { B } ) ) ;;
}

proof of fconst2 {
	step 1 : wff = fconst2g () |- ( B ∈ _V → ( F : A ⟶ { B } ↔ F = ( A × { B } ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( F : A ⟶ { B } ↔ F = ( A × { B } ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Two ways to express that a function is constant.  (Contributed by NM,
     27-Nov-2007.) */

theorem fconst5 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ A ≠ ∅ ) → ( F = ( A × { B } ) ↔ ran F = { B } ) ) ;;
}

proof of fconst5 {
	step 1 : wff = rneq () |- ( F = ( A × { B } ) → ran F = ran ( A × { B } ) ) ;;
	step 2 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × { B } ) = { B } ) ;;
	step 3 : wff = eqeq2d (step 2) |- ( A ≠ ∅ → ( ran F = ran ( A × { B } ) ↔ ran F = { B } ) ) ;;
	step 4 : wff = syl5ib (step 1, step 3) |- ( A ≠ ∅ → ( F = ( A × { B } ) → ran F = { B } ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( F Fn A ∧ A ≠ ∅ ) → ( F = ( A × { B } ) → ran F = { B } ) ) ;;
	step 6 : wff = df-fo () |- ( F : A ↠ { B } ↔ ( F Fn A ∧ ran F = { B } ) ) ;;
	step 7 : wff = fof () |- ( F : A ↠ { B } → F : A ⟶ { B } ) ;;
	step 8 : wff = sylbir (step 6, step 7) |- ( ( F Fn A ∧ ran F = { B } ) → F : A ⟶ { B } ) ;;
	step 9 : wff = fconst2g () |- ( B ∈ _V → ( F : A ⟶ { B } ↔ F = ( A × { B } ) ) ) ;;
	step 10 : wff = syl5ib (step 8, step 9) |- ( B ∈ _V → ( ( F Fn A ∧ ran F = { B } ) → F = ( A × { B } ) ) ) ;;
	step 11 : wff = exp3a (step 10) |- ( B ∈ _V → ( F Fn A → ( ran F = { B } → F = ( A × { B } ) ) ) ) ;;
	step 12 : wff = adantrd (step 11) |- ( B ∈ _V → ( ( F Fn A ∧ A ≠ ∅ ) → ( ran F = { B } → F = ( A × { B } ) ) ) ) ;;
	step 13 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 14 : wff = snprc () |- ( ¬ B ∈ _V ↔ { B } = ∅ ) ;;
	step 15 : wff = relrn0 () |- ( Rel F → ( F = ∅ ↔ ran F = ∅ ) ) ;;
	step 16 : wff = biimprd (step 15) |- ( Rel F → ( ran F = ∅ → F = ∅ ) ) ;;
	step 17 : wff = adantl (step 16) |- ( ( { B } = ∅ ∧ Rel F ) → ( ran F = ∅ → F = ∅ ) ) ;;
	step 18 : wff = eqeq2 () |- ( { B } = ∅ → ( ran F = { B } ↔ ran F = ∅ ) ) ;;
	step 19 : wff = adantr (step 18) |- ( ( { B } = ∅ ∧ Rel F ) → ( ran F = { B } ↔ ran F = ∅ ) ) ;;
	step 20 : wff = xpeq2 () |- ( { B } = ∅ → ( A × { B } ) = ( A × ∅ ) ) ;;
	step 21 : wff = xp0 () |- ( A × ∅ ) = ∅ ;;
	step 22 : wff = syl6eq (step 20, step 21) |- ( { B } = ∅ → ( A × { B } ) = ∅ ) ;;
	step 23 : wff = eqeq2d (step 22) |- ( { B } = ∅ → ( F = ( A × { B } ) ↔ F = ∅ ) ) ;;
	step 24 : wff = adantr (step 23) |- ( ( { B } = ∅ ∧ Rel F ) → ( F = ( A × { B } ) ↔ F = ∅ ) ) ;;
	step 25 : wff = 3imtr4d (step 17, step 19, step 24) |- ( ( { B } = ∅ ∧ Rel F ) → ( ran F = { B } → F = ( A × { B } ) ) ) ;;
	step 26 : wff = ex (step 25) |- ( { B } = ∅ → ( Rel F → ( ran F = { B } → F = ( A × { B } ) ) ) ) ;;
	step 27 : wff = sylbi (step 14, step 26) |- ( ¬ B ∈ _V → ( Rel F → ( ran F = { B } → F = ( A × { B } ) ) ) ) ;;
	step 28 : wff = syl5 (step 13, step 27) |- ( ¬ B ∈ _V → ( F Fn A → ( ran F = { B } → F = ( A × { B } ) ) ) ) ;;
	step 29 : wff = adantrd (step 28) |- ( ¬ B ∈ _V → ( ( F Fn A ∧ A ≠ ∅ ) → ( ran F = { B } → F = ( A × { B } ) ) ) ) ;;
	step 30 : wff = pm2.61i (step 12, step 29) |- ( ( F Fn A ∧ A ≠ ∅ ) → ( ran F = { B } → F = ( A × { B } ) ) ) ;;
	step 31 : wff = impbid (step 5, step 30) |- ( ( F Fn A ∧ A ≠ ∅ ) → ( F = ( A × { B } ) ↔ ran F = { B } ) ) ;;
	qed prop 1 = step 31 ;;
}

/*Two ways to express restriction of a support set.  (Contributed by
       Stefan O'Rear, 5-Feb-2015.) */

theorem fnsuppres (A : class, B : class, F : class, V : class, Z : class) disjointed(F a, V a, A a, B a, Z a) {
	prop 1 : wff = |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ A ↔ ( F ↾ B ) = ( B × { Z } ) ) ) ;;
}

proof of fnsuppres {
	var a : set;;
	step 1 : wff = unss () |- ( ( { a ∈ A | ( F ` a ) ≠ Z } ⊆ A ∧ { a ∈ B | ( F ` a ) ≠ Z } ⊆ A ) ↔ ( { a ∈ A | ( F ` a ) ≠ Z } ∪ { a ∈ B | ( F ` a ) ≠ Z } ) ⊆ A ) ;;
	step 2 : wff = ssrab2 () |- { a ∈ A | ( F ` a ) ≠ Z } ⊆ A ;;
	step 3 : wff = biantrur (step 2) |- ( { a ∈ B | ( F ` a ) ≠ Z } ⊆ A ↔ ( { a ∈ A | ( F ` a ) ≠ Z } ⊆ A ∧ { a ∈ B | ( F ` a ) ≠ Z } ⊆ A ) ) ;;
	step 4 : wff = rabun2 () |- { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } = ( { a ∈ A | ( F ` a ) ≠ Z } ∪ { a ∈ B | ( F ` a ) ≠ Z } ) ;;
	step 5 : wff = sseq1i (step 4) |- ( { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } ⊆ A ↔ ( { a ∈ A | ( F ` a ) ≠ Z } ∪ { a ∈ B | ( F ` a ) ≠ Z } ) ⊆ A ) ;;
	step 6 : wff = 3bitr4ri (step 1, step 3, step 5) |- ( { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } ⊆ A ↔ { a ∈ B | ( F ` a ) ≠ Z } ⊆ A ) ;;
	step 7 : wff = rabss () |- ( { a ∈ B | ( F ` a ) ≠ Z } ⊆ A ↔ ∀ a ∈ B ( ( F ` a ) ≠ Z → a ∈ A ) ) ;;
	step 8 : wff = fvres () |- ( a ∈ B → ( ( F ↾ B ) ` a ) = ( F ` a ) ) ;;
	step 9 : wff = adantl (step 8) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ( ( F ↾ B ) ` a ) = ( F ` a ) ) ;;
	step 10 : wff = fvconst2g () |- ( ( Z ∈ V ∧ a ∈ B ) → ( ( B × { Z } ) ` a ) = Z ) ;;
	step 11 : wff = 3ad2antl3 (step 10) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ( ( B × { Z } ) ` a ) = Z ) ;;
	step 12 : wff = eqeq12d (step 9, step 11) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ( ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ↔ ( F ` a ) = Z ) ) ;;
	step 13 : wff = nne () |- ( ¬ ( F ` a ) ≠ Z ↔ ( F ` a ) = Z ) ;;
	step 14 : wff = a1i (step 13) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ( ¬ ( F ` a ) ≠ Z ↔ ( F ` a ) = Z ) ) ;;
	step 15 : wff = id () |- ( a ∈ B → a ∈ B ) ;;
	step 16 : wff = simp2 () |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( A ∩ B ) = ∅ ) ;;
	step 17 : wff = minel () |- ( ( a ∈ B ∧ ( A ∩ B ) = ∅ ) → ¬ a ∈ A ) ;;
	step 18 : wff = syl2anr (step 15, step 16, step 17) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ¬ a ∈ A ) ;;
	step 19 : wff = mtt () |- ( ¬ a ∈ A → ( ¬ ( F ` a ) ≠ Z ↔ ( ( F ` a ) ≠ Z → a ∈ A ) ) ) ;;
	step 20 : wff = syl (step 18, step 19) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ( ¬ ( F ` a ) ≠ Z ↔ ( ( F ` a ) ≠ Z → a ∈ A ) ) ) ;;
	step 21 : wff = 3bitr2rd (step 12, step 14, step 20) |- ( ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) ∧ a ∈ B ) → ( ( ( F ` a ) ≠ Z → a ∈ A ) ↔ ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ) ) ;;
	step 22 : wff = ralbidva (step 21) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( ∀ a ∈ B ( ( F ` a ) ≠ Z → a ∈ A ) ↔ ∀ a ∈ B ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ) ) ;;
	step 23 : wff = syl5bb (step 7, step 22) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( { a ∈ B | ( F ` a ) ≠ Z } ⊆ A ↔ ∀ a ∈ B ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ) ) ;;
	step 24 : wff = syl5bb (step 6, step 23) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } ⊆ A ↔ ∀ a ∈ B ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ) ) ;;
	step 25 : wff = fnniniseg2 () |- ( F Fn ( A ∪ B ) → ( ⁻¹ F " ( _V ∖ { Z } ) ) = { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } ) ;;
	step 26 : wff = 3ad2ant1 (step 25) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( ⁻¹ F " ( _V ∖ { Z } ) ) = { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } ) ;;
	step 27 : wff = sseq1d (step 26) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ A ↔ { a ∈ ( A ∪ B ) | ( F ` a ) ≠ Z } ⊆ A ) ) ;;
	step 28 : wff = simp1 () |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → F Fn ( A ∪ B ) ) ;;
	step 29 : wff = ssun2 () |- B ⊆ ( A ∪ B ) ;;
	step 30 : wff = a1i (step 29) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → B ⊆ ( A ∪ B ) ) ;;
	step 31 : wff = fnssres () |- ( ( F Fn ( A ∪ B ) ∧ B ⊆ ( A ∪ B ) ) → ( F ↾ B ) Fn B ) ;;
	step 32 : wff = syl2anc (step 28, step 30, step 31) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( F ↾ B ) Fn B ) ;;
	step 33 : wff = fnconstg () |- ( Z ∈ V → ( B × { Z } ) Fn B ) ;;
	step 34 : wff = 3ad2ant3 (step 33) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( B × { Z } ) Fn B ) ;;
	step 35 : wff = eqfnfv () |- ( ( ( F ↾ B ) Fn B ∧ ( B × { Z } ) Fn B ) → ( ( F ↾ B ) = ( B × { Z } ) ↔ ∀ a ∈ B ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ) ) ;;
	step 36 : wff = syl2anc (step 32, step 34, step 35) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( ( F ↾ B ) = ( B × { Z } ) ↔ ∀ a ∈ B ( ( F ↾ B ) ` a ) = ( ( B × { Z } ) ` a ) ) ) ;;
	step 37 : wff = 3bitr4d (step 24, step 27, step 36) |- ( ( F Fn ( A ∪ B ) ∧ ( A ∩ B ) = ∅ ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ A ↔ ( F ↾ B ) = ( B × { Z } ) ) ) ;;
	qed prop 1 = step 37 ;;
}

/*The support of a function is empty iff it is identically zero.
       (Contributed by Stefan O'Rear, 22-Mar-2015.) */

theorem fnsuppeq0 (A : class, F : class, V : class, Z : class) disjointed(F, V, A, Z) {
	prop 1 : wff = |- ( ( F Fn A ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) = ∅ ↔ F = ( A × { Z } ) ) ) ;;
}

proof of fnsuppeq0 {
	step 1 : wff = ss0b () |- ( ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ ∅ ↔ ( ⁻¹ F " ( _V ∖ { Z } ) ) = ∅ ) ;;
	step 2 : wff = un0 () |- ( A ∪ ∅ ) = A ;;
	step 3 : wff = uncom () |- ( A ∪ ∅ ) = ( ∅ ∪ A ) ;;
	step 4 : wff = eqtr3i (step 2, step 3) |- A = ( ∅ ∪ A ) ;;
	step 5 : wff = fneq2i (step 4) |- ( F Fn A ↔ F Fn ( ∅ ∪ A ) ) ;;
	step 6 : wff = biimpi (step 5) |- ( F Fn A → F Fn ( ∅ ∪ A ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( F Fn A ∧ Z ∈ V ) → F Fn ( ∅ ∪ A ) ) ;;
	step 8 : wff = incom () |- ( ∅ ∩ A ) = ( A ∩ ∅ ) ;;
	step 9 : wff = in0 () |- ( A ∩ ∅ ) = ∅ ;;
	step 10 : wff = eqtri (step 8, step 9) |- ( ∅ ∩ A ) = ∅ ;;
	step 11 : wff = a1i (step 10) |- ( ( F Fn A ∧ Z ∈ V ) → ( ∅ ∩ A ) = ∅ ) ;;
	step 12 : wff = simpr () |- ( ( F Fn A ∧ Z ∈ V ) → Z ∈ V ) ;;
	step 13 : wff = fnsuppres () |- ( ( F Fn ( ∅ ∪ A ) ∧ ( ∅ ∩ A ) = ∅ ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ ∅ ↔ ( F ↾ A ) = ( A × { Z } ) ) ) ;;
	step 14 : wff = syl3anc (step 7, step 11, step 12, step 13) |- ( ( F Fn A ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) ⊆ ∅ ↔ ( F ↾ A ) = ( A × { Z } ) ) ) ;;
	step 15 : wff = syl5bbr (step 1, step 14) |- ( ( F Fn A ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) = ∅ ↔ ( F ↾ A ) = ( A × { Z } ) ) ) ;;
	step 16 : wff = fnresdm () |- ( F Fn A → ( F ↾ A ) = F ) ;;
	step 17 : wff = adantr (step 16) |- ( ( F Fn A ∧ Z ∈ V ) → ( F ↾ A ) = F ) ;;
	step 18 : wff = eqeq1d (step 17) |- ( ( F Fn A ∧ Z ∈ V ) → ( ( F ↾ A ) = ( A × { Z } ) ↔ F = ( A × { Z } ) ) ) ;;
	step 19 : wff = bitrd (step 15, step 18) |- ( ( F Fn A ∧ Z ∈ V ) → ( ( ⁻¹ F " ( _V ∖ { Z } ) ) = ∅ ↔ F = ( A × { Z } ) ) ) ;;
	qed prop 1 = step 19 ;;
}

/*A constant function expressed in terms of its functionality, domain, and
       value.  See also ~ fconst2 .  (Contributed by NM, 27-Aug-2004.) */

theorem fconstfv (x : set, A : class, B : class, F : class) disjointed(x y z A, x y z B, x y z F) {
	prop 1 : wff = |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) ) ;;
}

proof of fconstfv {
	var y : set, z : set;;
	step 1 : wff = ffn () |- ( F : A ⟶ { B } → F Fn A ) ;;
	step 2 : wff = fvconst () |- ( ( F : A ⟶ { B } ∧ x ∈ A ) → ( F ` x ) = B ) ;;
	step 3 : wff = ralrimiva (step 2) |- ( F : A ⟶ { B } → ∀ x ∈ A ( F ` x ) = B ) ;;
	step 4 : wff = jca (step 1, step 3) |- ( F : A ⟶ { B } → ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) ) ;;
	step 5 : wff = fneq2 () |- ( A = ∅ → ( F Fn A ↔ F Fn ∅ ) ) ;;
	step 6 : wff = fn0 () |- ( F Fn ∅ ↔ F = ∅ ) ;;
	step 7 : wff = syl6bb (step 5, step 6) |- ( A = ∅ → ( F Fn A ↔ F = ∅ ) ) ;;
	step 8 : wff = f0 () |- ∅ : ∅ ⟶ { B } ;;
	step 9 : wff = feq1 () |- ( F = ∅ → ( F : ∅ ⟶ { B } ↔ ∅ : ∅ ⟶ { B } ) ) ;;
	step 10 : wff = mpbiri (step 8, step 9) |- ( F = ∅ → F : ∅ ⟶ { B } ) ;;
	step 11 : wff = syl6bi (step 7, step 10) |- ( A = ∅ → ( F Fn A → F : ∅ ⟶ { B } ) ) ;;
	step 12 : wff = feq2 () |- ( A = ∅ → ( F : A ⟶ { B } ↔ F : ∅ ⟶ { B } ) ) ;;
	step 13 : wff = sylibrd (step 11, step 12) |- ( A = ∅ → ( F Fn A → F : A ⟶ { B } ) ) ;;
	step 14 : wff = adantrd (step 13) |- ( A = ∅ → ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) → F : A ⟶ { B } ) ) ;;
	step 15 : wff = fvelrnb () |- ( F Fn A → ( y ∈ ran F ↔ ∃ z ∈ A ( F ` z ) = y ) ) ;;
	step 16 : wff = fveq2 () |- ( x = z → ( F ` x ) = ( F ` z ) ) ;;
	step 17 : wff = eqeq1d (step 16) |- ( x = z → ( ( F ` x ) = B ↔ ( F ` z ) = B ) ) ;;
	step 18 : wff = rspccva (step 17) |- ( ( ∀ x ∈ A ( F ` x ) = B ∧ z ∈ A ) → ( F ` z ) = B ) ;;
	step 19 : wff = eqeq1d (step 18) |- ( ( ∀ x ∈ A ( F ` x ) = B ∧ z ∈ A ) → ( ( F ` z ) = y ↔ B = y ) ) ;;
	step 20 : wff = rexbidva (step 19) |- ( ∀ x ∈ A ( F ` x ) = B → ( ∃ z ∈ A ( F ` z ) = y ↔ ∃ z ∈ A B = y ) ) ;;
	step 21 : wff = r19.9rzv () |- ( A ≠ ∅ → ( B = y ↔ ∃ z ∈ A B = y ) ) ;;
	step 22 : wff = bicomd (step 21) |- ( A ≠ ∅ → ( ∃ z ∈ A B = y ↔ B = y ) ) ;;
	step 23 : wff = sylan9bbr (step 20, step 22) |- ( ( A ≠ ∅ ∧ ∀ x ∈ A ( F ` x ) = B ) → ( ∃ z ∈ A ( F ` z ) = y ↔ B = y ) ) ;;
	step 24 : wff = sylan9bbr (step 15, step 23) |- ( ( ( A ≠ ∅ ∧ ∀ x ∈ A ( F ` x ) = B ) ∧ F Fn A ) → ( y ∈ ran F ↔ B = y ) ) ;;
	step 25 : wff = elsn () |- ( y ∈ { B } ↔ y = B ) ;;
	step 26 : wff = eqcom () |- ( y = B ↔ B = y ) ;;
	step 27 : wff = bitr2i (step 25, step 26) |- ( B = y ↔ y ∈ { B } ) ;;
	step 28 : wff = syl6bb (step 24, step 27) |- ( ( ( A ≠ ∅ ∧ ∀ x ∈ A ( F ` x ) = B ) ∧ F Fn A ) → ( y ∈ ran F ↔ y ∈ { B } ) ) ;;
	step 29 : wff = eqrdv (step 28) |- ( ( ( A ≠ ∅ ∧ ∀ x ∈ A ( F ` x ) = B ) ∧ F Fn A ) → ran F = { B } ) ;;
	step 30 : wff = an32s (step 29) |- ( ( ( A ≠ ∅ ∧ F Fn A ) ∧ ∀ x ∈ A ( F ` x ) = B ) → ran F = { B } ) ;;
	step 31 : wff = exp31 (step 30) |- ( A ≠ ∅ → ( F Fn A → ( ∀ x ∈ A ( F ` x ) = B → ran F = { B } ) ) ) ;;
	step 32 : wff = imdistand (step 31) |- ( A ≠ ∅ → ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) → ( F Fn A ∧ ran F = { B } ) ) ) ;;
	step 33 : wff = df-fo () |- ( F : A ↠ { B } ↔ ( F Fn A ∧ ran F = { B } ) ) ;;
	step 34 : wff = fof () |- ( F : A ↠ { B } → F : A ⟶ { B } ) ;;
	step 35 : wff = sylbir (step 33, step 34) |- ( ( F Fn A ∧ ran F = { B } ) → F : A ⟶ { B } ) ;;
	step 36 : wff = syl6 (step 32, step 35) |- ( A ≠ ∅ → ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) → F : A ⟶ { B } ) ) ;;
	step 37 : wff = pm2.61ine (step 14, step 36) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) → F : A ⟶ { B } ) ;;
	step 38 : wff = impbii (step 4, step 37) |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) ) ;;
	qed prop 1 = step 38 ;;
}

/*Two ways to express a constant function.  (Contributed by NM,
       15-Mar-2007.) */

theorem fconst3 (A : class, B : class, F : class) disjointed(x A, x B, x F) {
	prop 1 : wff = |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
}

proof of fconst3 {
	var x : set;;
	step 1 : wff = fconstfv () |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) ) ;;
	step 2 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = eqimss2 () |- ( dom F = A → A ⊆ dom F ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( F Fn A → A ⊆ dom F ) ;;
	step 6 : wff = funconstss () |- ( ( Fun F ∧ A ⊆ dom F ) → ( ∀ x ∈ A ( F ` x ) = B ↔ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	step 7 : wff = syl2anc (step 2, step 5, step 6) |- ( F Fn A → ( ∀ x ∈ A ( F ` x ) = B ↔ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	step 8 : wff = pm5.32i (step 7) |- ( ( F Fn A ∧ ∀ x ∈ A ( F ` x ) = B ) ↔ ( F Fn A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Two ways to express a constant function.  (Contributed by NM,
     8-Mar-2007.) */

theorem fconst4 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ ( ⁻¹ F " { B } ) = A ) ) ;;
}

proof of fconst4 {
	step 1 : wff = fconst3 () |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	step 2 : wff = cnvimass () |- ( ⁻¹ F " { B } ) ⊆ dom F ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = syl5sseq (step 2, step 3) |- ( F Fn A → ( ⁻¹ F " { B } ) ⊆ A ) ;;
	step 5 : wff = biantrurd (step 4) |- ( F Fn A → ( A ⊆ ( ⁻¹ F " { B } ) ↔ ( ( ⁻¹ F " { B } ) ⊆ A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ) ) ;;
	step 6 : wff = eqss () |- ( ( ⁻¹ F " { B } ) = A ↔ ( ( ⁻¹ F " { B } ) ⊆ A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ) ;;
	step 7 : wff = syl6bbr (step 5, step 6) |- ( F Fn A → ( A ⊆ ( ⁻¹ F " { B } ) ↔ ( ⁻¹ F " { B } ) = A ) ) ;;
	step 8 : wff = pm5.32i (step 7) |- ( ( F Fn A ∧ A ⊆ ( ⁻¹ F " { B } ) ) ↔ ( F Fn A ∧ ( ⁻¹ F " { B } ) = A ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( F : A ⟶ { B } ↔ ( F Fn A ∧ ( ⁻¹ F " { B } ) = A ) ) ;;
	qed prop 1 = step 9 ;;
}

/*The restriction of a function to a set exists.  Compare Proposition 6.17
       of [TakeutiZaring] p. 28.  (Contributed by NM, 7-Apr-1995.)  (Revised by
       Mario Carneiro, 22-Jun-2013.) */

theorem resfunexg (A : class, B : class, C : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) ∈ _V ) ;;
}

proof of resfunexg {
	var x : set;;
	step 1 : wff = funres () |- ( Fun A → Fun ( A ↾ B ) ) ;;
	step 2 : wff = adantr (step 1) |- ( ( Fun A ∧ B ∈ C ) → Fun ( A ↾ B ) ) ;;
	step 3 : wff = funfn () |- ( Fun ( A ↾ B ) ↔ ( A ↾ B ) Fn dom ( A ↾ B ) ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) Fn dom ( A ↾ B ) ) ;;
	step 5 : wff = dffn5 () |- ( ( A ↾ B ) Fn dom ( A ↾ B ) ↔ ( A ↾ B ) = ( x ∈ dom ( A ↾ B ) ↦ ( ( A ↾ B ) ` x ) ) ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) = ( x ∈ dom ( A ↾ B ) ↦ ( ( A ↾ B ) ` x ) ) ) ;;
	step 7 : wff = fvex () |- ( ( A ↾ B ) ` x ) ∈ _V ;;
	step 8 : wff = fnasrn (step 7) |- ( x ∈ dom ( A ↾ B ) ↦ ( ( A ↾ B ) ` x ) ) = ran ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ;;
	step 9 : wff = syl6eq (step 6, step 8) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) = ran ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ) ;;
	step 10 : wff = opex () |- 〈 x , ( ( A ↾ B ) ` x ) 〉 ∈ _V ;;
	step 11 : wff = eqid () |- ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) = ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ;;
	step 12 : wff = dmmpti (step 10, step 11) |- dom ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) = dom ( A ↾ B ) ;;
	step 13 : wff = imaeq2i (step 12) |- ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ) = ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( A ↾ B ) ) ;;
	step 14 : wff = imadmrn () |- ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ) = ran ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ;;
	step 15 : wff = eqtr3i (step 13, step 14) |- ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( A ↾ B ) ) = ran ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ;;
	step 16 : wff = syl6eqr (step 9, step 15) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) = ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( A ↾ B ) ) ) ;;
	step 17 : wff = funmpt () |- Fun ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ;;
	step 18 : wff = dmresexg () |- ( B ∈ C → dom ( A ↾ B ) ∈ _V ) ;;
	step 19 : wff = adantl (step 18) |- ( ( Fun A ∧ B ∈ C ) → dom ( A ↾ B ) ∈ _V ) ;;
	step 20 : wff = funimaexg () |- ( ( Fun ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) ∧ dom ( A ↾ B ) ∈ _V ) → ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( A ↾ B ) ) ∈ _V ) ;;
	step 21 : wff = sylancr (step 17, step 19, step 20) |- ( ( Fun A ∧ B ∈ C ) → ( ( x ∈ dom ( A ↾ B ) ↦ 〈 x , ( ( A ↾ B ) ` x ) 〉 ) " dom ( A ↾ B ) ) ∈ _V ) ;;
	step 22 : wff = eqeltrd (step 16, step 21) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) ∈ _V ) ;;
	qed prop 1 = step 22 ;;
}

/*The restriction of a function to a set exists.  Compare Proposition 6.17
     of [TakeutiZaring] p. 28.  This version has a shorter proof than
     ~ resfunexg but requires ~ ax-pow .  (Contributed by NM, 7-Apr-1995.)
     (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem resfunexgALT (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) ∈ _V ) ;;
}

proof of resfunexgALT {
	step 1 : wff = dmresexg () |- ( B ∈ C → dom ( A ↾ B ) ∈ _V ) ;;
	step 2 : wff = adantl (step 1) |- ( ( Fun A ∧ B ∈ C ) → dom ( A ↾ B ) ∈ _V ) ;;
	step 3 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 4 : wff = funimaexg () |- ( ( Fun A ∧ B ∈ C ) → ( A " B ) ∈ _V ) ;;
	step 5 : wff = syl5eqelr (step 3, step 4) |- ( ( Fun A ∧ B ∈ C ) → ran ( A ↾ B ) ∈ _V ) ;;
	step 6 : wff = jca (step 2, step 5) |- ( ( Fun A ∧ B ∈ C ) → ( dom ( A ↾ B ) ∈ _V ∧ ran ( A ↾ B ) ∈ _V ) ) ;;
	step 7 : wff = xpexg () |- ( ( dom ( A ↾ B ) ∈ _V ∧ ran ( A ↾ B ) ∈ _V ) → ( dom ( A ↾ B ) × ran ( A ↾ B ) ) ∈ _V ) ;;
	step 8 : wff = relres () |- Rel ( A ↾ B ) ;;
	step 9 : wff = relssdmrn () |- ( Rel ( A ↾ B ) → ( A ↾ B ) ⊆ ( dom ( A ↾ B ) × ran ( A ↾ B ) ) ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- ( A ↾ B ) ⊆ ( dom ( A ↾ B ) × ran ( A ↾ B ) ) ;;
	step 11 : wff = ssexg () |- ( ( ( A ↾ B ) ⊆ ( dom ( A ↾ B ) × ran ( A ↾ B ) ) ∧ ( dom ( A ↾ B ) × ran ( A ↾ B ) ) ∈ _V ) → ( A ↾ B ) ∈ _V ) ;;
	step 12 : wff = mpan (step 10, step 11) |- ( ( dom ( A ↾ B ) × ran ( A ↾ B ) ) ∈ _V → ( A ↾ B ) ∈ _V ) ;;
	step 13 : wff = 3syl (step 6, step 7, step 12) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ B ) ∈ _V ) ;;
	qed prop 1 = step 13 ;;
}

/*Existence of a composition when the first member is a function.
     (Contributed by NM, 8-Oct-2007.) */

theorem cofunexg (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( Fun A ∧ B ∈ C ) → ( A ∘ B ) ∈ _V ) ;;
}

proof of cofunexg {
	step 1 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 2 : wff = relssdmrn () |- ( Rel ( A ∘ B ) → ( A ∘ B ) ⊆ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( A ∘ B ) ⊆ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ;;
	step 4 : wff = dmcoss () |- dom ( A ∘ B ) ⊆ dom B ;;
	step 5 : wff = dmexg () |- ( B ∈ C → dom B ∈ _V ) ;;
	step 6 : wff = ssexg () |- ( ( dom ( A ∘ B ) ⊆ dom B ∧ dom B ∈ _V ) → dom ( A ∘ B ) ∈ _V ) ;;
	step 7 : wff = sylancr (step 4, step 5, step 6) |- ( B ∈ C → dom ( A ∘ B ) ∈ _V ) ;;
	step 8 : wff = adantl (step 7) |- ( ( Fun A ∧ B ∈ C ) → dom ( A ∘ B ) ∈ _V ) ;;
	step 9 : wff = rnco () |- ran ( A ∘ B ) = ran ( A ↾ ran B ) ;;
	step 10 : wff = rnexg () |- ( B ∈ C → ran B ∈ _V ) ;;
	step 11 : wff = resfunexg () |- ( ( Fun A ∧ ran B ∈ _V ) → ( A ↾ ran B ) ∈ _V ) ;;
	step 12 : wff = sylan2 (step 10, step 11) |- ( ( Fun A ∧ B ∈ C ) → ( A ↾ ran B ) ∈ _V ) ;;
	step 13 : wff = rnexg () |- ( ( A ↾ ran B ) ∈ _V → ran ( A ↾ ran B ) ∈ _V ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( ( Fun A ∧ B ∈ C ) → ran ( A ↾ ran B ) ∈ _V ) ;;
	step 15 : wff = syl5eqel (step 9, step 14) |- ( ( Fun A ∧ B ∈ C ) → ran ( A ∘ B ) ∈ _V ) ;;
	step 16 : wff = xpexg () |- ( ( dom ( A ∘ B ) ∈ _V ∧ ran ( A ∘ B ) ∈ _V ) → ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ∈ _V ) ;;
	step 17 : wff = syl2anc (step 8, step 15, step 16) |- ( ( Fun A ∧ B ∈ C ) → ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ∈ _V ) ;;
	step 18 : wff = ssexg () |- ( ( ( A ∘ B ) ⊆ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ∧ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ∈ _V ) → ( A ∘ B ) ∈ _V ) ;;
	step 19 : wff = sylancr (step 3, step 17, step 18) |- ( ( Fun A ∧ B ∈ C ) → ( A ∘ B ) ∈ _V ) ;;
	qed prop 1 = step 19 ;;
}

/*Existence of a composition when the second member is one-to-one.
     (Contributed by NM, 8-Oct-2007.) */

theorem cofunex2g (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ Fun ⁻¹ B ) → ( A ∘ B ) ∈ _V ) ;;
}

proof of cofunex2g {
	step 1 : wff = cnvexg () |- ( A ∈ V → ⁻¹ A ∈ _V ) ;;
	step 2 : wff = cofunexg () |- ( ( Fun ⁻¹ B ∧ ⁻¹ A ∈ _V ) → ( ⁻¹ B ∘ ⁻¹ A ) ∈ _V ) ;;
	step 3 : wff = sylan2 (step 1, step 2) |- ( ( Fun ⁻¹ B ∧ A ∈ V ) → ( ⁻¹ B ∘ ⁻¹ A ) ∈ _V ) ;;
	step 4 : wff = cnvco () |- ⁻¹ ( ⁻¹ B ∘ ⁻¹ A ) = ( ⁻¹ ⁻¹ A ∘ ⁻¹ ⁻¹ B ) ;;
	step 5 : wff = cocnvcnv2 () |- ( ⁻¹ ⁻¹ A ∘ ⁻¹ ⁻¹ B ) = ( ⁻¹ ⁻¹ A ∘ B ) ;;
	step 6 : wff = cocnvcnv1 () |- ( ⁻¹ ⁻¹ A ∘ B ) = ( A ∘ B ) ;;
	step 7 : wff = 3eqtrri (step 4, step 5, step 6) |- ( A ∘ B ) = ⁻¹ ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 8 : wff = cnvexg () |- ( ( ⁻¹ B ∘ ⁻¹ A ) ∈ _V → ⁻¹ ( ⁻¹ B ∘ ⁻¹ A ) ∈ _V ) ;;
	step 9 : wff = syl5eqel (step 7, step 8) |- ( ( ⁻¹ B ∘ ⁻¹ A ) ∈ _V → ( A ∘ B ) ∈ _V ) ;;
	step 10 : wff = syl (step 3, step 9) |- ( ( Fun ⁻¹ B ∧ A ∈ V ) → ( A ∘ B ) ∈ _V ) ;;
	step 11 : wff = ancoms (step 10) |- ( ( A ∈ V ∧ Fun ⁻¹ B ) → ( A ∘ B ) ∈ _V ) ;;
	qed prop 1 = step 11 ;;
}

/*If the domain of a function is a set, the function is a set.  Theorem
     6.16(1) of [TakeutiZaring] p. 28.  This theorem is derived using the Axiom
     of Replacement in the form of ~ resfunexg .  See ~ fnexALT for alternate
     proof.  (Contributed by NM, 14-Aug-1994.)  (Proof shortened by Andrew
     Salmon, 17-Sep-2011.) */

theorem fnex (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ A ∈ B ) → F ∈ _V ) ;;
}

proof of fnex {
	step 1 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 2 : wff = adantr (step 1) |- ( ( F Fn A ∧ A ∈ B ) → Rel F ) ;;
	step 3 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 4 : wff = eleq1a () |- ( A ∈ B → ( dom F = A → dom F ∈ B ) ) ;;
	step 5 : wff = impcom (step 4) |- ( ( dom F = A ∧ A ∈ B ) → dom F ∈ B ) ;;
	step 6 : wff = resfunexg () |- ( ( Fun F ∧ dom F ∈ B ) → ( F ↾ dom F ) ∈ _V ) ;;
	step 7 : wff = sylan2 (step 5, step 6) |- ( ( Fun F ∧ ( dom F = A ∧ A ∈ B ) ) → ( F ↾ dom F ) ∈ _V ) ;;
	step 8 : wff = anassrs (step 7) |- ( ( ( Fun F ∧ dom F = A ) ∧ A ∈ B ) → ( F ↾ dom F ) ∈ _V ) ;;
	step 9 : wff = sylanb (step 3, step 8) |- ( ( F Fn A ∧ A ∈ B ) → ( F ↾ dom F ) ∈ _V ) ;;
	step 10 : wff = resdm () |- ( Rel F → ( F ↾ dom F ) = F ) ;;
	step 11 : wff = eleq1d (step 10) |- ( Rel F → ( ( F ↾ dom F ) ∈ _V ↔ F ∈ _V ) ) ;;
	step 12 : wff = biimpa (step 11) |- ( ( Rel F ∧ ( F ↾ dom F ) ∈ _V ) → F ∈ _V ) ;;
	step 13 : wff = syl2anc (step 2, step 9, step 12) |- ( ( F Fn A ∧ A ∈ B ) → F ∈ _V ) ;;
	qed prop 1 = step 13 ;;
}

/*If the domain of a function is a set, the function is a set.  Theorem
     6.16(1) of [TakeutiZaring] p. 28.  This theorem is derived using the Axiom
     of Replacement in the form of ~ funimaexg .  This version of ~ fnex uses
     ~ ax-pow , whereas ~ fnex does not.  (Contributed by NM, 14-Aug-1994.)
     (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem fnexALT (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ A ∈ B ) → F ∈ _V ) ;;
}

proof of fnexALT {
	step 1 : wff = fnrel () |- ( F Fn A → Rel F ) ;;
	step 2 : wff = relssdmrn () |- ( Rel F → F ⊆ ( dom F × ran F ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F Fn A → F ⊆ ( dom F × ran F ) ) ;;
	step 4 : wff = adantr (step 3) |- ( ( F Fn A ∧ A ∈ B ) → F ⊆ ( dom F × ran F ) ) ;;
	step 5 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 6 : wff = eleq1d (step 5) |- ( F Fn A → ( dom F ∈ B ↔ A ∈ B ) ) ;;
	step 7 : wff = biimpar (step 6) |- ( ( F Fn A ∧ A ∈ B ) → dom F ∈ B ) ;;
	step 8 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 9 : wff = funimaexg () |- ( ( Fun F ∧ A ∈ B ) → ( F " A ) ∈ _V ) ;;
	step 10 : wff = sylan (step 8, step 9) |- ( ( F Fn A ∧ A ∈ B ) → ( F " A ) ∈ _V ) ;;
	step 11 : wff = imadmrn () |- ( F " dom F ) = ran F ;;
	step 12 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 13 : wff = imaeq2d (step 12) |- ( F Fn A → ( F " dom F ) = ( F " A ) ) ;;
	step 14 : wff = syl5eqr (step 11, step 13) |- ( F Fn A → ran F = ( F " A ) ) ;;
	step 15 : wff = eleq1d (step 14) |- ( F Fn A → ( ran F ∈ _V ↔ ( F " A ) ∈ _V ) ) ;;
	step 16 : wff = biimpar (step 15) |- ( ( F Fn A ∧ ( F " A ) ∈ _V ) → ran F ∈ _V ) ;;
	step 17 : wff = syldan (step 10, step 16) |- ( ( F Fn A ∧ A ∈ B ) → ran F ∈ _V ) ;;
	step 18 : wff = xpexg () |- ( ( dom F ∈ B ∧ ran F ∈ _V ) → ( dom F × ran F ) ∈ _V ) ;;
	step 19 : wff = syl2anc (step 7, step 17, step 18) |- ( ( F Fn A ∧ A ∈ B ) → ( dom F × ran F ) ∈ _V ) ;;
	step 20 : wff = ssexg () |- ( ( F ⊆ ( dom F × ran F ) ∧ ( dom F × ran F ) ∈ _V ) → F ∈ _V ) ;;
	step 21 : wff = syl2anc (step 4, step 19, step 20) |- ( ( F Fn A ∧ A ∈ B ) → F ∈ _V ) ;;
	qed prop 1 = step 21 ;;
}

/*If the domain of a function exists, so the function.  Part of Theorem
     4.15(v) of [Monk1] p. 46.  This theorem is derived using the Axiom of
     Replacement in the form of ~ fnex .  (Note:  Any resemblance between
     F.U.N.E.X. and "Have You Any Eggs" is purely a coincidence originated by
     Swedish chefs.)  (Contributed by NM, 11-Nov-1995.) */

theorem funex (B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ dom F ∈ B ) → F ∈ _V ) ;;
}

proof of funex {
	step 1 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 2 : wff = fnex () |- ( ( F Fn dom F ∧ dom F ∈ B ) → F ∈ _V ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( Fun F ∧ dom F ∈ B ) → F ∈ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*Existence of a function expressed as class of ordered pairs.
       (Contributed by NM, 21-Jul-1996.) */

theorem opabex (ph : wff, x : set, y : set, A : class) disjointed(x y A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x ∈ A → ∃* y ph ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ;;
}

proof of opabex {
	step 1 : wff = funopab () |- ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ↔ ∀ x ∃* y ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = moanimv () |- ( ∃* y ( x ∈ A ∧ ph ) ↔ ( x ∈ A → ∃* y ph ) ) ;;
	step 3 : wff = mpbir (hyp 2, step 2) |- ∃* y ( x ∈ A ∧ ph ) ;;
	step 4 : wff = mpgbir (step 1, step 3) |- Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 5 : wff = dmopabss () |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ⊆ A ;;
	step 6 : wff = ssexi (hyp 1, step 5) |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ;;
	step 7 : wff = funex () |- ( ( Fun { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∧ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ) → { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ) ;;
	step 8 : wff = mp2an (step 4, step 6, step 7) |- { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ;;
	qed prop 1 = step 8 ;;
}

/*If the domain of a function given by maps-to notation is a set, the
       function is a set.  (Contributed by FL, 6-Jun-2011.)  (Revised by Mario
       Carneiro, 31-Aug-2015.) */

theorem mptexg (x : set, A : class, B : class, V : class) disjointed(x A, B) {
	prop 1 : wff = |- ( A ∈ V → ( x ∈ A ↦ B ) ∈ _V ) ;;
}

proof of mptexg {
	step 1 : wff = funmpt () |- Fun ( x ∈ A ↦ B ) ;;
	step 2 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 3 : wff = dmmptss (step 2) |- dom ( x ∈ A ↦ B ) ⊆ A ;;
	step 4 : wff = ssexg () |- ( ( dom ( x ∈ A ↦ B ) ⊆ A ∧ A ∈ V ) → dom ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 5 : wff = mpan (step 3, step 4) |- ( A ∈ V → dom ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 6 : wff = funex () |- ( ( Fun ( x ∈ A ↦ B ) ∧ dom ( x ∈ A ↦ B ) ∈ _V ) → ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 7 : wff = sylancr (step 1, step 5, step 6) |- ( A ∈ V → ( x ∈ A ↦ B ) ∈ _V ) ;;
	qed prop 1 = step 7 ;;
}

/*If the domain of a function given by maps-to notation is a set, the
       function is a set.  (Contributed by NM, 22-Apr-2005.)  (Revised by Mario
       Carneiro, 20-Dec-2013.) */

theorem mptex (x : set, A : class, B : class) disjointed(x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A ↦ B ) ∈ _V ;;
}

proof of mptex {
	step 1 : wff = mptexg () |- ( A ∈ _V → ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( x ∈ A ↦ B ) ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*If the domain of a function exists, so does its range.  Part of Theorem
     4.15(v) of [Monk1] p. 46.  This theorem is derived using the Axiom of
     Replacement in the form of ~ funex .  (Contributed by NM, 11-Nov-1995.) */

theorem funrnex (B : class, F : class)  {
	prop 1 : wff = |- ( dom F ∈ B → ( Fun F → ran F ∈ _V ) ) ;;
}

proof of funrnex {
	step 1 : wff = funex () |- ( ( Fun F ∧ dom F ∈ B ) → F ∈ _V ) ;;
	step 2 : wff = ex (step 1) |- ( Fun F → ( dom F ∈ B → F ∈ _V ) ) ;;
	step 3 : wff = rnexg () |- ( F ∈ _V → ran F ∈ _V ) ;;
	step 4 : wff = syl6com (step 2, step 3) |- ( dom F ∈ B → ( Fun F → ran F ∈ _V ) ) ;;
	qed prop 1 = step 4 ;;
}

/*A version of the Axiom of Replacement.  Normally ` ph ` would have free
       variables ` x ` and ` y ` .  Axiom 6 of [Kunen] p. 12.  The Separation
       Scheme ~ ax-sep cannot be derived from this version and must be stated
       as a separate axiom in an axiom system (such as Kunen's) that uses this
       version in place of our ~ ax-rep .  (Contributed by NM, 10-Oct-2003.) */

theorem zfrep6 (ph : wff, x : set, y : set, z : set, w : set) disjointed(ph w, x y z w) {
	prop 1 : wff = |- ( ∀ x ∈ z ∃! y ph → ∃ w ∀ x ∈ z ∃ y ∈ w ph ) ;;
}

proof of zfrep6 {
	step 1 : wff = euex () |- ( ∃! y ph → ∃ y ph ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ x ∈ z ∃! y ph → ∀ x ∈ z ∃ y ph ) ;;
	step 3 : wff = rabid2 () |- ( z = { x ∈ z | ∃ y ph } ↔ ∀ x ∈ z ∃ y ph ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( ∀ x ∈ z ∃! y ph → z = { x ∈ z | ∃ y ph } ) ;;
	step 5 : wff = 19.42v () |- ( ∃ y ( x ∈ z ∧ ph ) ↔ ( x ∈ z ∧ ∃ y ph ) ) ;;
	step 6 : wff = abbii (step 5) |- { x | ∃ y ( x ∈ z ∧ ph ) } = { x | ( x ∈ z ∧ ∃ y ph ) } ;;
	step 7 : wff = dmopab () |- dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = { x | ∃ y ( x ∈ z ∧ ph ) } ;;
	step 8 : wff = df-rab () |- { x ∈ z | ∃ y ph } = { x | ( x ∈ z ∧ ∃ y ph ) } ;;
	step 9 : wff = 3eqtr4i (step 6, step 7, step 8) |- dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = { x ∈ z | ∃ y ph } ;;
	step 10 : wff = syl6reqr (step 4, step 9) |- ( ∀ x ∈ z ∃! y ph → dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = z ) ;;
	step 11 : wff = vex () |- z ∈ _V ;;
	step 12 : wff = syl6eqel (step 10, step 11) |- ( ∀ x ∈ z ∃! y ph → dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∈ _V ) ;;
	step 13 : wff = eumo () |- ( ∃! y ph → ∃* y ph ) ;;
	step 14 : wff = imim2i (step 13) |- ( ( x ∈ z → ∃! y ph ) → ( x ∈ z → ∃* y ph ) ) ;;
	step 15 : wff = moanimv () |- ( ∃* y ( x ∈ z ∧ ph ) ↔ ( x ∈ z → ∃* y ph ) ) ;;
	step 16 : wff = sylibr (step 14, step 15) |- ( ( x ∈ z → ∃! y ph ) → ∃* y ( x ∈ z ∧ ph ) ) ;;
	step 17 : wff = alimi (step 16) |- ( ∀ x ( x ∈ z → ∃! y ph ) → ∀ x ∃* y ( x ∈ z ∧ ph ) ) ;;
	step 18 : wff = df-ral () |- ( ∀ x ∈ z ∃! y ph ↔ ∀ x ( x ∈ z → ∃! y ph ) ) ;;
	step 19 : wff = funopab () |- ( Fun { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ↔ ∀ x ∃* y ( x ∈ z ∧ ph ) ) ;;
	step 20 : wff = 3imtr4i (step 17, step 18, step 19) |- ( ∀ x ∈ z ∃! y ph → Fun { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ) ;;
	step 21 : wff = funrnex () |- ( dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∈ _V → ( Fun { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } → ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∈ _V ) ) ;;
	step 22 : wff = sylc (step 12, step 20, step 21) |- ( ∀ x ∈ z ∃! y ph → ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∈ _V ) ;;
	step 23 : wff = nfra1 () |- F/ x ∀ x ∈ z ∃! y ph ;;
	step 24 : wff = euex () |- ( ∃! y ph → ∃ y ph ) ;;
	step 25 : wff = ralimi (step 24) |- ( ∀ x ∈ z ∃! y ph → ∀ x ∈ z ∃ y ph ) ;;
	step 26 : wff = rabid2 () |- ( z = { x ∈ z | ∃ y ph } ↔ ∀ x ∈ z ∃ y ph ) ;;
	step 27 : wff = sylibr (step 25, step 26) |- ( ∀ x ∈ z ∃! y ph → z = { x ∈ z | ∃ y ph } ) ;;
	step 28 : wff = 19.42v () |- ( ∃ y ( x ∈ z ∧ ph ) ↔ ( x ∈ z ∧ ∃ y ph ) ) ;;
	step 29 : wff = abbii (step 28) |- { x | ∃ y ( x ∈ z ∧ ph ) } = { x | ( x ∈ z ∧ ∃ y ph ) } ;;
	step 30 : wff = dmopab () |- dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = { x | ∃ y ( x ∈ z ∧ ph ) } ;;
	step 31 : wff = df-rab () |- { x ∈ z | ∃ y ph } = { x | ( x ∈ z ∧ ∃ y ph ) } ;;
	step 32 : wff = 3eqtr4i (step 29, step 30, step 31) |- dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = { x ∈ z | ∃ y ph } ;;
	step 33 : wff = syl6reqr (step 27, step 32) |- ( ∀ x ∈ z ∃! y ph → dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = z ) ;;
	step 34 : wff = eleq2d (step 33) |- ( ∀ x ∈ z ∃! y ph → ( x ∈ dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ↔ x ∈ z ) ) ;;
	step 35 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ↔ ( x ∈ z ∧ ph ) ) ;;
	step 36 : wff = vex () |- x ∈ _V ;;
	step 37 : wff = vex () |- y ∈ _V ;;
	step 38 : wff = opelrn (step 36, step 37) |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } → y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ) ;;
	step 39 : wff = sylbir (step 35, step 38) |- ( ( x ∈ z ∧ ph ) → y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ) ;;
	step 40 : wff = ex (step 39) |- ( x ∈ z → ( ph → y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ) ) ;;
	step 41 : wff = impac (step 40) |- ( ( x ∈ z ∧ ph ) → ( y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∧ ph ) ) ;;
	step 42 : wff = eximi (step 41) |- ( ∃ y ( x ∈ z ∧ ph ) → ∃ y ( y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∧ ph ) ) ;;
	step 43 : wff = dmopab () |- dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } = { x | ∃ y ( x ∈ z ∧ ph ) } ;;
	step 44 : wff = abeq2i (step 43) |- ( x ∈ dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ↔ ∃ y ( x ∈ z ∧ ph ) ) ;;
	step 45 : wff = df-rex () |- ( ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph ↔ ∃ y ( y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∧ ph ) ) ;;
	step 46 : wff = 3imtr4i (step 42, step 44, step 45) |- ( x ∈ dom { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } → ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph ) ;;
	step 47 : wff = syl6bir (step 34, step 46) |- ( ∀ x ∈ z ∃! y ph → ( x ∈ z → ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph ) ) ;;
	step 48 : wff = ralrimi (step 23, step 47) |- ( ∀ x ∈ z ∃! y ph → ∀ x ∈ z ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph ) ;;
	step 49 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ;;
	step 50 : wff = nfrn (step 49) |- F/_ x ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ;;
	step 51 : wff = nfeq2 (step 50) |- F/ x w = ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ;;
	step 52 : wff = nfcv () |- F/_ y w ;;
	step 53 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ;;
	step 54 : wff = nfrn (step 53) |- F/_ y ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ;;
	step 55 : wff = rexeqf (step 52, step 54) |- ( w = ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } → ( ∃ y ∈ w ph ↔ ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph ) ) ;;
	step 56 : wff = ralbid (step 51, step 55) |- ( w = ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } → ( ∀ x ∈ z ∃ y ∈ w ph ↔ ∀ x ∈ z ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph ) ) ;;
	step 57 : wff = spcegv (step 56) |- ( ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ∈ _V → ( ∀ x ∈ z ∃ y ∈ ran { 〈 x , y 〉 | ( x ∈ z ∧ ph ) } ph → ∃ w ∀ x ∈ z ∃ y ∈ w ph ) ) ;;
	step 58 : wff = sylc (step 22, step 48, step 57) |- ( ∀ x ∈ z ∃! y ph → ∃ w ∀ x ∈ z ∃ y ∈ w ph ) ;;
	qed prop 1 = step 58 ;;
}

/*If the domain of a mapping is a set, the function is a set.  (Contributed
     by NM, 3-Oct-1999.) */

theorem fex (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ A ∈ C ) → F ∈ _V ) ;;
}

proof of fex {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = fnex () |- ( ( F Fn A ∧ A ∈ C ) → F ∈ _V ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F : A ⟶ B ∧ A ∈ C ) → F ∈ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*If the domain of an onto function exists, so does its codomain.
     (Contributed by NM, 23-Jul-2004.) */

theorem fornex (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A ∈ C → ( F : A ↠ B → B ∈ _V ) ) ;;
}

proof of fornex {
	step 1 : wff = fofun () |- ( F : A ↠ B → Fun F ) ;;
	step 2 : wff = funrnex () |- ( dom F ∈ C → ( Fun F → ran F ∈ _V ) ) ;;
	step 3 : wff = syl5com (step 1, step 2) |- ( F : A ↠ B → ( dom F ∈ C → ran F ∈ _V ) ) ;;
	step 4 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 5 : wff = fdm () |- ( F : A ⟶ B → dom F = A ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( F : A ↠ B → dom F = A ) ;;
	step 7 : wff = eleq1d (step 6) |- ( F : A ↠ B → ( dom F ∈ C ↔ A ∈ C ) ) ;;
	step 8 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 9 : wff = eleq1d (step 8) |- ( F : A ↠ B → ( ran F ∈ _V ↔ B ∈ _V ) ) ;;
	step 10 : wff = 3imtr3d (step 3, step 7, step 9) |- ( F : A ↠ B → ( A ∈ C → B ∈ _V ) ) ;;
	step 11 : wff = com12 (step 10) |- ( A ∈ C → ( F : A ↠ B → B ∈ _V ) ) ;;
	qed prop 1 = step 11 ;;
}

/*If the codomain of a one-to-one function exists, so does its domain.  This
     theorem is equivalent to the Axiom of Replacement ~ ax-rep .  (Contributed
     by NM, 4-Sep-2004.) */

theorem f1dmex (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ B ∈ C ) → A ∈ _V ) ;;
}

proof of f1dmex {
	step 1 : wff = f1f () |- ( F : A ↣ B → F : A ⟶ B ) ;;
	step 2 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ↣ B → ran F ⊆ B ) ;;
	step 4 : wff = ssexg () |- ( ( ran F ⊆ B ∧ B ∈ C ) → ran F ∈ _V ) ;;
	step 5 : wff = sylan (step 3, step 4) |- ( ( F : A ↣ B ∧ B ∈ C ) → ran F ∈ _V ) ;;
	step 6 : wff = ex (step 5) |- ( F : A ↣ B → ( B ∈ C → ran F ∈ _V ) ) ;;
	step 7 : wff = f1cnv () |- ( F : A ↣ B → ⁻¹ F : ran F ⤖ A ) ;;
	step 8 : wff = f1ofo () |- ( ⁻¹ F : ran F ⤖ A → ⁻¹ F : ran F ↠ A ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( F : A ↣ B → ⁻¹ F : ran F ↠ A ) ;;
	step 10 : wff = fornex () |- ( ran F ∈ _V → ( ⁻¹ F : ran F ↠ A → A ∈ _V ) ) ;;
	step 11 : wff = syl5com (step 9, step 10) |- ( F : A ↣ B → ( ran F ∈ _V → A ∈ _V ) ) ;;
	step 12 : wff = syld (step 6, step 11) |- ( F : A ↣ B → ( B ∈ C → A ∈ _V ) ) ;;
	step 13 : wff = imp (step 12) |- ( ( F : A ↣ B ∧ B ∈ C ) → A ∈ _V ) ;;
	qed prop 1 = step 13 ;;
}

/*A function is uniquely determined by its values.  (Contributed by NM,
       31-Aug-2011.) */

theorem eufnfv (x : set, A : class, B : class, f : set) disjointed(f x z A, f z B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ∃! f ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ;;
}

proof of eufnfv {
	var z : set;;
	step 1 : wff = mptex (hyp 1) |- ( x ∈ A ↦ B ) ∈ _V ;;
	step 2 : wff = eqeq2 () |- ( z = ( x ∈ A ↦ B ) → ( f = z ↔ f = ( x ∈ A ↦ B ) ) ) ;;
	step 3 : wff = bibi2d (step 2) |- ( z = ( x ∈ A ↦ B ) → ( ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = z ) ↔ ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = ( x ∈ A ↦ B ) ) ) ) ;;
	step 4 : wff = albidv (step 3) |- ( z = ( x ∈ A ↦ B ) → ( ∀ f ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = z ) ↔ ∀ f ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = ( x ∈ A ↦ B ) ) ) ) ;;
	step 5 : wff = spcev (step 1, step 4) |- ( ∀ f ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = ( x ∈ A ↦ B ) ) → ∃ z ∀ f ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = z ) ) ;;
	step 6 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 7 : wff = fnmpti (hyp 2, step 6) |- ( x ∈ A ↦ B ) Fn A ;;
	step 8 : wff = fneq1 () |- ( f = ( x ∈ A ↦ B ) → ( f Fn A ↔ ( x ∈ A ↦ B ) Fn A ) ) ;;
	step 9 : wff = mpbiri (step 7, step 8) |- ( f = ( x ∈ A ↦ B ) → f Fn A ) ;;
	step 10 : wff = pm4.71ri (step 9) |- ( f = ( x ∈ A ↦ B ) ↔ ( f Fn A ∧ f = ( x ∈ A ↦ B ) ) ) ;;
	step 11 : wff = dffn5 () |- ( f Fn A ↔ f = ( x ∈ A ↦ ( f ` x ) ) ) ;;
	step 12 : wff = eqeq1 () |- ( f = ( x ∈ A ↦ ( f ` x ) ) → ( f = ( x ∈ A ↦ B ) ↔ ( x ∈ A ↦ ( f ` x ) ) = ( x ∈ A ↦ B ) ) ) ;;
	step 13 : wff = sylbi (step 11, step 12) |- ( f Fn A → ( f = ( x ∈ A ↦ B ) ↔ ( x ∈ A ↦ ( f ` x ) ) = ( x ∈ A ↦ B ) ) ) ;;
	step 14 : wff = fvex () |- ( f ` x ) ∈ _V ;;
	step 15 : wff = rgenw (step 14) |- ∀ x ∈ A ( f ` x ) ∈ _V ;;
	step 16 : wff = mpteqb () |- ( ∀ x ∈ A ( f ` x ) ∈ _V → ( ( x ∈ A ↦ ( f ` x ) ) = ( x ∈ A ↦ B ) ↔ ∀ x ∈ A ( f ` x ) = B ) ) ;;
	step 17 : wff = ax-mp (step 15, step 16) |- ( ( x ∈ A ↦ ( f ` x ) ) = ( x ∈ A ↦ B ) ↔ ∀ x ∈ A ( f ` x ) = B ) ;;
	step 18 : wff = syl6bb (step 13, step 17) |- ( f Fn A → ( f = ( x ∈ A ↦ B ) ↔ ∀ x ∈ A ( f ` x ) = B ) ) ;;
	step 19 : wff = pm5.32i (step 18) |- ( ( f Fn A ∧ f = ( x ∈ A ↦ B ) ) ↔ ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ) ;;
	step 20 : wff = bitr2i (step 10, step 19) |- ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = ( x ∈ A ↦ B ) ) ;;
	step 21 : wff = mpg (step 5, step 20) |- ∃ z ∀ f ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = z ) ;;
	step 22 : wff = df-eu () |- ( ∃! f ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ ∃ z ∀ f ( ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ↔ f = z ) ) ;;
	step 23 : wff = mpbir (step 21, step 22) |- ∃! f ( f Fn A ∧ ∀ x ∈ A ( f ` x ) = B ) ;;
	qed prop 1 = step 23 ;;
}

/*A function's value in a preimage belongs to the image.  (Contributed by
     NM, 23-Sep-2003.) */

theorem funfvima (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ B ∈ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ;;
}

proof of funfvima {
	step 1 : wff = dmres () |- dom ( F ↾ A ) = ( A ∩ dom F ) ;;
	step 2 : wff = elin2 (step 1) |- ( B ∈ dom ( F ↾ A ) ↔ ( B ∈ A ∧ B ∈ dom F ) ) ;;
	step 3 : wff = funres () |- ( Fun F → Fun ( F ↾ A ) ) ;;
	step 4 : wff = fvelrn () |- ( ( Fun ( F ↾ A ) ∧ B ∈ dom ( F ↾ A ) ) → ( ( F ↾ A ) ` B ) ∈ ran ( F ↾ A ) ) ;;
	step 5 : wff = sylan (step 3, step 4) |- ( ( Fun F ∧ B ∈ dom ( F ↾ A ) ) → ( ( F ↾ A ) ` B ) ∈ ran ( F ↾ A ) ) ;;
	step 6 : wff = fvres () |- ( B ∈ A → ( ( F ↾ A ) ` B ) = ( F ` B ) ) ;;
	step 7 : wff = eleq1d (step 6) |- ( B ∈ A → ( ( ( F ↾ A ) ` B ) ∈ ran ( F ↾ A ) ↔ ( F ` B ) ∈ ran ( F ↾ A ) ) ) ;;
	step 8 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 9 : wff = eleq2i (step 8) |- ( ( F ` B ) ∈ ( F " A ) ↔ ( F ` B ) ∈ ran ( F ↾ A ) ) ;;
	step 10 : wff = syl6rbbr (step 7, step 9) |- ( B ∈ A → ( ( F ` B ) ∈ ( F " A ) ↔ ( ( F ↾ A ) ` B ) ∈ ran ( F ↾ A ) ) ) ;;
	step 11 : wff = syl5ibrcom (step 5, step 10) |- ( ( Fun F ∧ B ∈ dom ( F ↾ A ) ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ;;
	step 12 : wff = ex (step 11) |- ( Fun F → ( B ∈ dom ( F ↾ A ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 13 : wff = syl5bir (step 2, step 12) |- ( Fun F → ( ( B ∈ A ∧ B ∈ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 14 : wff = exp3a (step 13) |- ( Fun F → ( B ∈ A → ( B ∈ dom F → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ) ;;
	step 15 : wff = com12 (step 14) |- ( B ∈ A → ( Fun F → ( B ∈ dom F → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ) ;;
	step 16 : wff = imp3a (step 15) |- ( B ∈ A → ( ( Fun F ∧ B ∈ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 17 : wff = pm2.43b (step 16) |- ( ( Fun F ∧ B ∈ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ;;
	qed prop 1 = step 17 ;;
}

/*A function's value in an included preimage belongs to the image.
     (Contributed by NM, 3-Feb-1997.) */

theorem funfvima2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( ( Fun F ∧ A ⊆ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ;;
}

proof of funfvima2 {
	step 1 : wff = ssel () |- ( A ⊆ dom F → ( B ∈ A → B ∈ dom F ) ) ;;
	step 2 : wff = funfvima () |- ( ( Fun F ∧ B ∈ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ;;
	step 3 : wff = ex (step 2) |- ( Fun F → ( B ∈ dom F → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 4 : wff = com23 (step 3) |- ( Fun F → ( B ∈ A → ( B ∈ dom F → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 5 : wff = a2d (step 4) |- ( Fun F → ( ( B ∈ A → B ∈ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 6 : wff = syl5 (step 1, step 5) |- ( Fun F → ( A ⊆ dom F → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ) ;;
	step 7 : wff = imp (step 6) |- ( ( Fun F ∧ A ⊆ dom F ) → ( B ∈ A → ( F ` B ) ∈ ( F " A ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A class including a function contains the function's value in the image
       of the singleton of the argument.  (Contributed by NM, 23-Mar-2004.) */

theorem funfvima3 (A : class, F : class, G : class) disjointed(x A, x F, x G) {
	prop 1 : wff = |- ( ( Fun F ∧ F ⊆ G ) → ( A ∈ dom F → ( F ` A ) ∈ ( G " { A } ) ) ) ;;
}

proof of funfvima3 {
	var x : set;;
	step 1 : wff = funfvop () |- ( ( Fun F ∧ A ∈ dom F ) → 〈 A , ( F ` A ) 〉 ∈ F ) ;;
	step 2 : wff = ssel () |- ( F ⊆ G → ( 〈 A , ( F ` A ) 〉 ∈ F → 〈 A , ( F ` A ) 〉 ∈ G ) ) ;;
	step 3 : wff = syl5 (step 1, step 2) |- ( F ⊆ G → ( ( Fun F ∧ A ∈ dom F ) → 〈 A , ( F ` A ) 〉 ∈ G ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( F ⊆ G ∧ ( Fun F ∧ A ∈ dom F ) ) → 〈 A , ( F ` A ) 〉 ∈ G ) ;;
	step 5 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 6 : wff = imaeq2d (step 5) |- ( x = A → ( G " { x } ) = ( G " { A } ) ) ;;
	step 7 : wff = eleq2d (step 6) |- ( x = A → ( ( F ` A ) ∈ ( G " { x } ) ↔ ( F ` A ) ∈ ( G " { A } ) ) ) ;;
	step 8 : wff = opeq1 () |- ( x = A → 〈 x , ( F ` A ) 〉 = 〈 A , ( F ` A ) 〉 ) ;;
	step 9 : wff = eleq1d (step 8) |- ( x = A → ( 〈 x , ( F ` A ) 〉 ∈ G ↔ 〈 A , ( F ` A ) 〉 ∈ G ) ) ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = fvex () |- ( F ` A ) ∈ _V ;;
	step 12 : wff = elimasn (step 10, step 11) |- ( ( F ` A ) ∈ ( G " { x } ) ↔ 〈 x , ( F ` A ) 〉 ∈ G ) ;;
	step 13 : wff = vtoclbg (step 7, step 9, step 12) |- ( A ∈ dom F → ( ( F ` A ) ∈ ( G " { A } ) ↔ 〈 A , ( F ` A ) 〉 ∈ G ) ) ;;
	step 14 : wff = ad2antll (step 13) |- ( ( F ⊆ G ∧ ( Fun F ∧ A ∈ dom F ) ) → ( ( F ` A ) ∈ ( G " { A } ) ↔ 〈 A , ( F ` A ) 〉 ∈ G ) ) ;;
	step 15 : wff = mpbird (step 4, step 14) |- ( ( F ⊆ G ∧ ( Fun F ∧ A ∈ dom F ) ) → ( F ` A ) ∈ ( G " { A } ) ) ;;
	step 16 : wff = exp32 (step 15) |- ( F ⊆ G → ( Fun F → ( A ∈ dom F → ( F ` A ) ∈ ( G " { A } ) ) ) ) ;;
	step 17 : wff = impcom (step 16) |- ( ( Fun F ∧ F ⊆ G ) → ( A ∈ dom F → ( F ` A ) ∈ ( G " { A } ) ) ) ;;
	qed prop 1 = step 17 ;;
}

/*The function value of an operand in a set is contained in the image of
     that set, using the ` Fn ` abbreviation.  (Contributed by Stefan O'Rear,
     10-Mar-2015.) */

theorem fnfvima (A : class, S : class, F : class, X : class)  {
	prop 1 : wff = |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → ( F ` X ) ∈ ( F " S ) ) ;;
}

proof of fnfvima {
	step 1 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 2 : wff = 3ad2ant1 (step 1) |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → Fun F ) ;;
	step 3 : wff = simp2 () |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → S ⊆ A ) ;;
	step 4 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 5 : wff = 3ad2ant1 (step 4) |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → dom F = A ) ;;
	step 6 : wff = sseqtr4d (step 3, step 5) |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → S ⊆ dom F ) ;;
	step 7 : wff = jca (step 2, step 6) |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → ( Fun F ∧ S ⊆ dom F ) ) ;;
	step 8 : wff = simp3 () |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → X ∈ S ) ;;
	step 9 : wff = funfvima2 () |- ( ( Fun F ∧ S ⊆ dom F ) → ( X ∈ S → ( F ` X ) ∈ ( F " S ) ) ) ;;
	step 10 : wff = sylc (step 7, step 8, step 9) |- ( ( F Fn A ∧ S ⊆ A ∧ X ∈ S ) → ( F ` X ) ∈ ( F " S ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Existential quantification under an image in terms of the base set.
       (Contributed by Stefan O'Rear, 21-Jan-2015.) */

theorem rexima (ph : wff, ps : wff, x : set, y : set, A : class, B : class, F : class) disjointed(ph y, ps x, F x y, B x y, A x y) {
	hyp 1 : wff = |- ( x = ( F ` y ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn A ∧ B ⊆ A ) → ( ∃ x ∈ ( F " B ) ph ↔ ∃ y ∈ B ps ) ) ;;
}

proof of rexima {
	step 1 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 2 : wff = a1i (step 1) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ y ∈ B ) → ( F ` y ) ∈ _V ) ;;
	step 3 : wff = fvelimab () |- ( ( F Fn A ∧ B ⊆ A ) → ( x ∈ ( F " B ) ↔ ∃ y ∈ B ( F ` y ) = x ) ) ;;
	step 4 : wff = eqcom () |- ( ( F ` y ) = x ↔ x = ( F ` y ) ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ y ∈ B ( F ` y ) = x ↔ ∃ y ∈ B x = ( F ` y ) ) ;;
	step 6 : wff = syl6bb (step 3, step 5) |- ( ( F Fn A ∧ B ⊆ A ) → ( x ∈ ( F " B ) ↔ ∃ y ∈ B x = ( F ` y ) ) ) ;;
	step 7 : wff = adantl (hyp 1) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ x = ( F ` y ) ) → ( ph ↔ ps ) ) ;;
	step 8 : wff = rexxfr2d (step 2, step 6, step 7) |- ( ( F Fn A ∧ B ⊆ A ) → ( ∃ x ∈ ( F " B ) ph ↔ ∃ y ∈ B ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Universal quantification under an image in terms of the base set.
       (Contributed by Stefan O'Rear, 21-Jan-2015.) */

theorem ralima (ph : wff, ps : wff, x : set, y : set, A : class, B : class, F : class) disjointed(ph y, ps x, F x y, B x y, A x y) {
	hyp 1 : wff = |- ( x = ( F ` y ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn A ∧ B ⊆ A ) → ( ∀ x ∈ ( F " B ) ph ↔ ∀ y ∈ B ps ) ) ;;
}

proof of ralima {
	step 1 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 2 : wff = a1i (step 1) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ y ∈ B ) → ( F ` y ) ∈ _V ) ;;
	step 3 : wff = fvelimab () |- ( ( F Fn A ∧ B ⊆ A ) → ( x ∈ ( F " B ) ↔ ∃ y ∈ B ( F ` y ) = x ) ) ;;
	step 4 : wff = eqcom () |- ( ( F ` y ) = x ↔ x = ( F ` y ) ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ y ∈ B ( F ` y ) = x ↔ ∃ y ∈ B x = ( F ` y ) ) ;;
	step 6 : wff = syl6bb (step 3, step 5) |- ( ( F Fn A ∧ B ⊆ A ) → ( x ∈ ( F " B ) ↔ ∃ y ∈ B x = ( F ` y ) ) ) ;;
	step 7 : wff = adantl (hyp 1) |- ( ( ( F Fn A ∧ B ⊆ A ) ∧ x = ( F ` y ) ) → ( ph ↔ ps ) ) ;;
	step 8 : wff = ralxfr2d (step 2, step 6, step 7) |- ( ( F Fn A ∧ B ⊆ A ) → ( ∀ x ∈ ( F " B ) ph ↔ ∀ y ∈ B ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*TODO:  This is the same as ~ issref (which has a much longer proof).
       Should we replace ~ issref with this one? - NM 9-May-2016.

       Two ways to state a relation is reflexive.  (Adapted from Tarski.)
       (Contributed by FL, 15-Jan-2012.)  (Proof shortened by Mario Carneiro,
       3-Nov-2015.)  (Proof modification is discouraged.) */

theorem idref (x : set, A : class, R : class) disjointed(A x, R x) {
	prop 1 : wff = |- ( ( _I ↾ A ) ⊆ R ↔ ∀ x ∈ A x R x ) ;;
}

proof of idref {
	step 1 : wff = eqid () |- ( x ∈ A ↦ 〈 x , x 〉 ) = ( x ∈ A ↦ 〈 x , x 〉 ) ;;
	step 2 : wff = fmpt (step 1) |- ( ∀ x ∈ A 〈 x , x 〉 ∈ R ↔ ( x ∈ A ↦ 〈 x , x 〉 ) : A ⟶ R ) ;;
	step 3 : wff = opex () |- 〈 x , x 〉 ∈ _V ;;
	step 4 : wff = eqid () |- ( x ∈ A ↦ 〈 x , x 〉 ) = ( x ∈ A ↦ 〈 x , x 〉 ) ;;
	step 5 : wff = fnmpti (step 3, step 4) |- ( x ∈ A ↦ 〈 x , x 〉 ) Fn A ;;
	step 6 : wff = df-f () |- ( ( x ∈ A ↦ 〈 x , x 〉 ) : A ⟶ R ↔ ( ( x ∈ A ↦ 〈 x , x 〉 ) Fn A ∧ ran ( x ∈ A ↦ 〈 x , x 〉 ) ⊆ R ) ) ;;
	step 7 : wff = mpbiran (step 5, step 6) |- ( ( x ∈ A ↦ 〈 x , x 〉 ) : A ⟶ R ↔ ran ( x ∈ A ↦ 〈 x , x 〉 ) ⊆ R ) ;;
	step 8 : wff = bitri (step 2, step 7) |- ( ∀ x ∈ A 〈 x , x 〉 ∈ R ↔ ran ( x ∈ A ↦ 〈 x , x 〉 ) ⊆ R ) ;;
	step 9 : wff = df-br () |- ( x R x ↔ 〈 x , x 〉 ∈ R ) ;;
	step 10 : wff = ralbii (step 9) |- ( ∀ x ∈ A x R x ↔ ∀ x ∈ A 〈 x , x 〉 ∈ R ) ;;
	step 11 : wff = mptresid () |- ( x ∈ A ↦ x ) = ( _I ↾ A ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = fnasrn (step 12) |- ( x ∈ A ↦ x ) = ran ( x ∈ A ↦ 〈 x , x 〉 ) ;;
	step 14 : wff = eqtr3i (step 11, step 13) |- ( _I ↾ A ) = ran ( x ∈ A ↦ 〈 x , x 〉 ) ;;
	step 15 : wff = sseq1i (step 14) |- ( ( _I ↾ A ) ⊆ R ↔ ran ( x ∈ A ↦ 〈 x , x 〉 ) ⊆ R ) ;;
	step 16 : wff = 3bitr4ri (step 8, step 10, step 15) |- ( ( _I ↾ A ) ⊆ R ↔ ∀ x ∈ A x R x ) ;;
	qed prop 1 = step 16 ;;
}

/*Upper bound for the class of values of a class.  (Contributed by NM,
       9-Nov-1995.) */

theorem fvclss (x : set, y : set, F : class) disjointed(x y F) {
	prop 1 : wff = |- { y | ∃ x y = ( F ` x ) } ⊆ ( ran F ∪ { ∅ } ) ;;
}

proof of fvclss {
	step 1 : wff = eqcom () |- ( y = ( F ` x ) ↔ ( F ` x ) = y ) ;;
	step 2 : wff = tz6.12i () |- ( y ≠ ∅ → ( ( F ` x ) = y → x F y ) ) ;;
	step 3 : wff = syl5bi (step 1, step 2) |- ( y ≠ ∅ → ( y = ( F ` x ) → x F y ) ) ;;
	step 4 : wff = eximdv (step 3) |- ( y ≠ ∅ → ( ∃ x y = ( F ` x ) → ∃ x x F y ) ) ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = elrn (step 5) |- ( y ∈ ran F ↔ ∃ x x F y ) ;;
	step 7 : wff = syl6ibr (step 4, step 6) |- ( y ≠ ∅ → ( ∃ x y = ( F ` x ) → y ∈ ran F ) ) ;;
	step 8 : wff = com12 (step 7) |- ( ∃ x y = ( F ` x ) → ( y ≠ ∅ → y ∈ ran F ) ) ;;
	step 9 : wff = necon1bd (step 8) |- ( ∃ x y = ( F ` x ) → ( ¬ y ∈ ran F → y = ∅ ) ) ;;
	step 10 : wff = elsn () |- ( y ∈ { ∅ } ↔ y = ∅ ) ;;
	step 11 : wff = syl6ibr (step 9, step 10) |- ( ∃ x y = ( F ` x ) → ( ¬ y ∈ ran F → y ∈ { ∅ } ) ) ;;
	step 12 : wff = orrd (step 11) |- ( ∃ x y = ( F ` x ) → ( y ∈ ran F ∨ y ∈ { ∅ } ) ) ;;
	step 13 : wff = ss2abi (step 12) |- { y | ∃ x y = ( F ` x ) } ⊆ { y | ( y ∈ ran F ∨ y ∈ { ∅ } ) } ;;
	step 14 : wff = df-un () |- ( ran F ∪ { ∅ } ) = { y | ( y ∈ ran F ∨ y ∈ { ∅ } ) } ;;
	step 15 : wff = sseqtr4i (step 13, step 14) |- { y | ∃ x y = ( F ` x ) } ⊆ ( ran F ∪ { ∅ } ) ;;
	qed prop 1 = step 15 ;;
}

/*Existence of the class of values of a set.  (Contributed by NM,
       9-Nov-1995.) */

theorem fvclex (x : set, y : set, F : class) disjointed(x y F) {
	hyp 1 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { y | ∃ x y = ( F ` x ) } ∈ _V ;;
}

proof of fvclex {
	step 1 : wff = rnex (hyp 1) |- ran F ∈ _V ;;
	step 2 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 3 : wff = unex (step 1, step 2) |- ( ran F ∪ { ∅ } ) ∈ _V ;;
	step 4 : wff = fvclss () |- { y | ∃ x y = ( F ` x ) } ⊆ ( ran F ∪ { ∅ } ) ;;
	step 5 : wff = ssexi (step 3, step 4) |- { y | ∃ x y = ( F ` x ) } ∈ _V ;;
	qed prop 1 = step 5 ;;
}

/*Existence of the class of values of a restricted class.  (Contributed by
       NM, 14-Nov-1995.)  (Revised by Mario Carneiro, 11-Sep-2015.) */

theorem fvresex (x : set, y : set, A : class, F : class) disjointed(x y z A, x y z F) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { y | ∃ x y = ( ( F ↾ A ) ` x ) } ∈ _V ;;
}

proof of fvresex {
	var z : set;;
	step 1 : wff = ssv () |- A ⊆ _V ;;
	step 2 : wff = resmpt () |- ( A ⊆ _V → ( ( z ∈ _V ↦ ( F ` z ) ) ↾ A ) = ( z ∈ A ↦ ( F ` z ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( ( z ∈ _V ↦ ( F ` z ) ) ↾ A ) = ( z ∈ A ↦ ( F ` z ) ) ;;
	step 4 : wff = fveq1i (step 3) |- ( ( ( z ∈ _V ↦ ( F ` z ) ) ↾ A ) ` x ) = ( ( z ∈ A ↦ ( F ` z ) ) ` x ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 7 : wff = eqid () |- ( z ∈ _V ↦ ( F ` z ) ) = ( z ∈ _V ↦ ( F ` z ) ) ;;
	step 8 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 9 : wff = fvmpt (step 6, step 7, step 8) |- ( x ∈ _V → ( ( z ∈ _V ↦ ( F ` z ) ) ` x ) = ( F ` x ) ) ;;
	step 10 : wff = ax-mp (step 5, step 9) |- ( ( z ∈ _V ↦ ( F ` z ) ) ` x ) = ( F ` x ) ;;
	step 11 : wff = fveqres () |- ( ( ( z ∈ _V ↦ ( F ` z ) ) ` x ) = ( F ` x ) → ( ( ( z ∈ _V ↦ ( F ` z ) ) ↾ A ) ` x ) = ( ( F ↾ A ) ` x ) ) ;;
	step 12 : wff = ax-mp (step 10, step 11) |- ( ( ( z ∈ _V ↦ ( F ` z ) ) ↾ A ) ` x ) = ( ( F ↾ A ) ` x ) ;;
	step 13 : wff = eqtr3i (step 4, step 12) |- ( ( z ∈ A ↦ ( F ` z ) ) ` x ) = ( ( F ↾ A ) ` x ) ;;
	step 14 : wff = eqeq2i (step 13) |- ( y = ( ( z ∈ A ↦ ( F ` z ) ) ` x ) ↔ y = ( ( F ↾ A ) ` x ) ) ;;
	step 15 : wff = exbii (step 14) |- ( ∃ x y = ( ( z ∈ A ↦ ( F ` z ) ) ` x ) ↔ ∃ x y = ( ( F ↾ A ) ` x ) ) ;;
	step 16 : wff = abbii (step 15) |- { y | ∃ x y = ( ( z ∈ A ↦ ( F ` z ) ) ` x ) } = { y | ∃ x y = ( ( F ↾ A ) ` x ) } ;;
	step 17 : wff = mptex (hyp 1) |- ( z ∈ A ↦ ( F ` z ) ) ∈ _V ;;
	step 18 : wff = fvclex (step 17) |- { y | ∃ x y = ( ( z ∈ A ↦ ( F ` z ) ) ` x ) } ∈ _V ;;
	step 19 : wff = eqeltrri (step 16, step 18) |- { y | ∃ x y = ( ( F ↾ A ) ` x ) } ∈ _V ;;
	qed prop 1 = step 19 ;;
}

/*Existence of a class abstraction of existentially restricted sets. ` x `
       is normally a free-variable parameter in the class expression
       substituted for ` B ` , which can be thought of as ` B ( x ) ` .  This
       simple-looking theorem is actually quite powerful and appears to involve
       the Axiom of Replacement in an intrinsic way, as can be seen by tracing
       back through the path ~ mptexg , ~ funex , ~ fnex , ~ resfunexg , and
       ~ funimaexg .  See also ~ abrexex2 .  (Contributed by NM, 16-Oct-2003.)
       (Proof shortened by Mario Carneiro, 31-Aug-2015.) */

theorem abrexex (x : set, y : set, A : class, B : class) disjointed(x y A, y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { y | ∃ x ∈ A y = B } ∈ _V ;;
}

proof of abrexex {
	step 1 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 2 : wff = rnmpt (step 1) |- ran ( x ∈ A ↦ B ) = { y | ∃ x ∈ A y = B } ;;
	step 3 : wff = mptex (hyp 1) |- ( x ∈ A ↦ B ) ∈ _V ;;
	step 4 : wff = rnex (step 3) |- ran ( x ∈ A ↦ B ) ∈ _V ;;
	step 5 : wff = eqeltrri (step 2, step 4) |- { y | ∃ x ∈ A y = B } ∈ _V ;;
	qed prop 1 = step 5 ;;
}

/*Existence of a class abstraction of existentially restricted sets. ` x `
       is normally a free-variable parameter in ` B ` .  The antecedent assures
       us that ` A ` is a set.  (Contributed by NM, 3-Nov-2003.) */

theorem abrexexg (x : set, y : set, A : class, B : class, V : class) disjointed(x y A, y B) {
	prop 1 : wff = |- ( A ∈ V → { y | ∃ x ∈ A y = B } ∈ _V ) ;;
}

proof of abrexexg {
	step 1 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 2 : wff = rnmpt (step 1) |- ran ( x ∈ A ↦ B ) = { y | ∃ x ∈ A y = B } ;;
	step 3 : wff = mptexg () |- ( A ∈ V → ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 4 : wff = rnexg () |- ( ( x ∈ A ↦ B ) ∈ _V → ran ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( A ∈ V → ran ( x ∈ A ↦ B ) ∈ _V ) ;;
	step 6 : wff = syl5eqelr (step 2, step 5) |- ( A ∈ V → { y | ∃ x ∈ A y = B } ∈ _V ) ;;
	qed prop 1 = step 6 ;;
}

/*Elementhood in an image set.  (Contributed by Mario Carneiro,
       14-Jan-2014.) */

theorem elabrex (x : set, y : set, A : class, B : class) disjointed(y z B, x y z A) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A → B ∈ { y | ∃ x ∈ A y = B } ) ;;
}

proof of elabrex {
	var z : set;;
	step 1 : wff = tru () |- T. ;;
	step 2 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 3 : wff = eqcoms (step 2) |- ( z = x → B = [_ z / x ]_ B ) ;;
	step 4 : wff = a1tru () |- ( z = x → T. ) ;;
	step 5 : wff = 2thd (step 3, step 4) |- ( z = x → ( B = [_ z / x ]_ B ↔ T. ) ) ;;
	step 6 : wff = rspcev (step 5) |- ( ( x ∈ A ∧ T. ) → ∃ z ∈ A B = [_ z / x ]_ B ) ;;
	step 7 : wff = mpan2 (step 1, step 6) |- ( x ∈ A → ∃ z ∈ A B = [_ z / x ]_ B ) ;;
	step 8 : wff = eqeq1 () |- ( y = B → ( y = [_ z / x ]_ B ↔ B = [_ z / x ]_ B ) ) ;;
	step 9 : wff = rexbidv (step 8) |- ( y = B → ( ∃ z ∈ A y = [_ z / x ]_ B ↔ ∃ z ∈ A B = [_ z / x ]_ B ) ) ;;
	step 10 : wff = elab (hyp 1, step 9) |- ( B ∈ { y | ∃ z ∈ A y = [_ z / x ]_ B } ↔ ∃ z ∈ A B = [_ z / x ]_ B ) ;;
	step 11 : wff = sylibr (step 7, step 10) |- ( x ∈ A → B ∈ { y | ∃ z ∈ A y = [_ z / x ]_ B } ) ;;
	step 12 : wff = nfv () |- F/ z y = B ;;
	step 13 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ B ;;
	step 14 : wff = nfeq2 (step 13) |- F/ x y = [_ z / x ]_ B ;;
	step 15 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 16 : wff = eqeq2d (step 15) |- ( x = z → ( y = B ↔ y = [_ z / x ]_ B ) ) ;;
	step 17 : wff = cbvrex (step 12, step 14, step 16) |- ( ∃ x ∈ A y = B ↔ ∃ z ∈ A y = [_ z / x ]_ B ) ;;
	step 18 : wff = abbii (step 17) |- { y | ∃ x ∈ A y = B } = { y | ∃ z ∈ A y = [_ z / x ]_ B } ;;
	step 19 : wff = syl6eleqr (step 11, step 18) |- ( x ∈ A → B ∈ { y | ∃ x ∈ A y = B } ) ;;
	qed prop 1 = step 19 ;;
}

/*Composition of two image maps ` C ( y ) ` and ` B ( w ) ` .
       (Contributed by NM, 27-May-2013.) */

theorem abrexco (x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class) disjointed(A y z, B y z, C w, D y, w x y, w z y) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- ( y = B → C = D ) ;;
	-----------------------
	prop 1 : wff = |- { x | ∃ y ∈ { z | ∃ w ∈ A z = B } x = C } = { x | ∃ w ∈ A x = D } ;;
}

proof of abrexco {
	step 1 : wff = df-rex () |- ( ∃ y ∈ { z | ∃ w ∈ A z = B } x = C ↔ ∃ y ( y ∈ { z | ∃ w ∈ A z = B } ∧ x = C ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = eqeq1 () |- ( z = y → ( z = B ↔ y = B ) ) ;;
	step 4 : wff = rexbidv (step 3) |- ( z = y → ( ∃ w ∈ A z = B ↔ ∃ w ∈ A y = B ) ) ;;
	step 5 : wff = elab (step 2, step 4) |- ( y ∈ { z | ∃ w ∈ A z = B } ↔ ∃ w ∈ A y = B ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( y ∈ { z | ∃ w ∈ A z = B } ∧ x = C ) ↔ ( ∃ w ∈ A y = B ∧ x = C ) ) ;;
	step 7 : wff = r19.41v () |- ( ∃ w ∈ A ( y = B ∧ x = C ) ↔ ( ∃ w ∈ A y = B ∧ x = C ) ) ;;
	step 8 : wff = bitr4i (step 6, step 7) |- ( ( y ∈ { z | ∃ w ∈ A z = B } ∧ x = C ) ↔ ∃ w ∈ A ( y = B ∧ x = C ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ y ( y ∈ { z | ∃ w ∈ A z = B } ∧ x = C ) ↔ ∃ y ∃ w ∈ A ( y = B ∧ x = C ) ) ;;
	step 10 : wff = bitri (step 1, step 9) |- ( ∃ y ∈ { z | ∃ w ∈ A z = B } x = C ↔ ∃ y ∃ w ∈ A ( y = B ∧ x = C ) ) ;;
	step 11 : wff = rexcom4 () |- ( ∃ w ∈ A ∃ y ( y = B ∧ x = C ) ↔ ∃ y ∃ w ∈ A ( y = B ∧ x = C ) ) ;;
	step 12 : wff = bitr4i (step 10, step 11) |- ( ∃ y ∈ { z | ∃ w ∈ A z = B } x = C ↔ ∃ w ∈ A ∃ y ( y = B ∧ x = C ) ) ;;
	step 13 : wff = eqeq2d (hyp 2) |- ( y = B → ( x = C ↔ x = D ) ) ;;
	step 14 : wff = ceqsexv (hyp 1, step 13) |- ( ∃ y ( y = B ∧ x = C ) ↔ x = D ) ;;
	step 15 : wff = rexbii (step 14) |- ( ∃ w ∈ A ∃ y ( y = B ∧ x = C ) ↔ ∃ w ∈ A x = D ) ;;
	step 16 : wff = bitri (step 12, step 15) |- ( ∃ y ∈ { z | ∃ w ∈ A z = B } x = C ↔ ∃ w ∈ A x = D ) ;;
	step 17 : wff = abbii (step 16) |- { x | ∃ y ∈ { z | ∃ w ∈ A z = B } x = C } = { x | ∃ w ∈ A x = D } ;;
	qed prop 1 = step 17 ;;
}

/*The existence of an indexed union. ` x ` is normally a free-variable
       parameter in ` B ` .  (Contributed by NM, 23-Mar-2006.) */

theorem iunexg (x : set, A : class, B : class, V : class, W : class) disjointed(x y A, y B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ ∀ x ∈ A B ∈ W ) → ⋃_ x ∈ A B ∈ _V ) ;;
}

proof of iunexg {
	var y : set;;
	step 1 : wff = dfiun2g () |- ( ∀ x ∈ A B ∈ W → ⋃_ x ∈ A B = ⋃ { y | ∃ x ∈ A y = B } ) ;;
	step 2 : wff = adantl (step 1) |- ( ( A ∈ V ∧ ∀ x ∈ A B ∈ W ) → ⋃_ x ∈ A B = ⋃ { y | ∃ x ∈ A y = B } ) ;;
	step 3 : wff = abrexexg () |- ( A ∈ V → { y | ∃ x ∈ A y = B } ∈ _V ) ;;
	step 4 : wff = uniexg () |- ( { y | ∃ x ∈ A y = B } ∈ _V → ⋃ { y | ∃ x ∈ A y = B } ∈ _V ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( A ∈ V → ⋃ { y | ∃ x ∈ A y = B } ∈ _V ) ;;
	step 6 : wff = adantr (step 5) |- ( ( A ∈ V ∧ ∀ x ∈ A B ∈ W ) → ⋃ { y | ∃ x ∈ A y = B } ∈ _V ) ;;
	step 7 : wff = eqeltrd (step 2, step 6) |- ( ( A ∈ V ∧ ∀ x ∈ A B ∈ W ) → ⋃_ x ∈ A B ∈ _V ) ;;
	qed prop 1 = step 7 ;;
}

/*Existence of an existentially restricted class abstraction.
       (Contributed by Jeff Madsen, 2-Sep-2009.) */

theorem abrexex2g (ph : wff, x : set, y : set, A : class, V : class, W : class) disjointed(A x y z, V x y z, W x y z, ph z) {
	prop 1 : wff = |- ( ( A ∈ V ∧ ∀ x ∈ A { y | ph } ∈ W ) → { y | ∃ x ∈ A ph } ∈ _V ) ;;
}

proof of abrexex2g {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ∃ x ∈ A ph ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = nfs1v () |- F/ y [ z / y ] ph ;;
	step 4 : wff = nfrex (step 2, step 3) |- F/ y ∃ x ∈ A [ z / y ] ph ;;
	step 5 : wff = sbequ12 () |- ( y = z → ( ph ↔ [ z / y ] ph ) ) ;;
	step 6 : wff = rexbidv (step 5) |- ( y = z → ( ∃ x ∈ A ph ↔ ∃ x ∈ A [ z / y ] ph ) ) ;;
	step 7 : wff = cbvab (step 1, step 4, step 6) |- { y | ∃ x ∈ A ph } = { z | ∃ x ∈ A [ z / y ] ph } ;;
	step 8 : wff = df-clab () |- ( z ∈ { y | ph } ↔ [ z / y ] ph ) ;;
	step 9 : wff = rexbii (step 8) |- ( ∃ x ∈ A z ∈ { y | ph } ↔ ∃ x ∈ A [ z / y ] ph ) ;;
	step 10 : wff = abbii (step 9) |- { z | ∃ x ∈ A z ∈ { y | ph } } = { z | ∃ x ∈ A [ z / y ] ph } ;;
	step 11 : wff = eqtr4i (step 7, step 10) |- { y | ∃ x ∈ A ph } = { z | ∃ x ∈ A z ∈ { y | ph } } ;;
	step 12 : wff = df-iun () |- ⋃_ x ∈ A { y | ph } = { z | ∃ x ∈ A z ∈ { y | ph } } ;;
	step 13 : wff = iunexg () |- ( ( A ∈ V ∧ ∀ x ∈ A { y | ph } ∈ W ) → ⋃_ x ∈ A { y | ph } ∈ _V ) ;;
	step 14 : wff = syl5eqelr (step 12, step 13) |- ( ( A ∈ V ∧ ∀ x ∈ A { y | ph } ∈ W ) → { z | ∃ x ∈ A z ∈ { y | ph } } ∈ _V ) ;;
	step 15 : wff = syl5eqel (step 11, step 14) |- ( ( A ∈ V ∧ ∀ x ∈ A { y | ph } ∈ W ) → { y | ∃ x ∈ A ph } ∈ _V ) ;;
	qed prop 1 = step 15 ;;
}

/*Existence of an ordered pair abstraction.  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem opabex3 (ph : wff, x : set, y : set, A : class) disjointed(A x y v w z, ph v w z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x ∈ A → { y | ph } ∈ _V ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ;;
}

proof of opabex3 {
	var z : set, w : set, v : set;;
	step 1 : wff = 19.42v () |- ( ∃ y ( x ∈ A ∧ ( z = 〈 x , y 〉 ∧ ph ) ) ↔ ( x ∈ A ∧ ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 2 : wff = an12 () |- ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ ph ) ) ↔ ( x ∈ A ∧ ( z = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ ph ) ) ↔ ∃ y ( x ∈ A ∧ ( z = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 4 : wff = elxp () |- ( z ∈ ( { x } × { y | ph } ) ↔ ∃ v ∃ w ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ) ;;
	step 5 : wff = excom () |- ( ∃ v ∃ w ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ∃ w ∃ v ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ) ;;
	step 6 : wff = an12 () |- ( ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ( v ∈ { x } ∧ ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ) ) ;;
	step 7 : wff = elsn () |- ( v ∈ { x } ↔ v = x ) ;;
	step 8 : wff = anbi1i (step 7) |- ( ( v ∈ { x } ∧ ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ) ↔ ( v = x ∧ ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ) ) ;;
	step 9 : wff = bitri (step 6, step 8) |- ( ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ( v = x ∧ ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ) ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ v ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ∃ v ( v = x ∧ ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ) ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = opeq1 () |- ( v = x → 〈 v , w 〉 = 〈 x , w 〉 ) ;;
	step 13 : wff = eqeq2d (step 12) |- ( v = x → ( z = 〈 v , w 〉 ↔ z = 〈 x , w 〉 ) ) ;;
	step 14 : wff = anbi1d (step 13) |- ( v = x → ( ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ↔ ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ) ) ;;
	step 15 : wff = ceqsexv (step 11, step 14) |- ( ∃ v ( v = x ∧ ( z = 〈 v , w 〉 ∧ w ∈ { y | ph } ) ) ↔ ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ) ;;
	step 16 : wff = bitri (step 10, step 15) |- ( ∃ v ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ) ;;
	step 17 : wff = exbii (step 16) |- ( ∃ w ∃ v ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ∃ w ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ) ;;
	step 18 : wff = bitri (step 5, step 17) |- ( ∃ v ∃ w ( z = 〈 v , w 〉 ∧ ( v ∈ { x } ∧ w ∈ { y | ph } ) ) ↔ ∃ w ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ) ;;
	step 19 : wff = nfv () |- F/ y z = 〈 x , w 〉 ;;
	step 20 : wff = nfsab1 () |- F/ y w ∈ { y | ph } ;;
	step 21 : wff = nfan (step 19, step 20) |- F/ y ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ;;
	step 22 : wff = nfv () |- F/ w ( z = 〈 x , y 〉 ∧ ph ) ;;
	step 23 : wff = opeq2 () |- ( w = y → 〈 x , w 〉 = 〈 x , y 〉 ) ;;
	step 24 : wff = eqeq2d (step 23) |- ( w = y → ( z = 〈 x , w 〉 ↔ z = 〈 x , y 〉 ) ) ;;
	step 25 : wff = sbequ12 () |- ( y = w → ( ph ↔ [ w / y ] ph ) ) ;;
	step 26 : wff = eqcoms (step 25) |- ( w = y → ( ph ↔ [ w / y ] ph ) ) ;;
	step 27 : wff = df-clab () |- ( w ∈ { y | ph } ↔ [ w / y ] ph ) ;;
	step 28 : wff = syl6rbbr (step 26, step 27) |- ( w = y → ( w ∈ { y | ph } ↔ ph ) ) ;;
	step 29 : wff = anbi12d (step 24, step 28) |- ( w = y → ( ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ↔ ( z = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 30 : wff = cbvex (step 21, step 22, step 29) |- ( ∃ w ( z = 〈 x , w 〉 ∧ w ∈ { y | ph } ) ↔ ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 31 : wff = 3bitri (step 4, step 18, step 30) |- ( z ∈ ( { x } × { y | ph } ) ↔ ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 32 : wff = anbi2i (step 31) |- ( ( x ∈ A ∧ z ∈ ( { x } × { y | ph } ) ) ↔ ( x ∈ A ∧ ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 33 : wff = 3bitr4ri (step 1, step 3, step 32) |- ( ( x ∈ A ∧ z ∈ ( { x } × { y | ph } ) ) ↔ ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 34 : wff = exbii (step 33) |- ( ∃ x ( x ∈ A ∧ z ∈ ( { x } × { y | ph } ) ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 35 : wff = eliun () |- ( z ∈ ⋃_ x ∈ A ( { x } × { y | ph } ) ↔ ∃ x ∈ A z ∈ ( { x } × { y | ph } ) ) ;;
	step 36 : wff = df-rex () |- ( ∃ x ∈ A z ∈ ( { x } × { y | ph } ) ↔ ∃ x ( x ∈ A ∧ z ∈ ( { x } × { y | ph } ) ) ) ;;
	step 37 : wff = bitri (step 35, step 36) |- ( z ∈ ⋃_ x ∈ A ( { x } × { y | ph } ) ↔ ∃ x ( x ∈ A ∧ z ∈ ( { x } × { y | ph } ) ) ) ;;
	step 38 : wff = elopab () |- ( z ∈ { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 39 : wff = 3bitr4i (step 34, step 37, step 38) |- ( z ∈ ⋃_ x ∈ A ( { x } × { y | ph } ) ↔ z ∈ { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ) ;;
	step 40 : wff = eqriv (step 39) |- ⋃_ x ∈ A ( { x } × { y | ph } ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 41 : wff = snex () |- { x } ∈ _V ;;
	step 42 : wff = xpexg () |- ( ( { x } ∈ _V ∧ { y | ph } ∈ _V ) → ( { x } × { y | ph } ) ∈ _V ) ;;
	step 43 : wff = sylancr (step 41, hyp 2, step 42) |- ( x ∈ A → ( { x } × { y | ph } ) ∈ _V ) ;;
	step 44 : wff = rgen (step 43) |- ∀ x ∈ A ( { x } × { y | ph } ) ∈ _V ;;
	step 45 : wff = iunexg () |- ( ( A ∈ _V ∧ ∀ x ∈ A ( { x } × { y | ph } ) ∈ _V ) → ⋃_ x ∈ A ( { x } × { y | ph } ) ∈ _V ) ;;
	step 46 : wff = mp2an (hyp 1, step 44, step 45) |- ⋃_ x ∈ A ( { x } × { y | ph } ) ∈ _V ;;
	step 47 : wff = eqeltrri (step 40, step 46) |- { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ∈ _V ;;
	qed prop 1 = step 47 ;;
}

/*The existence of an indexed union. ` x ` is normally a free-variable
       parameter in the class expression substituted for ` B ` , which can be
       read informally as ` B ( x ) ` .  (Contributed by NM, 13-Oct-2003.) */

theorem iunex (x : set, A : class, B : class) disjointed(x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋃_ x ∈ A B ∈ _V ;;
}

proof of iunex {
	step 1 : wff = rgenw (hyp 2) |- ∀ x ∈ A B ∈ _V ;;
	step 2 : wff = iunexg () |- ( ( A ∈ _V ∧ ∀ x ∈ A B ∈ _V ) → ⋃_ x ∈ A B ∈ _V ) ;;
	step 3 : wff = mp2an (hyp 1, step 1, step 2) |- ⋃_ x ∈ A B ∈ _V ;;
	qed prop 1 = step 3 ;;
}

/*The image of an indexed union is the indexed union of the images.
       (Contributed by Mario Carneiro, 18-Jun-2014.) */

theorem imaiun (x : set, A : class, B : class, C : class) disjointed(x y z A, y z B, y z C) {
	prop 1 : wff = |- ( A " ⋃_ x ∈ B C ) = ⋃_ x ∈ B ( A " C ) ;;
}

proof of imaiun {
	var y : set, z : set;;
	step 1 : wff = rexcom4 () |- ( ∃ x ∈ B ∃ z ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ↔ ∃ z ∃ x ∈ B ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = elima3 (step 2) |- ( y ∈ ( A " C ) ↔ ∃ z ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 4 : wff = rexbii (step 3) |- ( ∃ x ∈ B y ∈ ( A " C ) ↔ ∃ x ∈ B ∃ z ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 5 : wff = eliun () |- ( z ∈ ⋃_ x ∈ B C ↔ ∃ x ∈ B z ∈ C ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( z ∈ ⋃_ x ∈ B C ∧ 〈 z , y 〉 ∈ A ) ↔ ( ∃ x ∈ B z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 7 : wff = r19.41v () |- ( ∃ x ∈ B ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ↔ ( ∃ x ∈ B z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 8 : wff = bitr4i (step 6, step 7) |- ( ( z ∈ ⋃_ x ∈ B C ∧ 〈 z , y 〉 ∈ A ) ↔ ∃ x ∈ B ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ z ( z ∈ ⋃_ x ∈ B C ∧ 〈 z , y 〉 ∈ A ) ↔ ∃ z ∃ x ∈ B ( z ∈ C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 10 : wff = 3bitr4ri (step 1, step 4, step 9) |- ( ∃ z ( z ∈ ⋃_ x ∈ B C ∧ 〈 z , y 〉 ∈ A ) ↔ ∃ x ∈ B y ∈ ( A " C ) ) ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = elima3 (step 11) |- ( y ∈ ( A " ⋃_ x ∈ B C ) ↔ ∃ z ( z ∈ ⋃_ x ∈ B C ∧ 〈 z , y 〉 ∈ A ) ) ;;
	step 13 : wff = eliun () |- ( y ∈ ⋃_ x ∈ B ( A " C ) ↔ ∃ x ∈ B y ∈ ( A " C ) ) ;;
	step 14 : wff = 3bitr4i (step 10, step 12, step 13) |- ( y ∈ ( A " ⋃_ x ∈ B C ) ↔ y ∈ ⋃_ x ∈ B ( A " C ) ) ;;
	step 15 : wff = eqriv (step 14) |- ( A " ⋃_ x ∈ B C ) = ⋃_ x ∈ B ( A " C ) ;;
	qed prop 1 = step 15 ;;
}

/*The image of a union is the indexed union of the images.  Theorem 3K(a)
       of [Enderton] p. 50.  (Contributed by NM, 9-Aug-2004.)  (Proof shortened
       by Mario Carneiro, 18-Jun-2014.) */

theorem imauni (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A " ⋃ B ) = ⋃_ x ∈ B ( A " x ) ;;
}

proof of imauni {
	step 1 : wff = uniiun () |- ⋃ B = ⋃_ x ∈ B x ;;
	step 2 : wff = imaeq2i (step 1) |- ( A " ⋃ B ) = ( A " ⋃_ x ∈ B x ) ;;
	step 3 : wff = imaiun () |- ( A " ⋃_ x ∈ B x ) = ⋃_ x ∈ B ( A " x ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- ( A " ⋃ B ) = ⋃_ x ∈ B ( A " x ) ;;
	qed prop 1 = step 4 ;;
}

/*The indexed union of a function's values is the union of its range.
       Compare Definition 5.4 of [Monk1] p. 50.  (Contributed by NM,
       27-Sep-2004.) */

theorem fniunfv (x : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( F Fn A → ⋃_ x ∈ A ( F ` x ) = ⋃ ran F ) ;;
}

proof of fniunfv {
	var y : set;;
	step 1 : wff = fnrnfv () |- ( F Fn A → ran F = { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	step 2 : wff = unieqd (step 1) |- ( F Fn A → ⋃ ran F = ⋃ { y | ∃ x ∈ A y = ( F ` x ) } ) ;;
	step 3 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 4 : wff = dfiun2 (step 3) |- ⋃_ x ∈ A ( F ` x ) = ⋃ { y | ∃ x ∈ A y = ( F ` x ) } ;;
	step 5 : wff = syl6reqr (step 2, step 4) |- ( F Fn A → ⋃_ x ∈ A ( F ` x ) = ⋃ ran F ) ;;
	qed prop 1 = step 5 ;;
}

/*The indexed union of a function's values is the union of its image under
       the index class.

       Note:  This theorem depends on the fact that our function value is the
       empty set outside of its domain.  If the antecedent is changed to
       ` F Fn A ` , the theorem can be proved without this dependency.
       (Contributed by NM, 26-Mar-2006.)  (Proof shortened by Mario Carneiro,
       31-Aug-2015.) */

theorem funiunfv (x : set, A : class, F : class) disjointed(x A, x F) {
	prop 1 : wff = |- ( Fun F → ⋃_ x ∈ A ( F ` x ) = ⋃ ( F " A ) ) ;;
}

proof of funiunfv {
	step 1 : wff = funres () |- ( Fun F → Fun ( F ↾ A ) ) ;;
	step 2 : wff = funfn () |- ( Fun ( F ↾ A ) ↔ ( F ↾ A ) Fn dom ( F ↾ A ) ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( Fun F → ( F ↾ A ) Fn dom ( F ↾ A ) ) ;;
	step 4 : wff = fniunfv () |- ( ( F ↾ A ) Fn dom ( F ↾ A ) → ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) = ⋃ ran ( F ↾ A ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( Fun F → ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) = ⋃ ran ( F ↾ A ) ) ;;
	step 6 : wff = undif2 () |- ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) = ( dom ( F ↾ A ) ∪ A ) ;;
	step 7 : wff = dmres () |- dom ( F ↾ A ) = ( A ∩ dom F ) ;;
	step 8 : wff = inss1 () |- ( A ∩ dom F ) ⊆ A ;;
	step 9 : wff = eqsstri (step 7, step 8) |- dom ( F ↾ A ) ⊆ A ;;
	step 10 : wff = ssequn1 () |- ( dom ( F ↾ A ) ⊆ A ↔ ( dom ( F ↾ A ) ∪ A ) = A ) ;;
	step 11 : wff = mpbi (step 9, step 10) |- ( dom ( F ↾ A ) ∪ A ) = A ;;
	step 12 : wff = eqtri (step 6, step 11) |- ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) = A ;;
	step 13 : wff = iuneq1 () |- ( ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) = A → ⋃_ x ∈ ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) ( ( F ↾ A ) ` x ) = ⋃_ x ∈ A ( ( F ↾ A ) ` x ) ) ;;
	step 14 : wff = ax-mp (step 12, step 13) |- ⋃_ x ∈ ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) ( ( F ↾ A ) ` x ) = ⋃_ x ∈ A ( ( F ↾ A ) ` x ) ;;
	step 15 : wff = iunxun () |- ⋃_ x ∈ ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) ( ( F ↾ A ) ` x ) = ( ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ∪ ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ( ( F ↾ A ) ` x ) ) ;;
	step 16 : wff = eldifn () |- ( x ∈ ( A ∖ dom ( F ↾ A ) ) → ¬ x ∈ dom ( F ↾ A ) ) ;;
	step 17 : wff = ndmfv () |- ( ¬ x ∈ dom ( F ↾ A ) → ( ( F ↾ A ) ` x ) = ∅ ) ;;
	step 18 : wff = syl (step 16, step 17) |- ( x ∈ ( A ∖ dom ( F ↾ A ) ) → ( ( F ↾ A ) ` x ) = ∅ ) ;;
	step 19 : wff = iuneq2i (step 18) |- ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ( ( F ↾ A ) ` x ) = ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ∅ ;;
	step 20 : wff = iun0 () |- ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ∅ = ∅ ;;
	step 21 : wff = eqtri (step 19, step 20) |- ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ( ( F ↾ A ) ` x ) = ∅ ;;
	step 22 : wff = uneq2i (step 21) |- ( ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ∪ ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ( ( F ↾ A ) ` x ) ) = ( ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ∪ ∅ ) ;;
	step 23 : wff = un0 () |- ( ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ∪ ∅ ) = ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ;;
	step 24 : wff = eqtri (step 22, step 23) |- ( ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ∪ ⋃_ x ∈ ( A ∖ dom ( F ↾ A ) ) ( ( F ↾ A ) ` x ) ) = ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ;;
	step 25 : wff = eqtri (step 15, step 24) |- ⋃_ x ∈ ( dom ( F ↾ A ) ∪ ( A ∖ dom ( F ↾ A ) ) ) ( ( F ↾ A ) ` x ) = ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ;;
	step 26 : wff = fvres () |- ( x ∈ A → ( ( F ↾ A ) ` x ) = ( F ` x ) ) ;;
	step 27 : wff = iuneq2i (step 26) |- ⋃_ x ∈ A ( ( F ↾ A ) ` x ) = ⋃_ x ∈ A ( F ` x ) ;;
	step 28 : wff = 3eqtr3ri (step 14, step 25, step 27) |- ⋃_ x ∈ A ( F ` x ) = ⋃_ x ∈ dom ( F ↾ A ) ( ( F ↾ A ) ` x ) ;;
	step 29 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 30 : wff = unieqi (step 29) |- ⋃ ( F " A ) = ⋃ ran ( F ↾ A ) ;;
	step 31 : wff = 3eqtr4g (step 5, step 28, step 30) |- ( Fun F → ⋃_ x ∈ A ( F ` x ) = ⋃ ( F " A ) ) ;;
	qed prop 1 = step 31 ;;
}

/*The indexed union of a function's values is the union of its image under
       the index class.  This version of ~ funiunfv uses a bound-variable
       hypothesis in place of a distinct variable condition.  (Contributed by
       NM, 26-Mar-2006.)  (Revised by David Abernethy, 15-Apr-2013.) */

theorem funiunfvf (x : set, A : class, F : class) disjointed(x z A, z F, x) {
	hyp 1 : wff = |- F/_ x F ;;
	-----------------------
	prop 1 : wff = |- ( Fun F → ⋃_ x ∈ A ( F ` x ) = ⋃ ( F " A ) ) ;;
}

proof of funiunfvf {
	var z : set;;
	step 1 : wff = nfcv () |- F/_ x z ;;
	step 2 : wff = nffv (hyp 1, step 1) |- F/_ x ( F ` z ) ;;
	step 3 : wff = nfcv () |- F/_ z ( F ` x ) ;;
	step 4 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 5 : wff = cbviun (step 2, step 3, step 4) |- ⋃_ z ∈ A ( F ` z ) = ⋃_ x ∈ A ( F ` x ) ;;
	step 6 : wff = funiunfv () |- ( Fun F → ⋃_ z ∈ A ( F ` z ) = ⋃ ( F " A ) ) ;;
	step 7 : wff = syl5eqr (step 5, step 6) |- ( Fun F → ⋃_ x ∈ A ( F ` x ) = ⋃ ( F " A ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Membership in the union of an image of a function.  (Contributed by NM,
       28-Sep-2006.) */

theorem eluniima (x : set, A : class, B : class, F : class) disjointed(x A, x B, x F) {
	prop 1 : wff = |- ( Fun F → ( B ∈ ⋃ ( F " A ) ↔ ∃ x ∈ A B ∈ ( F ` x ) ) ) ;;
}

proof of eluniima {
	step 1 : wff = eliun () |- ( B ∈ ⋃_ x ∈ A ( F ` x ) ↔ ∃ x ∈ A B ∈ ( F ` x ) ) ;;
	step 2 : wff = funiunfv () |- ( Fun F → ⋃_ x ∈ A ( F ` x ) = ⋃ ( F " A ) ) ;;
	step 3 : wff = eleq2d (step 2) |- ( Fun F → ( B ∈ ⋃_ x ∈ A ( F ` x ) ↔ B ∈ ⋃ ( F " A ) ) ) ;;
	step 4 : wff = syl5rbbr (step 1, step 3) |- ( Fun F → ( B ∈ ⋃ ( F " A ) ↔ ∃ x ∈ A B ∈ ( F ` x ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Membership in the union of the range of a function.  See ~ elunirnALT
       for alternate proof.  (Contributed by NM, 24-Sep-2006.) */

theorem elunirn (x : set, A : class, F : class) disjointed(x A, x, x F) {
	prop 1 : wff = |- ( Fun F → ( A ∈ ⋃ ran F ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
}

proof of elunirn {
	step 1 : wff = imadmrn () |- ( F " dom F ) = ran F ;;
	step 2 : wff = unieqi (step 1) |- ⋃ ( F " dom F ) = ⋃ ran F ;;
	step 3 : wff = eleq2i (step 2) |- ( A ∈ ⋃ ( F " dom F ) ↔ A ∈ ⋃ ran F ) ;;
	step 4 : wff = eluniima () |- ( Fun F → ( A ∈ ⋃ ( F " dom F ) ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	step 5 : wff = syl5bbr (step 3, step 4) |- ( Fun F → ( A ∈ ⋃ ran F ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Membership in a union of some function-defined family of sets.
       (Contributed by Stefan O'Rear, 30-Jan-2015.) */

theorem fnunirn (x : set, A : class, F : class, I : class) disjointed(x A, x I, x F) {
	prop 1 : wff = |- ( F Fn I → ( A ∈ ⋃ ran F ↔ ∃ x ∈ I A ∈ ( F ` x ) ) ) ;;
}

proof of fnunirn {
	step 1 : wff = fnfun () |- ( F Fn I → Fun F ) ;;
	step 2 : wff = elunirn () |- ( Fun F → ( A ∈ ⋃ ran F ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F Fn I → ( A ∈ ⋃ ran F ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	step 4 : wff = fndm () |- ( F Fn I → dom F = I ) ;;
	step 5 : wff = rexeqdv (step 4) |- ( F Fn I → ( ∃ x ∈ dom F A ∈ ( F ` x ) ↔ ∃ x ∈ I A ∈ ( F ` x ) ) ) ;;
	step 6 : wff = bitrd (step 3, step 5) |- ( F Fn I → ( A ∈ ⋃ ran F ↔ ∃ x ∈ I A ∈ ( F ` x ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Membership in the union of the range of a function, proved directly.
       Unlike ~ elunirn , it doesn't appeal to ~ ndmfv (via ~ funiunfv ).
       (Contributed by NM, 24-Sep-2006.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem elunirnALT (x : set, A : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( Fun F → ( A ∈ ⋃ ran F ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
}

proof of elunirnALT {
	var y : set;;
	step 1 : wff = eluni () |- ( A ∈ ⋃ ran F ↔ ∃ y ( A ∈ y ∧ y ∈ ran F ) ) ;;
	step 2 : wff = funfn () |- ( Fun F ↔ F Fn dom F ) ;;
	step 3 : wff = fvelrnb () |- ( F Fn dom F → ( y ∈ ran F ↔ ∃ x ∈ dom F ( F ` x ) = y ) ) ;;
	step 4 : wff = sylbi (step 2, step 3) |- ( Fun F → ( y ∈ ran F ↔ ∃ x ∈ dom F ( F ` x ) = y ) ) ;;
	step 5 : wff = anbi2d (step 4) |- ( Fun F → ( ( A ∈ y ∧ y ∈ ran F ) ↔ ( A ∈ y ∧ ∃ x ∈ dom F ( F ` x ) = y ) ) ) ;;
	step 6 : wff = r19.42v () |- ( ∃ x ∈ dom F ( A ∈ y ∧ ( F ` x ) = y ) ↔ ( A ∈ y ∧ ∃ x ∈ dom F ( F ` x ) = y ) ) ;;
	step 7 : wff = syl6bbr (step 5, step 6) |- ( Fun F → ( ( A ∈ y ∧ y ∈ ran F ) ↔ ∃ x ∈ dom F ( A ∈ y ∧ ( F ` x ) = y ) ) ) ;;
	step 8 : wff = eleq2 () |- ( ( F ` x ) = y → ( A ∈ ( F ` x ) ↔ A ∈ y ) ) ;;
	step 9 : wff = biimparc (step 8) |- ( ( A ∈ y ∧ ( F ` x ) = y ) → A ∈ ( F ` x ) ) ;;
	step 10 : wff = reximi (step 9) |- ( ∃ x ∈ dom F ( A ∈ y ∧ ( F ` x ) = y ) → ∃ x ∈ dom F A ∈ ( F ` x ) ) ;;
	step 11 : wff = syl6bi (step 7, step 10) |- ( Fun F → ( ( A ∈ y ∧ y ∈ ran F ) → ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	step 12 : wff = exlimdv (step 11) |- ( Fun F → ( ∃ y ( A ∈ y ∧ y ∈ ran F ) → ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	step 13 : wff = fvelrn () |- ( ( Fun F ∧ x ∈ dom F ) → ( F ` x ) ∈ ran F ) ;;
	step 14 : wff = a1d (step 13) |- ( ( Fun F ∧ x ∈ dom F ) → ( A ∈ ( F ` x ) → ( F ` x ) ∈ ran F ) ) ;;
	step 15 : wff = ancld (step 14) |- ( ( Fun F ∧ x ∈ dom F ) → ( A ∈ ( F ` x ) → ( A ∈ ( F ` x ) ∧ ( F ` x ) ∈ ran F ) ) ) ;;
	step 16 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 17 : wff = eleq2 () |- ( y = ( F ` x ) → ( A ∈ y ↔ A ∈ ( F ` x ) ) ) ;;
	step 18 : wff = eleq1 () |- ( y = ( F ` x ) → ( y ∈ ran F ↔ ( F ` x ) ∈ ran F ) ) ;;
	step 19 : wff = anbi12d (step 17, step 18) |- ( y = ( F ` x ) → ( ( A ∈ y ∧ y ∈ ran F ) ↔ ( A ∈ ( F ` x ) ∧ ( F ` x ) ∈ ran F ) ) ) ;;
	step 20 : wff = spcev (step 16, step 19) |- ( ( A ∈ ( F ` x ) ∧ ( F ` x ) ∈ ran F ) → ∃ y ( A ∈ y ∧ y ∈ ran F ) ) ;;
	step 21 : wff = syl6 (step 15, step 20) |- ( ( Fun F ∧ x ∈ dom F ) → ( A ∈ ( F ` x ) → ∃ y ( A ∈ y ∧ y ∈ ran F ) ) ) ;;
	step 22 : wff = rexlimdva (step 21) |- ( Fun F → ( ∃ x ∈ dom F A ∈ ( F ` x ) → ∃ y ( A ∈ y ∧ y ∈ ran F ) ) ) ;;
	step 23 : wff = impbid (step 12, step 22) |- ( Fun F → ( ∃ y ( A ∈ y ∧ y ∈ ran F ) ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	step 24 : wff = syl5bb (step 1, step 23) |- ( Fun F → ( A ∈ ⋃ ran F ↔ ∃ x ∈ dom F A ∈ ( F ` x ) ) ) ;;
	qed prop 1 = step 24 ;;
}

/*Existence of an existentially restricted class abstraction. ` ph ` is
       normally has free-variable parameters ` x ` and ` y ` .  See also
       ~ abrexex .  (Contributed by NM, 12-Sep-2004.) */

theorem abrexex2 (ph : wff, x : set, y : set, A : class) disjointed(x y z A, z ph) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- { y | ph } ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { y | ∃ x ∈ A ph } ∈ _V ;;
}

proof of abrexex2 {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ∃ x ∈ A ph ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = nfs1v () |- F/ y [ z / y ] ph ;;
	step 4 : wff = nfrex (step 2, step 3) |- F/ y ∃ x ∈ A [ z / y ] ph ;;
	step 5 : wff = sbequ12 () |- ( y = z → ( ph ↔ [ z / y ] ph ) ) ;;
	step 6 : wff = rexbidv (step 5) |- ( y = z → ( ∃ x ∈ A ph ↔ ∃ x ∈ A [ z / y ] ph ) ) ;;
	step 7 : wff = cbvab (step 1, step 4, step 6) |- { y | ∃ x ∈ A ph } = { z | ∃ x ∈ A [ z / y ] ph } ;;
	step 8 : wff = df-clab () |- ( z ∈ { y | ph } ↔ [ z / y ] ph ) ;;
	step 9 : wff = rexbii (step 8) |- ( ∃ x ∈ A z ∈ { y | ph } ↔ ∃ x ∈ A [ z / y ] ph ) ;;
	step 10 : wff = abbii (step 9) |- { z | ∃ x ∈ A z ∈ { y | ph } } = { z | ∃ x ∈ A [ z / y ] ph } ;;
	step 11 : wff = eqtr4i (step 7, step 10) |- { y | ∃ x ∈ A ph } = { z | ∃ x ∈ A z ∈ { y | ph } } ;;
	step 12 : wff = df-iun () |- ⋃_ x ∈ A { y | ph } = { z | ∃ x ∈ A z ∈ { y | ph } } ;;
	step 13 : wff = iunex (hyp 1, hyp 2) |- ⋃_ x ∈ A { y | ph } ∈ _V ;;
	step 14 : wff = eqeltrri (step 12, step 13) |- { z | ∃ x ∈ A z ∈ { y | ph } } ∈ _V ;;
	step 15 : wff = eqeltri (step 11, step 14) |- { y | ∃ x ∈ A ph } ∈ _V ;;
	qed prop 1 = step 15 ;;
}

/*Existence of a class abstraction with an existentially quantified
       expression.  Both ` x ` and ` y ` can be free in ` ph ` .  (Contributed
       by NM, 29-Jul-2006.) */

theorem abexssex (ph : wff, x : set, y : set, A : class) disjointed(x y A, ph) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- { y | ph } ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { y | ∃ x ( x ⊆ A ∧ ph ) } ∈ _V ;;
}

proof of abexssex {
	step 1 : wff = df-rex () |- ( ∃ x ∈ Pow A ph ↔ ∃ x ( x ∈ Pow A ∧ ph ) ) ;;
	step 2 : wff = elpw2 (hyp 1) |- ( x ∈ Pow A ↔ x ⊆ A ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( x ∈ Pow A ∧ ph ) ↔ ( x ⊆ A ∧ ph ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ x ( x ∈ Pow A ∧ ph ) ↔ ∃ x ( x ⊆ A ∧ ph ) ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( ∃ x ∈ Pow A ph ↔ ∃ x ( x ⊆ A ∧ ph ) ) ;;
	step 6 : wff = abbii (step 5) |- { y | ∃ x ∈ Pow A ph } = { y | ∃ x ( x ⊆ A ∧ ph ) } ;;
	step 7 : wff = pwex (hyp 1) |- Pow A ∈ _V ;;
	step 8 : wff = abrexex2 (step 7, hyp 2) |- { y | ∃ x ∈ Pow A ph } ∈ _V ;;
	step 9 : wff = eqeltrri (step 6, step 8) |- { y | ∃ x ( x ⊆ A ∧ ph ) } ∈ _V ;;
	qed prop 1 = step 9 ;;
}

/*A condition where a class builder continues to exist after its wff is
       existentially quantified.  (Contributed by NM, 4-Mar-2007.) */

theorem abexex (ph : wff, x : set, y : set, A : class) disjointed(x y A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( ph → x ∈ A ) ;;
	hyp 3 : wff = |- { y | ph } ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { y | ∃ x ph } ∈ _V ;;
}

proof of abexex {
	step 1 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = pm4.71ri (hyp 2) |- ( ph ↔ ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( ∃ x ∈ A ph ↔ ∃ x ph ) ;;
	step 5 : wff = abbii (step 4) |- { y | ∃ x ∈ A ph } = { y | ∃ x ph } ;;
	step 6 : wff = abrexex2 (hyp 1, hyp 3) |- { y | ∃ x ∈ A ph } ∈ _V ;;
	step 7 : wff = eqeltrri (step 5, step 6) |- { y | ∃ x ph } ∈ _V ;;
	qed prop 1 = step 7 ;;
}

/*A one-to-one function in terms of function values.  Compare Theorem
       4.8(iv) of [Monk1] p. 43.  (Contributed by NM, 29-Oct-1996.) */

theorem dff13 (x : set, y : set, A : class, B : class, F : class) disjointed(x y z A, z B, x y z F) {
	prop 1 : wff = |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
}

proof of dff13 {
	var z : set;;
	step 1 : wff = dff12 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ z ∃* x x F z ) ) ;;
	step 2 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- z ∈ _V ;;
	step 5 : wff = breldm (step 3, step 4) |- ( x F z → x ∈ dom F ) ;;
	step 6 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 7 : wff = eleq2d (step 6) |- ( F Fn A → ( x ∈ dom F ↔ x ∈ A ) ) ;;
	step 8 : wff = syl5ib (step 5, step 7) |- ( F Fn A → ( x F z → x ∈ A ) ) ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = vex () |- z ∈ _V ;;
	step 11 : wff = breldm (step 9, step 10) |- ( y F z → y ∈ dom F ) ;;
	step 12 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 13 : wff = eleq2d (step 12) |- ( F Fn A → ( y ∈ dom F ↔ y ∈ A ) ) ;;
	step 14 : wff = syl5ib (step 11, step 13) |- ( F Fn A → ( y F z → y ∈ A ) ) ;;
	step 15 : wff = anim12d (step 8, step 14) |- ( F Fn A → ( ( x F z ∧ y F z ) → ( x ∈ A ∧ y ∈ A ) ) ) ;;
	step 16 : wff = pm4.71rd (step 15) |- ( F Fn A → ( ( x F z ∧ y F z ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( x F z ∧ y F z ) ) ) ) ;;
	step 17 : wff = eqcom () |- ( z = ( F ` x ) ↔ ( F ` x ) = z ) ;;
	step 18 : wff = fnbrfvb () |- ( ( F Fn A ∧ x ∈ A ) → ( ( F ` x ) = z ↔ x F z ) ) ;;
	step 19 : wff = syl5bb (step 17, step 18) |- ( ( F Fn A ∧ x ∈ A ) → ( z = ( F ` x ) ↔ x F z ) ) ;;
	step 20 : wff = eqcom () |- ( z = ( F ` y ) ↔ ( F ` y ) = z ) ;;
	step 21 : wff = fnbrfvb () |- ( ( F Fn A ∧ y ∈ A ) → ( ( F ` y ) = z ↔ y F z ) ) ;;
	step 22 : wff = syl5bb (step 20, step 21) |- ( ( F Fn A ∧ y ∈ A ) → ( z = ( F ` y ) ↔ y F z ) ) ;;
	step 23 : wff = bi2anan9 (step 19, step 22) |- ( ( ( F Fn A ∧ x ∈ A ) ∧ ( F Fn A ∧ y ∈ A ) ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) ↔ ( x F z ∧ y F z ) ) ) ;;
	step 24 : wff = anandis (step 23) |- ( ( F Fn A ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) ↔ ( x F z ∧ y F z ) ) ) ;;
	step 25 : wff = pm5.32da (step 24) |- ( F Fn A → ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( z = ( F ` x ) ∧ z = ( F ` y ) ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( x F z ∧ y F z ) ) ) ) ;;
	step 26 : wff = bitr4d (step 16, step 25) |- ( F Fn A → ( ( x F z ∧ y F z ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( z = ( F ` x ) ∧ z = ( F ` y ) ) ) ) ) ;;
	step 27 : wff = imbi1d (step 26) |- ( F Fn A → ( ( ( x F z ∧ y F z ) → x = y ) ↔ ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( z = ( F ` x ) ∧ z = ( F ` y ) ) ) → x = y ) ) ) ;;
	step 28 : wff = impexp () |- ( ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( z = ( F ` x ) ∧ z = ( F ` y ) ) ) → x = y ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ) ;;
	step 29 : wff = syl6bb (step 27, step 28) |- ( F Fn A → ( ( ( x F z ∧ y F z ) → x = y ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ) ) ;;
	step 30 : wff = albidv (step 29) |- ( F Fn A → ( ∀ z ( ( x F z ∧ y F z ) → x = y ) ↔ ∀ z ( ( x ∈ A ∧ y ∈ A ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ) ) ;;
	step 31 : wff = 19.21v () |- ( ∀ z ( ( x ∈ A ∧ y ∈ A ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ∀ z ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ) ;;
	step 32 : wff = 19.23v () |- ( ∀ z ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ↔ ( ∃ z ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ;;
	step 33 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 34 : wff = eqvinc (step 33) |- ( ( F ` x ) = ( F ` y ) ↔ ∃ z ( z = ( F ` x ) ∧ z = ( F ` y ) ) ) ;;
	step 35 : wff = imbi1i (step 34) |- ( ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ( ∃ z ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ;;
	step 36 : wff = bitr4i (step 32, step 35) |- ( ∀ z ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ↔ ( ( F ` x ) = ( F ` y ) → x = y ) ) ;;
	step 37 : wff = imbi2i (step 36) |- ( ( ( x ∈ A ∧ y ∈ A ) → ∀ z ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 38 : wff = bitri (step 31, step 37) |- ( ∀ z ( ( x ∈ A ∧ y ∈ A ) → ( ( z = ( F ` x ) ∧ z = ( F ` y ) ) → x = y ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 39 : wff = syl6bb (step 30, step 38) |- ( F Fn A → ( ∀ z ( ( x F z ∧ y F z ) → x = y ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ) ;;
	step 40 : wff = 2albidv (step 39) |- ( F Fn A → ( ∀ x ∀ y ∀ z ( ( x F z ∧ y F z ) → x = y ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ) ;;
	step 41 : wff = breq1 () |- ( x = y → ( x F z ↔ y F z ) ) ;;
	step 42 : wff = mo4 (step 41) |- ( ∃* x x F z ↔ ∀ x ∀ y ( ( x F z ∧ y F z ) → x = y ) ) ;;
	step 43 : wff = albii (step 42) |- ( ∀ z ∃* x x F z ↔ ∀ z ∀ x ∀ y ( ( x F z ∧ y F z ) → x = y ) ) ;;
	step 44 : wff = alrot3 () |- ( ∀ z ∀ x ∀ y ( ( x F z ∧ y F z ) → x = y ) ↔ ∀ x ∀ y ∀ z ( ( x F z ∧ y F z ) → x = y ) ) ;;
	step 45 : wff = bitri (step 43, step 44) |- ( ∀ z ∃* x x F z ↔ ∀ x ∀ y ∀ z ( ( x F z ∧ y F z ) → x = y ) ) ;;
	step 46 : wff = r2al () |- ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 47 : wff = 3bitr4g (step 40, step 45, step 46) |- ( F Fn A → ( ∀ z ∃* x x F z ↔ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 48 : wff = syl (step 2, step 47) |- ( F : A ⟶ B → ( ∀ z ∃* x x F z ↔ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 49 : wff = pm5.32i (step 48) |- ( ( F : A ⟶ B ∧ ∀ z ∃* x x F z ) ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 50 : wff = bitri (step 1, step 49) |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	qed prop 1 = step 50 ;;
}

/*A one-to-one function in terms of function values.  Compare Theorem
       4.8(iv) of [Monk1] p. 43.  (Contributed by NM, 31-Jul-2003.) */

theorem dff13f (x : set, y : set, A : class, B : class, F : class) disjointed(x y w v A, w v B, w v F, x y) {
	hyp 1 : wff = |- F/_ x F ;;
	hyp 2 : wff = |- F/_ y F ;;
	-----------------------
	prop 1 : wff = |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
}

proof of dff13f {
	var w : set, v : set;;
	step 1 : wff = dff13 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) = ( F ` v ) → w = v ) ) ) ;;
	step 2 : wff = nfcv () |- F/_ y w ;;
	step 3 : wff = nffv (hyp 2, step 2) |- F/_ y ( F ` w ) ;;
	step 4 : wff = nfcv () |- F/_ y v ;;
	step 5 : wff = nffv (hyp 2, step 4) |- F/_ y ( F ` v ) ;;
	step 6 : wff = nfeq (step 3, step 5) |- F/ y ( F ` w ) = ( F ` v ) ;;
	step 7 : wff = nfv () |- F/ y w = v ;;
	step 8 : wff = nfim (step 6, step 7) |- F/ y ( ( F ` w ) = ( F ` v ) → w = v ) ;;
	step 9 : wff = nfv () |- F/ v ( ( F ` w ) = ( F ` y ) → w = y ) ;;
	step 10 : wff = fveq2 () |- ( v = y → ( F ` v ) = ( F ` y ) ) ;;
	step 11 : wff = eqeq2d (step 10) |- ( v = y → ( ( F ` w ) = ( F ` v ) ↔ ( F ` w ) = ( F ` y ) ) ) ;;
	step 12 : wff = eqeq2 () |- ( v = y → ( w = v ↔ w = y ) ) ;;
	step 13 : wff = imbi12d (step 11, step 12) |- ( v = y → ( ( ( F ` w ) = ( F ` v ) → w = v ) ↔ ( ( F ` w ) = ( F ` y ) → w = y ) ) ) ;;
	step 14 : wff = cbvral (step 8, step 9, step 13) |- ( ∀ v ∈ A ( ( F ` w ) = ( F ` v ) → w = v ) ↔ ∀ y ∈ A ( ( F ` w ) = ( F ` y ) → w = y ) ) ;;
	step 15 : wff = ralbii (step 14) |- ( ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) = ( F ` v ) → w = v ) ↔ ∀ w ∈ A ∀ y ∈ A ( ( F ` w ) = ( F ` y ) → w = y ) ) ;;
	step 16 : wff = nfcv () |- F/_ x A ;;
	step 17 : wff = nfcv () |- F/_ x w ;;
	step 18 : wff = nffv (hyp 1, step 17) |- F/_ x ( F ` w ) ;;
	step 19 : wff = nfcv () |- F/_ x y ;;
	step 20 : wff = nffv (hyp 1, step 19) |- F/_ x ( F ` y ) ;;
	step 21 : wff = nfeq (step 18, step 20) |- F/ x ( F ` w ) = ( F ` y ) ;;
	step 22 : wff = nfv () |- F/ x w = y ;;
	step 23 : wff = nfim (step 21, step 22) |- F/ x ( ( F ` w ) = ( F ` y ) → w = y ) ;;
	step 24 : wff = nfral (step 16, step 23) |- F/ x ∀ y ∈ A ( ( F ` w ) = ( F ` y ) → w = y ) ;;
	step 25 : wff = nfv () |- F/ w ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ;;
	step 26 : wff = fveq2 () |- ( w = x → ( F ` w ) = ( F ` x ) ) ;;
	step 27 : wff = eqeq1d (step 26) |- ( w = x → ( ( F ` w ) = ( F ` y ) ↔ ( F ` x ) = ( F ` y ) ) ) ;;
	step 28 : wff = eqeq1 () |- ( w = x → ( w = y ↔ x = y ) ) ;;
	step 29 : wff = imbi12d (step 27, step 28) |- ( w = x → ( ( ( F ` w ) = ( F ` y ) → w = y ) ↔ ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 30 : wff = ralbidv (step 29) |- ( w = x → ( ∀ y ∈ A ( ( F ` w ) = ( F ` y ) → w = y ) ↔ ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 31 : wff = cbvral (step 24, step 25, step 30) |- ( ∀ w ∈ A ∀ y ∈ A ( ( F ` w ) = ( F ` y ) → w = y ) ↔ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ;;
	step 32 : wff = bitri (step 15, step 31) |- ( ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) = ( F ` v ) → w = v ) ↔ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ;;
	step 33 : wff = anbi2i (step 32) |- ( ( F : A ⟶ B ∧ ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) = ( F ` v ) → w = v ) ) ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 34 : wff = bitri (step 1, step 33) |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	qed prop 1 = step 34 ;;
}

/*Express injection for a mapping operation.  (Contributed by Mario
       Carneiro, 2-Jan-2017.) */

theorem f1mpt (x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y A, x y B, y C, x D, y F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	hyp 2 : wff = |- ( x = y → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( F : A ↣ B ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
}

proof of f1mpt {
	step 1 : wff = nfmpt1 () |- F/_ x ( x ∈ A ↦ C ) ;;
	step 2 : wff = nfcxfr (hyp 1, step 1) |- F/_ x F ;;
	step 3 : wff = nfcv () |- F/_ y F ;;
	step 4 : wff = dff13f (step 2, step 3) |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 5 : wff = fmpt (hyp 1) |- ( ∀ x ∈ A C ∈ B ↔ F : A ⟶ B ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 7 : wff = eleq1d (hyp 2) |- ( x = y → ( C ∈ B ↔ D ∈ B ) ) ;;
	step 8 : wff = cbvralv (step 7) |- ( ∀ x ∈ A C ∈ B ↔ ∀ y ∈ A D ∈ B ) ;;
	step 9 : wff = raaanv () |- ( ∀ x ∈ A ∀ y ∈ A ( C ∈ B ∧ D ∈ B ) ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ y ∈ A D ∈ B ) ) ;;
	step 10 : wff = fvmpt2 (hyp 1) |- ( ( x ∈ A ∧ C ∈ B ) → ( F ` x ) = C ) ;;
	step 11 : wff = fvmptg (hyp 2, hyp 1) |- ( ( y ∈ A ∧ D ∈ B ) → ( F ` y ) = D ) ;;
	step 12 : wff = eqeqan12d (step 10, step 11) |- ( ( ( x ∈ A ∧ C ∈ B ) ∧ ( y ∈ A ∧ D ∈ B ) ) → ( ( F ` x ) = ( F ` y ) ↔ C = D ) ) ;;
	step 13 : wff = an4s (step 12) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( C ∈ B ∧ D ∈ B ) ) → ( ( F ` x ) = ( F ` y ) ↔ C = D ) ) ;;
	step 14 : wff = imbi1d (step 13) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( C ∈ B ∧ D ∈ B ) ) → ( ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ( C = D → x = y ) ) ) ;;
	step 15 : wff = ex (step 14) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( C ∈ B ∧ D ∈ B ) → ( ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ( C = D → x = y ) ) ) ) ;;
	step 16 : wff = ralimdva (step 15) |- ( x ∈ A → ( ∀ y ∈ A ( C ∈ B ∧ D ∈ B ) → ∀ y ∈ A ( ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ( C = D → x = y ) ) ) ) ;;
	step 17 : wff = ralbi () |- ( ∀ y ∈ A ( ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ( C = D → x = y ) ) → ( ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 18 : wff = syl6 (step 16, step 17) |- ( x ∈ A → ( ∀ y ∈ A ( C ∈ B ∧ D ∈ B ) → ( ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ y ∈ A ( C = D → x = y ) ) ) ) ;;
	step 19 : wff = ralimia (step 18) |- ( ∀ x ∈ A ∀ y ∈ A ( C ∈ B ∧ D ∈ B ) → ∀ x ∈ A ( ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 20 : wff = ralbi () |- ( ∀ x ∈ A ( ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ y ∈ A ( C = D → x = y ) ) → ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 21 : wff = syl (step 19, step 20) |- ( ∀ x ∈ A ∀ y ∈ A ( C ∈ B ∧ D ∈ B ) → ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 22 : wff = sylbir (step 9, step 21) |- ( ( ∀ x ∈ A C ∈ B ∧ ∀ y ∈ A D ∈ B ) → ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 23 : wff = sylan2b (step 8, step 22) |- ( ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A C ∈ B ) → ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 24 : wff = anidms (step 23) |- ( ∀ x ∈ A C ∈ B → ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 25 : wff = pm5.32i (step 24) |- ( ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 26 : wff = bitr3i (step 6, step 25) |- ( ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	step 27 : wff = bitri (step 4, step 26) |- ( F : A ↣ B ↔ ( ∀ x ∈ A C ∈ B ∧ ∀ x ∈ A ∀ y ∈ A ( C = D → x = y ) ) ) ;;
	qed prop 1 = step 27 ;;
}

/*Equality of function values for a one-to-one function.  (Contributed by
       NM, 11-Feb-1997.) */

theorem f1fveq (A : class, B : class, C : class, D : class, F : class) disjointed(x y A, x y B, x y C, x y D, x y F) {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ ( C ∈ A ∧ D ∈ A ) ) → ( ( F ` C ) = ( F ` D ) ↔ C = D ) ) ;;
}

proof of f1fveq {
	var x : set, y : set;;
	step 1 : wff = fveq2 () |- ( x = C → ( F ` x ) = ( F ` C ) ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( x = C → ( ( F ` x ) = ( F ` y ) ↔ ( F ` C ) = ( F ` y ) ) ) ;;
	step 3 : wff = eqeq1 () |- ( x = C → ( x = y ↔ C = y ) ) ;;
	step 4 : wff = imbi12d (step 2, step 3) |- ( x = C → ( ( ( F ` x ) = ( F ` y ) → x = y ) ↔ ( ( F ` C ) = ( F ` y ) → C = y ) ) ) ;;
	step 5 : wff = imbi2d (step 4) |- ( x = C → ( ( F : A ↣ B → ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( F : A ↣ B → ( ( F ` C ) = ( F ` y ) → C = y ) ) ) ) ;;
	step 6 : wff = fveq2 () |- ( y = D → ( F ` y ) = ( F ` D ) ) ;;
	step 7 : wff = eqeq2d (step 6) |- ( y = D → ( ( F ` C ) = ( F ` y ) ↔ ( F ` C ) = ( F ` D ) ) ) ;;
	step 8 : wff = eqeq2 () |- ( y = D → ( C = y ↔ C = D ) ) ;;
	step 9 : wff = imbi12d (step 7, step 8) |- ( y = D → ( ( ( F ` C ) = ( F ` y ) → C = y ) ↔ ( ( F ` C ) = ( F ` D ) → C = D ) ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( y = D → ( ( F : A ↣ B → ( ( F ` C ) = ( F ` y ) → C = y ) ) ↔ ( F : A ↣ B → ( ( F ` C ) = ( F ` D ) → C = D ) ) ) ) ;;
	step 11 : wff = dff13 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 12 : wff = simprbi (step 11) |- ( F : A ↣ B → ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ;;
	step 13 : wff = rsp2 () |- ( ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) → ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( F : A ↣ B → ( ( x ∈ A ∧ y ∈ A ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 15 : wff = com12 (step 14) |- ( ( x ∈ A ∧ y ∈ A ) → ( F : A ↣ B → ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 16 : wff = vtocl2ga (step 5, step 10, step 15) |- ( ( C ∈ A ∧ D ∈ A ) → ( F : A ↣ B → ( ( F ` C ) = ( F ` D ) → C = D ) ) ) ;;
	step 17 : wff = impcom (step 16) |- ( ( F : A ↣ B ∧ ( C ∈ A ∧ D ∈ A ) ) → ( ( F ` C ) = ( F ` D ) → C = D ) ) ;;
	step 18 : wff = fveq2 () |- ( C = D → ( F ` C ) = ( F ` D ) ) ;;
	step 19 : wff = impbid1 (step 17, step 18) |- ( ( F : A ↣ B ∧ ( C ∈ A ∧ D ∈ A ) ) → ( ( F ` C ) = ( F ` D ) ↔ C = D ) ) ;;
	qed prop 1 = step 19 ;;
}

/*Membership in the image of a 1-1 map.  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem f1elima (A : class, B : class, F : class, X : class, Y : class) disjointed(F z, A z, Y z, X z, B z) {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ X ∈ A ∧ Y ⊆ A ) → ( ( F ` X ) ∈ ( F " Y ) ↔ X ∈ Y ) ) ;;
}

proof of f1elima {
	var z : set;;
	step 1 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 2 : wff = fvelimab () |- ( ( F Fn A ∧ Y ⊆ A ) → ( ( F ` X ) ∈ ( F " Y ) ↔ ∃ z ∈ Y ( F ` z ) = ( F ` X ) ) ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( F : A ↣ B ∧ Y ⊆ A ) → ( ( F ` X ) ∈ ( F " Y ) ↔ ∃ z ∈ Y ( F ` z ) = ( F ` X ) ) ) ;;
	step 4 : wff = 3adant2 (step 3) |- ( ( F : A ↣ B ∧ X ∈ A ∧ Y ⊆ A ) → ( ( F ` X ) ∈ ( F " Y ) ↔ ∃ z ∈ Y ( F ` z ) = ( F ` X ) ) ) ;;
	step 5 : wff = ssel () |- ( Y ⊆ A → ( z ∈ Y → z ∈ A ) ) ;;
	step 6 : wff = impac (step 5) |- ( ( Y ⊆ A ∧ z ∈ Y ) → ( z ∈ A ∧ z ∈ Y ) ) ;;
	step 7 : wff = f1fveq () |- ( ( F : A ↣ B ∧ ( z ∈ A ∧ X ∈ A ) ) → ( ( F ` z ) = ( F ` X ) ↔ z = X ) ) ;;
	step 8 : wff = ancom2s (step 7) |- ( ( F : A ↣ B ∧ ( X ∈ A ∧ z ∈ A ) ) → ( ( F ` z ) = ( F ` X ) ↔ z = X ) ) ;;
	step 9 : wff = biimpd (step 8) |- ( ( F : A ↣ B ∧ ( X ∈ A ∧ z ∈ A ) ) → ( ( F ` z ) = ( F ` X ) → z = X ) ) ;;
	step 10 : wff = anassrs (step 9) |- ( ( ( F : A ↣ B ∧ X ∈ A ) ∧ z ∈ A ) → ( ( F ` z ) = ( F ` X ) → z = X ) ) ;;
	step 11 : wff = eleq1 () |- ( z = X → ( z ∈ Y ↔ X ∈ Y ) ) ;;
	step 12 : wff = biimpcd (step 11) |- ( z ∈ Y → ( z = X → X ∈ Y ) ) ;;
	step 13 : wff = sylan9 (step 10, step 12) |- ( ( ( ( F : A ↣ B ∧ X ∈ A ) ∧ z ∈ A ) ∧ z ∈ Y ) → ( ( F ` z ) = ( F ` X ) → X ∈ Y ) ) ;;
	step 14 : wff = anasss (step 13) |- ( ( ( F : A ↣ B ∧ X ∈ A ) ∧ ( z ∈ A ∧ z ∈ Y ) ) → ( ( F ` z ) = ( F ` X ) → X ∈ Y ) ) ;;
	step 15 : wff = sylan2 (step 6, step 14) |- ( ( ( F : A ↣ B ∧ X ∈ A ) ∧ ( Y ⊆ A ∧ z ∈ Y ) ) → ( ( F ` z ) = ( F ` X ) → X ∈ Y ) ) ;;
	step 16 : wff = anassrs (step 15) |- ( ( ( ( F : A ↣ B ∧ X ∈ A ) ∧ Y ⊆ A ) ∧ z ∈ Y ) → ( ( F ` z ) = ( F ` X ) → X ∈ Y ) ) ;;
	step 17 : wff = rexlimdva (step 16) |- ( ( ( F : A ↣ B ∧ X ∈ A ) ∧ Y ⊆ A ) → ( ∃ z ∈ Y ( F ` z ) = ( F ` X ) → X ∈ Y ) ) ;;
	step 18 : wff = 3impa (step 17) |- ( ( F : A ↣ B ∧ X ∈ A ∧ Y ⊆ A ) → ( ∃ z ∈ Y ( F ` z ) = ( F ` X ) → X ∈ Y ) ) ;;
	step 19 : wff = eqid () |- ( F ` X ) = ( F ` X ) ;;
	step 20 : wff = fveq2 () |- ( z = X → ( F ` z ) = ( F ` X ) ) ;;
	step 21 : wff = eqeq1d (step 20) |- ( z = X → ( ( F ` z ) = ( F ` X ) ↔ ( F ` X ) = ( F ` X ) ) ) ;;
	step 22 : wff = rspcev (step 21) |- ( ( X ∈ Y ∧ ( F ` X ) = ( F ` X ) ) → ∃ z ∈ Y ( F ` z ) = ( F ` X ) ) ;;
	step 23 : wff = mpan2 (step 19, step 22) |- ( X ∈ Y → ∃ z ∈ Y ( F ` z ) = ( F ` X ) ) ;;
	step 24 : wff = impbid1 (step 18, step 23) |- ( ( F : A ↣ B ∧ X ∈ A ∧ Y ⊆ A ) → ( ∃ z ∈ Y ( F ` z ) = ( F ` X ) ↔ X ∈ Y ) ) ;;
	step 25 : wff = bitrd (step 4, step 24) |- ( ( F : A ↣ B ∧ X ∈ A ∧ Y ⊆ A ) → ( ( F ` X ) ∈ ( F " Y ) ↔ X ∈ Y ) ) ;;
	qed prop 1 = step 25 ;;
}

/*Taking images under a one-to-one function preserves subsets.
       (Contributed by Stefan O'Rear, 30-Oct-2014.) */

theorem f1imass (A : class, B : class, C : class, D : class, F : class) disjointed(F a, A a, B a, C a, D a) {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊆ ( F " D ) ↔ C ⊆ D ) ) ;;
}

proof of f1imass {
	var a : set;;
	step 1 : wff = simplrl () |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) → C ⊆ A ) ;;
	step 2 : wff = sseld (step 1) |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) → ( a ∈ C → a ∈ A ) ) ;;
	step 3 : wff = simplr () |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → ( F " C ) ⊆ ( F " D ) ) ;;
	step 4 : wff = sseld (step 3) |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → ( ( F ` a ) ∈ ( F " C ) → ( F ` a ) ∈ ( F " D ) ) ) ;;
	step 5 : wff = simplll () |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → F : A ↣ B ) ;;
	step 6 : wff = simpr () |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → a ∈ A ) ;;
	step 7 : wff = simp1rl () |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ∧ a ∈ A ) → C ⊆ A ) ;;
	step 8 : wff = 3expa (step 7) |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → C ⊆ A ) ;;
	step 9 : wff = f1elima () |- ( ( F : A ↣ B ∧ a ∈ A ∧ C ⊆ A ) → ( ( F ` a ) ∈ ( F " C ) ↔ a ∈ C ) ) ;;
	step 10 : wff = syl3anc (step 5, step 6, step 8, step 9) |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → ( ( F ` a ) ∈ ( F " C ) ↔ a ∈ C ) ) ;;
	step 11 : wff = simplll () |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → F : A ↣ B ) ;;
	step 12 : wff = simpr () |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → a ∈ A ) ;;
	step 13 : wff = simp1rr () |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ∧ a ∈ A ) → D ⊆ A ) ;;
	step 14 : wff = 3expa (step 13) |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → D ⊆ A ) ;;
	step 15 : wff = f1elima () |- ( ( F : A ↣ B ∧ a ∈ A ∧ D ⊆ A ) → ( ( F ` a ) ∈ ( F " D ) ↔ a ∈ D ) ) ;;
	step 16 : wff = syl3anc (step 11, step 12, step 14, step 15) |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → ( ( F ` a ) ∈ ( F " D ) ↔ a ∈ D ) ) ;;
	step 17 : wff = 3imtr3d (step 4, step 10, step 16) |- ( ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) ∧ a ∈ A ) → ( a ∈ C → a ∈ D ) ) ;;
	step 18 : wff = ex (step 17) |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) → ( a ∈ A → ( a ∈ C → a ∈ D ) ) ) ;;
	step 19 : wff = syld (step 2, step 18) |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) → ( a ∈ C → ( a ∈ C → a ∈ D ) ) ) ;;
	step 20 : wff = pm2.43d (step 19) |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) → ( a ∈ C → a ∈ D ) ) ;;
	step 21 : wff = ssrdv (step 20) |- ( ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) ∧ ( F " C ) ⊆ ( F " D ) ) → C ⊆ D ) ;;
	step 22 : wff = ex (step 21) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊆ ( F " D ) → C ⊆ D ) ) ;;
	step 23 : wff = imass2 () |- ( C ⊆ D → ( F " C ) ⊆ ( F " D ) ) ;;
	step 24 : wff = impbid1 (step 22, step 23) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊆ ( F " D ) ↔ C ⊆ D ) ) ;;
	qed prop 1 = step 24 ;;
}

/*Taking images under a one-to-one function preserves equality.
       (Contributed by Stefan O'Rear, 30-Oct-2014.) */

theorem f1imaeq (A : class, B : class, C : class, D : class, F : class) disjointed(F, A, B, C, D) {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) = ( F " D ) ↔ C = D ) ) ;;
}

proof of f1imaeq {
	step 1 : wff = f1imass () |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊆ ( F " D ) ↔ C ⊆ D ) ) ;;
	step 2 : wff = f1imass () |- ( ( F : A ↣ B ∧ ( D ⊆ A ∧ C ⊆ A ) ) → ( ( F " D ) ⊆ ( F " C ) ↔ D ⊆ C ) ) ;;
	step 3 : wff = ancom2s (step 2) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " D ) ⊆ ( F " C ) ↔ D ⊆ C ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( ( F " C ) ⊆ ( F " D ) ∧ ( F " D ) ⊆ ( F " C ) ) ↔ ( C ⊆ D ∧ D ⊆ C ) ) ) ;;
	step 5 : wff = eqss () |- ( ( F " C ) = ( F " D ) ↔ ( ( F " C ) ⊆ ( F " D ) ∧ ( F " D ) ⊆ ( F " C ) ) ) ;;
	step 6 : wff = eqss () |- ( C = D ↔ ( C ⊆ D ∧ D ⊆ C ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) = ( F " D ) ↔ C = D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Taking images under a one-to-one function preserves proper subsets.
       (Contributed by Stefan O'Rear, 30-Oct-2014.) */

theorem f1imapss (A : class, B : class, C : class, D : class, F : class) disjointed(F, A, B, C, D) {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊂ ( F " D ) ↔ C ⊂ D ) ) ;;
}

proof of f1imapss {
	step 1 : wff = f1imass () |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊆ ( F " D ) ↔ C ⊆ D ) ) ;;
	step 2 : wff = f1imaeq () |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) = ( F " D ) ↔ C = D ) ) ;;
	step 3 : wff = notbid (step 2) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ¬ ( F " C ) = ( F " D ) ↔ ¬ C = D ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( ( F " C ) ⊆ ( F " D ) ∧ ¬ ( F " C ) = ( F " D ) ) ↔ ( C ⊆ D ∧ ¬ C = D ) ) ) ;;
	step 5 : wff = dfpss2 () |- ( ( F " C ) ⊂ ( F " D ) ↔ ( ( F " C ) ⊆ ( F " D ) ∧ ¬ ( F " C ) = ( F " D ) ) ) ;;
	step 6 : wff = dfpss2 () |- ( C ⊂ D ↔ ( C ⊆ D ∧ ¬ C = D ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( ( F : A ↣ B ∧ ( C ⊆ A ∧ D ⊆ A ) ) → ( ( F " C ) ⊂ ( F " D ) ↔ C ⊂ D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A one-to-one onto function in terms of function values.  (Contributed by
       NM, 29-Mar-2008.) */

theorem dff1o6 (x : set, y : set, A : class, B : class, F : class) disjointed(x y A, x y F) {
	prop 1 : wff = |- ( F : A ⤖ B ↔ ( F Fn A ∧ ran F = B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
}

proof of dff1o6 {
	step 1 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 2 : wff = dff13 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 3 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( F : A ↣ B ∧ F : A ↠ B ) ↔ ( ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ∧ ( F Fn A ∧ ran F = B ) ) ) ;;
	step 5 : wff = df-3an () |- ( ( F Fn A ∧ ran F = B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( ( F Fn A ∧ ran F = B ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 6 : wff = eqimss () |- ( ran F = B → ran F ⊆ B ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( F Fn A ∧ ran F = B ) → ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 8 : wff = df-f () |- ( F : A ⟶ B ↔ ( F Fn A ∧ ran F ⊆ B ) ) ;;
	step 9 : wff = sylibr (step 7, step 8) |- ( ( F Fn A ∧ ran F = B ) → F : A ⟶ B ) ;;
	step 10 : wff = pm4.71ri (step 9) |- ( ( F Fn A ∧ ran F = B ) ↔ ( F : A ⟶ B ∧ ( F Fn A ∧ ran F = B ) ) ) ;;
	step 11 : wff = anbi1i (step 10) |- ( ( ( F Fn A ∧ ran F = B ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( ( F : A ⟶ B ∧ ( F Fn A ∧ ran F = B ) ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 12 : wff = an32 () |- ( ( ( F : A ⟶ B ∧ ( F Fn A ∧ ran F = B ) ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ↔ ( ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ∧ ( F Fn A ∧ ran F = B ) ) ) ;;
	step 13 : wff = 3bitrri (step 5, step 11, step 12) |- ( ( ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ∧ ( F Fn A ∧ ran F = B ) ) ↔ ( F Fn A ∧ ran F = B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 14 : wff = 3bitri (step 1, step 4, step 13) |- ( F : A ⤖ B ↔ ( F Fn A ∧ ran F = B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	qed prop 1 = step 14 ;;
}

/*The converse value of the value of a one-to-one onto function.
     (Contributed by NM, 20-May-2004.) */

theorem f1ocnvfv1 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ⁻¹ F ` ( F ` C ) ) = C ) ;;
}

proof of f1ocnvfv1 {
	step 1 : wff = f1ococnv1 () |- ( F : A ⤖ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	step 2 : wff = fveq1d (step 1) |- ( F : A ⤖ B → ( ( ⁻¹ F ∘ F ) ` C ) = ( ( _I ↾ A ) ` C ) ) ;;
	step 3 : wff = adantr (step 2) |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( ⁻¹ F ∘ F ) ` C ) = ( ( _I ↾ A ) ` C ) ) ;;
	step 4 : wff = f1of () |- ( F : A ⤖ B → F : A ⟶ B ) ;;
	step 5 : wff = fvco3 () |- ( ( F : A ⟶ B ∧ C ∈ A ) → ( ( ⁻¹ F ∘ F ) ` C ) = ( ⁻¹ F ` ( F ` C ) ) ) ;;
	step 6 : wff = sylan (step 4, step 5) |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( ⁻¹ F ∘ F ) ` C ) = ( ⁻¹ F ` ( F ` C ) ) ) ;;
	step 7 : wff = fvresi () |- ( C ∈ A → ( ( _I ↾ A ) ` C ) = C ) ;;
	step 8 : wff = adantl (step 7) |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( _I ↾ A ) ` C ) = C ) ;;
	step 9 : wff = 3eqtr3d (step 3, step 6, step 8) |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ⁻¹ F ` ( F ` C ) ) = C ) ;;
	qed prop 1 = step 9 ;;
}

/*The value of the converse value of a one-to-one onto function.
     (Contributed by NM, 20-May-2004.) */

theorem f1ocnvfv2 (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( F ` ( ⁻¹ F ` C ) ) = C ) ;;
}

proof of f1ocnvfv2 {
	step 1 : wff = f1ococnv2 () |- ( F : A ⤖ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
	step 2 : wff = fveq1d (step 1) |- ( F : A ⤖ B → ( ( F ∘ ⁻¹ F ) ` C ) = ( ( _I ↾ B ) ` C ) ) ;;
	step 3 : wff = adantr (step 2) |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( ( F ∘ ⁻¹ F ) ` C ) = ( ( _I ↾ B ) ` C ) ) ;;
	step 4 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 5 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( F : A ⤖ B → ⁻¹ F : B ⟶ A ) ;;
	step 7 : wff = fvco3 () |- ( ( ⁻¹ F : B ⟶ A ∧ C ∈ B ) → ( ( F ∘ ⁻¹ F ) ` C ) = ( F ` ( ⁻¹ F ` C ) ) ) ;;
	step 8 : wff = sylan (step 6, step 7) |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( ( F ∘ ⁻¹ F ) ` C ) = ( F ` ( ⁻¹ F ` C ) ) ) ;;
	step 9 : wff = fvresi () |- ( C ∈ B → ( ( _I ↾ B ) ` C ) = C ) ;;
	step 10 : wff = adantl (step 9) |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( ( _I ↾ B ) ` C ) = C ) ;;
	step 11 : wff = 3eqtr3d (step 3, step 8, step 10) |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( F ` ( ⁻¹ F ` C ) ) = C ) ;;
	qed prop 1 = step 11 ;;
}

/*Relationship between the value of a one-to-one onto function and the value
     of its converse.  (Contributed by Raph Levien, 10-Apr-2004.) */

theorem f1ocnvfv (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( F ` C ) = D → ( ⁻¹ F ` D ) = C ) ) ;;
}

proof of f1ocnvfv {
	step 1 : wff = fveq2 () |- ( D = ( F ` C ) → ( ⁻¹ F ` D ) = ( ⁻¹ F ` ( F ` C ) ) ) ;;
	step 2 : wff = eqcoms (step 1) |- ( ( F ` C ) = D → ( ⁻¹ F ` D ) = ( ⁻¹ F ` ( F ` C ) ) ) ;;
	step 3 : wff = f1ocnvfv1 () |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ⁻¹ F ` ( F ` C ) ) = C ) ;;
	step 4 : wff = eqeq2d (step 3) |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( ⁻¹ F ` D ) = ( ⁻¹ F ` ( F ` C ) ) ↔ ( ⁻¹ F ` D ) = C ) ) ;;
	step 5 : wff = syl5ib (step 2, step 4) |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( F ` C ) = D → ( ⁻¹ F ` D ) = C ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Relationship between the value of a one-to-one onto function and the value
     of its converse.  (Contributed by NM, 20-May-2004.) */

theorem f1ocnvfvb (A : class, B : class, C : class, D : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( F ` C ) = D ↔ ( ⁻¹ F ` D ) = C ) ) ;;
}

proof of f1ocnvfvb {
	step 1 : wff = f1ocnvfv () |- ( ( F : A ⤖ B ∧ C ∈ A ) → ( ( F ` C ) = D → ( ⁻¹ F ` D ) = C ) ) ;;
	step 2 : wff = 3adant3 (step 1) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( F ` C ) = D → ( ⁻¹ F ` D ) = C ) ) ;;
	step 3 : wff = fveq2 () |- ( C = ( ⁻¹ F ` D ) → ( F ` C ) = ( F ` ( ⁻¹ F ` D ) ) ) ;;
	step 4 : wff = eqcoms (step 3) |- ( ( ⁻¹ F ` D ) = C → ( F ` C ) = ( F ` ( ⁻¹ F ` D ) ) ) ;;
	step 5 : wff = f1ocnvfv2 () |- ( ( F : A ⤖ B ∧ D ∈ B ) → ( F ` ( ⁻¹ F ` D ) ) = D ) ;;
	step 6 : wff = eqeq2d (step 5) |- ( ( F : A ⤖ B ∧ D ∈ B ) → ( ( F ` C ) = ( F ` ( ⁻¹ F ` D ) ) ↔ ( F ` C ) = D ) ) ;;
	step 7 : wff = syl5ib (step 4, step 6) |- ( ( F : A ⤖ B ∧ D ∈ B ) → ( ( ⁻¹ F ` D ) = C → ( F ` C ) = D ) ) ;;
	step 8 : wff = 3adant2 (step 7) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ⁻¹ F ` D ) = C → ( F ` C ) = D ) ) ;;
	step 9 : wff = impbid (step 2, step 8) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( F ` C ) = D ↔ ( ⁻¹ F ` D ) = C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*The value of the converse of a one-to-one onto function belongs to its
     domain.  (Contributed by NM, 26-May-2006.) */

theorem f1ocnvdm (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( ⁻¹ F ` C ) ∈ A ) ;;
}

proof of f1ocnvdm {
	step 1 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 2 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F : A ⤖ B → ⁻¹ F : B ⟶ A ) ;;
	step 4 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ C ∈ B ) → ( ⁻¹ F ` C ) ∈ A ) ;;
	step 5 : wff = sylan (step 3, step 4) |- ( ( F : A ⤖ B ∧ C ∈ B ) → ( ⁻¹ F ` C ) ∈ A ) ;;
	qed prop 1 = step 5 ;;
}

/*An application is injective if a retraction exists.  Proposition 8 of
       [BourbakiEns] p.  E.II.18.  (Contributed by FL, 11-Nov-2011.)  (Revised
       by Mario Carneiro, 27-Dec-2014.) */

theorem fcof1 (A : class, B : class, R : class, F : class) disjointed(A x y, B x y, F x y, R x y) {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) → F : A ↣ B ) ;;
}

proof of fcof1 {
	var x : set, y : set;;
	step 1 : wff = simpl () |- ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) → F : A ⟶ B ) ;;
	step 2 : wff = simprr () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( F ` x ) = ( F ` y ) ) ;;
	step 3 : wff = fveq2d (step 2) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( R ` ( F ` x ) ) = ( R ` ( F ` y ) ) ) ;;
	step 4 : wff = simpll () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → F : A ⟶ B ) ;;
	step 5 : wff = simprll () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → x ∈ A ) ;;
	step 6 : wff = fvco3 () |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( ( R ∘ F ) ` x ) = ( R ` ( F ` x ) ) ) ;;
	step 7 : wff = syl2anc (step 4, step 5, step 6) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( R ∘ F ) ` x ) = ( R ` ( F ` x ) ) ) ;;
	step 8 : wff = simpll () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → F : A ⟶ B ) ;;
	step 9 : wff = simprlr () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → y ∈ A ) ;;
	step 10 : wff = fvco3 () |- ( ( F : A ⟶ B ∧ y ∈ A ) → ( ( R ∘ F ) ` y ) = ( R ` ( F ` y ) ) ) ;;
	step 11 : wff = syl2anc (step 8, step 9, step 10) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( R ∘ F ) ` y ) = ( R ` ( F ` y ) ) ) ;;
	step 12 : wff = 3eqtr4d (step 3, step 7, step 11) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( R ∘ F ) ` x ) = ( ( R ∘ F ) ` y ) ) ;;
	step 13 : wff = simplr () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( R ∘ F ) = ( _I ↾ A ) ) ;;
	step 14 : wff = fveq1d (step 13) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( R ∘ F ) ` x ) = ( ( _I ↾ A ) ` x ) ) ;;
	step 15 : wff = simplr () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( R ∘ F ) = ( _I ↾ A ) ) ;;
	step 16 : wff = fveq1d (step 15) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( R ∘ F ) ` y ) = ( ( _I ↾ A ) ` y ) ) ;;
	step 17 : wff = 3eqtr3d (step 12, step 14, step 16) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( _I ↾ A ) ` x ) = ( ( _I ↾ A ) ` y ) ) ;;
	step 18 : wff = simprll () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → x ∈ A ) ;;
	step 19 : wff = fvresi () |- ( x ∈ A → ( ( _I ↾ A ) ` x ) = x ) ;;
	step 20 : wff = syl (step 18, step 19) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( _I ↾ A ) ` x ) = x ) ;;
	step 21 : wff = simprlr () |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → y ∈ A ) ;;
	step 22 : wff = fvresi () |- ( y ∈ A → ( ( _I ↾ A ) ` y ) = y ) ;;
	step 23 : wff = syl (step 21, step 22) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → ( ( _I ↾ A ) ` y ) = y ) ;;
	step 24 : wff = 3eqtr3d (step 17, step 20, step 23) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( ( x ∈ A ∧ y ∈ A ) ∧ ( F ` x ) = ( F ` y ) ) ) → x = y ) ;;
	step 25 : wff = expr (step 24) |- ( ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( F ` x ) = ( F ` y ) → x = y ) ) ;;
	step 26 : wff = ralrimivva (step 25) |- ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) → ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ;;
	step 27 : wff = dff13 () |- ( F : A ↣ B ↔ ( F : A ⟶ B ∧ ∀ x ∈ A ∀ y ∈ A ( ( F ` x ) = ( F ` y ) → x = y ) ) ) ;;
	step 28 : wff = sylanbrc (step 1, step 26, step 27) |- ( ( F : A ⟶ B ∧ ( R ∘ F ) = ( _I ↾ A ) ) → F : A ↣ B ) ;;
	qed prop 1 = step 28 ;;
}

/*An application is surjective if a section exists.  Proposition 8 of
       [BourbakiEns] p.  E.II.18.  (Contributed by FL, 17-Nov-2011.)  (Proof
       shortened by Mario Carneiro, 27-Dec-2014.) */

theorem fcofo (A : class, B : class, S : class, F : class) disjointed(A x y, B x y, F x y, S x y) {
	prop 1 : wff = |- ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
}

proof of fcofo {
	var x : set, y : set;;
	step 1 : wff = simp1 () |- ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) → F : A ⟶ B ) ;;
	step 2 : wff = ffvelrn () |- ( ( S : B ⟶ A ∧ y ∈ B ) → ( S ` y ) ∈ A ) ;;
	step 3 : wff = 3ad2antl2 (step 2) |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → ( S ` y ) ∈ A ) ;;
	step 4 : wff = simpl3 () |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → ( F ∘ S ) = ( _I ↾ B ) ) ;;
	step 5 : wff = fveq1d (step 4) |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → ( ( F ∘ S ) ` y ) = ( ( _I ↾ B ) ` y ) ) ;;
	step 6 : wff = fvco3 () |- ( ( S : B ⟶ A ∧ y ∈ B ) → ( ( F ∘ S ) ` y ) = ( F ` ( S ` y ) ) ) ;;
	step 7 : wff = 3ad2antl2 (step 6) |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → ( ( F ∘ S ) ` y ) = ( F ` ( S ` y ) ) ) ;;
	step 8 : wff = fvresi () |- ( y ∈ B → ( ( _I ↾ B ) ` y ) = y ) ;;
	step 9 : wff = adantl (step 8) |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → ( ( _I ↾ B ) ` y ) = y ) ;;
	step 10 : wff = 3eqtr3rd (step 5, step 7, step 9) |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → y = ( F ` ( S ` y ) ) ) ;;
	step 11 : wff = fveq2 () |- ( x = ( S ` y ) → ( F ` x ) = ( F ` ( S ` y ) ) ) ;;
	step 12 : wff = eqeq2d (step 11) |- ( x = ( S ` y ) → ( y = ( F ` x ) ↔ y = ( F ` ( S ` y ) ) ) ) ;;
	step 13 : wff = rspcev (step 12) |- ( ( ( S ` y ) ∈ A ∧ y = ( F ` ( S ` y ) ) ) → ∃ x ∈ A y = ( F ` x ) ) ;;
	step 14 : wff = syl2anc (step 3, step 10, step 13) |- ( ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) ∧ y ∈ B ) → ∃ x ∈ A y = ( F ` x ) ) ;;
	step 15 : wff = ralrimiva (step 14) |- ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) → ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ;;
	step 16 : wff = dffo3 () |- ( F : A ↠ B ↔ ( F : A ⟶ B ∧ ∀ y ∈ B ∃ x ∈ A y = ( F ` x ) ) ) ;;
	step 17 : wff = sylanbrc (step 1, step 15, step 16) |- ( ( F : A ⟶ B ∧ S : B ⟶ A ∧ ( F ∘ S ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	qed prop 1 = step 17 ;;
}

/*Change bound variable between domain and range of function.
       (Contributed by NM, 23-Feb-1997.)  (Proof shortened by Mario Carneiro,
       21-Mar-2015.) */

theorem cbvfo (ph : wff, ps : wff, x : set, y : set, A : class, B : class, F : class) disjointed(x y A, y B, x y F, y ph, x ps) {
	hyp 1 : wff = |- ( ( F ` x ) = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( F : A ↠ B → ( ∀ x ∈ A ph ↔ ∀ y ∈ B ps ) ) ;;
}

proof of cbvfo {
	step 1 : wff = fofn () |- ( F : A ↠ B → F Fn A ) ;;
	step 2 : wff = bicomd (hyp 1) |- ( ( F ` x ) = y → ( ps ↔ ph ) ) ;;
	step 3 : wff = eqcoms (step 2) |- ( y = ( F ` x ) → ( ps ↔ ph ) ) ;;
	step 4 : wff = ralrn (step 3) |- ( F Fn A → ( ∀ y ∈ ran F ps ↔ ∀ x ∈ A ph ) ) ;;
	step 5 : wff = syl (step 1, step 4) |- ( F : A ↠ B → ( ∀ y ∈ ran F ps ↔ ∀ x ∈ A ph ) ) ;;
	step 6 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 7 : wff = raleqdv (step 6) |- ( F : A ↠ B → ( ∀ y ∈ ran F ps ↔ ∀ y ∈ B ps ) ) ;;
	step 8 : wff = bitr3d (step 5, step 7) |- ( F : A ↠ B → ( ∀ x ∈ A ph ↔ ∀ y ∈ B ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Change bound variable between domain and range of function.
       (Contributed by NM, 23-Feb-1997.) */

theorem cbvexfo (ph : wff, ps : wff, x : set, y : set, A : class, B : class, F : class) disjointed(x y A, y B, x y F, y ph, x ps) {
	hyp 1 : wff = |- ( ( F ` x ) = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( F : A ↠ B → ( ∃ x ∈ A ph ↔ ∃ y ∈ B ps ) ) ;;
}

proof of cbvexfo {
	step 1 : wff = notbid (hyp 1) |- ( ( F ` x ) = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = cbvfo (step 1) |- ( F : A ↠ B → ( ∀ x ∈ A ¬ ph ↔ ∀ y ∈ B ¬ ps ) ) ;;
	step 3 : wff = notbid (step 2) |- ( F : A ↠ B → ( ¬ ∀ x ∈ A ¬ ph ↔ ¬ ∀ y ∈ B ¬ ps ) ) ;;
	step 4 : wff = dfrex2 () |- ( ∃ x ∈ A ph ↔ ¬ ∀ x ∈ A ¬ ph ) ;;
	step 5 : wff = dfrex2 () |- ( ∃ y ∈ B ps ↔ ¬ ∀ y ∈ B ¬ ps ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( F : A ↠ B → ( ∃ x ∈ A ph ↔ ∃ y ∈ B ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/*An injection is left-cancelable.  (Contributed by FL, 2-Aug-2009.)
       (Revised by Mario Carneiro, 21-Mar-2015.) */

theorem cocan1 (A : class, B : class, C : class, F : class, H : class, K : class) disjointed(A x, B x, C x, F x, H x, K x) {
	prop 1 : wff = |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( ( F ∘ H ) = ( F ∘ K ) ↔ H = K ) ) ;;
}

proof of cocan1 {
	var x : set;;
	step 1 : wff = fvco3 () |- ( ( H : A ⟶ B ∧ x ∈ A ) → ( ( F ∘ H ) ` x ) = ( F ` ( H ` x ) ) ) ;;
	step 2 : wff = 3ad2antl2 (step 1) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( ( F ∘ H ) ` x ) = ( F ` ( H ` x ) ) ) ;;
	step 3 : wff = fvco3 () |- ( ( K : A ⟶ B ∧ x ∈ A ) → ( ( F ∘ K ) ` x ) = ( F ` ( K ` x ) ) ) ;;
	step 4 : wff = 3ad2antl3 (step 3) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( ( F ∘ K ) ` x ) = ( F ` ( K ` x ) ) ) ;;
	step 5 : wff = eqeq12d (step 2, step 4) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( ( ( F ∘ H ) ` x ) = ( ( F ∘ K ) ` x ) ↔ ( F ` ( H ` x ) ) = ( F ` ( K ` x ) ) ) ) ;;
	step 6 : wff = simpl1 () |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → F : B ↣ C ) ;;
	step 7 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ x ∈ A ) → ( H ` x ) ∈ B ) ;;
	step 8 : wff = 3ad2antl2 (step 7) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( H ` x ) ∈ B ) ;;
	step 9 : wff = ffvelrn () |- ( ( K : A ⟶ B ∧ x ∈ A ) → ( K ` x ) ∈ B ) ;;
	step 10 : wff = 3ad2antl3 (step 9) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( K ` x ) ∈ B ) ;;
	step 11 : wff = f1fveq () |- ( ( F : B ↣ C ∧ ( ( H ` x ) ∈ B ∧ ( K ` x ) ∈ B ) ) → ( ( F ` ( H ` x ) ) = ( F ` ( K ` x ) ) ↔ ( H ` x ) = ( K ` x ) ) ) ;;
	step 12 : wff = syl12anc (step 6, step 8, step 10, step 11) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( ( F ` ( H ` x ) ) = ( F ` ( K ` x ) ) ↔ ( H ` x ) = ( K ` x ) ) ) ;;
	step 13 : wff = bitrd (step 5, step 12) |- ( ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) ∧ x ∈ A ) → ( ( ( F ∘ H ) ` x ) = ( ( F ∘ K ) ` x ) ↔ ( H ` x ) = ( K ` x ) ) ) ;;
	step 14 : wff = ralbidva (step 13) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( ∀ x ∈ A ( ( F ∘ H ) ` x ) = ( ( F ∘ K ) ` x ) ↔ ∀ x ∈ A ( H ` x ) = ( K ` x ) ) ) ;;
	step 15 : wff = f1f () |- ( F : B ↣ C → F : B ⟶ C ) ;;
	step 16 : wff = 3ad2ant1 (step 15) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → F : B ⟶ C ) ;;
	step 17 : wff = ffn () |- ( F : B ⟶ C → F Fn B ) ;;
	step 18 : wff = syl (step 16, step 17) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → F Fn B ) ;;
	step 19 : wff = simp2 () |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → H : A ⟶ B ) ;;
	step 20 : wff = fnfco () |- ( ( F Fn B ∧ H : A ⟶ B ) → ( F ∘ H ) Fn A ) ;;
	step 21 : wff = syl2anc (step 18, step 19, step 20) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( F ∘ H ) Fn A ) ;;
	step 22 : wff = f1f () |- ( F : B ↣ C → F : B ⟶ C ) ;;
	step 23 : wff = 3ad2ant1 (step 22) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → F : B ⟶ C ) ;;
	step 24 : wff = ffn () |- ( F : B ⟶ C → F Fn B ) ;;
	step 25 : wff = syl (step 23, step 24) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → F Fn B ) ;;
	step 26 : wff = simp3 () |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → K : A ⟶ B ) ;;
	step 27 : wff = fnfco () |- ( ( F Fn B ∧ K : A ⟶ B ) → ( F ∘ K ) Fn A ) ;;
	step 28 : wff = syl2anc (step 25, step 26, step 27) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( F ∘ K ) Fn A ) ;;
	step 29 : wff = eqfnfv () |- ( ( ( F ∘ H ) Fn A ∧ ( F ∘ K ) Fn A ) → ( ( F ∘ H ) = ( F ∘ K ) ↔ ∀ x ∈ A ( ( F ∘ H ) ` x ) = ( ( F ∘ K ) ` x ) ) ) ;;
	step 30 : wff = syl2anc (step 21, step 28, step 29) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( ( F ∘ H ) = ( F ∘ K ) ↔ ∀ x ∈ A ( ( F ∘ H ) ` x ) = ( ( F ∘ K ) ` x ) ) ) ;;
	step 31 : wff = simp2 () |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → H : A ⟶ B ) ;;
	step 32 : wff = ffn () |- ( H : A ⟶ B → H Fn A ) ;;
	step 33 : wff = syl (step 31, step 32) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → H Fn A ) ;;
	step 34 : wff = simp3 () |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → K : A ⟶ B ) ;;
	step 35 : wff = ffn () |- ( K : A ⟶ B → K Fn A ) ;;
	step 36 : wff = syl (step 34, step 35) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → K Fn A ) ;;
	step 37 : wff = eqfnfv () |- ( ( H Fn A ∧ K Fn A ) → ( H = K ↔ ∀ x ∈ A ( H ` x ) = ( K ` x ) ) ) ;;
	step 38 : wff = syl2anc (step 33, step 36, step 37) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( H = K ↔ ∀ x ∈ A ( H ` x ) = ( K ` x ) ) ) ;;
	step 39 : wff = 3bitr4d (step 14, step 30, step 38) |- ( ( F : B ↣ C ∧ H : A ⟶ B ∧ K : A ⟶ B ) → ( ( F ∘ H ) = ( F ∘ K ) ↔ H = K ) ) ;;
	qed prop 1 = step 39 ;;
}

/*A surjection is right-cancelable.  (Contributed by FL, 21-Nov-2011.)
       (Proof shortened by Mario Carneiro, 21-Mar-2015.) */

theorem cocan2 (A : class, B : class, F : class, H : class, K : class) disjointed(x y A, x y B, x y F, x y H, x y K) {
	prop 1 : wff = |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( ( H ∘ F ) = ( K ∘ F ) ↔ H = K ) ) ;;
}

proof of cocan2 {
	var x : set, y : set;;
	step 1 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 2 : wff = 3ad2ant1 (step 1) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → F : A ⟶ B ) ;;
	step 3 : wff = fvco3 () |- ( ( F : A ⟶ B ∧ y ∈ A ) → ( ( H ∘ F ) ` y ) = ( H ` ( F ` y ) ) ) ;;
	step 4 : wff = sylan (step 2, step 3) |- ( ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) ∧ y ∈ A ) → ( ( H ∘ F ) ` y ) = ( H ` ( F ` y ) ) ) ;;
	step 5 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 6 : wff = 3ad2ant1 (step 5) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → F : A ⟶ B ) ;;
	step 7 : wff = fvco3 () |- ( ( F : A ⟶ B ∧ y ∈ A ) → ( ( K ∘ F ) ` y ) = ( K ` ( F ` y ) ) ) ;;
	step 8 : wff = sylan (step 6, step 7) |- ( ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) ∧ y ∈ A ) → ( ( K ∘ F ) ` y ) = ( K ` ( F ` y ) ) ) ;;
	step 9 : wff = eqeq12d (step 4, step 8) |- ( ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) ∧ y ∈ A ) → ( ( ( H ∘ F ) ` y ) = ( ( K ∘ F ) ` y ) ↔ ( H ` ( F ` y ) ) = ( K ` ( F ` y ) ) ) ) ;;
	step 10 : wff = ralbidva (step 9) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( ∀ y ∈ A ( ( H ∘ F ) ` y ) = ( ( K ∘ F ) ` y ) ↔ ∀ y ∈ A ( H ` ( F ` y ) ) = ( K ` ( F ` y ) ) ) ) ;;
	step 11 : wff = fveq2 () |- ( ( F ` y ) = x → ( H ` ( F ` y ) ) = ( H ` x ) ) ;;
	step 12 : wff = fveq2 () |- ( ( F ` y ) = x → ( K ` ( F ` y ) ) = ( K ` x ) ) ;;
	step 13 : wff = eqeq12d (step 11, step 12) |- ( ( F ` y ) = x → ( ( H ` ( F ` y ) ) = ( K ` ( F ` y ) ) ↔ ( H ` x ) = ( K ` x ) ) ) ;;
	step 14 : wff = cbvfo (step 13) |- ( F : A ↠ B → ( ∀ y ∈ A ( H ` ( F ` y ) ) = ( K ` ( F ` y ) ) ↔ ∀ x ∈ B ( H ` x ) = ( K ` x ) ) ) ;;
	step 15 : wff = 3ad2ant1 (step 14) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( ∀ y ∈ A ( H ` ( F ` y ) ) = ( K ` ( F ` y ) ) ↔ ∀ x ∈ B ( H ` x ) = ( K ` x ) ) ) ;;
	step 16 : wff = bitrd (step 10, step 15) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( ∀ y ∈ A ( ( H ∘ F ) ` y ) = ( ( K ∘ F ) ` y ) ↔ ∀ x ∈ B ( H ` x ) = ( K ` x ) ) ) ;;
	step 17 : wff = simp2 () |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → H Fn B ) ;;
	step 18 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 19 : wff = 3ad2ant1 (step 18) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → F : A ⟶ B ) ;;
	step 20 : wff = fnfco () |- ( ( H Fn B ∧ F : A ⟶ B ) → ( H ∘ F ) Fn A ) ;;
	step 21 : wff = syl2anc (step 17, step 19, step 20) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( H ∘ F ) Fn A ) ;;
	step 22 : wff = simp3 () |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → K Fn B ) ;;
	step 23 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 24 : wff = 3ad2ant1 (step 23) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → F : A ⟶ B ) ;;
	step 25 : wff = fnfco () |- ( ( K Fn B ∧ F : A ⟶ B ) → ( K ∘ F ) Fn A ) ;;
	step 26 : wff = syl2anc (step 22, step 24, step 25) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( K ∘ F ) Fn A ) ;;
	step 27 : wff = eqfnfv () |- ( ( ( H ∘ F ) Fn A ∧ ( K ∘ F ) Fn A ) → ( ( H ∘ F ) = ( K ∘ F ) ↔ ∀ y ∈ A ( ( H ∘ F ) ` y ) = ( ( K ∘ F ) ` y ) ) ) ;;
	step 28 : wff = syl2anc (step 21, step 26, step 27) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( ( H ∘ F ) = ( K ∘ F ) ↔ ∀ y ∈ A ( ( H ∘ F ) ` y ) = ( ( K ∘ F ) ` y ) ) ) ;;
	step 29 : wff = simp2 () |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → H Fn B ) ;;
	step 30 : wff = simp3 () |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → K Fn B ) ;;
	step 31 : wff = eqfnfv () |- ( ( H Fn B ∧ K Fn B ) → ( H = K ↔ ∀ x ∈ B ( H ` x ) = ( K ` x ) ) ) ;;
	step 32 : wff = syl2anc (step 29, step 30, step 31) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( H = K ↔ ∀ x ∈ B ( H ` x ) = ( K ` x ) ) ) ;;
	step 33 : wff = 3bitr4d (step 16, step 28, step 32) |- ( ( F : A ↠ B ∧ H Fn B ∧ K Fn B ) → ( ( H ∘ F ) = ( K ∘ F ) ↔ H = K ) ) ;;
	qed prop 1 = step 33 ;;
}

/*Show that two functions are inverse to each other by computing their
       compositions.  (Contributed by Mario Carneiro, 21-Mar-2015.) */

theorem fcof1o (A : class, B : class, F : class, G : class) disjointed(A, B, F) {
	prop 1 : wff = |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( F : A ⤖ B ∧ ⁻¹ F = G ) ) ;;
}

proof of fcof1o {
	step 1 : wff = fcof1 () |- ( ( F : A ⟶ B ∧ ( G ∘ F ) = ( _I ↾ A ) ) → F : A ↣ B ) ;;
	step 2 : wff = ad2ant2rl (step 1) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ↣ B ) ;;
	step 3 : wff = fcofo () |- ( ( F : A ⟶ B ∧ G : B ⟶ A ∧ ( F ∘ G ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	step 4 : wff = 3expa (step 3) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( F ∘ G ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	step 5 : wff = adantrr (step 4) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ↠ B ) ;;
	step 6 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 7 : wff = sylanbrc (step 2, step 5, step 6) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ⤖ B ) ;;
	step 8 : wff = simprl () |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( F ∘ G ) = ( _I ↾ B ) ) ;;
	step 9 : wff = coeq2d (step 8) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ⁻¹ F ∘ ( F ∘ G ) ) = ( ⁻¹ F ∘ ( _I ↾ B ) ) ) ;;
	step 10 : wff = coass () |- ( ( ⁻¹ F ∘ F ) ∘ G ) = ( ⁻¹ F ∘ ( F ∘ G ) ) ;;
	step 11 : wff = fcof1 () |- ( ( F : A ⟶ B ∧ ( G ∘ F ) = ( _I ↾ A ) ) → F : A ↣ B ) ;;
	step 12 : wff = ad2ant2rl (step 11) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ↣ B ) ;;
	step 13 : wff = fcofo () |- ( ( F : A ⟶ B ∧ G : B ⟶ A ∧ ( F ∘ G ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	step 14 : wff = 3expa (step 13) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( F ∘ G ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	step 15 : wff = adantrr (step 14) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ↠ B ) ;;
	step 16 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 17 : wff = sylanbrc (step 12, step 15, step 16) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ⤖ B ) ;;
	step 18 : wff = f1ococnv1 () |- ( F : A ⤖ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	step 19 : wff = syl (step 17, step 18) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	step 20 : wff = coeq1d (step 19) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ( ⁻¹ F ∘ F ) ∘ G ) = ( ( _I ↾ A ) ∘ G ) ) ;;
	step 21 : wff = fcoi2 () |- ( G : B ⟶ A → ( ( _I ↾ A ) ∘ G ) = G ) ;;
	step 22 : wff = ad2antlr (step 21) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ( _I ↾ A ) ∘ G ) = G ) ;;
	step 23 : wff = eqtrd (step 20, step 22) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ( ⁻¹ F ∘ F ) ∘ G ) = G ) ;;
	step 24 : wff = syl5eqr (step 10, step 23) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ⁻¹ F ∘ ( F ∘ G ) ) = G ) ;;
	step 25 : wff = fcof1 () |- ( ( F : A ⟶ B ∧ ( G ∘ F ) = ( _I ↾ A ) ) → F : A ↣ B ) ;;
	step 26 : wff = ad2ant2rl (step 25) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ↣ B ) ;;
	step 27 : wff = fcofo () |- ( ( F : A ⟶ B ∧ G : B ⟶ A ∧ ( F ∘ G ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	step 28 : wff = 3expa (step 27) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( F ∘ G ) = ( _I ↾ B ) ) → F : A ↠ B ) ;;
	step 29 : wff = adantrr (step 28) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ↠ B ) ;;
	step 30 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 31 : wff = sylanbrc (step 26, step 29, step 30) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → F : A ⤖ B ) ;;
	step 32 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 33 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 34 : wff = 3syl (step 31, step 32, step 33) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ⁻¹ F : B ⟶ A ) ;;
	step 35 : wff = fcoi1 () |- ( ⁻¹ F : B ⟶ A → ( ⁻¹ F ∘ ( _I ↾ B ) ) = ⁻¹ F ) ;;
	step 36 : wff = syl (step 34, step 35) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( ⁻¹ F ∘ ( _I ↾ B ) ) = ⁻¹ F ) ;;
	step 37 : wff = 3eqtr3rd (step 9, step 24, step 36) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ⁻¹ F = G ) ;;
	step 38 : wff = jca (step 7, step 37) |- ( ( ( F : A ⟶ B ∧ G : B ⟶ A ) ∧ ( ( F ∘ G ) = ( _I ↾ B ) ∧ ( G ∘ F ) = ( _I ↾ A ) ) ) → ( F : A ⤖ B ∧ ⁻¹ F = G ) ) ;;
	qed prop 1 = step 38 ;;
}

/*Condition for function equality in terms of vanishing of the composition
       with the converse. _EDITORIAL_:  Is there a relation-algebraic proof of
       this?  (Contributed by Stefan O'Rear, 12-Feb-2015.) */

theorem foeqcnvco (A : class, B : class, F : class, G : class) disjointed(F x y, G x y, A x y, B x y) {
	prop 1 : wff = |- ( ( F : A ↠ B ∧ G : A ↠ B ) → ( F = G ↔ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ) ;;
}

proof of foeqcnvco {
	var x : set, y : set;;
	step 1 : wff = fococnv2 () |- ( F : A ↠ B → ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ) ;;
	step 2 : wff = cnveq () |- ( F = G → ⁻¹ F = ⁻¹ G ) ;;
	step 3 : wff = coeq2d (step 2) |- ( F = G → ( F ∘ ⁻¹ F ) = ( F ∘ ⁻¹ G ) ) ;;
	step 4 : wff = eqeq1d (step 3) |- ( F = G → ( ( F ∘ ⁻¹ F ) = ( _I ↾ B ) ↔ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ) ;;
	step 5 : wff = syl5ibcom (step 1, step 4) |- ( F : A ↠ B → ( F = G → ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ) ;;
	step 6 : wff = adantr (step 5) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → ( F = G → ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ) ;;
	step 7 : wff = fofn () |- ( F : A ↠ B → F Fn A ) ;;
	step 8 : wff = ad2antrr (step 7) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) → F Fn A ) ;;
	step 9 : wff = fofn () |- ( G : A ↠ B → G Fn A ) ;;
	step 10 : wff = ad2antlr (step 9) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) → G Fn A ) ;;
	step 11 : wff = fofn () |- ( G : A ↠ B → G Fn A ) ;;
	step 12 : wff = adantl (step 11) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → G Fn A ) ;;
	step 13 : wff = fnopfv () |- ( ( G Fn A ∧ x ∈ A ) → 〈 x , ( G ` x ) 〉 ∈ G ) ;;
	step 14 : wff = sylan (step 12, step 13) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → 〈 x , ( G ` x ) 〉 ∈ G ) ;;
	step 15 : wff = fvex () |- ( G ` x ) ∈ _V ;;
	step 16 : wff = vex () |- x ∈ _V ;;
	step 17 : wff = brcnv (step 15, step 16) |- ( ( G ` x ) ⁻¹ G x ↔ x G ( G ` x ) ) ;;
	step 18 : wff = df-br () |- ( x G ( G ` x ) ↔ 〈 x , ( G ` x ) 〉 ∈ G ) ;;
	step 19 : wff = bitri (step 17, step 18) |- ( ( G ` x ) ⁻¹ G x ↔ 〈 x , ( G ` x ) 〉 ∈ G ) ;;
	step 20 : wff = sylibr (step 14, step 19) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → ( G ` x ) ⁻¹ G x ) ;;
	step 21 : wff = fofn () |- ( F : A ↠ B → F Fn A ) ;;
	step 22 : wff = adantr (step 21) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → F Fn A ) ;;
	step 23 : wff = fnopfv () |- ( ( F Fn A ∧ x ∈ A ) → 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 24 : wff = sylan (step 22, step 23) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 25 : wff = df-br () |- ( x F ( F ` x ) ↔ 〈 x , ( F ` x ) 〉 ∈ F ) ;;
	step 26 : wff = sylibr (step 24, step 25) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → x F ( F ` x ) ) ;;
	step 27 : wff = vex () |- x ∈ _V ;;
	step 28 : wff = breq2 () |- ( y = x → ( ( G ` x ) ⁻¹ G y ↔ ( G ` x ) ⁻¹ G x ) ) ;;
	step 29 : wff = breq1 () |- ( y = x → ( y F ( F ` x ) ↔ x F ( F ` x ) ) ) ;;
	step 30 : wff = anbi12d (step 28, step 29) |- ( y = x → ( ( ( G ` x ) ⁻¹ G y ∧ y F ( F ` x ) ) ↔ ( ( G ` x ) ⁻¹ G x ∧ x F ( F ` x ) ) ) ) ;;
	step 31 : wff = spcev (step 27, step 30) |- ( ( ( G ` x ) ⁻¹ G x ∧ x F ( F ` x ) ) → ∃ y ( ( G ` x ) ⁻¹ G y ∧ y F ( F ` x ) ) ) ;;
	step 32 : wff = syl2anc (step 20, step 26, step 31) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → ∃ y ( ( G ` x ) ⁻¹ G y ∧ y F ( F ` x ) ) ) ;;
	step 33 : wff = fvex () |- ( G ` x ) ∈ _V ;;
	step 34 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 35 : wff = brco (step 33, step 34) |- ( ( G ` x ) ( F ∘ ⁻¹ G ) ( F ` x ) ↔ ∃ y ( ( G ` x ) ⁻¹ G y ∧ y F ( F ` x ) ) ) ;;
	step 36 : wff = sylibr (step 32, step 35) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → ( G ` x ) ( F ∘ ⁻¹ G ) ( F ` x ) ) ;;
	step 37 : wff = adantlr (step 36) |- ( ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ∧ x ∈ A ) → ( G ` x ) ( F ∘ ⁻¹ G ) ( F ` x ) ) ;;
	step 38 : wff = breq () |- ( ( F ∘ ⁻¹ G ) = ( _I ↾ B ) → ( ( G ` x ) ( F ∘ ⁻¹ G ) ( F ` x ) ↔ ( G ` x ) ( _I ↾ B ) ( F ` x ) ) ) ;;
	step 39 : wff = ad2antlr (step 38) |- ( ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ∧ x ∈ A ) → ( ( G ` x ) ( F ∘ ⁻¹ G ) ( F ` x ) ↔ ( G ` x ) ( _I ↾ B ) ( F ` x ) ) ) ;;
	step 40 : wff = mpbid (step 37, step 39) |- ( ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ∧ x ∈ A ) → ( G ` x ) ( _I ↾ B ) ( F ` x ) ) ;;
	step 41 : wff = fof () |- ( G : A ↠ B → G : A ⟶ B ) ;;
	step 42 : wff = adantl (step 41) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → G : A ⟶ B ) ;;
	step 43 : wff = ffvelrn () |- ( ( G : A ⟶ B ∧ x ∈ A ) → ( G ` x ) ∈ B ) ;;
	step 44 : wff = sylan (step 42, step 43) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → ( G ` x ) ∈ B ) ;;
	step 45 : wff = fof () |- ( F : A ↠ B → F : A ⟶ B ) ;;
	step 46 : wff = adantr (step 45) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → F : A ⟶ B ) ;;
	step 47 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( F ` x ) ∈ B ) ;;
	step 48 : wff = sylan (step 46, step 47) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → ( F ` x ) ∈ B ) ;;
	step 49 : wff = resieq () |- ( ( ( G ` x ) ∈ B ∧ ( F ` x ) ∈ B ) → ( ( G ` x ) ( _I ↾ B ) ( F ` x ) ↔ ( G ` x ) = ( F ` x ) ) ) ;;
	step 50 : wff = syl2anc (step 44, step 48, step 49) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ x ∈ A ) → ( ( G ` x ) ( _I ↾ B ) ( F ` x ) ↔ ( G ` x ) = ( F ` x ) ) ) ;;
	step 51 : wff = adantlr (step 50) |- ( ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ∧ x ∈ A ) → ( ( G ` x ) ( _I ↾ B ) ( F ` x ) ↔ ( G ` x ) = ( F ` x ) ) ) ;;
	step 52 : wff = mpbid (step 40, step 51) |- ( ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ∧ x ∈ A ) → ( G ` x ) = ( F ` x ) ) ;;
	step 53 : wff = eqcomd (step 52) |- ( ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ∧ x ∈ A ) → ( F ` x ) = ( G ` x ) ) ;;
	step 54 : wff = eqfnfvd (step 8, step 10, step 53) |- ( ( ( F : A ↠ B ∧ G : A ↠ B ) ∧ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) → F = G ) ;;
	step 55 : wff = ex (step 54) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → ( ( F ∘ ⁻¹ G ) = ( _I ↾ B ) → F = G ) ) ;;
	step 56 : wff = impbid (step 6, step 55) |- ( ( F : A ↠ B ∧ G : A ↠ B ) → ( F = G ↔ ( F ∘ ⁻¹ G ) = ( _I ↾ B ) ) ) ;;
	qed prop 1 = step 56 ;;
}

/*Condition for function equality in terms of vanishing of the composition
       with the inverse.  (Contributed by Stefan O'Rear, 12-Feb-2015.) */

theorem f1eqcocnv (A : class, B : class, F : class, G : class) disjointed(F x y, G x y, A x y, B x y) {
	prop 1 : wff = |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( F = G ↔ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
}

proof of f1eqcocnv {
	var x : set, y : set;;
	step 1 : wff = f1cocnv1 () |- ( F : A ↣ B → ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ) ;;
	step 2 : wff = coeq2 () |- ( F = G → ( ⁻¹ F ∘ F ) = ( ⁻¹ F ∘ G ) ) ;;
	step 3 : wff = eqeq1d (step 2) |- ( F = G → ( ( ⁻¹ F ∘ F ) = ( _I ↾ A ) ↔ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
	step 4 : wff = syl5ibcom (step 1, step 3) |- ( F : A ↣ B → ( F = G → ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
	step 5 : wff = adantr (step 4) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( F = G → ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
	step 6 : wff = f1fn () |- ( G : A ↣ B → G Fn A ) ;;
	step 7 : wff = adantl (step 6) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → G Fn A ) ;;
	step 8 : wff = adantr (step 7) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) → G Fn A ) ;;
	step 9 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 10 : wff = adantr (step 9) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → F Fn A ) ;;
	step 11 : wff = adantr (step 10) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) → F Fn A ) ;;
	step 12 : wff = eqid () |- x = x ;;
	step 13 : wff = resieq () |- ( ( x ∈ A ∧ x ∈ A ) → ( x ( _I ↾ A ) x ↔ x = x ) ) ;;
	step 14 : wff = mpbiri (step 12, step 13) |- ( ( x ∈ A ∧ x ∈ A ) → x ( _I ↾ A ) x ) ;;
	step 15 : wff = anidms (step 14) |- ( x ∈ A → x ( _I ↾ A ) x ) ;;
	step 16 : wff = adantl (step 15) |- ( ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ∧ x ∈ A ) → x ( _I ↾ A ) x ) ;;
	step 17 : wff = breq () |- ( ( ⁻¹ F ∘ G ) = ( _I ↾ A ) → ( x ( ⁻¹ F ∘ G ) x ↔ x ( _I ↾ A ) x ) ) ;;
	step 18 : wff = ad2antlr (step 17) |- ( ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ∧ x ∈ A ) → ( x ( ⁻¹ F ∘ G ) x ↔ x ( _I ↾ A ) x ) ) ;;
	step 19 : wff = mpbird (step 16, step 18) |- ( ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ∧ x ∈ A ) → x ( ⁻¹ F ∘ G ) x ) ;;
	step 20 : wff = f1fn () |- ( G : A ↣ B → G Fn A ) ;;
	step 21 : wff = adantl (step 20) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → G Fn A ) ;;
	step 22 : wff = fnfun () |- ( G Fn A → Fun G ) ;;
	step 23 : wff = syl (step 21, step 22) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → Fun G ) ;;
	step 24 : wff = adantr (step 23) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → Fun G ) ;;
	step 25 : wff = f1fn () |- ( G : A ↣ B → G Fn A ) ;;
	step 26 : wff = adantl (step 25) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → G Fn A ) ;;
	step 27 : wff = fndm () |- ( G Fn A → dom G = A ) ;;
	step 28 : wff = syl (step 26, step 27) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → dom G = A ) ;;
	step 29 : wff = eleq2d (step 28) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( x ∈ dom G ↔ x ∈ A ) ) ;;
	step 30 : wff = biimpar (step 29) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → x ∈ dom G ) ;;
	step 31 : wff = funopfvb () |- ( ( Fun G ∧ x ∈ dom G ) → ( ( G ` x ) = y ↔ 〈 x , y 〉 ∈ G ) ) ;;
	step 32 : wff = syl2anc (step 24, step 30, step 31) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( ( G ` x ) = y ↔ 〈 x , y 〉 ∈ G ) ) ;;
	step 33 : wff = bicomd (step 32) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( 〈 x , y 〉 ∈ G ↔ ( G ` x ) = y ) ) ;;
	step 34 : wff = df-br () |- ( x G y ↔ 〈 x , y 〉 ∈ G ) ;;
	step 35 : wff = eqcom () |- ( y = ( G ` x ) ↔ ( G ` x ) = y ) ;;
	step 36 : wff = 3bitr4g (step 33, step 34, step 35) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( x G y ↔ y = ( G ` x ) ) ) ;;
	step 37 : wff = biimpd (step 36) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( x G y → y = ( G ` x ) ) ) ;;
	step 38 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 39 : wff = adantr (step 38) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → F Fn A ) ;;
	step 40 : wff = fnfun () |- ( F Fn A → Fun F ) ;;
	step 41 : wff = syl (step 39, step 40) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → Fun F ) ;;
	step 42 : wff = adantr (step 41) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → Fun F ) ;;
	step 43 : wff = f1fn () |- ( F : A ↣ B → F Fn A ) ;;
	step 44 : wff = adantr (step 43) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → F Fn A ) ;;
	step 45 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 46 : wff = syl (step 44, step 45) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → dom F = A ) ;;
	step 47 : wff = eleq2d (step 46) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( x ∈ dom F ↔ x ∈ A ) ) ;;
	step 48 : wff = biimpar (step 47) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → x ∈ dom F ) ;;
	step 49 : wff = funopfvb () |- ( ( Fun F ∧ x ∈ dom F ) → ( ( F ` x ) = y ↔ 〈 x , y 〉 ∈ F ) ) ;;
	step 50 : wff = syl2anc (step 42, step 48, step 49) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( ( F ` x ) = y ↔ 〈 x , y 〉 ∈ F ) ) ;;
	step 51 : wff = df-br () |- ( x F y ↔ 〈 x , y 〉 ∈ F ) ;;
	step 52 : wff = syl6rbbr (step 50, step 51) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( x F y ↔ ( F ` x ) = y ) ) ;;
	step 53 : wff = vex () |- y ∈ _V ;;
	step 54 : wff = vex () |- x ∈ _V ;;
	step 55 : wff = brcnv (step 53, step 54) |- ( y ⁻¹ F x ↔ x F y ) ;;
	step 56 : wff = eqcom () |- ( y = ( F ` x ) ↔ ( F ` x ) = y ) ;;
	step 57 : wff = 3bitr4g (step 52, step 55, step 56) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( y ⁻¹ F x ↔ y = ( F ` x ) ) ) ;;
	step 58 : wff = biimpd (step 57) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( y ⁻¹ F x → y = ( F ` x ) ) ) ;;
	step 59 : wff = anim12d (step 37, step 58) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( ( x G y ∧ y ⁻¹ F x ) → ( y = ( G ` x ) ∧ y = ( F ` x ) ) ) ) ;;
	step 60 : wff = eximdv (step 59) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( ∃ y ( x G y ∧ y ⁻¹ F x ) → ∃ y ( y = ( G ` x ) ∧ y = ( F ` x ) ) ) ) ;;
	step 61 : wff = vex () |- x ∈ _V ;;
	step 62 : wff = vex () |- x ∈ _V ;;
	step 63 : wff = brco (step 61, step 62) |- ( x ( ⁻¹ F ∘ G ) x ↔ ∃ y ( x G y ∧ y ⁻¹ F x ) ) ;;
	step 64 : wff = fvex () |- ( G ` x ) ∈ _V ;;
	step 65 : wff = eqvinc (step 64) |- ( ( G ` x ) = ( F ` x ) ↔ ∃ y ( y = ( G ` x ) ∧ y = ( F ` x ) ) ) ;;
	step 66 : wff = 3imtr4g (step 60, step 63, step 65) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ x ∈ A ) → ( x ( ⁻¹ F ∘ G ) x → ( G ` x ) = ( F ` x ) ) ) ;;
	step 67 : wff = adantlr (step 66) |- ( ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ∧ x ∈ A ) → ( x ( ⁻¹ F ∘ G ) x → ( G ` x ) = ( F ` x ) ) ) ;;
	step 68 : wff = mpd (step 19, step 67) |- ( ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ∧ x ∈ A ) → ( G ` x ) = ( F ` x ) ) ;;
	step 69 : wff = eqfnfvd (step 8, step 11, step 68) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) → G = F ) ;;
	step 70 : wff = eqcomd (step 69) |- ( ( ( F : A ↣ B ∧ G : A ↣ B ) ∧ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) → F = G ) ;;
	step 71 : wff = ex (step 70) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( ( ⁻¹ F ∘ G ) = ( _I ↾ A ) → F = G ) ) ;;
	step 72 : wff = impbid (step 5, step 71) |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( F = G ↔ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
	qed prop 1 = step 72 ;;
}

/*Given a bijection ` F ` , produce another bijection ` G ` which
       additionally maps two specified points.  (Contributed by Mario Carneiro,
       30-May-2015.) */

theorem fveqf1o (A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- G = ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( G : A ⤖ B ∧ ( G ` C ) = D ) ) ;;
}

proof of fveqf1o {
	step 1 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 2 : wff = f1oi () |- ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) : ( A ∖ { C , ( ⁻¹ F ` D ) } ) ⤖ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 3 : wff = a1i (step 2) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) : ( A ∖ { C , ( ⁻¹ F ` D ) } ) ⤖ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 4 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 5 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 6 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 7 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 8 : wff = 3syl (step 5, step 6, step 7) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 9 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 10 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 11 : wff = syl2anc (step 8, step 9, step 10) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 12 : wff = f1oprswap () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 13 : wff = syl2anc (step 4, step 11, step 12) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 14 : wff = incom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 15 : wff = disjdif () |- ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = ∅ ;;
	step 16 : wff = eqtri (step 14, step 15) |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ;;
	step 17 : wff = a1i (step 16) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ;;
	step 18 : wff = incom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 19 : wff = disjdif () |- ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = ∅ ;;
	step 20 : wff = eqtri (step 18, step 19) |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ;;
	step 21 : wff = a1i (step 20) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ;;
	step 22 : wff = f1oun () |- ( ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) : ( A ∖ { C , ( ⁻¹ F ` D ) } ) ⤖ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∧ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ∧ ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ∧ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 23 : wff = syl22anc (step 3, step 13, step 17, step 21, step 22) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 24 : wff = uncom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 25 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 26 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 27 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 28 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 29 : wff = 3syl (step 26, step 27, step 28) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 30 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 31 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 32 : wff = syl2anc (step 29, step 30, step 31) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 33 : wff = prssi () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 34 : wff = syl2anc (step 25, step 32, step 33) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 35 : wff = undif () |- ( { C , ( ⁻¹ F ` D ) } ⊆ A ↔ ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 36 : wff = sylib (step 34, step 35) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 37 : wff = syl5eq (step 24, step 36) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A ) ;;
	step 38 : wff = f1oeq2 () |- ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ) ;;
	step 39 : wff = syl (step 37, step 38) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ) ;;
	step 40 : wff = mpbid (step 23, step 39) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 41 : wff = uncom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 42 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 43 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 44 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 45 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 46 : wff = 3syl (step 43, step 44, step 45) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 47 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 48 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 49 : wff = syl2anc (step 46, step 47, step 48) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 50 : wff = prssi () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 51 : wff = syl2anc (step 42, step 49, step 50) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 52 : wff = undif () |- ( { C , ( ⁻¹ F ` D ) } ⊆ A ↔ ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 53 : wff = sylib (step 51, step 52) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 54 : wff = syl5eq (step 41, step 53) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A ) ;;
	step 55 : wff = f1oeq3 () |- ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) ) ;;
	step 56 : wff = syl (step 54, step 55) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) ) ;;
	step 57 : wff = mpbid (step 40, step 56) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) ;;
	step 58 : wff = f1oco () |- ( ( F : A ⤖ B ∧ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) → ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) : A ⤖ B ) ;;
	step 59 : wff = syl2anc (step 1, step 57, step 58) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) : A ⤖ B ) ;;
	step 60 : wff = f1oeq1 () |- ( G = ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) → ( G : A ⤖ B ↔ ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) : A ⤖ B ) ) ;;
	step 61 : wff = ax-mp (hyp 1, step 60) |- ( G : A ⤖ B ↔ ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) : A ⤖ B ) ;;
	step 62 : wff = sylibr (step 59, step 61) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → G : A ⤖ B ) ;;
	step 63 : wff = fveq1i (hyp 1) |- ( G ` C ) = ( ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) ` C ) ;;
	step 64 : wff = f1oi () |- ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) : ( A ∖ { C , ( ⁻¹ F ` D ) } ) ⤖ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 65 : wff = a1i (step 64) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) : ( A ∖ { C , ( ⁻¹ F ` D ) } ) ⤖ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 66 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 67 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 68 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 69 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 70 : wff = 3syl (step 67, step 68, step 69) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 71 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 72 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 73 : wff = syl2anc (step 70, step 71, step 72) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 74 : wff = f1oprswap () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 75 : wff = syl2anc (step 66, step 73, step 74) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 76 : wff = incom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 77 : wff = disjdif () |- ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = ∅ ;;
	step 78 : wff = eqtri (step 76, step 77) |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ;;
	step 79 : wff = a1i (step 78) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ;;
	step 80 : wff = incom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 81 : wff = disjdif () |- ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = ∅ ;;
	step 82 : wff = eqtri (step 80, step 81) |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ;;
	step 83 : wff = a1i (step 82) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ;;
	step 84 : wff = f1oun () |- ( ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) : ( A ∖ { C , ( ⁻¹ F ` D ) } ) ⤖ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∧ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ∧ ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ∧ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 85 : wff = syl22anc (step 65, step 75, step 79, step 83, step 84) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 86 : wff = uncom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 87 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 88 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 89 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 90 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 91 : wff = 3syl (step 88, step 89, step 90) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 92 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 93 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 94 : wff = syl2anc (step 91, step 92, step 93) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 95 : wff = prssi () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 96 : wff = syl2anc (step 87, step 94, step 95) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 97 : wff = undif () |- ( { C , ( ⁻¹ F ` D ) } ⊆ A ↔ ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 98 : wff = sylib (step 96, step 97) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 99 : wff = syl5eq (step 86, step 98) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A ) ;;
	step 100 : wff = f1oeq2 () |- ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ) ;;
	step 101 : wff = syl (step 99, step 100) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ) ;;
	step 102 : wff = mpbid (step 85, step 101) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 103 : wff = uncom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 104 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 105 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 106 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 107 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 108 : wff = 3syl (step 105, step 106, step 107) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 109 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 110 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 111 : wff = syl2anc (step 108, step 109, step 110) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 112 : wff = prssi () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 113 : wff = syl2anc (step 104, step 111, step 112) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { C , ( ⁻¹ F ` D ) } ⊆ A ) ;;
	step 114 : wff = undif () |- ( { C , ( ⁻¹ F ` D ) } ⊆ A ↔ ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 115 : wff = sylib (step 113, step 114) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( { C , ( ⁻¹ F ` D ) } ∪ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = A ) ;;
	step 116 : wff = syl5eq (step 103, step 115) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A ) ;;
	step 117 : wff = f1oeq3 () |- ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) = A → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) ) ;;
	step 118 : wff = syl (step 116, step 117) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∪ { C , ( ⁻¹ F ` D ) } ) ↔ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) ) ;;
	step 119 : wff = mpbid (step 102, step 118) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A ) ;;
	step 120 : wff = f1of () |- ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⤖ A → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⟶ A ) ;;
	step 121 : wff = syl (step 119, step 120) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⟶ A ) ;;
	step 122 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 123 : wff = fvco3 () |- ( ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) : A ⟶ A ∧ C ∈ A ) → ( ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) ` C ) = ( F ` ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) ) ) ;;
	step 124 : wff = syl2anc (step 121, step 122, step 123) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( F ∘ ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ) ` C ) = ( F ` ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) ) ) ;;
	step 125 : wff = syl5eq (step 63, step 124) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( G ` C ) = ( F ` ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) ) ) ;;
	step 126 : wff = fnresi () |- ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) Fn ( A ∖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 127 : wff = a1i (step 126) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) Fn ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 128 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 129 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 130 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 131 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 132 : wff = 3syl (step 129, step 130, step 131) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 133 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 134 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 135 : wff = syl2anc (step 132, step 133, step 134) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 136 : wff = f1oprswap () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 137 : wff = syl2anc (step 128, step 135, step 136) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 138 : wff = f1ofn () |- ( { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } Fn { C , ( ⁻¹ F ` D ) } ) ;;
	step 139 : wff = syl (step 137, step 138) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } Fn { C , ( ⁻¹ F ` D ) } ) ;;
	step 140 : wff = incom () |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ;;
	step 141 : wff = disjdif () |- ( { C , ( ⁻¹ F ` D ) } ∩ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) = ∅ ;;
	step 142 : wff = eqtri (step 140, step 141) |- ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ;;
	step 143 : wff = a1i (step 142) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ) ;;
	step 144 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 145 : wff = prid1g () |- ( C ∈ A → C ∈ { C , ( ⁻¹ F ` D ) } ) ;;
	step 146 : wff = syl (step 144, step 145) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ { C , ( ⁻¹ F ` D ) } ) ;;
	step 147 : wff = fvun2 () |- ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) Fn ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∧ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } Fn { C , ( ⁻¹ F ` D ) } ∧ ( ( ( A ∖ { C , ( ⁻¹ F ` D ) } ) ∩ { C , ( ⁻¹ F ` D ) } ) = ∅ ∧ C ∈ { C , ( ⁻¹ F ` D ) } ) ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) = ( { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ` C ) ) ;;
	step 148 : wff = syl112anc (step 127, step 139, step 143, step 146, step 147) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) = ( { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ` C ) ) ;;
	step 149 : wff = simp2 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → C ∈ A ) ;;
	step 150 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 151 : wff = f1ocnv () |- ( F : A ⤖ B → ⁻¹ F : B ⤖ A ) ;;
	step 152 : wff = f1of () |- ( ⁻¹ F : B ⤖ A → ⁻¹ F : B ⟶ A ) ;;
	step 153 : wff = 3syl (step 150, step 151, step 152) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ⁻¹ F : B ⟶ A ) ;;
	step 154 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 155 : wff = ffvelrn () |- ( ( ⁻¹ F : B ⟶ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 156 : wff = syl2anc (step 153, step 154, step 155) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ⁻¹ F ` D ) ∈ A ) ;;
	step 157 : wff = f1oprswap () |- ( ( C ∈ A ∧ ( ⁻¹ F ` D ) ∈ A ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 158 : wff = syl2anc (step 149, step 156, step 157) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } ) ;;
	step 159 : wff = f1ofun () |- ( { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } : { C , ( ⁻¹ F ` D ) } ⤖ { C , ( ⁻¹ F ` D ) } → Fun { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ;;
	step 160 : wff = syl (step 158, step 159) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → Fun { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ;;
	step 161 : wff = opex () |- 〈 C , ( ⁻¹ F ` D ) 〉 ∈ _V ;;
	step 162 : wff = prid1 (step 161) |- 〈 C , ( ⁻¹ F ` D ) 〉 ∈ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ;;
	step 163 : wff = funopfv () |- ( Fun { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } → ( 〈 C , ( ⁻¹ F ` D ) 〉 ∈ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } → ( { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ` C ) = ( ⁻¹ F ` D ) ) ) ;;
	step 164 : wff = ee10 (step 160, step 162, step 163) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ` C ) = ( ⁻¹ F ` D ) ) ;;
	step 165 : wff = eqtrd (step 148, step 164) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) = ( ⁻¹ F ` D ) ) ;;
	step 166 : wff = fveq2d (step 165) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( F ` ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) ) = ( F ` ( ⁻¹ F ` D ) ) ) ;;
	step 167 : wff = simp1 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → F : A ⤖ B ) ;;
	step 168 : wff = simp3 () |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 169 : wff = f1ocnvfv2 () |- ( ( F : A ⤖ B ∧ D ∈ B ) → ( F ` ( ⁻¹ F ` D ) ) = D ) ;;
	step 170 : wff = syl2anc (step 167, step 168, step 169) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( F ` ( ⁻¹ F ` D ) ) = D ) ;;
	step 171 : wff = eqtrd (step 166, step 170) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( F ` ( ( ( _I ↾ ( A ∖ { C , ( ⁻¹ F ` D ) } ) ) ∪ { 〈 C , ( ⁻¹ F ` D ) 〉 , 〈 ( ⁻¹ F ` D ) , C 〉 } ) ` C ) ) = D ) ;;
	step 172 : wff = eqtrd (step 125, step 171) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( G ` C ) = D ) ;;
	step 173 : wff = jca (step 62, step 172) |- ( ( F : A ⤖ B ∧ C ∈ A ∧ D ∈ B ) → ( G : A ⤖ B ∧ ( G ` C ) = D ) ) ;;
	qed prop 1 = step 173 ;;
}

/*` F ` , a function lift, is a subset of ` R X. S ` .  (Contributed by
       Mario Carneiro, 23-Dec-2016.) */

theorem fliftrel (ph : wff, x : set, A : class, B : class, R : class, S : class, F : class, X : class) disjointed(A, B, x, x R, x, x, F, x ph, x X, x S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F ⊆ ( R × S ) ) ;;
}

proof of fliftrel {
	step 1 : wff = opelxpi () |- ( ( A ∈ R ∧ B ∈ S ) → 〈 A , B 〉 ∈ ( R × S ) ) ;;
	step 2 : wff = syl2anc (hyp 2, hyp 3, step 1) |- ( ( ph ∧ x ∈ X ) → 〈 A , B 〉 ∈ ( R × S ) ) ;;
	step 3 : wff = eqid () |- ( x ∈ X ↦ 〈 A , B 〉 ) = ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	step 4 : wff = fmptd (step 2, step 3) |- ( ph → ( x ∈ X ↦ 〈 A , B 〉 ) : X ⟶ ( R × S ) ) ;;
	step 5 : wff = frn () |- ( ( x ∈ X ↦ 〈 A , B 〉 ) : X ⟶ ( R × S ) → ran ( x ∈ X ↦ 〈 A , B 〉 ) ⊆ ( R × S ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ph → ran ( x ∈ X ↦ 〈 A , B 〉 ) ⊆ ( R × S ) ) ;;
	step 7 : wff = syl5eqss (hyp 1, step 6) |- ( ph → F ⊆ ( R × S ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Elementhood in the relation ` F ` .  (Contributed by Mario Carneiro,
       23-Dec-2016.) */

theorem fliftel (ph : wff, x : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, X : class) disjointed(A, B, x C, x R, x, x D, F, x ph, x X, x S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C F D ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
}

proof of fliftel {
	step 1 : wff = df-br () |- ( C F D ↔ 〈 C , D 〉 ∈ F ) ;;
	step 2 : wff = eleq2i (hyp 1) |- ( 〈 C , D 〉 ∈ F ↔ 〈 C , D 〉 ∈ ran ( x ∈ X ↦ 〈 A , B 〉 ) ) ;;
	step 3 : wff = eqid () |- ( x ∈ X ↦ 〈 A , B 〉 ) = ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	step 4 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 5 : wff = elrnmpti (step 3, step 4) |- ( 〈 C , D 〉 ∈ ran ( x ∈ X ↦ 〈 A , B 〉 ) ↔ ∃ x ∈ X 〈 C , D 〉 = 〈 A , B 〉 ) ;;
	step 6 : wff = 3bitri (step 1, step 2, step 5) |- ( C F D ↔ ∃ x ∈ X 〈 C , D 〉 = 〈 A , B 〉 ) ;;
	step 7 : wff = opthg2 () |- ( ( A ∈ R ∧ B ∈ S ) → ( 〈 C , D 〉 = 〈 A , B 〉 ↔ ( C = A ∧ D = B ) ) ) ;;
	step 8 : wff = syl2anc (hyp 2, hyp 3, step 7) |- ( ( ph ∧ x ∈ X ) → ( 〈 C , D 〉 = 〈 A , B 〉 ↔ ( C = A ∧ D = B ) ) ) ;;
	step 9 : wff = rexbidva (step 8) |- ( ph → ( ∃ x ∈ X 〈 C , D 〉 = 〈 A , B 〉 ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
	step 10 : wff = syl5bb (step 6, step 9) |- ( ph → ( C F D ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Elementhood in the relation ` F ` .  (Contributed by Mario Carneiro,
       23-Dec-2016.) */

theorem fliftel1 (ph : wff, x : set, A : class, B : class, R : class, S : class, F : class, X : class) disjointed(A, B, x, x R, x, x, F, x ph, x X, x S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ x ∈ X ) → A F B ) ;;
}

proof of fliftel1 {
	step 1 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 2 : wff = eqid () |- ( x ∈ X ↦ 〈 A , B 〉 ) = ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	step 3 : wff = elrnmpt1 (step 2) |- ( ( x ∈ X ∧ 〈 A , B 〉 ∈ _V ) → 〈 A , B 〉 ∈ ran ( x ∈ X ↦ 〈 A , B 〉 ) ) ;;
	step 4 : wff = mpan2 (step 1, step 3) |- ( x ∈ X → 〈 A , B 〉 ∈ ran ( x ∈ X ↦ 〈 A , B 〉 ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ph ∧ x ∈ X ) → 〈 A , B 〉 ∈ ran ( x ∈ X ↦ 〈 A , B 〉 ) ) ;;
	step 6 : wff = syl6eleqr (step 5, hyp 1) |- ( ( ph ∧ x ∈ X ) → 〈 A , B 〉 ∈ F ) ;;
	step 7 : wff = df-br () |- ( A F B ↔ 〈 A , B 〉 ∈ F ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( ph ∧ x ∈ X ) → A F B ) ;;
	qed prop 1 = step 8 ;;
}

/*Converse of the relation ` F ` .  (Contributed by Mario Carneiro,
       23-Dec-2016.) */

theorem fliftcnv (ph : wff, x : set, A : class, B : class, R : class, S : class, F : class, X : class) disjointed(y z A, y z B, x z, x y z R, x, x z, y z F, x y z ph, x y z X, x y z S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ⁻¹ F = ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ;;
}

proof of fliftcnv {
	var y : set, z : set;;
	step 1 : wff = eqid () |- ran ( x ∈ X ↦ 〈 B , A 〉 ) = ran ( x ∈ X ↦ 〈 B , A 〉 ) ;;
	step 2 : wff = fliftrel (step 1, hyp 3, hyp 2) |- ( ph → ran ( x ∈ X ↦ 〈 B , A 〉 ) ⊆ ( S × R ) ) ;;
	step 3 : wff = relxp () |- Rel ( S × R ) ;;
	step 4 : wff = relss () |- ( ran ( x ∈ X ↦ 〈 B , A 〉 ) ⊆ ( S × R ) → ( Rel ( S × R ) → Rel ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ) ;;
	step 5 : wff = ee10 (step 2, step 3, step 4) |- ( ph → Rel ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ;;
	step 6 : wff = relcnv () |- Rel ⁻¹ F ;;
	step 7 : wff = jctil (step 5, step 6) |- ( ph → ( Rel ⁻¹ F ∧ Rel ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ) ;;
	step 8 : wff = fliftel (hyp 1, hyp 2, hyp 3) |- ( ph → ( z F y ↔ ∃ x ∈ X ( z = A ∧ y = B ) ) ) ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = vex () |- z ∈ _V ;;
	step 11 : wff = brcnv (step 9, step 10) |- ( y ⁻¹ F z ↔ z F y ) ;;
	step 12 : wff = ancom () |- ( ( y = B ∧ z = A ) ↔ ( z = A ∧ y = B ) ) ;;
	step 13 : wff = rexbii (step 12) |- ( ∃ x ∈ X ( y = B ∧ z = A ) ↔ ∃ x ∈ X ( z = A ∧ y = B ) ) ;;
	step 14 : wff = 3bitr4g (step 8, step 11, step 13) |- ( ph → ( y ⁻¹ F z ↔ ∃ x ∈ X ( y = B ∧ z = A ) ) ) ;;
	step 15 : wff = eqid () |- ran ( x ∈ X ↦ 〈 B , A 〉 ) = ran ( x ∈ X ↦ 〈 B , A 〉 ) ;;
	step 16 : wff = fliftel (step 15, hyp 3, hyp 2) |- ( ph → ( y ran ( x ∈ X ↦ 〈 B , A 〉 ) z ↔ ∃ x ∈ X ( y = B ∧ z = A ) ) ) ;;
	step 17 : wff = bitr4d (step 14, step 16) |- ( ph → ( y ⁻¹ F z ↔ y ran ( x ∈ X ↦ 〈 B , A 〉 ) z ) ) ;;
	step 18 : wff = df-br () |- ( y ⁻¹ F z ↔ 〈 y , z 〉 ∈ ⁻¹ F ) ;;
	step 19 : wff = df-br () |- ( y ran ( x ∈ X ↦ 〈 B , A 〉 ) z ↔ 〈 y , z 〉 ∈ ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ;;
	step 20 : wff = 3bitr3g (step 17, step 18, step 19) |- ( ph → ( 〈 y , z 〉 ∈ ⁻¹ F ↔ 〈 y , z 〉 ∈ ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ) ;;
	step 21 : wff = eqrelrdv2 (step 20) |- ( ( ( Rel ⁻¹ F ∧ Rel ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ∧ ph ) → ⁻¹ F = ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ;;
	step 22 : wff = mpancom (step 7, step 21) |- ( ph → ⁻¹ F = ran ( x ∈ X ↦ 〈 B , A 〉 ) ) ;;
	qed prop 1 = step 22 ;;
}

/*The function ` F ` is the unique function defined by ` F `` A = B ` ,
         provided that the well-definedness condition holds.  (Contributed by
         Mario Carneiro, 23-Dec-2016.) */

theorem fliftfun (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, X : class) disjointed(u v y z A, u v y z B, u v x z C, x y z R, x, u v x z D, u v y z F, u v x y z ph, u v x y z X, x y z S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	hyp 4 : wff = |- ( x = y → A = C ) ;;
	hyp 5 : wff = |- ( x = y → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( Fun F ↔ ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ) ) ;;
}

proof of fliftfun {
	var z : set, v : set, u : set;;
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfmpt1 () |- F/_ x ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	step 3 : wff = nfrn (step 2) |- F/_ x ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	step 4 : wff = nfcxfr (hyp 1, step 3) |- F/_ x F ;;
	step 5 : wff = nffun (step 4) |- F/ x Fun F ;;
	step 6 : wff = fveq2 () |- ( A = C → ( F ` A ) = ( F ` C ) ) ;;
	step 7 : wff = simplr () |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → Fun F ) ;;
	step 8 : wff = fliftel1 (hyp 1, hyp 2, hyp 3) |- ( ( ph ∧ x ∈ X ) → A F B ) ;;
	step 9 : wff = ad2ant2r (step 8) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → A F B ) ;;
	step 10 : wff = funbrfv () |- ( Fun F → ( A F B → ( F ` A ) = B ) ) ;;
	step 11 : wff = sylc (step 7, step 9, step 10) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → ( F ` A ) = B ) ;;
	step 12 : wff = simplr () |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → Fun F ) ;;
	step 13 : wff = simprr () |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → y ∈ X ) ;;
	step 14 : wff = eqidd () |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → C = C ) ;;
	step 15 : wff = eqidd () |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → D = D ) ;;
	step 16 : wff = eqeq2d (hyp 4) |- ( x = y → ( C = A ↔ C = C ) ) ;;
	step 17 : wff = eqeq2d (hyp 5) |- ( x = y → ( D = B ↔ D = D ) ) ;;
	step 18 : wff = anbi12d (step 16, step 17) |- ( x = y → ( ( C = A ∧ D = B ) ↔ ( C = C ∧ D = D ) ) ) ;;
	step 19 : wff = rspcev (step 18) |- ( ( y ∈ X ∧ ( C = C ∧ D = D ) ) → ∃ x ∈ X ( C = A ∧ D = B ) ) ;;
	step 20 : wff = syl12anc (step 13, step 14, step 15, step 19) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → ∃ x ∈ X ( C = A ∧ D = B ) ) ;;
	step 21 : wff = fliftel (hyp 1, hyp 2, hyp 3) |- ( ph → ( C F D ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
	step 22 : wff = ad2antrr (step 21) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → ( C F D ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
	step 23 : wff = mpbird (step 20, step 22) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → C F D ) ;;
	step 24 : wff = funbrfv () |- ( Fun F → ( C F D → ( F ` C ) = D ) ) ;;
	step 25 : wff = sylc (step 12, step 23, step 24) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → ( F ` C ) = D ) ;;
	step 26 : wff = eqeq12d (step 11, step 25) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → ( ( F ` A ) = ( F ` C ) ↔ B = D ) ) ;;
	step 27 : wff = syl5ib (step 6, step 26) |- ( ( ( ph ∧ Fun F ) ∧ ( x ∈ X ∧ y ∈ X ) ) → ( A = C → B = D ) ) ;;
	step 28 : wff = anassrs (step 27) |- ( ( ( ( ph ∧ Fun F ) ∧ x ∈ X ) ∧ y ∈ X ) → ( A = C → B = D ) ) ;;
	step 29 : wff = ralrimiva (step 28) |- ( ( ( ph ∧ Fun F ) ∧ x ∈ X ) → ∀ y ∈ X ( A = C → B = D ) ) ;;
	step 30 : wff = exp31 (step 29) |- ( ph → ( Fun F → ( x ∈ X → ∀ y ∈ X ( A = C → B = D ) ) ) ) ;;
	step 31 : wff = ralrimd (step 1, step 5, step 30) |- ( ph → ( Fun F → ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ) ) ;;
	step 32 : wff = fliftel (hyp 1, hyp 2, hyp 3) |- ( ph → ( z F u ↔ ∃ x ∈ X ( z = A ∧ u = B ) ) ) ;;
	step 33 : wff = fliftel (hyp 1, hyp 2, hyp 3) |- ( ph → ( z F v ↔ ∃ x ∈ X ( z = A ∧ v = B ) ) ) ;;
	step 34 : wff = eqeq2d (hyp 4) |- ( x = y → ( z = A ↔ z = C ) ) ;;
	step 35 : wff = eqeq2d (hyp 5) |- ( x = y → ( v = B ↔ v = D ) ) ;;
	step 36 : wff = anbi12d (step 34, step 35) |- ( x = y → ( ( z = A ∧ v = B ) ↔ ( z = C ∧ v = D ) ) ) ;;
	step 37 : wff = cbvrexv (step 36) |- ( ∃ x ∈ X ( z = A ∧ v = B ) ↔ ∃ y ∈ X ( z = C ∧ v = D ) ) ;;
	step 38 : wff = syl6bb (step 33, step 37) |- ( ph → ( z F v ↔ ∃ y ∈ X ( z = C ∧ v = D ) ) ) ;;
	step 39 : wff = anbi12d (step 32, step 38) |- ( ph → ( ( z F u ∧ z F v ) ↔ ( ∃ x ∈ X ( z = A ∧ u = B ) ∧ ∃ y ∈ X ( z = C ∧ v = D ) ) ) ) ;;
	step 40 : wff = biimpd (step 39) |- ( ph → ( ( z F u ∧ z F v ) → ( ∃ x ∈ X ( z = A ∧ u = B ) ∧ ∃ y ∈ X ( z = C ∧ v = D ) ) ) ) ;;
	step 41 : wff = reeanv () |- ( ∃ x ∈ X ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ↔ ( ∃ x ∈ X ( z = A ∧ u = B ) ∧ ∃ y ∈ X ( z = C ∧ v = D ) ) ) ;;
	step 42 : wff = r19.29 () |- ( ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ∧ ∃ x ∈ X ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → ∃ x ∈ X ( ∀ y ∈ X ( A = C → B = D ) ∧ ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) ) ;;
	step 43 : wff = r19.29 () |- ( ( ∀ y ∈ X ( A = C → B = D ) ∧ ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → ∃ y ∈ X ( ( A = C → B = D ) ∧ ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) ) ;;
	step 44 : wff = eqtr2 () |- ( ( z = A ∧ z = C ) → A = C ) ;;
	step 45 : wff = ad2ant2r (step 44) |- ( ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) → A = C ) ;;
	step 46 : wff = imim1i (step 45) |- ( ( A = C → B = D ) → ( ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) → B = D ) ) ;;
	step 47 : wff = imp (step 46) |- ( ( ( A = C → B = D ) ∧ ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → B = D ) ;;
	step 48 : wff = simprlr () |- ( ( ( A = C → B = D ) ∧ ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → u = B ) ;;
	step 49 : wff = simprrr () |- ( ( ( A = C → B = D ) ∧ ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → v = D ) ;;
	step 50 : wff = 3eqtr4d (step 47, step 48, step 49) |- ( ( ( A = C → B = D ) ∧ ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → u = v ) ;;
	step 51 : wff = rexlimivw (step 50) |- ( ∃ y ∈ X ( ( A = C → B = D ) ∧ ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → u = v ) ;;
	step 52 : wff = syl (step 43, step 51) |- ( ( ∀ y ∈ X ( A = C → B = D ) ∧ ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → u = v ) ;;
	step 53 : wff = rexlimivw (step 52) |- ( ∃ x ∈ X ( ∀ y ∈ X ( A = C → B = D ) ∧ ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → u = v ) ;;
	step 54 : wff = syl (step 42, step 53) |- ( ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ∧ ∃ x ∈ X ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) ) → u = v ) ;;
	step 55 : wff = ex (step 54) |- ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → ( ∃ x ∈ X ∃ y ∈ X ( ( z = A ∧ u = B ) ∧ ( z = C ∧ v = D ) ) → u = v ) ) ;;
	step 56 : wff = syl5bir (step 41, step 55) |- ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → ( ( ∃ x ∈ X ( z = A ∧ u = B ) ∧ ∃ y ∈ X ( z = C ∧ v = D ) ) → u = v ) ) ;;
	step 57 : wff = syl9 (step 40, step 56) |- ( ph → ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 58 : wff = alrimdv (step 57) |- ( ph → ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → ∀ v ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 59 : wff = alrimdv (step 58) |- ( ph → ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → ∀ u ∀ v ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 60 : wff = alrimdv (step 59) |- ( ph → ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → ∀ z ∀ u ∀ v ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 61 : wff = fliftrel (hyp 1, hyp 2, hyp 3) |- ( ph → F ⊆ ( R × S ) ) ;;
	step 62 : wff = relxp () |- Rel ( R × S ) ;;
	step 63 : wff = relss () |- ( F ⊆ ( R × S ) → ( Rel ( R × S ) → Rel F ) ) ;;
	step 64 : wff = ee10 (step 61, step 62, step 63) |- ( ph → Rel F ) ;;
	step 65 : wff = dffun2 () |- ( Fun F ↔ ( Rel F ∧ ∀ z ∀ u ∀ v ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 66 : wff = baib (step 65) |- ( Rel F → ( Fun F ↔ ∀ z ∀ u ∀ v ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 67 : wff = syl (step 64, step 66) |- ( ph → ( Fun F ↔ ∀ z ∀ u ∀ v ( ( z F u ∧ z F v ) → u = v ) ) ) ;;
	step 68 : wff = sylibrd (step 60, step 67) |- ( ph → ( ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) → Fun F ) ) ;;
	step 69 : wff = impbid (step 31, step 68) |- ( ph → ( Fun F ↔ ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ) ) ;;
	qed prop 1 = step 69 ;;
}

/*The function ` F ` is the unique function defined by ` F `` A = B ` ,
         provided that the well-definedness condition holds.  (Contributed by
         Mario Carneiro, 23-Dec-2016.) */

theorem fliftfund (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, X : class) disjointed(y A, y B, x C, x y R, x, x D, y F, x y ph, x y X, x y S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	hyp 4 : wff = |- ( x = y → A = C ) ;;
	hyp 5 : wff = |- ( x = y → B = D ) ;;
	hyp 6 : wff = |- ( ( ph ∧ ( x ∈ X ∧ y ∈ X ∧ A = C ) ) → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → Fun F ) ;;
}

proof of fliftfund {
	step 1 : wff = 3exp2 (hyp 6) |- ( ph → ( x ∈ X → ( y ∈ X → ( A = C → B = D ) ) ) ) ;;
	step 2 : wff = imp32 (step 1) |- ( ( ph ∧ ( x ∈ X ∧ y ∈ X ) ) → ( A = C → B = D ) ) ;;
	step 3 : wff = ralrimivva (step 2) |- ( ph → ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ) ;;
	step 4 : wff = fliftfun (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ph → ( Fun F ↔ ∀ x ∈ X ∀ y ∈ X ( A = C → B = D ) ) ) ;;
	step 5 : wff = mpbird (step 3, step 4) |- ( ph → Fun F ) ;;
	qed prop 1 = step 5 ;;
}

/*The function ` F ` is the unique function defined by ` F `` A = B ` ,
       provided that the well-definedness condition holds.  (Contributed by
       Mario Carneiro, 23-Dec-2016.) */

theorem fliftfuns (ph : wff, x : set, y : set, z : set, A : class, B : class, R : class, S : class, F : class, X : class) disjointed(y z A, y z B, x z, x y z R, x, x z, y z F, x y z ph, x y z X, x y z S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( Fun F ↔ ∀ y ∈ X ∀ z ∈ X ( [_ y / x ]_ A = [_ z / x ]_ A → [_ y / x ]_ B = [_ z / x ]_ B ) ) ) ;;
}

proof of fliftfuns {
	step 1 : wff = nfcv () |- F/_ y 〈 A , B 〉 ;;
	step 2 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ A ;;
	step 3 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 4 : wff = nfop (step 2, step 3) |- F/_ x 〈 [_ y / x ]_ A , [_ y / x ]_ B 〉 ;;
	step 5 : wff = csbeq1a () |- ( x = y → A = [_ y / x ]_ A ) ;;
	step 6 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 7 : wff = opeq12d (step 5, step 6) |- ( x = y → 〈 A , B 〉 = 〈 [_ y / x ]_ A , [_ y / x ]_ B 〉 ) ;;
	step 8 : wff = cbvmpt (step 1, step 4, step 7) |- ( x ∈ X ↦ 〈 A , B 〉 ) = ( y ∈ X ↦ 〈 [_ y / x ]_ A , [_ y / x ]_ B 〉 ) ;;
	step 9 : wff = rneqi (step 8) |- ran ( x ∈ X ↦ 〈 A , B 〉 ) = ran ( y ∈ X ↦ 〈 [_ y / x ]_ A , [_ y / x ]_ B 〉 ) ;;
	step 10 : wff = eqtri (hyp 1, step 9) |- F = ran ( y ∈ X ↦ 〈 [_ y / x ]_ A , [_ y / x ]_ B 〉 ) ;;
	step 11 : wff = ralrimiva (hyp 2) |- ( ph → ∀ x ∈ X A ∈ R ) ;;
	step 12 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ A ;;
	step 13 : wff = nfel1 (step 12) |- F/ x [_ y / x ]_ A ∈ R ;;
	step 14 : wff = csbeq1a () |- ( x = y → A = [_ y / x ]_ A ) ;;
	step 15 : wff = eleq1d (step 14) |- ( x = y → ( A ∈ R ↔ [_ y / x ]_ A ∈ R ) ) ;;
	step 16 : wff = rspc (step 13, step 15) |- ( y ∈ X → ( ∀ x ∈ X A ∈ R → [_ y / x ]_ A ∈ R ) ) ;;
	step 17 : wff = mpan9 (step 11, step 16) |- ( ( ph ∧ y ∈ X ) → [_ y / x ]_ A ∈ R ) ;;
	step 18 : wff = ralrimiva (hyp 3) |- ( ph → ∀ x ∈ X B ∈ S ) ;;
	step 19 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 20 : wff = nfel1 (step 19) |- F/ x [_ y / x ]_ B ∈ S ;;
	step 21 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 22 : wff = eleq1d (step 21) |- ( x = y → ( B ∈ S ↔ [_ y / x ]_ B ∈ S ) ) ;;
	step 23 : wff = rspc (step 20, step 22) |- ( y ∈ X → ( ∀ x ∈ X B ∈ S → [_ y / x ]_ B ∈ S ) ) ;;
	step 24 : wff = mpan9 (step 18, step 23) |- ( ( ph ∧ y ∈ X ) → [_ y / x ]_ B ∈ S ) ;;
	step 25 : wff = csbeq1 () |- ( y = z → [_ y / x ]_ A = [_ z / x ]_ A ) ;;
	step 26 : wff = csbeq1 () |- ( y = z → [_ y / x ]_ B = [_ z / x ]_ B ) ;;
	step 27 : wff = fliftfun (step 10, step 17, step 24, step 25, step 26) |- ( ph → ( Fun F ↔ ∀ y ∈ X ∀ z ∈ X ( [_ y / x ]_ A = [_ z / x ]_ A → [_ y / x ]_ B = [_ z / x ]_ B ) ) ) ;;
	qed prop 1 = step 27 ;;
}

/*The domain and range of the function ` F ` .  (Contributed by Mario
       Carneiro, 23-Dec-2016.) */

theorem fliftf (ph : wff, x : set, A : class, B : class, R : class, S : class, F : class, X : class) disjointed(y z A, y z B, x z, x y z R, x, x z, y z F, x y z ph, x y z X, x y z S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( Fun F ↔ F : ran ( x ∈ X ↦ A ) ⟶ S ) ) ;;
}

proof of fliftf {
	var y : set, z : set;;
	step 1 : wff = simpr () |- ( ( ph ∧ Fun F ) → Fun F ) ;;
	step 2 : wff = fliftel (hyp 1, hyp 2, hyp 3) |- ( ph → ( y F z ↔ ∃ x ∈ X ( y = A ∧ z = B ) ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( ph → ( ∃ z y F z ↔ ∃ z ∃ x ∈ X ( y = A ∧ z = B ) ) ) ;;
	step 4 : wff = adantr (step 3) |- ( ( ph ∧ Fun F ) → ( ∃ z y F z ↔ ∃ z ∃ x ∈ X ( y = A ∧ z = B ) ) ) ;;
	step 5 : wff = rexcom4 () |- ( ∃ x ∈ X ∃ z ( y = A ∧ z = B ) ↔ ∃ z ∃ x ∈ X ( y = A ∧ z = B ) ) ;;
	step 6 : wff = elisset () |- ( B ∈ S → ∃ z z = B ) ;;
	step 7 : wff = syl (hyp 3, step 6) |- ( ( ph ∧ x ∈ X ) → ∃ z z = B ) ;;
	step 8 : wff = biantrud (step 7) |- ( ( ph ∧ x ∈ X ) → ( y = A ↔ ( y = A ∧ ∃ z z = B ) ) ) ;;
	step 9 : wff = 19.42v () |- ( ∃ z ( y = A ∧ z = B ) ↔ ( y = A ∧ ∃ z z = B ) ) ;;
	step 10 : wff = syl6rbbr (step 8, step 9) |- ( ( ph ∧ x ∈ X ) → ( ∃ z ( y = A ∧ z = B ) ↔ y = A ) ) ;;
	step 11 : wff = rexbidva (step 10) |- ( ph → ( ∃ x ∈ X ∃ z ( y = A ∧ z = B ) ↔ ∃ x ∈ X y = A ) ) ;;
	step 12 : wff = adantr (step 11) |- ( ( ph ∧ Fun F ) → ( ∃ x ∈ X ∃ z ( y = A ∧ z = B ) ↔ ∃ x ∈ X y = A ) ) ;;
	step 13 : wff = syl5bbr (step 5, step 12) |- ( ( ph ∧ Fun F ) → ( ∃ z ∃ x ∈ X ( y = A ∧ z = B ) ↔ ∃ x ∈ X y = A ) ) ;;
	step 14 : wff = bitrd (step 4, step 13) |- ( ( ph ∧ Fun F ) → ( ∃ z y F z ↔ ∃ x ∈ X y = A ) ) ;;
	step 15 : wff = abbidv (step 14) |- ( ( ph ∧ Fun F ) → { y | ∃ z y F z } = { y | ∃ x ∈ X y = A } ) ;;
	step 16 : wff = df-dm () |- dom F = { y | ∃ z y F z } ;;
	step 17 : wff = eqid () |- ( x ∈ X ↦ A ) = ( x ∈ X ↦ A ) ;;
	step 18 : wff = rnmpt (step 17) |- ran ( x ∈ X ↦ A ) = { y | ∃ x ∈ X y = A } ;;
	step 19 : wff = 3eqtr4g (step 15, step 16, step 18) |- ( ( ph ∧ Fun F ) → dom F = ran ( x ∈ X ↦ A ) ) ;;
	step 20 : wff = df-fn () |- ( F Fn ran ( x ∈ X ↦ A ) ↔ ( Fun F ∧ dom F = ran ( x ∈ X ↦ A ) ) ) ;;
	step 21 : wff = sylanbrc (step 1, step 19, step 20) |- ( ( ph ∧ Fun F ) → F Fn ran ( x ∈ X ↦ A ) ) ;;
	step 22 : wff = fliftrel (hyp 1, hyp 2, hyp 3) |- ( ph → F ⊆ ( R × S ) ) ;;
	step 23 : wff = adantr (step 22) |- ( ( ph ∧ Fun F ) → F ⊆ ( R × S ) ) ;;
	step 24 : wff = rnss () |- ( F ⊆ ( R × S ) → ran F ⊆ ran ( R × S ) ) ;;
	step 25 : wff = syl (step 23, step 24) |- ( ( ph ∧ Fun F ) → ran F ⊆ ran ( R × S ) ) ;;
	step 26 : wff = rnxpss () |- ran ( R × S ) ⊆ S ;;
	step 27 : wff = syl6ss (step 25, step 26) |- ( ( ph ∧ Fun F ) → ran F ⊆ S ) ;;
	step 28 : wff = df-f () |- ( F : ran ( x ∈ X ↦ A ) ⟶ S ↔ ( F Fn ran ( x ∈ X ↦ A ) ∧ ran F ⊆ S ) ) ;;
	step 29 : wff = sylanbrc (step 21, step 27, step 28) |- ( ( ph ∧ Fun F ) → F : ran ( x ∈ X ↦ A ) ⟶ S ) ;;
	step 30 : wff = ex (step 29) |- ( ph → ( Fun F → F : ran ( x ∈ X ↦ A ) ⟶ S ) ) ;;
	step 31 : wff = ffun () |- ( F : ran ( x ∈ X ↦ A ) ⟶ S → Fun F ) ;;
	step 32 : wff = impbid1 (step 30, step 31) |- ( ph → ( Fun F ↔ F : ran ( x ∈ X ↦ A ) ⟶ S ) ) ;;
	qed prop 1 = step 32 ;;
}

/*The value of the function ` F ` .  (Contributed by Mario Carneiro,
       23-Dec-2016.) */

theorem fliftval (ph : wff, x : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, X : class, Y : class) disjointed(A, B, x C, x R, x Y, x D, F, x ph, x X, x S) {
	hyp 1 : wff = |- F = ran ( x ∈ X ↦ 〈 A , B 〉 ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ X ) → A ∈ R ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ X ) → B ∈ S ) ;;
	hyp 4 : wff = |- ( x = Y → A = C ) ;;
	hyp 5 : wff = |- ( x = Y → B = D ) ;;
	hyp 6 : wff = |- ( ph → Fun F ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ Y ∈ X ) → ( F ` C ) = D ) ;;
}

proof of fliftval {
	step 1 : wff = adantr (hyp 6) |- ( ( ph ∧ Y ∈ X ) → Fun F ) ;;
	step 2 : wff = simpr () |- ( ( ph ∧ Y ∈ X ) → Y ∈ X ) ;;
	step 3 : wff = eqidd () |- ( ph → D = D ) ;;
	step 4 : wff = eqidd () |- ( Y ∈ X → C = C ) ;;
	step 5 : wff = anim12ci (step 3, step 4) |- ( ( ph ∧ Y ∈ X ) → ( C = C ∧ D = D ) ) ;;
	step 6 : wff = eqeq2d (hyp 4) |- ( x = Y → ( C = A ↔ C = C ) ) ;;
	step 7 : wff = eqeq2d (hyp 5) |- ( x = Y → ( D = B ↔ D = D ) ) ;;
	step 8 : wff = anbi12d (step 6, step 7) |- ( x = Y → ( ( C = A ∧ D = B ) ↔ ( C = C ∧ D = D ) ) ) ;;
	step 9 : wff = rspcev (step 8) |- ( ( Y ∈ X ∧ ( C = C ∧ D = D ) ) → ∃ x ∈ X ( C = A ∧ D = B ) ) ;;
	step 10 : wff = syl2anc (step 2, step 5, step 9) |- ( ( ph ∧ Y ∈ X ) → ∃ x ∈ X ( C = A ∧ D = B ) ) ;;
	step 11 : wff = fliftel (hyp 1, hyp 2, hyp 3) |- ( ph → ( C F D ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
	step 12 : wff = adantr (step 11) |- ( ( ph ∧ Y ∈ X ) → ( C F D ↔ ∃ x ∈ X ( C = A ∧ D = B ) ) ) ;;
	step 13 : wff = mpbird (step 10, step 12) |- ( ( ph ∧ Y ∈ X ) → C F D ) ;;
	step 14 : wff = funbrfv () |- ( Fun F → ( C F D → ( F ` C ) = D ) ) ;;
	step 15 : wff = sylc (step 1, step 13, step 14) |- ( ( ph ∧ Y ∈ X ) → ( F ` C ) = D ) ;;
	qed prop 1 = step 15 ;;
}

/*Equality theorem for isomorphisms.  (Contributed by NM, 17-May-2004.) */

theorem isoeq1 (A : class, B : class, R : class, S : class, G : class, H : class) disjointed(x y A, x y B, x y, x y H, x y G, x y R, x y S, x y) {
	prop 1 : wff = |- ( H = G → ( H Isom R , S ( A , B ) ↔ G Isom R , S ( A , B ) ) ) ;;
}

proof of isoeq1 {
	var x : set, y : set;;
	step 1 : wff = f1oeq1 () |- ( H = G → ( H : A ⤖ B ↔ G : A ⤖ B ) ) ;;
	step 2 : wff = fveq1 () |- ( H = G → ( H ` x ) = ( G ` x ) ) ;;
	step 3 : wff = fveq1 () |- ( H = G → ( H ` y ) = ( G ` y ) ) ;;
	step 4 : wff = breq12d (step 2, step 3) |- ( H = G → ( ( H ` x ) S ( H ` y ) ↔ ( G ` x ) S ( G ` y ) ) ) ;;
	step 5 : wff = bibi2d (step 4) |- ( H = G → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( x R y ↔ ( G ` x ) S ( G ` y ) ) ) ) ;;
	step 6 : wff = 2ralbidv (step 5) |- ( H = G → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( G ` x ) S ( G ` y ) ) ) ) ;;
	step 7 : wff = anbi12d (step 1, step 6) |- ( H = G → ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( G : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( G ` x ) S ( G ` y ) ) ) ) ) ;;
	step 8 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 9 : wff = df-isom () |- ( G Isom R , S ( A , B ) ↔ ( G : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( G ` x ) S ( G ` y ) ) ) ) ;;
	step 10 : wff = 3bitr4g (step 7, step 8, step 9) |- ( H = G → ( H Isom R , S ( A , B ) ↔ G Isom R , S ( A , B ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Equality theorem for isomorphisms.  (Contributed by NM, 17-May-2004.) */

theorem isoeq2 (A : class, B : class, R : class, S : class, T : class, H : class) disjointed(x y A, x y B, x y, x y H, x y, x y R, x y S, x y T) {
	prop 1 : wff = |- ( R = T → ( H Isom R , S ( A , B ) ↔ H Isom T , S ( A , B ) ) ) ;;
}

proof of isoeq2 {
	var x : set, y : set;;
	step 1 : wff = breq () |- ( R = T → ( x R y ↔ x T y ) ) ;;
	step 2 : wff = bibi1d (step 1) |- ( R = T → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( x T y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 3 : wff = 2ralbidv (step 2) |- ( R = T → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x T y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 4 : wff = anbi2d (step 3) |- ( R = T → ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x T y ↔ ( H ` x ) S ( H ` y ) ) ) ) ) ;;
	step 5 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 6 : wff = df-isom () |- ( H Isom T , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x T y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( R = T → ( H Isom R , S ( A , B ) ↔ H Isom T , S ( A , B ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for isomorphisms.  (Contributed by NM, 17-May-2004.) */

theorem isoeq3 (A : class, B : class, R : class, S : class, T : class, H : class) disjointed(x y A, x y B, x y, x y H, x y, x y R, x y S, x y T) {
	prop 1 : wff = |- ( S = T → ( H Isom R , S ( A , B ) ↔ H Isom R , T ( A , B ) ) ) ;;
}

proof of isoeq3 {
	var x : set, y : set;;
	step 1 : wff = breq () |- ( S = T → ( ( H ` x ) S ( H ` y ) ↔ ( H ` x ) T ( H ` y ) ) ) ;;
	step 2 : wff = bibi2d (step 1) |- ( S = T → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( x R y ↔ ( H ` x ) T ( H ` y ) ) ) ) ;;
	step 3 : wff = 2ralbidv (step 2) |- ( S = T → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) T ( H ` y ) ) ) ) ;;
	step 4 : wff = anbi2d (step 3) |- ( S = T → ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) T ( H ` y ) ) ) ) ) ;;
	step 5 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 6 : wff = df-isom () |- ( H Isom R , T ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) T ( H ` y ) ) ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( S = T → ( H Isom R , S ( A , B ) ↔ H Isom R , T ( A , B ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for isomorphisms.  (Contributed by NM, 17-May-2004.) */

theorem isoeq4 (A : class, B : class, C : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y C, x y H, x y, x y R, x y S, x y) {
	prop 1 : wff = |- ( A = C → ( H Isom R , S ( A , B ) ↔ H Isom R , S ( C , B ) ) ) ;;
}

proof of isoeq4 {
	var x : set, y : set;;
	step 1 : wff = f1oeq2 () |- ( A = C → ( H : A ⤖ B ↔ H : C ⤖ B ) ) ;;
	step 2 : wff = raleq () |- ( A = C → ( ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 3 : wff = raleqbi1dv (step 2) |- ( A = C → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( A = C → ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( H : C ⤖ B ∧ ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ) ;;
	step 5 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 6 : wff = df-isom () |- ( H Isom R , S ( C , B ) ↔ ( H : C ⤖ B ∧ ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( A = C → ( H Isom R , S ( A , B ) ↔ H Isom R , S ( C , B ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for isomorphisms.  (Contributed by NM, 17-May-2004.) */

theorem isoeq5 (A : class, B : class, C : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y C, x y H, x y, x y R, x y S, x y) {
	prop 1 : wff = |- ( B = C → ( H Isom R , S ( A , B ) ↔ H Isom R , S ( A , C ) ) ) ;;
}

proof of isoeq5 {
	var x : set, y : set;;
	step 1 : wff = f1oeq3 () |- ( B = C → ( H : A ⤖ B ↔ H : A ⤖ C ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( B = C → ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( H : A ⤖ C ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ) ;;
	step 3 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 4 : wff = df-isom () |- ( H Isom R , S ( A , C ) ↔ ( H : A ⤖ C ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( B = C → ( H Isom R , S ( A , B ) ↔ H Isom R , S ( A , C ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for an isomorphism.  (Contributed by
       NM, 17-May-2004.)  (Proof shortened by Andrew Salmon, 22-Oct-2011.) */

theorem nfiso (x : set, A : class, B : class, R : class, S : class, H : class) disjointed(y z H, y z R, y z S, y z A, y z B, x y z) {
	hyp 1 : wff = |- F/_ x H ;;
	hyp 2 : wff = |- F/_ x R ;;
	hyp 3 : wff = |- F/_ x S ;;
	hyp 4 : wff = |- F/_ x A ;;
	hyp 5 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x H Isom R , S ( A , B ) ;;
}

proof of nfiso {
	var y : set, z : set;;
	step 1 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ y ∈ A ∀ z ∈ A ( y R z ↔ ( H ` y ) S ( H ` z ) ) ) ) ;;
	step 2 : wff = nff1o (hyp 1, hyp 4, hyp 5) |- F/ x H : A ⤖ B ;;
	step 3 : wff = nfcv () |- F/_ x y ;;
	step 4 : wff = nfcv () |- F/_ x z ;;
	step 5 : wff = nfbr (step 3, hyp 2, step 4) |- F/ x y R z ;;
	step 6 : wff = nfcv () |- F/_ x y ;;
	step 7 : wff = nffv (hyp 1, step 6) |- F/_ x ( H ` y ) ;;
	step 8 : wff = nfcv () |- F/_ x z ;;
	step 9 : wff = nffv (hyp 1, step 8) |- F/_ x ( H ` z ) ;;
	step 10 : wff = nfbr (step 7, hyp 3, step 9) |- F/ x ( H ` y ) S ( H ` z ) ;;
	step 11 : wff = nfbi (step 5, step 10) |- F/ x ( y R z ↔ ( H ` y ) S ( H ` z ) ) ;;
	step 12 : wff = nfral (hyp 4, step 11) |- F/ x ∀ z ∈ A ( y R z ↔ ( H ` y ) S ( H ` z ) ) ;;
	step 13 : wff = nfral (hyp 4, step 12) |- F/ x ∀ y ∈ A ∀ z ∈ A ( y R z ↔ ( H ` y ) S ( H ` z ) ) ;;
	step 14 : wff = nfan (step 2, step 13) |- F/ x ( H : A ⤖ B ∧ ∀ y ∈ A ∀ z ∈ A ( y R z ↔ ( H ` y ) S ( H ` z ) ) ) ;;
	step 15 : wff = nfxfr (step 1, step 14) |- F/ x H Isom R , S ( A , B ) ;;
	qed prop 1 = step 15 ;;
}

/*An isomorphism is a one-to-one onto function.  (Contributed by NM,
       27-Apr-2004.) */

theorem isof1o (A : class, B : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y R, x y S, x y H) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
}

proof of isof1o {
	var x : set, y : set;;
	step 1 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	qed prop 1 = step 2 ;;
}

/*An isomorphism connects binary relations via its function values.
       (Contributed by NM, 27-Apr-2004.) */

theorem isorel (A : class, B : class, C : class, D : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y R, x y S, x y H, x y C, x y D) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ ( C ∈ A ∧ D ∈ A ) ) → ( C R D ↔ ( H ` C ) S ( H ` D ) ) ) ;;
}

proof of isorel {
	var x : set, y : set;;
	step 1 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( H Isom R , S ( A , B ) → ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 3 : wff = breq1 () |- ( x = C → ( x R y ↔ C R y ) ) ;;
	step 4 : wff = fveq2 () |- ( x = C → ( H ` x ) = ( H ` C ) ) ;;
	step 5 : wff = breq1d (step 4) |- ( x = C → ( ( H ` x ) S ( H ` y ) ↔ ( H ` C ) S ( H ` y ) ) ) ;;
	step 6 : wff = bibi12d (step 3, step 5) |- ( x = C → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( C R y ↔ ( H ` C ) S ( H ` y ) ) ) ) ;;
	step 7 : wff = breq2 () |- ( y = D → ( C R y ↔ C R D ) ) ;;
	step 8 : wff = fveq2 () |- ( y = D → ( H ` y ) = ( H ` D ) ) ;;
	step 9 : wff = breq2d (step 8) |- ( y = D → ( ( H ` C ) S ( H ` y ) ↔ ( H ` C ) S ( H ` D ) ) ) ;;
	step 10 : wff = bibi12d (step 7, step 9) |- ( y = D → ( ( C R y ↔ ( H ` C ) S ( H ` y ) ) ↔ ( C R D ↔ ( H ` C ) S ( H ` D ) ) ) ) ;;
	step 11 : wff = rspc2v (step 6, step 10) |- ( ( C ∈ A ∧ D ∈ A ) → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) → ( C R D ↔ ( H ` C ) S ( H ` D ) ) ) ) ;;
	step 12 : wff = mpan9 (step 2, step 11) |- ( ( H Isom R , S ( A , B ) ∧ ( C ∈ A ∧ D ∈ A ) ) → ( C R D ↔ ( H ` C ) S ( H ` D ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Express the condition of isomorphism on two strict orders for a
       function's restriction.  (Contributed by Mario Carneiro,
       22-Jan-2015.) */

theorem soisores (x : set, y : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(w x y z A, w z B, w z C, w x y z F, w x y z R, w x y z S) {
	prop 1 : wff = |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ) → ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ) ;;
}

proof of soisores {
	var z : set, w : set;;
	step 1 : wff = isorel () |- ( ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( x R y ↔ ( ( F ↾ A ) ` x ) S ( ( F ↾ A ) ` y ) ) ) ;;
	step 2 : wff = fvres () |- ( x ∈ A → ( ( F ↾ A ) ` x ) = ( F ` x ) ) ;;
	step 3 : wff = fvres () |- ( y ∈ A → ( ( F ↾ A ) ` y ) = ( F ` y ) ) ;;
	step 4 : wff = breqan12d (step 2, step 3) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( ( F ↾ A ) ` x ) S ( ( F ↾ A ) ` y ) ↔ ( F ` x ) S ( F ` y ) ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( ( F ↾ A ) ` x ) S ( ( F ↾ A ) ` y ) ↔ ( F ` x ) S ( F ` y ) ) ) ;;
	step 6 : wff = bitrd (step 1, step 5) |- ( ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( x R y ↔ ( F ` x ) S ( F ` y ) ) ) ;;
	step 7 : wff = biimpd (step 6) |- ( ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( x R y → ( F ` x ) S ( F ` y ) ) ) ;;
	step 8 : wff = ralrimivva (step 7) |- ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ;;
	step 9 : wff = ffn () |- ( F : B ⟶ C → F Fn B ) ;;
	step 10 : wff = ad2antrl (step 9) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ) → F Fn B ) ;;
	step 11 : wff = simprr () |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ) → A ⊆ B ) ;;
	step 12 : wff = fnssres () |- ( ( F Fn B ∧ A ⊆ B ) → ( F ↾ A ) Fn A ) ;;
	step 13 : wff = syl2anc (step 10, step 11, step 12) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ) → ( F ↾ A ) Fn A ) ;;
	step 14 : wff = 3adant3 (step 13) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( F ↾ A ) Fn A ) ;;
	step 15 : wff = df-ima () |- ( F " A ) = ran ( F ↾ A ) ;;
	step 16 : wff = eqcomi (step 15) |- ran ( F ↾ A ) = ( F " A ) ;;
	step 17 : wff = a1i (step 16) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ran ( F ↾ A ) = ( F " A ) ) ;;
	step 18 : wff = fvres () |- ( z ∈ A → ( ( F ↾ A ) ` z ) = ( F ` z ) ) ;;
	step 19 : wff = fvres () |- ( w ∈ A → ( ( F ↾ A ) ` w ) = ( F ` w ) ) ;;
	step 20 : wff = eqeqan12d (step 18, step 19) |- ( ( z ∈ A ∧ w ∈ A ) → ( ( ( F ↾ A ) ` z ) = ( ( F ↾ A ) ` w ) ↔ ( F ` z ) = ( F ` w ) ) ) ;;
	step 21 : wff = adantl (step 20) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( ( F ↾ A ) ` z ) = ( ( F ↾ A ) ` w ) ↔ ( F ` z ) = ( F ` w ) ) ) ;;
	step 22 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 23 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 24 : wff = simpl3 () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ;;
	step 25 : wff = breq1 () |- ( x = z → ( x R y ↔ z R y ) ) ;;
	step 26 : wff = fveq2 () |- ( x = z → ( F ` x ) = ( F ` z ) ) ;;
	step 27 : wff = breq1d (step 26) |- ( x = z → ( ( F ` x ) S ( F ` y ) ↔ ( F ` z ) S ( F ` y ) ) ) ;;
	step 28 : wff = imbi12d (step 25, step 27) |- ( x = z → ( ( x R y → ( F ` x ) S ( F ` y ) ) ↔ ( z R y → ( F ` z ) S ( F ` y ) ) ) ) ;;
	step 29 : wff = breq2 () |- ( y = w → ( z R y ↔ z R w ) ) ;;
	step 30 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 31 : wff = breq2d (step 30) |- ( y = w → ( ( F ` z ) S ( F ` y ) ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 32 : wff = imbi12d (step 29, step 31) |- ( y = w → ( ( z R y → ( F ` z ) S ( F ` y ) ) ↔ ( z R w → ( F ` z ) S ( F ` w ) ) ) ) ;;
	step 33 : wff = rspc2va (step 28, step 32) |- ( ( ( z ∈ A ∧ w ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( z R w → ( F ` z ) S ( F ` w ) ) ) ;;
	step 34 : wff = syl21anc (step 22, step 23, step 24, step 33) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z R w → ( F ` z ) S ( F ` w ) ) ) ;;
	step 35 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 36 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 37 : wff = simpl3 () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ;;
	step 38 : wff = breq1 () |- ( x = w → ( x R y ↔ w R y ) ) ;;
	step 39 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 40 : wff = breq1d (step 39) |- ( x = w → ( ( F ` x ) S ( F ` y ) ↔ ( F ` w ) S ( F ` y ) ) ) ;;
	step 41 : wff = imbi12d (step 38, step 40) |- ( x = w → ( ( x R y → ( F ` x ) S ( F ` y ) ) ↔ ( w R y → ( F ` w ) S ( F ` y ) ) ) ) ;;
	step 42 : wff = breq2 () |- ( y = z → ( w R y ↔ w R z ) ) ;;
	step 43 : wff = fveq2 () |- ( y = z → ( F ` y ) = ( F ` z ) ) ;;
	step 44 : wff = breq2d (step 43) |- ( y = z → ( ( F ` w ) S ( F ` y ) ↔ ( F ` w ) S ( F ` z ) ) ) ;;
	step 45 : wff = imbi12d (step 42, step 44) |- ( y = z → ( ( w R y → ( F ` w ) S ( F ` y ) ) ↔ ( w R z → ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 46 : wff = rspc2va (step 41, step 45) |- ( ( ( w ∈ A ∧ z ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( w R z → ( F ` w ) S ( F ` z ) ) ) ;;
	step 47 : wff = syl21anc (step 35, step 36, step 37, step 46) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( w R z → ( F ` w ) S ( F ` z ) ) ) ;;
	step 48 : wff = orim12d (step 34, step 47) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( z R w ∨ w R z ) → ( ( F ` z ) S ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 49 : wff = con3d (step 48) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ¬ ( ( F ` z ) S ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) → ¬ ( z R w ∨ w R z ) ) ) ;;
	step 50 : wff = simpl1r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → S Or C ) ;;
	step 51 : wff = simpl2l () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → F : B ⟶ C ) ;;
	step 52 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 53 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 54 : wff = sseldd (step 52, step 53) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ B ) ;;
	step 55 : wff = ffvelrn () |- ( ( F : B ⟶ C ∧ z ∈ B ) → ( F ` z ) ∈ C ) ;;
	step 56 : wff = syl2anc (step 51, step 54, step 55) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( F ` z ) ∈ C ) ;;
	step 57 : wff = simpl2l () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → F : B ⟶ C ) ;;
	step 58 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 59 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 60 : wff = sseldd (step 58, step 59) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ B ) ;;
	step 61 : wff = ffvelrn () |- ( ( F : B ⟶ C ∧ w ∈ B ) → ( F ` w ) ∈ C ) ;;
	step 62 : wff = syl2anc (step 57, step 60, step 61) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( F ` w ) ∈ C ) ;;
	step 63 : wff = sotrieq () |- ( ( S Or C ∧ ( ( F ` z ) ∈ C ∧ ( F ` w ) ∈ C ) ) → ( ( F ` z ) = ( F ` w ) ↔ ¬ ( ( F ` z ) S ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 64 : wff = syl12anc (step 50, step 56, step 62, step 63) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( F ` z ) = ( F ` w ) ↔ ¬ ( ( F ` z ) S ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 65 : wff = simpl1l () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → R Or B ) ;;
	step 66 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 67 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 68 : wff = sseldd (step 66, step 67) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ B ) ;;
	step 69 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 70 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 71 : wff = sseldd (step 69, step 70) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ B ) ;;
	step 72 : wff = sotrieq () |- ( ( R Or B ∧ ( z ∈ B ∧ w ∈ B ) ) → ( z = w ↔ ¬ ( z R w ∨ w R z ) ) ) ;;
	step 73 : wff = syl12anc (step 65, step 68, step 71, step 72) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z = w ↔ ¬ ( z R w ∨ w R z ) ) ) ;;
	step 74 : wff = 3imtr4d (step 49, step 64, step 73) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( F ` z ) = ( F ` w ) → z = w ) ) ;;
	step 75 : wff = sylbid (step 21, step 74) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( ( F ↾ A ) ` z ) = ( ( F ↾ A ) ` w ) → z = w ) ) ;;
	step 76 : wff = ralrimivva (step 75) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ∀ z ∈ A ∀ w ∈ A ( ( ( F ↾ A ) ` z ) = ( ( F ↾ A ) ` w ) → z = w ) ) ;;
	step 77 : wff = dff1o6 () |- ( ( F ↾ A ) : A ⤖ ( F " A ) ↔ ( ( F ↾ A ) Fn A ∧ ran ( F ↾ A ) = ( F " A ) ∧ ∀ z ∈ A ∀ w ∈ A ( ( ( F ↾ A ) ` z ) = ( ( F ↾ A ) ` w ) → z = w ) ) ) ;;
	step 78 : wff = syl3anbrc (step 14, step 17, step 76, step 77) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( F ↾ A ) : A ⤖ ( F " A ) ) ;;
	step 79 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 80 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 81 : wff = simpl3 () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ;;
	step 82 : wff = breq1 () |- ( x = z → ( x R y ↔ z R y ) ) ;;
	step 83 : wff = fveq2 () |- ( x = z → ( F ` x ) = ( F ` z ) ) ;;
	step 84 : wff = breq1d (step 83) |- ( x = z → ( ( F ` x ) S ( F ` y ) ↔ ( F ` z ) S ( F ` y ) ) ) ;;
	step 85 : wff = imbi12d (step 82, step 84) |- ( x = z → ( ( x R y → ( F ` x ) S ( F ` y ) ) ↔ ( z R y → ( F ` z ) S ( F ` y ) ) ) ) ;;
	step 86 : wff = breq2 () |- ( y = w → ( z R y ↔ z R w ) ) ;;
	step 87 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 88 : wff = breq2d (step 87) |- ( y = w → ( ( F ` z ) S ( F ` y ) ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 89 : wff = imbi12d (step 86, step 88) |- ( y = w → ( ( z R y → ( F ` z ) S ( F ` y ) ) ↔ ( z R w → ( F ` z ) S ( F ` w ) ) ) ) ;;
	step 90 : wff = rspc2va (step 85, step 89) |- ( ( ( z ∈ A ∧ w ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( z R w → ( F ` z ) S ( F ` w ) ) ) ;;
	step 91 : wff = syl21anc (step 79, step 80, step 81, step 90) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z R w → ( F ` z ) S ( F ` w ) ) ) ;;
	step 92 : wff = fveq2 () |- ( z = w → ( F ` z ) = ( F ` w ) ) ;;
	step 93 : wff = a1i (step 92) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z = w → ( F ` z ) = ( F ` w ) ) ) ;;
	step 94 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 95 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 96 : wff = simpl3 () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ;;
	step 97 : wff = breq1 () |- ( x = w → ( x R y ↔ w R y ) ) ;;
	step 98 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 99 : wff = breq1d (step 98) |- ( x = w → ( ( F ` x ) S ( F ` y ) ↔ ( F ` w ) S ( F ` y ) ) ) ;;
	step 100 : wff = imbi12d (step 97, step 99) |- ( x = w → ( ( x R y → ( F ` x ) S ( F ` y ) ) ↔ ( w R y → ( F ` w ) S ( F ` y ) ) ) ) ;;
	step 101 : wff = breq2 () |- ( y = z → ( w R y ↔ w R z ) ) ;;
	step 102 : wff = fveq2 () |- ( y = z → ( F ` y ) = ( F ` z ) ) ;;
	step 103 : wff = breq2d (step 102) |- ( y = z → ( ( F ` w ) S ( F ` y ) ↔ ( F ` w ) S ( F ` z ) ) ) ;;
	step 104 : wff = imbi12d (step 101, step 103) |- ( y = z → ( ( w R y → ( F ` w ) S ( F ` y ) ) ↔ ( w R z → ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 105 : wff = rspc2va (step 100, step 104) |- ( ( ( w ∈ A ∧ z ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( w R z → ( F ` w ) S ( F ` z ) ) ) ;;
	step 106 : wff = syl21anc (step 94, step 95, step 96, step 105) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( w R z → ( F ` w ) S ( F ` z ) ) ) ;;
	step 107 : wff = orim12d (step 93, step 106) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( z = w ∨ w R z ) → ( ( F ` z ) = ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 108 : wff = con3d (step 107) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ¬ ( ( F ` z ) = ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) → ¬ ( z = w ∨ w R z ) ) ) ;;
	step 109 : wff = simpl1r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → S Or C ) ;;
	step 110 : wff = simpl2l () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → F : B ⟶ C ) ;;
	step 111 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 112 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 113 : wff = sseldd (step 111, step 112) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ B ) ;;
	step 114 : wff = ffvelrn () |- ( ( F : B ⟶ C ∧ z ∈ B ) → ( F ` z ) ∈ C ) ;;
	step 115 : wff = syl2anc (step 110, step 113, step 114) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( F ` z ) ∈ C ) ;;
	step 116 : wff = simpl2l () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → F : B ⟶ C ) ;;
	step 117 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 118 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 119 : wff = sseldd (step 117, step 118) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ B ) ;;
	step 120 : wff = ffvelrn () |- ( ( F : B ⟶ C ∧ w ∈ B ) → ( F ` w ) ∈ C ) ;;
	step 121 : wff = syl2anc (step 116, step 119, step 120) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( F ` w ) ∈ C ) ;;
	step 122 : wff = sotric () |- ( ( S Or C ∧ ( ( F ` z ) ∈ C ∧ ( F ` w ) ∈ C ) ) → ( ( F ` z ) S ( F ` w ) ↔ ¬ ( ( F ` z ) = ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 123 : wff = syl12anc (step 109, step 115, step 121, step 122) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( F ` z ) S ( F ` w ) ↔ ¬ ( ( F ` z ) = ( F ` w ) ∨ ( F ` w ) S ( F ` z ) ) ) ) ;;
	step 124 : wff = simpl1l () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → R Or B ) ;;
	step 125 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 126 : wff = simprl () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ A ) ;;
	step 127 : wff = sseldd (step 125, step 126) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → z ∈ B ) ;;
	step 128 : wff = simpl2r () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → A ⊆ B ) ;;
	step 129 : wff = simprr () |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ A ) ;;
	step 130 : wff = sseldd (step 128, step 129) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → w ∈ B ) ;;
	step 131 : wff = sotric () |- ( ( R Or B ∧ ( z ∈ B ∧ w ∈ B ) ) → ( z R w ↔ ¬ ( z = w ∨ w R z ) ) ) ;;
	step 132 : wff = syl12anc (step 124, step 127, step 130, step 131) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z R w ↔ ¬ ( z = w ∨ w R z ) ) ) ;;
	step 133 : wff = 3imtr4d (step 108, step 123, step 132) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( F ` z ) S ( F ` w ) → z R w ) ) ;;
	step 134 : wff = impbid (step 91, step 133) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z R w ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 135 : wff = fvres () |- ( z ∈ A → ( ( F ↾ A ) ` z ) = ( F ` z ) ) ;;
	step 136 : wff = fvres () |- ( w ∈ A → ( ( F ↾ A ) ` w ) = ( F ` w ) ) ;;
	step 137 : wff = breqan12d (step 135, step 136) |- ( ( z ∈ A ∧ w ∈ A ) → ( ( ( F ↾ A ) ` z ) S ( ( F ↾ A ) ` w ) ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 138 : wff = adantl (step 137) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( ( ( F ↾ A ) ` z ) S ( ( F ↾ A ) ` w ) ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 139 : wff = bitr4d (step 134, step 138) |- ( ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ∧ ( z ∈ A ∧ w ∈ A ) ) → ( z R w ↔ ( ( F ↾ A ) ` z ) S ( ( F ↾ A ) ` w ) ) ) ;;
	step 140 : wff = ralrimivva (step 139) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ∀ z ∈ A ∀ w ∈ A ( z R w ↔ ( ( F ↾ A ) ` z ) S ( ( F ↾ A ) ` w ) ) ) ;;
	step 141 : wff = df-isom () |- ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ↔ ( ( F ↾ A ) : A ⤖ ( F " A ) ∧ ∀ z ∈ A ∀ w ∈ A ( z R w ↔ ( ( F ↾ A ) ` z ) S ( ( F ↾ A ) ` w ) ) ) ) ;;
	step 142 : wff = sylanbrc (step 78, step 140, step 141) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) → ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ) ;;
	step 143 : wff = 3expia (step 142) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ) → ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) → ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ) ) ;;
	step 144 : wff = impbid2 (step 8, step 143) |- ( ( ( R Or B ∧ S Or C ) ∧ ( F : B ⟶ C ∧ A ⊆ B ) ) → ( ( F ↾ A ) Isom R , S ( A , ( F " A ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x R y → ( F ` x ) S ( F ` y ) ) ) ) ;;
	qed prop 1 = step 144 ;;
}

/*Infer isomorphism from one direction of an order proof for isomorphisms
       between strict orders.  (Contributed by Stefan O'Rear, 2-Nov-2014.) */

theorem soisoi (x : set, y : set, A : class, B : class, R : class, S : class, H : class) disjointed(R x y a b, S x y a b, H x y a b, A x y a b, B x y a b) {
	prop 1 : wff = |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H Isom R , S ( A , B ) ) ;;
}

proof of soisoi {
	var a : set, b : set;;
	step 1 : wff = simprl () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H : A ↠ B ) ;;
	step 2 : wff = fof () |- ( H : A ↠ B → H : A ⟶ B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H : A ⟶ B ) ;;
	step 4 : wff = simpll () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → R Or A ) ;;
	step 5 : wff = sotrieq () |- ( ( R Or A ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a = b ↔ ¬ ( a R b ∨ b R a ) ) ) ;;
	step 6 : wff = con2bid (step 5) |- ( ( R Or A ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( a R b ∨ b R a ) ↔ ¬ a = b ) ) ;;
	step 7 : wff = sylan (step 4, step 6) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( a R b ∨ b R a ) ↔ ¬ a = b ) ) ;;
	step 8 : wff = simprr () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ;;
	step 9 : wff = breq1 () |- ( x = a → ( x R y ↔ a R y ) ) ;;
	step 10 : wff = fveq2 () |- ( x = a → ( H ` x ) = ( H ` a ) ) ;;
	step 11 : wff = breq1d (step 10) |- ( x = a → ( ( H ` x ) S ( H ` y ) ↔ ( H ` a ) S ( H ` y ) ) ) ;;
	step 12 : wff = imbi12d (step 9, step 11) |- ( x = a → ( ( x R y → ( H ` x ) S ( H ` y ) ) ↔ ( a R y → ( H ` a ) S ( H ` y ) ) ) ) ;;
	step 13 : wff = breq2 () |- ( y = b → ( a R y ↔ a R b ) ) ;;
	step 14 : wff = fveq2 () |- ( y = b → ( H ` y ) = ( H ` b ) ) ;;
	step 15 : wff = breq2d (step 14) |- ( y = b → ( ( H ` a ) S ( H ` y ) ↔ ( H ` a ) S ( H ` b ) ) ) ;;
	step 16 : wff = imbi12d (step 13, step 15) |- ( y = b → ( ( a R y → ( H ` a ) S ( H ` y ) ) ↔ ( a R b → ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 17 : wff = rspc2va (step 12, step 16) |- ( ( ( a ∈ A ∧ b ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) → ( a R b → ( H ` a ) S ( H ` b ) ) ) ;;
	step 18 : wff = ancoms (step 17) |- ( ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b → ( H ` a ) S ( H ` b ) ) ) ;;
	step 19 : wff = sylan (step 8, step 18) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b → ( H ` a ) S ( H ` b ) ) ) ;;
	step 20 : wff = simpllr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → S Po B ) ;;
	step 21 : wff = simplrl () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ↠ B ) ;;
	step 22 : wff = fof () |- ( H : A ↠ B → H : A ⟶ B ) ;;
	step 23 : wff = syl (step 21, step 22) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ⟶ B ) ;;
	step 24 : wff = simprr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → b ∈ A ) ;;
	step 25 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ b ∈ A ) → ( H ` b ) ∈ B ) ;;
	step 26 : wff = syl2anc (step 23, step 24, step 25) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( H ` b ) ∈ B ) ;;
	step 27 : wff = poirr () |- ( ( S Po B ∧ ( H ` b ) ∈ B ) → ¬ ( H ` b ) S ( H ` b ) ) ;;
	step 28 : wff = breq1 () |- ( ( H ` a ) = ( H ` b ) → ( ( H ` a ) S ( H ` b ) ↔ ( H ` b ) S ( H ` b ) ) ) ;;
	step 29 : wff = notbid (step 28) |- ( ( H ` a ) = ( H ` b ) → ( ¬ ( H ` a ) S ( H ` b ) ↔ ¬ ( H ` b ) S ( H ` b ) ) ) ;;
	step 30 : wff = syl5ibrcom (step 27, step 29) |- ( ( S Po B ∧ ( H ` b ) ∈ B ) → ( ( H ` a ) = ( H ` b ) → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 31 : wff = syl2anc (step 20, step 26, step 30) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( H ` a ) = ( H ` b ) → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 32 : wff = con2d (step 31) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( H ` a ) S ( H ` b ) → ¬ ( H ` a ) = ( H ` b ) ) ) ;;
	step 33 : wff = syld (step 19, step 32) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b → ¬ ( H ` a ) = ( H ` b ) ) ) ;;
	step 34 : wff = simprr () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ;;
	step 35 : wff = breq1 () |- ( x = b → ( x R y ↔ b R y ) ) ;;
	step 36 : wff = fveq2 () |- ( x = b → ( H ` x ) = ( H ` b ) ) ;;
	step 37 : wff = breq1d (step 36) |- ( x = b → ( ( H ` x ) S ( H ` y ) ↔ ( H ` b ) S ( H ` y ) ) ) ;;
	step 38 : wff = imbi12d (step 35, step 37) |- ( x = b → ( ( x R y → ( H ` x ) S ( H ` y ) ) ↔ ( b R y → ( H ` b ) S ( H ` y ) ) ) ) ;;
	step 39 : wff = breq2 () |- ( y = a → ( b R y ↔ b R a ) ) ;;
	step 40 : wff = fveq2 () |- ( y = a → ( H ` y ) = ( H ` a ) ) ;;
	step 41 : wff = breq2d (step 40) |- ( y = a → ( ( H ` b ) S ( H ` y ) ↔ ( H ` b ) S ( H ` a ) ) ) ;;
	step 42 : wff = imbi12d (step 39, step 41) |- ( y = a → ( ( b R y → ( H ` b ) S ( H ` y ) ) ↔ ( b R a → ( H ` b ) S ( H ` a ) ) ) ) ;;
	step 43 : wff = rspc2va (step 38, step 42) |- ( ( ( b ∈ A ∧ a ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 44 : wff = ancoms (step 43) |- ( ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ∧ ( b ∈ A ∧ a ∈ A ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 45 : wff = ancom2s (step 44) |- ( ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 46 : wff = sylan (step 34, step 45) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 47 : wff = simpllr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → S Po B ) ;;
	step 48 : wff = simplrl () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ↠ B ) ;;
	step 49 : wff = fof () |- ( H : A ↠ B → H : A ⟶ B ) ;;
	step 50 : wff = syl (step 48, step 49) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ⟶ B ) ;;
	step 51 : wff = simprr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → b ∈ A ) ;;
	step 52 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ b ∈ A ) → ( H ` b ) ∈ B ) ;;
	step 53 : wff = syl2anc (step 50, step 51, step 52) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( H ` b ) ∈ B ) ;;
	step 54 : wff = poirr () |- ( ( S Po B ∧ ( H ` b ) ∈ B ) → ¬ ( H ` b ) S ( H ` b ) ) ;;
	step 55 : wff = breq2 () |- ( ( H ` a ) = ( H ` b ) → ( ( H ` b ) S ( H ` a ) ↔ ( H ` b ) S ( H ` b ) ) ) ;;
	step 56 : wff = notbid (step 55) |- ( ( H ` a ) = ( H ` b ) → ( ¬ ( H ` b ) S ( H ` a ) ↔ ¬ ( H ` b ) S ( H ` b ) ) ) ;;
	step 57 : wff = syl5ibrcom (step 54, step 56) |- ( ( S Po B ∧ ( H ` b ) ∈ B ) → ( ( H ` a ) = ( H ` b ) → ¬ ( H ` b ) S ( H ` a ) ) ) ;;
	step 58 : wff = syl2anc (step 47, step 53, step 57) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( H ` a ) = ( H ` b ) → ¬ ( H ` b ) S ( H ` a ) ) ) ;;
	step 59 : wff = con2d (step 58) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( H ` b ) S ( H ` a ) → ¬ ( H ` a ) = ( H ` b ) ) ) ;;
	step 60 : wff = syld (step 46, step 59) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( b R a → ¬ ( H ` a ) = ( H ` b ) ) ) ;;
	step 61 : wff = jaod (step 33, step 60) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( a R b ∨ b R a ) → ¬ ( H ` a ) = ( H ` b ) ) ) ;;
	step 62 : wff = sylbird (step 7, step 61) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ¬ a = b → ¬ ( H ` a ) = ( H ` b ) ) ) ;;
	step 63 : wff = con4d (step 62) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( H ` a ) = ( H ` b ) → a = b ) ) ;;
	step 64 : wff = ralrimivva (step 63) |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → ∀ a ∈ A ∀ b ∈ A ( ( H ` a ) = ( H ` b ) → a = b ) ) ;;
	step 65 : wff = dff13 () |- ( H : A ↣ B ↔ ( H : A ⟶ B ∧ ∀ a ∈ A ∀ b ∈ A ( ( H ` a ) = ( H ` b ) → a = b ) ) ) ;;
	step 66 : wff = sylanbrc (step 3, step 64, step 65) |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H : A ↣ B ) ;;
	step 67 : wff = simprl () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H : A ↠ B ) ;;
	step 68 : wff = df-f1o () |- ( H : A ⤖ B ↔ ( H : A ↣ B ∧ H : A ↠ B ) ) ;;
	step 69 : wff = sylanbrc (step 66, step 67, step 68) |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H : A ⤖ B ) ;;
	step 70 : wff = simprr () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ;;
	step 71 : wff = breq1 () |- ( x = a → ( x R y ↔ a R y ) ) ;;
	step 72 : wff = fveq2 () |- ( x = a → ( H ` x ) = ( H ` a ) ) ;;
	step 73 : wff = breq1d (step 72) |- ( x = a → ( ( H ` x ) S ( H ` y ) ↔ ( H ` a ) S ( H ` y ) ) ) ;;
	step 74 : wff = imbi12d (step 71, step 73) |- ( x = a → ( ( x R y → ( H ` x ) S ( H ` y ) ) ↔ ( a R y → ( H ` a ) S ( H ` y ) ) ) ) ;;
	step 75 : wff = breq2 () |- ( y = b → ( a R y ↔ a R b ) ) ;;
	step 76 : wff = fveq2 () |- ( y = b → ( H ` y ) = ( H ` b ) ) ;;
	step 77 : wff = breq2d (step 76) |- ( y = b → ( ( H ` a ) S ( H ` y ) ↔ ( H ` a ) S ( H ` b ) ) ) ;;
	step 78 : wff = imbi12d (step 75, step 77) |- ( y = b → ( ( a R y → ( H ` a ) S ( H ` y ) ) ↔ ( a R b → ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 79 : wff = rspc2va (step 74, step 78) |- ( ( ( a ∈ A ∧ b ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) → ( a R b → ( H ` a ) S ( H ` b ) ) ) ;;
	step 80 : wff = ancoms (step 79) |- ( ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b → ( H ` a ) S ( H ` b ) ) ) ;;
	step 81 : wff = sylan (step 70, step 80) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b → ( H ` a ) S ( H ` b ) ) ) ;;
	step 82 : wff = simpll () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → R Or A ) ;;
	step 83 : wff = sotric () |- ( ( R Or A ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b ↔ ¬ ( a = b ∨ b R a ) ) ) ;;
	step 84 : wff = con2bid (step 83) |- ( ( R Or A ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( a = b ∨ b R a ) ↔ ¬ a R b ) ) ;;
	step 85 : wff = sylan (step 82, step 84) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( a = b ∨ b R a ) ↔ ¬ a R b ) ) ;;
	step 86 : wff = simpllr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → S Po B ) ;;
	step 87 : wff = simplrl () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ↠ B ) ;;
	step 88 : wff = fof () |- ( H : A ↠ B → H : A ⟶ B ) ;;
	step 89 : wff = syl (step 87, step 88) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ⟶ B ) ;;
	step 90 : wff = simprr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → b ∈ A ) ;;
	step 91 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ b ∈ A ) → ( H ` b ) ∈ B ) ;;
	step 92 : wff = syl2anc (step 89, step 90, step 91) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( H ` b ) ∈ B ) ;;
	step 93 : wff = poirr () |- ( ( S Po B ∧ ( H ` b ) ∈ B ) → ¬ ( H ` b ) S ( H ` b ) ) ;;
	step 94 : wff = fveq2 () |- ( a = b → ( H ` a ) = ( H ` b ) ) ;;
	step 95 : wff = breq1d (step 94) |- ( a = b → ( ( H ` a ) S ( H ` b ) ↔ ( H ` b ) S ( H ` b ) ) ) ;;
	step 96 : wff = notbid (step 95) |- ( a = b → ( ¬ ( H ` a ) S ( H ` b ) ↔ ¬ ( H ` b ) S ( H ` b ) ) ) ;;
	step 97 : wff = syl5ibrcom (step 93, step 96) |- ( ( S Po B ∧ ( H ` b ) ∈ B ) → ( a = b → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 98 : wff = syl2anc (step 86, step 92, step 97) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a = b → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 99 : wff = simprr () |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ;;
	step 100 : wff = breq1 () |- ( x = b → ( x R y ↔ b R y ) ) ;;
	step 101 : wff = fveq2 () |- ( x = b → ( H ` x ) = ( H ` b ) ) ;;
	step 102 : wff = breq1d (step 101) |- ( x = b → ( ( H ` x ) S ( H ` y ) ↔ ( H ` b ) S ( H ` y ) ) ) ;;
	step 103 : wff = imbi12d (step 100, step 102) |- ( x = b → ( ( x R y → ( H ` x ) S ( H ` y ) ) ↔ ( b R y → ( H ` b ) S ( H ` y ) ) ) ) ;;
	step 104 : wff = breq2 () |- ( y = a → ( b R y ↔ b R a ) ) ;;
	step 105 : wff = fveq2 () |- ( y = a → ( H ` y ) = ( H ` a ) ) ;;
	step 106 : wff = breq2d (step 105) |- ( y = a → ( ( H ` b ) S ( H ` y ) ↔ ( H ` b ) S ( H ` a ) ) ) ;;
	step 107 : wff = imbi12d (step 104, step 106) |- ( y = a → ( ( b R y → ( H ` b ) S ( H ` y ) ) ↔ ( b R a → ( H ` b ) S ( H ` a ) ) ) ) ;;
	step 108 : wff = rspc2va (step 103, step 107) |- ( ( ( b ∈ A ∧ a ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 109 : wff = ancoms (step 108) |- ( ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ∧ ( b ∈ A ∧ a ∈ A ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 110 : wff = ancom2s (step 109) |- ( ( ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 111 : wff = sylan (step 99, step 110) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( b R a → ( H ` b ) S ( H ` a ) ) ) ;;
	step 112 : wff = simpllr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → S Po B ) ;;
	step 113 : wff = simplrl () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ↠ B ) ;;
	step 114 : wff = fof () |- ( H : A ↠ B → H : A ⟶ B ) ;;
	step 115 : wff = syl (step 113, step 114) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ⟶ B ) ;;
	step 116 : wff = simprr () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → b ∈ A ) ;;
	step 117 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ b ∈ A ) → ( H ` b ) ∈ B ) ;;
	step 118 : wff = syl2anc (step 115, step 116, step 117) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( H ` b ) ∈ B ) ;;
	step 119 : wff = simplrl () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ↠ B ) ;;
	step 120 : wff = fof () |- ( H : A ↠ B → H : A ⟶ B ) ;;
	step 121 : wff = syl (step 119, step 120) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → H : A ⟶ B ) ;;
	step 122 : wff = simprl () |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → a ∈ A ) ;;
	step 123 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ a ∈ A ) → ( H ` a ) ∈ B ) ;;
	step 124 : wff = syl2anc (step 121, step 122, step 123) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( H ` a ) ∈ B ) ;;
	step 125 : wff = po2nr () |- ( ( S Po B ∧ ( ( H ` b ) ∈ B ∧ ( H ` a ) ∈ B ) ) → ¬ ( ( H ` b ) S ( H ` a ) ∧ ( H ` a ) S ( H ` b ) ) ) ;;
	step 126 : wff = imnan () |- ( ( ( H ` b ) S ( H ` a ) → ¬ ( H ` a ) S ( H ` b ) ) ↔ ¬ ( ( H ` b ) S ( H ` a ) ∧ ( H ` a ) S ( H ` b ) ) ) ;;
	step 127 : wff = sylibr (step 125, step 126) |- ( ( S Po B ∧ ( ( H ` b ) ∈ B ∧ ( H ` a ) ∈ B ) ) → ( ( H ` b ) S ( H ` a ) → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 128 : wff = syl12anc (step 112, step 118, step 124, step 127) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( H ` b ) S ( H ` a ) → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 129 : wff = syld (step 111, step 128) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( b R a → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 130 : wff = jaod (step 98, step 129) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ( a = b ∨ b R a ) → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 131 : wff = sylbird (step 85, step 130) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( ¬ a R b → ¬ ( H ` a ) S ( H ` b ) ) ) ;;
	step 132 : wff = impcon4bid (step 81, step 131) |- ( ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) ∧ ( a ∈ A ∧ b ∈ A ) ) → ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ;;
	step 133 : wff = ralrimivva (step 132) |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → ∀ a ∈ A ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ;;
	step 134 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ a ∈ A ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 135 : wff = sylanbrc (step 69, step 133, step 134) |- ( ( ( R Or A ∧ S Po B ) ∧ ( H : A ↠ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y → ( H ` x ) S ( H ` y ) ) ) ) → H Isom R , S ( A , B ) ) ;;
	qed prop 1 = step 135 ;;
}

/*Identity law for isomorphism.  Proposition 6.30(1) of [TakeutiZaring]
       p. 33.  (Contributed by NM, 27-Apr-2004.) */

theorem isoid (A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( _I ↾ A ) Isom R , R ( A , A ) ;;
}

proof of isoid {
	var x : set, y : set;;
	step 1 : wff = f1oi () |- ( _I ↾ A ) : A ⤖ A ;;
	step 2 : wff = fvresi () |- ( x ∈ A → ( ( _I ↾ A ) ` x ) = x ) ;;
	step 3 : wff = fvresi () |- ( y ∈ A → ( ( _I ↾ A ) ` y ) = y ) ;;
	step 4 : wff = breqan12d (step 2, step 3) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( ( _I ↾ A ) ` x ) R ( ( _I ↾ A ) ` y ) ↔ x R y ) ) ;;
	step 5 : wff = bicomd (step 4) |- ( ( x ∈ A ∧ y ∈ A ) → ( x R y ↔ ( ( _I ↾ A ) ` x ) R ( ( _I ↾ A ) ` y ) ) ) ;;
	step 6 : wff = rgen2a (step 5) |- ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( _I ↾ A ) ` x ) R ( ( _I ↾ A ) ` y ) ) ;;
	step 7 : wff = df-isom () |- ( ( _I ↾ A ) Isom R , R ( A , A ) ↔ ( ( _I ↾ A ) : A ⤖ A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( _I ↾ A ) ` x ) R ( ( _I ↾ A ) ` y ) ) ) ) ;;
	step 8 : wff = mpbir2an (step 1, step 6, step 7) |- ( _I ↾ A ) Isom R , R ( A , A ) ;;
	qed prop 1 = step 8 ;;
}

/*Converse law for isomorphism.  Proposition 6.30(2) of [TakeutiZaring]
       p. 33.  (Contributed by NM, 27-Apr-2004.) */

theorem isocnv (A : class, B : class, R : class, S : class, H : class) disjointed(w x y z A, w x y z B, x y, x y, w x y z H, w x y z R, w x y z S) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
}

proof of isocnv {
	var x : set, y : set, z : set, w : set;;
	step 1 : wff = f1ocnv () |- ( H : A ⤖ B → ⁻¹ H : B ⤖ A ) ;;
	step 2 : wff = adantr (step 1) |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → ⁻¹ H : B ⤖ A ) ;;
	step 3 : wff = f1ocnvfv2 () |- ( ( H : A ⤖ B ∧ z ∈ B ) → ( H ` ( ⁻¹ H ` z ) ) = z ) ;;
	step 4 : wff = adantrr (step 3) |- ( ( H : A ⤖ B ∧ ( z ∈ B ∧ w ∈ B ) ) → ( H ` ( ⁻¹ H ` z ) ) = z ) ;;
	step 5 : wff = f1ocnvfv2 () |- ( ( H : A ⤖ B ∧ w ∈ B ) → ( H ` ( ⁻¹ H ` w ) ) = w ) ;;
	step 6 : wff = adantrl (step 5) |- ( ( H : A ⤖ B ∧ ( z ∈ B ∧ w ∈ B ) ) → ( H ` ( ⁻¹ H ` w ) ) = w ) ;;
	step 7 : wff = breq12d (step 4, step 6) |- ( ( H : A ⤖ B ∧ ( z ∈ B ∧ w ∈ B ) ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ z S w ) ) ;;
	step 8 : wff = adantlr (step 7) |- ( ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( z ∈ B ∧ w ∈ B ) ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ z S w ) ) ;;
	step 9 : wff = f1ocnv () |- ( H : A ⤖ B → ⁻¹ H : B ⤖ A ) ;;
	step 10 : wff = f1of () |- ( ⁻¹ H : B ⤖ A → ⁻¹ H : B ⟶ A ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( H : A ⤖ B → ⁻¹ H : B ⟶ A ) ;;
	step 12 : wff = ffvelrn () |- ( ( ⁻¹ H : B ⟶ A ∧ z ∈ B ) → ( ⁻¹ H ` z ) ∈ A ) ;;
	step 13 : wff = ffvelrn () |- ( ( ⁻¹ H : B ⟶ A ∧ w ∈ B ) → ( ⁻¹ H ` w ) ∈ A ) ;;
	step 14 : wff = anim12dan (step 12, step 13) |- ( ( ⁻¹ H : B ⟶ A ∧ ( z ∈ B ∧ w ∈ B ) ) → ( ( ⁻¹ H ` z ) ∈ A ∧ ( ⁻¹ H ` w ) ∈ A ) ) ;;
	step 15 : wff = breq1 () |- ( x = ( ⁻¹ H ` z ) → ( x R y ↔ ( ⁻¹ H ` z ) R y ) ) ;;
	step 16 : wff = fveq2 () |- ( x = ( ⁻¹ H ` z ) → ( H ` x ) = ( H ` ( ⁻¹ H ` z ) ) ) ;;
	step 17 : wff = breq1d (step 16) |- ( x = ( ⁻¹ H ` z ) → ( ( H ` x ) S ( H ` y ) ↔ ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ) ) ;;
	step 18 : wff = bibi12d (step 15, step 17) |- ( x = ( ⁻¹ H ` z ) → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( ( ⁻¹ H ` z ) R y ↔ ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ) ) ) ;;
	step 19 : wff = bicom () |- ( ( ( ⁻¹ H ` z ) R y ↔ ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ) ↔ ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ↔ ( ⁻¹ H ` z ) R y ) ) ;;
	step 20 : wff = syl6bb (step 18, step 19) |- ( x = ( ⁻¹ H ` z ) → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ↔ ( ⁻¹ H ` z ) R y ) ) ) ;;
	step 21 : wff = fveq2 () |- ( y = ( ⁻¹ H ` w ) → ( H ` y ) = ( H ` ( ⁻¹ H ` w ) ) ) ;;
	step 22 : wff = breq2d (step 21) |- ( y = ( ⁻¹ H ` w ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ↔ ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ) ) ;;
	step 23 : wff = breq2 () |- ( y = ( ⁻¹ H ` w ) → ( ( ⁻¹ H ` z ) R y ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 24 : wff = bibi12d (step 22, step 23) |- ( y = ( ⁻¹ H ` w ) → ( ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` y ) ↔ ( ⁻¹ H ` z ) R y ) ↔ ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ) ;;
	step 25 : wff = rspc2va (step 20, step 24) |- ( ( ( ( ⁻¹ H ` z ) ∈ A ∧ ( ⁻¹ H ` w ) ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 26 : wff = sylan (step 14, step 25) |- ( ( ( ⁻¹ H : B ⟶ A ∧ ( z ∈ B ∧ w ∈ B ) ) ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 27 : wff = an32s (step 26) |- ( ( ( ⁻¹ H : B ⟶ A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( z ∈ B ∧ w ∈ B ) ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 28 : wff = sylanl1 (step 11, step 27) |- ( ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( z ∈ B ∧ w ∈ B ) ) → ( ( H ` ( ⁻¹ H ` z ) ) S ( H ` ( ⁻¹ H ` w ) ) ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 29 : wff = bitr3d (step 8, step 28) |- ( ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( z ∈ B ∧ w ∈ B ) ) → ( z S w ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 30 : wff = ralrimivva (step 29) |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ;;
	step 31 : wff = jca (step 2, step 30) |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → ( ⁻¹ H : B ⤖ A ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ) ;;
	step 32 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 33 : wff = df-isom () |- ( ⁻¹ H Isom S , R ( B , A ) ↔ ( ⁻¹ H : B ⤖ A ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( ⁻¹ H ` z ) R ( ⁻¹ H ` w ) ) ) ) ;;
	step 34 : wff = 3imtr4i (step 31, step 32, step 33) |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	qed prop 1 = step 34 ;;
}

/*Converse law for isomorphism.  (Contributed by Mario Carneiro,
       30-Jan-2014.) */

theorem isocnv2 (A : class, B : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y, x y, x y H, x y R, x y S) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) ↔ H Isom ⁻¹ R , ⁻¹ S ( A , B ) ) ;;
}

proof of isocnv2 {
	var x : set, y : set;;
	step 1 : wff = ralcom () |- ( ∀ y ∈ A ∀ x ∈ A ( y R x ↔ ( H ` y ) S ( H ` x ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( y R x ↔ ( H ` y ) S ( H ` x ) ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = brcnv (step 2, step 3) |- ( x ⁻¹ R y ↔ y R x ) ;;
	step 5 : wff = fvex () |- ( H ` x ) ∈ _V ;;
	step 6 : wff = fvex () |- ( H ` y ) ∈ _V ;;
	step 7 : wff = brcnv (step 5, step 6) |- ( ( H ` x ) ⁻¹ S ( H ` y ) ↔ ( H ` y ) S ( H ` x ) ) ;;
	step 8 : wff = bibi12i (step 4, step 7) |- ( ( x ⁻¹ R y ↔ ( H ` x ) ⁻¹ S ( H ` y ) ) ↔ ( y R x ↔ ( H ` y ) S ( H ` x ) ) ) ;;
	step 9 : wff = 2ralbii (step 8) |- ( ∀ x ∈ A ∀ y ∈ A ( x ⁻¹ R y ↔ ( H ` x ) ⁻¹ S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( y R x ↔ ( H ` y ) S ( H ` x ) ) ) ;;
	step 10 : wff = bitr4i (step 1, step 9) |- ( ∀ y ∈ A ∀ x ∈ A ( y R x ↔ ( H ` y ) S ( H ` x ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x ⁻¹ R y ↔ ( H ` x ) ⁻¹ S ( H ` y ) ) ) ;;
	step 11 : wff = anbi2i (step 10) |- ( ( H : A ⤖ B ∧ ∀ y ∈ A ∀ x ∈ A ( y R x ↔ ( H ` y ) S ( H ` x ) ) ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x ⁻¹ R y ↔ ( H ` x ) ⁻¹ S ( H ` y ) ) ) ) ;;
	step 12 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ y ∈ A ∀ x ∈ A ( y R x ↔ ( H ` y ) S ( H ` x ) ) ) ) ;;
	step 13 : wff = df-isom () |- ( H Isom ⁻¹ R , ⁻¹ S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x ⁻¹ R y ↔ ( H ` x ) ⁻¹ S ( H ` y ) ) ) ) ;;
	step 14 : wff = 3bitr4i (step 11, step 12, step 13) |- ( H Isom R , S ( A , B ) ↔ H Isom ⁻¹ R , ⁻¹ S ( A , B ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Complementation law for isomorphism.  (Contributed by Mario Carneiro,
       9-Sep-2015.) */

theorem isocnv3 (A : class, B : class, C : class, D : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y C, x y D, x y H, x y R, x y S) {
	hyp 1 : wff = |- C = ( ( A × A ) ∖ R ) ;;
	hyp 2 : wff = |- D = ( ( B × B ) ∖ S ) ;;
	-----------------------
	prop 1 : wff = |- ( H Isom R , S ( A , B ) ↔ H Isom C , D ( A , B ) ) ;;
}

proof of isocnv3 {
	var x : set, y : set;;
	step 1 : wff = brxp () |- ( x ( A × A ) y ↔ ( x ∈ A ∧ y ∈ A ) ) ;;
	step 2 : wff = breqi (hyp 1) |- ( x C y ↔ x ( ( A × A ) ∖ R ) y ) ;;
	step 3 : wff = brdif () |- ( x ( ( A × A ) ∖ R ) y ↔ ( x ( A × A ) y ∧ ¬ x R y ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( x C y ↔ ( x ( A × A ) y ∧ ¬ x R y ) ) ;;
	step 5 : wff = baib (step 4) |- ( x ( A × A ) y → ( x C y ↔ ¬ x R y ) ) ;;
	step 6 : wff = sylbir (step 1, step 5) |- ( ( x ∈ A ∧ y ∈ A ) → ( x C y ↔ ¬ x R y ) ) ;;
	step 7 : wff = adantl (step 6) |- ( ( H : A ⤖ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( x C y ↔ ¬ x R y ) ) ;;
	step 8 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 9 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ x ∈ A ) → ( H ` x ) ∈ B ) ;;
	step 10 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ y ∈ A ) → ( H ` y ) ∈ B ) ;;
	step 11 : wff = anim12dan (step 9, step 10) |- ( ( H : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( H ` x ) ∈ B ∧ ( H ` y ) ∈ B ) ) ;;
	step 12 : wff = brxp () |- ( ( H ` x ) ( B × B ) ( H ` y ) ↔ ( ( H ` x ) ∈ B ∧ ( H ` y ) ∈ B ) ) ;;
	step 13 : wff = sylibr (step 11, step 12) |- ( ( H : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( H ` x ) ( B × B ) ( H ` y ) ) ;;
	step 14 : wff = sylan (step 8, step 13) |- ( ( H : A ⤖ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( H ` x ) ( B × B ) ( H ` y ) ) ;;
	step 15 : wff = breqi (hyp 2) |- ( ( H ` x ) D ( H ` y ) ↔ ( H ` x ) ( ( B × B ) ∖ S ) ( H ` y ) ) ;;
	step 16 : wff = brdif () |- ( ( H ` x ) ( ( B × B ) ∖ S ) ( H ` y ) ↔ ( ( H ` x ) ( B × B ) ( H ` y ) ∧ ¬ ( H ` x ) S ( H ` y ) ) ) ;;
	step 17 : wff = bitri (step 15, step 16) |- ( ( H ` x ) D ( H ` y ) ↔ ( ( H ` x ) ( B × B ) ( H ` y ) ∧ ¬ ( H ` x ) S ( H ` y ) ) ) ;;
	step 18 : wff = baib (step 17) |- ( ( H ` x ) ( B × B ) ( H ` y ) → ( ( H ` x ) D ( H ` y ) ↔ ¬ ( H ` x ) S ( H ` y ) ) ) ;;
	step 19 : wff = syl (step 14, step 18) |- ( ( H : A ⤖ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( H ` x ) D ( H ` y ) ↔ ¬ ( H ` x ) S ( H ` y ) ) ) ;;
	step 20 : wff = bibi12d (step 7, step 19) |- ( ( H : A ⤖ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( x C y ↔ ( H ` x ) D ( H ` y ) ) ↔ ( ¬ x R y ↔ ¬ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 21 : wff = notbi () |- ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( ¬ x R y ↔ ¬ ( H ` x ) S ( H ` y ) ) ) ;;
	step 22 : wff = syl6rbbr (step 20, step 21) |- ( ( H : A ⤖ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( x C y ↔ ( H ` x ) D ( H ` y ) ) ) ) ;;
	step 23 : wff = 2ralbidva (step 22) |- ( H : A ⤖ B → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x C y ↔ ( H ` x ) D ( H ` y ) ) ) ) ;;
	step 24 : wff = pm5.32i (step 23) |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x C y ↔ ( H ` x ) D ( H ` y ) ) ) ) ;;
	step 25 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 26 : wff = df-isom () |- ( H Isom C , D ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x C y ↔ ( H ` x ) D ( H ` y ) ) ) ) ;;
	step 27 : wff = 3bitr4i (step 24, step 25, step 26) |- ( H Isom R , S ( A , B ) ↔ H Isom C , D ( A , B ) ) ;;
	qed prop 1 = step 27 ;;
}

/*An isomorphism from one well-order to another can be restricted on
       either well-order.  (Contributed by Mario Carneiro, 15-Jan-2013.) */

theorem isores2 (A : class, B : class, R : class, S : class, H : class) disjointed(A x y, B x y, H x y, R x y, S x y) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) ↔ H Isom R , ( S ∩ ( B × B ) ) ( A , B ) ) ;;
}

proof of isores2 {
	var x : set, y : set;;
	step 1 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 2 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ x ∈ A ) → ( H ` x ) ∈ B ) ;;
	step 3 : wff = adantrr (step 2) |- ( ( H : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( H ` x ) ∈ B ) ;;
	step 4 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ y ∈ A ) → ( H ` y ) ∈ B ) ;;
	step 5 : wff = adantrl (step 4) |- ( ( H : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( H ` y ) ∈ B ) ;;
	step 6 : wff = brinxp () |- ( ( ( H ` x ) ∈ B ∧ ( H ` y ) ∈ B ) → ( ( H ` x ) S ( H ` y ) ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ;;
	step 7 : wff = syl2anc (step 3, step 5, step 6) |- ( ( H : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( H ` x ) S ( H ` y ) ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ;;
	step 8 : wff = sylan (step 1, step 7) |- ( ( H : A ⤖ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( H ` x ) S ( H ` y ) ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ;;
	step 9 : wff = anassrs (step 8) |- ( ( ( H : A ⤖ B ∧ x ∈ A ) ∧ y ∈ A ) → ( ( H ` x ) S ( H ` y ) ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ;;
	step 10 : wff = bibi2d (step 9) |- ( ( ( H : A ⤖ B ∧ x ∈ A ) ∧ y ∈ A ) → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( x R y ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ) ;;
	step 11 : wff = ralbidva (step 10) |- ( ( H : A ⤖ B ∧ x ∈ A ) → ( ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ y ∈ A ( x R y ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ) ;;
	step 12 : wff = ralbidva (step 11) |- ( H : A ⤖ B → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ) ;;
	step 13 : wff = pm5.32i (step 12) |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ) ;;
	step 14 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 15 : wff = df-isom () |- ( H Isom R , ( S ∩ ( B × B ) ) ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) ( S ∩ ( B × B ) ) ( H ` y ) ) ) ) ;;
	step 16 : wff = 3bitr4i (step 13, step 14, step 15) |- ( H Isom R , S ( A , B ) ↔ H Isom R , ( S ∩ ( B × B ) ) ( A , B ) ) ;;
	qed prop 1 = step 16 ;;
}

/*An isomorphism from one well-order to another can be restricted on
       either well-order.  (Contributed by Mario Carneiro, 15-Jan-2013.) */

theorem isores1 (A : class, B : class, R : class, S : class, H : class)  {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) ↔ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ;;
}

proof of isores1 {
	step 1 : wff = isocnv () |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 2 : wff = isores2 () |- ( ⁻¹ H Isom S , R ( B , A ) ↔ ⁻¹ H Isom S , ( R ∩ ( A × A ) ) ( B , A ) ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , ( R ∩ ( A × A ) ) ( B , A ) ) ;;
	step 4 : wff = isocnv () |- ( ⁻¹ H Isom S , ( R ∩ ( A × A ) ) ( B , A ) → ⁻¹ ⁻¹ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( H Isom R , S ( A , B ) → ⁻¹ ⁻¹ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ;;
	step 6 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 7 : wff = f1orel () |- ( H : A ⤖ B → Rel H ) ;;
	step 8 : wff = dfrel2 () |- ( Rel H ↔ ⁻¹ ⁻¹ H = H ) ;;
	step 9 : wff = isoeq1 () |- ( ⁻¹ ⁻¹ H = H → ( ⁻¹ ⁻¹ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ↔ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ) ;;
	step 10 : wff = sylbi (step 8, step 9) |- ( Rel H → ( ⁻¹ ⁻¹ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ↔ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ) ;;
	step 11 : wff = 3syl (step 6, step 7, step 10) |- ( H Isom R , S ( A , B ) → ( ⁻¹ ⁻¹ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ↔ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ) ;;
	step 12 : wff = mpbid (step 5, step 11) |- ( H Isom R , S ( A , B ) → H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ;;
	step 13 : wff = isocnv () |- ( H Isom ( R ∩ ( A × A ) ) , S ( A , B ) → ⁻¹ H Isom S , ( R ∩ ( A × A ) ) ( B , A ) ) ;;
	step 14 : wff = isores2 () |- ( ⁻¹ H Isom S , R ( B , A ) ↔ ⁻¹ H Isom S , ( R ∩ ( A × A ) ) ( B , A ) ) ;;
	step 15 : wff = sylibr (step 13, step 14) |- ( H Isom ( R ∩ ( A × A ) ) , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 16 : wff = isocnv () |- ( ⁻¹ H Isom S , R ( B , A ) → ⁻¹ ⁻¹ H Isom R , S ( A , B ) ) ;;
	step 17 : wff = syl (step 15, step 16) |- ( H Isom ( R ∩ ( A × A ) ) , S ( A , B ) → ⁻¹ ⁻¹ H Isom R , S ( A , B ) ) ;;
	step 18 : wff = isof1o () |- ( H Isom ( R ∩ ( A × A ) ) , S ( A , B ) → H : A ⤖ B ) ;;
	step 19 : wff = f1orel () |- ( H : A ⤖ B → Rel H ) ;;
	step 20 : wff = dfrel2 () |- ( Rel H ↔ ⁻¹ ⁻¹ H = H ) ;;
	step 21 : wff = isoeq1 () |- ( ⁻¹ ⁻¹ H = H → ( ⁻¹ ⁻¹ H Isom R , S ( A , B ) ↔ H Isom R , S ( A , B ) ) ) ;;
	step 22 : wff = sylbi (step 20, step 21) |- ( Rel H → ( ⁻¹ ⁻¹ H Isom R , S ( A , B ) ↔ H Isom R , S ( A , B ) ) ) ;;
	step 23 : wff = 3syl (step 18, step 19, step 22) |- ( H Isom ( R ∩ ( A × A ) ) , S ( A , B ) → ( ⁻¹ ⁻¹ H Isom R , S ( A , B ) ↔ H Isom R , S ( A , B ) ) ) ;;
	step 24 : wff = mpbid (step 17, step 23) |- ( H Isom ( R ∩ ( A × A ) ) , S ( A , B ) → H Isom R , S ( A , B ) ) ;;
	step 25 : wff = impbii (step 12, step 24) |- ( H Isom R , S ( A , B ) ↔ H Isom ( R ∩ ( A × A ) ) , S ( A , B ) ) ;;
	qed prop 1 = step 25 ;;
}

/*Induced isomorphism on a subset.  (Contributed by Stefan O'Rear,
       5-Nov-2014.) */

theorem isores3 (A : class, B : class, R : class, S : class, H : class, K : class, X : class) disjointed(H a b, R a b, S a b, K a b, A a b, B a b, X a b) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ K ⊆ A ∧ X = ( H " K ) ) → ( H ↾ K ) Isom R , S ( K , X ) ) ;;
}

proof of isores3 {
	var a : set, b : set;;
	step 1 : wff = f1of1 () |- ( H : A ⤖ B → H : A ↣ B ) ;;
	step 2 : wff = f1ores () |- ( ( H : A ↣ B ∧ K ⊆ A ) → ( H ↾ K ) : K ⤖ ( H " K ) ) ;;
	step 3 : wff = expcom (step 2) |- ( K ⊆ A → ( H : A ↣ B → ( H ↾ K ) : K ⤖ ( H " K ) ) ) ;;
	step 4 : wff = syl5 (step 1, step 3) |- ( K ⊆ A → ( H : A ⤖ B → ( H ↾ K ) : K ⤖ ( H " K ) ) ) ;;
	step 5 : wff = ssralv () |- ( K ⊆ A → ( ∀ a ∈ A ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ a ∈ K ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 6 : wff = ssralv () |- ( K ⊆ A → ( ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ b ∈ K ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( K ⊆ A ∧ a ∈ K ) → ( ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ b ∈ K ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 8 : wff = fvres () |- ( a ∈ K → ( ( H ↾ K ) ` a ) = ( H ` a ) ) ;;
	step 9 : wff = fvres () |- ( b ∈ K → ( ( H ↾ K ) ` b ) = ( H ` b ) ) ;;
	step 10 : wff = breqan12d (step 8, step 9) |- ( ( a ∈ K ∧ b ∈ K ) → ( ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ↔ ( H ` a ) S ( H ` b ) ) ) ;;
	step 11 : wff = adantll (step 10) |- ( ( ( K ⊆ A ∧ a ∈ K ) ∧ b ∈ K ) → ( ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ↔ ( H ` a ) S ( H ` b ) ) ) ;;
	step 12 : wff = bibi2d (step 11) |- ( ( ( K ⊆ A ∧ a ∈ K ) ∧ b ∈ K ) → ( ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ↔ ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 13 : wff = biimprd (step 12) |- ( ( ( K ⊆ A ∧ a ∈ K ) ∧ b ∈ K ) → ( ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ;;
	step 14 : wff = ralimdva (step 13) |- ( ( K ⊆ A ∧ a ∈ K ) → ( ∀ b ∈ K ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ b ∈ K ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ;;
	step 15 : wff = syld (step 7, step 14) |- ( ( K ⊆ A ∧ a ∈ K ) → ( ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ b ∈ K ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ;;
	step 16 : wff = ralimdva (step 15) |- ( K ⊆ A → ( ∀ a ∈ K ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ a ∈ K ∀ b ∈ K ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ;;
	step 17 : wff = syld (step 5, step 16) |- ( K ⊆ A → ( ∀ a ∈ A ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) → ∀ a ∈ K ∀ b ∈ K ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ;;
	step 18 : wff = anim12d (step 4, step 17) |- ( K ⊆ A → ( ( H : A ⤖ B ∧ ∀ a ∈ A ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) → ( ( H ↾ K ) : K ⤖ ( H " K ) ∧ ∀ a ∈ K ∀ b ∈ K ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ) ;;
	step 19 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ a ∈ A ∀ b ∈ A ( a R b ↔ ( H ` a ) S ( H ` b ) ) ) ) ;;
	step 20 : wff = df-isom () |- ( ( H ↾ K ) Isom R , S ( K , ( H " K ) ) ↔ ( ( H ↾ K ) : K ⤖ ( H " K ) ∧ ∀ a ∈ K ∀ b ∈ K ( a R b ↔ ( ( H ↾ K ) ` a ) S ( ( H ↾ K ) ` b ) ) ) ) ;;
	step 21 : wff = 3imtr4g (step 18, step 19, step 20) |- ( K ⊆ A → ( H Isom R , S ( A , B ) → ( H ↾ K ) Isom R , S ( K , ( H " K ) ) ) ) ;;
	step 22 : wff = impcom (step 21) |- ( ( H Isom R , S ( A , B ) ∧ K ⊆ A ) → ( H ↾ K ) Isom R , S ( K , ( H " K ) ) ) ;;
	step 23 : wff = isoeq5 () |- ( X = ( H " K ) → ( ( H ↾ K ) Isom R , S ( K , X ) ↔ ( H ↾ K ) Isom R , S ( K , ( H " K ) ) ) ) ;;
	step 24 : wff = syl5ibrcom (step 22, step 23) |- ( ( H Isom R , S ( A , B ) ∧ K ⊆ A ) → ( X = ( H " K ) → ( H ↾ K ) Isom R , S ( K , X ) ) ) ;;
	step 25 : wff = 3impia (step 24) |- ( ( H Isom R , S ( A , B ) ∧ K ⊆ A ∧ X = ( H " K ) ) → ( H ↾ K ) Isom R , S ( K , X ) ) ;;
	qed prop 1 = step 25 ;;
}

/*Composition (transitive) law for isomorphism.  Proposition 6.30(3) of
       [TakeutiZaring] p. 33.  (Contributed by NM, 27-Apr-2004.)  (Proof
       shortened by Mario Carneiro, 5-Dec-2016.) */

theorem isotr (A : class, B : class, C : class, R : class, S : class, T : class, G : class, H : class) disjointed(x y z w A, x y z w B, x y z w C, x y z w R, x y z w S, x y z w T, x y z w G, x y z w H) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ G Isom S , T ( B , C ) ) → ( G ∘ H ) Isom R , T ( A , C ) ) ;;
}

proof of isotr {
	var x : set, y : set, z : set, w : set;;
	step 1 : wff = simpl () |- ( ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) → G : B ⤖ C ) ;;
	step 2 : wff = simpl () |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → H : A ⤖ B ) ;;
	step 3 : wff = f1oco () |- ( ( G : B ⤖ C ∧ H : A ⤖ B ) → ( G ∘ H ) : A ⤖ C ) ;;
	step 4 : wff = syl2anr (step 1, step 2, step 3) |- ( ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) → ( G ∘ H ) : A ⤖ C ) ;;
	step 5 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 6 : wff = ad2antrr (step 5) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → H : A ⟶ B ) ;;
	step 7 : wff = simprl () |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → x ∈ A ) ;;
	step 8 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ x ∈ A ) → ( H ` x ) ∈ B ) ;;
	step 9 : wff = syl2anc (step 6, step 7, step 8) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( H ` x ) ∈ B ) ;;
	step 10 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 11 : wff = ad2antrr (step 10) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → H : A ⟶ B ) ;;
	step 12 : wff = simprr () |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → y ∈ A ) ;;
	step 13 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ y ∈ A ) → ( H ` y ) ∈ B ) ;;
	step 14 : wff = syl2anc (step 11, step 12, step 13) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( H ` y ) ∈ B ) ;;
	step 15 : wff = simplrr () |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ;;
	step 16 : wff = breq1 () |- ( z = ( H ` x ) → ( z S w ↔ ( H ` x ) S w ) ) ;;
	step 17 : wff = fveq2 () |- ( z = ( H ` x ) → ( G ` z ) = ( G ` ( H ` x ) ) ) ;;
	step 18 : wff = breq1d (step 17) |- ( z = ( H ` x ) → ( ( G ` z ) T ( G ` w ) ↔ ( G ` ( H ` x ) ) T ( G ` w ) ) ) ;;
	step 19 : wff = bibi12d (step 16, step 18) |- ( z = ( H ` x ) → ( ( z S w ↔ ( G ` z ) T ( G ` w ) ) ↔ ( ( H ` x ) S w ↔ ( G ` ( H ` x ) ) T ( G ` w ) ) ) ) ;;
	step 20 : wff = breq2 () |- ( w = ( H ` y ) → ( ( H ` x ) S w ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 21 : wff = fveq2 () |- ( w = ( H ` y ) → ( G ` w ) = ( G ` ( H ` y ) ) ) ;;
	step 22 : wff = breq2d (step 21) |- ( w = ( H ` y ) → ( ( G ` ( H ` x ) ) T ( G ` w ) ↔ ( G ` ( H ` x ) ) T ( G ` ( H ` y ) ) ) ) ;;
	step 23 : wff = bibi12d (step 20, step 22) |- ( w = ( H ` y ) → ( ( ( H ` x ) S w ↔ ( G ` ( H ` x ) ) T ( G ` w ) ) ↔ ( ( H ` x ) S ( H ` y ) ↔ ( G ` ( H ` x ) ) T ( G ` ( H ` y ) ) ) ) ) ;;
	step 24 : wff = rspc2va (step 19, step 23) |- ( ( ( ( H ` x ) ∈ B ∧ ( H ` y ) ∈ B ) ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) → ( ( H ` x ) S ( H ` y ) ↔ ( G ` ( H ` x ) ) T ( G ` ( H ` y ) ) ) ) ;;
	step 25 : wff = syl21anc (step 9, step 14, step 15, step 24) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( H ` x ) S ( H ` y ) ↔ ( G ` ( H ` x ) ) T ( G ` ( H ` y ) ) ) ) ;;
	step 26 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 27 : wff = ad2antrr (step 26) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → H : A ⟶ B ) ;;
	step 28 : wff = simprl () |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → x ∈ A ) ;;
	step 29 : wff = fvco3 () |- ( ( H : A ⟶ B ∧ x ∈ A ) → ( ( G ∘ H ) ` x ) = ( G ` ( H ` x ) ) ) ;;
	step 30 : wff = syl2anc (step 27, step 28, step 29) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( G ∘ H ) ` x ) = ( G ` ( H ` x ) ) ) ;;
	step 31 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 32 : wff = ad2antrr (step 31) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → H : A ⟶ B ) ;;
	step 33 : wff = simprr () |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → y ∈ A ) ;;
	step 34 : wff = fvco3 () |- ( ( H : A ⟶ B ∧ y ∈ A ) → ( ( G ∘ H ) ` y ) = ( G ` ( H ` y ) ) ) ;;
	step 35 : wff = syl2anc (step 32, step 33, step 34) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( G ∘ H ) ` y ) = ( G ` ( H ` y ) ) ) ;;
	step 36 : wff = breq12d (step 30, step 35) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ↔ ( G ` ( H ` x ) ) T ( G ` ( H ` y ) ) ) ) ;;
	step 37 : wff = bitr4d (step 25, step 36) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( H ` x ) S ( H ` y ) ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ;;
	step 38 : wff = bibi2d (step 37) |- ( ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ) ;;
	step 39 : wff = 2ralbidva (step 38) |- ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ↔ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ) ;;
	step 40 : wff = biimpd (step 39) |- ( ( H : A ⤖ B ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ) ;;
	step 41 : wff = impancom (step 40) |- ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) → ( ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ) ;;
	step 42 : wff = imp (step 41) |- ( ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) → ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ;;
	step 43 : wff = jca (step 4, step 42) |- ( ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) → ( ( G ∘ H ) : A ⤖ C ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ) ;;
	step 44 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 45 : wff = df-isom () |- ( G Isom S , T ( B , C ) ↔ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ;;
	step 46 : wff = anbi12i (step 44, step 45) |- ( ( H Isom R , S ( A , B ) ∧ G Isom S , T ( B , C ) ) ↔ ( ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ∧ ( G : B ⤖ C ∧ ∀ z ∈ B ∀ w ∈ B ( z S w ↔ ( G ` z ) T ( G ` w ) ) ) ) ) ;;
	step 47 : wff = df-isom () |- ( ( G ∘ H ) Isom R , T ( A , C ) ↔ ( ( G ∘ H ) : A ⤖ C ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( ( G ∘ H ) ` x ) T ( ( G ∘ H ) ` y ) ) ) ) ;;
	step 48 : wff = 3imtr4i (step 43, step 46, step 47) |- ( ( H Isom R , S ( A , B ) ∧ G Isom S , T ( B , C ) ) → ( G ∘ H ) Isom R , T ( A , C ) ) ;;
	qed prop 1 = step 48 ;;
}

/*Isomorphisms preserve minimal elements.  Note that ` ( ``' R " { D } ) `
       is Takeuti and Zaring's idiom for the initial segment
       ` { x | x R D } ` .  Proposition 6.31(1) of [TakeutiZaring] p. 33.
       (Contributed by NM, 19-Apr-2004.) */

theorem isomin (A : class, B : class, C : class, D : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y R, x y S, x y H, x y C, x y D) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ↔ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ) ;;
}

proof of isomin {
	var x : set, y : set;;
	step 1 : wff = neq0 () |- ( ¬ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ↔ ∃ y y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 2 : wff = ssel () |- ( C ⊆ A → ( x ∈ C → x ∈ A ) ) ;;
	step 3 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 4 : wff = f1ofn () |- ( H : A ⤖ B → H Fn A ) ;;
	step 5 : wff = fnbrfvb () |- ( ( H Fn A ∧ x ∈ A ) → ( ( H ` x ) = y ↔ x H y ) ) ;;
	step 6 : wff = ex (step 5) |- ( H Fn A → ( x ∈ A → ( ( H ` x ) = y ↔ x H y ) ) ) ;;
	step 7 : wff = 3syl (step 3, step 4, step 6) |- ( H Isom R , S ( A , B ) → ( x ∈ A → ( ( H ` x ) = y ↔ x H y ) ) ) ;;
	step 8 : wff = syl9r (step 2, step 7) |- ( H Isom R , S ( A , B ) → ( C ⊆ A → ( x ∈ C → ( ( H ` x ) = y ↔ x H y ) ) ) ) ;;
	step 9 : wff = imp31 (step 8) |- ( ( ( H Isom R , S ( A , B ) ∧ C ⊆ A ) ∧ x ∈ C ) → ( ( H ` x ) = y ↔ x H y ) ) ;;
	step 10 : wff = rexbidva (step 9) |- ( ( H Isom R , S ( A , B ) ∧ C ⊆ A ) → ( ∃ x ∈ C ( H ` x ) = y ↔ ∃ x ∈ C x H y ) ) ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = elima (step 11) |- ( y ∈ ( H " C ) ↔ ∃ x ∈ C x H y ) ;;
	step 13 : wff = syl6rbbr (step 10, step 12) |- ( ( H Isom R , S ( A , B ) ∧ C ⊆ A ) → ( y ∈ ( H " C ) ↔ ∃ x ∈ C ( H ` x ) = y ) ) ;;
	step 14 : wff = fvex () |- ( H ` D ) ∈ _V ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = eliniseg (step 15) |- ( ( H ` D ) ∈ _V → ( y ∈ ( ⁻¹ S " { ( H ` D ) } ) ↔ y S ( H ` D ) ) ) ;;
	step 17 : wff = mp1i (step 14, step 16) |- ( ( H Isom R , S ( A , B ) ∧ C ⊆ A ) → ( y ∈ ( ⁻¹ S " { ( H ` D ) } ) ↔ y S ( H ` D ) ) ) ;;
	step 18 : wff = anbi12d (step 13, step 17) |- ( ( H Isom R , S ( A , B ) ∧ C ⊆ A ) → ( ( y ∈ ( H " C ) ∧ y ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ( ∃ x ∈ C ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 19 : wff = elin () |- ( y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ( y ∈ ( H " C ) ∧ y ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 20 : wff = r19.41v () |- ( ∃ x ∈ C ( ( H ` x ) = y ∧ y S ( H ` D ) ) ↔ ( ∃ x ∈ C ( H ` x ) = y ∧ y S ( H ` D ) ) ) ;;
	step 21 : wff = 3bitr4g (step 18, step 19, step 20) |- ( ( H Isom R , S ( A , B ) ∧ C ⊆ A ) → ( y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ∃ x ∈ C ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 22 : wff = adantrr (step 21) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ∃ x ∈ C ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 23 : wff = ssel () |- ( C ⊆ A → ( x ∈ C → x ∈ A ) ) ;;
	step 24 : wff = breq1 () |- ( ( H ` x ) = y → ( ( H ` x ) S ( H ` D ) ↔ y S ( H ` D ) ) ) ;;
	step 25 : wff = biimpar (step 24) |- ( ( ( H ` x ) = y ∧ y S ( H ` D ) ) → ( H ` x ) S ( H ` D ) ) ;;
	step 26 : wff = vex () |- x ∈ _V ;;
	step 27 : wff = eliniseg (step 26) |- ( D ∈ A → ( x ∈ ( ⁻¹ R " { D } ) ↔ x R D ) ) ;;
	step 28 : wff = ad2antll (step 27) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x ∈ ( ⁻¹ R " { D } ) ↔ x R D ) ) ;;
	step 29 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x R D ↔ ( H ` x ) S ( H ` D ) ) ) ;;
	step 30 : wff = bitrd (step 28, step 29) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x ∈ ( ⁻¹ R " { D } ) ↔ ( H ` x ) S ( H ` D ) ) ) ;;
	step 31 : wff = syl5ibr (step 25, step 30) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( ( ( H ` x ) = y ∧ y S ( H ` D ) ) → x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 32 : wff = exp32 (step 31) |- ( H Isom R , S ( A , B ) → ( x ∈ A → ( D ∈ A → ( ( ( H ` x ) = y ∧ y S ( H ` D ) ) → x ∈ ( ⁻¹ R " { D } ) ) ) ) ) ;;
	step 33 : wff = syl9r (step 23, step 32) |- ( H Isom R , S ( A , B ) → ( C ⊆ A → ( x ∈ C → ( D ∈ A → ( ( ( H ` x ) = y ∧ y S ( H ` D ) ) → x ∈ ( ⁻¹ R " { D } ) ) ) ) ) ) ;;
	step 34 : wff = com34 (step 33) |- ( H Isom R , S ( A , B ) → ( C ⊆ A → ( D ∈ A → ( x ∈ C → ( ( ( H ` x ) = y ∧ y S ( H ` D ) ) → x ∈ ( ⁻¹ R " { D } ) ) ) ) ) ) ;;
	step 35 : wff = imp32 (step 34) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( x ∈ C → ( ( ( H ` x ) = y ∧ y S ( H ` D ) ) → x ∈ ( ⁻¹ R " { D } ) ) ) ) ;;
	step 36 : wff = reximdvai (step 35) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ∃ x ∈ C ( ( H ` x ) = y ∧ y S ( H ` D ) ) → ∃ x ∈ C x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 37 : wff = sylbid (step 22, step 36) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) → ∃ x ∈ C x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 38 : wff = elin () |- ( x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) ↔ ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 39 : wff = exbii (step 38) |- ( ∃ x x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) ↔ ∃ x ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 40 : wff = neq0 () |- ( ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ↔ ∃ x x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) ) ;;
	step 41 : wff = df-rex () |- ( ∃ x ∈ C x ∈ ( ⁻¹ R " { D } ) ↔ ∃ x ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 42 : wff = 3bitr4i (step 39, step 40, step 41) |- ( ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ↔ ∃ x ∈ C x ∈ ( ⁻¹ R " { D } ) ) ;;
	step 43 : wff = syl6ibr (step 37, step 42) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) → ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ) ) ;;
	step 44 : wff = exlimdv (step 43) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ∃ y y ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) → ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ) ) ;;
	step 45 : wff = syl5bi (step 1, step 44) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ¬ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ → ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ) ) ;;
	step 46 : wff = con4d (step 45) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ → ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ) ;;
	step 47 : wff = neq0 () |- ( ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ↔ ∃ x x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) ) ;;
	step 48 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 49 : wff = f1ofn () |- ( H : A ⤖ B → H Fn A ) ;;
	step 50 : wff = syl (step 48, step 49) |- ( H Isom R , S ( A , B ) → H Fn A ) ;;
	step 51 : wff = fnfvima () |- ( ( H Fn A ∧ C ⊆ A ∧ x ∈ C ) → ( H ` x ) ∈ ( H " C ) ) ;;
	step 52 : wff = 3expia (step 51) |- ( ( H Fn A ∧ C ⊆ A ) → ( x ∈ C → ( H ` x ) ∈ ( H " C ) ) ) ;;
	step 53 : wff = adantrr (step 52) |- ( ( H Fn A ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( x ∈ C → ( H ` x ) ∈ ( H " C ) ) ) ;;
	step 54 : wff = sylan (step 50, step 53) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( x ∈ C → ( H ` x ) ∈ ( H " C ) ) ) ;;
	step 55 : wff = adantrd (step 54) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) → ( H ` x ) ∈ ( H " C ) ) ) ;;
	step 56 : wff = ssel () |- ( C ⊆ A → ( x ∈ C → x ∈ A ) ) ;;
	step 57 : wff = vex () |- x ∈ _V ;;
	step 58 : wff = eliniseg (step 57) |- ( D ∈ A → ( x ∈ ( ⁻¹ R " { D } ) ↔ x R D ) ) ;;
	step 59 : wff = ad2antll (step 58) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x ∈ ( ⁻¹ R " { D } ) ↔ x R D ) ) ;;
	step 60 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x R D ↔ ( H ` x ) S ( H ` D ) ) ) ;;
	step 61 : wff = biimpd (step 60) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x R D → ( H ` x ) S ( H ` D ) ) ) ;;
	step 62 : wff = fvex () |- ( H ` D ) ∈ _V ;;
	step 63 : wff = fvex () |- ( H ` x ) ∈ _V ;;
	step 64 : wff = eliniseg (step 63) |- ( ( H ` D ) ∈ _V → ( ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ↔ ( H ` x ) S ( H ` D ) ) ) ;;
	step 65 : wff = ax-mp (step 62, step 64) |- ( ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ↔ ( H ` x ) S ( H ` D ) ) ;;
	step 66 : wff = syl6ibr (step 61, step 65) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x R D → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 67 : wff = sylbid (step 59, step 66) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x ∈ ( ⁻¹ R " { D } ) → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 68 : wff = exp32 (step 67) |- ( H Isom R , S ( A , B ) → ( x ∈ A → ( D ∈ A → ( x ∈ ( ⁻¹ R " { D } ) → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ) ) ;;
	step 69 : wff = syl9r (step 56, step 68) |- ( H Isom R , S ( A , B ) → ( C ⊆ A → ( x ∈ C → ( D ∈ A → ( x ∈ ( ⁻¹ R " { D } ) → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ) ) ) ;;
	step 70 : wff = com34 (step 69) |- ( H Isom R , S ( A , B ) → ( C ⊆ A → ( D ∈ A → ( x ∈ C → ( x ∈ ( ⁻¹ R " { D } ) → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ) ) ) ;;
	step 71 : wff = imp32 (step 70) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( x ∈ C → ( x ∈ ( ⁻¹ R " { D } ) → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ) ;;
	step 72 : wff = imp3a (step 71) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) → ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 73 : wff = jcad (step 55, step 72) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) → ( ( H ` x ) ∈ ( H " C ) ∧ ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ) ;;
	step 74 : wff = elin () |- ( x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) ↔ ( x ∈ C ∧ x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 75 : wff = elin () |- ( ( H ` x ) ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ( ( H ` x ) ∈ ( H " C ) ∧ ( H ` x ) ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 76 : wff = 3imtr4g (step 73, step 74, step 75) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) → ( H ` x ) ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ) ) ;;
	step 77 : wff = n0i () |- ( ( H ` x ) ∈ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) → ¬ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ;;
	step 78 : wff = syl6 (step 76, step 77) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) → ¬ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ) ;;
	step 79 : wff = exlimdv (step 78) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ∃ x x ∈ ( C ∩ ( ⁻¹ R " { D } ) ) → ¬ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ) ;;
	step 80 : wff = syl5bi (step 47, step 79) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ¬ ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ → ¬ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ) ;;
	step 81 : wff = impcon4bid (step 46, step 80) |- ( ( H Isom R , S ( A , B ) ∧ ( C ⊆ A ∧ D ∈ A ) ) → ( ( C ∩ ( ⁻¹ R " { D } ) ) = ∅ ↔ ( ( H " C ) ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = ∅ ) ) ;;
	qed prop 1 = step 81 ;;
}

/*Isomorphisms preserve initial segments.  Proposition 6.31(2) of
       [TakeutiZaring] p. 33.  (Contributed by NM, 20-Apr-2004.) */

theorem isoini (A : class, B : class, D : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y R, x y S, x y H, x y D) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( H " ( A ∩ ( ⁻¹ R " { D } ) ) ) = ( B ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
}

proof of isoini {
	var x : set, y : set;;
	step 1 : wff = elin () |- ( y ∈ ( B ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ( y ∈ B ∧ y ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	step 2 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 3 : wff = f1ofo () |- ( H : A ⤖ B → H : A ↠ B ) ;;
	step 4 : wff = forn () |- ( H : A ↠ B → ran H = B ) ;;
	step 5 : wff = eleq2d (step 4) |- ( H : A ↠ B → ( y ∈ ran H ↔ y ∈ B ) ) ;;
	step 6 : wff = 3syl (step 2, step 3, step 5) |- ( H Isom R , S ( A , B ) → ( y ∈ ran H ↔ y ∈ B ) ) ;;
	step 7 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 8 : wff = f1ofn () |- ( H : A ⤖ B → H Fn A ) ;;
	step 9 : wff = fvelrnb () |- ( H Fn A → ( y ∈ ran H ↔ ∃ x ∈ A ( H ` x ) = y ) ) ;;
	step 10 : wff = 3syl (step 7, step 8, step 9) |- ( H Isom R , S ( A , B ) → ( y ∈ ran H ↔ ∃ x ∈ A ( H ` x ) = y ) ) ;;
	step 11 : wff = bitr3d (step 6, step 10) |- ( H Isom R , S ( A , B ) → ( y ∈ B ↔ ∃ x ∈ A ( H ` x ) = y ) ) ;;
	step 12 : wff = fvex () |- ( H ` D ) ∈ _V ;;
	step 13 : wff = vex () |- y ∈ _V ;;
	step 14 : wff = eliniseg (step 13) |- ( ( H ` D ) ∈ _V → ( y ∈ ( ⁻¹ S " { ( H ` D ) } ) ↔ y S ( H ` D ) ) ) ;;
	step 15 : wff = mp1i (step 12, step 14) |- ( H Isom R , S ( A , B ) → ( y ∈ ( ⁻¹ S " { ( H ` D ) } ) ↔ y S ( H ` D ) ) ) ;;
	step 16 : wff = anbi12d (step 11, step 15) |- ( H Isom R , S ( A , B ) → ( ( y ∈ B ∧ y ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ( ∃ x ∈ A ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 17 : wff = adantr (step 16) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ( y ∈ B ∧ y ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ( ∃ x ∈ A ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 18 : wff = elin () |- ( x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) ↔ ( x ∈ A ∧ x ∈ ( ⁻¹ R " { D } ) ) ) ;;
	step 19 : wff = vex () |- x ∈ _V ;;
	step 20 : wff = eliniseg (step 19) |- ( D ∈ A → ( x ∈ ( ⁻¹ R " { D } ) ↔ x R D ) ) ;;
	step 21 : wff = anbi2d (step 20) |- ( D ∈ A → ( ( x ∈ A ∧ x ∈ ( ⁻¹ R " { D } ) ) ↔ ( x ∈ A ∧ x R D ) ) ) ;;
	step 22 : wff = syl5bb (step 18, step 21) |- ( D ∈ A → ( x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) ↔ ( x ∈ A ∧ x R D ) ) ) ;;
	step 23 : wff = anbi1d (step 22) |- ( D ∈ A → ( ( x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) ∧ x H y ) ↔ ( ( x ∈ A ∧ x R D ) ∧ x H y ) ) ) ;;
	step 24 : wff = anass () |- ( ( ( x ∈ A ∧ x R D ) ∧ x H y ) ↔ ( x ∈ A ∧ ( x R D ∧ x H y ) ) ) ;;
	step 25 : wff = syl6bb (step 23, step 24) |- ( D ∈ A → ( ( x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) ∧ x H y ) ↔ ( x ∈ A ∧ ( x R D ∧ x H y ) ) ) ) ;;
	step 26 : wff = adantl (step 25) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ( x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) ∧ x H y ) ↔ ( x ∈ A ∧ ( x R D ∧ x H y ) ) ) ) ;;
	step 27 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x R D ↔ ( H ` x ) S ( H ` D ) ) ) ;;
	step 28 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 29 : wff = f1ofn () |- ( H : A ⤖ B → H Fn A ) ;;
	step 30 : wff = syl (step 28, step 29) |- ( H Isom R , S ( A , B ) → H Fn A ) ;;
	step 31 : wff = fnbrfvb () |- ( ( H Fn A ∧ x ∈ A ) → ( ( H ` x ) = y ↔ x H y ) ) ;;
	step 32 : wff = bicomd (step 31) |- ( ( H Fn A ∧ x ∈ A ) → ( x H y ↔ ( H ` x ) = y ) ) ;;
	step 33 : wff = sylan (step 30, step 32) |- ( ( H Isom R , S ( A , B ) ∧ x ∈ A ) → ( x H y ↔ ( H ` x ) = y ) ) ;;
	step 34 : wff = adantrr (step 33) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( x H y ↔ ( H ` x ) = y ) ) ;;
	step 35 : wff = anbi12d (step 27, step 34) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( ( x R D ∧ x H y ) ↔ ( ( H ` x ) S ( H ` D ) ∧ ( H ` x ) = y ) ) ) ;;
	step 36 : wff = ancom () |- ( ( ( H ` x ) S ( H ` D ) ∧ ( H ` x ) = y ) ↔ ( ( H ` x ) = y ∧ ( H ` x ) S ( H ` D ) ) ) ;;
	step 37 : wff = breq1 () |- ( ( H ` x ) = y → ( ( H ` x ) S ( H ` D ) ↔ y S ( H ` D ) ) ) ;;
	step 38 : wff = pm5.32i (step 37) |- ( ( ( H ` x ) = y ∧ ( H ` x ) S ( H ` D ) ) ↔ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ;;
	step 39 : wff = bitri (step 36, step 38) |- ( ( ( H ` x ) S ( H ` D ) ∧ ( H ` x ) = y ) ↔ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ;;
	step 40 : wff = syl6bb (step 35, step 39) |- ( ( H Isom R , S ( A , B ) ∧ ( x ∈ A ∧ D ∈ A ) ) → ( ( x R D ∧ x H y ) ↔ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 41 : wff = exp32 (step 40) |- ( H Isom R , S ( A , B ) → ( x ∈ A → ( D ∈ A → ( ( x R D ∧ x H y ) ↔ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ) ) ;;
	step 42 : wff = com23 (step 41) |- ( H Isom R , S ( A , B ) → ( D ∈ A → ( x ∈ A → ( ( x R D ∧ x H y ) ↔ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ) ) ;;
	step 43 : wff = imp (step 42) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( x ∈ A → ( ( x R D ∧ x H y ) ↔ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ) ;;
	step 44 : wff = pm5.32d (step 43) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ( x ∈ A ∧ ( x R D ∧ x H y ) ) ↔ ( x ∈ A ∧ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ) ;;
	step 45 : wff = bitrd (step 26, step 44) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ( x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) ∧ x H y ) ↔ ( x ∈ A ∧ ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ) ;;
	step 46 : wff = rexbidv2 (step 45) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ∃ x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) x H y ↔ ∃ x ∈ A ( ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 47 : wff = r19.41v () |- ( ∃ x ∈ A ( ( H ` x ) = y ∧ y S ( H ` D ) ) ↔ ( ∃ x ∈ A ( H ` x ) = y ∧ y S ( H ` D ) ) ) ;;
	step 48 : wff = syl6bb (step 46, step 47) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ∃ x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) x H y ↔ ( ∃ x ∈ A ( H ` x ) = y ∧ y S ( H ` D ) ) ) ) ;;
	step 49 : wff = bitr4d (step 17, step 48) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( ( y ∈ B ∧ y ∈ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ∃ x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) x H y ) ) ;;
	step 50 : wff = syl5bb (step 1, step 49) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( y ∈ ( B ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ↔ ∃ x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) x H y ) ) ;;
	step 51 : wff = abbi2dv (step 50) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( B ∩ ( ⁻¹ S " { ( H ` D ) } ) ) = { y | ∃ x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) x H y } ) ;;
	step 52 : wff = dfima2 () |- ( H " ( A ∩ ( ⁻¹ R " { D } ) ) ) = { y | ∃ x ∈ ( A ∩ ( ⁻¹ R " { D } ) ) x H y } ;;
	step 53 : wff = syl6reqr (step 51, step 52) |- ( ( H Isom R , S ( A , B ) ∧ D ∈ A ) → ( H " ( A ∩ ( ⁻¹ R " { D } ) ) ) = ( B ∩ ( ⁻¹ S " { ( H ` D ) } ) ) ) ;;
	qed prop 1 = step 53 ;;
}

/*Isomorphisms are isomorphisms on their initial segments.  (Contributed
       by Mario Carneiro, 29-Mar-2014.) */

theorem isoini2 (A : class, B : class, C : class, D : class, R : class, S : class, H : class, X : class) disjointed(x y A, x y B, x y C, x y D, x y H, x y R, x y S) {
	hyp 1 : wff = |- C = ( A ∩ ( ⁻¹ R " { X } ) ) ;;
	hyp 2 : wff = |- D = ( B ∩ ( ⁻¹ S " { ( H ` X ) } ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( H ↾ C ) Isom R , S ( C , D ) ) ;;
}

proof of isoini2 {
	var x : set, y : set;;
	step 1 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 2 : wff = f1of1 () |- ( H : A ⤖ B → H : A ↣ B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( H Isom R , S ( A , B ) → H : A ↣ B ) ;;
	step 4 : wff = adantr (step 3) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → H : A ↣ B ) ;;
	step 5 : wff = inss1 () |- ( A ∩ ( ⁻¹ R " { X } ) ) ⊆ A ;;
	step 6 : wff = eqsstri (hyp 1, step 5) |- C ⊆ A ;;
	step 7 : wff = f1ores () |- ( ( H : A ↣ B ∧ C ⊆ A ) → ( H ↾ C ) : C ⤖ ( H " C ) ) ;;
	step 8 : wff = sylancl (step 4, step 6, step 7) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( H ↾ C ) : C ⤖ ( H " C ) ) ;;
	step 9 : wff = isoini () |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( H " ( A ∩ ( ⁻¹ R " { X } ) ) ) = ( B ∩ ( ⁻¹ S " { ( H ` X ) } ) ) ) ;;
	step 10 : wff = imaeq2i (hyp 1) |- ( H " C ) = ( H " ( A ∩ ( ⁻¹ R " { X } ) ) ) ;;
	step 11 : wff = 3eqtr4g (step 9, step 10, hyp 2) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( H " C ) = D ) ;;
	step 12 : wff = f1oeq3 () |- ( ( H " C ) = D → ( ( H ↾ C ) : C ⤖ ( H " C ) ↔ ( H ↾ C ) : C ⤖ D ) ) ;;
	step 13 : wff = syl (step 11, step 12) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( ( H ↾ C ) : C ⤖ ( H " C ) ↔ ( H ↾ C ) : C ⤖ D ) ) ;;
	step 14 : wff = mpbid (step 8, step 13) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( H ↾ C ) : C ⤖ D ) ;;
	step 15 : wff = inss1 () |- ( A ∩ ( ⁻¹ R " { X } ) ) ⊆ A ;;
	step 16 : wff = eqsstri (hyp 1, step 15) |- C ⊆ A ;;
	step 17 : wff = inss1 () |- ( A ∩ ( ⁻¹ R " { X } ) ) ⊆ A ;;
	step 18 : wff = eqsstri (hyp 1, step 17) |- C ⊆ A ;;
	step 19 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 20 : wff = simprbi (step 19) |- ( H Isom R , S ( A , B ) → ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 21 : wff = adantr (step 20) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 22 : wff = ssralv () |- ( C ⊆ A → ( ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) → ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 23 : wff = ralimdv (step 22) |- ( C ⊆ A → ( ∀ x ∈ A ∀ y ∈ A ( x R y ↔ ( H ` x ) S ( H ` y ) ) → ∀ x ∈ A ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 24 : wff = mpsyl (step 18, step 21, step 23) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ∀ x ∈ A ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 25 : wff = ssralv () |- ( C ⊆ A → ( ∀ x ∈ A ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) → ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 26 : wff = mpsyl (step 16, step 24, step 25) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 27 : wff = fvres () |- ( x ∈ C → ( ( H ↾ C ) ` x ) = ( H ` x ) ) ;;
	step 28 : wff = fvres () |- ( y ∈ C → ( ( H ↾ C ) ` y ) = ( H ` y ) ) ;;
	step 29 : wff = breqan12d (step 27, step 28) |- ( ( x ∈ C ∧ y ∈ C ) → ( ( ( H ↾ C ) ` x ) S ( ( H ↾ C ) ` y ) ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 30 : wff = bibi2d (step 29) |- ( ( x ∈ C ∧ y ∈ C ) → ( ( x R y ↔ ( ( H ↾ C ) ` x ) S ( ( H ↾ C ) ` y ) ) ↔ ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 31 : wff = ralbidva (step 30) |- ( x ∈ C → ( ∀ y ∈ C ( x R y ↔ ( ( H ↾ C ) ` x ) S ( ( H ↾ C ) ` y ) ) ↔ ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ) ;;
	step 32 : wff = ralbiia (step 31) |- ( ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( ( H ↾ C ) ` x ) S ( ( H ↾ C ) ` y ) ) ↔ ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( H ` x ) S ( H ` y ) ) ) ;;
	step 33 : wff = sylibr (step 26, step 32) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( ( H ↾ C ) ` x ) S ( ( H ↾ C ) ` y ) ) ) ;;
	step 34 : wff = df-isom () |- ( ( H ↾ C ) Isom R , S ( C , D ) ↔ ( ( H ↾ C ) : C ⤖ D ∧ ∀ x ∈ C ∀ y ∈ C ( x R y ↔ ( ( H ↾ C ) ` x ) S ( ( H ↾ C ) ` y ) ) ) ) ;;
	step 35 : wff = sylanbrc (step 14, step 33, step 34) |- ( ( H Isom R , S ( A , B ) ∧ X ∈ A ) → ( H ↾ C ) Isom R , S ( C , D ) ) ;;
	qed prop 1 = step 35 ;;
}

/*Lemma for ~ isofr .  (Contributed by NM, 29-Apr-2004.)  (Revised by
       Mario Carneiro, 18-Nov-2014.) */

theorem isofrlem (ph : wff, x : set, A : class, B : class, R : class, S : class, H : class) disjointed(w x y z A, w x y z B, w x y z H, w x y z ph, w x y z R, w x y z S) {
	hyp 1 : wff = |- ( ph → H Isom R , S ( A , B ) ) ;;
	hyp 2 : wff = |- ( ph → ( H " x ) ∈ _V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( S Fr B → R Fr A ) ) ;;
}

proof of isofrlem {
	var y : set, z : set, w : set;;
	step 1 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → H : A ⤖ B ) ;;
	step 3 : wff = f1ofn () |- ( H : A ⤖ B → H Fn A ) ;;
	step 4 : wff = n0 () |- ( x ≠ ∅ ↔ ∃ y y ∈ x ) ;;
	step 5 : wff = fnfvima () |- ( ( H Fn A ∧ x ⊆ A ∧ y ∈ x ) → ( H ` y ) ∈ ( H " x ) ) ;;
	step 6 : wff = ne0i () |- ( ( H ` y ) ∈ ( H " x ) → ( H " x ) ≠ ∅ ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ( H Fn A ∧ x ⊆ A ∧ y ∈ x ) → ( H " x ) ≠ ∅ ) ;;
	step 8 : wff = 3expia (step 7) |- ( ( H Fn A ∧ x ⊆ A ) → ( y ∈ x → ( H " x ) ≠ ∅ ) ) ;;
	step 9 : wff = exlimdv (step 8) |- ( ( H Fn A ∧ x ⊆ A ) → ( ∃ y y ∈ x → ( H " x ) ≠ ∅ ) ) ;;
	step 10 : wff = syl5bi (step 4, step 9) |- ( ( H Fn A ∧ x ⊆ A ) → ( x ≠ ∅ → ( H " x ) ≠ ∅ ) ) ;;
	step 11 : wff = expimpd (step 10) |- ( H Fn A → ( ( x ⊆ A ∧ x ≠ ∅ ) → ( H " x ) ≠ ∅ ) ) ;;
	step 12 : wff = syl (step 3, step 11) |- ( H : A ⤖ B → ( ( x ⊆ A ∧ x ≠ ∅ ) → ( H " x ) ≠ ∅ ) ) ;;
	step 13 : wff = f1ofo () |- ( H : A ⤖ B → H : A ↠ B ) ;;
	step 14 : wff = imassrn () |- ( H " x ) ⊆ ran H ;;
	step 15 : wff = forn () |- ( H : A ↠ B → ran H = B ) ;;
	step 16 : wff = syl5sseq (step 14, step 15) |- ( H : A ↠ B → ( H " x ) ⊆ B ) ;;
	step 17 : wff = syl (step 13, step 16) |- ( H : A ⤖ B → ( H " x ) ⊆ B ) ;;
	step 18 : wff = jctild (step 12, step 17) |- ( H : A ⤖ B → ( ( x ⊆ A ∧ x ≠ ∅ ) → ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) ) ) ;;
	step 19 : wff = syl (step 2, step 18) |- ( ph → ( ( x ⊆ A ∧ x ≠ ∅ ) → ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) ) ) ;;
	step 20 : wff = dffr3 () |- ( S Fr B ↔ ∀ z ( ( z ⊆ B ∧ z ≠ ∅ ) → ∃ w ∈ z ( z ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ;;
	step 21 : wff = sseq1 () |- ( z = ( H " x ) → ( z ⊆ B ↔ ( H " x ) ⊆ B ) ) ;;
	step 22 : wff = neeq1 () |- ( z = ( H " x ) → ( z ≠ ∅ ↔ ( H " x ) ≠ ∅ ) ) ;;
	step 23 : wff = anbi12d (step 21, step 22) |- ( z = ( H " x ) → ( ( z ⊆ B ∧ z ≠ ∅ ) ↔ ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) ) ) ;;
	step 24 : wff = ineq1 () |- ( z = ( H " x ) → ( z ∩ ( ⁻¹ S " { w } ) ) = ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) ) ;;
	step 25 : wff = eqeq1d (step 24) |- ( z = ( H " x ) → ( ( z ∩ ( ⁻¹ S " { w } ) ) = ∅ ↔ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ;;
	step 26 : wff = rexeqbi1dv (step 25) |- ( z = ( H " x ) → ( ∃ w ∈ z ( z ∩ ( ⁻¹ S " { w } ) ) = ∅ ↔ ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ;;
	step 27 : wff = imbi12d (step 23, step 26) |- ( z = ( H " x ) → ( ( ( z ⊆ B ∧ z ≠ ∅ ) → ∃ w ∈ z ( z ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ↔ ( ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) → ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ) ;;
	step 28 : wff = spcgv (step 27) |- ( ( H " x ) ∈ _V → ( ∀ z ( ( z ⊆ B ∧ z ≠ ∅ ) → ∃ w ∈ z ( z ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) → ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ) ;;
	step 29 : wff = syl (hyp 2, step 28) |- ( ph → ( ∀ z ( ( z ⊆ B ∧ z ≠ ∅ ) → ∃ w ∈ z ( z ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) → ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ) ;;
	step 30 : wff = syl5bi (step 20, step 29) |- ( ph → ( S Fr B → ( ( ( H " x ) ⊆ B ∧ ( H " x ) ≠ ∅ ) → ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ) ;;
	step 31 : wff = syl5d (step 19, step 30) |- ( ph → ( S Fr B → ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ) ;;
	step 32 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 33 : wff = syl (hyp 1, step 32) |- ( ph → H : A ⤖ B ) ;;
	step 34 : wff = adantr (step 33) |- ( ( ph ∧ x ⊆ A ) → H : A ⤖ B ) ;;
	step 35 : wff = f1ofun () |- ( H : A ⤖ B → Fun H ) ;;
	step 36 : wff = syl (step 34, step 35) |- ( ( ph ∧ x ⊆ A ) → Fun H ) ;;
	step 37 : wff = simpl () |- ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → w ∈ ( H " x ) ) ;;
	step 38 : wff = fvelima () |- ( ( Fun H ∧ w ∈ ( H " x ) ) → ∃ y ∈ x ( H ` y ) = w ) ;;
	step 39 : wff = syl2an (step 36, step 37, step 38) |- ( ( ( ph ∧ x ⊆ A ) ∧ ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) → ∃ y ∈ x ( H ` y ) = w ) ;;
	step 40 : wff = simpr () |- ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ;;
	step 41 : wff = ssel () |- ( x ⊆ A → ( y ∈ x → y ∈ A ) ) ;;
	step 42 : wff = imdistani (step 41) |- ( ( x ⊆ A ∧ y ∈ x ) → ( x ⊆ A ∧ y ∈ A ) ) ;;
	step 43 : wff = isomin () |- ( ( H Isom R , S ( A , B ) ∧ ( x ⊆ A ∧ y ∈ A ) ) → ( ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ↔ ( ( H " x ) ∩ ( ⁻¹ S " { ( H ` y ) } ) ) = ∅ ) ) ;;
	step 44 : wff = syl2an (hyp 1, step 42, step 43) |- ( ( ph ∧ ( x ⊆ A ∧ y ∈ x ) ) → ( ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ↔ ( ( H " x ) ∩ ( ⁻¹ S " { ( H ` y ) } ) ) = ∅ ) ) ;;
	step 45 : wff = sneq () |- ( ( H ` y ) = w → { ( H ` y ) } = { w } ) ;;
	step 46 : wff = imaeq2d (step 45) |- ( ( H ` y ) = w → ( ⁻¹ S " { ( H ` y ) } ) = ( ⁻¹ S " { w } ) ) ;;
	step 47 : wff = ineq2d (step 46) |- ( ( H ` y ) = w → ( ( H " x ) ∩ ( ⁻¹ S " { ( H ` y ) } ) ) = ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) ) ;;
	step 48 : wff = eqeq1d (step 47) |- ( ( H ` y ) = w → ( ( ( H " x ) ∩ ( ⁻¹ S " { ( H ` y ) } ) ) = ∅ ↔ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ;;
	step 49 : wff = sylan9bb (step 44, step 48) |- ( ( ( ph ∧ ( x ⊆ A ∧ y ∈ x ) ) ∧ ( H ` y ) = w ) → ( ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ↔ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) ;;
	step 50 : wff = syl5ibr (step 40, step 49) |- ( ( ( ph ∧ ( x ⊆ A ∧ y ∈ x ) ) ∧ ( H ` y ) = w ) → ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ;;
	step 51 : wff = exp42 (step 50) |- ( ph → ( x ⊆ A → ( y ∈ x → ( ( H ` y ) = w → ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ) ) ;;
	step 52 : wff = imp (step 51) |- ( ( ph ∧ x ⊆ A ) → ( y ∈ x → ( ( H ` y ) = w → ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ) ;;
	step 53 : wff = com3l (step 52) |- ( y ∈ x → ( ( H ` y ) = w → ( ( ph ∧ x ⊆ A ) → ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ) ;;
	step 54 : wff = com4t (step 53) |- ( ( ph ∧ x ⊆ A ) → ( ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( y ∈ x → ( ( H ` y ) = w → ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ) ;;
	step 55 : wff = imp (step 54) |- ( ( ( ph ∧ x ⊆ A ) ∧ ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) → ( y ∈ x → ( ( H ` y ) = w → ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 56 : wff = reximdvai (step 55) |- ( ( ( ph ∧ x ⊆ A ) ∧ ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) → ( ∃ y ∈ x ( H ` y ) = w → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ;;
	step 57 : wff = mpd (step 39, step 56) |- ( ( ( ph ∧ x ⊆ A ) ∧ ( w ∈ ( H " x ) ∧ ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ;;
	step 58 : wff = exp32 (step 57) |- ( ( ph ∧ x ⊆ A ) → ( w ∈ ( H " x ) → ( ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 59 : wff = rexlimdv (step 58) |- ( ( ph ∧ x ⊆ A ) → ( ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ;;
	step 60 : wff = ex (step 59) |- ( ph → ( x ⊆ A → ( ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 61 : wff = adantrd (step 60) |- ( ph → ( ( x ⊆ A ∧ x ≠ ∅ ) → ( ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 62 : wff = a2d (step 61) |- ( ph → ( ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ w ∈ ( H " x ) ( ( H " x ) ∩ ( ⁻¹ S " { w } ) ) = ∅ ) → ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 63 : wff = syld (step 31, step 62) |- ( ph → ( S Fr B → ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 64 : wff = alrimdv (step 63) |- ( ph → ( S Fr B → ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ) ;;
	step 65 : wff = dffr3 () |- ( R Fr A ↔ ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ;;
	step 66 : wff = syl6ibr (step 64, step 65) |- ( ph → ( S Fr B → R Fr A ) ) ;;
	qed prop 1 = step 66 ;;
}

/*Lemma for ~ isose .  (Contributed by Mario Carneiro, 23-Jun-2015.) */

theorem isoselem (ph : wff, x : set, A : class, B : class, R : class, S : class, H : class) disjointed(x y z A, x y z B, x y z H, x y z ph, x y z R, x y z S) {
	hyp 1 : wff = |- ( ph → H Isom R , S ( A , B ) ) ;;
	hyp 2 : wff = |- ( ph → ( H " x ) ∈ _V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( R Se A → S Se B ) ) ;;
}

proof of isoselem {
	var y : set, z : set;;
	step 1 : wff = dfse2 () |- ( R Se A ↔ ∀ z ∈ A ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V ) ;;
	step 2 : wff = biimpi (step 1) |- ( R Se A → ∀ z ∈ A ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V ) ;;
	step 3 : wff = r19.21bi (step 2) |- ( ( R Se A ∧ z ∈ A ) → ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V ) ;;
	step 4 : wff = expcom (step 3) |- ( z ∈ A → ( R Se A → ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ph ∧ z ∈ A ) → ( R Se A → ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V ) ) ;;
	step 6 : wff = imaeq2 () |- ( x = ( A ∩ ( ⁻¹ R " { z } ) ) → ( H " x ) = ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ) ;;
	step 7 : wff = eleq1d (step 6) |- ( x = ( A ∩ ( ⁻¹ R " { z } ) ) → ( ( H " x ) ∈ _V ↔ ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ∈ _V ) ) ;;
	step 8 : wff = imbi2d (step 7) |- ( x = ( A ∩ ( ⁻¹ R " { z } ) ) → ( ( ph → ( H " x ) ∈ _V ) ↔ ( ph → ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ∈ _V ) ) ) ;;
	step 9 : wff = vtoclg (step 8, hyp 2) |- ( ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V → ( ph → ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ∈ _V ) ) ;;
	step 10 : wff = com12 (step 9) |- ( ph → ( ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V → ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ∈ _V ) ) ;;
	step 11 : wff = adantr (step 10) |- ( ( ph ∧ z ∈ A ) → ( ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V → ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ∈ _V ) ) ;;
	step 12 : wff = isoini () |- ( ( H Isom R , S ( A , B ) ∧ z ∈ A ) → ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) = ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ) ;;
	step 13 : wff = sylan (hyp 1, step 12) |- ( ( ph ∧ z ∈ A ) → ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) = ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ) ;;
	step 14 : wff = eleq1d (step 13) |- ( ( ph ∧ z ∈ A ) → ( ( H " ( A ∩ ( ⁻¹ R " { z } ) ) ) ∈ _V ↔ ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 15 : wff = sylibd (step 11, step 14) |- ( ( ph ∧ z ∈ A ) → ( ( A ∩ ( ⁻¹ R " { z } ) ) ∈ _V → ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 16 : wff = syld (step 5, step 15) |- ( ( ph ∧ z ∈ A ) → ( R Se A → ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 17 : wff = ralrimdva (step 16) |- ( ph → ( R Se A → ∀ z ∈ A ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 18 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 19 : wff = syl (hyp 1, step 18) |- ( ph → H : A ⤖ B ) ;;
	step 20 : wff = f1ofn () |- ( H : A ⤖ B → H Fn A ) ;;
	step 21 : wff = sneq () |- ( y = ( H ` z ) → { y } = { ( H ` z ) } ) ;;
	step 22 : wff = imaeq2d (step 21) |- ( y = ( H ` z ) → ( ⁻¹ S " { y } ) = ( ⁻¹ S " { ( H ` z ) } ) ) ;;
	step 23 : wff = ineq2d (step 22) |- ( y = ( H ` z ) → ( B ∩ ( ⁻¹ S " { y } ) ) = ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ) ;;
	step 24 : wff = eleq1d (step 23) |- ( y = ( H ` z ) → ( ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ↔ ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 25 : wff = ralrn (step 24) |- ( H Fn A → ( ∀ y ∈ ran H ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ↔ ∀ z ∈ A ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 26 : wff = 3syl (step 19, step 20, step 25) |- ( ph → ( ∀ y ∈ ran H ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ↔ ∀ z ∈ A ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ) ) ;;
	step 27 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 28 : wff = syl (hyp 1, step 27) |- ( ph → H : A ⤖ B ) ;;
	step 29 : wff = f1ofo () |- ( H : A ⤖ B → H : A ↠ B ) ;;
	step 30 : wff = forn () |- ( H : A ↠ B → ran H = B ) ;;
	step 31 : wff = 3syl (step 28, step 29, step 30) |- ( ph → ran H = B ) ;;
	step 32 : wff = raleqdv (step 31) |- ( ph → ( ∀ y ∈ ran H ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ↔ ∀ y ∈ B ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ) ) ;;
	step 33 : wff = bitr3d (step 26, step 32) |- ( ph → ( ∀ z ∈ A ( B ∩ ( ⁻¹ S " { ( H ` z ) } ) ) ∈ _V ↔ ∀ y ∈ B ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ) ) ;;
	step 34 : wff = sylibd (step 17, step 33) |- ( ph → ( R Se A → ∀ y ∈ B ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ) ) ;;
	step 35 : wff = dfse2 () |- ( S Se B ↔ ∀ y ∈ B ( B ∩ ( ⁻¹ S " { y } ) ) ∈ _V ) ;;
	step 36 : wff = syl6ibr (step 34, step 35) |- ( ph → ( R Se A → S Se B ) ) ;;
	qed prop 1 = step 36 ;;
}

/*An isomorphism preserves well-foundedness.  Proposition 6.32(1) of
       [TakeutiZaring] p. 33.  (Contributed by NM, 30-Apr-2004.)  (Revised by
       Mario Carneiro, 18-Nov-2014.) */

theorem isofr (A : class, B : class, R : class, S : class, H : class) disjointed(x A, x B, x H, x R, x S, x) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( R Fr A ↔ S Fr B ) ) ;;
}

proof of isofr {
	var x : set;;
	step 1 : wff = isocnv () |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 2 : wff = id () |- ( ⁻¹ H Isom S , R ( B , A ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 3 : wff = isof1o () |- ( ⁻¹ H Isom S , R ( B , A ) → ⁻¹ H : B ⤖ A ) ;;
	step 4 : wff = f1ofun () |- ( ⁻¹ H : B ⤖ A → Fun ⁻¹ H ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = funimaex (step 5) |- ( Fun ⁻¹ H → ( ⁻¹ H " x ) ∈ _V ) ;;
	step 7 : wff = 3syl (step 3, step 4, step 6) |- ( ⁻¹ H Isom S , R ( B , A ) → ( ⁻¹ H " x ) ∈ _V ) ;;
	step 8 : wff = isofrlem (step 2, step 7) |- ( ⁻¹ H Isom S , R ( B , A ) → ( R Fr A → S Fr B ) ) ;;
	step 9 : wff = syl (step 1, step 8) |- ( H Isom R , S ( A , B ) → ( R Fr A → S Fr B ) ) ;;
	step 10 : wff = id () |- ( H Isom R , S ( A , B ) → H Isom R , S ( A , B ) ) ;;
	step 11 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 12 : wff = f1ofun () |- ( H : A ⤖ B → Fun H ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = funimaex (step 13) |- ( Fun H → ( H " x ) ∈ _V ) ;;
	step 15 : wff = 3syl (step 11, step 12, step 14) |- ( H Isom R , S ( A , B ) → ( H " x ) ∈ _V ) ;;
	step 16 : wff = isofrlem (step 10, step 15) |- ( H Isom R , S ( A , B ) → ( S Fr B → R Fr A ) ) ;;
	step 17 : wff = impbid (step 9, step 16) |- ( H Isom R , S ( A , B ) → ( R Fr A ↔ S Fr B ) ) ;;
	qed prop 1 = step 17 ;;
}

/*An isomorphism preserves set-like relations.  (Contributed by Mario
       Carneiro, 23-Jun-2015.) */

theorem isose (A : class, B : class, R : class, S : class, H : class) disjointed(x A, x B, x H, x R, x S, x) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( R Se A ↔ S Se B ) ) ;;
}

proof of isose {
	var x : set;;
	step 1 : wff = id () |- ( H Isom R , S ( A , B ) → H Isom R , S ( A , B ) ) ;;
	step 2 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 3 : wff = f1ofun () |- ( H : A ⤖ B → Fun H ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = funimaex (step 4) |- ( Fun H → ( H " x ) ∈ _V ) ;;
	step 6 : wff = 3syl (step 2, step 3, step 5) |- ( H Isom R , S ( A , B ) → ( H " x ) ∈ _V ) ;;
	step 7 : wff = isoselem (step 1, step 6) |- ( H Isom R , S ( A , B ) → ( R Se A → S Se B ) ) ;;
	step 8 : wff = isocnv () |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 9 : wff = isocnv () |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 10 : wff = isof1o () |- ( ⁻¹ H Isom S , R ( B , A ) → ⁻¹ H : B ⤖ A ) ;;
	step 11 : wff = f1ofun () |- ( ⁻¹ H : B ⤖ A → Fun ⁻¹ H ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = funimaex (step 12) |- ( Fun ⁻¹ H → ( ⁻¹ H " x ) ∈ _V ) ;;
	step 14 : wff = 3syl (step 10, step 11, step 13) |- ( ⁻¹ H Isom S , R ( B , A ) → ( ⁻¹ H " x ) ∈ _V ) ;;
	step 15 : wff = syl (step 9, step 14) |- ( H Isom R , S ( A , B ) → ( ⁻¹ H " x ) ∈ _V ) ;;
	step 16 : wff = isoselem (step 8, step 15) |- ( H Isom R , S ( A , B ) → ( S Se B → R Se A ) ) ;;
	step 17 : wff = impbid (step 7, step 16) |- ( H Isom R , S ( A , B ) → ( R Se A ↔ S Se B ) ) ;;
	qed prop 1 = step 17 ;;
}

/*A weak form of ~ isofr that does not need Replacement.  (Contributed by
       Mario Carneiro, 18-Nov-2014.) */

theorem isofr2 (A : class, B : class, R : class, S : class, H : class, V : class) disjointed(x A, x B, x H, x R, x S, x V) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ B ∈ V ) → ( S Fr B → R Fr A ) ) ;;
}

proof of isofr2 {
	var x : set;;
	step 1 : wff = simpl () |- ( ( H Isom R , S ( A , B ) ∧ B ∈ V ) → H Isom R , S ( A , B ) ) ;;
	step 2 : wff = imassrn () |- ( H " x ) ⊆ ran H ;;
	step 3 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 4 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 5 : wff = frn () |- ( H : A ⟶ B → ran H ⊆ B ) ;;
	step 6 : wff = 3syl (step 3, step 4, step 5) |- ( H Isom R , S ( A , B ) → ran H ⊆ B ) ;;
	step 7 : wff = syl5ss (step 2, step 6) |- ( H Isom R , S ( A , B ) → ( H " x ) ⊆ B ) ;;
	step 8 : wff = ssexg () |- ( ( ( H " x ) ⊆ B ∧ B ∈ V ) → ( H " x ) ∈ _V ) ;;
	step 9 : wff = sylan (step 7, step 8) |- ( ( H Isom R , S ( A , B ) ∧ B ∈ V ) → ( H " x ) ∈ _V ) ;;
	step 10 : wff = isofrlem (step 1, step 9) |- ( ( H Isom R , S ( A , B ) ∧ B ∈ V ) → ( S Fr B → R Fr A ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Lemma for ~ isopo .  (Contributed by Stefan O'Rear, 16-Nov-2014.) */

theorem isopolem (A : class, B : class, R : class, S : class, H : class) disjointed(H a b c d e f, R a b c d e f, S a b c d e f, A a b c d e f, B a b c d e f) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( S Po B → R Po A ) ) ;;
}

proof of isopolem {
	var e : set, f : set, a : set, b : set, c : set, d : set;;
	step 1 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 2 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 3 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ d ∈ A ) → ( H ` d ) ∈ B ) ;;
	step 4 : wff = ex (step 3) |- ( H : A ⟶ B → ( d ∈ A → ( H ` d ) ∈ B ) ) ;;
	step 5 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ e ∈ A ) → ( H ` e ) ∈ B ) ;;
	step 6 : wff = ex (step 5) |- ( H : A ⟶ B → ( e ∈ A → ( H ` e ) ∈ B ) ) ;;
	step 7 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ f ∈ A ) → ( H ` f ) ∈ B ) ;;
	step 8 : wff = ex (step 7) |- ( H : A ⟶ B → ( f ∈ A → ( H ` f ) ∈ B ) ) ;;
	step 9 : wff = 3anim123d (step 4, step 6, step 8) |- ( H : A ⟶ B → ( ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) → ( ( H ` d ) ∈ B ∧ ( H ` e ) ∈ B ∧ ( H ` f ) ∈ B ) ) ) ;;
	step 10 : wff = 3syl (step 1, step 2, step 9) |- ( H Isom R , S ( A , B ) → ( ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) → ( ( H ` d ) ∈ B ∧ ( H ` e ) ∈ B ∧ ( H ` f ) ∈ B ) ) ) ;;
	step 11 : wff = imp (step 10) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ( H ` d ) ∈ B ∧ ( H ` e ) ∈ B ∧ ( H ` f ) ∈ B ) ) ;;
	step 12 : wff = breq12 () |- ( ( a = ( H ` d ) ∧ a = ( H ` d ) ) → ( a S a ↔ ( H ` d ) S ( H ` d ) ) ) ;;
	step 13 : wff = anidms (step 12) |- ( a = ( H ` d ) → ( a S a ↔ ( H ` d ) S ( H ` d ) ) ) ;;
	step 14 : wff = notbid (step 13) |- ( a = ( H ` d ) → ( ¬ a S a ↔ ¬ ( H ` d ) S ( H ` d ) ) ) ;;
	step 15 : wff = breq1 () |- ( a = ( H ` d ) → ( a S b ↔ ( H ` d ) S b ) ) ;;
	step 16 : wff = anbi1d (step 15) |- ( a = ( H ` d ) → ( ( a S b ∧ b S c ) ↔ ( ( H ` d ) S b ∧ b S c ) ) ) ;;
	step 17 : wff = breq1 () |- ( a = ( H ` d ) → ( a S c ↔ ( H ` d ) S c ) ) ;;
	step 18 : wff = imbi12d (step 16, step 17) |- ( a = ( H ` d ) → ( ( ( a S b ∧ b S c ) → a S c ) ↔ ( ( ( H ` d ) S b ∧ b S c ) → ( H ` d ) S c ) ) ) ;;
	step 19 : wff = anbi12d (step 14, step 18) |- ( a = ( H ` d ) → ( ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) ↔ ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S b ∧ b S c ) → ( H ` d ) S c ) ) ) ) ;;
	step 20 : wff = breq2 () |- ( b = ( H ` e ) → ( ( H ` d ) S b ↔ ( H ` d ) S ( H ` e ) ) ) ;;
	step 21 : wff = breq1 () |- ( b = ( H ` e ) → ( b S c ↔ ( H ` e ) S c ) ) ;;
	step 22 : wff = anbi12d (step 20, step 21) |- ( b = ( H ` e ) → ( ( ( H ` d ) S b ∧ b S c ) ↔ ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S c ) ) ) ;;
	step 23 : wff = imbi1d (step 22) |- ( b = ( H ` e ) → ( ( ( ( H ` d ) S b ∧ b S c ) → ( H ` d ) S c ) ↔ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S c ) → ( H ` d ) S c ) ) ) ;;
	step 24 : wff = anbi2d (step 23) |- ( b = ( H ` e ) → ( ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S b ∧ b S c ) → ( H ` d ) S c ) ) ↔ ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S c ) → ( H ` d ) S c ) ) ) ) ;;
	step 25 : wff = breq2 () |- ( c = ( H ` f ) → ( ( H ` e ) S c ↔ ( H ` e ) S ( H ` f ) ) ) ;;
	step 26 : wff = anbi2d (step 25) |- ( c = ( H ` f ) → ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S c ) ↔ ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) ) ) ;;
	step 27 : wff = breq2 () |- ( c = ( H ` f ) → ( ( H ` d ) S c ↔ ( H ` d ) S ( H ` f ) ) ) ;;
	step 28 : wff = imbi12d (step 26, step 27) |- ( c = ( H ` f ) → ( ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S c ) → ( H ` d ) S c ) ↔ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) → ( H ` d ) S ( H ` f ) ) ) ) ;;
	step 29 : wff = anbi2d (step 28) |- ( c = ( H ` f ) → ( ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S c ) → ( H ` d ) S c ) ) ↔ ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) → ( H ` d ) S ( H ` f ) ) ) ) ) ;;
	step 30 : wff = rspc3v (step 19, step 24, step 29) |- ( ( ( H ` d ) ∈ B ∧ ( H ` e ) ∈ B ∧ ( H ` f ) ∈ B ) → ( ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) → ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) → ( H ` d ) S ( H ` f ) ) ) ) ) ;;
	step 31 : wff = syl (step 11, step 30) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) → ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) → ( H ` d ) S ( H ` f ) ) ) ) ) ;;
	step 32 : wff = simpl () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → H Isom R , S ( A , B ) ) ;;
	step 33 : wff = simpr1 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → d ∈ A ) ;;
	step 34 : wff = simpr1 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → d ∈ A ) ;;
	step 35 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ d ∈ A ) ) → ( d R d ↔ ( H ` d ) S ( H ` d ) ) ) ;;
	step 36 : wff = syl12anc (step 32, step 33, step 34, step 35) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( d R d ↔ ( H ` d ) S ( H ` d ) ) ) ;;
	step 37 : wff = notbid (step 36) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ¬ d R d ↔ ¬ ( H ` d ) S ( H ` d ) ) ) ;;
	step 38 : wff = simpl () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → H Isom R , S ( A , B ) ) ;;
	step 39 : wff = simpr1 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → d ∈ A ) ;;
	step 40 : wff = simpr2 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → e ∈ A ) ;;
	step 41 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ) ) → ( d R e ↔ ( H ` d ) S ( H ` e ) ) ) ;;
	step 42 : wff = syl12anc (step 38, step 39, step 40, step 41) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( d R e ↔ ( H ` d ) S ( H ` e ) ) ) ;;
	step 43 : wff = simpl () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → H Isom R , S ( A , B ) ) ;;
	step 44 : wff = simpr2 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → e ∈ A ) ;;
	step 45 : wff = simpr3 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → f ∈ A ) ;;
	step 46 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( e ∈ A ∧ f ∈ A ) ) → ( e R f ↔ ( H ` e ) S ( H ` f ) ) ) ;;
	step 47 : wff = syl12anc (step 43, step 44, step 45, step 46) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( e R f ↔ ( H ` e ) S ( H ` f ) ) ) ;;
	step 48 : wff = anbi12d (step 42, step 47) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ( d R e ∧ e R f ) ↔ ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) ) ) ;;
	step 49 : wff = simpl () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → H Isom R , S ( A , B ) ) ;;
	step 50 : wff = simpr1 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → d ∈ A ) ;;
	step 51 : wff = simpr3 () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → f ∈ A ) ;;
	step 52 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ f ∈ A ) ) → ( d R f ↔ ( H ` d ) S ( H ` f ) ) ) ;;
	step 53 : wff = syl12anc (step 49, step 50, step 51, step 52) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( d R f ↔ ( H ` d ) S ( H ` f ) ) ) ;;
	step 54 : wff = imbi12d (step 48, step 53) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ( ( d R e ∧ e R f ) → d R f ) ↔ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) → ( H ` d ) S ( H ` f ) ) ) ) ;;
	step 55 : wff = anbi12d (step 37, step 54) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ↔ ( ¬ ( H ` d ) S ( H ` d ) ∧ ( ( ( H ` d ) S ( H ` e ) ∧ ( H ` e ) S ( H ` f ) ) → ( H ` d ) S ( H ` f ) ) ) ) ) ;;
	step 56 : wff = sylibrd (step 31, step 55) |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) → ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ) ;;
	step 57 : wff = ex (step 56) |- ( H Isom R , S ( A , B ) → ( ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) → ( ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) → ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ) ) ;;
	step 58 : wff = com23 (step 57) |- ( H Isom R , S ( A , B ) → ( ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) → ( ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) → ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ) ) ;;
	step 59 : wff = imp31 (step 58) |- ( ( ( H Isom R , S ( A , B ) ∧ ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) ) ∧ ( d ∈ A ∧ e ∈ A ∧ f ∈ A ) ) → ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ;;
	step 60 : wff = ralrimivvva (step 59) |- ( ( H Isom R , S ( A , B ) ∧ ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) ) → ∀ d ∈ A ∀ e ∈ A ∀ f ∈ A ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ;;
	step 61 : wff = ex (step 60) |- ( H Isom R , S ( A , B ) → ( ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) → ∀ d ∈ A ∀ e ∈ A ∀ f ∈ A ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ) ;;
	step 62 : wff = df-po () |- ( S Po B ↔ ∀ a ∈ B ∀ b ∈ B ∀ c ∈ B ( ¬ a S a ∧ ( ( a S b ∧ b S c ) → a S c ) ) ) ;;
	step 63 : wff = df-po () |- ( R Po A ↔ ∀ d ∈ A ∀ e ∈ A ∀ f ∈ A ( ¬ d R d ∧ ( ( d R e ∧ e R f ) → d R f ) ) ) ;;
	step 64 : wff = 3imtr4g (step 61, step 62, step 63) |- ( H Isom R , S ( A , B ) → ( S Po B → R Po A ) ) ;;
	qed prop 1 = step 64 ;;
}

/*An isomorphism preserves partial ordering.  (Contributed by Stefan
       O'Rear, 16-Nov-2014.) */

theorem isopo (A : class, B : class, R : class, S : class, H : class) disjointed(H, R, S, A, B) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( R Po A ↔ S Po B ) ) ;;
}

proof of isopo {
	step 1 : wff = isocnv () |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 2 : wff = isopolem () |- ( ⁻¹ H Isom S , R ( B , A ) → ( R Po A → S Po B ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( H Isom R , S ( A , B ) → ( R Po A → S Po B ) ) ;;
	step 4 : wff = isopolem () |- ( H Isom R , S ( A , B ) → ( S Po B → R Po A ) ) ;;
	step 5 : wff = impbid (step 3, step 4) |- ( H Isom R , S ( A , B ) → ( R Po A ↔ S Po B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Lemma for ~ isoso .  (Contributed by Stefan O'Rear, 16-Nov-2014.) */

theorem isosolem (A : class, B : class, R : class, S : class, H : class) disjointed(H a b c d, R a b c d, S a b c d, A a b c d, B a b c d) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( S Or B → R Or A ) ) ;;
}

proof of isosolem {
	var a : set, b : set, c : set, d : set;;
	step 1 : wff = isopolem () |- ( H Isom R , S ( A , B ) → ( S Po B → R Po A ) ) ;;
	step 2 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 3 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 4 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ c ∈ A ) → ( H ` c ) ∈ B ) ;;
	step 5 : wff = ex (step 4) |- ( H : A ⟶ B → ( c ∈ A → ( H ` c ) ∈ B ) ) ;;
	step 6 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ d ∈ A ) → ( H ` d ) ∈ B ) ;;
	step 7 : wff = ex (step 6) |- ( H : A ⟶ B → ( d ∈ A → ( H ` d ) ∈ B ) ) ;;
	step 8 : wff = anim12d (step 5, step 7) |- ( H : A ⟶ B → ( ( c ∈ A ∧ d ∈ A ) → ( ( H ` c ) ∈ B ∧ ( H ` d ) ∈ B ) ) ) ;;
	step 9 : wff = 3syl (step 2, step 3, step 8) |- ( H Isom R , S ( A , B ) → ( ( c ∈ A ∧ d ∈ A ) → ( ( H ` c ) ∈ B ∧ ( H ` d ) ∈ B ) ) ) ;;
	step 10 : wff = imp (step 9) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( ( H ` c ) ∈ B ∧ ( H ` d ) ∈ B ) ) ;;
	step 11 : wff = breq1 () |- ( a = ( H ` c ) → ( a S b ↔ ( H ` c ) S b ) ) ;;
	step 12 : wff = eqeq1 () |- ( a = ( H ` c ) → ( a = b ↔ ( H ` c ) = b ) ) ;;
	step 13 : wff = breq2 () |- ( a = ( H ` c ) → ( b S a ↔ b S ( H ` c ) ) ) ;;
	step 14 : wff = 3orbi123d (step 11, step 12, step 13) |- ( a = ( H ` c ) → ( ( a S b ∨ a = b ∨ b S a ) ↔ ( ( H ` c ) S b ∨ ( H ` c ) = b ∨ b S ( H ` c ) ) ) ) ;;
	step 15 : wff = breq2 () |- ( b = ( H ` d ) → ( ( H ` c ) S b ↔ ( H ` c ) S ( H ` d ) ) ) ;;
	step 16 : wff = eqeq2 () |- ( b = ( H ` d ) → ( ( H ` c ) = b ↔ ( H ` c ) = ( H ` d ) ) ) ;;
	step 17 : wff = breq1 () |- ( b = ( H ` d ) → ( b S ( H ` c ) ↔ ( H ` d ) S ( H ` c ) ) ) ;;
	step 18 : wff = 3orbi123d (step 15, step 16, step 17) |- ( b = ( H ` d ) → ( ( ( H ` c ) S b ∨ ( H ` c ) = b ∨ b S ( H ` c ) ) ↔ ( ( H ` c ) S ( H ` d ) ∨ ( H ` c ) = ( H ` d ) ∨ ( H ` d ) S ( H ` c ) ) ) ) ;;
	step 19 : wff = rspc2v (step 14, step 18) |- ( ( ( H ` c ) ∈ B ∧ ( H ` d ) ∈ B ) → ( ∀ a ∈ B ∀ b ∈ B ( a S b ∨ a = b ∨ b S a ) → ( ( H ` c ) S ( H ` d ) ∨ ( H ` c ) = ( H ` d ) ∨ ( H ` d ) S ( H ` c ) ) ) ) ;;
	step 20 : wff = syl (step 10, step 19) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( ∀ a ∈ B ∀ b ∈ B ( a S b ∨ a = b ∨ b S a ) → ( ( H ` c ) S ( H ` d ) ∨ ( H ` c ) = ( H ` d ) ∨ ( H ` d ) S ( H ` c ) ) ) ) ;;
	step 21 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( c R d ↔ ( H ` c ) S ( H ` d ) ) ) ;;
	step 22 : wff = isof1o () |- ( H Isom R , S ( A , B ) → H : A ⤖ B ) ;;
	step 23 : wff = f1of1 () |- ( H : A ⤖ B → H : A ↣ B ) ;;
	step 24 : wff = syl (step 22, step 23) |- ( H Isom R , S ( A , B ) → H : A ↣ B ) ;;
	step 25 : wff = f1fveq () |- ( ( H : A ↣ B ∧ ( c ∈ A ∧ d ∈ A ) ) → ( ( H ` c ) = ( H ` d ) ↔ c = d ) ) ;;
	step 26 : wff = sylan (step 24, step 25) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( ( H ` c ) = ( H ` d ) ↔ c = d ) ) ;;
	step 27 : wff = bicomd (step 26) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( c = d ↔ ( H ` c ) = ( H ` d ) ) ) ;;
	step 28 : wff = isorel () |- ( ( H Isom R , S ( A , B ) ∧ ( d ∈ A ∧ c ∈ A ) ) → ( d R c ↔ ( H ` d ) S ( H ` c ) ) ) ;;
	step 29 : wff = ancom2s (step 28) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( d R c ↔ ( H ` d ) S ( H ` c ) ) ) ;;
	step 30 : wff = 3orbi123d (step 21, step 27, step 29) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( ( c R d ∨ c = d ∨ d R c ) ↔ ( ( H ` c ) S ( H ` d ) ∨ ( H ` c ) = ( H ` d ) ∨ ( H ` d ) S ( H ` c ) ) ) ) ;;
	step 31 : wff = sylibrd (step 20, step 30) |- ( ( H Isom R , S ( A , B ) ∧ ( c ∈ A ∧ d ∈ A ) ) → ( ∀ a ∈ B ∀ b ∈ B ( a S b ∨ a = b ∨ b S a ) → ( c R d ∨ c = d ∨ d R c ) ) ) ;;
	step 32 : wff = ralrimdvva (step 31) |- ( H Isom R , S ( A , B ) → ( ∀ a ∈ B ∀ b ∈ B ( a S b ∨ a = b ∨ b S a ) → ∀ c ∈ A ∀ d ∈ A ( c R d ∨ c = d ∨ d R c ) ) ) ;;
	step 33 : wff = anim12d (step 1, step 32) |- ( H Isom R , S ( A , B ) → ( ( S Po B ∧ ∀ a ∈ B ∀ b ∈ B ( a S b ∨ a = b ∨ b S a ) ) → ( R Po A ∧ ∀ c ∈ A ∀ d ∈ A ( c R d ∨ c = d ∨ d R c ) ) ) ) ;;
	step 34 : wff = df-so () |- ( S Or B ↔ ( S Po B ∧ ∀ a ∈ B ∀ b ∈ B ( a S b ∨ a = b ∨ b S a ) ) ) ;;
	step 35 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ c ∈ A ∀ d ∈ A ( c R d ∨ c = d ∨ d R c ) ) ) ;;
	step 36 : wff = 3imtr4g (step 33, step 34, step 35) |- ( H Isom R , S ( A , B ) → ( S Or B → R Or A ) ) ;;
	qed prop 1 = step 36 ;;
}

/*An isomorphism preserves strict ordering.  (Contributed by Stefan
       O'Rear, 16-Nov-2014.) */

theorem isoso (A : class, B : class, R : class, S : class, H : class) disjointed(H, R, S, A, B) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( R Or A ↔ S Or B ) ) ;;
}

proof of isoso {
	step 1 : wff = isocnv () |- ( H Isom R , S ( A , B ) → ⁻¹ H Isom S , R ( B , A ) ) ;;
	step 2 : wff = isosolem () |- ( ⁻¹ H Isom S , R ( B , A ) → ( R Or A → S Or B ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( H Isom R , S ( A , B ) → ( R Or A → S Or B ) ) ;;
	step 4 : wff = isosolem () |- ( H Isom R , S ( A , B ) → ( S Or B → R Or A ) ) ;;
	step 5 : wff = impbid (step 3, step 4) |- ( H Isom R , S ( A , B ) → ( R Or A ↔ S Or B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*An isomorphism preserves well-ordering.  Proposition 6.32(3) of
       [TakeutiZaring] p. 33.  (Contributed by NM, 30-Apr-2004.)  (Revised by
       Mario Carneiro, 18-Nov-2014.) */

theorem isowe (A : class, B : class, R : class, S : class, H : class) disjointed(A, B, R, S, H) {
	prop 1 : wff = |- ( H Isom R , S ( A , B ) → ( R We A ↔ S We B ) ) ;;
}

proof of isowe {
	step 1 : wff = isofr () |- ( H Isom R , S ( A , B ) → ( R Fr A ↔ S Fr B ) ) ;;
	step 2 : wff = isoso () |- ( H Isom R , S ( A , B ) → ( R Or A ↔ S Or B ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( H Isom R , S ( A , B ) → ( ( R Fr A ∧ R Or A ) ↔ ( S Fr B ∧ S Or B ) ) ) ;;
	step 4 : wff = df-we () |- ( R We A ↔ ( R Fr A ∧ R Or A ) ) ;;
	step 5 : wff = df-we () |- ( S We B ↔ ( S Fr B ∧ S Or B ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( H Isom R , S ( A , B ) → ( R We A ↔ S We B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*A weak form of ~ isowe that does not need Replacement.  (Contributed by
       Mario Carneiro, 18-Nov-2014.) */

theorem isowe2 (x : set, A : class, B : class, R : class, S : class, H : class) disjointed(x y A, x y B, x y R, x y S, x y H) {
	prop 1 : wff = |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → ( S We B → R We A ) ) ;;
}

proof of isowe2 {
	var y : set;;
	step 1 : wff = simpl () |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → H Isom R , S ( A , B ) ) ;;
	step 2 : wff = imaeq2 () |- ( x = y → ( H " x ) = ( H " y ) ) ;;
	step 3 : wff = eleq1d (step 2) |- ( x = y → ( ( H " x ) ∈ _V ↔ ( H " y ) ∈ _V ) ) ;;
	step 4 : wff = spv (step 3) |- ( ∀ x ( H " x ) ∈ _V → ( H " y ) ∈ _V ) ;;
	step 5 : wff = adantl (step 4) |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → ( H " y ) ∈ _V ) ;;
	step 6 : wff = isofrlem (step 1, step 5) |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → ( S Fr B → R Fr A ) ) ;;
	step 7 : wff = isosolem () |- ( H Isom R , S ( A , B ) → ( S Or B → R Or A ) ) ;;
	step 8 : wff = adantr (step 7) |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → ( S Or B → R Or A ) ) ;;
	step 9 : wff = anim12d (step 6, step 8) |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → ( ( S Fr B ∧ S Or B ) → ( R Fr A ∧ R Or A ) ) ) ;;
	step 10 : wff = df-we () |- ( S We B ↔ ( S Fr B ∧ S Or B ) ) ;;
	step 11 : wff = df-we () |- ( R We A ↔ ( R Fr A ∧ R Or A ) ) ;;
	step 12 : wff = 3imtr4g (step 9, step 10, step 11) |- ( ( H Isom R , S ( A , B ) ∧ ∀ x ( H " x ) ∈ _V ) → ( S We B → R We A ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Any one-to-one onto function determines an isomorphism with an induced
       relation ` S ` .  Proposition 6.33 of [TakeutiZaring] p. 34.
       (Contributed by NM, 30-Apr-2004.) */

theorem f1oiso (x : set, y : set, z : set, w : set, A : class, B : class, R : class, S : class, H : class) disjointed(x y z w v u A, x y v u B, x y z w v u H, x y z w v u R, v u S) {
	prop 1 : wff = |- ( ( H : A ⤖ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) → H Isom R , S ( A , B ) ) ;;
}

proof of f1oiso {
	var v : set, u : set;;
	step 1 : wff = simpl () |- ( ( H : A ⤖ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) → H : A ⤖ B ) ;;
	step 2 : wff = f1of1 () |- ( H : A ⤖ B → H : A ↣ B ) ;;
	step 3 : wff = df-br () |- ( ( H ` v ) S ( H ` u ) ↔ 〈 ( H ` v ) , ( H ` u ) 〉 ∈ S ) ;;
	step 4 : wff = eleq2 () |- ( S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } → ( 〈 ( H ` v ) , ( H ` u ) 〉 ∈ S ↔ 〈 ( H ` v ) , ( H ` u ) 〉 ∈ { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) ) ;;
	step 5 : wff = fvex () |- ( H ` v ) ∈ _V ;;
	step 6 : wff = fvex () |- ( H ` u ) ∈ _V ;;
	step 7 : wff = eqeq1 () |- ( z = ( H ` v ) → ( z = ( H ` x ) ↔ ( H ` v ) = ( H ` x ) ) ) ;;
	step 8 : wff = anbi1d (step 7) |- ( z = ( H ` v ) → ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ↔ ( ( H ` v ) = ( H ` x ) ∧ w = ( H ` y ) ) ) ) ;;
	step 9 : wff = anbi1d (step 8) |- ( z = ( H ` v ) → ( ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) ↔ ( ( ( H ` v ) = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) ) ) ;;
	step 10 : wff = 2rexbidv (step 9) |- ( z = ( H ` v ) → ( ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) ↔ ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) ) ) ;;
	step 11 : wff = eqeq1 () |- ( w = ( H ` u ) → ( w = ( H ` y ) ↔ ( H ` u ) = ( H ` y ) ) ) ;;
	step 12 : wff = anbi2d (step 11) |- ( w = ( H ` u ) → ( ( ( H ` v ) = ( H ` x ) ∧ w = ( H ` y ) ) ↔ ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ) ) ;;
	step 13 : wff = anbi1d (step 12) |- ( w = ( H ` u ) → ( ( ( ( H ` v ) = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) ↔ ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ) ) ;;
	step 14 : wff = 2rexbidv (step 13) |- ( w = ( H ` u ) → ( ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) ↔ ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ) ) ;;
	step 15 : wff = opelopab (step 5, step 6, step 10, step 14) |- ( 〈 ( H ` v ) , ( H ` u ) 〉 ∈ { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ↔ ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ) ;;
	step 16 : wff = anass () |- ( ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ ( ( H ` v ) = ( H ` x ) ∧ ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ;;
	step 17 : wff = f1fveq () |- ( ( H : A ↣ B ∧ ( v ∈ A ∧ x ∈ A ) ) → ( ( H ` v ) = ( H ` x ) ↔ v = x ) ) ;;
	step 18 : wff = eqcom () |- ( v = x ↔ x = v ) ;;
	step 19 : wff = syl6bb (step 17, step 18) |- ( ( H : A ↣ B ∧ ( v ∈ A ∧ x ∈ A ) ) → ( ( H ` v ) = ( H ` x ) ↔ x = v ) ) ;;
	step 20 : wff = anassrs (step 19) |- ( ( ( H : A ↣ B ∧ v ∈ A ) ∧ x ∈ A ) → ( ( H ` v ) = ( H ` x ) ↔ x = v ) ) ;;
	step 21 : wff = anbi1d (step 20) |- ( ( ( H : A ↣ B ∧ v ∈ A ) ∧ x ∈ A ) → ( ( ( H ` v ) = ( H ` x ) ∧ ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ↔ ( x = v ∧ ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ) ;;
	step 22 : wff = syl5bb (step 16, step 21) |- ( ( ( H : A ↣ B ∧ v ∈ A ) ∧ x ∈ A ) → ( ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ ( x = v ∧ ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ) ;;
	step 23 : wff = rexbidv (step 22) |- ( ( ( H : A ↣ B ∧ v ∈ A ) ∧ x ∈ A ) → ( ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ ∃ y ∈ A ( x = v ∧ ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ) ;;
	step 24 : wff = r19.42v () |- ( ∃ y ∈ A ( x = v ∧ ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ↔ ( x = v ∧ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ;;
	step 25 : wff = syl6bb (step 23, step 24) |- ( ( ( H : A ↣ B ∧ v ∈ A ) ∧ x ∈ A ) → ( ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ ( x = v ∧ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ) ;;
	step 26 : wff = rexbidva (step 25) |- ( ( H : A ↣ B ∧ v ∈ A ) → ( ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ ∃ x ∈ A ( x = v ∧ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ) ) ;;
	step 27 : wff = breq1 () |- ( x = v → ( x R y ↔ v R y ) ) ;;
	step 28 : wff = anbi2d (step 27) |- ( x = v → ( ( ( H ` u ) = ( H ` y ) ∧ x R y ) ↔ ( ( H ` u ) = ( H ` y ) ∧ v R y ) ) ) ;;
	step 29 : wff = rexbidv (step 28) |- ( x = v → ( ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ x R y ) ↔ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ v R y ) ) ) ;;
	step 30 : wff = ceqsrexv (step 29) |- ( v ∈ A → ( ∃ x ∈ A ( x = v ∧ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ↔ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ v R y ) ) ) ;;
	step 31 : wff = adantl (step 30) |- ( ( H : A ↣ B ∧ v ∈ A ) → ( ∃ x ∈ A ( x = v ∧ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ x R y ) ) ↔ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ v R y ) ) ) ;;
	step 32 : wff = bitrd (step 26, step 31) |- ( ( H : A ↣ B ∧ v ∈ A ) → ( ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ v R y ) ) ) ;;
	step 33 : wff = f1fveq () |- ( ( H : A ↣ B ∧ ( u ∈ A ∧ y ∈ A ) ) → ( ( H ` u ) = ( H ` y ) ↔ u = y ) ) ;;
	step 34 : wff = eqcom () |- ( u = y ↔ y = u ) ;;
	step 35 : wff = syl6bb (step 33, step 34) |- ( ( H : A ↣ B ∧ ( u ∈ A ∧ y ∈ A ) ) → ( ( H ` u ) = ( H ` y ) ↔ y = u ) ) ;;
	step 36 : wff = anassrs (step 35) |- ( ( ( H : A ↣ B ∧ u ∈ A ) ∧ y ∈ A ) → ( ( H ` u ) = ( H ` y ) ↔ y = u ) ) ;;
	step 37 : wff = anbi1d (step 36) |- ( ( ( H : A ↣ B ∧ u ∈ A ) ∧ y ∈ A ) → ( ( ( H ` u ) = ( H ` y ) ∧ v R y ) ↔ ( y = u ∧ v R y ) ) ) ;;
	step 38 : wff = rexbidva (step 37) |- ( ( H : A ↣ B ∧ u ∈ A ) → ( ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ v R y ) ↔ ∃ y ∈ A ( y = u ∧ v R y ) ) ) ;;
	step 39 : wff = breq2 () |- ( y = u → ( v R y ↔ v R u ) ) ;;
	step 40 : wff = ceqsrexv (step 39) |- ( u ∈ A → ( ∃ y ∈ A ( y = u ∧ v R y ) ↔ v R u ) ) ;;
	step 41 : wff = adantl (step 40) |- ( ( H : A ↣ B ∧ u ∈ A ) → ( ∃ y ∈ A ( y = u ∧ v R y ) ↔ v R u ) ) ;;
	step 42 : wff = bitrd (step 38, step 41) |- ( ( H : A ↣ B ∧ u ∈ A ) → ( ∃ y ∈ A ( ( H ` u ) = ( H ` y ) ∧ v R y ) ↔ v R u ) ) ;;
	step 43 : wff = sylan9bb (step 32, step 42) |- ( ( ( H : A ↣ B ∧ v ∈ A ) ∧ ( H : A ↣ B ∧ u ∈ A ) ) → ( ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ v R u ) ) ;;
	step 44 : wff = anandis (step 43) |- ( ( H : A ↣ B ∧ ( v ∈ A ∧ u ∈ A ) ) → ( ∃ x ∈ A ∃ y ∈ A ( ( ( H ` v ) = ( H ` x ) ∧ ( H ` u ) = ( H ` y ) ) ∧ x R y ) ↔ v R u ) ) ;;
	step 45 : wff = syl5bb (step 15, step 44) |- ( ( H : A ↣ B ∧ ( v ∈ A ∧ u ∈ A ) ) → ( 〈 ( H ` v ) , ( H ` u ) 〉 ∈ { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ↔ v R u ) ) ;;
	step 46 : wff = sylan9bbr (step 4, step 45) |- ( ( ( H : A ↣ B ∧ ( v ∈ A ∧ u ∈ A ) ) ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) → ( 〈 ( H ` v ) , ( H ` u ) 〉 ∈ S ↔ v R u ) ) ;;
	step 47 : wff = an32s (step 46) |- ( ( ( H : A ↣ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) ∧ ( v ∈ A ∧ u ∈ A ) ) → ( 〈 ( H ` v ) , ( H ` u ) 〉 ∈ S ↔ v R u ) ) ;;
	step 48 : wff = syl5rbb (step 3, step 47) |- ( ( ( H : A ↣ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) ∧ ( v ∈ A ∧ u ∈ A ) ) → ( v R u ↔ ( H ` v ) S ( H ` u ) ) ) ;;
	step 49 : wff = ralrimivva (step 48) |- ( ( H : A ↣ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) → ∀ v ∈ A ∀ u ∈ A ( v R u ↔ ( H ` v ) S ( H ` u ) ) ) ;;
	step 50 : wff = sylan (step 2, step 49) |- ( ( H : A ⤖ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) → ∀ v ∈ A ∀ u ∈ A ( v R u ↔ ( H ` v ) S ( H ` u ) ) ) ;;
	step 51 : wff = df-isom () |- ( H Isom R , S ( A , B ) ↔ ( H : A ⤖ B ∧ ∀ v ∈ A ∀ u ∈ A ( v R u ↔ ( H ` v ) S ( H ` u ) ) ) ) ;;
	step 52 : wff = sylanbrc (step 1, step 50, step 51) |- ( ( H : A ⤖ B ∧ S = { 〈 z , w 〉 | ∃ x ∈ A ∃ y ∈ A ( ( z = ( H ` x ) ∧ w = ( H ` y ) ) ∧ x R y ) } ) → H Isom R , S ( A , B ) ) ;;
	qed prop 1 = step 52 ;;
}

/*Any one-to-one onto function determines an isomorphism with an induced
       relation ` S ` .  (Contributed by Mario Carneiro, 9-Mar-2013.) */

theorem f1oiso2 (x : set, y : set, A : class, B : class, R : class, S : class, H : class) disjointed(A w x y z, B w x y z, H w x y z, R w x y z) {
	hyp 1 : wff = |- S = { 〈 x , y 〉 | ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( H : A ⤖ B → H Isom R , S ( A , B ) ) ;;
}

proof of f1oiso2 {
	var z : set, w : set;;
	step 1 : wff = f1ocnvdm () |- ( ( H : A ⤖ B ∧ x ∈ B ) → ( ⁻¹ H ` x ) ∈ A ) ;;
	step 2 : wff = adantrr (step 1) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ) → ( ⁻¹ H ` x ) ∈ A ) ;;
	step 3 : wff = 3adant3 (step 2) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ( ⁻¹ H ` x ) ∈ A ) ;;
	step 4 : wff = f1ocnvdm () |- ( ( H : A ⤖ B ∧ y ∈ B ) → ( ⁻¹ H ` y ) ∈ A ) ;;
	step 5 : wff = adantrl (step 4) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ) → ( ⁻¹ H ` y ) ∈ A ) ;;
	step 6 : wff = 3adant3 (step 5) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ( ⁻¹ H ` y ) ∈ A ) ;;
	step 7 : wff = f1ocnvfv2 () |- ( ( H : A ⤖ B ∧ x ∈ B ) → ( H ` ( ⁻¹ H ` x ) ) = x ) ;;
	step 8 : wff = eqcomd (step 7) |- ( ( H : A ⤖ B ∧ x ∈ B ) → x = ( H ` ( ⁻¹ H ` x ) ) ) ;;
	step 9 : wff = f1ocnvfv2 () |- ( ( H : A ⤖ B ∧ y ∈ B ) → ( H ` ( ⁻¹ H ` y ) ) = y ) ;;
	step 10 : wff = eqcomd (step 9) |- ( ( H : A ⤖ B ∧ y ∈ B ) → y = ( H ` ( ⁻¹ H ` y ) ) ) ;;
	step 11 : wff = anim12dan (step 8, step 10) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ) → ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` ( ⁻¹ H ` y ) ) ) ) ;;
	step 12 : wff = 3adant3 (step 11) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` ( ⁻¹ H ` y ) ) ) ) ;;
	step 13 : wff = simp3 () |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ;;
	step 14 : wff = fveq2 () |- ( w = ( ⁻¹ H ` y ) → ( H ` w ) = ( H ` ( ⁻¹ H ` y ) ) ) ;;
	step 15 : wff = eqeq2d (step 14) |- ( w = ( ⁻¹ H ` y ) → ( y = ( H ` w ) ↔ y = ( H ` ( ⁻¹ H ` y ) ) ) ) ;;
	step 16 : wff = anbi2d (step 15) |- ( w = ( ⁻¹ H ` y ) → ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ↔ ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` ( ⁻¹ H ` y ) ) ) ) ) ;;
	step 17 : wff = breq2 () |- ( w = ( ⁻¹ H ` y ) → ( ( ⁻¹ H ` x ) R w ↔ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ) ;;
	step 18 : wff = anbi12d (step 16, step 17) |- ( w = ( ⁻¹ H ` y ) → ( ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ∧ ( ⁻¹ H ` x ) R w ) ↔ ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` ( ⁻¹ H ` y ) ) ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ) ) ;;
	step 19 : wff = rspcev (step 18) |- ( ( ( ⁻¹ H ` y ) ∈ A ∧ ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` ( ⁻¹ H ` y ) ) ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ) → ∃ w ∈ A ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ∧ ( ⁻¹ H ` x ) R w ) ) ;;
	step 20 : wff = syl12anc (step 6, step 12, step 13, step 19) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ∃ w ∈ A ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ∧ ( ⁻¹ H ` x ) R w ) ) ;;
	step 21 : wff = fveq2 () |- ( z = ( ⁻¹ H ` x ) → ( H ` z ) = ( H ` ( ⁻¹ H ` x ) ) ) ;;
	step 22 : wff = eqeq2d (step 21) |- ( z = ( ⁻¹ H ` x ) → ( x = ( H ` z ) ↔ x = ( H ` ( ⁻¹ H ` x ) ) ) ) ;;
	step 23 : wff = anbi1d (step 22) |- ( z = ( ⁻¹ H ` x ) → ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ↔ ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ) ) ;;
	step 24 : wff = breq1 () |- ( z = ( ⁻¹ H ` x ) → ( z R w ↔ ( ⁻¹ H ` x ) R w ) ) ;;
	step 25 : wff = anbi12d (step 23, step 24) |- ( z = ( ⁻¹ H ` x ) → ( ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ↔ ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ∧ ( ⁻¹ H ` x ) R w ) ) ) ;;
	step 26 : wff = rexbidv (step 25) |- ( z = ( ⁻¹ H ` x ) → ( ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ↔ ∃ w ∈ A ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ∧ ( ⁻¹ H ` x ) R w ) ) ) ;;
	step 27 : wff = rspcev (step 26) |- ( ( ( ⁻¹ H ` x ) ∈ A ∧ ∃ w ∈ A ( ( x = ( H ` ( ⁻¹ H ` x ) ) ∧ y = ( H ` w ) ) ∧ ( ⁻¹ H ` x ) R w ) ) → ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) ;;
	step 28 : wff = syl2anc (step 3, step 20, step 27) |- ( ( H : A ⤖ B ∧ ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) ;;
	step 29 : wff = 3expib (step 28) |- ( H : A ⤖ B → ( ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) → ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) ) ;;
	step 30 : wff = simp3ll () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → x = ( H ` z ) ) ;;
	step 31 : wff = simp1 () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → H : A ⤖ B ) ;;
	step 32 : wff = simp2l () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → z ∈ A ) ;;
	step 33 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 34 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ z ∈ A ) → ( H ` z ) ∈ B ) ;;
	step 35 : wff = sylan (step 33, step 34) |- ( ( H : A ⤖ B ∧ z ∈ A ) → ( H ` z ) ∈ B ) ;;
	step 36 : wff = syl2anc (step 31, step 32, step 35) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( H ` z ) ∈ B ) ;;
	step 37 : wff = eqeltrd (step 30, step 36) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → x ∈ B ) ;;
	step 38 : wff = simp3lr () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → y = ( H ` w ) ) ;;
	step 39 : wff = simp1 () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → H : A ⤖ B ) ;;
	step 40 : wff = simp2r () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → w ∈ A ) ;;
	step 41 : wff = f1of () |- ( H : A ⤖ B → H : A ⟶ B ) ;;
	step 42 : wff = ffvelrn () |- ( ( H : A ⟶ B ∧ w ∈ A ) → ( H ` w ) ∈ B ) ;;
	step 43 : wff = sylan (step 41, step 42) |- ( ( H : A ⤖ B ∧ w ∈ A ) → ( H ` w ) ∈ B ) ;;
	step 44 : wff = syl2anc (step 39, step 40, step 43) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( H ` w ) ∈ B ) ;;
	step 45 : wff = eqeltrd (step 38, step 44) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → y ∈ B ) ;;
	step 46 : wff = simp3r () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → z R w ) ;;
	step 47 : wff = simp3ll () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → x = ( H ` z ) ) ;;
	step 48 : wff = eqcomd (step 47) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( H ` z ) = x ) ;;
	step 49 : wff = simp1 () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → H : A ⤖ B ) ;;
	step 50 : wff = simp2l () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → z ∈ A ) ;;
	step 51 : wff = f1ocnvfv () |- ( ( H : A ⤖ B ∧ z ∈ A ) → ( ( H ` z ) = x → ( ⁻¹ H ` x ) = z ) ) ;;
	step 52 : wff = syl2anc (step 49, step 50, step 51) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( ( H ` z ) = x → ( ⁻¹ H ` x ) = z ) ) ;;
	step 53 : wff = mpd (step 48, step 52) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( ⁻¹ H ` x ) = z ) ;;
	step 54 : wff = simp3lr () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → y = ( H ` w ) ) ;;
	step 55 : wff = eqcomd (step 54) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( H ` w ) = y ) ;;
	step 56 : wff = simp1 () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → H : A ⤖ B ) ;;
	step 57 : wff = simp2r () |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → w ∈ A ) ;;
	step 58 : wff = f1ocnvfv () |- ( ( H : A ⤖ B ∧ w ∈ A ) → ( ( H ` w ) = y → ( ⁻¹ H ` y ) = w ) ) ;;
	step 59 : wff = syl2anc (step 56, step 57, step 58) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( ( H ` w ) = y → ( ⁻¹ H ` y ) = w ) ) ;;
	step 60 : wff = mpd (step 55, step 59) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( ⁻¹ H ` y ) = w ) ;;
	step 61 : wff = 3brtr4d (step 46, step 53, step 60) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ;;
	step 62 : wff = jca31 (step 37, step 45, step 61) |- ( ( H : A ⤖ B ∧ ( z ∈ A ∧ w ∈ A ) ∧ ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) → ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ) ;;
	step 63 : wff = 3exp (step 62) |- ( H : A ⤖ B → ( ( z ∈ A ∧ w ∈ A ) → ( ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) → ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ) ) ) ;;
	step 64 : wff = rexlimdvv (step 63) |- ( H : A ⤖ B → ( ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) → ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ) ) ;;
	step 65 : wff = impbid (step 29, step 64) |- ( H : A ⤖ B → ( ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) ↔ ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) ) ) ;;
	step 66 : wff = opabbidv (step 65) |- ( H : A ⤖ B → { 〈 x , y 〉 | ( ( x ∈ B ∧ y ∈ B ) ∧ ( ⁻¹ H ` x ) R ( ⁻¹ H ` y ) ) } = { 〈 x , y 〉 | ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) } ) ;;
	step 67 : wff = syl5eq (hyp 1, step 66) |- ( H : A ⤖ B → S = { 〈 x , y 〉 | ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) } ) ;;
	step 68 : wff = f1oiso () |- ( ( H : A ⤖ B ∧ S = { 〈 x , y 〉 | ∃ z ∈ A ∃ w ∈ A ( ( x = ( H ` z ) ∧ y = ( H ` w ) ) ∧ z R w ) } ) → H Isom R , S ( A , B ) ) ;;
	step 69 : wff = mpdan (step 67, step 68) |- ( H : A ⤖ B → H Isom R , S ( A , B ) ) ;;
	qed prop 1 = step 69 ;;
}

/*Well-ordering of isomorphic relations.  (Contributed by NM,
       4-Mar-1997.) */

theorem f1owe (x : set, y : set, A : class, B : class, R : class, S : class, F : class) disjointed(z w R, x y z w S, z w A, z w B, x y z w F) {
	hyp 1 : wff = |- R = { 〈 x , y 〉 | ( F ` x ) S ( F ` y ) } ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⤖ B → ( S We B → R We A ) ) ;;
}

proof of f1owe {
	var z : set, w : set;;
	step 1 : wff = fveq2 () |- ( x = z → ( F ` x ) = ( F ` z ) ) ;;
	step 2 : wff = breq1d (step 1) |- ( x = z → ( ( F ` x ) S ( F ` y ) ↔ ( F ` z ) S ( F ` y ) ) ) ;;
	step 3 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 4 : wff = breq2d (step 3) |- ( y = w → ( ( F ` z ) S ( F ` y ) ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 5 : wff = brabg (step 2, step 4, hyp 1) |- ( ( z ∈ A ∧ w ∈ A ) → ( z R w ↔ ( F ` z ) S ( F ` w ) ) ) ;;
	step 6 : wff = rgen2a (step 5) |- ∀ z ∈ A ∀ w ∈ A ( z R w ↔ ( F ` z ) S ( F ` w ) ) ;;
	step 7 : wff = df-isom () |- ( F Isom R , S ( A , B ) ↔ ( F : A ⤖ B ∧ ∀ z ∈ A ∀ w ∈ A ( z R w ↔ ( F ` z ) S ( F ` w ) ) ) ) ;;
	step 8 : wff = isowe () |- ( F Isom R , S ( A , B ) → ( R We A ↔ S We B ) ) ;;
	step 9 : wff = sylbir (step 7, step 8) |- ( ( F : A ⤖ B ∧ ∀ z ∈ A ∀ w ∈ A ( z R w ↔ ( F ` z ) S ( F ` w ) ) ) → ( R We A ↔ S We B ) ) ;;
	step 10 : wff = mpan2 (step 6, step 9) |- ( F : A ⤖ B → ( R We A ↔ S We B ) ) ;;
	step 11 : wff = biimprd (step 10) |- ( F : A ⤖ B → ( S We B → R We A ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Well-ordering of isomorphic relations.  (This version is proved directly
       instead of with the isomorphism predicate.)  (Contributed by NM,
       4-Mar-1997.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem f1oweALT (x : set, y : set, A : class, B : class, R : class, S : class, F : class) disjointed(z w v u f R, x y z w v u f S, z w v u f A, z w v u f B, x y z w v u f F) {
	hyp 1 : wff = |- R = { 〈 x , y 〉 | ( F ` x ) S ( F ` y ) } ;;
	-----------------------
	prop 1 : wff = |- ( F : A ⤖ B → ( S We B → R We A ) ) ;;
}

proof of f1oweALT {
	var z : set, w : set, v : set, u : set, f : set;;
	step 1 : wff = f1ofo () |- ( F : A ⤖ B → F : A ↠ B ) ;;
	step 2 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 3 : wff = freq2 () |- ( ran F = B → ( S Fr ran F ↔ S Fr B ) ) ;;
	step 4 : wff = biimprd (step 3) |- ( ran F = B → ( S Fr B → S Fr ran F ) ) ;;
	step 5 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 6 : wff = df-fr () |- ( S Fr ran F ↔ ∀ w ( ( w ⊆ ran F ∧ w ≠ ∅ ) → ∃ u ∈ w ∀ f ∈ w ¬ f S u ) ) ;;
	step 7 : wff = vex () |- z ∈ _V ;;
	step 8 : wff = funimaex (step 7) |- ( Fun F → ( F " z ) ∈ _V ) ;;
	step 9 : wff = n0 () |- ( z ≠ ∅ ↔ ∃ w w ∈ z ) ;;
	step 10 : wff = funfvima2 () |- ( ( Fun F ∧ z ⊆ dom F ) → ( w ∈ z → ( F ` w ) ∈ ( F " z ) ) ) ;;
	step 11 : wff = ne0i () |- ( ( F ` w ) ∈ ( F " z ) → ( F " z ) ≠ ∅ ) ;;
	step 12 : wff = syl6 (step 10, step 11) |- ( ( Fun F ∧ z ⊆ dom F ) → ( w ∈ z → ( F " z ) ≠ ∅ ) ) ;;
	step 13 : wff = exlimdv (step 12) |- ( ( Fun F ∧ z ⊆ dom F ) → ( ∃ w w ∈ z → ( F " z ) ≠ ∅ ) ) ;;
	step 14 : wff = syl5bi (step 9, step 13) |- ( ( Fun F ∧ z ⊆ dom F ) → ( z ≠ ∅ → ( F " z ) ≠ ∅ ) ) ;;
	step 15 : wff = imp (step 14) |- ( ( ( Fun F ∧ z ⊆ dom F ) ∧ z ≠ ∅ ) → ( F " z ) ≠ ∅ ) ;;
	step 16 : wff = imassrn () |- ( F " z ) ⊆ ran F ;;
	step 17 : wff = jctil (step 15, step 16) |- ( ( ( Fun F ∧ z ⊆ dom F ) ∧ z ≠ ∅ ) → ( ( F " z ) ⊆ ran F ∧ ( F " z ) ≠ ∅ ) ) ;;
	step 18 : wff = sseq1 () |- ( w = ( F " z ) → ( w ⊆ ran F ↔ ( F " z ) ⊆ ran F ) ) ;;
	step 19 : wff = neeq1 () |- ( w = ( F " z ) → ( w ≠ ∅ ↔ ( F " z ) ≠ ∅ ) ) ;;
	step 20 : wff = anbi12d (step 18, step 19) |- ( w = ( F " z ) → ( ( w ⊆ ran F ∧ w ≠ ∅ ) ↔ ( ( F " z ) ⊆ ran F ∧ ( F " z ) ≠ ∅ ) ) ) ;;
	step 21 : wff = raleq () |- ( w = ( F " z ) → ( ∀ f ∈ w ¬ f S u ↔ ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 22 : wff = rexeqbi1dv (step 21) |- ( w = ( F " z ) → ( ∃ u ∈ w ∀ f ∈ w ¬ f S u ↔ ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 23 : wff = imbi12d (step 20, step 22) |- ( w = ( F " z ) → ( ( ( w ⊆ ran F ∧ w ≠ ∅ ) → ∃ u ∈ w ∀ f ∈ w ¬ f S u ) ↔ ( ( ( F " z ) ⊆ ran F ∧ ( F " z ) ≠ ∅ ) → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 24 : wff = spcgv (step 23) |- ( ( F " z ) ∈ _V → ( ∀ w ( ( w ⊆ ran F ∧ w ≠ ∅ ) → ∃ u ∈ w ∀ f ∈ w ¬ f S u ) → ( ( ( F " z ) ⊆ ran F ∧ ( F " z ) ≠ ∅ ) → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 25 : wff = syl7 (step 17, step 24) |- ( ( F " z ) ∈ _V → ( ∀ w ( ( w ⊆ ran F ∧ w ≠ ∅ ) → ∃ u ∈ w ∀ f ∈ w ¬ f S u ) → ( ( ( Fun F ∧ z ⊆ dom F ) ∧ z ≠ ∅ ) → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 26 : wff = syl (step 8, step 25) |- ( Fun F → ( ∀ w ( ( w ⊆ ran F ∧ w ≠ ∅ ) → ∃ u ∈ w ∀ f ∈ w ¬ f S u ) → ( ( ( Fun F ∧ z ⊆ dom F ) ∧ z ≠ ∅ ) → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 27 : wff = syl5bi (step 6, step 26) |- ( Fun F → ( S Fr ran F → ( ( ( Fun F ∧ z ⊆ dom F ) ∧ z ≠ ∅ ) → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 28 : wff = com23 (step 27) |- ( Fun F → ( ( ( Fun F ∧ z ⊆ dom F ) ∧ z ≠ ∅ ) → ( S Fr ran F → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 29 : wff = exp3a (step 28) |- ( Fun F → ( ( Fun F ∧ z ⊆ dom F ) → ( z ≠ ∅ → ( S Fr ran F → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ) ;;
	step 30 : wff = anabsi5 (step 29) |- ( ( Fun F ∧ z ⊆ dom F ) → ( z ≠ ∅ → ( S Fr ran F → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ) ;;
	step 31 : wff = imp3a (step 30) |- ( ( Fun F ∧ z ⊆ dom F ) → ( ( z ≠ ∅ ∧ S Fr ran F ) → ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 32 : wff = fores () |- ( ( Fun F ∧ z ⊆ dom F ) → ( F ↾ z ) : z ↠ ( F " z ) ) ;;
	step 33 : wff = fvres () |- ( v ∈ z → ( ( F ↾ z ) ` v ) = ( F ` v ) ) ;;
	step 34 : wff = fvres () |- ( w ∈ z → ( ( F ↾ z ) ` w ) = ( F ` w ) ) ;;
	step 35 : wff = breqan12rd (step 33, step 34) |- ( ( w ∈ z ∧ v ∈ z ) → ( ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ↔ ( F ` v ) S ( F ` w ) ) ) ;;
	step 36 : wff = vex () |- v ∈ _V ;;
	step 37 : wff = vex () |- w ∈ _V ;;
	step 38 : wff = fveq2 () |- ( x = v → ( F ` x ) = ( F ` v ) ) ;;
	step 39 : wff = breq1d (step 38) |- ( x = v → ( ( F ` x ) S ( F ` y ) ↔ ( F ` v ) S ( F ` y ) ) ) ;;
	step 40 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 41 : wff = breq2d (step 40) |- ( y = w → ( ( F ` v ) S ( F ` y ) ↔ ( F ` v ) S ( F ` w ) ) ) ;;
	step 42 : wff = brab (step 36, step 37, step 39, step 41, hyp 1) |- ( v R w ↔ ( F ` v ) S ( F ` w ) ) ;;
	step 43 : wff = syl6rbbr (step 35, step 42) |- ( ( w ∈ z ∧ v ∈ z ) → ( v R w ↔ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ) ) ;;
	step 44 : wff = notbid (step 43) |- ( ( w ∈ z ∧ v ∈ z ) → ( ¬ v R w ↔ ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ) ) ;;
	step 45 : wff = ralbidva (step 44) |- ( w ∈ z → ( ∀ v ∈ z ¬ v R w ↔ ∀ v ∈ z ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ) ) ;;
	step 46 : wff = rexbiia (step 45) |- ( ∃ w ∈ z ∀ v ∈ z ¬ v R w ↔ ∃ w ∈ z ∀ v ∈ z ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ) ;;
	step 47 : wff = breq1 () |- ( ( ( F ↾ z ) ` v ) = f → ( ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ↔ f S ( ( F ↾ z ) ` w ) ) ) ;;
	step 48 : wff = notbid (step 47) |- ( ( ( F ↾ z ) ` v ) = f → ( ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ↔ ¬ f S ( ( F ↾ z ) ` w ) ) ) ;;
	step 49 : wff = cbvfo (step 48) |- ( ( F ↾ z ) : z ↠ ( F " z ) → ( ∀ v ∈ z ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ↔ ∀ f ∈ ( F " z ) ¬ f S ( ( F ↾ z ) ` w ) ) ) ;;
	step 50 : wff = rexbidv (step 49) |- ( ( F ↾ z ) : z ↠ ( F " z ) → ( ∃ w ∈ z ∀ v ∈ z ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ↔ ∃ w ∈ z ∀ f ∈ ( F " z ) ¬ f S ( ( F ↾ z ) ` w ) ) ) ;;
	step 51 : wff = breq2 () |- ( ( ( F ↾ z ) ` w ) = u → ( f S ( ( F ↾ z ) ` w ) ↔ f S u ) ) ;;
	step 52 : wff = notbid (step 51) |- ( ( ( F ↾ z ) ` w ) = u → ( ¬ f S ( ( F ↾ z ) ` w ) ↔ ¬ f S u ) ) ;;
	step 53 : wff = ralbidv (step 52) |- ( ( ( F ↾ z ) ` w ) = u → ( ∀ f ∈ ( F " z ) ¬ f S ( ( F ↾ z ) ` w ) ↔ ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 54 : wff = cbvexfo (step 53) |- ( ( F ↾ z ) : z ↠ ( F " z ) → ( ∃ w ∈ z ∀ f ∈ ( F " z ) ¬ f S ( ( F ↾ z ) ` w ) ↔ ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 55 : wff = bitrd (step 50, step 54) |- ( ( F ↾ z ) : z ↠ ( F " z ) → ( ∃ w ∈ z ∀ v ∈ z ¬ ( ( F ↾ z ) ` v ) S ( ( F ↾ z ) ` w ) ↔ ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 56 : wff = syl5bb (step 46, step 55) |- ( ( F ↾ z ) : z ↠ ( F " z ) → ( ∃ w ∈ z ∀ v ∈ z ¬ v R w ↔ ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 57 : wff = syl (step 32, step 56) |- ( ( Fun F ∧ z ⊆ dom F ) → ( ∃ w ∈ z ∀ v ∈ z ¬ v R w ↔ ∃ u ∈ ( F " z ) ∀ f ∈ ( F " z ) ¬ f S u ) ) ;;
	step 58 : wff = sylibrd (step 31, step 57) |- ( ( Fun F ∧ z ⊆ dom F ) → ( ( z ≠ ∅ ∧ S Fr ran F ) → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ;;
	step 59 : wff = exp4b (step 58) |- ( Fun F → ( z ⊆ dom F → ( z ≠ ∅ → ( S Fr ran F → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ) ) ;;
	step 60 : wff = com34 (step 59) |- ( Fun F → ( z ⊆ dom F → ( S Fr ran F → ( z ≠ ∅ → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ) ) ;;
	step 61 : wff = com23 (step 60) |- ( Fun F → ( S Fr ran F → ( z ⊆ dom F → ( z ≠ ∅ → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ) ) ;;
	step 62 : wff = imp4a (step 61) |- ( Fun F → ( S Fr ran F → ( ( z ⊆ dom F ∧ z ≠ ∅ ) → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ) ;;
	step 63 : wff = alrimdv (step 62) |- ( Fun F → ( S Fr ran F → ∀ z ( ( z ⊆ dom F ∧ z ≠ ∅ ) → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ) ;;
	step 64 : wff = df-fr () |- ( R Fr dom F ↔ ∀ z ( ( z ⊆ dom F ∧ z ≠ ∅ ) → ∃ w ∈ z ∀ v ∈ z ¬ v R w ) ) ;;
	step 65 : wff = syl6ibr (step 63, step 64) |- ( Fun F → ( S Fr ran F → R Fr dom F ) ) ;;
	step 66 : wff = freq2 () |- ( dom F = A → ( R Fr dom F ↔ R Fr A ) ) ;;
	step 67 : wff = biimpd (step 66) |- ( dom F = A → ( R Fr dom F → R Fr A ) ) ;;
	step 68 : wff = sylan9 (step 65, step 67) |- ( ( Fun F ∧ dom F = A ) → ( S Fr ran F → R Fr A ) ) ;;
	step 69 : wff = sylbi (step 5, step 68) |- ( F Fn A → ( S Fr ran F → R Fr A ) ) ;;
	step 70 : wff = sylan9r (step 4, step 69) |- ( ( F Fn A ∧ ran F = B ) → ( S Fr B → R Fr A ) ) ;;
	step 71 : wff = sylbi (step 2, step 70) |- ( F : A ↠ B → ( S Fr B → R Fr A ) ) ;;
	step 72 : wff = syl (step 1, step 71) |- ( F : A ⤖ B → ( S Fr B → R Fr A ) ) ;;
	step 73 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 74 : wff = vex () |- w ∈ _V ;;
	step 75 : wff = vex () |- v ∈ _V ;;
	step 76 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 77 : wff = breq1d (step 76) |- ( x = w → ( ( F ` x ) S ( F ` y ) ↔ ( F ` w ) S ( F ` y ) ) ) ;;
	step 78 : wff = fveq2 () |- ( y = v → ( F ` y ) = ( F ` v ) ) ;;
	step 79 : wff = breq2d (step 78) |- ( y = v → ( ( F ` w ) S ( F ` y ) ↔ ( F ` w ) S ( F ` v ) ) ) ;;
	step 80 : wff = brab (step 74, step 75, step 77, step 79, hyp 1) |- ( w R v ↔ ( F ` w ) S ( F ` v ) ) ;;
	step 81 : wff = a1i (step 80) |- ( ( F : A ↣ B ∧ ( w ∈ A ∧ v ∈ A ) ) → ( w R v ↔ ( F ` w ) S ( F ` v ) ) ) ;;
	step 82 : wff = f1fveq () |- ( ( F : A ↣ B ∧ ( w ∈ A ∧ v ∈ A ) ) → ( ( F ` w ) = ( F ` v ) ↔ w = v ) ) ;;
	step 83 : wff = bicomd (step 82) |- ( ( F : A ↣ B ∧ ( w ∈ A ∧ v ∈ A ) ) → ( w = v ↔ ( F ` w ) = ( F ` v ) ) ) ;;
	step 84 : wff = vex () |- v ∈ _V ;;
	step 85 : wff = vex () |- w ∈ _V ;;
	step 86 : wff = fveq2 () |- ( x = v → ( F ` x ) = ( F ` v ) ) ;;
	step 87 : wff = breq1d (step 86) |- ( x = v → ( ( F ` x ) S ( F ` y ) ↔ ( F ` v ) S ( F ` y ) ) ) ;;
	step 88 : wff = fveq2 () |- ( y = w → ( F ` y ) = ( F ` w ) ) ;;
	step 89 : wff = breq2d (step 88) |- ( y = w → ( ( F ` v ) S ( F ` y ) ↔ ( F ` v ) S ( F ` w ) ) ) ;;
	step 90 : wff = brab (step 84, step 85, step 87, step 89, hyp 1) |- ( v R w ↔ ( F ` v ) S ( F ` w ) ) ;;
	step 91 : wff = a1i (step 90) |- ( ( F : A ↣ B ∧ ( w ∈ A ∧ v ∈ A ) ) → ( v R w ↔ ( F ` v ) S ( F ` w ) ) ) ;;
	step 92 : wff = 3orbi123d (step 81, step 83, step 91) |- ( ( F : A ↣ B ∧ ( w ∈ A ∧ v ∈ A ) ) → ( ( w R v ∨ w = v ∨ v R w ) ↔ ( ( F ` w ) S ( F ` v ) ∨ ( F ` w ) = ( F ` v ) ∨ ( F ` v ) S ( F ` w ) ) ) ) ;;
	step 93 : wff = 2ralbidva (step 92) |- ( F : A ↣ B → ( ∀ w ∈ A ∀ v ∈ A ( w R v ∨ w = v ∨ v R w ) ↔ ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) S ( F ` v ) ∨ ( F ` w ) = ( F ` v ) ∨ ( F ` v ) S ( F ` w ) ) ) ) ;;
	step 94 : wff = breq1 () |- ( ( F ` w ) = u → ( ( F ` w ) S ( F ` v ) ↔ u S ( F ` v ) ) ) ;;
	step 95 : wff = eqeq1 () |- ( ( F ` w ) = u → ( ( F ` w ) = ( F ` v ) ↔ u = ( F ` v ) ) ) ;;
	step 96 : wff = breq2 () |- ( ( F ` w ) = u → ( ( F ` v ) S ( F ` w ) ↔ ( F ` v ) S u ) ) ;;
	step 97 : wff = 3orbi123d (step 94, step 95, step 96) |- ( ( F ` w ) = u → ( ( ( F ` w ) S ( F ` v ) ∨ ( F ` w ) = ( F ` v ) ∨ ( F ` v ) S ( F ` w ) ) ↔ ( u S ( F ` v ) ∨ u = ( F ` v ) ∨ ( F ` v ) S u ) ) ) ;;
	step 98 : wff = ralbidv (step 97) |- ( ( F ` w ) = u → ( ∀ v ∈ A ( ( F ` w ) S ( F ` v ) ∨ ( F ` w ) = ( F ` v ) ∨ ( F ` v ) S ( F ` w ) ) ↔ ∀ v ∈ A ( u S ( F ` v ) ∨ u = ( F ` v ) ∨ ( F ` v ) S u ) ) ) ;;
	step 99 : wff = cbvfo (step 98) |- ( F : A ↠ B → ( ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) S ( F ` v ) ∨ ( F ` w ) = ( F ` v ) ∨ ( F ` v ) S ( F ` w ) ) ↔ ∀ u ∈ B ∀ v ∈ A ( u S ( F ` v ) ∨ u = ( F ` v ) ∨ ( F ` v ) S u ) ) ) ;;
	step 100 : wff = breq2 () |- ( ( F ` v ) = f → ( u S ( F ` v ) ↔ u S f ) ) ;;
	step 101 : wff = eqeq2 () |- ( ( F ` v ) = f → ( u = ( F ` v ) ↔ u = f ) ) ;;
	step 102 : wff = breq1 () |- ( ( F ` v ) = f → ( ( F ` v ) S u ↔ f S u ) ) ;;
	step 103 : wff = 3orbi123d (step 100, step 101, step 102) |- ( ( F ` v ) = f → ( ( u S ( F ` v ) ∨ u = ( F ` v ) ∨ ( F ` v ) S u ) ↔ ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 104 : wff = cbvfo (step 103) |- ( F : A ↠ B → ( ∀ v ∈ A ( u S ( F ` v ) ∨ u = ( F ` v ) ∨ ( F ` v ) S u ) ↔ ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 105 : wff = ralbidv (step 104) |- ( F : A ↠ B → ( ∀ u ∈ B ∀ v ∈ A ( u S ( F ` v ) ∨ u = ( F ` v ) ∨ ( F ` v ) S u ) ↔ ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 106 : wff = bitrd (step 99, step 105) |- ( F : A ↠ B → ( ∀ w ∈ A ∀ v ∈ A ( ( F ` w ) S ( F ` v ) ∨ ( F ` w ) = ( F ` v ) ∨ ( F ` v ) S ( F ` w ) ) ↔ ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 107 : wff = sylan9bb (step 93, step 106) |- ( ( F : A ↣ B ∧ F : A ↠ B ) → ( ∀ w ∈ A ∀ v ∈ A ( w R v ∨ w = v ∨ v R w ) ↔ ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 108 : wff = sylbi (step 73, step 107) |- ( F : A ⤖ B → ( ∀ w ∈ A ∀ v ∈ A ( w R v ∨ w = v ∨ v R w ) ↔ ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 109 : wff = biimprd (step 108) |- ( F : A ⤖ B → ( ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) → ∀ w ∈ A ∀ v ∈ A ( w R v ∨ w = v ∨ v R w ) ) ) ;;
	step 110 : wff = anim12d (step 72, step 109) |- ( F : A ⤖ B → ( ( S Fr B ∧ ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) → ( R Fr A ∧ ∀ w ∈ A ∀ v ∈ A ( w R v ∨ w = v ∨ v R w ) ) ) ) ;;
	step 111 : wff = dfwe2 () |- ( S We B ↔ ( S Fr B ∧ ∀ u ∈ B ∀ f ∈ B ( u S f ∨ u = f ∨ f S u ) ) ) ;;
	step 112 : wff = dfwe2 () |- ( R We A ↔ ( R Fr A ∧ ∀ w ∈ A ∀ v ∈ A ( w R v ∨ w = v ∨ v R w ) ) ) ;;
	step 113 : wff = 3imtr4g (step 110, step 111, step 112) |- ( F : A ⤖ B → ( S We B → R We A ) ) ;;
	qed prop 1 = step 113 ;;
}

/*A set-like well-ordering has no nontrivial automorphisms.  (Contributed
       by Stefan O'Rear, 16-Nov-2014.)  (Revised by Mario Carneiro,
       25-Jun-2015.) */

theorem weniso (A : class, R : class, F : class) disjointed(A a b c, R b c, F a b c) {
	prop 1 : wff = |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → F = ( _I ↾ A ) ) ;;
}

proof of weniso {
	var a : set, b : set, c : set;;
	step 1 : wff = rabn0 () |- ( { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ↔ ∃ a ∈ A ¬ ( F ` a ) = a ) ;;
	step 2 : wff = rexnal () |- ( ∃ a ∈ A ¬ ( F ` a ) = a ↔ ¬ ∀ a ∈ A ( F ` a ) = a ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ↔ ¬ ∀ a ∈ A ( F ` a ) = a ) ;;
	step 4 : wff = simpl1 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) → R We A ) ;;
	step 5 : wff = simpl2 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) → R Se A ) ;;
	step 6 : wff = ssrab2 () |- { a ∈ A | ¬ ( F ` a ) = a } ⊆ A ;;
	step 7 : wff = a1i (step 6) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) → { a ∈ A | ¬ ( F ` a ) = a } ⊆ A ) ;;
	step 8 : wff = simpr () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) → { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) ;;
	step 9 : wff = wereu2 () |- ( ( ( R We A ∧ R Se A ) ∧ ( { a ∈ A | ¬ ( F ` a ) = a } ⊆ A ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) ) → ∃! b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ) ;;
	step 10 : wff = syl22anc (step 4, step 5, step 7, step 8, step 9) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) → ∃! b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ) ;;
	step 11 : wff = reurex () |- ( ∃! b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b → ∃ b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ ) → ∃ b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ) ;;
	step 13 : wff = ex (step 12) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ → ∃ b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ) ) ;;
	step 14 : wff = fveq2 () |- ( a = b → ( F ` a ) = ( F ` b ) ) ;;
	step 15 : wff = id () |- ( a = b → a = b ) ;;
	step 16 : wff = eqeq12d (step 14, step 15) |- ( a = b → ( ( F ` a ) = a ↔ ( F ` b ) = b ) ) ;;
	step 17 : wff = notbid (step 16) |- ( a = b → ( ¬ ( F ` a ) = a ↔ ¬ ( F ` b ) = b ) ) ;;
	step 18 : wff = elrab (step 17) |- ( b ∈ { a ∈ A | ¬ ( F ` a ) = a } ↔ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ;;
	step 19 : wff = fveq2 () |- ( a = c → ( F ` a ) = ( F ` c ) ) ;;
	step 20 : wff = id () |- ( a = c → a = c ) ;;
	step 21 : wff = eqeq12d (step 19, step 20) |- ( a = c → ( ( F ` a ) = a ↔ ( F ` c ) = c ) ) ;;
	step 22 : wff = notbid (step 21) |- ( a = c → ( ¬ ( F ` a ) = a ↔ ¬ ( F ` c ) = c ) ) ;;
	step 23 : wff = ralrab (step 22) |- ( ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ↔ ∀ c ∈ A ( ¬ ( F ` c ) = c → ¬ c R b ) ) ;;
	step 24 : wff = con34b () |- ( ( c R b → ( F ` c ) = c ) ↔ ( ¬ ( F ` c ) = c → ¬ c R b ) ) ;;
	step 25 : wff = bicomi (step 24) |- ( ( ¬ ( F ` c ) = c → ¬ c R b ) ↔ ( c R b → ( F ` c ) = c ) ) ;;
	step 26 : wff = ralbii (step 25) |- ( ∀ c ∈ A ( ¬ ( F ` c ) = c → ¬ c R b ) ↔ ∀ c ∈ A ( c R b → ( F ` c ) = c ) ) ;;
	step 27 : wff = bitri (step 23, step 26) |- ( ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b ↔ ∀ c ∈ A ( c R b → ( F ` c ) = c ) ) ;;
	step 28 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 29 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 30 : wff = syl (step 28, step 29) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 31 : wff = f1of () |- ( F : A ⤖ A → F : A ⟶ A ) ;;
	step 32 : wff = syl (step 30, step 31) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⟶ A ) ;;
	step 33 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 34 : wff = ffvelrn () |- ( ( F : A ⟶ A ∧ b ∈ A ) → ( F ` b ) ∈ A ) ;;
	step 35 : wff = syl2anc (step 32, step 33, step 34) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` b ) ∈ A ) ;;
	step 36 : wff = breq1 () |- ( c = ( F ` b ) → ( c R b ↔ ( F ` b ) R b ) ) ;;
	step 37 : wff = fveq2 () |- ( c = ( F ` b ) → ( F ` c ) = ( F ` ( F ` b ) ) ) ;;
	step 38 : wff = id () |- ( c = ( F ` b ) → c = ( F ` b ) ) ;;
	step 39 : wff = eqeq12d (step 37, step 38) |- ( c = ( F ` b ) → ( ( F ` c ) = c ↔ ( F ` ( F ` b ) ) = ( F ` b ) ) ) ;;
	step 40 : wff = imbi12d (step 36, step 39) |- ( c = ( F ` b ) → ( ( c R b → ( F ` c ) = c ) ↔ ( ( F ` b ) R b → ( F ` ( F ` b ) ) = ( F ` b ) ) ) ) ;;
	step 41 : wff = rspcv (step 40) |- ( ( F ` b ) ∈ A → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( ( F ` b ) R b → ( F ` ( F ` b ) ) = ( F ` b ) ) ) ) ;;
	step 42 : wff = syl (step 35, step 41) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( ( F ` b ) R b → ( F ` ( F ` b ) ) = ( F ` b ) ) ) ) ;;
	step 43 : wff = com23 (step 42) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` b ) R b → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( F ` ( F ` b ) ) = ( F ` b ) ) ) ) ;;
	step 44 : wff = imp (step 43) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` b ) R b ) → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( F ` ( F ` b ) ) = ( F ` b ) ) ) ;;
	step 45 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 46 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 47 : wff = syl (step 45, step 46) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 48 : wff = f1of1 () |- ( F : A ⤖ A → F : A ↣ A ) ;;
	step 49 : wff = syl (step 47, step 48) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ↣ A ) ;;
	step 50 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 51 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 52 : wff = syl (step 50, step 51) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 53 : wff = f1of () |- ( F : A ⤖ A → F : A ⟶ A ) ;;
	step 54 : wff = syl (step 52, step 53) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⟶ A ) ;;
	step 55 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 56 : wff = ffvelrn () |- ( ( F : A ⟶ A ∧ b ∈ A ) → ( F ` b ) ∈ A ) ;;
	step 57 : wff = syl2anc (step 54, step 55, step 56) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` b ) ∈ A ) ;;
	step 58 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 59 : wff = f1fveq () |- ( ( F : A ↣ A ∧ ( ( F ` b ) ∈ A ∧ b ∈ A ) ) → ( ( F ` ( F ` b ) ) = ( F ` b ) ↔ ( F ` b ) = b ) ) ;;
	step 60 : wff = syl12anc (step 49, step 57, step 58, step 59) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` ( F ` b ) ) = ( F ` b ) ↔ ( F ` b ) = b ) ) ;;
	step 61 : wff = pm2.21 () |- ( ¬ ( F ` b ) = b → ( ( F ` b ) = b → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 62 : wff = ad2antll (step 61) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` b ) = b → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 63 : wff = sylbid (step 60, step 62) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` ( F ` b ) ) = ( F ` b ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 64 : wff = adantr (step 63) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` b ) R b ) → ( ( F ` ( F ` b ) ) = ( F ` b ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 65 : wff = syld (step 44, step 64) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` b ) R b ) → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 66 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 67 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 68 : wff = syl (step 66, step 67) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 69 : wff = f1ocnv () |- ( F : A ⤖ A → ⁻¹ F : A ⤖ A ) ;;
	step 70 : wff = f1of () |- ( ⁻¹ F : A ⤖ A → ⁻¹ F : A ⟶ A ) ;;
	step 71 : wff = 3syl (step 68, step 69, step 70) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ⁻¹ F : A ⟶ A ) ;;
	step 72 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 73 : wff = ffvelrn () |- ( ( ⁻¹ F : A ⟶ A ∧ b ∈ A ) → ( ⁻¹ F ` b ) ∈ A ) ;;
	step 74 : wff = syl2anc (step 71, step 72, step 73) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ⁻¹ F ` b ) ∈ A ) ;;
	step 75 : wff = adantr (step 74) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ b R ( F ` b ) ) → ( ⁻¹ F ` b ) ∈ A ) ;;
	step 76 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 77 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 78 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 79 : wff = syl (step 77, step 78) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 80 : wff = f1ocnv () |- ( F : A ⤖ A → ⁻¹ F : A ⤖ A ) ;;
	step 81 : wff = f1of () |- ( ⁻¹ F : A ⤖ A → ⁻¹ F : A ⟶ A ) ;;
	step 82 : wff = 3syl (step 79, step 80, step 81) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ⁻¹ F : A ⟶ A ) ;;
	step 83 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 84 : wff = ffvelrn () |- ( ( ⁻¹ F : A ⟶ A ∧ b ∈ A ) → ( ⁻¹ F ` b ) ∈ A ) ;;
	step 85 : wff = syl2anc (step 82, step 83, step 84) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ⁻¹ F ` b ) ∈ A ) ;;
	step 86 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 87 : wff = isorel () |- ( ( F Isom R , R ( A , A ) ∧ ( ( ⁻¹ F ` b ) ∈ A ∧ b ∈ A ) ) → ( ( ⁻¹ F ` b ) R b ↔ ( F ` ( ⁻¹ F ` b ) ) R ( F ` b ) ) ) ;;
	step 88 : wff = syl12anc (step 76, step 85, step 86, step 87) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( ⁻¹ F ` b ) R b ↔ ( F ` ( ⁻¹ F ` b ) ) R ( F ` b ) ) ) ;;
	step 89 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 90 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 91 : wff = syl (step 89, step 90) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 92 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 93 : wff = f1ocnvfv2 () |- ( ( F : A ⤖ A ∧ b ∈ A ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 94 : wff = syl2anc (step 91, step 92, step 93) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 95 : wff = breq1d (step 94) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` ( ⁻¹ F ` b ) ) R ( F ` b ) ↔ b R ( F ` b ) ) ) ;;
	step 96 : wff = bitr2d (step 88, step 95) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( b R ( F ` b ) ↔ ( ⁻¹ F ` b ) R b ) ) ;;
	step 97 : wff = biimpa (step 96) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ b R ( F ` b ) ) → ( ⁻¹ F ` b ) R b ) ;;
	step 98 : wff = breq1 () |- ( c = ( ⁻¹ F ` b ) → ( c R b ↔ ( ⁻¹ F ` b ) R b ) ) ;;
	step 99 : wff = fveq2 () |- ( c = ( ⁻¹ F ` b ) → ( F ` c ) = ( F ` ( ⁻¹ F ` b ) ) ) ;;
	step 100 : wff = id () |- ( c = ( ⁻¹ F ` b ) → c = ( ⁻¹ F ` b ) ) ;;
	step 101 : wff = eqeq12d (step 99, step 100) |- ( c = ( ⁻¹ F ` b ) → ( ( F ` c ) = c ↔ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) ) ;;
	step 102 : wff = imbi12d (step 98, step 101) |- ( c = ( ⁻¹ F ` b ) → ( ( c R b → ( F ` c ) = c ) ↔ ( ( ⁻¹ F ` b ) R b → ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) ) ) ;;
	step 103 : wff = rspcv (step 102) |- ( ( ⁻¹ F ` b ) ∈ A → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( ( ⁻¹ F ` b ) R b → ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) ) ) ;;
	step 104 : wff = com23 (step 103) |- ( ( ⁻¹ F ` b ) ∈ A → ( ( ⁻¹ F ` b ) R b → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) ) ) ;;
	step 105 : wff = sylc (step 75, step 97, step 104) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ b R ( F ` b ) ) → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) ) ;;
	step 106 : wff = simplrr () |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) → ¬ ( F ` b ) = b ) ;;
	step 107 : wff = fveq2 () |- ( ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) → ( F ` ( F ` ( ⁻¹ F ` b ) ) ) = ( F ` ( ⁻¹ F ` b ) ) ) ;;
	step 108 : wff = adantl (step 107) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) → ( F ` ( F ` ( ⁻¹ F ` b ) ) ) = ( F ` ( ⁻¹ F ` b ) ) ) ;;
	step 109 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 110 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 111 : wff = syl (step 109, step 110) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 112 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 113 : wff = f1ocnvfv2 () |- ( ( F : A ⤖ A ∧ b ∈ A ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 114 : wff = syl2anc (step 111, step 112, step 113) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 115 : wff = fveq2d (step 114) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` ( F ` ( ⁻¹ F ` b ) ) ) = ( F ` b ) ) ;;
	step 116 : wff = adantr (step 115) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) → ( F ` ( F ` ( ⁻¹ F ` b ) ) ) = ( F ` b ) ) ;;
	step 117 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 118 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 119 : wff = syl (step 117, step 118) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 120 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 121 : wff = f1ocnvfv2 () |- ( ( F : A ⤖ A ∧ b ∈ A ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 122 : wff = syl2anc (step 119, step 120, step 121) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 123 : wff = adantr (step 122) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) → ( F ` ( ⁻¹ F ` b ) ) = b ) ;;
	step 124 : wff = 3eqtr3d (step 108, step 116, step 123) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) → ( F ` b ) = b ) ;;
	step 125 : wff = pm2.21 () |- ( ¬ ( F ` b ) = b → ( ( F ` b ) = b → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 126 : wff = sylc (step 106, step 124, step 125) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) ) → ∀ a ∈ A ( F ` a ) = a ) ;;
	step 127 : wff = ex (step 126) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 128 : wff = adantr (step 127) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ b R ( F ` b ) ) → ( ( F ` ( ⁻¹ F ` b ) ) = ( ⁻¹ F ` b ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 129 : wff = syld (step 105, step 128) |- ( ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) ∧ b R ( F ` b ) ) → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 130 : wff = simprr () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ¬ ( F ` b ) = b ) ;;
	step 131 : wff = simpl1 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → R We A ) ;;
	step 132 : wff = weso () |- ( R We A → R Or A ) ;;
	step 133 : wff = syl (step 131, step 132) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → R Or A ) ;;
	step 134 : wff = simpl3 () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F Isom R , R ( A , A ) ) ;;
	step 135 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 136 : wff = syl (step 134, step 135) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⤖ A ) ;;
	step 137 : wff = f1of () |- ( F : A ⤖ A → F : A ⟶ A ) ;;
	step 138 : wff = syl (step 136, step 137) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → F : A ⟶ A ) ;;
	step 139 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 140 : wff = ffvelrn () |- ( ( F : A ⟶ A ∧ b ∈ A ) → ( F ` b ) ∈ A ) ;;
	step 141 : wff = syl2anc (step 138, step 139, step 140) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( F ` b ) ∈ A ) ;;
	step 142 : wff = simprl () |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → b ∈ A ) ;;
	step 143 : wff = sotrieq () |- ( ( R Or A ∧ ( ( F ` b ) ∈ A ∧ b ∈ A ) ) → ( ( F ` b ) = b ↔ ¬ ( ( F ` b ) R b ∨ b R ( F ` b ) ) ) ) ;;
	step 144 : wff = syl12anc (step 133, step 141, step 142, step 143) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` b ) = b ↔ ¬ ( ( F ` b ) R b ∨ b R ( F ` b ) ) ) ) ;;
	step 145 : wff = con2bid (step 144) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( ( F ` b ) R b ∨ b R ( F ` b ) ) ↔ ¬ ( F ` b ) = b ) ) ;;
	step 146 : wff = mpbird (step 130, step 145) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ( F ` b ) R b ∨ b R ( F ` b ) ) ) ;;
	step 147 : wff = mpjaodan (step 65, step 129, step 146) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ∀ c ∈ A ( c R b → ( F ` c ) = c ) → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 148 : wff = syl5bi (step 27, step 147) |- ( ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) ∧ ( b ∈ A ∧ ¬ ( F ` b ) = b ) ) → ( ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 149 : wff = ex (step 148) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( ( b ∈ A ∧ ¬ ( F ` b ) = b ) → ( ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b → ∀ a ∈ A ( F ` a ) = a ) ) ) ;;
	step 150 : wff = syl5bi (step 18, step 149) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( b ∈ { a ∈ A | ¬ ( F ` a ) = a } → ( ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b → ∀ a ∈ A ( F ` a ) = a ) ) ) ;;
	step 151 : wff = rexlimdv (step 150) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( ∃ b ∈ { a ∈ A | ¬ ( F ` a ) = a } ∀ c ∈ { a ∈ A | ¬ ( F ` a ) = a } ¬ c R b → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 152 : wff = syld (step 13, step 151) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( { a ∈ A | ¬ ( F ` a ) = a } ≠ ∅ → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 153 : wff = syl5bir (step 3, step 152) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( ¬ ∀ a ∈ A ( F ` a ) = a → ∀ a ∈ A ( F ` a ) = a ) ) ;;
	step 154 : wff = pm2.18d (step 153) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ∀ a ∈ A ( F ` a ) = a ) ;;
	step 155 : wff = fvresi () |- ( a ∈ A → ( ( _I ↾ A ) ` a ) = a ) ;;
	step 156 : wff = eqeq2d (step 155) |- ( a ∈ A → ( ( F ` a ) = ( ( _I ↾ A ) ` a ) ↔ ( F ` a ) = a ) ) ;;
	step 157 : wff = biimprd (step 156) |- ( a ∈ A → ( ( F ` a ) = a → ( F ` a ) = ( ( _I ↾ A ) ` a ) ) ) ;;
	step 158 : wff = ralimia (step 157) |- ( ∀ a ∈ A ( F ` a ) = a → ∀ a ∈ A ( F ` a ) = ( ( _I ↾ A ) ` a ) ) ;;
	step 159 : wff = syl (step 154, step 158) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ∀ a ∈ A ( F ` a ) = ( ( _I ↾ A ) ` a ) ) ;;
	step 160 : wff = isof1o () |- ( F Isom R , R ( A , A ) → F : A ⤖ A ) ;;
	step 161 : wff = 3ad2ant3 (step 160) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → F : A ⤖ A ) ;;
	step 162 : wff = f1ofn () |- ( F : A ⤖ A → F Fn A ) ;;
	step 163 : wff = syl (step 161, step 162) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → F Fn A ) ;;
	step 164 : wff = fnresi () |- ( _I ↾ A ) Fn A ;;
	step 165 : wff = a1i (step 164) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( _I ↾ A ) Fn A ) ;;
	step 166 : wff = eqfnfv () |- ( ( F Fn A ∧ ( _I ↾ A ) Fn A ) → ( F = ( _I ↾ A ) ↔ ∀ a ∈ A ( F ` a ) = ( ( _I ↾ A ) ` a ) ) ) ;;
	step 167 : wff = syl2anc (step 163, step 165, step 166) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → ( F = ( _I ↾ A ) ↔ ∀ a ∈ A ( F ` a ) = ( ( _I ↾ A ) ` a ) ) ) ;;
	step 168 : wff = mpbird (step 159, step 167) |- ( ( R We A ∧ R Se A ∧ F Isom R , R ( A , A ) ) → F = ( _I ↾ A ) ) ;;
	qed prop 1 = step 168 ;;
}

/*Thus, there is at most one isomorphism between any two set-like
       well-ordered classes.  Class version of ~ wemoiso .  (Contributed by
       Mario Carneiro, 25-Jun-2015.) */

theorem weisoeq (A : class, B : class, R : class, S : class, F : class, G : class) disjointed(A, R, F) {
	prop 1 : wff = |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F = G ) ;;
}

proof of weisoeq {
	step 1 : wff = id () |- ( G Isom R , S ( A , B ) → G Isom R , S ( A , B ) ) ;;
	step 2 : wff = isocnv () |- ( F Isom R , S ( A , B ) → ⁻¹ F Isom S , R ( B , A ) ) ;;
	step 3 : wff = isotr () |- ( ( G Isom R , S ( A , B ) ∧ ⁻¹ F Isom S , R ( B , A ) ) → ( ⁻¹ F ∘ G ) Isom R , R ( A , A ) ) ;;
	step 4 : wff = syl2anr (step 1, step 2, step 3) |- ( ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) → ( ⁻¹ F ∘ G ) Isom R , R ( A , A ) ) ;;
	step 5 : wff = weniso () |- ( ( R We A ∧ R Se A ∧ ( ⁻¹ F ∘ G ) Isom R , R ( A , A ) ) → ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ;;
	step 6 : wff = 3expa (step 5) |- ( ( ( R We A ∧ R Se A ) ∧ ( ⁻¹ F ∘ G ) Isom R , R ( A , A ) ) → ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ;;
	step 7 : wff = sylan2 (step 4, step 6) |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ;;
	step 8 : wff = simprl () |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F Isom R , S ( A , B ) ) ;;
	step 9 : wff = isof1o () |- ( F Isom R , S ( A , B ) → F : A ⤖ B ) ;;
	step 10 : wff = f1of1 () |- ( F : A ⤖ B → F : A ↣ B ) ;;
	step 11 : wff = 3syl (step 8, step 9, step 10) |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F : A ↣ B ) ;;
	step 12 : wff = simprr () |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → G Isom R , S ( A , B ) ) ;;
	step 13 : wff = isof1o () |- ( G Isom R , S ( A , B ) → G : A ⤖ B ) ;;
	step 14 : wff = f1of1 () |- ( G : A ⤖ B → G : A ↣ B ) ;;
	step 15 : wff = 3syl (step 12, step 13, step 14) |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → G : A ↣ B ) ;;
	step 16 : wff = f1eqcocnv () |- ( ( F : A ↣ B ∧ G : A ↣ B ) → ( F = G ↔ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
	step 17 : wff = syl2anc (step 11, step 15, step 16) |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → ( F = G ↔ ( ⁻¹ F ∘ G ) = ( _I ↾ A ) ) ) ;;
	step 18 : wff = mpbird (step 7, step 17) |- ( ( ( R We A ∧ R Se A ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F = G ) ;;
	qed prop 1 = step 18 ;;
}

/*Thus, there is at most one isomorphism between any two set-like
       well-ordered classes.  Class version of ~ wemoiso2 .  (Contributed by
       Mario Carneiro, 25-Jun-2015.) */

theorem weisoeq2 (A : class, B : class, R : class, S : class, F : class, G : class) disjointed(A, R, F) {
	prop 1 : wff = |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F = G ) ;;
}

proof of weisoeq2 {
	step 1 : wff = isocnv () |- ( F Isom R , S ( A , B ) → ⁻¹ F Isom S , R ( B , A ) ) ;;
	step 2 : wff = isocnv () |- ( G Isom R , S ( A , B ) → ⁻¹ G Isom S , R ( B , A ) ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) → ( ⁻¹ F Isom S , R ( B , A ) ∧ ⁻¹ G Isom S , R ( B , A ) ) ) ;;
	step 4 : wff = weisoeq () |- ( ( ( S We B ∧ S Se B ) ∧ ( ⁻¹ F Isom S , R ( B , A ) ∧ ⁻¹ G Isom S , R ( B , A ) ) ) → ⁻¹ F = ⁻¹ G ) ;;
	step 5 : wff = sylan2 (step 3, step 4) |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → ⁻¹ F = ⁻¹ G ) ;;
	step 6 : wff = simprl () |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F Isom R , S ( A , B ) ) ;;
	step 7 : wff = isof1o () |- ( F Isom R , S ( A , B ) → F : A ⤖ B ) ;;
	step 8 : wff = f1orel () |- ( F : A ⤖ B → Rel F ) ;;
	step 9 : wff = 3syl (step 6, step 7, step 8) |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → Rel F ) ;;
	step 10 : wff = simprr () |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → G Isom R , S ( A , B ) ) ;;
	step 11 : wff = isof1o () |- ( G Isom R , S ( A , B ) → G : A ⤖ B ) ;;
	step 12 : wff = f1orel () |- ( G : A ⤖ B → Rel G ) ;;
	step 13 : wff = 3syl (step 10, step 11, step 12) |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → Rel G ) ;;
	step 14 : wff = cnveqb () |- ( ( Rel F ∧ Rel G ) → ( F = G ↔ ⁻¹ F = ⁻¹ G ) ) ;;
	step 15 : wff = syl2anc (step 9, step 13, step 14) |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → ( F = G ↔ ⁻¹ F = ⁻¹ G ) ) ;;
	step 16 : wff = mpbird (step 5, step 15) |- ( ( ( S We B ∧ S Se B ) ∧ ( F Isom R , S ( A , B ) ∧ G Isom R , S ( A , B ) ) ) → F = G ) ;;
	qed prop 1 = step 16 ;;
}

/*Thus, there is at most one isomorphism between any two well-ordered
       sets.  TODO:  Shorten ~ finnisoeu .  (Contributed by Stefan O'Rear,
       12-Feb-2015.)  (Revised by Mario Carneiro, 25-Jun-2015.) */

theorem wemoiso (A : class, B : class, R : class, S : class, f : set) disjointed(R f g, A f g, S f g, B f g) {
	prop 1 : wff = |- ( R We A → ∃* f f Isom R , S ( A , B ) ) ;;
}

proof of wemoiso {
	var g : set;;
	step 1 : wff = simpl () |- ( ( R We A ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → R We A ) ;;
	step 2 : wff = vex () |- f ∈ _V ;;
	step 3 : wff = isof1o () |- ( f Isom R , S ( A , B ) → f : A ⤖ B ) ;;
	step 4 : wff = f1of () |- ( f : A ⤖ B → f : A ⟶ B ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( f Isom R , S ( A , B ) → f : A ⟶ B ) ;;
	step 6 : wff = dmfex () |- ( ( f ∈ _V ∧ f : A ⟶ B ) → A ∈ _V ) ;;
	step 7 : wff = sylancr (step 2, step 5, step 6) |- ( f Isom R , S ( A , B ) → A ∈ _V ) ;;
	step 8 : wff = ad2antrl (step 7) |- ( ( R We A ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → A ∈ _V ) ;;
	step 9 : wff = exse () |- ( A ∈ _V → R Se A ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ( R We A ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → R Se A ) ;;
	step 11 : wff = jca (step 1, step 10) |- ( ( R We A ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → ( R We A ∧ R Se A ) ) ;;
	step 12 : wff = weisoeq () |- ( ( ( R We A ∧ R Se A ) ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → f = g ) ;;
	step 13 : wff = sylancom (step 11, step 12) |- ( ( R We A ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → f = g ) ;;
	step 14 : wff = ex (step 13) |- ( R We A → ( ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) → f = g ) ) ;;
	step 15 : wff = alrimivv (step 14) |- ( R We A → ∀ f ∀ g ( ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) → f = g ) ) ;;
	step 16 : wff = isoeq1 () |- ( f = g → ( f Isom R , S ( A , B ) ↔ g Isom R , S ( A , B ) ) ) ;;
	step 17 : wff = mo4 (step 16) |- ( ∃* f f Isom R , S ( A , B ) ↔ ∀ f ∀ g ( ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) → f = g ) ) ;;
	step 18 : wff = sylibr (step 15, step 17) |- ( R We A → ∃* f f Isom R , S ( A , B ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Thus, there is at most one isomorphism between any two well-ordered
       sets.  (Contributed by Stefan O'Rear, 12-Feb-2015.)  (Revised by Mario
       Carneiro, 25-Jun-2015.) */

theorem wemoiso2 (A : class, B : class, R : class, S : class, f : set) disjointed(R f g, A f g, S f g, B f g) {
	prop 1 : wff = |- ( S We B → ∃* f f Isom R , S ( A , B ) ) ;;
}

proof of wemoiso2 {
	var g : set;;
	step 1 : wff = simpl () |- ( ( S We B ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → S We B ) ;;
	step 2 : wff = isof1o () |- ( f Isom R , S ( A , B ) → f : A ⤖ B ) ;;
	step 3 : wff = f1ofo () |- ( f : A ⤖ B → f : A ↠ B ) ;;
	step 4 : wff = forn () |- ( f : A ↠ B → ran f = B ) ;;
	step 5 : wff = 3syl (step 2, step 3, step 4) |- ( f Isom R , S ( A , B ) → ran f = B ) ;;
	step 6 : wff = vex () |- f ∈ _V ;;
	step 7 : wff = rnex (step 6) |- ran f ∈ _V ;;
	step 8 : wff = syl6eqelr (step 5, step 7) |- ( f Isom R , S ( A , B ) → B ∈ _V ) ;;
	step 9 : wff = ad2antrl (step 8) |- ( ( S We B ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → B ∈ _V ) ;;
	step 10 : wff = exse () |- ( B ∈ _V → S Se B ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( ( S We B ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → S Se B ) ;;
	step 12 : wff = jca (step 1, step 11) |- ( ( S We B ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → ( S We B ∧ S Se B ) ) ;;
	step 13 : wff = weisoeq2 () |- ( ( ( S We B ∧ S Se B ) ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → f = g ) ;;
	step 14 : wff = sylancom (step 12, step 13) |- ( ( S We B ∧ ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) ) → f = g ) ;;
	step 15 : wff = ex (step 14) |- ( S We B → ( ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) → f = g ) ) ;;
	step 16 : wff = alrimivv (step 15) |- ( S We B → ∀ f ∀ g ( ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) → f = g ) ) ;;
	step 17 : wff = isoeq1 () |- ( f = g → ( f Isom R , S ( A , B ) ↔ g Isom R , S ( A , B ) ) ) ;;
	step 18 : wff = mo4 (step 17) |- ( ∃* f f Isom R , S ( A , B ) ↔ ∀ f ∀ g ( ( f Isom R , S ( A , B ) ∧ g Isom R , S ( A , B ) ) → f = g ) ) ;;
	step 19 : wff = sylibr (step 16, step 18) |- ( S We B → ∃* f f Isom R , S ( A , B ) ) ;;
	qed prop 1 = step 19 ;;
}

/*The Knaster-Tarski theorem says that every monotone function over a
       complete lattice has a (least) fixpoint.  Here we specialize this
       theorem to the case when the lattice is the powerset lattice ` ~P A ` .
       (Contributed by Mario Carneiro, 11-Jun-2015.) */

theorem knatar (x : set, y : set, z : set, A : class, F : class, V : class, X : class) disjointed(w x y z A, w x y z F, w V, w x y X) {
	hyp 1 : wff = |- X = ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( X ⊆ A ∧ ( F ` X ) = X ) ) ;;
}

proof of knatar {
	var w : set;;
	step 1 : wff = pwidg () |- ( A ∈ V → A ∈ Pow A ) ;;
	step 2 : wff = 3ad2ant1 (step 1) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → A ∈ Pow A ) ;;
	step 3 : wff = simp2 () |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` A ) ⊆ A ) ;;
	step 4 : wff = fveq2 () |- ( z = A → ( F ` z ) = ( F ` A ) ) ;;
	step 5 : wff = id () |- ( z = A → z = A ) ;;
	step 6 : wff = sseq12d (step 4, step 5) |- ( z = A → ( ( F ` z ) ⊆ z ↔ ( F ` A ) ⊆ A ) ) ;;
	step 7 : wff = intminss (step 6) |- ( ( A ∈ Pow A ∧ ( F ` A ) ⊆ A ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ A ) ;;
	step 8 : wff = syl2anc (step 2, step 3, step 7) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ A ) ;;
	step 9 : wff = syl5eqss (hyp 1, step 8) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → X ⊆ A ) ;;
	step 10 : wff = fveq2 () |- ( z = w → ( F ` z ) = ( F ` w ) ) ;;
	step 11 : wff = id () |- ( z = w → z = w ) ;;
	step 12 : wff = sseq12d (step 10, step 11) |- ( z = w → ( ( F ` z ) ⊆ z ↔ ( F ` w ) ⊆ w ) ) ;;
	step 13 : wff = intminss (step 12) |- ( ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ w ) ;;
	step 14 : wff = adantl (step 13) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ w ) ;;
	step 15 : wff = syl5eqss (hyp 1, step 14) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → X ⊆ w ) ;;
	step 16 : wff = vex () |- w ∈ _V ;;
	step 17 : wff = elpw2 (step 16) |- ( X ∈ Pow w ↔ X ⊆ w ) ;;
	step 18 : wff = sylibr (step 15, step 17) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → X ∈ Pow w ) ;;
	step 19 : wff = simprl () |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → w ∈ Pow A ) ;;
	step 20 : wff = simpl3 () |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ;;
	step 21 : wff = pweq () |- ( x = w → Pow x = Pow w ) ;;
	step 22 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 23 : wff = sseq2d (step 22) |- ( x = w → ( ( F ` y ) ⊆ ( F ` x ) ↔ ( F ` y ) ⊆ ( F ` w ) ) ) ;;
	step 24 : wff = raleqbidv (step 21, step 23) |- ( x = w → ( ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ↔ ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) ) ) ;;
	step 25 : wff = rspcv (step 24) |- ( w ∈ Pow A → ( ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) → ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) ) ) ;;
	step 26 : wff = sylc (step 19, step 20, step 25) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) ) ;;
	step 27 : wff = fveq2 () |- ( y = X → ( F ` y ) = ( F ` X ) ) ;;
	step 28 : wff = sseq1d (step 27) |- ( y = X → ( ( F ` y ) ⊆ ( F ` w ) ↔ ( F ` X ) ⊆ ( F ` w ) ) ) ;;
	step 29 : wff = rspcv (step 28) |- ( X ∈ Pow w → ( ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) → ( F ` X ) ⊆ ( F ` w ) ) ) ;;
	step 30 : wff = sylc (step 18, step 26, step 29) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ( F ` X ) ⊆ ( F ` w ) ) ;;
	step 31 : wff = simprr () |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ( F ` w ) ⊆ w ) ;;
	step 32 : wff = sstrd (step 30, step 31) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ( F ` X ) ⊆ w ) ;;
	step 33 : wff = expr (step 32) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ w ∈ Pow A ) → ( ( F ` w ) ⊆ w → ( F ` X ) ⊆ w ) ) ;;
	step 34 : wff = ralrimiva (step 33) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ∀ w ∈ Pow A ( ( F ` w ) ⊆ w → ( F ` X ) ⊆ w ) ) ;;
	step 35 : wff = ssintrab () |- ( ( F ` X ) ⊆ ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ↔ ∀ w ∈ Pow A ( ( F ` w ) ⊆ w → ( F ` X ) ⊆ w ) ) ;;
	step 36 : wff = sylibr (step 34, step 35) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ⊆ ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ) ;;
	step 37 : wff = fveq2 () |- ( z = w → ( F ` z ) = ( F ` w ) ) ;;
	step 38 : wff = id () |- ( z = w → z = w ) ;;
	step 39 : wff = sseq12d (step 37, step 38) |- ( z = w → ( ( F ` z ) ⊆ z ↔ ( F ` w ) ⊆ w ) ) ;;
	step 40 : wff = cbvrabv (step 39) |- { z ∈ Pow A | ( F ` z ) ⊆ z } = { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 41 : wff = inteqi (step 40) |- ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } = ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 42 : wff = eqtri (hyp 1, step 41) |- X = ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 43 : wff = syl6sseqr (step 36, step 42) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ⊆ X ) ;;
	step 44 : wff = fveq2 () |- ( z = w → ( F ` z ) = ( F ` w ) ) ;;
	step 45 : wff = id () |- ( z = w → z = w ) ;;
	step 46 : wff = sseq12d (step 44, step 45) |- ( z = w → ( ( F ` z ) ⊆ z ↔ ( F ` w ) ⊆ w ) ) ;;
	step 47 : wff = cbvrabv (step 46) |- { z ∈ Pow A | ( F ` z ) ⊆ z } = { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 48 : wff = inteqi (step 47) |- ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } = ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 49 : wff = eqtri (hyp 1, step 48) |- X = ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 50 : wff = pwidg () |- ( A ∈ V → A ∈ Pow A ) ;;
	step 51 : wff = 3ad2ant1 (step 50) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → A ∈ Pow A ) ;;
	step 52 : wff = simp2 () |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` A ) ⊆ A ) ;;
	step 53 : wff = fveq2 () |- ( z = A → ( F ` z ) = ( F ` A ) ) ;;
	step 54 : wff = id () |- ( z = A → z = A ) ;;
	step 55 : wff = sseq12d (step 53, step 54) |- ( z = A → ( ( F ` z ) ⊆ z ↔ ( F ` A ) ⊆ A ) ) ;;
	step 56 : wff = intminss (step 55) |- ( ( A ∈ Pow A ∧ ( F ` A ) ⊆ A ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ A ) ;;
	step 57 : wff = syl2anc (step 51, step 52, step 56) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ A ) ;;
	step 58 : wff = syl5eqss (hyp 1, step 57) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → X ⊆ A ) ;;
	step 59 : wff = elpw2g () |- ( A ∈ V → ( X ∈ Pow A ↔ X ⊆ A ) ) ;;
	step 60 : wff = 3ad2ant1 (step 59) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( X ∈ Pow A ↔ X ⊆ A ) ) ;;
	step 61 : wff = mpbird (step 58, step 60) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → X ∈ Pow A ) ;;
	step 62 : wff = pwidg () |- ( A ∈ V → A ∈ Pow A ) ;;
	step 63 : wff = 3ad2ant1 (step 62) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → A ∈ Pow A ) ;;
	step 64 : wff = simp3 () |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ;;
	step 65 : wff = pweq () |- ( x = A → Pow x = Pow A ) ;;
	step 66 : wff = fveq2 () |- ( x = A → ( F ` x ) = ( F ` A ) ) ;;
	step 67 : wff = sseq2d (step 66) |- ( x = A → ( ( F ` y ) ⊆ ( F ` x ) ↔ ( F ` y ) ⊆ ( F ` A ) ) ) ;;
	step 68 : wff = raleqbidv (step 65, step 67) |- ( x = A → ( ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ↔ ∀ y ∈ Pow A ( F ` y ) ⊆ ( F ` A ) ) ) ;;
	step 69 : wff = rspcv (step 68) |- ( A ∈ Pow A → ( ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) → ∀ y ∈ Pow A ( F ` y ) ⊆ ( F ` A ) ) ) ;;
	step 70 : wff = sylc (step 63, step 64, step 69) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ∀ y ∈ Pow A ( F ` y ) ⊆ ( F ` A ) ) ;;
	step 71 : wff = fveq2 () |- ( y = X → ( F ` y ) = ( F ` X ) ) ;;
	step 72 : wff = sseq1d (step 71) |- ( y = X → ( ( F ` y ) ⊆ ( F ` A ) ↔ ( F ` X ) ⊆ ( F ` A ) ) ) ;;
	step 73 : wff = rspcv (step 72) |- ( X ∈ Pow A → ( ∀ y ∈ Pow A ( F ` y ) ⊆ ( F ` A ) → ( F ` X ) ⊆ ( F ` A ) ) ) ;;
	step 74 : wff = sylc (step 61, step 70, step 73) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ⊆ ( F ` A ) ) ;;
	step 75 : wff = simp2 () |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` A ) ⊆ A ) ;;
	step 76 : wff = sstrd (step 74, step 75) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ⊆ A ) ;;
	step 77 : wff = fvex () |- ( F ` X ) ∈ _V ;;
	step 78 : wff = elpw (step 77) |- ( ( F ` X ) ∈ Pow A ↔ ( F ` X ) ⊆ A ) ;;
	step 79 : wff = sylibr (step 76, step 78) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ∈ Pow A ) ;;
	step 80 : wff = fveq2 () |- ( z = w → ( F ` z ) = ( F ` w ) ) ;;
	step 81 : wff = id () |- ( z = w → z = w ) ;;
	step 82 : wff = sseq12d (step 80, step 81) |- ( z = w → ( ( F ` z ) ⊆ z ↔ ( F ` w ) ⊆ w ) ) ;;
	step 83 : wff = intminss (step 82) |- ( ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ w ) ;;
	step 84 : wff = adantl (step 83) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ w ) ;;
	step 85 : wff = syl5eqss (hyp 1, step 84) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → X ⊆ w ) ;;
	step 86 : wff = vex () |- w ∈ _V ;;
	step 87 : wff = elpw2 (step 86) |- ( X ∈ Pow w ↔ X ⊆ w ) ;;
	step 88 : wff = sylibr (step 85, step 87) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → X ∈ Pow w ) ;;
	step 89 : wff = simprl () |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → w ∈ Pow A ) ;;
	step 90 : wff = simpl3 () |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ;;
	step 91 : wff = pweq () |- ( x = w → Pow x = Pow w ) ;;
	step 92 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 93 : wff = sseq2d (step 92) |- ( x = w → ( ( F ` y ) ⊆ ( F ` x ) ↔ ( F ` y ) ⊆ ( F ` w ) ) ) ;;
	step 94 : wff = raleqbidv (step 91, step 93) |- ( x = w → ( ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ↔ ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) ) ) ;;
	step 95 : wff = rspcv (step 94) |- ( w ∈ Pow A → ( ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) → ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) ) ) ;;
	step 96 : wff = sylc (step 89, step 90, step 95) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) ) ;;
	step 97 : wff = fveq2 () |- ( y = X → ( F ` y ) = ( F ` X ) ) ;;
	step 98 : wff = sseq1d (step 97) |- ( y = X → ( ( F ` y ) ⊆ ( F ` w ) ↔ ( F ` X ) ⊆ ( F ` w ) ) ) ;;
	step 99 : wff = rspcv (step 98) |- ( X ∈ Pow w → ( ∀ y ∈ Pow w ( F ` y ) ⊆ ( F ` w ) → ( F ` X ) ⊆ ( F ` w ) ) ) ;;
	step 100 : wff = sylc (step 88, step 96, step 99) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ( F ` X ) ⊆ ( F ` w ) ) ;;
	step 101 : wff = simprr () |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ( F ` w ) ⊆ w ) ;;
	step 102 : wff = sstrd (step 100, step 101) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ ( w ∈ Pow A ∧ ( F ` w ) ⊆ w ) ) → ( F ` X ) ⊆ w ) ;;
	step 103 : wff = expr (step 102) |- ( ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ∧ w ∈ Pow A ) → ( ( F ` w ) ⊆ w → ( F ` X ) ⊆ w ) ) ;;
	step 104 : wff = ralrimiva (step 103) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ∀ w ∈ Pow A ( ( F ` w ) ⊆ w → ( F ` X ) ⊆ w ) ) ;;
	step 105 : wff = ssintrab () |- ( ( F ` X ) ⊆ ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ↔ ∀ w ∈ Pow A ( ( F ` w ) ⊆ w → ( F ` X ) ⊆ w ) ) ;;
	step 106 : wff = sylibr (step 104, step 105) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ⊆ ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ) ;;
	step 107 : wff = fveq2 () |- ( z = w → ( F ` z ) = ( F ` w ) ) ;;
	step 108 : wff = id () |- ( z = w → z = w ) ;;
	step 109 : wff = sseq12d (step 107, step 108) |- ( z = w → ( ( F ` z ) ⊆ z ↔ ( F ` w ) ⊆ w ) ) ;;
	step 110 : wff = cbvrabv (step 109) |- { z ∈ Pow A | ( F ` z ) ⊆ z } = { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 111 : wff = inteqi (step 110) |- ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } = ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 112 : wff = eqtri (hyp 1, step 111) |- X = ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ;;
	step 113 : wff = syl6sseqr (step 106, step 112) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ⊆ X ) ;;
	step 114 : wff = fvex () |- ( F ` X ) ∈ _V ;;
	step 115 : wff = elpw (step 114) |- ( ( F ` X ) ∈ Pow X ↔ ( F ` X ) ⊆ X ) ;;
	step 116 : wff = sylibr (step 113, step 115) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) ∈ Pow X ) ;;
	step 117 : wff = pwidg () |- ( A ∈ V → A ∈ Pow A ) ;;
	step 118 : wff = 3ad2ant1 (step 117) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → A ∈ Pow A ) ;;
	step 119 : wff = simp2 () |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` A ) ⊆ A ) ;;
	step 120 : wff = fveq2 () |- ( z = A → ( F ` z ) = ( F ` A ) ) ;;
	step 121 : wff = id () |- ( z = A → z = A ) ;;
	step 122 : wff = sseq12d (step 120, step 121) |- ( z = A → ( ( F ` z ) ⊆ z ↔ ( F ` A ) ⊆ A ) ) ;;
	step 123 : wff = intminss (step 122) |- ( ( A ∈ Pow A ∧ ( F ` A ) ⊆ A ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ A ) ;;
	step 124 : wff = syl2anc (step 118, step 119, step 123) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ⋂ { z ∈ Pow A | ( F ` z ) ⊆ z } ⊆ A ) ;;
	step 125 : wff = syl5eqss (hyp 1, step 124) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → X ⊆ A ) ;;
	step 126 : wff = elpw2g () |- ( A ∈ V → ( X ∈ Pow A ↔ X ⊆ A ) ) ;;
	step 127 : wff = 3ad2ant1 (step 126) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( X ∈ Pow A ↔ X ⊆ A ) ) ;;
	step 128 : wff = mpbird (step 125, step 127) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → X ∈ Pow A ) ;;
	step 129 : wff = simp3 () |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) ;;
	step 130 : wff = pweq () |- ( x = X → Pow x = Pow X ) ;;
	step 131 : wff = fveq2 () |- ( x = X → ( F ` x ) = ( F ` X ) ) ;;
	step 132 : wff = sseq2d (step 131) |- ( x = X → ( ( F ` y ) ⊆ ( F ` x ) ↔ ( F ` y ) ⊆ ( F ` X ) ) ) ;;
	step 133 : wff = raleqbidv (step 130, step 132) |- ( x = X → ( ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ↔ ∀ y ∈ Pow X ( F ` y ) ⊆ ( F ` X ) ) ) ;;
	step 134 : wff = rspcv (step 133) |- ( X ∈ Pow A → ( ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) → ∀ y ∈ Pow X ( F ` y ) ⊆ ( F ` X ) ) ) ;;
	step 135 : wff = sylc (step 128, step 129, step 134) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ∀ y ∈ Pow X ( F ` y ) ⊆ ( F ` X ) ) ;;
	step 136 : wff = fveq2 () |- ( y = ( F ` X ) → ( F ` y ) = ( F ` ( F ` X ) ) ) ;;
	step 137 : wff = sseq1d (step 136) |- ( y = ( F ` X ) → ( ( F ` y ) ⊆ ( F ` X ) ↔ ( F ` ( F ` X ) ) ⊆ ( F ` X ) ) ) ;;
	step 138 : wff = rspcv (step 137) |- ( ( F ` X ) ∈ Pow X → ( ∀ y ∈ Pow X ( F ` y ) ⊆ ( F ` X ) → ( F ` ( F ` X ) ) ⊆ ( F ` X ) ) ) ;;
	step 139 : wff = sylc (step 116, step 135, step 138) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` ( F ` X ) ) ⊆ ( F ` X ) ) ;;
	step 140 : wff = fveq2 () |- ( w = ( F ` X ) → ( F ` w ) = ( F ` ( F ` X ) ) ) ;;
	step 141 : wff = id () |- ( w = ( F ` X ) → w = ( F ` X ) ) ;;
	step 142 : wff = sseq12d (step 140, step 141) |- ( w = ( F ` X ) → ( ( F ` w ) ⊆ w ↔ ( F ` ( F ` X ) ) ⊆ ( F ` X ) ) ) ;;
	step 143 : wff = intminss (step 142) |- ( ( ( F ` X ) ∈ Pow A ∧ ( F ` ( F ` X ) ) ⊆ ( F ` X ) ) → ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ⊆ ( F ` X ) ) ;;
	step 144 : wff = syl2anc (step 79, step 139, step 143) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ⋂ { w ∈ Pow A | ( F ` w ) ⊆ w } ⊆ ( F ` X ) ) ;;
	step 145 : wff = syl5eqss (step 49, step 144) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → X ⊆ ( F ` X ) ) ;;
	step 146 : wff = eqssd (step 43, step 145) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( F ` X ) = X ) ;;
	step 147 : wff = jca (step 9, step 146) |- ( ( A ∈ V ∧ ( F ` A ) ⊆ A ∧ ∀ x ∈ Pow A ∀ y ∈ Pow x ( F ` y ) ⊆ ( F ` x ) ) → ( X ⊆ A ∧ ( F ` X ) = X ) ) ;;
	qed prop 1 = step 147 ;;
}


