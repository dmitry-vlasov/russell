import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Finite_induction_(for_finite_ordinals).rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                              Relations

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Introduce new constant symbols. */

constant {
	symbol × ;;
	ascii X. ;;
	latex \times ;;
}

/*Times symbol (cross product symbol) (read: 'cross') */

constant {
	symbol ⁻¹ ;;
	ascii `' ;;
	latex {}^{-1} ;;
}

/*Small elevated smiley (converse operation) */

constant {
	symbol dom ;;
}

/*Domain */

constant {
	symbol ran ;;
}

/*Range */

constant {
	symbol ↾ ;;
	ascii |` ;;
	latex \upharpoonright ;;
}

/*Right hook (restriction symbol) */

constant {
	symbol " ;;
	ascii " ;;
	latex `` ;;
}

/*Left quote (image symbol) */

constant {
	symbol ∘ ;;
	ascii o. ;;
	latex \circ ;;
}

/*Small circle (composition symbol) */

constant {
	symbol Rel ;;
}

/*Relation predicate */

/*Extend the definition of a class to include the cross product. */

rule cxp (A : class, B : class) {
	term : class = # ( A × B ) ;;
}

/*Extend the definition of a class to include the converse of a class. */

rule ccnv (A : class) {
	term : class = # ⁻¹ A ;;
}

/*Extend the definition of a class to include the domain of a class. */

rule cdm (A : class) {
	term : class = # dom A ;;
}

/*Extend the definition of a class to include the range of a class. */

rule crn (A : class) {
	term : class = # ran A ;;
}

/*Extend the definition of a class to include the restriction of a class.
     (Read:  The restriction of ` A ` to ` B ` .) */

rule cres (A : class, B : class) {
	term : class = # ( A ↾ B ) ;;
}

/*Extend the definition of a class to include the image of a class.  (Read:
     The image of ` B ` under ` A ` .) */

rule cima (A : class, B : class) {
	term : class = # ( A " B ) ;;
}

/*Extend the definition of a class to include the composition of two
     classes.  (Read:  The composition of ` A ` and ` B ` .) */

rule ccom (A : class, B : class) {
	term : class = # ( A ∘ B ) ;;
}

/*Extend the definition of a wff to include the relation predicate.  (Read:
     ` A ` is a relation.) */

rule wrel (A : class) {
	term : wff = # Rel A ;;
}

/*Define the cross product of two classes.  Definition 9.11 of [Quine]
       p. 64.  For example, ` ( { 1 , 5 } X. { 2 , 7 } ) = `
       ` ( { <. 1 , 2 >. , <. 1 , 7 >. } u. { <. 5 , 2 >. , <. 5 , 7 >. } ) `
       ( ~ ex-xp ).  Another example is that the set of rational numbers are
       defined in ~ df-q using the cross-product ` ( ZZ X. NN ) ` ; the left-
       and right-hand sides of the cross-product represent the top (integer)
       and bottom (natural) numbers of a fraction.  (Contributed by NM,
       4-Jul-1994.) */

definition df-xp (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	defiendum : class = # ( A × B ) ;;
	definiens : class = # { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the relation predicate.  Definition 6.4(1) of [TakeutiZaring]
       p. 23.  For alternate definitions, see ~ dfrel2 and ~ dfrel3 .
       (Contributed by NM, 1-Aug-1994.) */

definition df-rel (A : class) disjointed(A) {
	defiendum : wff = # Rel A ;;
	definiens : wff = # A ⊆ ( _V × _V ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define the converse of a class.  Definition 9.12 of [Quine] p. 64.  The
       converse of a binary relation swaps its arguments, i.e., if ` A e. _V `
       and ` B e. _V ` then ` ( A ``' R B <-> B R A ) ` , as proven in ~ brcnv
       (see ~ df-br and ~ df-rel for more on relations).  For example,
       ` ``' { <. 2 , 6 >. , <. 3 , 9 >. } = { <. 6 , 2 >. , <. 9 , 3 >. } `
       ( ~ ex-cnv ).  We use Quine's breve accent (smile) notation.  Like
       Quine, we use it as a prefix, which eliminates the need for
       parentheses.  Many authors use the postfix superscript "to the minus
       one."  "Converse" is Quine's terminology; some authors call it
       "inverse," especially when the argument is a function.  (Contributed by
       NM, 4-Jul-1994.) */

definition df-cnv (x : set, y : set, A : class) disjointed(x y A, x y) {
	defiendum : class = # ⁻¹ A ;;
	definiens : class = # { 〈 x , y 〉 | y A x } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the composition of two classes.  Definition 6.6(3) of
       [TakeutiZaring] p. 24.  For example, ` ( ( exp o. cos ) `` 0 ) = _e `
       ( ~ ex-co ) because ` ( cos `` 0 ) = 1 ` (see ~ cos0 ) and
       ` ( exp `` 1 ) = _e ` (see ~ df-e ).  Note that Definition 7 of [Suppes]
       p. 63 reverses ` A ` and ` B ` , uses ` /. ` instead of ` o. ` , and
       calls the operation "relative product."  (Contributed by NM,
       4-Jul-1994.) */

definition df-co (x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x y z B) {
	defiendum : class = # ( A ∘ B ) ;;
	definiens : class = # { 〈 x , y 〉 | ∃ z ( x B z ∧ z A y ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the domain of a class.  Definition 3 of [Suppes] p. 59.  For
       example, ` F = { <. 2 , 6 >. , <. 3 , 9 >. } -> dom F = { 2 , 3 } `
       ( ~ ex-dm ).  Another example is the domain of the complex arctangent,
       ` ( A e. dom arctan <-> ( A e. CC /\ A =/= -u _i /\ A =/= _i ) ) ` (for
       proof see ~ atandm ).  Contrast with range (defined in ~ df-rn ).  For
       alternate definitions see ~ dfdm2 , ~ dfdm3 , and ~ dfdm4 .  The
       notation " ` dom ` " is used by Enderton; other authors sometimes use
       script D. (Contributed by NM, 1-Aug-1994.) */

definition df-dm (x : set, y : set, A : class) disjointed(x y A, x y) {
	defiendum : class = # dom A ;;
	definiens : class = # { x | ∃ y x A y } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the range of a class.  For example,
       ` F = { <. 2 , 6 >. , <. 3 , 9 >. } -> ran F = { 6 , 9 } ` ( ~ ex-rn ).
       Contrast with domain (defined in ~ df-dm ).  For alternate definitions,
       see ~ dfrn2 , ~ dfrn3 , and ~ dfrn4 .  The notation " ` ran ` " is used
       by Enderton; other authors sometimes use script R or script W.
       (Contributed by NM, 1-Aug-1994.) */

definition df-rn (A : class) disjointed(A) {
	defiendum : class = # ran A ;;
	definiens : class = # dom ⁻¹ A ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the restriction of a class.  Definition 6.6(1) of [TakeutiZaring]
       p. 24.  For example, the expression ` ( exp |`` RR ) ` (used in
       ~ reeff1 ) means "the exponential function e to the x, but the exponent
       x must be in the reals" ( ~ df-ef defines the exponential function,
       which normally allows the exponent to be a complex number).  Another
       example is that ` ( F = { <. 2 , 6 >. , <. 3 , 9 >. } `
       ` /\ B = { 1 , 2 } ) -> ( F |`` B ) = { <. 2 , 6 >. } ` ( ~ ex-res ).
       (Contributed by NM, 2-Aug-1994.) */

definition df-res (A : class, B : class) disjointed(A, B) {
	defiendum : class = # ( A ↾ B ) ;;
	definiens : class = # ( A ∩ ( B × _V ) ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Define the image of a class (as restricted by another class).
       Definition 6.6(2) of [TakeutiZaring] p. 24.  For example,
` ( F = { <. 2 , 6 >. , <. 3 , 9 >. } /\ B = { 1 , 2 } ) -> ( F " B ) = { 6 } `
       ( ~ ex-ima ).  Contrast with restriction ( ~ df-res ) and range
       ( ~ df-rn ).  For an alternate definition, see ~ dfima2 .  (Contributed
       by NM, 2-Aug-1994.) */

definition df-ima (A : class, B : class) disjointed(A, B) {
	defiendum : class = # ( A " B ) ;;
	definiens : class = # ran ( A ↾ B ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Equality theorem for cross product.  (Contributed by NM, 4-Jul-1994.) */

theorem xpeq1 (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A = B → ( A × C ) = ( B × C ) ) ;;
}

proof of xpeq1 {
	var x : set, y : set;;
	step 1 : wff = eleq2 () |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( A = B → ( ( x ∈ A ∧ y ∈ C ) ↔ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 3 : wff = opabbidv (step 2) |- ( A = B → { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ) ;;
	step 4 : wff = df-xp () |- ( A × C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ;;
	step 5 : wff = df-xp () |- ( B × C ) = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ;;
	step 6 : wff = 3eqtr4g (step 3, step 4, step 5) |- ( A = B → ( A × C ) = ( B × C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality theorem for cross product.  (Contributed by NM, 5-Jul-1994.) */

theorem xpeq2 (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A = B → ( C × A ) = ( C × B ) ) ;;
}

proof of xpeq2 {
	var x : set, y : set;;
	step 1 : wff = eleq2 () |- ( A = B → ( y ∈ A ↔ y ∈ B ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( A = B → ( ( x ∈ C ∧ y ∈ A ) ↔ ( x ∈ C ∧ y ∈ B ) ) ) ;;
	step 3 : wff = opabbidv (step 2) |- ( A = B → { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ A ) } = { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ B ) } ) ;;
	step 4 : wff = df-xp () |- ( C × A ) = { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ A ) } ;;
	step 5 : wff = df-xp () |- ( C × B ) = { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ B ) } ;;
	step 6 : wff = 3eqtr4g (step 3, step 4, step 5) |- ( A = B → ( C × A ) = ( C × B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Membership in a cross product.  Uses fewer axioms than ~ elxp .
       (Contributed by NM, 4-Jul-1994.) */

theorem elxpi (x : set, y : set, A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) → ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
}

proof of elxpi {
	var z : set;;
	step 1 : wff = eqeq1 () |- ( z = A → ( z = 〈 x , y 〉 ↔ A = 〈 x , y 〉 ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( z = A → ( ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 3 : wff = 2exbidv (step 2) |- ( z = A → ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 4 : wff = elabg (step 3) |- ( A ∈ { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) } → ( A ∈ { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 5 : wff = ibi (step 4) |- ( A ∈ { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) } → ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 6 : wff = df-xp () |- ( B × C ) = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ;;
	step 7 : wff = df-opab () |- { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) } ;;
	step 8 : wff = eqtri (step 6, step 7) |- ( B × C ) = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) } ;;
	step 9 : wff = eleq2s (step 5, step 8) |- ( A ∈ ( B × C ) → ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Membership in a cross product.  (Contributed by NM, 4-Jul-1994.) */

theorem elxp (x : set, y : set, A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
}

proof of elxp {
	step 1 : wff = df-xp () |- ( B × C ) = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ;;
	step 2 : wff = eleq2i (step 1) |- ( A ∈ ( B × C ) ↔ A ∈ { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ) ;;
	step 3 : wff = elopab () |- ( A ∈ { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Membership in a cross product.  (Contributed by NM, 23-Feb-2004.) */

theorem elxp2 (x : set, y : set, A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ∃ x ∈ B ∃ y ∈ C A = 〈 x , y 〉 ) ;;
}

proof of elxp2 {
	step 1 : wff = df-rex () |- ( ∃ y ∈ C ( x ∈ B ∧ A = 〈 x , y 〉 ) ↔ ∃ y ( y ∈ C ∧ ( x ∈ B ∧ A = 〈 x , y 〉 ) ) ) ;;
	step 2 : wff = r19.42v () |- ( ∃ y ∈ C ( x ∈ B ∧ A = 〈 x , y 〉 ) ↔ ( x ∈ B ∧ ∃ y ∈ C A = 〈 x , y 〉 ) ) ;;
	step 3 : wff = an13 () |- ( ( y ∈ C ∧ ( x ∈ B ∧ A = 〈 x , y 〉 ) ) ↔ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ( y ∈ C ∧ ( x ∈ B ∧ A = 〈 x , y 〉 ) ) ↔ ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 5 : wff = 3bitr3i (step 1, step 2, step 4) |- ( ( x ∈ B ∧ ∃ y ∈ C A = 〈 x , y 〉 ) ↔ ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ x ( x ∈ B ∧ ∃ y ∈ C A = 〈 x , y 〉 ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 7 : wff = df-rex () |- ( ∃ x ∈ B ∃ y ∈ C A = 〈 x , y 〉 ↔ ∃ x ( x ∈ B ∧ ∃ y ∈ C A = 〈 x , y 〉 ) ) ;;
	step 8 : wff = elxp () |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 9 : wff = 3bitr4ri (step 6, step 7, step 8) |- ( A ∈ ( B × C ) ↔ ∃ x ∈ B ∃ y ∈ C A = 〈 x , y 〉 ) ;;
	qed prop 1 = step 9 ;;
}

/*Equality theorem for cross product.  (Contributed by FL, 31-Aug-2009.) */

theorem xpeq12 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → ( A × C ) = ( B × D ) ) ;;
}

proof of xpeq12 {
	step 1 : wff = xpeq1 () |- ( A = B → ( A × C ) = ( B × C ) ) ;;
	step 2 : wff = xpeq2 () |- ( C = D → ( B × C ) = ( B × D ) ) ;;
	step 3 : wff = sylan9eq (step 1, step 2) |- ( ( A = B ∧ C = D ) → ( A × C ) = ( B × D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality inference for cross product.  (Contributed by NM,
       21-Dec-2008.) */

theorem xpeq1i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A × C ) = ( B × C ) ;;
}

proof of xpeq1i {
	step 1 : wff = xpeq1 () |- ( A = B → ( A × C ) = ( B × C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A × C ) = ( B × C ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for cross product.  (Contributed by NM,
       21-Dec-2008.) */

theorem xpeq2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C × A ) = ( C × B ) ;;
}

proof of xpeq2i {
	step 1 : wff = xpeq2 () |- ( A = B → ( C × A ) = ( C × B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C × A ) = ( C × B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for cross product.  (Contributed by FL,
       31-Aug-2009.) */

theorem xpeq12i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A × C ) = ( B × D ) ;;
}

proof of xpeq12i {
	step 1 : wff = xpeq12 () |- ( ( A = B ∧ C = D ) → ( A × C ) = ( B × D ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A × C ) = ( B × D ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for cross product.  (Contributed by Jeff Madsen,
       17-Jun-2010.) */

theorem xpeq1d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A × C ) = ( B × C ) ) ;;
}

proof of xpeq1d {
	step 1 : wff = xpeq1 () |- ( A = B → ( A × C ) = ( B × C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A × C ) = ( B × C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for cross product.  (Contributed by Jeff Madsen,
       17-Jun-2010.) */

theorem xpeq2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C × A ) = ( C × B ) ) ;;
}

proof of xpeq2d {
	step 1 : wff = xpeq2 () |- ( A = B → ( C × A ) = ( C × B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C × A ) = ( C × B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for cross product.  (Contributed by NM,
       8-Dec-2013.) */

theorem xpeq12d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A × C ) = ( B × D ) ) ;;
}

proof of xpeq12d {
	step 1 : wff = xpeq12 () |- ( ( A = B ∧ C = D ) → ( A × C ) = ( B × D ) ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → ( A × C ) = ( B × D ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for cross product.  (Contributed by
       NM, 15-Sep-2003.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nfxp (x : set, A : class, B : class) disjointed(y z A, y z B, x y z) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x ( A × B ) ;;
}

proof of nfxp {
	var y : set, z : set;;
	step 1 : wff = df-xp () |- ( A × B ) = { 〈 y , z 〉 | ( y ∈ A ∧ z ∈ B ) } ;;
	step 2 : wff = nfcri (hyp 1) |- F/ x y ∈ A ;;
	step 3 : wff = nfcri (hyp 2) |- F/ x z ∈ B ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ x ( y ∈ A ∧ z ∈ B ) ;;
	step 5 : wff = nfopab (step 4) |- F/_ x { 〈 y , z 〉 | ( y ∈ A ∧ z ∈ B ) } ;;
	step 6 : wff = nfcxfr (step 1, step 5) |- F/_ x ( A × B ) ;;
	qed prop 1 = step 6 ;;
}

/*Distribute proper substitution through the cross product of two
       classes.  (Contributed by Alan Sare, 10-Nov-2012.) */

theorem csbxpg (x : set, A : class, B : class, C : class, D : class) disjointed(A w y z, B w y z, C w y z, D w y z, w x y z) {
	prop 1 : wff = |- ( A ∈ D → [_ A / x ]_ ( B × C ) = ( [_ A / x ]_ B × [_ A / x ]_ C ) ) ;;
}

proof of csbxpg {
	var y : set, z : set, w : set;;
	step 1 : wff = csbabg () |- ( A ∈ D → [_ A / x ]_ { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } = { z | [. A / x ]. ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } ) ;;
	step 2 : wff = sbcexg () |- ( A ∈ D → ( [. A / x ]. ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ∃ w [. A / x ]. ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 3 : wff = sbcexg () |- ( A ∈ D → ( [. A / x ]. ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ∃ y [. A / x ]. ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 4 : wff = sbcang () |- ( A ∈ D → ( [. A / x ]. ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ( [. A / x ]. z = 〈 w , y 〉 ∧ [. A / x ]. ( w ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 5 : wff = sbcg () |- ( A ∈ D → ( [. A / x ]. z = 〈 w , y 〉 ↔ z = 〈 w , y 〉 ) ) ;;
	step 6 : wff = sbcang () |- ( A ∈ D → ( [. A / x ]. ( w ∈ B ∧ y ∈ C ) ↔ ( [. A / x ]. w ∈ B ∧ [. A / x ]. y ∈ C ) ) ) ;;
	step 7 : wff = sbcel2g () |- ( A ∈ D → ( [. A / x ]. w ∈ B ↔ w ∈ [_ A / x ]_ B ) ) ;;
	step 8 : wff = sbcel2g () |- ( A ∈ D → ( [. A / x ]. y ∈ C ↔ y ∈ [_ A / x ]_ C ) ) ;;
	step 9 : wff = anbi12d (step 7, step 8) |- ( A ∈ D → ( ( [. A / x ]. w ∈ B ∧ [. A / x ]. y ∈ C ) ↔ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ;;
	step 10 : wff = bitrd (step 6, step 9) |- ( A ∈ D → ( [. A / x ]. ( w ∈ B ∧ y ∈ C ) ↔ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ;;
	step 11 : wff = anbi12d (step 5, step 10) |- ( A ∈ D → ( ( [. A / x ]. z = 〈 w , y 〉 ∧ [. A / x ]. ( w ∈ B ∧ y ∈ C ) ) ↔ ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ) ;;
	step 12 : wff = bitrd (step 4, step 11) |- ( A ∈ D → ( [. A / x ]. ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ) ;;
	step 13 : wff = exbidv (step 12) |- ( A ∈ D → ( ∃ y [. A / x ]. ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ) ;;
	step 14 : wff = bitrd (step 3, step 13) |- ( A ∈ D → ( [. A / x ]. ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ) ;;
	step 15 : wff = exbidv (step 14) |- ( A ∈ D → ( ∃ w [. A / x ]. ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ) ;;
	step 16 : wff = bitrd (step 2, step 15) |- ( A ∈ D → ( [. A / x ]. ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) ↔ ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) ) ) ;;
	step 17 : wff = abbidv (step 16) |- ( A ∈ D → { z | [. A / x ]. ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } = { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) } ) ;;
	step 18 : wff = eqtrd (step 1, step 17) |- ( A ∈ D → [_ A / x ]_ { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } = { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) } ) ;;
	step 19 : wff = df-xp () |- ( B × C ) = { 〈 w , y 〉 | ( w ∈ B ∧ y ∈ C ) } ;;
	step 20 : wff = df-opab () |- { 〈 w , y 〉 | ( w ∈ B ∧ y ∈ C ) } = { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } ;;
	step 21 : wff = eqtri (step 19, step 20) |- ( B × C ) = { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } ;;
	step 22 : wff = csbeq2i (step 21) |- [_ A / x ]_ ( B × C ) = [_ A / x ]_ { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ B ∧ y ∈ C ) ) } ;;
	step 23 : wff = df-xp () |- ( [_ A / x ]_ B × [_ A / x ]_ C ) = { 〈 w , y 〉 | ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) } ;;
	step 24 : wff = df-opab () |- { 〈 w , y 〉 | ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) } = { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) } ;;
	step 25 : wff = eqtri (step 23, step 24) |- ( [_ A / x ]_ B × [_ A / x ]_ C ) = { z | ∃ w ∃ y ( z = 〈 w , y 〉 ∧ ( w ∈ [_ A / x ]_ B ∧ y ∈ [_ A / x ]_ C ) ) } ;;
	step 26 : wff = 3eqtr4g (step 18, step 22, step 25) |- ( A ∈ D → [_ A / x ]_ ( B × C ) = ( [_ A / x ]_ B × [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 26 ;;
}

/*The empty set is not a member of a cross product.  (Contributed by NM,
       2-May-1996.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem 0nelxp (A : class, B : class) disjointed(x y A, x y B, x y) {
	prop 1 : wff = |- ¬ ∅ ∈ ( A × B ) ;;
}

proof of 0nelxp {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = opnzi (step 1, step 2) |- 〈 x , y 〉 ≠ ∅ ;;
	step 4 : wff = simpl () |- ( ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → ∅ = 〈 x , y 〉 ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → 〈 x , y 〉 = ∅ ) ;;
	step 6 : wff = necon3ai (step 5) |- ( 〈 x , y 〉 ≠ ∅ → ¬ ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 7 : wff = ax-mp (step 3, step 6) |- ¬ ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 8 : wff = nex (step 7) |- ¬ ∃ y ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 9 : wff = nex (step 8) |- ¬ ∃ x ∃ y ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 10 : wff = elxp () |- ( ∅ ∈ ( A × B ) ↔ ∃ x ∃ y ( ∅ = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 11 : wff = mtbir (step 9, step 10) |- ¬ ∅ ∈ ( A × B ) ;;
	qed prop 1 = step 11 ;;
}

/*A member of a cross product (ordered pair) doesn't contain the empty
       set.  (Contributed by NM, 15-Dec-2008.) */

theorem 0nelelxp (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( C ∈ ( A × B ) → ¬ ∅ ∈ C ) ;;
}

proof of 0nelelxp {
	var x : set, y : set;;
	step 1 : wff = elxp () |- ( C ∈ ( A × B ) ↔ ∃ x ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 2 : wff = 0nelop () |- ¬ ∅ ∈ 〈 x , y 〉 ;;
	step 3 : wff = simpl () |- ( ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → C = 〈 x , y 〉 ) ;;
	step 4 : wff = eleq2d (step 3) |- ( ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → ( ∅ ∈ C ↔ ∅ ∈ 〈 x , y 〉 ) ) ;;
	step 5 : wff = mtbiri (step 2, step 4) |- ( ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → ¬ ∅ ∈ C ) ;;
	step 6 : wff = exlimivv (step 5) |- ( ∃ x ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → ¬ ∅ ∈ C ) ;;
	step 7 : wff = sylbi (step 1, step 6) |- ( C ∈ ( A × B ) → ¬ ∅ ∈ C ) ;;
	qed prop 1 = step 7 ;;
}

/*Ordered pair membership in a cross product.  (Contributed by NM,
       15-Nov-1994.)  (Proof shortened by Andrew Salmon, 12-Aug-2011.)
       (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem opelxp (A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x y C, x y D) {
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
}

proof of opelxp {
	var x : set, y : set;;
	step 1 : wff = elxp2 () |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ∃ x ∈ C ∃ y ∈ D 〈 A , B 〉 = 〈 x , y 〉 ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opth2 (step 2, step 3) |- ( 〈 A , B 〉 = 〈 x , y 〉 ↔ ( A = x ∧ B = y ) ) ;;
	step 5 : wff = eleq1 () |- ( A = x → ( A ∈ C ↔ x ∈ C ) ) ;;
	step 6 : wff = eleq1 () |- ( B = y → ( B ∈ D ↔ y ∈ D ) ) ;;
	step 7 : wff = bi2anan9 (step 5, step 6) |- ( ( A = x ∧ B = y ) → ( ( A ∈ C ∧ B ∈ D ) ↔ ( x ∈ C ∧ y ∈ D ) ) ) ;;
	step 8 : wff = sylbi (step 4, step 7) |- ( 〈 A , B 〉 = 〈 x , y 〉 → ( ( A ∈ C ∧ B ∈ D ) ↔ ( x ∈ C ∧ y ∈ D ) ) ) ;;
	step 9 : wff = biimprcd (step 8) |- ( ( x ∈ C ∧ y ∈ D ) → ( 〈 A , B 〉 = 〈 x , y 〉 → ( A ∈ C ∧ B ∈ D ) ) ) ;;
	step 10 : wff = rexlimivv (step 9) |- ( ∃ x ∈ C ∃ y ∈ D 〈 A , B 〉 = 〈 x , y 〉 → ( A ∈ C ∧ B ∈ D ) ) ;;
	step 11 : wff = eqid () |- 〈 A , B 〉 = 〈 A , B 〉 ;;
	step 12 : wff = opeq1 () |- ( x = A → 〈 x , y 〉 = 〈 A , y 〉 ) ;;
	step 13 : wff = eqeq2d (step 12) |- ( x = A → ( 〈 A , B 〉 = 〈 x , y 〉 ↔ 〈 A , B 〉 = 〈 A , y 〉 ) ) ;;
	step 14 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 15 : wff = eqeq2d (step 14) |- ( y = B → ( 〈 A , B 〉 = 〈 A , y 〉 ↔ 〈 A , B 〉 = 〈 A , B 〉 ) ) ;;
	step 16 : wff = rspc2ev (step 13, step 15) |- ( ( A ∈ C ∧ B ∈ D ∧ 〈 A , B 〉 = 〈 A , B 〉 ) → ∃ x ∈ C ∃ y ∈ D 〈 A , B 〉 = 〈 x , y 〉 ) ;;
	step 17 : wff = mp3an3 (step 11, step 16) |- ( ( A ∈ C ∧ B ∈ D ) → ∃ x ∈ C ∃ y ∈ D 〈 A , B 〉 = 〈 x , y 〉 ) ;;
	step 18 : wff = impbii (step 10, step 17) |- ( ∃ x ∈ C ∃ y ∈ D 〈 A , B 〉 = 〈 x , y 〉 ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 19 : wff = bitri (step 1, step 18) |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	qed prop 1 = step 19 ;;
}

/*Binary relation on a cross product.  (Contributed by NM,
       22-Apr-2004.) */

theorem brxp (A : class, B : class, C : class, D : class) disjointed(A, B, C, D) {
	prop 1 : wff = |- ( A ( C × D ) B ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
}

proof of brxp {
	step 1 : wff = df-br () |- ( A ( C × D ) B ↔ 〈 A , B 〉 ∈ ( C × D ) ) ;;
	step 2 : wff = opelxp () |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A ( C × D ) B ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Ordered pair membership in a cross product (implication).  (Contributed by
     NM, 28-May-1995.) */

theorem opelxpi (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → 〈 A , B 〉 ∈ ( C × D ) ) ;;
}

proof of opelxpi {
	step 1 : wff = opelxp () |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 2 : wff = biimpri (step 1) |- ( ( A ∈ C ∧ B ∈ D ) → 〈 A , B 〉 ∈ ( C × D ) ) ;;
	qed prop 1 = step 2 ;;
}

/*The first member of an ordered pair of classes in a cross product belongs
     to first cross product argument.  (Contributed by NM, 28-May-2008.)
     (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem opelxp1 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ ( C × D ) → A ∈ C ) ;;
}

proof of opelxp1 {
	step 1 : wff = opelxp () |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( 〈 A , B 〉 ∈ ( C × D ) → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*The second member of an ordered pair of classes in a cross product belongs
     to second cross product argument.  (Contributed by Mario Carneiro,
     26-Apr-2015.) */

theorem opelxp2 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ ( C × D ) → B ∈ D ) ;;
}

proof of opelxp2 {
	step 1 : wff = opelxp () |- ( 〈 A , B 〉 ∈ ( C × D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( 〈 A , B 〉 ∈ ( C × D ) → B ∈ D ) ;;
	qed prop 1 = step 2 ;;
}

/*The first member of an ordered triple of classes in a cross product
     belongs to first cross product argument.  (Contributed by NM,
     28-May-2008.) */

theorem otelxp1 (A : class, B : class, C : class, R : class, S : class, T : class)  {
	prop 1 : wff = |- ( 〈 〈 A , B 〉 , C 〉 ∈ ( ( R × S ) × T ) → A ∈ R ) ;;
}

proof of otelxp1 {
	step 1 : wff = opelxp1 () |- ( 〈 〈 A , B 〉 , C 〉 ∈ ( ( R × S ) × T ) → 〈 A , B 〉 ∈ ( R × S ) ) ;;
	step 2 : wff = opelxp1 () |- ( 〈 A , B 〉 ∈ ( R × S ) → A ∈ R ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( 〈 〈 A , B 〉 , C 〉 ∈ ( ( R × S ) × T ) → A ∈ R ) ;;
	qed prop 1 = step 3 ;;
}

/*Membership in a class builder restricted to a cross product.
       (Contributed by NM, 20-Feb-2014.) */

theorem rabxp (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x y z B, y z ph, x ps) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { x ∈ ( A × B ) | ph } = { 〈 y , z 〉 | ( y ∈ A ∧ z ∈ B ∧ ps ) } ;;
}

proof of rabxp {
	step 1 : wff = elxp () |- ( x ∈ ( A × B ) ↔ ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ) ;;
	step 2 : wff = anbi1i (step 1) |- ( ( x ∈ ( A × B ) ∧ ph ) ↔ ( ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ∧ ph ) ) ;;
	step 3 : wff = 19.41vv () |- ( ∃ y ∃ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ∧ ph ) ↔ ( ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ∧ ph ) ) ;;
	step 4 : wff = anass () |- ( ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ∧ ph ) ↔ ( x = 〈 y , z 〉 ∧ ( ( y ∈ A ∧ z ∈ B ) ∧ ph ) ) ) ;;
	step 5 : wff = anbi2d (hyp 1) |- ( x = 〈 y , z 〉 → ( ( ( y ∈ A ∧ z ∈ B ) ∧ ph ) ↔ ( ( y ∈ A ∧ z ∈ B ) ∧ ps ) ) ) ;;
	step 6 : wff = df-3an () |- ( ( y ∈ A ∧ z ∈ B ∧ ps ) ↔ ( ( y ∈ A ∧ z ∈ B ) ∧ ps ) ) ;;
	step 7 : wff = syl6bbr (step 5, step 6) |- ( x = 〈 y , z 〉 → ( ( ( y ∈ A ∧ z ∈ B ) ∧ ph ) ↔ ( y ∈ A ∧ z ∈ B ∧ ps ) ) ) ;;
	step 8 : wff = pm5.32i (step 7) |- ( ( x = 〈 y , z 〉 ∧ ( ( y ∈ A ∧ z ∈ B ) ∧ ph ) ) ↔ ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ∧ ps ) ) ) ;;
	step 9 : wff = bitri (step 4, step 8) |- ( ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ∧ ph ) ↔ ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ∧ ps ) ) ) ;;
	step 10 : wff = 2exbii (step 9) |- ( ∃ y ∃ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ∧ ph ) ↔ ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ∧ ps ) ) ) ;;
	step 11 : wff = 3bitr2i (step 2, step 3, step 10) |- ( ( x ∈ ( A × B ) ∧ ph ) ↔ ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ∧ ps ) ) ) ;;
	step 12 : wff = abbii (step 11) |- { x | ( x ∈ ( A × B ) ∧ ph ) } = { x | ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ∧ ps ) ) } ;;
	step 13 : wff = df-rab () |- { x ∈ ( A × B ) | ph } = { x | ( x ∈ ( A × B ) ∧ ph ) } ;;
	step 14 : wff = df-opab () |- { 〈 y , z 〉 | ( y ∈ A ∧ z ∈ B ∧ ps ) } = { x | ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ∧ ps ) ) } ;;
	step 15 : wff = 3eqtr4i (step 12, step 13, step 14) |- { x ∈ ( A × B ) | ph } = { 〈 y , z 〉 | ( y ∈ A ∧ z ∈ B ∧ ps ) } ;;
	qed prop 1 = step 15 ;;
}

/*A true binary relation on a relation implies the arguments are sets.
     (This is a property of our ordered pair definition.)  (Contributed by
     Mario Carneiro, 26-Apr-2015.) */

theorem brrelex12 (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A R B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
}

proof of brrelex12 {
	step 1 : wff = df-rel () |- ( Rel R ↔ R ⊆ ( _V × _V ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( Rel R → R ⊆ ( _V × _V ) ) ;;
	step 3 : wff = ssbrd (step 2) |- ( Rel R → ( A R B → A ( _V × _V ) B ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( Rel R ∧ A R B ) → A ( _V × _V ) B ) ;;
	step 5 : wff = brxp () |- ( A ( _V × _V ) B ↔ ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( ( Rel R ∧ A R B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	qed prop 1 = step 6 ;;
}

/*A true binary relation on a relation implies the first argument is a set.
     (This is a property of our ordered pair definition.)  (Contributed by NM,
     18-May-2004.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem brrelex (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A R B ) → A ∈ _V ) ;;
}

proof of brrelex {
	step 1 : wff = brrelex12 () |- ( ( Rel R ∧ A R B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 2 : wff = simpld (step 1) |- ( ( Rel R ∧ A R B ) → A ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/*A true binary relation on a relation implies the second argument is a
     set.  (This is a property of our ordered pair definition.)  (Contributed
     by Mario Carneiro, 26-Apr-2015.) */

theorem brrelex2 (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A R B ) → B ∈ _V ) ;;
}

proof of brrelex2 {
	step 1 : wff = brrelex12 () |- ( ( Rel R ∧ A R B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 2 : wff = simprd (step 1) |- ( ( Rel R ∧ A R B ) → B ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/*The first argument of a binary relation exists.  (An artifact of our
       ordered pair definition.)  (Contributed by NM, 4-Jun-1998.) */

theorem brrelexi (A : class, B : class, R : class)  {
	hyp 1 : wff = |- Rel R ;;
	-----------------------
	prop 1 : wff = |- ( A R B → A ∈ _V ) ;;
}

proof of brrelexi {
	step 1 : wff = brrelex () |- ( ( Rel R ∧ A R B ) → A ∈ _V ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( A R B → A ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/*The second argument of a binary relation exists.  (An artifact of our
       ordered pair definition.)  (Contributed by Mario Carneiro,
       26-Apr-2015.) */

theorem brrelex2i (A : class, B : class, R : class)  {
	hyp 1 : wff = |- Rel R ;;
	-----------------------
	prop 1 : wff = |- ( A R B → B ∈ _V ) ;;
}

proof of brrelex2i {
	step 1 : wff = brrelex2 () |- ( ( Rel R ∧ A R B ) → B ∈ _V ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( A R B → B ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/*No proper class is related to anything via any relation.  (Contributed
       by Roy F. Longton, 30-Jul-2005.) */

theorem nprrel (A : class, B : class, R : class)  {
	hyp 1 : wff = |- Rel R ;;
	hyp 2 : wff = |- ¬ A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ¬ A R B ;;
}

proof of nprrel {
	step 1 : wff = brrelexi (hyp 1) |- ( A R B → A ∈ _V ) ;;
	step 2 : wff = mto (hyp 2, step 1) |- ¬ A R B ;;
	qed prop 1 = step 2 ;;
}

/*Representation of a constant function using the mapping operation.
       (Note that ` x ` cannot appear free in ` B ` .)  (Contributed by NM,
       12-Oct-1999.)  (Revised by Mario Carneiro, 16-Nov-2013.) */

theorem fconstmpt (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A × { B } ) = ( x ∈ A ↦ B ) ;;
}

proof of fconstmpt {
	var y : set;;
	step 1 : wff = elsn () |- ( y ∈ { B } ↔ y = B ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( x ∈ A ∧ y ∈ { B } ) ↔ ( x ∈ A ∧ y = B ) ) ;;
	step 3 : wff = opabbii (step 2) |- { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ { B } ) } = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 4 : wff = df-xp () |- ( A × { B } ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ { B } ) } ;;
	step 5 : wff = df-mpt () |- ( x ∈ A ↦ B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 6 : wff = 3eqtr4i (step 3, step 4, step 5) |- ( A × { B } ) = ( x ∈ A ↦ B ) ;;
	qed prop 1 = step 6 ;;
}

/*Variable to class conversion of transitive relation.  (Contributed by
       NM, 9-Jun-1998.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem vtoclr (x : set, y : set, z : set, A : class, B : class, C : class, R : class) disjointed(x y A, y B, x y z C, x y z R) {
	hyp 1 : wff = |- Rel R ;;
	hyp 2 : wff = |- ( ( x R y ∧ y R z ) → x R z ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A R B ∧ B R C ) → A R C ) ;;
}

proof of vtoclr {
	step 1 : wff = brrelexi (hyp 1) |- ( A R B → A ∈ _V ) ;;
	step 2 : wff = brrelex2i (hyp 1) |- ( A R B → B ∈ _V ) ;;
	step 3 : wff = jca (step 1, step 2) |- ( A R B → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 4 : wff = brrelex2i (hyp 1) |- ( B R C → C ∈ _V ) ;;
	step 5 : wff = breq1 () |- ( x = A → ( x R y ↔ A R y ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( x = A → ( ( x R y ∧ y R C ) ↔ ( A R y ∧ y R C ) ) ) ;;
	step 7 : wff = breq1 () |- ( x = A → ( x R C ↔ A R C ) ) ;;
	step 8 : wff = imbi12d (step 6, step 7) |- ( x = A → ( ( ( x R y ∧ y R C ) → x R C ) ↔ ( ( A R y ∧ y R C ) → A R C ) ) ) ;;
	step 9 : wff = imbi2d (step 8) |- ( x = A → ( ( C ∈ _V → ( ( x R y ∧ y R C ) → x R C ) ) ↔ ( C ∈ _V → ( ( A R y ∧ y R C ) → A R C ) ) ) ) ;;
	step 10 : wff = breq2 () |- ( y = B → ( A R y ↔ A R B ) ) ;;
	step 11 : wff = breq1 () |- ( y = B → ( y R C ↔ B R C ) ) ;;
	step 12 : wff = anbi12d (step 10, step 11) |- ( y = B → ( ( A R y ∧ y R C ) ↔ ( A R B ∧ B R C ) ) ) ;;
	step 13 : wff = imbi1d (step 12) |- ( y = B → ( ( ( A R y ∧ y R C ) → A R C ) ↔ ( ( A R B ∧ B R C ) → A R C ) ) ) ;;
	step 14 : wff = imbi2d (step 13) |- ( y = B → ( ( C ∈ _V → ( ( A R y ∧ y R C ) → A R C ) ) ↔ ( C ∈ _V → ( ( A R B ∧ B R C ) → A R C ) ) ) ) ;;
	step 15 : wff = breq2 () |- ( z = C → ( y R z ↔ y R C ) ) ;;
	step 16 : wff = anbi2d (step 15) |- ( z = C → ( ( x R y ∧ y R z ) ↔ ( x R y ∧ y R C ) ) ) ;;
	step 17 : wff = breq2 () |- ( z = C → ( x R z ↔ x R C ) ) ;;
	step 18 : wff = imbi12d (step 16, step 17) |- ( z = C → ( ( ( x R y ∧ y R z ) → x R z ) ↔ ( ( x R y ∧ y R C ) → x R C ) ) ) ;;
	step 19 : wff = vtoclg (step 18, hyp 2) |- ( C ∈ _V → ( ( x R y ∧ y R C ) → x R C ) ) ;;
	step 20 : wff = vtocl2g (step 9, step 14, step 19) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( C ∈ _V → ( ( A R B ∧ B R C ) → A R C ) ) ) ;;
	step 21 : wff = syl2im (step 3, step 4, step 20) |- ( A R B → ( B R C → ( ( A R B ∧ B R C ) → A R C ) ) ) ;;
	step 22 : wff = imp (step 21) |- ( ( A R B ∧ B R C ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 23 : wff = pm2.43i (step 22) |- ( ( A R B ∧ B R C ) → A R C ) ;;
	qed prop 1 = step 23 ;;
}

/*Ordered pair membership in the universal class of ordered pairs.
     (Contributed by Mario Carneiro, 3-May-2015.) */

theorem opelvvg (A : class, B : class, V : class, W : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → 〈 A , B 〉 ∈ ( _V × _V ) ) ;;
}

proof of opelvvg {
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = elex () |- ( B ∈ W → B ∈ _V ) ;;
	step 3 : wff = opelxpi () |- ( ( A ∈ _V ∧ B ∈ _V ) → 〈 A , B 〉 ∈ ( _V × _V ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( A ∈ V ∧ B ∈ W ) → 〈 A , B 〉 ∈ ( _V × _V ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Ordered pair membership in the universal class of ordered pairs.
       (Contributed by NM, 22-Aug-2013.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem opelvv (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- 〈 A , B 〉 ∈ ( _V × _V ) ;;
}

proof of opelvv {
	step 1 : wff = opelxpi () |- ( ( A ∈ _V ∧ B ∈ _V ) → 〈 A , B 〉 ∈ ( _V × _V ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- 〈 A , B 〉 ∈ ( _V × _V ) ;;
	qed prop 1 = step 2 ;;
}

/*Justification theorem for an ordered pair definition that works for any
       classes, including proper classes.  This is a possible definition
       implied by the footnote in [Jech] p. 78, which says, "The sophisticated
       reader will not object to our use of a pair of classes."  (Contributed
       by NM, 28-Sep-2003.) */

theorem opthprc (A : class, B : class, C : class, D : class) disjointed(x A, x B, x C, x D) {
	prop 1 : wff = |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ↔ ( A = C ∧ B = D ) ) ;;
}

proof of opthprc {
	var x : set;;
	step 1 : wff = eleq2 () |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → ( 〈 x , ∅ 〉 ∈ ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) ↔ 〈 x , ∅ 〉 ∈ ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ) ) ;;
	step 2 : wff = 0ex () |- ∅ ∈ _V ;;
	step 3 : wff = snid (step 2) |- ∅ ∈ { ∅ } ;;
	step 4 : wff = opelxp () |- ( 〈 x , ∅ 〉 ∈ ( A × { ∅ } ) ↔ ( x ∈ A ∧ ∅ ∈ { ∅ } ) ) ;;
	step 5 : wff = mpbiran2 (step 3, step 4) |- ( 〈 x , ∅ 〉 ∈ ( A × { ∅ } ) ↔ x ∈ A ) ;;
	step 6 : wff = opelxp () |- ( 〈 x , ∅ 〉 ∈ ( B × { { ∅ } } ) ↔ ( x ∈ B ∧ ∅ ∈ { { ∅ } } ) ) ;;
	step 7 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 8 : wff = 0ex () |- ∅ ∈ _V ;;
	step 9 : wff = elsnc (step 8) |- ( ∅ ∈ { { ∅ } } ↔ ∅ = { ∅ } ) ;;
	step 10 : wff = nemtbir (step 7, step 9) |- ¬ ∅ ∈ { { ∅ } } ;;
	step 11 : wff = bianfi (step 10) |- ( ∅ ∈ { { ∅ } } ↔ ( x ∈ B ∧ ∅ ∈ { { ∅ } } ) ) ;;
	step 12 : wff = bitr4i (step 6, step 11) |- ( 〈 x , ∅ 〉 ∈ ( B × { { ∅ } } ) ↔ ∅ ∈ { { ∅ } } ) ;;
	step 13 : wff = orbi12i (step 5, step 12) |- ( ( 〈 x , ∅ 〉 ∈ ( A × { ∅ } ) ∨ 〈 x , ∅ 〉 ∈ ( B × { { ∅ } } ) ) ↔ ( x ∈ A ∨ ∅ ∈ { { ∅ } } ) ) ;;
	step 14 : wff = elun () |- ( 〈 x , ∅ 〉 ∈ ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) ↔ ( 〈 x , ∅ 〉 ∈ ( A × { ∅ } ) ∨ 〈 x , ∅ 〉 ∈ ( B × { { ∅ } } ) ) ) ;;
	step 15 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 16 : wff = 0ex () |- ∅ ∈ _V ;;
	step 17 : wff = elsnc (step 16) |- ( ∅ ∈ { { ∅ } } ↔ ∅ = { ∅ } ) ;;
	step 18 : wff = nemtbir (step 15, step 17) |- ¬ ∅ ∈ { { ∅ } } ;;
	step 19 : wff = biorfi (step 18) |- ( x ∈ A ↔ ( x ∈ A ∨ ∅ ∈ { { ∅ } } ) ) ;;
	step 20 : wff = 3bitr4ri (step 13, step 14, step 19) |- ( x ∈ A ↔ 〈 x , ∅ 〉 ∈ ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) ) ;;
	step 21 : wff = 0ex () |- ∅ ∈ _V ;;
	step 22 : wff = snid (step 21) |- ∅ ∈ { ∅ } ;;
	step 23 : wff = opelxp () |- ( 〈 x , ∅ 〉 ∈ ( C × { ∅ } ) ↔ ( x ∈ C ∧ ∅ ∈ { ∅ } ) ) ;;
	step 24 : wff = mpbiran2 (step 22, step 23) |- ( 〈 x , ∅ 〉 ∈ ( C × { ∅ } ) ↔ x ∈ C ) ;;
	step 25 : wff = opelxp () |- ( 〈 x , ∅ 〉 ∈ ( D × { { ∅ } } ) ↔ ( x ∈ D ∧ ∅ ∈ { { ∅ } } ) ) ;;
	step 26 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 27 : wff = 0ex () |- ∅ ∈ _V ;;
	step 28 : wff = elsnc (step 27) |- ( ∅ ∈ { { ∅ } } ↔ ∅ = { ∅ } ) ;;
	step 29 : wff = nemtbir (step 26, step 28) |- ¬ ∅ ∈ { { ∅ } } ;;
	step 30 : wff = bianfi (step 29) |- ( ∅ ∈ { { ∅ } } ↔ ( x ∈ D ∧ ∅ ∈ { { ∅ } } ) ) ;;
	step 31 : wff = bitr4i (step 25, step 30) |- ( 〈 x , ∅ 〉 ∈ ( D × { { ∅ } } ) ↔ ∅ ∈ { { ∅ } } ) ;;
	step 32 : wff = orbi12i (step 24, step 31) |- ( ( 〈 x , ∅ 〉 ∈ ( C × { ∅ } ) ∨ 〈 x , ∅ 〉 ∈ ( D × { { ∅ } } ) ) ↔ ( x ∈ C ∨ ∅ ∈ { { ∅ } } ) ) ;;
	step 33 : wff = elun () |- ( 〈 x , ∅ 〉 ∈ ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ↔ ( 〈 x , ∅ 〉 ∈ ( C × { ∅ } ) ∨ 〈 x , ∅ 〉 ∈ ( D × { { ∅ } } ) ) ) ;;
	step 34 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 35 : wff = 0ex () |- ∅ ∈ _V ;;
	step 36 : wff = elsnc (step 35) |- ( ∅ ∈ { { ∅ } } ↔ ∅ = { ∅ } ) ;;
	step 37 : wff = nemtbir (step 34, step 36) |- ¬ ∅ ∈ { { ∅ } } ;;
	step 38 : wff = biorfi (step 37) |- ( x ∈ C ↔ ( x ∈ C ∨ ∅ ∈ { { ∅ } } ) ) ;;
	step 39 : wff = 3bitr4ri (step 32, step 33, step 38) |- ( x ∈ C ↔ 〈 x , ∅ 〉 ∈ ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ) ;;
	step 40 : wff = 3bitr4g (step 1, step 20, step 39) |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → ( x ∈ A ↔ x ∈ C ) ) ;;
	step 41 : wff = eqrdv (step 40) |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → A = C ) ;;
	step 42 : wff = eleq2 () |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → ( 〈 x , { ∅ } 〉 ∈ ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) ↔ 〈 x , { ∅ } 〉 ∈ ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ) ) ;;
	step 43 : wff = opelxp () |- ( 〈 x , { ∅ } 〉 ∈ ( A × { ∅ } ) ↔ ( x ∈ A ∧ { ∅ } ∈ { ∅ } ) ) ;;
	step 44 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 45 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 46 : wff = elsnc (step 45) |- ( { ∅ } ∈ { ∅ } ↔ { ∅ } = ∅ ) ;;
	step 47 : wff = eqcom () |- ( { ∅ } = ∅ ↔ ∅ = { ∅ } ) ;;
	step 48 : wff = bitri (step 46, step 47) |- ( { ∅ } ∈ { ∅ } ↔ ∅ = { ∅ } ) ;;
	step 49 : wff = nemtbir (step 44, step 48) |- ¬ { ∅ } ∈ { ∅ } ;;
	step 50 : wff = bianfi (step 49) |- ( { ∅ } ∈ { ∅ } ↔ ( x ∈ A ∧ { ∅ } ∈ { ∅ } ) ) ;;
	step 51 : wff = bitr4i (step 43, step 50) |- ( 〈 x , { ∅ } 〉 ∈ ( A × { ∅ } ) ↔ { ∅ } ∈ { ∅ } ) ;;
	step 52 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 53 : wff = snid (step 52) |- { ∅ } ∈ { { ∅ } } ;;
	step 54 : wff = opelxp () |- ( 〈 x , { ∅ } 〉 ∈ ( B × { { ∅ } } ) ↔ ( x ∈ B ∧ { ∅ } ∈ { { ∅ } } ) ) ;;
	step 55 : wff = mpbiran2 (step 53, step 54) |- ( 〈 x , { ∅ } 〉 ∈ ( B × { { ∅ } } ) ↔ x ∈ B ) ;;
	step 56 : wff = orbi12i (step 51, step 55) |- ( ( 〈 x , { ∅ } 〉 ∈ ( A × { ∅ } ) ∨ 〈 x , { ∅ } 〉 ∈ ( B × { { ∅ } } ) ) ↔ ( { ∅ } ∈ { ∅ } ∨ x ∈ B ) ) ;;
	step 57 : wff = elun () |- ( 〈 x , { ∅ } 〉 ∈ ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) ↔ ( 〈 x , { ∅ } 〉 ∈ ( A × { ∅ } ) ∨ 〈 x , { ∅ } 〉 ∈ ( B × { { ∅ } } ) ) ) ;;
	step 58 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 59 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 60 : wff = elsnc (step 59) |- ( { ∅ } ∈ { ∅ } ↔ { ∅ } = ∅ ) ;;
	step 61 : wff = eqcom () |- ( { ∅ } = ∅ ↔ ∅ = { ∅ } ) ;;
	step 62 : wff = bitri (step 60, step 61) |- ( { ∅ } ∈ { ∅ } ↔ ∅ = { ∅ } ) ;;
	step 63 : wff = nemtbir (step 58, step 62) |- ¬ { ∅ } ∈ { ∅ } ;;
	step 64 : wff = biorf () |- ( ¬ { ∅ } ∈ { ∅ } → ( x ∈ B ↔ ( { ∅ } ∈ { ∅ } ∨ x ∈ B ) ) ) ;;
	step 65 : wff = ax-mp (step 63, step 64) |- ( x ∈ B ↔ ( { ∅ } ∈ { ∅ } ∨ x ∈ B ) ) ;;
	step 66 : wff = 3bitr4ri (step 56, step 57, step 65) |- ( x ∈ B ↔ 〈 x , { ∅ } 〉 ∈ ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) ) ;;
	step 67 : wff = opelxp () |- ( 〈 x , { ∅ } 〉 ∈ ( C × { ∅ } ) ↔ ( x ∈ C ∧ { ∅ } ∈ { ∅ } ) ) ;;
	step 68 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 69 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 70 : wff = elsnc (step 69) |- ( { ∅ } ∈ { ∅ } ↔ { ∅ } = ∅ ) ;;
	step 71 : wff = eqcom () |- ( { ∅ } = ∅ ↔ ∅ = { ∅ } ) ;;
	step 72 : wff = bitri (step 70, step 71) |- ( { ∅ } ∈ { ∅ } ↔ ∅ = { ∅ } ) ;;
	step 73 : wff = nemtbir (step 68, step 72) |- ¬ { ∅ } ∈ { ∅ } ;;
	step 74 : wff = bianfi (step 73) |- ( { ∅ } ∈ { ∅ } ↔ ( x ∈ C ∧ { ∅ } ∈ { ∅ } ) ) ;;
	step 75 : wff = bitr4i (step 67, step 74) |- ( 〈 x , { ∅ } 〉 ∈ ( C × { ∅ } ) ↔ { ∅ } ∈ { ∅ } ) ;;
	step 76 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 77 : wff = snid (step 76) |- { ∅ } ∈ { { ∅ } } ;;
	step 78 : wff = opelxp () |- ( 〈 x , { ∅ } 〉 ∈ ( D × { { ∅ } } ) ↔ ( x ∈ D ∧ { ∅ } ∈ { { ∅ } } ) ) ;;
	step 79 : wff = mpbiran2 (step 77, step 78) |- ( 〈 x , { ∅ } 〉 ∈ ( D × { { ∅ } } ) ↔ x ∈ D ) ;;
	step 80 : wff = orbi12i (step 75, step 79) |- ( ( 〈 x , { ∅ } 〉 ∈ ( C × { ∅ } ) ∨ 〈 x , { ∅ } 〉 ∈ ( D × { { ∅ } } ) ) ↔ ( { ∅ } ∈ { ∅ } ∨ x ∈ D ) ) ;;
	step 81 : wff = elun () |- ( 〈 x , { ∅ } 〉 ∈ ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ↔ ( 〈 x , { ∅ } 〉 ∈ ( C × { ∅ } ) ∨ 〈 x , { ∅ } 〉 ∈ ( D × { { ∅ } } ) ) ) ;;
	step 82 : wff = 0nep0 () |- ∅ ≠ { ∅ } ;;
	step 83 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 84 : wff = elsnc (step 83) |- ( { ∅ } ∈ { ∅ } ↔ { ∅ } = ∅ ) ;;
	step 85 : wff = eqcom () |- ( { ∅ } = ∅ ↔ ∅ = { ∅ } ) ;;
	step 86 : wff = bitri (step 84, step 85) |- ( { ∅ } ∈ { ∅ } ↔ ∅ = { ∅ } ) ;;
	step 87 : wff = nemtbir (step 82, step 86) |- ¬ { ∅ } ∈ { ∅ } ;;
	step 88 : wff = biorf () |- ( ¬ { ∅ } ∈ { ∅ } → ( x ∈ D ↔ ( { ∅ } ∈ { ∅ } ∨ x ∈ D ) ) ) ;;
	step 89 : wff = ax-mp (step 87, step 88) |- ( x ∈ D ↔ ( { ∅ } ∈ { ∅ } ∨ x ∈ D ) ) ;;
	step 90 : wff = 3bitr4ri (step 80, step 81, step 89) |- ( x ∈ D ↔ 〈 x , { ∅ } 〉 ∈ ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ) ;;
	step 91 : wff = 3bitr4g (step 42, step 66, step 90) |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → ( x ∈ B ↔ x ∈ D ) ) ;;
	step 92 : wff = eqrdv (step 91) |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → B = D ) ;;
	step 93 : wff = jca (step 41, step 92) |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) → ( A = C ∧ B = D ) ) ;;
	step 94 : wff = xpeq1 () |- ( A = C → ( A × { ∅ } ) = ( C × { ∅ } ) ) ;;
	step 95 : wff = xpeq1 () |- ( B = D → ( B × { { ∅ } } ) = ( D × { { ∅ } } ) ) ;;
	step 96 : wff = uneq12 () |- ( ( ( A × { ∅ } ) = ( C × { ∅ } ) ∧ ( B × { { ∅ } } ) = ( D × { { ∅ } } ) ) → ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ) ;;
	step 97 : wff = syl2an (step 94, step 95, step 96) |- ( ( A = C ∧ B = D ) → ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ) ;;
	step 98 : wff = impbii (step 93, step 97) |- ( ( ( A × { ∅ } ) ∪ ( B × { { ∅ } } ) ) = ( ( C × { ∅ } ) ∪ ( D × { { ∅ } } ) ) ↔ ( A = C ∧ B = D ) ) ;;
	qed prop 1 = step 98 ;;
}

/*Two things in a binary relation belong to the relation's domain.
       (Contributed by NM, 17-May-1996.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem brel (A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- R ⊆ ( C × D ) ;;
	-----------------------
	prop 1 : wff = |- ( A R B → ( A ∈ C ∧ B ∈ D ) ) ;;
}

proof of brel {
	step 1 : wff = ssbri (hyp 1) |- ( A R B → A ( C × D ) B ) ;;
	step 2 : wff = brxp () |- ( A ( C × D ) B ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( A R B → ( A ∈ C ∧ B ∈ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Ordered pair membership in an ordered pair class abstraction.
       (Contributed by Mario Carneiro, 9-Nov-2015.) */

theorem brab2a (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class) disjointed(x y A, x y B, x y C, x y D, x y ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- R = { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( A R B ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ ps ) ) ;;
}

proof of brab2a {
	step 1 : wff = simpl () |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) → ( x ∈ C ∧ y ∈ D ) ) ;;
	step 2 : wff = ssopab2i (step 1) |- { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ⊆ { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ D ) } ;;
	step 3 : wff = df-xp () |- ( C × D ) = { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ D ) } ;;
	step 4 : wff = 3sstr4i (step 2, hyp 2, step 3) |- R ⊆ ( C × D ) ;;
	step 5 : wff = brel (step 4) |- ( A R B → ( A ∈ C ∧ B ∈ D ) ) ;;
	step 6 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 7 : wff = eleq2i (hyp 2) |- ( 〈 A , B 〉 ∈ R ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( A R B ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
	step 9 : wff = opelopab2a (hyp 1) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ps ) ) ;;
	step 10 : wff = syl5bb (step 8, step 9) |- ( ( A ∈ C ∧ B ∈ D ) → ( A R B ↔ ps ) ) ;;
	step 11 : wff = biadan2 (step 5, step 10) |- ( A R B ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ ps ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Membership in a cross product.  (Contributed by NM, 5-Mar-1995.) */

theorem elxp3 (x : set, y : set, A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) ) ;;
}

proof of elxp3 {
	step 1 : wff = elxp () |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 2 : wff = eqcom () |- ( 〈 x , y 〉 = A ↔ A = 〈 x , y 〉 ) ;;
	step 3 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( B × C ) ↔ ( x ∈ B ∧ y ∈ C ) ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) ↔ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 5 : wff = 2exbii (step 4) |- ( ∃ x ∃ y ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 6 : wff = bitr4i (step 1, step 5) |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Membership in a union of cross products.  (Contributed by Mario
       Carneiro, 29-Dec-2014.)  (Revised by Mario Carneiro, 1-Jan-2017.) */

theorem opeliunxp (x : set, A : class, B : class, C : class) disjointed(y z A, y z B, y z C, x y z) {
	prop 1 : wff = |- ( 〈 x , C 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( x ∈ A ∧ C ∈ B ) ) ;;
}

proof of opeliunxp {
	var y : set, z : set;;
	step 1 : wff = df-iun () |- ⋃_ x ∈ A ( { x } × B ) = { y | ∃ x ∈ A y ∈ ( { x } × B ) } ;;
	step 2 : wff = eleq2i (step 1) |- ( 〈 x , C 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ 〈 x , C 〉 ∈ { y | ∃ x ∈ A y ∈ ( { x } × B ) } ) ;;
	step 3 : wff = opex () |- 〈 x , C 〉 ∈ _V ;;
	step 4 : wff = df-rex () |- ( ∃ x ∈ A y ∈ ( { x } × B ) ↔ ∃ x ( x ∈ A ∧ y ∈ ( { x } × B ) ) ) ;;
	step 5 : wff = nfv () |- F/ z ( x ∈ A ∧ y ∈ ( { x } × B ) ) ;;
	step 6 : wff = nfs1v () |- F/ x [ z / x ] x ∈ A ;;
	step 7 : wff = nfcv () |- F/_ x { z } ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ B ;;
	step 9 : wff = nfxp (step 7, step 8) |- F/_ x ( { z } × [_ z / x ]_ B ) ;;
	step 10 : wff = nfcri (step 9) |- F/ x y ∈ ( { z } × [_ z / x ]_ B ) ;;
	step 11 : wff = nfan (step 6, step 10) |- F/ x ( [ z / x ] x ∈ A ∧ y ∈ ( { z } × [_ z / x ]_ B ) ) ;;
	step 12 : wff = sbequ12 () |- ( x = z → ( x ∈ A ↔ [ z / x ] x ∈ A ) ) ;;
	step 13 : wff = sneq () |- ( x = z → { x } = { z } ) ;;
	step 14 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 15 : wff = xpeq12d (step 13, step 14) |- ( x = z → ( { x } × B ) = ( { z } × [_ z / x ]_ B ) ) ;;
	step 16 : wff = eleq2d (step 15) |- ( x = z → ( y ∈ ( { x } × B ) ↔ y ∈ ( { z } × [_ z / x ]_ B ) ) ) ;;
	step 17 : wff = anbi12d (step 12, step 16) |- ( x = z → ( ( x ∈ A ∧ y ∈ ( { x } × B ) ) ↔ ( [ z / x ] x ∈ A ∧ y ∈ ( { z } × [_ z / x ]_ B ) ) ) ) ;;
	step 18 : wff = cbvex (step 5, step 11, step 17) |- ( ∃ x ( x ∈ A ∧ y ∈ ( { x } × B ) ) ↔ ∃ z ( [ z / x ] x ∈ A ∧ y ∈ ( { z } × [_ z / x ]_ B ) ) ) ;;
	step 19 : wff = bitri (step 4, step 18) |- ( ∃ x ∈ A y ∈ ( { x } × B ) ↔ ∃ z ( [ z / x ] x ∈ A ∧ y ∈ ( { z } × [_ z / x ]_ B ) ) ) ;;
	step 20 : wff = eleq1 () |- ( y = 〈 x , C 〉 → ( y ∈ ( { z } × [_ z / x ]_ B ) ↔ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ) ;;
	step 21 : wff = anbi2d (step 20) |- ( y = 〈 x , C 〉 → ( ( [ z / x ] x ∈ A ∧ y ∈ ( { z } × [_ z / x ]_ B ) ) ↔ ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ) ) ;;
	step 22 : wff = exbidv (step 21) |- ( y = 〈 x , C 〉 → ( ∃ z ( [ z / x ] x ∈ A ∧ y ∈ ( { z } × [_ z / x ]_ B ) ) ↔ ∃ z ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ) ) ;;
	step 23 : wff = syl5bb (step 19, step 22) |- ( y = 〈 x , C 〉 → ( ∃ x ∈ A y ∈ ( { x } × B ) ↔ ∃ z ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ) ) ;;
	step 24 : wff = elab (step 3, step 23) |- ( 〈 x , C 〉 ∈ { y | ∃ x ∈ A y ∈ ( { x } × B ) } ↔ ∃ z ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ) ;;
	step 25 : wff = opelxp () |- ( 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ↔ ( x ∈ { z } ∧ C ∈ [_ z / x ]_ B ) ) ;;
	step 26 : wff = anbi2i (step 25) |- ( ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ↔ ( [ z / x ] x ∈ A ∧ ( x ∈ { z } ∧ C ∈ [_ z / x ]_ B ) ) ) ;;
	step 27 : wff = an12 () |- ( ( [ z / x ] x ∈ A ∧ ( x ∈ { z } ∧ C ∈ [_ z / x ]_ B ) ) ↔ ( x ∈ { z } ∧ ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ) ) ;;
	step 28 : wff = elsn () |- ( x ∈ { z } ↔ x = z ) ;;
	step 29 : wff = eqcom () |- ( x = z ↔ z = x ) ;;
	step 30 : wff = bitri (step 28, step 29) |- ( x ∈ { z } ↔ z = x ) ;;
	step 31 : wff = anbi1i (step 30) |- ( ( x ∈ { z } ∧ ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ) ↔ ( z = x ∧ ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ) ) ;;
	step 32 : wff = 3bitri (step 26, step 27, step 31) |- ( ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ↔ ( z = x ∧ ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ) ) ;;
	step 33 : wff = exbii (step 32) |- ( ∃ z ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ↔ ∃ z ( z = x ∧ ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ) ) ;;
	step 34 : wff = vex () |- x ∈ _V ;;
	step 35 : wff = sbequ12r () |- ( z = x → ( [ z / x ] x ∈ A ↔ x ∈ A ) ) ;;
	step 36 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 37 : wff = eqcoms (step 36) |- ( z = x → B = [_ z / x ]_ B ) ;;
	step 38 : wff = eqcomd (step 37) |- ( z = x → [_ z / x ]_ B = B ) ;;
	step 39 : wff = eleq2d (step 38) |- ( z = x → ( C ∈ [_ z / x ]_ B ↔ C ∈ B ) ) ;;
	step 40 : wff = anbi12d (step 35, step 39) |- ( z = x → ( ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ↔ ( x ∈ A ∧ C ∈ B ) ) ) ;;
	step 41 : wff = ceqsexv (step 34, step 40) |- ( ∃ z ( z = x ∧ ( [ z / x ] x ∈ A ∧ C ∈ [_ z / x ]_ B ) ) ↔ ( x ∈ A ∧ C ∈ B ) ) ;;
	step 42 : wff = bitri (step 33, step 41) |- ( ∃ z ( [ z / x ] x ∈ A ∧ 〈 x , C 〉 ∈ ( { z } × [_ z / x ]_ B ) ) ↔ ( x ∈ A ∧ C ∈ B ) ) ;;
	step 43 : wff = 3bitri (step 2, step 24, step 42) |- ( 〈 x , C 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( x ∈ A ∧ C ∈ B ) ) ;;
	qed prop 1 = step 43 ;;
}

/*Distributive law for cross product over union.  Theorem 103 of [Suppes]
       p. 52.  (Contributed by NM, 12-Aug-2004.) */

theorem xpundi (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A × ( B ∪ C ) ) = ( ( A × B ) ∪ ( A × C ) ) ;;
}

proof of xpundi {
	var x : set, y : set;;
	step 1 : wff = df-xp () |- ( A × ( B ∪ C ) ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ ( B ∪ C ) ) } ;;
	step 2 : wff = df-xp () |- ( A × B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ;;
	step 3 : wff = df-xp () |- ( A × C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ;;
	step 4 : wff = uneq12i (step 2, step 3) |- ( ( A × B ) ∪ ( A × C ) ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ∪ { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ) ;;
	step 5 : wff = elun () |- ( y ∈ ( B ∪ C ) ↔ ( y ∈ B ∨ y ∈ C ) ) ;;
	step 6 : wff = anbi2i (step 5) |- ( ( x ∈ A ∧ y ∈ ( B ∪ C ) ) ↔ ( x ∈ A ∧ ( y ∈ B ∨ y ∈ C ) ) ) ;;
	step 7 : wff = andi () |- ( ( x ∈ A ∧ ( y ∈ B ∨ y ∈ C ) ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∨ ( x ∈ A ∧ y ∈ C ) ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ( x ∈ A ∧ y ∈ ( B ∪ C ) ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∨ ( x ∈ A ∧ y ∈ C ) ) ) ;;
	step 9 : wff = opabbii (step 8) |- { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ ( B ∪ C ) ) } = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∨ ( x ∈ A ∧ y ∈ C ) ) } ;;
	step 10 : wff = unopab () |- ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ∪ { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ) = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∨ ( x ∈ A ∧ y ∈ C ) ) } ;;
	step 11 : wff = eqtr4i (step 9, step 10) |- { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ ( B ∪ C ) ) } = ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ∪ { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ) ;;
	step 12 : wff = eqtr4i (step 4, step 11) |- ( ( A × B ) ∪ ( A × C ) ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ ( B ∪ C ) ) } ;;
	step 13 : wff = eqtr4i (step 1, step 12) |- ( A × ( B ∪ C ) ) = ( ( A × B ) ∪ ( A × C ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Distributive law for cross product over union.  Similar to Theorem 103
       of [Suppes] p. 52.  (Contributed by NM, 30-Sep-2002.) */

theorem xpundir (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( ( A ∪ B ) × C ) = ( ( A × C ) ∪ ( B × C ) ) ;;
}

proof of xpundir {
	var x : set, y : set;;
	step 1 : wff = df-xp () |- ( ( A ∪ B ) × C ) = { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y ∈ C ) } ;;
	step 2 : wff = df-xp () |- ( A × C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ;;
	step 3 : wff = df-xp () |- ( B × C ) = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ;;
	step 4 : wff = uneq12i (step 2, step 3) |- ( ( A × C ) ∪ ( B × C ) ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ∪ { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ) ;;
	step 5 : wff = elun () |- ( x ∈ ( A ∪ B ) ↔ ( x ∈ A ∨ x ∈ B ) ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( x ∈ ( A ∪ B ) ∧ y ∈ C ) ↔ ( ( x ∈ A ∨ x ∈ B ) ∧ y ∈ C ) ) ;;
	step 7 : wff = andir () |- ( ( ( x ∈ A ∨ x ∈ B ) ∧ y ∈ C ) ↔ ( ( x ∈ A ∧ y ∈ C ) ∨ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ( x ∈ ( A ∪ B ) ∧ y ∈ C ) ↔ ( ( x ∈ A ∧ y ∈ C ) ∨ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 9 : wff = opabbii (step 8) |- { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y ∈ C ) } = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ C ) ∨ ( x ∈ B ∧ y ∈ C ) ) } ;;
	step 10 : wff = unopab () |- ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ∪ { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ) = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ C ) ∨ ( x ∈ B ∧ y ∈ C ) ) } ;;
	step 11 : wff = eqtr4i (step 9, step 10) |- { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y ∈ C ) } = ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ∪ { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ C ) } ) ;;
	step 12 : wff = eqtr4i (step 4, step 11) |- ( ( A × C ) ∪ ( B × C ) ) = { 〈 x , y 〉 | ( x ∈ ( A ∪ B ) ∧ y ∈ C ) } ;;
	step 13 : wff = eqtr4i (step 1, step 12) |- ( ( A ∪ B ) × C ) = ( ( A × C ) ∪ ( B × C ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Distributive law for cross product over indexed union.  (Contributed by
       Mario Carneiro, 27-Apr-2014.) */

theorem xpiundi (x : set, A : class, B : class, C : class) disjointed(w y z A, w y z B, w x y z C, x) {
	prop 1 : wff = |- ( C × ⋃_ x ∈ A B ) = ⋃_ x ∈ A ( C × B ) ;;
}

proof of xpiundi {
	var y : set, z : set, w : set;;
	step 1 : wff = rexcom () |- ( ∃ w ∈ C ∃ x ∈ A ∃ y ∈ B z = 〈 w , y 〉 ↔ ∃ x ∈ A ∃ w ∈ C ∃ y ∈ B z = 〈 w , y 〉 ) ;;
	step 2 : wff = eliun () |- ( y ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A y ∈ B ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( y ∈ ⋃_ x ∈ A B ∧ z = 〈 w , y 〉 ) ↔ ( ∃ x ∈ A y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ( y ∈ ⋃_ x ∈ A B ∧ z = 〈 w , y 〉 ) ↔ ∃ y ( ∃ x ∈ A y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 5 : wff = df-rex () |- ( ∃ y ∈ ⋃_ x ∈ A B z = 〈 w , y 〉 ↔ ∃ y ( y ∈ ⋃_ x ∈ A B ∧ z = 〈 w , y 〉 ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ y ∈ B z = 〈 w , y 〉 ↔ ∃ y ( y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 7 : wff = rexbii (step 6) |- ( ∃ x ∈ A ∃ y ∈ B z = 〈 w , y 〉 ↔ ∃ x ∈ A ∃ y ( y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 8 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ y ( y ∈ B ∧ z = 〈 w , y 〉 ) ↔ ∃ y ∃ x ∈ A ( y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 9 : wff = r19.41v () |- ( ∃ x ∈ A ( y ∈ B ∧ z = 〈 w , y 〉 ) ↔ ( ∃ x ∈ A y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ y ∃ x ∈ A ( y ∈ B ∧ z = 〈 w , y 〉 ) ↔ ∃ y ( ∃ x ∈ A y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 11 : wff = 3bitri (step 7, step 8, step 10) |- ( ∃ x ∈ A ∃ y ∈ B z = 〈 w , y 〉 ↔ ∃ y ( ∃ x ∈ A y ∈ B ∧ z = 〈 w , y 〉 ) ) ;;
	step 12 : wff = 3bitr4i (step 4, step 5, step 11) |- ( ∃ y ∈ ⋃_ x ∈ A B z = 〈 w , y 〉 ↔ ∃ x ∈ A ∃ y ∈ B z = 〈 w , y 〉 ) ;;
	step 13 : wff = rexbii (step 12) |- ( ∃ w ∈ C ∃ y ∈ ⋃_ x ∈ A B z = 〈 w , y 〉 ↔ ∃ w ∈ C ∃ x ∈ A ∃ y ∈ B z = 〈 w , y 〉 ) ;;
	step 14 : wff = elxp2 () |- ( z ∈ ( C × B ) ↔ ∃ w ∈ C ∃ y ∈ B z = 〈 w , y 〉 ) ;;
	step 15 : wff = rexbii (step 14) |- ( ∃ x ∈ A z ∈ ( C × B ) ↔ ∃ x ∈ A ∃ w ∈ C ∃ y ∈ B z = 〈 w , y 〉 ) ;;
	step 16 : wff = 3bitr4i (step 1, step 13, step 15) |- ( ∃ w ∈ C ∃ y ∈ ⋃_ x ∈ A B z = 〈 w , y 〉 ↔ ∃ x ∈ A z ∈ ( C × B ) ) ;;
	step 17 : wff = elxp2 () |- ( z ∈ ( C × ⋃_ x ∈ A B ) ↔ ∃ w ∈ C ∃ y ∈ ⋃_ x ∈ A B z = 〈 w , y 〉 ) ;;
	step 18 : wff = eliun () |- ( z ∈ ⋃_ x ∈ A ( C × B ) ↔ ∃ x ∈ A z ∈ ( C × B ) ) ;;
	step 19 : wff = 3bitr4i (step 16, step 17, step 18) |- ( z ∈ ( C × ⋃_ x ∈ A B ) ↔ z ∈ ⋃_ x ∈ A ( C × B ) ) ;;
	step 20 : wff = eqriv (step 19) |- ( C × ⋃_ x ∈ A B ) = ⋃_ x ∈ A ( C × B ) ;;
	qed prop 1 = step 20 ;;
}

/*Distributive law for cross product over indexed union.  (Contributed by
       Mario Carneiro, 27-Apr-2014.) */

theorem xpiundir (x : set, A : class, B : class, C : class) disjointed(w y z A, w y z B, w x y z C, x) {
	prop 1 : wff = |- ( ⋃_ x ∈ A B × C ) = ⋃_ x ∈ A ( B × C ) ;;
}

proof of xpiundir {
	var y : set, z : set, w : set;;
	step 1 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ y ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ↔ ∃ y ∃ x ∈ A ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ y ∈ B ∃ w ∈ C z = 〈 y , w 〉 ↔ ∃ y ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ x ∈ A ∃ y ∈ B ∃ w ∈ C z = 〈 y , w 〉 ↔ ∃ x ∈ A ∃ y ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 4 : wff = eliun () |- ( y ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A y ∈ B ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( y ∈ ⋃_ x ∈ A B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ↔ ( ∃ x ∈ A y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 6 : wff = r19.41v () |- ( ∃ x ∈ A ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ↔ ( ∃ x ∈ A y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ( y ∈ ⋃_ x ∈ A B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ↔ ∃ x ∈ A ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ y ( y ∈ ⋃_ x ∈ A B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ↔ ∃ y ∃ x ∈ A ( y ∈ B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 9 : wff = 3bitr4ri (step 1, step 3, step 8) |- ( ∃ y ( y ∈ ⋃_ x ∈ A B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ↔ ∃ x ∈ A ∃ y ∈ B ∃ w ∈ C z = 〈 y , w 〉 ) ;;
	step 10 : wff = df-rex () |- ( ∃ y ∈ ⋃_ x ∈ A B ∃ w ∈ C z = 〈 y , w 〉 ↔ ∃ y ( y ∈ ⋃_ x ∈ A B ∧ ∃ w ∈ C z = 〈 y , w 〉 ) ) ;;
	step 11 : wff = elxp2 () |- ( z ∈ ( B × C ) ↔ ∃ y ∈ B ∃ w ∈ C z = 〈 y , w 〉 ) ;;
	step 12 : wff = rexbii (step 11) |- ( ∃ x ∈ A z ∈ ( B × C ) ↔ ∃ x ∈ A ∃ y ∈ B ∃ w ∈ C z = 〈 y , w 〉 ) ;;
	step 13 : wff = 3bitr4i (step 9, step 10, step 12) |- ( ∃ y ∈ ⋃_ x ∈ A B ∃ w ∈ C z = 〈 y , w 〉 ↔ ∃ x ∈ A z ∈ ( B × C ) ) ;;
	step 14 : wff = elxp2 () |- ( z ∈ ( ⋃_ x ∈ A B × C ) ↔ ∃ y ∈ ⋃_ x ∈ A B ∃ w ∈ C z = 〈 y , w 〉 ) ;;
	step 15 : wff = eliun () |- ( z ∈ ⋃_ x ∈ A ( B × C ) ↔ ∃ x ∈ A z ∈ ( B × C ) ) ;;
	step 16 : wff = 3bitr4i (step 13, step 14, step 15) |- ( z ∈ ( ⋃_ x ∈ A B × C ) ↔ z ∈ ⋃_ x ∈ A ( B × C ) ) ;;
	step 17 : wff = eqriv (step 16) |- ( ⋃_ x ∈ A B × C ) = ⋃_ x ∈ A ( B × C ) ;;
	qed prop 1 = step 17 ;;
}

/*Obsolete proof of ~ resiun2 as of 5-Apr-2016.  Distributive law for
       cross product over restriction.  (Contributed by Mario Carneiro,
       11-Nov-2014.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem resiundiOLD (x : set, A : class, B : class, F : class) disjointed(A, B, x, x F) {
	prop 1 : wff = |- ( F ↾ ⋃_ x ∈ A B ) = ⋃_ x ∈ A ( F ↾ B ) ;;
}

proof of resiundiOLD {
	step 1 : wff = xpiundir () |- ( ⋃_ x ∈ A B × _V ) = ⋃_ x ∈ A ( B × _V ) ;;
	step 2 : wff = ineq2i (step 1) |- ( F ∩ ( ⋃_ x ∈ A B × _V ) ) = ( F ∩ ⋃_ x ∈ A ( B × _V ) ) ;;
	step 3 : wff = iunin2 () |- ⋃_ x ∈ A ( F ∩ ( B × _V ) ) = ( F ∩ ⋃_ x ∈ A ( B × _V ) ) ;;
	step 4 : wff = eqtr4i (step 2, step 3) |- ( F ∩ ( ⋃_ x ∈ A B × _V ) ) = ⋃_ x ∈ A ( F ∩ ( B × _V ) ) ;;
	step 5 : wff = df-res () |- ( F ↾ ⋃_ x ∈ A B ) = ( F ∩ ( ⋃_ x ∈ A B × _V ) ) ;;
	step 6 : wff = df-res () |- ( F ↾ B ) = ( F ∩ ( B × _V ) ) ;;
	step 7 : wff = a1i (step 6) |- ( x ∈ A → ( F ↾ B ) = ( F ∩ ( B × _V ) ) ) ;;
	step 8 : wff = iuneq2i (step 7) |- ⋃_ x ∈ A ( F ↾ B ) = ⋃_ x ∈ A ( F ∩ ( B × _V ) ) ;;
	step 9 : wff = 3eqtr4i (step 4, step 5, step 8) |- ( F ↾ ⋃_ x ∈ A B ) = ⋃_ x ∈ A ( F ↾ B ) ;;
	qed prop 1 = step 9 ;;
}

/*Membership in a union of cross products when the second factor is
       constant.  (Contributed by Mario Carneiro, 29-Dec-2014.) */

theorem iunxpconst (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ⋃_ x ∈ A ( { x } × B ) = ( A × B ) ;;
}

proof of iunxpconst {
	step 1 : wff = xpiundir () |- ( ⋃_ x ∈ A { x } × B ) = ⋃_ x ∈ A ( { x } × B ) ;;
	step 2 : wff = iunid () |- ⋃_ x ∈ A { x } = A ;;
	step 3 : wff = xpeq1i (step 2) |- ( ⋃_ x ∈ A { x } × B ) = ( A × B ) ;;
	step 4 : wff = eqtr3i (step 1, step 3) |- ⋃_ x ∈ A ( { x } × B ) = ( A × B ) ;;
	qed prop 1 = step 4 ;;
}

/*The cross product of two unions.  (Contributed by NM, 12-Aug-2004.) */

theorem xpun (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A ∪ B ) × ( C ∪ D ) ) = ( ( ( A × C ) ∪ ( A × D ) ) ∪ ( ( B × C ) ∪ ( B × D ) ) ) ;;
}

proof of xpun {
	step 1 : wff = xpundi () |- ( ( A ∪ B ) × ( C ∪ D ) ) = ( ( ( A ∪ B ) × C ) ∪ ( ( A ∪ B ) × D ) ) ;;
	step 2 : wff = xpundir () |- ( ( A ∪ B ) × C ) = ( ( A × C ) ∪ ( B × C ) ) ;;
	step 3 : wff = xpundir () |- ( ( A ∪ B ) × D ) = ( ( A × D ) ∪ ( B × D ) ) ;;
	step 4 : wff = uneq12i (step 2, step 3) |- ( ( ( A ∪ B ) × C ) ∪ ( ( A ∪ B ) × D ) ) = ( ( ( A × C ) ∪ ( B × C ) ) ∪ ( ( A × D ) ∪ ( B × D ) ) ) ;;
	step 5 : wff = un4 () |- ( ( ( A × C ) ∪ ( B × C ) ) ∪ ( ( A × D ) ∪ ( B × D ) ) ) = ( ( ( A × C ) ∪ ( A × D ) ) ∪ ( ( B × C ) ∪ ( B × D ) ) ) ;;
	step 6 : wff = 3eqtri (step 1, step 4, step 5) |- ( ( A ∪ B ) × ( C ∪ D ) ) = ( ( ( A × C ) ∪ ( A × D ) ) ∪ ( ( B × C ) ∪ ( B × D ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Membership in universal class of ordered pairs.  (Contributed by NM,
       4-Jul-1994.) */

theorem elvv (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
}

proof of elvv {
	step 1 : wff = elxp () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ _V ∧ y ∈ _V ) ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = pm3.2i (step 2, step 3) |- ( x ∈ _V ∧ y ∈ _V ) ;;
	step 5 : wff = biantru (step 4) |- ( A = 〈 x , y 〉 ↔ ( A = 〈 x , y 〉 ∧ ( x ∈ _V ∧ y ∈ _V ) ) ) ;;
	step 6 : wff = 2exbii (step 5) |- ( ∃ x ∃ y A = 〈 x , y 〉 ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ _V ∧ y ∈ _V ) ) ) ;;
	step 7 : wff = bitr4i (step 1, step 6) |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	qed prop 1 = step 7 ;;
}

/*Membership in universal class of ordered triples.  (Contributed by NM,
       17-Dec-2008.) */

theorem elvvv (x : set, y : set, z : set, A : class) disjointed(w x y z A) {
	prop 1 : wff = |- ( A ∈ ( ( _V × _V ) × _V ) ↔ ∃ x ∃ y ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
}

proof of elvvv {
	var w : set;;
	step 1 : wff = elxp () |- ( A ∈ ( ( _V × _V ) × _V ) ↔ ∃ w ∃ z ( A = 〈 w , z 〉 ∧ ( w ∈ ( _V × _V ) ∧ z ∈ _V ) ) ) ;;
	step 2 : wff = anass () |- ( ( ( A = 〈 w , z 〉 ∧ w ∈ ( _V × _V ) ) ∧ z ∈ _V ) ↔ ( A = 〈 w , z 〉 ∧ ( w ∈ ( _V × _V ) ∧ z ∈ _V ) ) ) ;;
	step 3 : wff = 19.42vv () |- ( ∃ x ∃ y ( A = 〈 w , z 〉 ∧ w = 〈 x , y 〉 ) ↔ ( A = 〈 w , z 〉 ∧ ∃ x ∃ y w = 〈 x , y 〉 ) ) ;;
	step 4 : wff = ancom () |- ( ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ( A = 〈 w , z 〉 ∧ w = 〈 x , y 〉 ) ) ;;
	step 5 : wff = 2exbii (step 4) |- ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ x ∃ y ( A = 〈 w , z 〉 ∧ w = 〈 x , y 〉 ) ) ;;
	step 6 : wff = vex () |- z ∈ _V ;;
	step 7 : wff = biantru (step 6) |- ( ( A = 〈 w , z 〉 ∧ w ∈ ( _V × _V ) ) ↔ ( ( A = 〈 w , z 〉 ∧ w ∈ ( _V × _V ) ) ∧ z ∈ _V ) ) ;;
	step 8 : wff = elvv () |- ( w ∈ ( _V × _V ) ↔ ∃ x ∃ y w = 〈 x , y 〉 ) ;;
	step 9 : wff = anbi2i (step 8) |- ( ( A = 〈 w , z 〉 ∧ w ∈ ( _V × _V ) ) ↔ ( A = 〈 w , z 〉 ∧ ∃ x ∃ y w = 〈 x , y 〉 ) ) ;;
	step 10 : wff = bitr3i (step 7, step 9) |- ( ( ( A = 〈 w , z 〉 ∧ w ∈ ( _V × _V ) ) ∧ z ∈ _V ) ↔ ( A = 〈 w , z 〉 ∧ ∃ x ∃ y w = 〈 x , y 〉 ) ) ;;
	step 11 : wff = 3bitr4ri (step 3, step 5, step 10) |- ( ( ( A = 〈 w , z 〉 ∧ w ∈ ( _V × _V ) ) ∧ z ∈ _V ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ) ;;
	step 12 : wff = bitr3i (step 2, step 11) |- ( ( A = 〈 w , z 〉 ∧ ( w ∈ ( _V × _V ) ∧ z ∈ _V ) ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ) ;;
	step 13 : wff = 2exbii (step 12) |- ( ∃ w ∃ z ( A = 〈 w , z 〉 ∧ ( w ∈ ( _V × _V ) ∧ z ∈ _V ) ) ↔ ∃ w ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ) ;;
	step 14 : wff = exrot4 () |- ( ∃ x ∃ y ∃ w ∃ z ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ w ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ) ;;
	step 15 : wff = excom () |- ( ∃ w ∃ z ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ z ∃ w ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ) ;;
	step 16 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 17 : wff = opeq1 () |- ( w = 〈 x , y 〉 → 〈 w , z 〉 = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 18 : wff = eqeq2d (step 17) |- ( w = 〈 x , y 〉 → ( A = 〈 w , z 〉 ↔ A = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 19 : wff = ceqsexv (step 16, step 18) |- ( ∃ w ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ A = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 20 : wff = exbii (step 19) |- ( ∃ z ∃ w ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 21 : wff = bitri (step 15, step 20) |- ( ∃ w ∃ z ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 22 : wff = 2exbii (step 21) |- ( ∃ x ∃ y ∃ w ∃ z ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ x ∃ y ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 23 : wff = bitr3i (step 14, step 22) |- ( ∃ w ∃ z ∃ x ∃ y ( w = 〈 x , y 〉 ∧ A = 〈 w , z 〉 ) ↔ ∃ x ∃ y ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 24 : wff = bitri (step 13, step 23) |- ( ∃ w ∃ z ( A = 〈 w , z 〉 ∧ ( w ∈ ( _V × _V ) ∧ z ∈ _V ) ) ↔ ∃ x ∃ y ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 25 : wff = bitri (step 1, step 24) |- ( A ∈ ( ( _V × _V ) × _V ) ↔ ∃ x ∃ y ∃ z A = 〈 〈 x , y 〉 , z 〉 ) ;;
	qed prop 1 = step 25 ;;
}

/*An ordered pair contains its union.  (Contributed by NM,
       16-Sep-2006.) */

theorem elvvuni (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) → ⋃ A ∈ A ) ;;
}

proof of elvvuni {
	var x : set, y : set;;
	step 1 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = uniop (step 2, step 3) |- ⋃ 〈 x , y 〉 = { x , y } ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = opi2 (step 5, step 6) |- { x , y } ∈ 〈 x , y 〉 ;;
	step 8 : wff = eqeltri (step 4, step 7) |- ⋃ 〈 x , y 〉 ∈ 〈 x , y 〉 ;;
	step 9 : wff = unieq () |- ( A = 〈 x , y 〉 → ⋃ A = ⋃ 〈 x , y 〉 ) ;;
	step 10 : wff = id () |- ( A = 〈 x , y 〉 → A = 〈 x , y 〉 ) ;;
	step 11 : wff = eleq12d (step 9, step 10) |- ( A = 〈 x , y 〉 → ( ⋃ A ∈ A ↔ ⋃ 〈 x , y 〉 ∈ 〈 x , y 〉 ) ) ;;
	step 12 : wff = mpbiri (step 8, step 11) |- ( A = 〈 x , y 〉 → ⋃ A ∈ A ) ;;
	step 13 : wff = exlimivv (step 12) |- ( ∃ x ∃ y A = 〈 x , y 〉 → ⋃ A ∈ A ) ;;
	step 14 : wff = sylbi (step 1, step 13) |- ( A ∈ ( _V × _V ) → ⋃ A ∈ A ) ;;
	qed prop 1 = step 14 ;;
}

/*Intersection of binary relation with cross product.  (Contributed by NM,
     3-Mar-2007.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem brinxp2 (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( A ( R ∩ ( C × D ) ) B ↔ ( A ∈ C ∧ B ∈ D ∧ A R B ) ) ;;
}

proof of brinxp2 {
	step 1 : wff = brin () |- ( A ( R ∩ ( C × D ) ) B ↔ ( A R B ∧ A ( C × D ) B ) ) ;;
	step 2 : wff = ancom () |- ( ( A R B ∧ A ( C × D ) B ) ↔ ( A ( C × D ) B ∧ A R B ) ) ;;
	step 3 : wff = brxp () |- ( A ( C × D ) B ↔ ( A ∈ C ∧ B ∈ D ) ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( A ( C × D ) B ∧ A R B ) ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ A R B ) ) ;;
	step 5 : wff = df-3an () |- ( ( A ∈ C ∧ B ∈ D ∧ A R B ) ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ A R B ) ) ;;
	step 6 : wff = bitr4i (step 4, step 5) |- ( ( A ( C × D ) B ∧ A R B ) ↔ ( A ∈ C ∧ B ∈ D ∧ A R B ) ) ;;
	step 7 : wff = 3bitri (step 1, step 2, step 6) |- ( A ( R ∩ ( C × D ) ) B ↔ ( A ∈ C ∧ B ∈ D ∧ A R B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Intersection of binary relation with cross product.  (Contributed by NM,
     9-Mar-1997.) */

theorem brinxp (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( A R B ↔ A ( R ∩ ( C × D ) ) B ) ) ;;
}

proof of brinxp {
	step 1 : wff = brinxp2 () |- ( A ( R ∩ ( C × D ) ) B ↔ ( A ∈ C ∧ B ∈ D ∧ A R B ) ) ;;
	step 2 : wff = df-3an () |- ( ( A ∈ C ∧ B ∈ D ∧ A R B ) ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ A R B ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A ( R ∩ ( C × D ) ) B ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ A R B ) ) ;;
	step 4 : wff = baibr (step 3) |- ( ( A ∈ C ∧ B ∈ D ) → ( A R B ↔ A ( R ∩ ( C × D ) ) B ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Intersection of partial order with cross product of its field.
       (Contributed by Mario Carneiro, 10-Jul-2014.) */

theorem poinxp (A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( R Po A ↔ ( R ∩ ( A × A ) ) Po A ) ;;
}

proof of poinxp {
	var x : set, y : set, z : set;;
	step 1 : wff = simpll () |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → x ∈ A ) ;;
	step 2 : wff = simpll () |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → x ∈ A ) ;;
	step 3 : wff = brinxp () |- ( ( x ∈ A ∧ x ∈ A ) → ( x R x ↔ x ( R ∩ ( A × A ) ) x ) ) ;;
	step 4 : wff = syl2anc (step 1, step 2, step 3) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( x R x ↔ x ( R ∩ ( A × A ) ) x ) ) ;;
	step 5 : wff = notbid (step 4) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( ¬ x R x ↔ ¬ x ( R ∩ ( A × A ) ) x ) ) ;;
	step 6 : wff = brinxp () |- ( ( x ∈ A ∧ y ∈ A ) → ( x R y ↔ x ( R ∩ ( A × A ) ) y ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( x R y ↔ x ( R ∩ ( A × A ) ) y ) ) ;;
	step 8 : wff = brinxp () |- ( ( y ∈ A ∧ z ∈ A ) → ( y R z ↔ y ( R ∩ ( A × A ) ) z ) ) ;;
	step 9 : wff = adantll (step 8) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( y R z ↔ y ( R ∩ ( A × A ) ) z ) ) ;;
	step 10 : wff = anbi12d (step 7, step 9) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( ( x R y ∧ y R z ) ↔ ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) ) ) ;;
	step 11 : wff = brinxp () |- ( ( x ∈ A ∧ z ∈ A ) → ( x R z ↔ x ( R ∩ ( A × A ) ) z ) ) ;;
	step 12 : wff = adantlr (step 11) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( x R z ↔ x ( R ∩ ( A × A ) ) z ) ) ;;
	step 13 : wff = imbi12d (step 10, step 12) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( ( ( x R y ∧ y R z ) → x R z ) ↔ ( ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) → x ( R ∩ ( A × A ) ) z ) ) ) ;;
	step 14 : wff = anbi12d (step 5, step 13) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ z ∈ A ) → ( ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ¬ x ( R ∩ ( A × A ) ) x ∧ ( ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) → x ( R ∩ ( A × A ) ) z ) ) ) ) ;;
	step 15 : wff = ralbidva (step 14) |- ( ( x ∈ A ∧ y ∈ A ) → ( ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ z ∈ A ( ¬ x ( R ∩ ( A × A ) ) x ∧ ( ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) → x ( R ∩ ( A × A ) ) z ) ) ) ) ;;
	step 16 : wff = ralbidva (step 15) |- ( x ∈ A → ( ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ y ∈ A ∀ z ∈ A ( ¬ x ( R ∩ ( A × A ) ) x ∧ ( ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) → x ( R ∩ ( A × A ) ) z ) ) ) ) ;;
	step 17 : wff = ralbiia (step 16) |- ( ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x ( R ∩ ( A × A ) ) x ∧ ( ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) → x ( R ∩ ( A × A ) ) z ) ) ) ;;
	step 18 : wff = df-po () |- ( R Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 19 : wff = df-po () |- ( ( R ∩ ( A × A ) ) Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x ( R ∩ ( A × A ) ) x ∧ ( ( x ( R ∩ ( A × A ) ) y ∧ y ( R ∩ ( A × A ) ) z ) → x ( R ∩ ( A × A ) ) z ) ) ) ;;
	step 20 : wff = 3bitr4i (step 17, step 18, step 19) |- ( R Po A ↔ ( R ∩ ( A × A ) ) Po A ) ;;
	qed prop 1 = step 20 ;;
}

/*Intersection of total order with cross product of its field.
       (Contributed by Mario Carneiro, 10-Jul-2014.) */

theorem soinxp (A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( R Or A ↔ ( R ∩ ( A × A ) ) Or A ) ;;
}

proof of soinxp {
	var x : set, y : set;;
	step 1 : wff = poinxp () |- ( R Po A ↔ ( R ∩ ( A × A ) ) Po A ) ;;
	step 2 : wff = brinxp () |- ( ( x ∈ A ∧ y ∈ A ) → ( x R y ↔ x ( R ∩ ( A × A ) ) y ) ) ;;
	step 3 : wff = biidd () |- ( ( x ∈ A ∧ y ∈ A ) → ( x = y ↔ x = y ) ) ;;
	step 4 : wff = brinxp () |- ( ( y ∈ A ∧ x ∈ A ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 5 : wff = ancoms (step 4) |- ( ( x ∈ A ∧ y ∈ A ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 6 : wff = 3orbi123d (step 2, step 3, step 5) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( x R y ∨ x = y ∨ y R x ) ↔ ( x ( R ∩ ( A × A ) ) y ∨ x = y ∨ y ( R ∩ ( A × A ) ) x ) ) ) ;;
	step 7 : wff = ralbidva (step 6) |- ( x ∈ A → ( ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ↔ ∀ y ∈ A ( x ( R ∩ ( A × A ) ) y ∨ x = y ∨ y ( R ∩ ( A × A ) ) x ) ) ) ;;
	step 8 : wff = ralbiia (step 7) |- ( ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ↔ ∀ x ∈ A ∀ y ∈ A ( x ( R ∩ ( A × A ) ) y ∨ x = y ∨ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 9 : wff = anbi12i (step 1, step 8) |- ( ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ↔ ( ( R ∩ ( A × A ) ) Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x ( R ∩ ( A × A ) ) y ∨ x = y ∨ y ( R ∩ ( A × A ) ) x ) ) ) ;;
	step 10 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 11 : wff = df-so () |- ( ( R ∩ ( A × A ) ) Or A ↔ ( ( R ∩ ( A × A ) ) Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x ( R ∩ ( A × A ) ) y ∨ x = y ∨ y ( R ∩ ( A × A ) ) x ) ) ) ;;
	step 12 : wff = 3bitr4i (step 9, step 10, step 11) |- ( R Or A ↔ ( R ∩ ( A × A ) ) Or A ) ;;
	qed prop 1 = step 12 ;;
}

/*Intersection of well-founded relation with cross product of its field.
       (Contributed by Mario Carneiro, 10-Jul-2014.) */

theorem frinxp (A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( R Fr A ↔ ( R ∩ ( A × A ) ) Fr A ) ;;
}

proof of frinxp {
	var x : set, y : set, z : set;;
	step 1 : wff = ssel () |- ( z ⊆ A → ( x ∈ z → x ∈ A ) ) ;;
	step 2 : wff = ssel () |- ( z ⊆ A → ( y ∈ z → y ∈ A ) ) ;;
	step 3 : wff = anim12d (step 1, step 2) |- ( z ⊆ A → ( ( x ∈ z ∧ y ∈ z ) → ( x ∈ A ∧ y ∈ A ) ) ) ;;
	step 4 : wff = brinxp () |- ( ( y ∈ A ∧ x ∈ A ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 5 : wff = ancoms (step 4) |- ( ( x ∈ A ∧ y ∈ A ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 6 : wff = syl6 (step 3, step 5) |- ( z ⊆ A → ( ( x ∈ z ∧ y ∈ z ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ) ;;
	step 7 : wff = impl (step 6) |- ( ( ( z ⊆ A ∧ x ∈ z ) ∧ y ∈ z ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 8 : wff = notbid (step 7) |- ( ( ( z ⊆ A ∧ x ∈ z ) ∧ y ∈ z ) → ( ¬ y R x ↔ ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 9 : wff = ralbidva (step 8) |- ( ( z ⊆ A ∧ x ∈ z ) → ( ∀ y ∈ z ¬ y R x ↔ ∀ y ∈ z ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 10 : wff = rexbidva (step 9) |- ( z ⊆ A → ( ∃ x ∈ z ∀ y ∈ z ¬ y R x ↔ ∃ x ∈ z ∀ y ∈ z ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 11 : wff = adantr (step 10) |- ( ( z ⊆ A ∧ z ≠ ∅ ) → ( ∃ x ∈ z ∀ y ∈ z ¬ y R x ↔ ∃ x ∈ z ∀ y ∈ z ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 12 : wff = pm5.74i (step 11) |- ( ( ( z ⊆ A ∧ z ≠ ∅ ) → ∃ x ∈ z ∀ y ∈ z ¬ y R x ) ↔ ( ( z ⊆ A ∧ z ≠ ∅ ) → ∃ x ∈ z ∀ y ∈ z ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ z ( ( z ⊆ A ∧ z ≠ ∅ ) → ∃ x ∈ z ∀ y ∈ z ¬ y R x ) ↔ ∀ z ( ( z ⊆ A ∧ z ≠ ∅ ) → ∃ x ∈ z ∀ y ∈ z ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 14 : wff = df-fr () |- ( R Fr A ↔ ∀ z ( ( z ⊆ A ∧ z ≠ ∅ ) → ∃ x ∈ z ∀ y ∈ z ¬ y R x ) ) ;;
	step 15 : wff = df-fr () |- ( ( R ∩ ( A × A ) ) Fr A ↔ ∀ z ( ( z ⊆ A ∧ z ≠ ∅ ) → ∃ x ∈ z ∀ y ∈ z ¬ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 16 : wff = 3bitr4i (step 13, step 14, step 15) |- ( R Fr A ↔ ( R ∩ ( A × A ) ) Fr A ) ;;
	qed prop 1 = step 16 ;;
}

/*Intersection of set-like relation with cross product of its field.
       (Contributed by Mario Carneiro, 22-Jun-2015.) */

theorem seinxp (A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( R Se A ↔ ( R ∩ ( A × A ) ) Se A ) ;;
}

proof of seinxp {
	var x : set, y : set;;
	step 1 : wff = brinxp () |- ( ( y ∈ A ∧ x ∈ A ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( x ∈ A ∧ y ∈ A ) → ( y R x ↔ y ( R ∩ ( A × A ) ) x ) ) ;;
	step 3 : wff = rabbidva (step 2) |- ( x ∈ A → { y ∈ A | y R x } = { y ∈ A | y ( R ∩ ( A × A ) ) x } ) ;;
	step 4 : wff = eleq1d (step 3) |- ( x ∈ A → ( { y ∈ A | y R x } ∈ _V ↔ { y ∈ A | y ( R ∩ ( A × A ) ) x } ∈ _V ) ) ;;
	step 5 : wff = ralbiia (step 4) |- ( ∀ x ∈ A { y ∈ A | y R x } ∈ _V ↔ ∀ x ∈ A { y ∈ A | y ( R ∩ ( A × A ) ) x } ∈ _V ) ;;
	step 6 : wff = df-se () |- ( R Se A ↔ ∀ x ∈ A { y ∈ A | y R x } ∈ _V ) ;;
	step 7 : wff = df-se () |- ( ( R ∩ ( A × A ) ) Se A ↔ ∀ x ∈ A { y ∈ A | y ( R ∩ ( A × A ) ) x } ∈ _V ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( R Se A ↔ ( R ∩ ( A × A ) ) Se A ) ;;
	qed prop 1 = step 8 ;;
}

/*Intersection of well-ordering with cross product of its field.
       (Contributed by NM, 9-Mar-1997.)  (Revised by Mario Carneiro,
       10-Jul-2014.) */

theorem weinxp (A : class, R : class) disjointed(A, R) {
	prop 1 : wff = |- ( R We A ↔ ( R ∩ ( A × A ) ) We A ) ;;
}

proof of weinxp {
	step 1 : wff = frinxp () |- ( R Fr A ↔ ( R ∩ ( A × A ) ) Fr A ) ;;
	step 2 : wff = soinxp () |- ( R Or A ↔ ( R ∩ ( A × A ) ) Or A ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( R Fr A ∧ R Or A ) ↔ ( ( R ∩ ( A × A ) ) Fr A ∧ ( R ∩ ( A × A ) ) Or A ) ) ;;
	step 4 : wff = df-we () |- ( R We A ↔ ( R Fr A ∧ R Or A ) ) ;;
	step 5 : wff = df-we () |- ( ( R ∩ ( A × A ) ) We A ↔ ( ( R ∩ ( A × A ) ) Fr A ∧ ( R ∩ ( A × A ) ) Or A ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( R We A ↔ ( R ∩ ( A × A ) ) We A ) ;;
	qed prop 1 = step 6 ;;
}

/*Partial ordering of a singleton.  (Contributed by NM, 27-Apr-2009.)
       (Revised by Mario Carneiro, 23-Apr-2015.) */

theorem posn (A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( Rel R → ( R Po { A } ↔ ¬ A R A ) ) ;;
}

proof of posn {
	var x : set, y : set, z : set;;
	step 1 : wff = df-po () |- ( R Po { A } ↔ ∀ x ∈ { A } ∀ y ∈ { A } ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 2 : wff = breq2 () |- ( z = A → ( y R z ↔ y R A ) ) ;;
	step 3 : wff = anbi2d (step 2) |- ( z = A → ( ( x R y ∧ y R z ) ↔ ( x R y ∧ y R A ) ) ) ;;
	step 4 : wff = breq2 () |- ( z = A → ( x R z ↔ x R A ) ) ;;
	step 5 : wff = imbi12d (step 3, step 4) |- ( z = A → ( ( ( x R y ∧ y R z ) → x R z ) ↔ ( ( x R y ∧ y R A ) → x R A ) ) ) ;;
	step 6 : wff = anbi2d (step 5) |- ( z = A → ( ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ¬ x R x ∧ ( ( x R y ∧ y R A ) → x R A ) ) ) ) ;;
	step 7 : wff = ralsng (step 6) |- ( A ∈ _V → ( ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ¬ x R x ∧ ( ( x R y ∧ y R A ) → x R A ) ) ) ) ;;
	step 8 : wff = ralbidv (step 7) |- ( A ∈ _V → ( ∀ y ∈ { A } ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ y ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R A ) → x R A ) ) ) ) ;;
	step 9 : wff = simpl () |- ( ( x R y ∧ y R A ) → x R y ) ;;
	step 10 : wff = breq2 () |- ( y = A → ( x R y ↔ x R A ) ) ;;
	step 11 : wff = syl5ib (step 9, step 10) |- ( y = A → ( ( x R y ∧ y R A ) → x R A ) ) ;;
	step 12 : wff = biantrud (step 11) |- ( y = A → ( ¬ x R x ↔ ( ¬ x R x ∧ ( ( x R y ∧ y R A ) → x R A ) ) ) ) ;;
	step 13 : wff = bicomd (step 12) |- ( y = A → ( ( ¬ x R x ∧ ( ( x R y ∧ y R A ) → x R A ) ) ↔ ¬ x R x ) ) ;;
	step 14 : wff = ralsng (step 13) |- ( A ∈ _V → ( ∀ y ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R A ) → x R A ) ) ↔ ¬ x R x ) ) ;;
	step 15 : wff = bitrd (step 8, step 14) |- ( A ∈ _V → ( ∀ y ∈ { A } ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ¬ x R x ) ) ;;
	step 16 : wff = ralbidv (step 15) |- ( A ∈ _V → ( ∀ x ∈ { A } ∀ y ∈ { A } ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∈ { A } ¬ x R x ) ) ;;
	step 17 : wff = breq12 () |- ( ( x = A ∧ x = A ) → ( x R x ↔ A R A ) ) ;;
	step 18 : wff = anidms (step 17) |- ( x = A → ( x R x ↔ A R A ) ) ;;
	step 19 : wff = notbid (step 18) |- ( x = A → ( ¬ x R x ↔ ¬ A R A ) ) ;;
	step 20 : wff = ralsng (step 19) |- ( A ∈ _V → ( ∀ x ∈ { A } ¬ x R x ↔ ¬ A R A ) ) ;;
	step 21 : wff = bitrd (step 16, step 20) |- ( A ∈ _V → ( ∀ x ∈ { A } ∀ y ∈ { A } ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ¬ A R A ) ) ;;
	step 22 : wff = adantl (step 21) |- ( ( Rel R ∧ A ∈ _V ) → ( ∀ x ∈ { A } ∀ y ∈ { A } ∀ z ∈ { A } ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ¬ A R A ) ) ;;
	step 23 : wff = syl5bb (step 1, step 22) |- ( ( Rel R ∧ A ∈ _V ) → ( R Po { A } ↔ ¬ A R A ) ) ;;
	step 24 : wff = po0 () |- R Po ∅ ;;
	step 25 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 26 : wff = poeq2 () |- ( { A } = ∅ → ( R Po { A } ↔ R Po ∅ ) ) ;;
	step 27 : wff = sylbi (step 25, step 26) |- ( ¬ A ∈ _V → ( R Po { A } ↔ R Po ∅ ) ) ;;
	step 28 : wff = mpbiri (step 24, step 27) |- ( ¬ A ∈ _V → R Po { A } ) ;;
	step 29 : wff = adantl (step 28) |- ( ( Rel R ∧ ¬ A ∈ _V ) → R Po { A } ) ;;
	step 30 : wff = brrelex () |- ( ( Rel R ∧ A R A ) → A ∈ _V ) ;;
	step 31 : wff = ex (step 30) |- ( Rel R → ( A R A → A ∈ _V ) ) ;;
	step 32 : wff = con3and (step 31) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ¬ A R A ) ;;
	step 33 : wff = 2thd (step 29, step 32) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ( R Po { A } ↔ ¬ A R A ) ) ;;
	step 34 : wff = pm2.61dan (step 23, step 33) |- ( Rel R → ( R Po { A } ↔ ¬ A R A ) ) ;;
	qed prop 1 = step 34 ;;
}

/*Strict ordering on a singleton.  (Contributed by Mario Carneiro,
       28-Dec-2014.) */

theorem sosn (A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( Rel R → ( R Or { A } ↔ ¬ A R A ) ) ;;
}

proof of sosn {
	var x : set, y : set;;
	step 1 : wff = elsni () |- ( x ∈ { A } → x = A ) ;;
	step 2 : wff = elsni () |- ( y ∈ { A } → y = A ) ;;
	step 3 : wff = eqcomd (step 2) |- ( y ∈ { A } → A = y ) ;;
	step 4 : wff = sylan9eq (step 1, step 3) |- ( ( x ∈ { A } ∧ y ∈ { A } ) → x = y ) ;;
	step 5 : wff = 3mix2 () |- ( x = y → ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ( x ∈ { A } ∧ y ∈ { A } ) → ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 7 : wff = rgen2a (step 6) |- ∀ x ∈ { A } ∀ y ∈ { A } ( x R y ∨ x = y ∨ y R x ) ;;
	step 8 : wff = df-so () |- ( R Or { A } ↔ ( R Po { A } ∧ ∀ x ∈ { A } ∀ y ∈ { A } ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 9 : wff = mpbiran2 (step 7, step 8) |- ( R Or { A } ↔ R Po { A } ) ;;
	step 10 : wff = posn () |- ( Rel R → ( R Po { A } ↔ ¬ A R A ) ) ;;
	step 11 : wff = syl5bb (step 9, step 10) |- ( Rel R → ( R Or { A } ↔ ¬ A R A ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Founded relation on a singleton.  (Contributed by Mario Carneiro,
       28-Dec-2014.)  (Revised by Mario Carneiro, 23-Apr-2015.) */

theorem frsn (A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( Rel R → ( R Fr { A } ↔ ¬ A R A ) ) ;;
}

proof of frsn {
	var x : set, y : set, z : set;;
	step 1 : wff = df-fr () |- ( R Fr { A } ↔ ∀ x ( ( x ⊆ { A } ∧ x ≠ ∅ ) → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ) ;;
	step 2 : wff = df-ne () |- ( x ≠ ∅ ↔ ¬ x = ∅ ) ;;
	step 3 : wff = simpr () |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x ⊆ { A } ) → x ⊆ { A } ) ;;
	step 4 : wff = sssn () |- ( x ⊆ { A } ↔ ( x = ∅ ∨ x = { A } ) ) ;;
	step 5 : wff = sylib (step 3, step 4) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x ⊆ { A } ) → ( x = ∅ ∨ x = { A } ) ) ;;
	step 6 : wff = ord (step 5) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x ⊆ { A } ) → ( ¬ x = ∅ → x = { A } ) ) ;;
	step 7 : wff = syl5bi (step 2, step 6) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x ⊆ { A } ) → ( x ≠ ∅ → x = { A } ) ) ;;
	step 8 : wff = impr (step 7) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ ( x ⊆ { A } ∧ x ≠ ∅ ) ) → x = { A } ) ;;
	step 9 : wff = eqimss () |- ( x = { A } → x ⊆ { A } ) ;;
	step 10 : wff = adantl (step 9) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x = { A } ) → x ⊆ { A } ) ;;
	step 11 : wff = simpr () |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x = { A } ) → x = { A } ) ;;
	step 12 : wff = snnzg () |- ( A ∈ _V → { A } ≠ ∅ ) ;;
	step 13 : wff = ad2antlr (step 12) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x = { A } ) → { A } ≠ ∅ ) ;;
	step 14 : wff = eqnetrd (step 11, step 13) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x = { A } ) → x ≠ ∅ ) ;;
	step 15 : wff = jca (step 10, step 14) |- ( ( ( Rel R ∧ A ∈ _V ) ∧ x = { A } ) → ( x ⊆ { A } ∧ x ≠ ∅ ) ) ;;
	step 16 : wff = impbida (step 8, step 15) |- ( ( Rel R ∧ A ∈ _V ) → ( ( x ⊆ { A } ∧ x ≠ ∅ ) ↔ x = { A } ) ) ;;
	step 17 : wff = imbi1d (step 16) |- ( ( Rel R ∧ A ∈ _V ) → ( ( ( x ⊆ { A } ∧ x ≠ ∅ ) → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ↔ ( x = { A } → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ) ) ;;
	step 18 : wff = albidv (step 17) |- ( ( Rel R ∧ A ∈ _V ) → ( ∀ x ( ( x ⊆ { A } ∧ x ≠ ∅ ) → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ↔ ∀ x ( x = { A } → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ) ) ;;
	step 19 : wff = snex () |- { A } ∈ _V ;;
	step 20 : wff = raleq () |- ( x = { A } → ( ∀ z ∈ x ¬ z R y ↔ ∀ z ∈ { A } ¬ z R y ) ) ;;
	step 21 : wff = rexeqbi1dv (step 20) |- ( x = { A } → ( ∃ y ∈ x ∀ z ∈ x ¬ z R y ↔ ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ) ) ;;
	step 22 : wff = ceqsalv (step 19, step 21) |- ( ∀ x ( x = { A } → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ↔ ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ) ;;
	step 23 : wff = syl6bb (step 18, step 22) |- ( ( Rel R ∧ A ∈ _V ) → ( ∀ x ( ( x ⊆ { A } ∧ x ≠ ∅ ) → ∃ y ∈ x ∀ z ∈ x ¬ z R y ) ↔ ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ) ) ;;
	step 24 : wff = syl5bb (step 1, step 23) |- ( ( Rel R ∧ A ∈ _V ) → ( R Fr { A } ↔ ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ) ) ;;
	step 25 : wff = breq2 () |- ( y = A → ( z R y ↔ z R A ) ) ;;
	step 26 : wff = notbid (step 25) |- ( y = A → ( ¬ z R y ↔ ¬ z R A ) ) ;;
	step 27 : wff = ralbidv (step 26) |- ( y = A → ( ∀ z ∈ { A } ¬ z R y ↔ ∀ z ∈ { A } ¬ z R A ) ) ;;
	step 28 : wff = rexsng (step 27) |- ( A ∈ _V → ( ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ↔ ∀ z ∈ { A } ¬ z R A ) ) ;;
	step 29 : wff = breq1 () |- ( z = A → ( z R A ↔ A R A ) ) ;;
	step 30 : wff = notbid (step 29) |- ( z = A → ( ¬ z R A ↔ ¬ A R A ) ) ;;
	step 31 : wff = ralsng (step 30) |- ( A ∈ _V → ( ∀ z ∈ { A } ¬ z R A ↔ ¬ A R A ) ) ;;
	step 32 : wff = bitrd (step 28, step 31) |- ( A ∈ _V → ( ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ↔ ¬ A R A ) ) ;;
	step 33 : wff = adantl (step 32) |- ( ( Rel R ∧ A ∈ _V ) → ( ∃ y ∈ { A } ∀ z ∈ { A } ¬ z R y ↔ ¬ A R A ) ) ;;
	step 34 : wff = bitrd (step 24, step 33) |- ( ( Rel R ∧ A ∈ _V ) → ( R Fr { A } ↔ ¬ A R A ) ) ;;
	step 35 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 36 : wff = fr0 () |- R Fr ∅ ;;
	step 37 : wff = freq2 () |- ( { A } = ∅ → ( R Fr { A } ↔ R Fr ∅ ) ) ;;
	step 38 : wff = mpbiri (step 36, step 37) |- ( { A } = ∅ → R Fr { A } ) ;;
	step 39 : wff = sylbi (step 35, step 38) |- ( ¬ A ∈ _V → R Fr { A } ) ;;
	step 40 : wff = adantl (step 39) |- ( ( Rel R ∧ ¬ A ∈ _V ) → R Fr { A } ) ;;
	step 41 : wff = brrelex () |- ( ( Rel R ∧ A R A ) → A ∈ _V ) ;;
	step 42 : wff = ex (step 41) |- ( Rel R → ( A R A → A ∈ _V ) ) ;;
	step 43 : wff = con3and (step 42) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ¬ A R A ) ;;
	step 44 : wff = 2thd (step 40, step 43) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ( R Fr { A } ↔ ¬ A R A ) ) ;;
	step 45 : wff = pm2.61dan (step 34, step 44) |- ( Rel R → ( R Fr { A } ↔ ¬ A R A ) ) ;;
	qed prop 1 = step 45 ;;
}

/*Well-ordering of a singleton.  (Contributed by Mario Carneiro,
       28-Dec-2014.) */

theorem wesn (A : class, R : class) disjointed(A, R) {
	prop 1 : wff = |- ( Rel R → ( R We { A } ↔ ¬ A R A ) ) ;;
}

proof of wesn {
	step 1 : wff = frsn () |- ( Rel R → ( R Fr { A } ↔ ¬ A R A ) ) ;;
	step 2 : wff = sosn () |- ( Rel R → ( R Or { A } ↔ ¬ A R A ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( Rel R → ( ( R Fr { A } ∧ R Or { A } ) ↔ ( ¬ A R A ∧ ¬ A R A ) ) ) ;;
	step 4 : wff = df-we () |- ( R We { A } ↔ ( R Fr { A } ∧ R Or { A } ) ) ;;
	step 5 : wff = pm4.24 () |- ( ¬ A R A ↔ ( ¬ A R A ∧ ¬ A R A ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( Rel R → ( R We { A } ↔ ¬ A R A ) ) ;;
	qed prop 1 = step 6 ;;
}

/*An abstraction relation is a subset of a related cross product.
       (Contributed by NM, 16-Jul-1995.) */

theorem opabssxp (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ ( A × B ) ;;
}

proof of opabssxp {
	step 1 : wff = simpl () |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) → ( x ∈ A ∧ y ∈ B ) ) ;;
	step 2 : wff = ssopab2i (step 1) |- { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ;;
	step 3 : wff = df-xp () |- ( A × B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ;;
	step 4 : wff = sseqtr4i (step 2, step 3) |- { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) } ⊆ ( A × B ) ;;
	qed prop 1 = step 4 ;;
}

/*The law of concretion for a binary relation.  See ~ brab2a for alternate
       proof.  TODO: should one of them be deleted?  (Contributed by Mario
       Carneiro, 28-Apr-2015.)  (Proof modification is discouraged.) */

theorem brab2ga (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class) disjointed(x y A, x y B, x y C, x y D, x y ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- R = { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ;;
	-----------------------
	prop 1 : wff = |- ( A R B ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ ps ) ) ;;
}

proof of brab2ga {
	step 1 : wff = opabssxp () |- { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ⊆ ( C × D ) ;;
	step 2 : wff = eqsstri (hyp 2, step 1) |- R ⊆ ( C × D ) ;;
	step 3 : wff = brel (step 2) |- ( A R B → ( A ∈ C ∧ B ∈ D ) ) ;;
	step 4 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 5 : wff = eleq2i (hyp 2) |- ( 〈 A , B 〉 ∈ R ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( A R B ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ) ;;
	step 7 : wff = opelopab2a (hyp 1) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ps ) ) ;;
	step 8 : wff = syl5bb (step 6, step 7) |- ( ( A ∈ C ∧ B ∈ D ) → ( A R B ↔ ps ) ) ;;
	step 9 : wff = biadan2 (step 3, step 8) |- ( A R B ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Implicit substitution of class for ordered pair.  (Contributed by NM,
       5-Mar-1995.) */

theorem optocl (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x y C, x y ps) {
	hyp 1 : wff = |- D = ( B × C ) ;;
	hyp 2 : wff = |- ( 〈 x , y 〉 = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( ( x ∈ B ∧ y ∈ C ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ D → ps ) ;;
}

proof of optocl {
	step 1 : wff = elxp3 () |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) ) ;;
	step 2 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( B × C ) ↔ ( x ∈ B ∧ y ∈ C ) ) ;;
	step 3 : wff = sylbi (step 2, hyp 3) |- ( 〈 x , y 〉 ∈ ( B × C ) → ph ) ;;
	step 4 : wff = syl5ib (step 3, hyp 2) |- ( 〈 x , y 〉 = A → ( 〈 x , y 〉 ∈ ( B × C ) → ps ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) → ps ) ;;
	step 6 : wff = exlimivv (step 5) |- ( ∃ x ∃ y ( 〈 x , y 〉 = A ∧ 〈 x , y 〉 ∈ ( B × C ) ) → ps ) ;;
	step 7 : wff = sylbi (step 1, step 6) |- ( A ∈ ( B × C ) → ps ) ;;
	step 8 : wff = eleq2s (step 7, hyp 1) |- ( A ∈ D → ps ) ;;
	qed prop 1 = step 8 ;;
}

/*Implicit substitution of classes for ordered pairs.  (Contributed by NM,
       12-Mar-1995.) */

theorem 2optocl (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class, R : class) disjointed(x y z w A, z w B, x y z w C, x y z w D, x y ps, z w ch, z w R) {
	hyp 1 : wff = |- R = ( C × D ) ;;
	hyp 2 : wff = |- ( 〈 x , y 〉 = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( 〈 z , w 〉 = B → ( ps ↔ ch ) ) ;;
	hyp 4 : wff = |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( z ∈ C ∧ w ∈ D ) ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ R ) → ch ) ;;
}

proof of 2optocl {
	step 1 : wff = imbi2d (hyp 3) |- ( 〈 z , w 〉 = B → ( ( A ∈ R → ps ) ↔ ( A ∈ R → ch ) ) ) ;;
	step 2 : wff = imbi2d (hyp 2) |- ( 〈 x , y 〉 = A → ( ( ( z ∈ C ∧ w ∈ D ) → ph ) ↔ ( ( z ∈ C ∧ w ∈ D ) → ps ) ) ) ;;
	step 3 : wff = ex (hyp 4) |- ( ( x ∈ C ∧ y ∈ D ) → ( ( z ∈ C ∧ w ∈ D ) → ph ) ) ;;
	step 4 : wff = optocl (hyp 1, step 2, step 3) |- ( A ∈ R → ( ( z ∈ C ∧ w ∈ D ) → ps ) ) ;;
	step 5 : wff = com12 (step 4) |- ( ( z ∈ C ∧ w ∈ D ) → ( A ∈ R → ps ) ) ;;
	step 6 : wff = optocl (hyp 1, step 1, step 5) |- ( B ∈ R → ( A ∈ R → ch ) ) ;;
	step 7 : wff = impcom (step 6) |- ( ( A ∈ R ∧ B ∈ R ) → ch ) ;;
	qed prop 1 = step 7 ;;
}

/*Implicit substitution of classes for ordered pairs.  (Contributed by NM,
       12-Mar-1995.) */

theorem 3optocl (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, w : set, v : set, u : set, A : class, B : class, C : class, D : class, R : class, F : class) disjointed(x y z w v u A, z w v u B, v u C, x y z w v u D, x y z w v u F, z w v u R, x y ps, z w ch, v u th) {
	hyp 1 : wff = |- R = ( D × F ) ;;
	hyp 2 : wff = |- ( 〈 x , y 〉 = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( 〈 z , w 〉 = B → ( ps ↔ ch ) ) ;;
	hyp 4 : wff = |- ( 〈 v , u 〉 = C → ( ch ↔ th ) ) ;;
	hyp 5 : wff = |- ( ( ( x ∈ D ∧ y ∈ F ) ∧ ( z ∈ D ∧ w ∈ F ) ∧ ( v ∈ D ∧ u ∈ F ) ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ R ∧ C ∈ R ) → th ) ;;
}

proof of 3optocl {
	step 1 : wff = imbi2d (hyp 4) |- ( 〈 v , u 〉 = C → ( ( ( A ∈ R ∧ B ∈ R ) → ch ) ↔ ( ( A ∈ R ∧ B ∈ R ) → th ) ) ) ;;
	step 2 : wff = imbi2d (hyp 2) |- ( 〈 x , y 〉 = A → ( ( ( v ∈ D ∧ u ∈ F ) → ph ) ↔ ( ( v ∈ D ∧ u ∈ F ) → ps ) ) ) ;;
	step 3 : wff = imbi2d (hyp 3) |- ( 〈 z , w 〉 = B → ( ( ( v ∈ D ∧ u ∈ F ) → ps ) ↔ ( ( v ∈ D ∧ u ∈ F ) → ch ) ) ) ;;
	step 4 : wff = 3expia (hyp 5) |- ( ( ( x ∈ D ∧ y ∈ F ) ∧ ( z ∈ D ∧ w ∈ F ) ) → ( ( v ∈ D ∧ u ∈ F ) → ph ) ) ;;
	step 5 : wff = 2optocl (hyp 1, step 2, step 3, step 4) |- ( ( A ∈ R ∧ B ∈ R ) → ( ( v ∈ D ∧ u ∈ F ) → ch ) ) ;;
	step 6 : wff = com12 (step 5) |- ( ( v ∈ D ∧ u ∈ F ) → ( ( A ∈ R ∧ B ∈ R ) → ch ) ) ;;
	step 7 : wff = optocl (hyp 1, step 1, step 6) |- ( C ∈ R → ( ( A ∈ R ∧ B ∈ R ) → th ) ) ;;
	step 8 : wff = impcom (step 7) |- ( ( ( A ∈ R ∧ B ∈ R ) ∧ C ∈ R ) → th ) ;;
	step 9 : wff = 3impa (step 8) |- ( ( A ∈ R ∧ B ∈ R ∧ C ∈ R ) → th ) ;;
	qed prop 1 = step 9 ;;
}

/*Ordered pair membership in a relation.  Special case.  (Contributed by
       NM, 5-Aug-1995.) */

theorem opbrop (ph : wff, ps : wff, x : set, y : set, z : set, w : set, v : set, u : set, A : class, B : class, C : class, D : class, R : class, S : class) disjointed(x y z w v u A, x y z w v u B, x y z w v u C, x y z w v u D, x y z w v u S, x y ph, z w v u ps) {
	hyp 1 : wff = |- ( ( ( z = A ∧ w = B ) ∧ ( v = C ∧ u = D ) ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- R = { 〈 x , y 〉 | ( ( x ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( x = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( 〈 A , B 〉 R 〈 C , D 〉 ↔ ps ) ) ;;
}

proof of opbrop {
	step 1 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 2 : wff = opex () |- 〈 C , D 〉 ∈ _V ;;
	step 3 : wff = eleq1 () |- ( x = 〈 A , B 〉 → ( x ∈ ( S × S ) ↔ 〈 A , B 〉 ∈ ( S × S ) ) ) ;;
	step 4 : wff = anbi1d (step 3) |- ( x = 〈 A , B 〉 → ( ( x ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ↔ ( 〈 A , B 〉 ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ) ) ;;
	step 5 : wff = eqeq1 () |- ( x = 〈 A , B 〉 → ( x = 〈 z , w 〉 ↔ 〈 A , B 〉 = 〈 z , w 〉 ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( x = 〈 A , B 〉 → ( ( x = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ↔ ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ) ) ;;
	step 7 : wff = anbi1d (step 6) |- ( x = 〈 A , B 〉 → ( ( ( x = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ↔ ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ) ) ;;
	step 8 : wff = 4exbidv (step 7) |- ( x = 〈 A , B 〉 → ( ∃ z ∃ w ∃ v ∃ u ( ( x = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ↔ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ) ) ;;
	step 9 : wff = anbi12d (step 4, step 8) |- ( x = 〈 A , B 〉 → ( ( ( x ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( x = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ) ↔ ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ) ) ) ;;
	step 10 : wff = eleq1 () |- ( y = 〈 C , D 〉 → ( y ∈ ( S × S ) ↔ 〈 C , D 〉 ∈ ( S × S ) ) ) ;;
	step 11 : wff = anbi2d (step 10) |- ( y = 〈 C , D 〉 → ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ↔ ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ) ) ;;
	step 12 : wff = eqeq1 () |- ( y = 〈 C , D 〉 → ( y = 〈 v , u 〉 ↔ 〈 C , D 〉 = 〈 v , u 〉 ) ) ;;
	step 13 : wff = anbi2d (step 12) |- ( y = 〈 C , D 〉 → ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ↔ ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ) ) ;;
	step 14 : wff = anbi1d (step 13) |- ( y = 〈 C , D 〉 → ( ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ↔ ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ∧ ph ) ) ) ;;
	step 15 : wff = 4exbidv (step 14) |- ( y = 〈 C , D 〉 → ( ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ↔ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ∧ ph ) ) ) ;;
	step 16 : wff = anbi12d (step 11, step 15) |- ( y = 〈 C , D 〉 → ( ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ y ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ y = 〈 v , u 〉 ) ∧ ph ) ) ↔ ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ∧ ph ) ) ) ) ;;
	step 17 : wff = brab (step 1, step 2, step 9, step 16, hyp 2) |- ( 〈 A , B 〉 R 〈 C , D 〉 ↔ ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ∧ ph ) ) ) ;;
	step 18 : wff = copsex4g (hyp 1) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ∧ ph ) ↔ ps ) ) ;;
	step 19 : wff = anbi2d (step 18) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ∧ ∃ z ∃ w ∃ v ∃ u ( ( 〈 A , B 〉 = 〈 z , w 〉 ∧ 〈 C , D 〉 = 〈 v , u 〉 ) ∧ ph ) ) ↔ ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ∧ ps ) ) ) ;;
	step 20 : wff = syl5bb (step 17, step 19) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( 〈 A , B 〉 R 〈 C , D 〉 ↔ ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ∧ ps ) ) ) ;;
	step 21 : wff = opelxpi () |- ( ( A ∈ S ∧ B ∈ S ) → 〈 A , B 〉 ∈ ( S × S ) ) ;;
	step 22 : wff = opelxpi () |- ( ( C ∈ S ∧ D ∈ S ) → 〈 C , D 〉 ∈ ( S × S ) ) ;;
	step 23 : wff = anim12i (step 21, step 22) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ) ;;
	step 24 : wff = biantrurd (step 23) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( ps ↔ ( ( 〈 A , B 〉 ∈ ( S × S ) ∧ 〈 C , D 〉 ∈ ( S × S ) ) ∧ ps ) ) ) ;;
	step 25 : wff = bitr4d (step 20, step 24) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( C ∈ S ∧ D ∈ S ) ) → ( 〈 A , B 〉 R 〈 C , D 〉 ↔ ps ) ) ;;
	qed prop 1 = step 25 ;;
}

/*The cross product with the empty set is empty.  Part of Theorem 3.13(ii)
       of [Monk1] p. 37.  (Contributed by NM, 4-Jul-1994.) */

theorem xp0r (A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( ∅ × A ) = ∅ ;;
}

proof of xp0r {
	var x : set, y : set, z : set;;
	step 1 : wff = elxp () |- ( z ∈ ( ∅ × A ) ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ ∅ ∧ y ∈ A ) ) ) ;;
	step 2 : wff = noel () |- ¬ x ∈ ∅ ;;
	step 3 : wff = simprl () |- ( ( z = 〈 x , y 〉 ∧ ( x ∈ ∅ ∧ y ∈ A ) ) → x ∈ ∅ ) ;;
	step 4 : wff = mto (step 2, step 3) |- ¬ ( z = 〈 x , y 〉 ∧ ( x ∈ ∅ ∧ y ∈ A ) ) ;;
	step 5 : wff = nex (step 4) |- ¬ ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ ∅ ∧ y ∈ A ) ) ;;
	step 6 : wff = nex (step 5) |- ¬ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ ∅ ∧ y ∈ A ) ) ;;
	step 7 : wff = noel () |- ¬ z ∈ ∅ ;;
	step 8 : wff = 2false (step 6, step 7) |- ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ ∅ ∧ y ∈ A ) ) ↔ z ∈ ∅ ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( z ∈ ( ∅ × A ) ↔ z ∈ ∅ ) ;;
	step 10 : wff = eqriv (step 9) |- ( ∅ × A ) = ∅ ;;
	qed prop 1 = step 10 ;;
}

/*Ordinal numbers and ordered pairs are disjoint collections.  This
       theorem can be used if we want to extend a set of ordinal numbers or
       ordered pairs with disjoint elements.  See also ~ snsn0non .
       (Contributed by NM, 1-Jun-2004.)  (Proof shortened by Andrew Salmon,
       27-Aug-2011.) */

theorem onxpdisj () disjointed(x) {
	prop 1 : wff = |- ( On ∩ ( _V × _V ) ) = ∅ ;;
}

proof of onxpdisj {
	var x : set;;
	step 1 : wff = disj () |- ( ( On ∩ ( _V × _V ) ) = ∅ ↔ ∀ x ∈ On ¬ x ∈ ( _V × _V ) ) ;;
	step 2 : wff = on0eqel () |- ( x ∈ On → ( x = ∅ ∨ ∅ ∈ x ) ) ;;
	step 3 : wff = 0nelxp () |- ¬ ∅ ∈ ( _V × _V ) ;;
	step 4 : wff = eleq1 () |- ( x = ∅ → ( x ∈ ( _V × _V ) ↔ ∅ ∈ ( _V × _V ) ) ) ;;
	step 5 : wff = mtbiri (step 3, step 4) |- ( x = ∅ → ¬ x ∈ ( _V × _V ) ) ;;
	step 6 : wff = 0nelelxp () |- ( x ∈ ( _V × _V ) → ¬ ∅ ∈ x ) ;;
	step 7 : wff = con2i (step 6) |- ( ∅ ∈ x → ¬ x ∈ ( _V × _V ) ) ;;
	step 8 : wff = jaoi (step 5, step 7) |- ( ( x = ∅ ∨ ∅ ∈ x ) → ¬ x ∈ ( _V × _V ) ) ;;
	step 9 : wff = syl (step 2, step 8) |- ( x ∈ On → ¬ x ∈ ( _V × _V ) ) ;;
	step 10 : wff = mprgbir (step 1, step 9) |- ( On ∩ ( _V × _V ) ) = ∅ ;;
	qed prop 1 = step 10 ;;
}

/*The class of ordinal numbers is not equal to the universe.  (Contributed
     by NM, 16-Jun-2007.)  (Proof shortened by Mario Carneiro, 10-Jan-2013.) */

theorem onnev ()  {
	prop 1 : wff = |- On ≠ _V ;;
}

proof of onnev {
	step 1 : wff = snsn0non () |- ¬ { { ∅ } } ∈ On ;;
	step 2 : wff = snex () |- { { ∅ } } ∈ _V ;;
	step 3 : wff = id () |- ( On = _V → On = _V ) ;;
	step 4 : wff = syl5eleqr (step 2, step 3) |- ( On = _V → { { ∅ } } ∈ On ) ;;
	step 5 : wff = necon3bi (step 4) |- ( ¬ { { ∅ } } ∈ On → On ≠ _V ) ;;
	step 6 : wff = ax-mp (step 1, step 5) |- On ≠ _V ;;
	qed prop 1 = step 6 ;;
}

/*Equality theorem for the relation predicate.  (Contributed by NM,
     1-Aug-1994.) */

theorem releq (A : class, B : class)  {
	prop 1 : wff = |- ( A = B → ( Rel A ↔ Rel B ) ) ;;
}

proof of releq {
	step 1 : wff = sseq1 () |- ( A = B → ( A ⊆ ( _V × _V ) ↔ B ⊆ ( _V × _V ) ) ) ;;
	step 2 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 3 : wff = df-rel () |- ( Rel B ↔ B ⊆ ( _V × _V ) ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( A = B → ( Rel A ↔ Rel B ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality inference for the relation predicate.  (Contributed by NM,
       8-Dec-2006.) */

theorem releqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( Rel A ↔ Rel B ) ;;
}

proof of releqi {
	step 1 : wff = releq () |- ( A = B → ( Rel A ↔ Rel B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( Rel A ↔ Rel B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for the relation predicate.  (Contributed by NM,
       8-Mar-2014.) */

theorem releqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( Rel A ↔ Rel B ) ) ;;
}

proof of releqd {
	step 1 : wff = releq () |- ( A = B → ( Rel A ↔ Rel B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( Rel A ↔ Rel B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for a relation.  (Contributed by NM,
       31-Jan-2004.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nfrel (x : set, A : class) disjointed(A, x) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x Rel A ;;
}

proof of nfrel {
	step 1 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 2 : wff = nfcv () |- F/_ x ( _V × _V ) ;;
	step 3 : wff = nfss (hyp 1, step 2) |- F/ x A ⊆ ( _V × _V ) ;;
	step 4 : wff = nfxfr (step 1, step 3) |- F/ x Rel A ;;
	qed prop 1 = step 4 ;;
}

/*Subclass theorem for relation predicate.  Theorem 2 of [Suppes] p. 58.
     (Contributed by NM, 15-Aug-1994.) */

theorem relss (A : class, B : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( Rel B → Rel A ) ) ;;
}

proof of relss {
	step 1 : wff = sstr2 () |- ( A ⊆ B → ( B ⊆ ( _V × _V ) → A ⊆ ( _V × _V ) ) ) ;;
	step 2 : wff = df-rel () |- ( Rel B ↔ B ⊆ ( _V × _V ) ) ;;
	step 3 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 4 : wff = 3imtr4g (step 1, step 2, step 3) |- ( A ⊆ B → ( Rel B → Rel A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*A subclass relationship depends only on a relation's ordered pairs.
       Theorem 3.2(i) of [Monk1] p. 33.  (Contributed by NM, 2-Aug-1994.)
       (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem ssrel (x : set, y : set, A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- ( Rel A → ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
}

proof of ssrel {
	var z : set;;
	step 1 : wff = ssel () |- ( A ⊆ B → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = alrimivv (step 1) |- ( A ⊆ B → ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ;;
	step 3 : wff = eleq1 () |- ( z = 〈 x , y 〉 → ( z ∈ A ↔ 〈 x , y 〉 ∈ A ) ) ;;
	step 4 : wff = eleq1 () |- ( z = 〈 x , y 〉 → ( z ∈ B ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 5 : wff = imbi12d (step 3, step 4) |- ( z = 〈 x , y 〉 → ( ( z ∈ A → z ∈ B ) ↔ ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
	step 6 : wff = biimprcd (step 5) |- ( ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ( z = 〈 x , y 〉 → ( z ∈ A → z ∈ B ) ) ) ;;
	step 7 : wff = 2alimi (step 6) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ∀ x ∀ y ( z = 〈 x , y 〉 → ( z ∈ A → z ∈ B ) ) ) ;;
	step 8 : wff = 19.23vv () |- ( ∀ x ∀ y ( z = 〈 x , y 〉 → ( z ∈ A → z ∈ B ) ) ↔ ( ∃ x ∃ y z = 〈 x , y 〉 → ( z ∈ A → z ∈ B ) ) ) ;;
	step 9 : wff = sylib (step 7, step 8) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ( ∃ x ∃ y z = 〈 x , y 〉 → ( z ∈ A → z ∈ B ) ) ) ;;
	step 10 : wff = com23 (step 9) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ( z ∈ A → ( ∃ x ∃ y z = 〈 x , y 〉 → z ∈ B ) ) ) ;;
	step 11 : wff = a2d (step 10) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ( ( z ∈ A → ∃ x ∃ y z = 〈 x , y 〉 ) → ( z ∈ A → z ∈ B ) ) ) ;;
	step 12 : wff = alimdv (step 11) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ( ∀ z ( z ∈ A → ∃ x ∃ y z = 〈 x , y 〉 ) → ∀ z ( z ∈ A → z ∈ B ) ) ) ;;
	step 13 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 14 : wff = dfss2 () |- ( A ⊆ ( _V × _V ) ↔ ∀ z ( z ∈ A → z ∈ ( _V × _V ) ) ) ;;
	step 15 : wff = elvv () |- ( z ∈ ( _V × _V ) ↔ ∃ x ∃ y z = 〈 x , y 〉 ) ;;
	step 16 : wff = imbi2i (step 15) |- ( ( z ∈ A → z ∈ ( _V × _V ) ) ↔ ( z ∈ A → ∃ x ∃ y z = 〈 x , y 〉 ) ) ;;
	step 17 : wff = albii (step 16) |- ( ∀ z ( z ∈ A → z ∈ ( _V × _V ) ) ↔ ∀ z ( z ∈ A → ∃ x ∃ y z = 〈 x , y 〉 ) ) ;;
	step 18 : wff = 3bitri (step 13, step 14, step 17) |- ( Rel A ↔ ∀ z ( z ∈ A → ∃ x ∃ y z = 〈 x , y 〉 ) ) ;;
	step 19 : wff = dfss2 () |- ( A ⊆ B ↔ ∀ z ( z ∈ A → z ∈ B ) ) ;;
	step 20 : wff = 3imtr4g (step 12, step 18, step 19) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → ( Rel A → A ⊆ B ) ) ;;
	step 21 : wff = com12 (step 20) |- ( Rel A → ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) → A ⊆ B ) ) ;;
	step 22 : wff = impbid2 (step 2, step 21) |- ( Rel A → ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
	qed prop 1 = step 22 ;;
}

/*Extensionality principle for relations.  Theorem 3.2(ii) of [Monk1]
       p. 33.  (Contributed by NM, 2-Aug-1994.) */

theorem eqrel (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
}

proof of eqrel {
	step 1 : wff = ssrel () |- ( Rel A → ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
	step 2 : wff = ssrel () |- ( Rel B → ( B ⊆ A ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ B → 〈 x , y 〉 ∈ A ) ) ) ;;
	step 3 : wff = bi2anan9 (step 1, step 2) |- ( ( Rel A ∧ Rel B ) → ( ( A ⊆ B ∧ B ⊆ A ) ↔ ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ∧ ∀ x ∀ y ( 〈 x , y 〉 ∈ B → 〈 x , y 〉 ∈ A ) ) ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = 2albiim () |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ↔ ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ∧ ∀ x ∀ y ( 〈 x , y 〉 ∈ B → 〈 x , y 〉 ∈ A ) ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Inference from subclass principle for relations.  (Contributed by NM,
       31-Mar-1998.) */

theorem relssi (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- Rel A ;;
	hyp 2 : wff = |- ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- A ⊆ B ;;
}

proof of relssi {
	step 1 : wff = ssrel () |- ( Rel A → ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ;;
	step 3 : wff = ax-gen (hyp 2) |- ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ;;
	step 4 : wff = mpgbir (step 2, step 3) |- A ⊆ B ;;
	qed prop 1 = step 4 ;;
}

/*Deduction from subclass principle for relations.  (Contributed by NM,
       11-Sep-2004.) */

theorem relssdv (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, x y ph) {
	hyp 1 : wff = |- ( ph → Rel A ) ;;
	hyp 2 : wff = |- ( ph → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ⊆ B ) ;;
}

proof of relssdv {
	step 1 : wff = alrimivv (hyp 2) |- ( ph → ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = ssrel () |- ( Rel A → ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
	step 3 : wff = syl (hyp 1, step 2) |- ( ph → ( A ⊆ B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ) ;;
	step 4 : wff = mpbird (step 1, step 3) |- ( ph → A ⊆ B ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference from extensionality principle for relations.  (Contributed by
       FL, 15-Oct-2012.) */

theorem eqrelriv (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( Rel A ∧ Rel B ) → A = B ) ;;
}

proof of eqrelriv {
	step 1 : wff = gen2 (hyp 1) |- ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ;;
	step 2 : wff = eqrel () |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 3 : wff = mpbiri (step 1, step 2) |- ( ( Rel A ∧ Rel B ) → A = B ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from extensionality principle for relations.  (Contributed by
       NM, 17-Mar-1995.) */

theorem eqrelriiv (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- Rel A ;;
	hyp 2 : wff = |- Rel B ;;
	hyp 3 : wff = |- ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- A = B ;;
}

proof of eqrelriiv {
	step 1 : wff = eqrelriv (hyp 3) |- ( ( Rel A ∧ Rel B ) → A = B ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- A = B ;;
	qed prop 1 = step 2 ;;
}

/*Inference from extensionality principle for relations.  (Contributed by
       NM, 12-Dec-2006.) */

theorem eqbrriv (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- Rel A ;;
	hyp 2 : wff = |- Rel B ;;
	hyp 3 : wff = |- ( x A y ↔ x B y ) ;;
	-----------------------
	prop 1 : wff = |- A = B ;;
}

proof of eqbrriv {
	step 1 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 2 : wff = df-br () |- ( x B y ↔ 〈 x , y 〉 ∈ B ) ;;
	step 3 : wff = 3bitr3i (hyp 3, step 1, step 2) |- ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ;;
	step 4 : wff = eqrelriiv (hyp 1, hyp 2, step 3) |- A = B ;;
	qed prop 1 = step 4 ;;
}

/*Deduce equality of relations from equivalence of membership.
       (Contributed by Rodolfo Medina, 10-Oct-2010.) */

theorem eqrelrdv (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, ph x, ph y) {
	hyp 1 : wff = |- Rel A ;;
	hyp 2 : wff = |- Rel B ;;
	hyp 3 : wff = |- ( ph → ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = B ) ;;
}

proof of eqrelrdv {
	step 1 : wff = alrimivv (hyp 3) |- ( ph → ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = eqrel () |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 3 : wff = mp2an (hyp 1, hyp 2, step 2) |- ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 4 : wff = sylibr (step 1, step 3) |- ( ph → A = B ) ;;
	qed prop 1 = step 4 ;;
}

/*Deduction from extensionality principle for relations.  (Contributed by
       Mario Carneiro, 3-Jan-2017.) */

theorem eqbrrdv (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, ph x, ph y) {
	hyp 1 : wff = |- ( ph → Rel A ) ;;
	hyp 2 : wff = |- ( ph → Rel B ) ;;
	hyp 3 : wff = |- ( ph → ( x A y ↔ x B y ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = B ) ;;
}

proof of eqbrrdv {
	step 1 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 2 : wff = df-br () |- ( x B y ↔ 〈 x , y 〉 ∈ B ) ;;
	step 3 : wff = 3bitr3g (hyp 3, step 1, step 2) |- ( ph → ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 4 : wff = alrimivv (step 3) |- ( ph → ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 5 : wff = eqrel () |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 6 : wff = syl2anc (hyp 1, hyp 2, step 5) |- ( ph → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 7 : wff = mpbird (step 4, step 6) |- ( ph → A = B ) ;;
	qed prop 1 = step 7 ;;
}

/*Deduction from extensionality principle for relations.  (Contributed by
       Rodolfo Medina, 10-Oct-2010.) */

theorem eqbrrdiv (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, ph x, ph y) {
	hyp 1 : wff = |- Rel A ;;
	hyp 2 : wff = |- Rel B ;;
	hyp 3 : wff = |- ( ph → ( x A y ↔ x B y ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = B ) ;;
}

proof of eqbrrdiv {
	step 1 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 2 : wff = df-br () |- ( x B y ↔ 〈 x , y 〉 ∈ B ) ;;
	step 3 : wff = 3bitr3g (hyp 3, step 1, step 2) |- ( ph → ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 4 : wff = eqrelrdv (hyp 1, hyp 2, step 3) |- ( ph → A = B ) ;;
	qed prop 1 = step 4 ;;
}

/*A version of ~ eqrelrdv .  (Contributed by Rodolfo Medina,
       10-Oct-2010.) */

theorem eqrelrdv2 (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, ph x, ph y) {
	hyp 1 : wff = |- ( ph → ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( Rel A ∧ Rel B ) ∧ ph ) → A = B ) ;;
}

proof of eqrelrdv2 {
	step 1 : wff = alrimivv (hyp 1) |- ( ph → ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = adantl (step 1) |- ( ( ( Rel A ∧ Rel B ) ∧ ph ) → ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ;;
	step 3 : wff = eqrel () |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 4 : wff = adantr (step 3) |- ( ( ( Rel A ∧ Rel B ) ∧ ph ) → ( A = B ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 5 : wff = mpbird (step 2, step 4) |- ( ( ( Rel A ∧ Rel B ) ∧ ph ) → A = B ) ;;
	qed prop 1 = step 5 ;;
}

/*A subclass relationship determined by ordered triples.  Use ~ relrelss
       to express the antecedent in terms of the relation predicate.
       (Contributed by NM, 17-Dec-2008.)  (Proof shortened by Andrew Salmon,
       27-Aug-2011.) */

theorem ssrelrel (x : set, y : set, z : set, A : class, B : class) disjointed(w x y z A, w x y z B) {
	prop 1 : wff = |- ( A ⊆ ( ( _V × _V ) × _V ) → ( A ⊆ B ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
}

proof of ssrelrel {
	var w : set;;
	step 1 : wff = ssel () |- ( A ⊆ B → ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ;;
	step 2 : wff = alrimiv (step 1) |- ( A ⊆ B → ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ;;
	step 3 : wff = alrimivv (step 2) |- ( A ⊆ B → ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ;;
	step 4 : wff = elvvv () |- ( w ∈ ( ( _V × _V ) × _V ) ↔ ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 5 : wff = eleq1 () |- ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ;;
	step 6 : wff = eleq1 () |- ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ B ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ;;
	step 7 : wff = imbi12d (step 5, step 6) |- ( w = 〈 〈 x , y 〉 , z 〉 → ( ( w ∈ A → w ∈ B ) ↔ ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
	step 8 : wff = biimprcd (step 7) |- ( ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 9 : wff = alimi (step 8) |- ( ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ∀ z ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 10 : wff = 19.23v () |- ( ∀ z ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ↔ ( ∃ z w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 11 : wff = sylib (step 9, step 10) |- ( ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( ∃ z w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 12 : wff = 2alimi (step 11) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ∀ x ∀ y ( ∃ z w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 13 : wff = 19.23vv () |- ( ∀ x ∀ y ( ∃ z w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ↔ ( ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 14 : wff = sylib (step 12, step 13) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ A → w ∈ B ) ) ) ;;
	step 15 : wff = syl5bi (step 4, step 14) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( w ∈ ( ( _V × _V ) × _V ) → ( w ∈ A → w ∈ B ) ) ) ;;
	step 16 : wff = com23 (step 15) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( w ∈ A → ( w ∈ ( ( _V × _V ) × _V ) → w ∈ B ) ) ) ;;
	step 17 : wff = a2d (step 16) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( ( w ∈ A → w ∈ ( ( _V × _V ) × _V ) ) → ( w ∈ A → w ∈ B ) ) ) ;;
	step 18 : wff = alimdv (step 17) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( ∀ w ( w ∈ A → w ∈ ( ( _V × _V ) × _V ) ) → ∀ w ( w ∈ A → w ∈ B ) ) ) ;;
	step 19 : wff = dfss2 () |- ( A ⊆ ( ( _V × _V ) × _V ) ↔ ∀ w ( w ∈ A → w ∈ ( ( _V × _V ) × _V ) ) ) ;;
	step 20 : wff = dfss2 () |- ( A ⊆ B ↔ ∀ w ( w ∈ A → w ∈ B ) ) ;;
	step 21 : wff = 3imtr4g (step 18, step 19, step 20) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → ( A ⊆ ( ( _V × _V ) × _V ) → A ⊆ B ) ) ;;
	step 22 : wff = com12 (step 21) |- ( A ⊆ ( ( _V × _V ) × _V ) → ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) → A ⊆ B ) ) ;;
	step 23 : wff = impbid2 (step 3, step 22) |- ( A ⊆ ( ( _V × _V ) × _V ) → ( A ⊆ B ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
	qed prop 1 = step 23 ;;
}

/*Extensionality principle for ordered triples (used by 2-place operations
       ~ df-oprab ), analogous to ~ eqrel .  Use ~ relrelss to express the
       antecedent in terms of the relation predicate.  (Contributed by NM,
       17-Dec-2008.) */

theorem eqrelrel (x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- ( ( A ∪ B ) ⊆ ( ( _V × _V ) × _V ) → ( A = B ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
}

proof of eqrelrel {
	step 1 : wff = unss () |- ( ( A ⊆ ( ( _V × _V ) × _V ) ∧ B ⊆ ( ( _V × _V ) × _V ) ) ↔ ( A ∪ B ) ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 2 : wff = ssrelrel () |- ( A ⊆ ( ( _V × _V ) × _V ) → ( A ⊆ B ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
	step 3 : wff = ssrelrel () |- ( B ⊆ ( ( _V × _V ) × _V ) → ( B ⊆ A ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ) ;;
	step 4 : wff = bi2anan9 (step 2, step 3) |- ( ( A ⊆ ( ( _V × _V ) × _V ) ∧ B ⊆ ( ( _V × _V ) × _V ) ) → ( ( A ⊆ B ∧ B ⊆ A ) ↔ ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ∧ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ) ) ;;
	step 5 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 6 : wff = 2albiim () |- ( ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ↔ ( ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ∧ ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ↔ ∀ x ( ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ∧ ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ) ;;
	step 8 : wff = 19.26 () |- ( ∀ x ( ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ∧ ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ↔ ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ∧ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ) ;;
	step 9 : wff = bitri (step 7, step 8) |- ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ↔ ( ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A → 〈 〈 x , y 〉 , z 〉 ∈ B ) ∧ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ B → 〈 〈 x , y 〉 , z 〉 ∈ A ) ) ) ;;
	step 10 : wff = 3bitr4g (step 4, step 5, step 9) |- ( ( A ⊆ ( ( _V × _V ) × _V ) ∧ B ⊆ ( ( _V × _V ) × _V ) ) → ( A = B ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
	step 11 : wff = sylbir (step 1, step 10) |- ( ( A ∪ B ) ⊆ ( ( _V × _V ) × _V ) → ( A = B ↔ ∀ x ∀ y ∀ z ( 〈 〈 x , y 〉 , z 〉 ∈ A ↔ 〈 〈 x , y 〉 , z 〉 ∈ B ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/*A member of a relation is an ordered pair.  (Contributed by NM,
       17-Sep-2006.) */

theorem elrel (x : set, y : set, A : class, R : class) disjointed(x y A) {
	prop 1 : wff = |- ( ( Rel R ∧ A ∈ R ) → ∃ x ∃ y A = 〈 x , y 〉 ) ;;
}

proof of elrel {
	step 1 : wff = df-rel () |- ( Rel R ↔ R ⊆ ( _V × _V ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( Rel R → R ⊆ ( _V × _V ) ) ;;
	step 3 : wff = sselda (step 2) |- ( ( Rel R ∧ A ∈ R ) → A ∈ ( _V × _V ) ) ;;
	step 4 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 5 : wff = sylib (step 3, step 4) |- ( ( Rel R ∧ A ∈ R ) → ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	qed prop 1 = step 5 ;;
}

/*A singleton is a relation iff it is an ordered pair.  (Contributed by
       NM, 24-Sep-2013.) */

theorem relsn (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( Rel { A } ↔ A ∈ ( _V × _V ) ) ;;
}

proof of relsn {
	step 1 : wff = df-rel () |- ( Rel { A } ↔ { A } ⊆ ( _V × _V ) ) ;;
	step 2 : wff = snss (hyp 1) |- ( A ∈ ( _V × _V ) ↔ { A } ⊆ ( _V × _V ) ) ;;
	step 3 : wff = bitr4i (step 1, step 2) |- ( Rel { A } ↔ A ∈ ( _V × _V ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A singleton of an ordered pair is a relation.  (Contributed by NM,
       17-May-1998.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem relsnop (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- Rel { 〈 A , B 〉 } ;;
}

proof of relsnop {
	step 1 : wff = opelvv (hyp 1, hyp 2) |- 〈 A , B 〉 ∈ ( _V × _V ) ;;
	step 2 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 3 : wff = relsn (step 2) |- ( Rel { 〈 A , B 〉 } ↔ 〈 A , B 〉 ∈ ( _V × _V ) ) ;;
	step 4 : wff = mpbir (step 1, step 3) |- Rel { 〈 A , B 〉 } ;;
	qed prop 1 = step 4 ;;
}

/*Subset theorem for cross product.  Generalization of Theorem 101 of
       [Suppes] p. 52.  (Contributed by NM, 26-Aug-1995.)  (Proof shortened by
       Andrew Salmon, 27-Aug-2011.) */

theorem xpss12 (A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x y C, x y D) {
	prop 1 : wff = |- ( ( A ⊆ B ∧ C ⊆ D ) → ( A × C ) ⊆ ( B × D ) ) ;;
}

proof of xpss12 {
	var x : set, y : set;;
	step 1 : wff = ssel () |- ( A ⊆ B → ( x ∈ A → x ∈ B ) ) ;;
	step 2 : wff = ssel () |- ( C ⊆ D → ( y ∈ C → y ∈ D ) ) ;;
	step 3 : wff = im2anan9 (step 1, step 2) |- ( ( A ⊆ B ∧ C ⊆ D ) → ( ( x ∈ A ∧ y ∈ C ) → ( x ∈ B ∧ y ∈ D ) ) ) ;;
	step 4 : wff = ssopab2dv (step 3) |- ( ( A ⊆ B ∧ C ⊆ D ) → { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ⊆ { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ D ) } ) ;;
	step 5 : wff = df-xp () |- ( A × C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ C ) } ;;
	step 6 : wff = df-xp () |- ( B × D ) = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ D ) } ;;
	step 7 : wff = 3sstr4g (step 4, step 5, step 6) |- ( ( A ⊆ B ∧ C ⊆ D ) → ( A × C ) ⊆ ( B × D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A cross product is included in the ordered pair universe.  Exercise 3 of
       [TakeutiZaring] p. 25.  (Contributed by NM, 2-Aug-1994.) */

theorem xpss (A : class, B : class) disjointed(A, B) {
	prop 1 : wff = |- ( A × B ) ⊆ ( _V × _V ) ;;
}

proof of xpss {
	step 1 : wff = ssv () |- A ⊆ _V ;;
	step 2 : wff = ssv () |- B ⊆ _V ;;
	step 3 : wff = xpss12 () |- ( ( A ⊆ _V ∧ B ⊆ _V ) → ( A × B ) ⊆ ( _V × _V ) ) ;;
	step 4 : wff = mp2an (step 1, step 2, step 3) |- ( A × B ) ⊆ ( _V × _V ) ;;
	qed prop 1 = step 4 ;;
}

/*A cross product is a relation.  Theorem 3.13(i) of [Monk1] p. 37.
     (Contributed by NM, 2-Aug-1994.) */

theorem relxp (A : class, B : class)  {
	prop 1 : wff = |- Rel ( A × B ) ;;
}

proof of relxp {
	step 1 : wff = xpss () |- ( A × B ) ⊆ ( _V × _V ) ;;
	step 2 : wff = df-rel () |- ( Rel ( A × B ) ↔ ( A × B ) ⊆ ( _V × _V ) ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- Rel ( A × B ) ;;
	qed prop 1 = step 3 ;;
}

/*Subset relation for cross product.  (Contributed by Jeff Hankins,
     30-Aug-2009.) */

theorem xpss1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( A × C ) ⊆ ( B × C ) ) ;;
}

proof of xpss1 {
	step 1 : wff = ssid () |- C ⊆ C ;;
	step 2 : wff = xpss12 () |- ( ( A ⊆ B ∧ C ⊆ C ) → ( A × C ) ⊆ ( B × C ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( A ⊆ B → ( A × C ) ⊆ ( B × C ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Subset relation for cross product.  (Contributed by Jeff Hankins,
     30-Aug-2009.) */

theorem xpss2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( C × A ) ⊆ ( C × B ) ) ;;
}

proof of xpss2 {
	step 1 : wff = ssid () |- C ⊆ C ;;
	step 2 : wff = xpss12 () |- ( ( C ⊆ C ∧ A ⊆ B ) → ( C × A ) ⊆ ( C × B ) ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( A ⊆ B → ( C × A ) ⊆ ( C × B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A cross product is included in the power of the power of the union of
       its arguments.  (Contributed by NM, 13-Sep-2006.) */

theorem xpsspw (A : class, B : class) disjointed(A x y z, B x y z) {
	prop 1 : wff = |- ( A × B ) ⊆ Pow Pow ( A ∪ B ) ;;
}

proof of xpsspw {
	var x : set, y : set, z : set;;
	step 1 : wff = elxpi () |- ( z ∈ ( A × B ) → ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = dfop (step 2, step 3) |- 〈 x , y 〉 = { { x } , { x , y } } ;;
	step 5 : wff = snssi () |- ( x ∈ A → { x } ⊆ A ) ;;
	step 6 : wff = ssun3 () |- ( { x } ⊆ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( x ∈ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 8 : wff = adantr (step 7) |- ( ( x ∈ A ∧ y ∈ B ) → { x } ⊆ ( A ∪ B ) ) ;;
	step 9 : wff = sseq1 () |- ( z = { x } → ( z ⊆ ( A ∪ B ) ↔ { x } ⊆ ( A ∪ B ) ) ) ;;
	step 10 : wff = syl5ibrcom (step 8, step 9) |- ( ( x ∈ A ∧ y ∈ B ) → ( z = { x } → z ⊆ ( A ∪ B ) ) ) ;;
	step 11 : wff = df-pr () |- { x , y } = ( { x } ∪ { y } ) ;;
	step 12 : wff = snssi () |- ( x ∈ A → { x } ⊆ A ) ;;
	step 13 : wff = ssun3 () |- ( { x } ⊆ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( x ∈ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 15 : wff = snssi () |- ( y ∈ B → { y } ⊆ B ) ;;
	step 16 : wff = ssun4 () |- ( { y } ⊆ B → { y } ⊆ ( A ∪ B ) ) ;;
	step 17 : wff = syl (step 15, step 16) |- ( y ∈ B → { y } ⊆ ( A ∪ B ) ) ;;
	step 18 : wff = anim12i (step 14, step 17) |- ( ( x ∈ A ∧ y ∈ B ) → ( { x } ⊆ ( A ∪ B ) ∧ { y } ⊆ ( A ∪ B ) ) ) ;;
	step 19 : wff = unss () |- ( ( { x } ⊆ ( A ∪ B ) ∧ { y } ⊆ ( A ∪ B ) ) ↔ ( { x } ∪ { y } ) ⊆ ( A ∪ B ) ) ;;
	step 20 : wff = sylib (step 18, step 19) |- ( ( x ∈ A ∧ y ∈ B ) → ( { x } ∪ { y } ) ⊆ ( A ∪ B ) ) ;;
	step 21 : wff = syl5eqss (step 11, step 20) |- ( ( x ∈ A ∧ y ∈ B ) → { x , y } ⊆ ( A ∪ B ) ) ;;
	step 22 : wff = sseq1 () |- ( z = { x , y } → ( z ⊆ ( A ∪ B ) ↔ { x , y } ⊆ ( A ∪ B ) ) ) ;;
	step 23 : wff = syl5ibrcom (step 21, step 22) |- ( ( x ∈ A ∧ y ∈ B ) → ( z = { x , y } → z ⊆ ( A ∪ B ) ) ) ;;
	step 24 : wff = jaod (step 10, step 23) |- ( ( x ∈ A ∧ y ∈ B ) → ( ( z = { x } ∨ z = { x , y } ) → z ⊆ ( A ∪ B ) ) ) ;;
	step 25 : wff = vex () |- z ∈ _V ;;
	step 26 : wff = elpr (step 25) |- ( z ∈ { { x } , { x , y } } ↔ ( z = { x } ∨ z = { x , y } ) ) ;;
	step 27 : wff = vex () |- z ∈ _V ;;
	step 28 : wff = elpw (step 27) |- ( z ∈ Pow ( A ∪ B ) ↔ z ⊆ ( A ∪ B ) ) ;;
	step 29 : wff = 3imtr4g (step 24, step 26, step 28) |- ( ( x ∈ A ∧ y ∈ B ) → ( z ∈ { { x } , { x , y } } → z ∈ Pow ( A ∪ B ) ) ) ;;
	step 30 : wff = ssrdv (step 29) |- ( ( x ∈ A ∧ y ∈ B ) → { { x } , { x , y } } ⊆ Pow ( A ∪ B ) ) ;;
	step 31 : wff = syl5eqss (step 4, step 30) |- ( ( x ∈ A ∧ y ∈ B ) → 〈 x , y 〉 ⊆ Pow ( A ∪ B ) ) ;;
	step 32 : wff = sseq1 () |- ( z = 〈 x , y 〉 → ( z ⊆ Pow ( A ∪ B ) ↔ 〈 x , y 〉 ⊆ Pow ( A ∪ B ) ) ) ;;
	step 33 : wff = biimpar (step 32) |- ( ( z = 〈 x , y 〉 ∧ 〈 x , y 〉 ⊆ Pow ( A ∪ B ) ) → z ⊆ Pow ( A ∪ B ) ) ;;
	step 34 : wff = sylan2 (step 31, step 33) |- ( ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → z ⊆ Pow ( A ∪ B ) ) ;;
	step 35 : wff = exlimivv (step 34) |- ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) → z ⊆ Pow ( A ∪ B ) ) ;;
	step 36 : wff = syl (step 1, step 35) |- ( z ∈ ( A × B ) → z ⊆ Pow ( A ∪ B ) ) ;;
	step 37 : wff = vex () |- z ∈ _V ;;
	step 38 : wff = elpw (step 37) |- ( z ∈ Pow Pow ( A ∪ B ) ↔ z ⊆ Pow ( A ∪ B ) ) ;;
	step 39 : wff = sylibr (step 36, step 38) |- ( z ∈ ( A × B ) → z ∈ Pow Pow ( A ∪ B ) ) ;;
	step 40 : wff = ssriv (step 39) |- ( A × B ) ⊆ Pow Pow ( A ∪ B ) ;;
	qed prop 1 = step 40 ;;
}

/*A cross product is included in the power of the power of the union of
       its arguments.  (Contributed by NM, 13-Sep-2006.)
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem xpsspwOLD (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A × B ) ⊆ Pow Pow ( A ∪ B ) ;;
}

proof of xpsspwOLD {
	var x : set, y : set;;
	step 1 : wff = relxp () |- Rel ( A × B ) ;;
	step 2 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 3 : wff = snssi () |- ( x ∈ A → { x } ⊆ A ) ;;
	step 4 : wff = ssun3 () |- ( { x } ⊆ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( x ∈ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 6 : wff = snex () |- { x } ∈ _V ;;
	step 7 : wff = elpw (step 6) |- ( { x } ∈ Pow ( A ∪ B ) ↔ { x } ⊆ ( A ∪ B ) ) ;;
	step 8 : wff = sylibr (step 5, step 7) |- ( x ∈ A → { x } ∈ Pow ( A ∪ B ) ) ;;
	step 9 : wff = adantr (step 8) |- ( ( x ∈ A ∧ y ∈ B ) → { x } ∈ Pow ( A ∪ B ) ) ;;
	step 10 : wff = df-pr () |- { x , y } = ( { x } ∪ { y } ) ;;
	step 11 : wff = snssi () |- ( x ∈ A → { x } ⊆ A ) ;;
	step 12 : wff = ssun3 () |- ( { x } ⊆ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 13 : wff = syl (step 11, step 12) |- ( x ∈ A → { x } ⊆ ( A ∪ B ) ) ;;
	step 14 : wff = snssi () |- ( y ∈ B → { y } ⊆ B ) ;;
	step 15 : wff = ssun4 () |- ( { y } ⊆ B → { y } ⊆ ( A ∪ B ) ) ;;
	step 16 : wff = syl (step 14, step 15) |- ( y ∈ B → { y } ⊆ ( A ∪ B ) ) ;;
	step 17 : wff = anim12i (step 13, step 16) |- ( ( x ∈ A ∧ y ∈ B ) → ( { x } ⊆ ( A ∪ B ) ∧ { y } ⊆ ( A ∪ B ) ) ) ;;
	step 18 : wff = unss () |- ( ( { x } ⊆ ( A ∪ B ) ∧ { y } ⊆ ( A ∪ B ) ) ↔ ( { x } ∪ { y } ) ⊆ ( A ∪ B ) ) ;;
	step 19 : wff = sylib (step 17, step 18) |- ( ( x ∈ A ∧ y ∈ B ) → ( { x } ∪ { y } ) ⊆ ( A ∪ B ) ) ;;
	step 20 : wff = syl5eqss (step 10, step 19) |- ( ( x ∈ A ∧ y ∈ B ) → { x , y } ⊆ ( A ∪ B ) ) ;;
	step 21 : wff = zfpair2 () |- { x , y } ∈ _V ;;
	step 22 : wff = elpw (step 21) |- ( { x , y } ∈ Pow ( A ∪ B ) ↔ { x , y } ⊆ ( A ∪ B ) ) ;;
	step 23 : wff = sylibr (step 20, step 22) |- ( ( x ∈ A ∧ y ∈ B ) → { x , y } ∈ Pow ( A ∪ B ) ) ;;
	step 24 : wff = jca (step 9, step 23) |- ( ( x ∈ A ∧ y ∈ B ) → ( { x } ∈ Pow ( A ∪ B ) ∧ { x , y } ∈ Pow ( A ∪ B ) ) ) ;;
	step 25 : wff = prex () |- { { x } , { x , y } } ∈ _V ;;
	step 26 : wff = elpw (step 25) |- ( { { x } , { x , y } } ∈ Pow Pow ( A ∪ B ) ↔ { { x } , { x , y } } ⊆ Pow ( A ∪ B ) ) ;;
	step 27 : wff = vex () |- x ∈ _V ;;
	step 28 : wff = vex () |- y ∈ _V ;;
	step 29 : wff = dfop (step 27, step 28) |- 〈 x , y 〉 = { { x } , { x , y } } ;;
	step 30 : wff = eleq1i (step 29) |- ( 〈 x , y 〉 ∈ Pow Pow ( A ∪ B ) ↔ { { x } , { x , y } } ∈ Pow Pow ( A ∪ B ) ) ;;
	step 31 : wff = snex () |- { x } ∈ _V ;;
	step 32 : wff = zfpair2 () |- { x , y } ∈ _V ;;
	step 33 : wff = prss (step 31, step 32) |- ( ( { x } ∈ Pow ( A ∪ B ) ∧ { x , y } ∈ Pow ( A ∪ B ) ) ↔ { { x } , { x , y } } ⊆ Pow ( A ∪ B ) ) ;;
	step 34 : wff = 3bitr4ri (step 26, step 30, step 33) |- ( ( { x } ∈ Pow ( A ∪ B ) ∧ { x , y } ∈ Pow ( A ∪ B ) ) ↔ 〈 x , y 〉 ∈ Pow Pow ( A ∪ B ) ) ;;
	step 35 : wff = sylib (step 24, step 34) |- ( ( x ∈ A ∧ y ∈ B ) → 〈 x , y 〉 ∈ Pow Pow ( A ∪ B ) ) ;;
	step 36 : wff = sylbi (step 2, step 35) |- ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ Pow Pow ( A ∪ B ) ) ;;
	step 37 : wff = relssi (step 1, step 36) |- ( A × B ) ⊆ Pow Pow ( A ∪ B ) ;;
	qed prop 1 = step 37 ;;
}

/*The double class union of a cross product is included in the union of its
     arguments.  (Contributed by NM, 16-Sep-2006.) */

theorem unixpss (A : class, B : class)  {
	prop 1 : wff = |- ⋃ ⋃ ( A × B ) ⊆ ( A ∪ B ) ;;
}

proof of unixpss {
	step 1 : wff = xpsspw () |- ( A × B ) ⊆ Pow Pow ( A ∪ B ) ;;
	step 2 : wff = uniss () |- ( ( A × B ) ⊆ Pow Pow ( A ∪ B ) → ⋃ ( A × B ) ⊆ ⋃ Pow Pow ( A ∪ B ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ⋃ ( A × B ) ⊆ ⋃ Pow Pow ( A ∪ B ) ;;
	step 4 : wff = unipw () |- ⋃ Pow Pow ( A ∪ B ) = Pow ( A ∪ B ) ;;
	step 5 : wff = sseqtri (step 3, step 4) |- ⋃ ( A × B ) ⊆ Pow ( A ∪ B ) ;;
	step 6 : wff = uniss () |- ( ⋃ ( A × B ) ⊆ Pow ( A ∪ B ) → ⋃ ⋃ ( A × B ) ⊆ ⋃ Pow ( A ∪ B ) ) ;;
	step 7 : wff = ax-mp (step 5, step 6) |- ⋃ ⋃ ( A × B ) ⊆ ⋃ Pow ( A ∪ B ) ;;
	step 8 : wff = unipw () |- ⋃ Pow ( A ∪ B ) = ( A ∪ B ) ;;
	step 9 : wff = sseqtri (step 7, step 8) |- ⋃ ⋃ ( A × B ) ⊆ ( A ∪ B ) ;;
	qed prop 1 = step 9 ;;
}

/*The cross product of two sets is a set.  Proposition 6.2 of
     [TakeutiZaring] p. 23.  See also ~ xpexgALT .  (Contributed by NM,
     14-Aug-1994.) */

theorem xpexg (A : class, B : class, V : class, W : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( A × B ) ∈ _V ) ;;
}

proof of xpexg {
	step 1 : wff = xpsspw () |- ( A × B ) ⊆ Pow Pow ( A ∪ B ) ;;
	step 2 : wff = unexg () |- ( ( A ∈ V ∧ B ∈ W ) → ( A ∪ B ) ∈ _V ) ;;
	step 3 : wff = pwexg () |- ( ( A ∪ B ) ∈ _V → Pow ( A ∪ B ) ∈ _V ) ;;
	step 4 : wff = pwexg () |- ( Pow ( A ∪ B ) ∈ _V → Pow Pow ( A ∪ B ) ∈ _V ) ;;
	step 5 : wff = 3syl (step 2, step 3, step 4) |- ( ( A ∈ V ∧ B ∈ W ) → Pow Pow ( A ∪ B ) ∈ _V ) ;;
	step 6 : wff = ssexg () |- ( ( ( A × B ) ⊆ Pow Pow ( A ∪ B ) ∧ Pow Pow ( A ∪ B ) ∈ _V ) → ( A × B ) ∈ _V ) ;;
	step 7 : wff = sylancr (step 1, step 5, step 6) |- ( ( A ∈ V ∧ B ∈ W ) → ( A × B ) ∈ _V ) ;;
	qed prop 1 = step 7 ;;
}

/*The cross product of two sets is a set.  Proposition 6.2 of
       [TakeutiZaring] p. 23.  (Contributed by NM, 14-Aug-1994.) */

theorem xpex (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A × B ) ∈ _V ;;
}

proof of xpex {
	step 1 : wff = xpexg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A × B ) ∈ _V ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A × B ) ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*The union of two relations is a relation.  Compare Exercise 5 of
     [TakeutiZaring] p. 25.  (Contributed by NM, 12-Aug-1994.) */

theorem relun (A : class, B : class)  {
	prop 1 : wff = |- ( Rel ( A ∪ B ) ↔ ( Rel A ∧ Rel B ) ) ;;
}

proof of relun {
	step 1 : wff = unss () |- ( ( A ⊆ ( _V × _V ) ∧ B ⊆ ( _V × _V ) ) ↔ ( A ∪ B ) ⊆ ( _V × _V ) ) ;;
	step 2 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 3 : wff = df-rel () |- ( Rel B ↔ B ⊆ ( _V × _V ) ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( Rel A ∧ Rel B ) ↔ ( A ⊆ ( _V × _V ) ∧ B ⊆ ( _V × _V ) ) ) ;;
	step 5 : wff = df-rel () |- ( Rel ( A ∪ B ) ↔ ( A ∪ B ) ⊆ ( _V × _V ) ) ;;
	step 6 : wff = 3bitr4ri (step 1, step 4, step 5) |- ( Rel ( A ∪ B ) ↔ ( Rel A ∧ Rel B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The intersection with a relation is a relation.  (Contributed by NM,
     16-Aug-1994.) */

theorem relin1 (A : class, B : class)  {
	prop 1 : wff = |- ( Rel A → Rel ( A ∩ B ) ) ;;
}

proof of relin1 {
	step 1 : wff = inss1 () |- ( A ∩ B ) ⊆ A ;;
	step 2 : wff = relss () |- ( ( A ∩ B ) ⊆ A → ( Rel A → Rel ( A ∩ B ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( Rel A → Rel ( A ∩ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The intersection with a relation is a relation.  (Contributed by NM,
     17-Jan-2006.) */

theorem relin2 (A : class, B : class)  {
	prop 1 : wff = |- ( Rel B → Rel ( A ∩ B ) ) ;;
}

proof of relin2 {
	step 1 : wff = inss2 () |- ( A ∩ B ) ⊆ B ;;
	step 2 : wff = relss () |- ( ( A ∩ B ) ⊆ B → ( Rel B → Rel ( A ∩ B ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( Rel B → Rel ( A ∩ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A difference cutting down a relation is a relation.  (Contributed by NM,
     31-Mar-1998.) */

theorem reldif (A : class, B : class)  {
	prop 1 : wff = |- ( Rel A → Rel ( A ∖ B ) ) ;;
}

proof of reldif {
	step 1 : wff = difss () |- ( A ∖ B ) ⊆ A ;;
	step 2 : wff = relss () |- ( ( A ∖ B ) ⊆ A → ( Rel A → Rel ( A ∖ B ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( Rel A → Rel ( A ∖ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*An indexed union is a relation iff each member of its indexed family is
       a relation.  (Contributed by NM, 19-Dec-2008.) */

theorem reliun (x : set, A : class, B : class) disjointed(y A, y B, x y) {
	prop 1 : wff = |- ( Rel ⋃_ x ∈ A B ↔ ∀ x ∈ A Rel B ) ;;
}

proof of reliun {
	var y : set;;
	step 1 : wff = df-iun () |- ⋃_ x ∈ A B = { y | ∃ x ∈ A y ∈ B } ;;
	step 2 : wff = releqi (step 1) |- ( Rel ⋃_ x ∈ A B ↔ Rel { y | ∃ x ∈ A y ∈ B } ) ;;
	step 3 : wff = df-rel () |- ( Rel { y | ∃ x ∈ A y ∈ B } ↔ { y | ∃ x ∈ A y ∈ B } ⊆ ( _V × _V ) ) ;;
	step 4 : wff = abss () |- ( { y | ∃ x ∈ A y ∈ B } ⊆ ( _V × _V ) ↔ ∀ y ( ∃ x ∈ A y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 5 : wff = df-rel () |- ( Rel B ↔ B ⊆ ( _V × _V ) ) ;;
	step 6 : wff = dfss2 () |- ( B ⊆ ( _V × _V ) ↔ ∀ y ( y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 7 : wff = bitri (step 5, step 6) |- ( Rel B ↔ ∀ y ( y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 8 : wff = ralbii (step 7) |- ( ∀ x ∈ A Rel B ↔ ∀ x ∈ A ∀ y ( y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 9 : wff = ralcom4 () |- ( ∀ x ∈ A ∀ y ( y ∈ B → y ∈ ( _V × _V ) ) ↔ ∀ y ∀ x ∈ A ( y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 10 : wff = r19.23v () |- ( ∀ x ∈ A ( y ∈ B → y ∈ ( _V × _V ) ) ↔ ( ∃ x ∈ A y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ y ∀ x ∈ A ( y ∈ B → y ∈ ( _V × _V ) ) ↔ ∀ y ( ∃ x ∈ A y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 12 : wff = 3bitri (step 8, step 9, step 11) |- ( ∀ x ∈ A Rel B ↔ ∀ y ( ∃ x ∈ A y ∈ B → y ∈ ( _V × _V ) ) ) ;;
	step 13 : wff = bitr4i (step 4, step 12) |- ( { y | ∃ x ∈ A y ∈ B } ⊆ ( _V × _V ) ↔ ∀ x ∈ A Rel B ) ;;
	step 14 : wff = 3bitri (step 2, step 3, step 13) |- ( Rel ⋃_ x ∈ A B ↔ ∀ x ∈ A Rel B ) ;;
	qed prop 1 = step 14 ;;
}

/*An indexed intersection is a relation if at least one of the member of the
     indexed family is a relation.  (Contributed by NM, 8-Mar-2014.) */

theorem reliin (x : set, A : class, B : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A Rel B → Rel ⋂_ x ∈ A B ) ;;
}

proof of reliin {
	step 1 : wff = iinss () |- ( ∃ x ∈ A B ⊆ ( _V × _V ) → ⋂_ x ∈ A B ⊆ ( _V × _V ) ) ;;
	step 2 : wff = df-rel () |- ( Rel B ↔ B ⊆ ( _V × _V ) ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ x ∈ A Rel B ↔ ∃ x ∈ A B ⊆ ( _V × _V ) ) ;;
	step 4 : wff = df-rel () |- ( Rel ⋂_ x ∈ A B ↔ ⋂_ x ∈ A B ⊆ ( _V × _V ) ) ;;
	step 5 : wff = 3imtr4i (step 1, step 3, step 4) |- ( ∃ x ∈ A Rel B → Rel ⋂_ x ∈ A B ) ;;
	qed prop 1 = step 5 ;;
}

/*The union of a class is a relation iff any member is a relation.
       Exercise 6 of [TakeutiZaring] p. 25 and its converse.  (Contributed by
       NM, 13-Aug-2004.) */

theorem reluni (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Rel ⋃ A ↔ ∀ x ∈ A Rel x ) ;;
}

proof of reluni {
	step 1 : wff = uniiun () |- ⋃ A = ⋃_ x ∈ A x ;;
	step 2 : wff = releqi (step 1) |- ( Rel ⋃ A ↔ Rel ⋃_ x ∈ A x ) ;;
	step 3 : wff = reliun () |- ( Rel ⋃_ x ∈ A x ↔ ∀ x ∈ A Rel x ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( Rel ⋃ A ↔ ∀ x ∈ A Rel x ) ;;
	qed prop 1 = step 4 ;;
}

/*The intersection of a class is a relation if at least one member is a
       relation.  (Contributed by NM, 8-Mar-2014.) */

theorem relint (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( ∃ x ∈ A Rel x → Rel ⋂ A ) ;;
}

proof of relint {
	step 1 : wff = reliin () |- ( ∃ x ∈ A Rel x → Rel ⋂_ x ∈ A x ) ;;
	step 2 : wff = intiin () |- ⋂ A = ⋂_ x ∈ A x ;;
	step 3 : wff = releqi (step 2) |- ( Rel ⋂ A ↔ Rel ⋂_ x ∈ A x ) ;;
	step 4 : wff = sylibr (step 1, step 3) |- ( ∃ x ∈ A Rel x → Rel ⋂ A ) ;;
	qed prop 1 = step 4 ;;
}

/*The empty set is a relation.  (Contributed by NM, 26-Apr-1998.) */

theorem rel0 ()  {
	prop 1 : wff = |- Rel ∅ ;;
}

proof of rel0 {
	step 1 : wff = 0ss () |- ∅ ⊆ ( _V × _V ) ;;
	step 2 : wff = df-rel () |- ( Rel ∅ ↔ ∅ ⊆ ( _V × _V ) ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- Rel ∅ ;;
	qed prop 1 = step 3 ;;
}

/*A class of ordered pairs is a relation.  (Contributed by Mario Carneiro,
       21-Dec-2013.) */

theorem relopabi (ph : wff, x : set, y : set, A : class) disjointed(ph z, x z, y z) {
	hyp 1 : wff = |- A = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- Rel A ;;
}

proof of relopabi {
	var z : set;;
	step 1 : wff = df-opab () |- { 〈 x , y 〉 | ph } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- A = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = opelvv (step 3, step 4) |- 〈 x , y 〉 ∈ ( _V × _V ) ;;
	step 6 : wff = eleq1 () |- ( z = 〈 x , y 〉 → ( z ∈ ( _V × _V ) ↔ 〈 x , y 〉 ∈ ( _V × _V ) ) ) ;;
	step 7 : wff = mpbiri (step 5, step 6) |- ( z = 〈 x , y 〉 → z ∈ ( _V × _V ) ) ;;
	step 8 : wff = adantr (step 7) |- ( ( z = 〈 x , y 〉 ∧ ph ) → z ∈ ( _V × _V ) ) ;;
	step 9 : wff = exlimivv (step 8) |- ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) → z ∈ ( _V × _V ) ) ;;
	step 10 : wff = abssi (step 9) |- { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ⊆ ( _V × _V ) ;;
	step 11 : wff = eqsstri (step 2, step 10) |- A ⊆ ( _V × _V ) ;;
	step 12 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 13 : wff = mpbir (step 11, step 12) |- Rel A ;;
	qed prop 1 = step 13 ;;
}

/*A class of ordered pairs is a relation.  (Contributed by NM, 8-Mar-1995.)
     (Unnecessary distinct variable restrictions were removed by Alan Sare,
     9-Jul-2013.)  (Proof shortened by Mario Carneiro, 21-Dec-2013.) */

theorem relopab (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- Rel { 〈 x , y 〉 | ph } ;;
}

proof of relopab {
	step 1 : wff = eqid () |- { 〈 x , y 〉 | ph } = { 〈 x , y 〉 | ph } ;;
	step 2 : wff = relopabi (step 1) |- Rel { 〈 x , y 〉 | ph } ;;
	qed prop 1 = step 2 ;;
}

/*The identity relation is a relation.  Part of Exercise 4.12(p) of
       [Mendelson] p. 235.  (Contributed by NM, 26-Apr-1998.)  (Revised by
       Mario Carneiro, 21-Dec-2013.) */

theorem reli () disjointed(x y, x y, x y, x y) {
	prop 1 : wff = |- Rel _I ;;
}

proof of reli {
	var x : set, y : set;;
	step 1 : wff = dfid3 () |- _I = { 〈 x , y 〉 | x = y } ;;
	step 2 : wff = relopabi (step 1) |- Rel _I ;;
	qed prop 1 = step 2 ;;
}

/*The membership relation is a relation.  (Contributed by NM,
       26-Apr-1998.)  (Revised by Mario Carneiro, 21-Dec-2013.) */

theorem rele () disjointed(x y, x y, x y, x y) {
	prop 1 : wff = |- Rel 𝛜 ;;
}

proof of rele {
	var x : set, y : set;;
	step 1 : wff = df-eprel () |- 𝛜 = { 〈 x , y 〉 | x ∈ y } ;;
	step 2 : wff = relopabi (step 1) |- Rel 𝛜 ;;
	qed prop 1 = step 2 ;;
}

/*A relation expressed as an ordered pair abstraction.  (Contributed by
       NM, 11-Dec-2006.) */

theorem opabid2 (x : set, y : set, A : class) disjointed(w x y z A, x y, x y, x y, z w, z w) {
	prop 1 : wff = |- ( Rel A → { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = A ) ;;
}

proof of opabid2 {
	var z : set, w : set;;
	step 1 : wff = vex () |- z ∈ _V ;;
	step 2 : wff = vex () |- w ∈ _V ;;
	step 3 : wff = opeq1 () |- ( x = z → 〈 x , y 〉 = 〈 z , y 〉 ) ;;
	step 4 : wff = eleq1d (step 3) |- ( x = z → ( 〈 x , y 〉 ∈ A ↔ 〈 z , y 〉 ∈ A ) ) ;;
	step 5 : wff = opeq2 () |- ( y = w → 〈 z , y 〉 = 〈 z , w 〉 ) ;;
	step 6 : wff = eleq1d (step 5) |- ( y = w → ( 〈 z , y 〉 ∈ A ↔ 〈 z , w 〉 ∈ A ) ) ;;
	step 7 : wff = opelopab (step 1, step 2, step 4, step 6) |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } ↔ 〈 z , w 〉 ∈ A ) ;;
	step 8 : wff = gen2 (step 7) |- ∀ z ∀ w ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } ↔ 〈 z , w 〉 ∈ A ) ;;
	step 9 : wff = relopab () |- Rel { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } ;;
	step 10 : wff = eqrel () |- ( ( Rel { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } ∧ Rel A ) → ( { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = A ↔ ∀ z ∀ w ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } ↔ 〈 z , w 〉 ∈ A ) ) ) ;;
	step 11 : wff = mpan (step 9, step 10) |- ( Rel A → ( { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = A ↔ ∀ z ∀ w ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } ↔ 〈 z , w 〉 ∈ A ) ) ) ;;
	step 12 : wff = mpbiri (step 8, step 11) |- ( Rel A → { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = A ) ;;
	qed prop 1 = step 12 ;;
}

/*Intersection of two ordered pair class abstractions.  (Contributed by
       NM, 30-Sep-2002.) */

theorem inopab (ph : wff, ps : wff, x : set, y : set) disjointed(w x y z, x y, x y, x y, ph z w, ps z w) {
	prop 1 : wff = |- ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | ps } ) = { 〈 x , y 〉 | ( ph ∧ ps ) } ;;
}

proof of inopab {
	var z : set, w : set;;
	step 1 : wff = relopab () |- Rel { 〈 x , y 〉 | ph } ;;
	step 2 : wff = relin1 () |- ( Rel { 〈 x , y 〉 | ph } → Rel ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | ps } ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- Rel ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | ps } ) ;;
	step 4 : wff = relopab () |- Rel { 〈 x , y 〉 | ( ph ∧ ps ) } ;;
	step 5 : wff = sban () |- ( [ w / y ] ( [ z / x ] ph ∧ [ z / x ] ps ) ↔ ( [ w / y ] [ z / x ] ph ∧ [ w / y ] [ z / x ] ps ) ) ;;
	step 6 : wff = sban () |- ( [ z / x ] ( ph ∧ ps ) ↔ ( [ z / x ] ph ∧ [ z / x ] ps ) ) ;;
	step 7 : wff = sbbii (step 6) |- ( [ w / y ] [ z / x ] ( ph ∧ ps ) ↔ [ w / y ] ( [ z / x ] ph ∧ [ z / x ] ps ) ) ;;
	step 8 : wff = opelopabsbOLD () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] [ z / x ] ph ) ;;
	step 9 : wff = opelopabsbOLD () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ↔ [ w / y ] [ z / x ] ps ) ;;
	step 10 : wff = anbi12i (step 8, step 9) |- ( ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ∧ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ) ↔ ( [ w / y ] [ z / x ] ph ∧ [ w / y ] [ z / x ] ps ) ) ;;
	step 11 : wff = 3bitr4ri (step 5, step 7, step 10) |- ( ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ∧ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ) ↔ [ w / y ] [ z / x ] ( ph ∧ ps ) ) ;;
	step 12 : wff = elin () |- ( 〈 z , w 〉 ∈ ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | ps } ) ↔ ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ∧ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ) ) ;;
	step 13 : wff = opelopabsbOLD () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ( ph ∧ ps ) } ↔ [ w / y ] [ z / x ] ( ph ∧ ps ) ) ;;
	step 14 : wff = 3bitr4i (step 11, step 12, step 13) |- ( 〈 z , w 〉 ∈ ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | ps } ) ↔ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ( ph ∧ ps ) } ) ;;
	step 15 : wff = eqrelriiv (step 3, step 4, step 14) |- ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | ps } ) = { 〈 x , y 〉 | ( ph ∧ ps ) } ;;
	qed prop 1 = step 15 ;;
}

/*The difference of two ordered-pair abstractions.  (Contributed by Stefan
       O'Rear, 17-Jan-2015.) */

theorem difopab (ph : wff, ps : wff, x : set, y : set) disjointed(w x y z, x y, x y, x y, ph z w, ps z w) {
	prop 1 : wff = |- ( { 〈 x , y 〉 | ph } ∖ { 〈 x , y 〉 | ps } ) = { 〈 x , y 〉 | ( ph ∧ ¬ ps ) } ;;
}

proof of difopab {
	var z : set, w : set;;
	step 1 : wff = relopab () |- Rel { 〈 x , y 〉 | ph } ;;
	step 2 : wff = reldif () |- ( Rel { 〈 x , y 〉 | ph } → Rel ( { 〈 x , y 〉 | ph } ∖ { 〈 x , y 〉 | ps } ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- Rel ( { 〈 x , y 〉 | ph } ∖ { 〈 x , y 〉 | ps } ) ;;
	step 4 : wff = relopab () |- Rel { 〈 x , y 〉 | ( ph ∧ ¬ ps ) } ;;
	step 5 : wff = sbcan () |- ( [. z / x ]. ( [. w / y ]. ph ∧ [. w / y ]. ¬ ps ) ↔ ( [. z / x ]. [. w / y ]. ph ∧ [. z / x ]. [. w / y ]. ¬ ps ) ) ;;
	step 6 : wff = sbcan () |- ( [. w / y ]. ( ph ∧ ¬ ps ) ↔ ( [. w / y ]. ph ∧ [. w / y ]. ¬ ps ) ) ;;
	step 7 : wff = sbcbii (step 6) |- ( [. z / x ]. [. w / y ]. ( ph ∧ ¬ ps ) ↔ [. z / x ]. ( [. w / y ]. ph ∧ [. w / y ]. ¬ ps ) ) ;;
	step 8 : wff = opelopabsb () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. z / x ]. [. w / y ]. ph ) ;;
	step 9 : wff = vex () |- z ∈ _V ;;
	step 10 : wff = sbcng () |- ( z ∈ _V → ( [. z / x ]. ¬ [. w / y ]. ps ↔ ¬ [. z / x ]. [. w / y ]. ps ) ) ;;
	step 11 : wff = ax-mp (step 9, step 10) |- ( [. z / x ]. ¬ [. w / y ]. ps ↔ ¬ [. z / x ]. [. w / y ]. ps ) ;;
	step 12 : wff = vex () |- w ∈ _V ;;
	step 13 : wff = sbcng () |- ( w ∈ _V → ( [. w / y ]. ¬ ps ↔ ¬ [. w / y ]. ps ) ) ;;
	step 14 : wff = ax-mp (step 12, step 13) |- ( [. w / y ]. ¬ ps ↔ ¬ [. w / y ]. ps ) ;;
	step 15 : wff = sbcbii (step 14) |- ( [. z / x ]. [. w / y ]. ¬ ps ↔ [. z / x ]. ¬ [. w / y ]. ps ) ;;
	step 16 : wff = opelopabsb () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ↔ [. z / x ]. [. w / y ]. ps ) ;;
	step 17 : wff = notbii (step 16) |- ( ¬ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ↔ ¬ [. z / x ]. [. w / y ]. ps ) ;;
	step 18 : wff = 3bitr4ri (step 11, step 15, step 17) |- ( ¬ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ↔ [. z / x ]. [. w / y ]. ¬ ps ) ;;
	step 19 : wff = anbi12i (step 8, step 18) |- ( ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ∧ ¬ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ) ↔ ( [. z / x ]. [. w / y ]. ph ∧ [. z / x ]. [. w / y ]. ¬ ps ) ) ;;
	step 20 : wff = 3bitr4ri (step 5, step 7, step 19) |- ( ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ∧ ¬ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ) ↔ [. z / x ]. [. w / y ]. ( ph ∧ ¬ ps ) ) ;;
	step 21 : wff = eldif () |- ( 〈 z , w 〉 ∈ ( { 〈 x , y 〉 | ph } ∖ { 〈 x , y 〉 | ps } ) ↔ ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ∧ ¬ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ps } ) ) ;;
	step 22 : wff = opelopabsb () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ( ph ∧ ¬ ps ) } ↔ [. z / x ]. [. w / y ]. ( ph ∧ ¬ ps ) ) ;;
	step 23 : wff = 3bitr4i (step 20, step 21, step 22) |- ( 〈 z , w 〉 ∈ ( { 〈 x , y 〉 | ph } ∖ { 〈 x , y 〉 | ps } ) ↔ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ( ph ∧ ¬ ps ) } ) ;;
	step 24 : wff = eqrelriiv (step 3, step 4, step 23) |- ( { 〈 x , y 〉 | ph } ∖ { 〈 x , y 〉 | ps } ) = { 〈 x , y 〉 | ( ph ∧ ¬ ps ) } ;;
	qed prop 1 = step 24 ;;
}

/*The intersection of two cross products.  Exercise 9 of [TakeutiZaring]
       p. 25.  (Contributed by NM, 3-Aug-1994.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem inxp (A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x y C, x y D) {
	prop 1 : wff = |- ( ( A × B ) ∩ ( C × D ) ) = ( ( A ∩ C ) × ( B ∩ D ) ) ;;
}

proof of inxp {
	var x : set, y : set;;
	step 1 : wff = inopab () |- ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ∩ { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ D ) } ) = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ( x ∈ C ∧ y ∈ D ) ) } ;;
	step 2 : wff = an4 () |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ( x ∈ C ∧ y ∈ D ) ) ↔ ( ( x ∈ A ∧ x ∈ C ) ∧ ( y ∈ B ∧ y ∈ D ) ) ) ;;
	step 3 : wff = elin () |- ( x ∈ ( A ∩ C ) ↔ ( x ∈ A ∧ x ∈ C ) ) ;;
	step 4 : wff = elin () |- ( y ∈ ( B ∩ D ) ↔ ( y ∈ B ∧ y ∈ D ) ) ;;
	step 5 : wff = anbi12i (step 3, step 4) |- ( ( x ∈ ( A ∩ C ) ∧ y ∈ ( B ∩ D ) ) ↔ ( ( x ∈ A ∧ x ∈ C ) ∧ ( y ∈ B ∧ y ∈ D ) ) ) ;;
	step 6 : wff = bitr4i (step 2, step 5) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ( x ∈ C ∧ y ∈ D ) ) ↔ ( x ∈ ( A ∩ C ) ∧ y ∈ ( B ∩ D ) ) ) ;;
	step 7 : wff = opabbii (step 6) |- { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ( x ∈ C ∧ y ∈ D ) ) } = { 〈 x , y 〉 | ( x ∈ ( A ∩ C ) ∧ y ∈ ( B ∩ D ) ) } ;;
	step 8 : wff = eqtri (step 1, step 7) |- ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ∩ { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ D ) } ) = { 〈 x , y 〉 | ( x ∈ ( A ∩ C ) ∧ y ∈ ( B ∩ D ) ) } ;;
	step 9 : wff = df-xp () |- ( A × B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ;;
	step 10 : wff = df-xp () |- ( C × D ) = { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ D ) } ;;
	step 11 : wff = ineq12i (step 9, step 10) |- ( ( A × B ) ∩ ( C × D ) ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ B ) } ∩ { 〈 x , y 〉 | ( x ∈ C ∧ y ∈ D ) } ) ;;
	step 12 : wff = df-xp () |- ( ( A ∩ C ) × ( B ∩ D ) ) = { 〈 x , y 〉 | ( x ∈ ( A ∩ C ) ∧ y ∈ ( B ∩ D ) ) } ;;
	step 13 : wff = 3eqtr4i (step 8, step 11, step 12) |- ( ( A × B ) ∩ ( C × D ) ) = ( ( A ∩ C ) × ( B ∩ D ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Distributive law for cross product over intersection.  Theorem 102 of
       [Suppes] p. 52.  (Contributed by NM, 26-Sep-2004.) */

theorem xpindi (A : class, B : class, C : class) disjointed(A, B, C) {
	prop 1 : wff = |- ( A × ( B ∩ C ) ) = ( ( A × B ) ∩ ( A × C ) ) ;;
}

proof of xpindi {
	step 1 : wff = inxp () |- ( ( A × B ) ∩ ( A × C ) ) = ( ( A ∩ A ) × ( B ∩ C ) ) ;;
	step 2 : wff = inidm () |- ( A ∩ A ) = A ;;
	step 3 : wff = xpeq1i (step 2) |- ( ( A ∩ A ) × ( B ∩ C ) ) = ( A × ( B ∩ C ) ) ;;
	step 4 : wff = eqtr2i (step 1, step 3) |- ( A × ( B ∩ C ) ) = ( ( A × B ) ∩ ( A × C ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Distributive law for cross product over intersection.  Similar to
       Theorem 102 of [Suppes] p. 52.  (Contributed by NM, 26-Sep-2004.) */

theorem xpindir (A : class, B : class, C : class) disjointed(A, B, C) {
	prop 1 : wff = |- ( ( A ∩ B ) × C ) = ( ( A × C ) ∩ ( B × C ) ) ;;
}

proof of xpindir {
	step 1 : wff = inxp () |- ( ( A × C ) ∩ ( B × C ) ) = ( ( A ∩ B ) × ( C ∩ C ) ) ;;
	step 2 : wff = inidm () |- ( C ∩ C ) = C ;;
	step 3 : wff = xpeq2i (step 2) |- ( ( A ∩ B ) × ( C ∩ C ) ) = ( ( A ∩ B ) × C ) ;;
	step 4 : wff = eqtr2i (step 1, step 3) |- ( ( A ∩ B ) × C ) = ( ( A × C ) ∩ ( B × C ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Distributive law for cross product over indexed intersection.
       (Contributed by Mario Carneiro, 21-Mar-2015.) */

theorem xpiindi (x : set, A : class, B : class, C : class) disjointed(x y z A, x y z C, y z B) {
	prop 1 : wff = |- ( A ≠ ∅ → ( C × ⋂_ x ∈ A B ) = ⋂_ x ∈ A ( C × B ) ) ;;
}

proof of xpiindi {
	var y : set, z : set;;
	step 1 : wff = relxp () |- Rel ( C × B ) ;;
	step 2 : wff = rgenw (step 1) |- ∀ x ∈ A Rel ( C × B ) ;;
	step 3 : wff = r19.2z () |- ( ( A ≠ ∅ ∧ ∀ x ∈ A Rel ( C × B ) ) → ∃ x ∈ A Rel ( C × B ) ) ;;
	step 4 : wff = mpan2 (step 2, step 3) |- ( A ≠ ∅ → ∃ x ∈ A Rel ( C × B ) ) ;;
	step 5 : wff = reliin () |- ( ∃ x ∈ A Rel ( C × B ) → Rel ⋂_ x ∈ A ( C × B ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A ≠ ∅ → Rel ⋂_ x ∈ A ( C × B ) ) ;;
	step 7 : wff = relxp () |- Rel ( C × ⋂_ x ∈ A B ) ;;
	step 8 : wff = jctil (step 6, step 7) |- ( A ≠ ∅ → ( Rel ( C × ⋂_ x ∈ A B ) ∧ Rel ⋂_ x ∈ A ( C × B ) ) ) ;;
	step 9 : wff = r19.28zv () |- ( A ≠ ∅ → ( ∀ x ∈ A ( y ∈ C ∧ z ∈ B ) ↔ ( y ∈ C ∧ ∀ x ∈ A z ∈ B ) ) ) ;;
	step 10 : wff = bicomd (step 9) |- ( A ≠ ∅ → ( ( y ∈ C ∧ ∀ x ∈ A z ∈ B ) ↔ ∀ x ∈ A ( y ∈ C ∧ z ∈ B ) ) ) ;;
	step 11 : wff = vex () |- z ∈ _V ;;
	step 12 : wff = eliin () |- ( z ∈ _V → ( z ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A z ∈ B ) ) ;;
	step 13 : wff = ax-mp (step 11, step 12) |- ( z ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A z ∈ B ) ;;
	step 14 : wff = anbi2i (step 13) |- ( ( y ∈ C ∧ z ∈ ⋂_ x ∈ A B ) ↔ ( y ∈ C ∧ ∀ x ∈ A z ∈ B ) ) ;;
	step 15 : wff = opelxp () |- ( 〈 y , z 〉 ∈ ( C × B ) ↔ ( y ∈ C ∧ z ∈ B ) ) ;;
	step 16 : wff = ralbii (step 15) |- ( ∀ x ∈ A 〈 y , z 〉 ∈ ( C × B ) ↔ ∀ x ∈ A ( y ∈ C ∧ z ∈ B ) ) ;;
	step 17 : wff = 3bitr4g (step 10, step 14, step 16) |- ( A ≠ ∅ → ( ( y ∈ C ∧ z ∈ ⋂_ x ∈ A B ) ↔ ∀ x ∈ A 〈 y , z 〉 ∈ ( C × B ) ) ) ;;
	step 18 : wff = opelxp () |- ( 〈 y , z 〉 ∈ ( C × ⋂_ x ∈ A B ) ↔ ( y ∈ C ∧ z ∈ ⋂_ x ∈ A B ) ) ;;
	step 19 : wff = opex () |- 〈 y , z 〉 ∈ _V ;;
	step 20 : wff = eliin () |- ( 〈 y , z 〉 ∈ _V → ( 〈 y , z 〉 ∈ ⋂_ x ∈ A ( C × B ) ↔ ∀ x ∈ A 〈 y , z 〉 ∈ ( C × B ) ) ) ;;
	step 21 : wff = ax-mp (step 19, step 20) |- ( 〈 y , z 〉 ∈ ⋂_ x ∈ A ( C × B ) ↔ ∀ x ∈ A 〈 y , z 〉 ∈ ( C × B ) ) ;;
	step 22 : wff = 3bitr4g (step 17, step 18, step 21) |- ( A ≠ ∅ → ( 〈 y , z 〉 ∈ ( C × ⋂_ x ∈ A B ) ↔ 〈 y , z 〉 ∈ ⋂_ x ∈ A ( C × B ) ) ) ;;
	step 23 : wff = eqrelrdv2 (step 22) |- ( ( ( Rel ( C × ⋂_ x ∈ A B ) ∧ Rel ⋂_ x ∈ A ( C × B ) ) ∧ A ≠ ∅ ) → ( C × ⋂_ x ∈ A B ) = ⋂_ x ∈ A ( C × B ) ) ;;
	step 24 : wff = mpancom (step 8, step 23) |- ( A ≠ ∅ → ( C × ⋂_ x ∈ A B ) = ⋂_ x ∈ A ( C × B ) ) ;;
	qed prop 1 = step 24 ;;
}

/*Distributive law for cross product over relativized indexed
       intersection.  (Contributed by Mario Carneiro, 21-Mar-2015.) */

theorem xpriindi (x : set, A : class, B : class, C : class, D : class) disjointed(x A, x C, B) {
	prop 1 : wff = |- ( C × ( D ∩ ⋂_ x ∈ A B ) ) = ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) ;;
}

proof of xpriindi {
	step 1 : wff = iineq1 () |- ( A = ∅ → ⋂_ x ∈ A B = ⋂_ x ∈ ∅ B ) ;;
	step 2 : wff = 0iin () |- ⋂_ x ∈ ∅ B = _V ;;
	step 3 : wff = syl6eq (step 1, step 2) |- ( A = ∅ → ⋂_ x ∈ A B = _V ) ;;
	step 4 : wff = ineq2d (step 3) |- ( A = ∅ → ( D ∩ ⋂_ x ∈ A B ) = ( D ∩ _V ) ) ;;
	step 5 : wff = inv1 () |- ( D ∩ _V ) = D ;;
	step 6 : wff = syl6eq (step 4, step 5) |- ( A = ∅ → ( D ∩ ⋂_ x ∈ A B ) = D ) ;;
	step 7 : wff = xpeq2d (step 6) |- ( A = ∅ → ( C × ( D ∩ ⋂_ x ∈ A B ) ) = ( C × D ) ) ;;
	step 8 : wff = iineq1 () |- ( A = ∅ → ⋂_ x ∈ A ( C × B ) = ⋂_ x ∈ ∅ ( C × B ) ) ;;
	step 9 : wff = 0iin () |- ⋂_ x ∈ ∅ ( C × B ) = _V ;;
	step 10 : wff = syl6eq (step 8, step 9) |- ( A = ∅ → ⋂_ x ∈ A ( C × B ) = _V ) ;;
	step 11 : wff = ineq2d (step 10) |- ( A = ∅ → ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) = ( ( C × D ) ∩ _V ) ) ;;
	step 12 : wff = inv1 () |- ( ( C × D ) ∩ _V ) = ( C × D ) ;;
	step 13 : wff = syl6eq (step 11, step 12) |- ( A = ∅ → ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) = ( C × D ) ) ;;
	step 14 : wff = eqtr4d (step 7, step 13) |- ( A = ∅ → ( C × ( D ∩ ⋂_ x ∈ A B ) ) = ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) ) ;;
	step 15 : wff = xpindi () |- ( C × ( D ∩ ⋂_ x ∈ A B ) ) = ( ( C × D ) ∩ ( C × ⋂_ x ∈ A B ) ) ;;
	step 16 : wff = xpiindi () |- ( A ≠ ∅ → ( C × ⋂_ x ∈ A B ) = ⋂_ x ∈ A ( C × B ) ) ;;
	step 17 : wff = ineq2d (step 16) |- ( A ≠ ∅ → ( ( C × D ) ∩ ( C × ⋂_ x ∈ A B ) ) = ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) ) ;;
	step 18 : wff = syl5eq (step 15, step 17) |- ( A ≠ ∅ → ( C × ( D ∩ ⋂_ x ∈ A B ) ) = ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) ) ;;
	step 19 : wff = pm2.61ine (step 14, step 18) |- ( C × ( D ∩ ⋂_ x ∈ A B ) ) = ( ( C × D ) ∩ ⋂_ x ∈ A ( C × B ) ) ;;
	qed prop 1 = step 19 ;;
}

/*Membership in a union of cross products.  Analogue of ~ elxp for
       nonconstant ` B ( x ) ` .  (Contributed by Mario Carneiro,
       29-Dec-2014.) */

theorem eliunxp (x : set, y : set, A : class, B : class, C : class) disjointed(y A, y B, x y C, x y, x, x) {
	prop 1 : wff = |- ( C ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ∃ x ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
}

proof of eliunxp {
	step 1 : wff = relxp () |- Rel ( { x } × B ) ;;
	step 2 : wff = rgenw (step 1) |- ∀ x ∈ A Rel ( { x } × B ) ;;
	step 3 : wff = reliun () |- ( Rel ⋃_ x ∈ A ( { x } × B ) ↔ ∀ x ∈ A Rel ( { x } × B ) ) ;;
	step 4 : wff = mpbir (step 2, step 3) |- Rel ⋃_ x ∈ A ( { x } × B ) ;;
	step 5 : wff = elrel () |- ( ( Rel ⋃_ x ∈ A ( { x } × B ) ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) → ∃ x ∃ y C = 〈 x , y 〉 ) ;;
	step 6 : wff = mpan (step 4, step 5) |- ( C ∈ ⋃_ x ∈ A ( { x } × B ) → ∃ x ∃ y C = 〈 x , y 〉 ) ;;
	step 7 : wff = pm4.71ri (step 6) |- ( C ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( ∃ x ∃ y C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ) ;;
	step 8 : wff = nfiu1 () |- F/_ x ⋃_ x ∈ A ( { x } × B ) ;;
	step 9 : wff = nfel2 (step 8) |- F/ x C ∈ ⋃_ x ∈ A ( { x } × B ) ;;
	step 10 : wff = 19.41 (step 9) |- ( ∃ x ( ∃ y C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ↔ ( ∃ x ∃ y C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ) ;;
	step 11 : wff = 19.41v () |- ( ∃ y ( C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ↔ ( ∃ y C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ) ;;
	step 12 : wff = eleq1 () |- ( C = 〈 x , y 〉 → ( C ∈ ⋃_ x ∈ A ( { x } × B ) ↔ 〈 x , y 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ) ) ;;
	step 13 : wff = opeliunxp () |- ( 〈 x , y 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 14 : wff = syl6bb (step 12, step 13) |- ( C = 〈 x , y 〉 → ( C ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 15 : wff = pm5.32i (step 14) |- ( ( C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ↔ ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 16 : wff = exbii (step 15) |- ( ∃ y ( C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ↔ ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 17 : wff = bitr3i (step 11, step 16) |- ( ( ∃ y C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ↔ ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 18 : wff = exbii (step 17) |- ( ∃ x ( ∃ y C = 〈 x , y 〉 ∧ C ∈ ⋃_ x ∈ A ( { x } × B ) ) ↔ ∃ x ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 19 : wff = 3bitr2i (step 7, step 10, step 18) |- ( C ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ∃ x ∃ y ( C = 〈 x , y 〉 ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	qed prop 1 = step 19 ;;
}

/*Membership in a union of cross products.  (Contributed by Mario
       Carneiro, 14-Feb-2015.) */

theorem opeliunxp2 (x : set, A : class, B : class, C : class, D : class, E : class) disjointed(A, B, x C, x D, x E, x, x A) {
	hyp 1 : wff = |- ( x = C → B = E ) ;;
	-----------------------
	prop 1 : wff = |- ( 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( C ∈ A ∧ D ∈ E ) ) ;;
}

proof of opeliunxp2 {
	step 1 : wff = df-br () |- ( C ⋃_ x ∈ A ( { x } × B ) D ↔ 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ) ;;
	step 2 : wff = relxp () |- Rel ( { x } × B ) ;;
	step 3 : wff = rgenw (step 2) |- ∀ x ∈ A Rel ( { x } × B ) ;;
	step 4 : wff = reliun () |- ( Rel ⋃_ x ∈ A ( { x } × B ) ↔ ∀ x ∈ A Rel ( { x } × B ) ) ;;
	step 5 : wff = mpbir (step 3, step 4) |- Rel ⋃_ x ∈ A ( { x } × B ) ;;
	step 6 : wff = brrelexi (step 5) |- ( C ⋃_ x ∈ A ( { x } × B ) D → C ∈ _V ) ;;
	step 7 : wff = sylbir (step 1, step 6) |- ( 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) → C ∈ _V ) ;;
	step 8 : wff = elex () |- ( C ∈ A → C ∈ _V ) ;;
	step 9 : wff = adantr (step 8) |- ( ( C ∈ A ∧ D ∈ E ) → C ∈ _V ) ;;
	step 10 : wff = nfcv () |- F/_ x C ;;
	step 11 : wff = nfiu1 () |- F/_ x ⋃_ x ∈ A ( { x } × B ) ;;
	step 12 : wff = nfel2 (step 11) |- F/ x 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ;;
	step 13 : wff = nfv () |- F/ x ( C ∈ A ∧ D ∈ E ) ;;
	step 14 : wff = nfbi (step 12, step 13) |- F/ x ( 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( C ∈ A ∧ D ∈ E ) ) ;;
	step 15 : wff = opeq1 () |- ( x = C → 〈 x , D 〉 = 〈 C , D 〉 ) ;;
	step 16 : wff = eleq1d (step 15) |- ( x = C → ( 〈 x , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ) ) ;;
	step 17 : wff = eleq1 () |- ( x = C → ( x ∈ A ↔ C ∈ A ) ) ;;
	step 18 : wff = eleq2d (hyp 1) |- ( x = C → ( D ∈ B ↔ D ∈ E ) ) ;;
	step 19 : wff = anbi12d (step 17, step 18) |- ( x = C → ( ( x ∈ A ∧ D ∈ B ) ↔ ( C ∈ A ∧ D ∈ E ) ) ) ;;
	step 20 : wff = bibi12d (step 16, step 19) |- ( x = C → ( ( 〈 x , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( x ∈ A ∧ D ∈ B ) ) ↔ ( 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( C ∈ A ∧ D ∈ E ) ) ) ) ;;
	step 21 : wff = opeliunxp () |- ( 〈 x , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( x ∈ A ∧ D ∈ B ) ) ;;
	step 22 : wff = vtoclgf (step 10, step 14, step 20, step 21) |- ( C ∈ _V → ( 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( C ∈ A ∧ D ∈ E ) ) ) ;;
	step 23 : wff = pm5.21nii (step 7, step 9, step 22) |- ( 〈 C , D 〉 ∈ ⋃_ x ∈ A ( { x } × B ) ↔ ( C ∈ A ∧ D ∈ E ) ) ;;
	qed prop 1 = step 23 ;;
}

/*Write a double restricted quantification as one universal quantifier.
       In this version of ~ ralxp , ` B ( y ) ` is not assumed to be constant.
       (Contributed by Mario Carneiro, 29-Dec-2014.) */

theorem raliunxp (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x z B, y z ph, x ps) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
}

proof of raliunxp {
	step 1 : wff = eliunxp () |- ( x ∈ ⋃_ y ∈ A ( { y } × B ) ↔ ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) ) ;;
	step 2 : wff = imbi1i (step 1) |- ( ( x ∈ ⋃_ y ∈ A ( { y } × B ) → ph ) ↔ ( ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ) ;;
	step 3 : wff = 19.23vv () |- ( ∀ y ∀ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ( ∃ y ∃ z ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( ( x ∈ ⋃_ y ∈ A ( { y } × B ) → ph ) ↔ ∀ y ∀ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ x ( x ∈ ⋃_ y ∈ A ( { y } × B ) → ph ) ↔ ∀ x ∀ y ∀ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ) ;;
	step 6 : wff = alrot3 () |- ( ∀ x ∀ y ∀ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ∀ y ∀ z ∀ x ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ) ;;
	step 7 : wff = impexp () |- ( ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ( x = 〈 y , z 〉 → ( ( y ∈ A ∧ z ∈ B ) → ph ) ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ∀ x ( x = 〈 y , z 〉 → ( ( y ∈ A ∧ z ∈ B ) → ph ) ) ) ;;
	step 9 : wff = opex () |- 〈 y , z 〉 ∈ _V ;;
	step 10 : wff = imbi2d (hyp 1) |- ( x = 〈 y , z 〉 → ( ( ( y ∈ A ∧ z ∈ B ) → ph ) ↔ ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ) ;;
	step 11 : wff = ceqsalv (step 9, step 10) |- ( ∀ x ( x = 〈 y , z 〉 → ( ( y ∈ A ∧ z ∈ B ) → ph ) ) ↔ ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ;;
	step 12 : wff = bitri (step 8, step 11) |- ( ∀ x ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ;;
	step 13 : wff = 2albii (step 12) |- ( ∀ y ∀ z ∀ x ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ∀ y ∀ z ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ;;
	step 14 : wff = bitri (step 6, step 13) |- ( ∀ x ∀ y ∀ z ( ( x = 〈 y , z 〉 ∧ ( y ∈ A ∧ z ∈ B ) ) → ph ) ↔ ∀ y ∀ z ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ;;
	step 15 : wff = bitri (step 5, step 14) |- ( ∀ x ( x ∈ ⋃_ y ∈ A ( { y } × B ) → ph ) ↔ ∀ y ∀ z ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ;;
	step 16 : wff = df-ral () |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∀ x ( x ∈ ⋃_ y ∈ A ( { y } × B ) → ph ) ) ;;
	step 17 : wff = r2al () |- ( ∀ y ∈ A ∀ z ∈ B ps ↔ ∀ y ∀ z ( ( y ∈ A ∧ z ∈ B ) → ps ) ) ;;
	step 18 : wff = 3bitr4i (step 15, step 16, step 17) |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
	qed prop 1 = step 18 ;;
}

/*Write a double restricted quantification as one universal quantifier.
       In this version of ~ rexxp , ` B ( y ) ` is not assumed to be constant.
       (Contributed by Mario Carneiro, 14-Feb-2015.) */

theorem rexiunxp (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x z B, y z ph, x ps) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
}

proof of rexiunxp {
	step 1 : wff = notbid (hyp 1) |- ( x = 〈 y , z 〉 → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = raliunxp (step 1) |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ¬ ph ↔ ∀ y ∈ A ∀ z ∈ B ¬ ps ) ;;
	step 3 : wff = ralnex () |- ( ∀ z ∈ B ¬ ps ↔ ¬ ∃ z ∈ B ps ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ y ∈ A ∀ z ∈ B ¬ ps ↔ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ¬ ph ↔ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 6 : wff = notbii (step 5) |- ( ¬ ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ¬ ph ↔ ¬ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 7 : wff = dfrex2 () |- ( ∃ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ¬ ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ¬ ph ) ;;
	step 8 : wff = dfrex2 () |- ( ∃ y ∈ A ∃ z ∈ B ps ↔ ¬ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 9 : wff = 3bitr4i (step 6, step 7, step 8) |- ( ∃ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
	qed prop 1 = step 9 ;;
}

/*Universal quantification restricted to a cross product is equivalent to
       a double restricted quantification.  The hypothesis specifies an
       implicit substitution.  (Contributed by NM, 7-Feb-2004.)  (Revised by
       Mario Carneiro, 29-Dec-2014.) */

theorem ralxp (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x z B, y z ph, x ps, y B) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ ( A × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
}

proof of ralxp {
	step 1 : wff = iunxpconst () |- ⋃_ y ∈ A ( { y } × B ) = ( A × B ) ;;
	step 2 : wff = raleqi (step 1) |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∀ x ∈ ( A × B ) ph ) ;;
	step 3 : wff = raliunxp (hyp 1) |- ( ∀ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
	step 4 : wff = bitr3i (step 2, step 3) |- ( ∀ x ∈ ( A × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Existential quantification restricted to a cross product is equivalent
       to a double restricted quantification.  (Contributed by NM,
       11-Nov-1995.)  (Revised by Mario Carneiro, 14-Feb-2015.) */

theorem rexxp (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y z A, x z B, y z ph, x ps, y B) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ ( A × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
}

proof of rexxp {
	step 1 : wff = iunxpconst () |- ⋃_ y ∈ A ( { y } × B ) = ( A × B ) ;;
	step 2 : wff = rexeqi (step 1) |- ( ∃ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∃ x ∈ ( A × B ) ph ) ;;
	step 3 : wff = rexiunxp (hyp 1) |- ( ∃ x ∈ ⋃_ y ∈ A ( { y } × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
	step 4 : wff = bitr3i (step 2, step 3) |- ( ∃ x ∈ ( A × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Disjoint union is a subset of a cross product.  (Contributed by Stefan
       O'Rear, 21-Nov-2014.) */

theorem djussxp (x : set, A : class, B : class) disjointed(x A) {
	prop 1 : wff = |- ⋃_ x ∈ A ( { x } × B ) ⊆ ( A × _V ) ;;
}

proof of djussxp {
	step 1 : wff = iunss () |- ( ⋃_ x ∈ A ( { x } × B ) ⊆ ( A × _V ) ↔ ∀ x ∈ A ( { x } × B ) ⊆ ( A × _V ) ) ;;
	step 2 : wff = snssi () |- ( x ∈ A → { x } ⊆ A ) ;;
	step 3 : wff = ssv () |- B ⊆ _V ;;
	step 4 : wff = xpss12 () |- ( ( { x } ⊆ A ∧ B ⊆ _V ) → ( { x } × B ) ⊆ ( A × _V ) ) ;;
	step 5 : wff = sylancl (step 2, step 3, step 4) |- ( x ∈ A → ( { x } × B ) ⊆ ( A × _V ) ) ;;
	step 6 : wff = mprgbir (step 1, step 5) |- ⋃_ x ∈ A ( { x } × B ) ⊆ ( A × _V ) ;;
	qed prop 1 = step 6 ;;
}

/*Version of ~ ralxp with bound-variable hypotheses.  (Contributed by NM,
       18-Aug-2006.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem ralxpf (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(u v w x y A, u v w x y z B, u v w ph, u v w ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ z ph ;;
	hyp 3 : wff = |- F/ x ps ;;
	hyp 4 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ ( A × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
}

proof of ralxpf {
	var w : set, v : set, u : set;;
	step 1 : wff = cbvralsv () |- ( ∀ x ∈ ( A × B ) ph ↔ ∀ w ∈ ( A × B ) [ w / x ] ph ) ;;
	step 2 : wff = cbvralsv () |- ( ∀ z ∈ B [ u / y ] ps ↔ ∀ v ∈ B [ v / z ] [ u / y ] ps ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ u ∈ A ∀ z ∈ B [ u / y ] ps ↔ ∀ u ∈ A ∀ v ∈ B [ v / z ] [ u / y ] ps ) ;;
	step 4 : wff = nfv () |- F/ u ∀ z ∈ B ps ;;
	step 5 : wff = nfcv () |- F/_ y B ;;
	step 6 : wff = nfs1v () |- F/ y [ u / y ] ps ;;
	step 7 : wff = nfral (step 5, step 6) |- F/ y ∀ z ∈ B [ u / y ] ps ;;
	step 8 : wff = sbequ12 () |- ( y = u → ( ps ↔ [ u / y ] ps ) ) ;;
	step 9 : wff = ralbidv (step 8) |- ( y = u → ( ∀ z ∈ B ps ↔ ∀ z ∈ B [ u / y ] ps ) ) ;;
	step 10 : wff = cbvral (step 4, step 7, step 9) |- ( ∀ y ∈ A ∀ z ∈ B ps ↔ ∀ u ∈ A ∀ z ∈ B [ u / y ] ps ) ;;
	step 11 : wff = vex () |- u ∈ _V ;;
	step 12 : wff = vex () |- v ∈ _V ;;
	step 13 : wff = eqvinop (step 11, step 12) |- ( w = 〈 u , v 〉 ↔ ∃ y ∃ z ( w = 〈 y , z 〉 ∧ 〈 y , z 〉 = 〈 u , v 〉 ) ) ;;
	step 14 : wff = nfsb (hyp 1) |- F/ y [ w / x ] ph ;;
	step 15 : wff = nfs1v () |- F/ y [ u / y ] ps ;;
	step 16 : wff = nfsb (step 15) |- F/ y [ v / z ] [ u / y ] ps ;;
	step 17 : wff = nfbi (step 14, step 16) |- F/ y ( [ w / x ] ph ↔ [ v / z ] [ u / y ] ps ) ;;
	step 18 : wff = nfsb (hyp 2) |- F/ z [ w / x ] ph ;;
	step 19 : wff = nfs1v () |- F/ z [ v / z ] [ u / y ] ps ;;
	step 20 : wff = nfbi (step 18, step 19) |- F/ z ( [ w / x ] ph ↔ [ v / z ] [ u / y ] ps ) ;;
	step 21 : wff = sbhypf (hyp 3, hyp 4) |- ( w = 〈 y , z 〉 → ( [ w / x ] ph ↔ ps ) ) ;;
	step 22 : wff = vex () |- y ∈ _V ;;
	step 23 : wff = vex () |- z ∈ _V ;;
	step 24 : wff = opth (step 22, step 23) |- ( 〈 y , z 〉 = 〈 u , v 〉 ↔ ( y = u ∧ z = v ) ) ;;
	step 25 : wff = sbequ12 () |- ( y = u → ( ps ↔ [ u / y ] ps ) ) ;;
	step 26 : wff = sbequ12 () |- ( z = v → ( [ u / y ] ps ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 27 : wff = sylan9bb (step 25, step 26) |- ( ( y = u ∧ z = v ) → ( ps ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 28 : wff = sylbi (step 24, step 27) |- ( 〈 y , z 〉 = 〈 u , v 〉 → ( ps ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 29 : wff = sylan9bb (step 21, step 28) |- ( ( w = 〈 y , z 〉 ∧ 〈 y , z 〉 = 〈 u , v 〉 ) → ( [ w / x ] ph ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 30 : wff = exlimi (step 20, step 29) |- ( ∃ z ( w = 〈 y , z 〉 ∧ 〈 y , z 〉 = 〈 u , v 〉 ) → ( [ w / x ] ph ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 31 : wff = exlimi (step 17, step 30) |- ( ∃ y ∃ z ( w = 〈 y , z 〉 ∧ 〈 y , z 〉 = 〈 u , v 〉 ) → ( [ w / x ] ph ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 32 : wff = sylbi (step 13, step 31) |- ( w = 〈 u , v 〉 → ( [ w / x ] ph ↔ [ v / z ] [ u / y ] ps ) ) ;;
	step 33 : wff = ralxp (step 32) |- ( ∀ w ∈ ( A × B ) [ w / x ] ph ↔ ∀ u ∈ A ∀ v ∈ B [ v / z ] [ u / y ] ps ) ;;
	step 34 : wff = 3bitr4ri (step 3, step 10, step 33) |- ( ∀ w ∈ ( A × B ) [ w / x ] ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
	step 35 : wff = bitri (step 1, step 34) |- ( ∀ x ∈ ( A × B ) ph ↔ ∀ y ∈ A ∀ z ∈ B ps ) ;;
	qed prop 1 = step 35 ;;
}

/*Version of ~ rexxp with bound-variable hypotheses.  (Contributed by NM,
       19-Dec-2008.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem rexxpf (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(x y A, x y z B, ph, ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ z ph ;;
	hyp 3 : wff = |- F/ x ps ;;
	hyp 4 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ ( A × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
}

proof of rexxpf {
	step 1 : wff = nfn (hyp 1) |- F/ y ¬ ph ;;
	step 2 : wff = nfn (hyp 2) |- F/ z ¬ ph ;;
	step 3 : wff = nfn (hyp 3) |- F/ x ¬ ps ;;
	step 4 : wff = notbid (hyp 4) |- ( x = 〈 y , z 〉 → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 5 : wff = ralxpf (step 1, step 2, step 3, step 4) |- ( ∀ x ∈ ( A × B ) ¬ ph ↔ ∀ y ∈ A ∀ z ∈ B ¬ ps ) ;;
	step 6 : wff = ralnex () |- ( ∀ z ∈ B ¬ ps ↔ ¬ ∃ z ∈ B ps ) ;;
	step 7 : wff = ralbii (step 6) |- ( ∀ y ∈ A ∀ z ∈ B ¬ ps ↔ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 8 : wff = bitri (step 5, step 7) |- ( ∀ x ∈ ( A × B ) ¬ ph ↔ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 9 : wff = notbii (step 8) |- ( ¬ ∀ x ∈ ( A × B ) ¬ ph ↔ ¬ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 10 : wff = dfrex2 () |- ( ∃ x ∈ ( A × B ) ph ↔ ¬ ∀ x ∈ ( A × B ) ¬ ph ) ;;
	step 11 : wff = dfrex2 () |- ( ∃ y ∈ A ∃ z ∈ B ps ↔ ¬ ∀ y ∈ A ¬ ∃ z ∈ B ps ) ;;
	step 12 : wff = 3bitr4i (step 9, step 10, step 11) |- ( ∃ x ∈ ( A × B ) ph ↔ ∃ y ∈ A ∃ z ∈ B ps ) ;;
	qed prop 1 = step 12 ;;
}

/*Indexed union on a cross product is equals a double indexed union.  The
       hypothesis specifies an implicit substitution.  (Contributed by NM,
       19-Dec-2008.) */

theorem iunxpf (x : set, y : set, z : set, A : class, B : class, C : class, D : class) disjointed(w x y A, w x y z B, w C, w D) {
	hyp 1 : wff = |- F/_ y C ;;
	hyp 2 : wff = |- F/_ z C ;;
	hyp 3 : wff = |- F/_ x D ;;
	hyp 4 : wff = |- ( x = 〈 y , z 〉 → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ⋃_ x ∈ ( A × B ) C = ⋃_ y ∈ A ⋃_ z ∈ B D ;;
}

proof of iunxpf {
	var w : set;;
	step 1 : wff = nfcri (hyp 1) |- F/ y w ∈ C ;;
	step 2 : wff = nfcri (hyp 2) |- F/ z w ∈ C ;;
	step 3 : wff = nfcri (hyp 3) |- F/ x w ∈ D ;;
	step 4 : wff = eleq2d (hyp 4) |- ( x = 〈 y , z 〉 → ( w ∈ C ↔ w ∈ D ) ) ;;
	step 5 : wff = rexxpf (step 1, step 2, step 3, step 4) |- ( ∃ x ∈ ( A × B ) w ∈ C ↔ ∃ y ∈ A ∃ z ∈ B w ∈ D ) ;;
	step 6 : wff = eliun () |- ( w ∈ ⋃_ x ∈ ( A × B ) C ↔ ∃ x ∈ ( A × B ) w ∈ C ) ;;
	step 7 : wff = eliun () |- ( w ∈ ⋃_ y ∈ A ⋃_ z ∈ B D ↔ ∃ y ∈ A w ∈ ⋃_ z ∈ B D ) ;;
	step 8 : wff = eliun () |- ( w ∈ ⋃_ z ∈ B D ↔ ∃ z ∈ B w ∈ D ) ;;
	step 9 : wff = rexbii (step 8) |- ( ∃ y ∈ A w ∈ ⋃_ z ∈ B D ↔ ∃ y ∈ A ∃ z ∈ B w ∈ D ) ;;
	step 10 : wff = bitri (step 7, step 9) |- ( w ∈ ⋃_ y ∈ A ⋃_ z ∈ B D ↔ ∃ y ∈ A ∃ z ∈ B w ∈ D ) ;;
	step 11 : wff = 3bitr4i (step 5, step 6, step 10) |- ( w ∈ ⋃_ x ∈ ( A × B ) C ↔ w ∈ ⋃_ y ∈ A ⋃_ z ∈ B D ) ;;
	step 12 : wff = eqriv (step 11) |- ⋃_ x ∈ ( A × B ) C = ⋃_ y ∈ A ⋃_ z ∈ B D ;;
	qed prop 1 = step 12 ;;
}

/*Deduce equality of a relation and an ordered-pair class builder.
       Compare ~ abbi2dv .  (Contributed by NM, 24-Feb-2014.) */

theorem opabbi2dv (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, x y ph) {
	hyp 1 : wff = |- Rel A ;;
	hyp 2 : wff = |- ( ph → ( 〈 x , y 〉 ∈ A ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = { 〈 x , y 〉 | ps } ) ;;
}

proof of opabbi2dv {
	step 1 : wff = opabid2 () |- ( Rel A → { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = A ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = A ;;
	step 3 : wff = opabbidv (hyp 2) |- ( ph → { 〈 x , y 〉 | 〈 x , y 〉 ∈ A } = { 〈 x , y 〉 | ps } ) ;;
	step 4 : wff = syl5eqr (step 2, step 3) |- ( ph → A = { 〈 x , y 〉 | ps } ) ;;
	qed prop 1 = step 4 ;;
}

/*A necessary and sufficient condition for a Kuratowski ordered pair to be
       a relation.  (Contributed by NM, 3-Jun-2008.) */

theorem relop (x : set, y : set, A : class, B : class) disjointed(v w x y z A, v w x y z B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( Rel 〈 A , B 〉 ↔ ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ;;
}

proof of relop {
	var z : set, w : set, v : set;;
	step 1 : wff = df-rel () |- ( Rel 〈 A , B 〉 ↔ 〈 A , B 〉 ⊆ ( _V × _V ) ) ;;
	step 2 : wff = dfss2 () |- ( 〈 A , B 〉 ⊆ ( _V × _V ) ↔ ∀ z ( z ∈ 〈 A , B 〉 → z ∈ ( _V × _V ) ) ) ;;
	step 3 : wff = vex () |- z ∈ _V ;;
	step 4 : wff = elop (step 3, hyp 1, hyp 2) |- ( z ∈ 〈 A , B 〉 ↔ ( z = { A } ∨ z = { A , B } ) ) ;;
	step 5 : wff = elvv () |- ( z ∈ ( _V × _V ) ↔ ∃ x ∃ y z = 〈 x , y 〉 ) ;;
	step 6 : wff = imbi12i (step 4, step 5) |- ( ( z ∈ 〈 A , B 〉 → z ∈ ( _V × _V ) ) ↔ ( ( z = { A } ∨ z = { A , B } ) → ∃ x ∃ y z = 〈 x , y 〉 ) ) ;;
	step 7 : wff = jaob () |- ( ( ( z = { A } ∨ z = { A , B } ) → ∃ x ∃ y z = 〈 x , y 〉 ) ↔ ( ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ( z ∈ 〈 A , B 〉 → z ∈ ( _V × _V ) ) ↔ ( ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ) ;;
	step 9 : wff = albii (step 8) |- ( ∀ z ( z ∈ 〈 A , B 〉 → z ∈ ( _V × _V ) ) ↔ ∀ z ( ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ) ;;
	step 10 : wff = 19.26 () |- ( ∀ z ( ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ↔ ( ∀ z ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ∀ z ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ) ;;
	step 11 : wff = bitri (step 9, step 10) |- ( ∀ z ( z ∈ 〈 A , B 〉 → z ∈ ( _V × _V ) ) ↔ ( ∀ z ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ∀ z ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ) ;;
	step 12 : wff = bitri (step 2, step 11) |- ( 〈 A , B 〉 ⊆ ( _V × _V ) ↔ ( ∀ z ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ∀ z ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) ) ;;
	step 13 : wff = snex () |- { A } ∈ _V ;;
	step 14 : wff = eqeq1 () |- ( z = { A } → ( z = { A } ↔ { A } = { A } ) ) ;;
	step 15 : wff = eqeq1 () |- ( z = { A } → ( z = 〈 x , y 〉 ↔ { A } = 〈 x , y 〉 ) ) ;;
	step 16 : wff = eqcom () |- ( { A } = 〈 x , y 〉 ↔ 〈 x , y 〉 = { A } ) ;;
	step 17 : wff = vex () |- x ∈ _V ;;
	step 18 : wff = vex () |- y ∈ _V ;;
	step 19 : wff = opeqsn (step 17, step 18, hyp 1) |- ( 〈 x , y 〉 = { A } ↔ ( x = y ∧ A = { x } ) ) ;;
	step 20 : wff = bitri (step 16, step 19) |- ( { A } = 〈 x , y 〉 ↔ ( x = y ∧ A = { x } ) ) ;;
	step 21 : wff = syl6bb (step 15, step 20) |- ( z = { A } → ( z = 〈 x , y 〉 ↔ ( x = y ∧ A = { x } ) ) ) ;;
	step 22 : wff = 2exbidv (step 21) |- ( z = { A } → ( ∃ x ∃ y z = 〈 x , y 〉 ↔ ∃ x ∃ y ( x = y ∧ A = { x } ) ) ) ;;
	step 23 : wff = imbi12d (step 14, step 22) |- ( z = { A } → ( ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ↔ ( { A } = { A } → ∃ x ∃ y ( x = y ∧ A = { x } ) ) ) ) ;;
	step 24 : wff = spcv (step 13, step 23) |- ( ∀ z ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) → ( { A } = { A } → ∃ x ∃ y ( x = y ∧ A = { x } ) ) ) ;;
	step 25 : wff = sneq () |- ( w = x → { w } = { x } ) ;;
	step 26 : wff = eqeq2d (step 25) |- ( w = x → ( A = { w } ↔ A = { x } ) ) ;;
	step 27 : wff = cbvexv (step 26) |- ( ∃ w A = { w } ↔ ∃ x A = { x } ) ;;
	step 28 : wff = a9ev () |- ∃ y y = x ;;
	step 29 : wff = equcom () |- ( y = x ↔ x = y ) ;;
	step 30 : wff = exbii (step 29) |- ( ∃ y y = x ↔ ∃ y x = y ) ;;
	step 31 : wff = mpbi (step 28, step 30) |- ∃ y x = y ;;
	step 32 : wff = 19.41v () |- ( ∃ y ( x = y ∧ A = { x } ) ↔ ( ∃ y x = y ∧ A = { x } ) ) ;;
	step 33 : wff = mpbiran (step 31, step 32) |- ( ∃ y ( x = y ∧ A = { x } ) ↔ A = { x } ) ;;
	step 34 : wff = exbii (step 33) |- ( ∃ x ∃ y ( x = y ∧ A = { x } ) ↔ ∃ x A = { x } ) ;;
	step 35 : wff = eqid () |- { A } = { A } ;;
	step 36 : wff = a1bi (step 35) |- ( ∃ x ∃ y ( x = y ∧ A = { x } ) ↔ ( { A } = { A } → ∃ x ∃ y ( x = y ∧ A = { x } ) ) ) ;;
	step 37 : wff = 3bitr2ri (step 27, step 34, step 36) |- ( ( { A } = { A } → ∃ x ∃ y ( x = y ∧ A = { x } ) ) ↔ ∃ w A = { w } ) ;;
	step 38 : wff = sylib (step 24, step 37) |- ( ∀ z ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) → ∃ w A = { w } ) ;;
	step 39 : wff = eqid () |- { A , B } = { A , B } ;;
	step 40 : wff = prex () |- { A , B } ∈ _V ;;
	step 41 : wff = eqeq1 () |- ( z = { A , B } → ( z = { A , B } ↔ { A , B } = { A , B } ) ) ;;
	step 42 : wff = eqeq1 () |- ( z = { A , B } → ( z = 〈 x , y 〉 ↔ { A , B } = 〈 x , y 〉 ) ) ;;
	step 43 : wff = 2exbidv (step 42) |- ( z = { A , B } → ( ∃ x ∃ y z = 〈 x , y 〉 ↔ ∃ x ∃ y { A , B } = 〈 x , y 〉 ) ) ;;
	step 44 : wff = imbi12d (step 41, step 43) |- ( z = { A , B } → ( ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ↔ ( { A , B } = { A , B } → ∃ x ∃ y { A , B } = 〈 x , y 〉 ) ) ) ;;
	step 45 : wff = spcv (step 40, step 44) |- ( ∀ z ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) → ( { A , B } = { A , B } → ∃ x ∃ y { A , B } = 〈 x , y 〉 ) ) ;;
	step 46 : wff = mpi (step 39, step 45) |- ( ∀ z ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) → ∃ x ∃ y { A , B } = 〈 x , y 〉 ) ;;
	step 47 : wff = eqcom () |- ( { A , B } = 〈 x , y 〉 ↔ 〈 x , y 〉 = { A , B } ) ;;
	step 48 : wff = vex () |- x ∈ _V ;;
	step 49 : wff = vex () |- y ∈ _V ;;
	step 50 : wff = opeqpr (step 48, step 49, hyp 1, hyp 2) |- ( 〈 x , y 〉 = { A , B } ↔ ( ( A = { x } ∧ B = { x , y } ) ∨ ( A = { x , y } ∧ B = { x } ) ) ) ;;
	step 51 : wff = bitri (step 47, step 50) |- ( { A , B } = 〈 x , y 〉 ↔ ( ( A = { x } ∧ B = { x , y } ) ∨ ( A = { x , y } ∧ B = { x } ) ) ) ;;
	step 52 : wff = idd () |- ( A = { w } → ( ( A = { x } ∧ B = { x , y } ) → ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 53 : wff = eqtr2 () |- ( ( A = { x , y } ∧ A = { w } ) → { x , y } = { w } ) ;;
	step 54 : wff = vex () |- x ∈ _V ;;
	step 55 : wff = vex () |- y ∈ _V ;;
	step 56 : wff = vex () |- w ∈ _V ;;
	step 57 : wff = preqsn (step 54, step 55, step 56) |- ( { x , y } = { w } ↔ ( x = y ∧ y = w ) ) ;;
	step 58 : wff = simplbi (step 57) |- ( { x , y } = { w } → x = y ) ;;
	step 59 : wff = syl (step 53, step 58) |- ( ( A = { x , y } ∧ A = { w } ) → x = y ) ;;
	step 60 : wff = dfsn2 () |- { x } = { x , x } ;;
	step 61 : wff = preq2 () |- ( x = y → { x , x } = { x , y } ) ;;
	step 62 : wff = syl5req (step 60, step 61) |- ( x = y → { x , y } = { x } ) ;;
	step 63 : wff = eqeq2d (step 62) |- ( x = y → ( A = { x , y } ↔ A = { x } ) ) ;;
	step 64 : wff = dfsn2 () |- { x } = { x , x } ;;
	step 65 : wff = preq2 () |- ( x = y → { x , x } = { x , y } ) ;;
	step 66 : wff = syl5eq (step 64, step 65) |- ( x = y → { x } = { x , y } ) ;;
	step 67 : wff = eqeq2d (step 66) |- ( x = y → ( B = { x } ↔ B = { x , y } ) ) ;;
	step 68 : wff = anbi12d (step 63, step 67) |- ( x = y → ( ( A = { x , y } ∧ B = { x } ) ↔ ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 69 : wff = biimpd (step 68) |- ( x = y → ( ( A = { x , y } ∧ B = { x } ) → ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 70 : wff = exp3a (step 69) |- ( x = y → ( A = { x , y } → ( B = { x } → ( A = { x } ∧ B = { x , y } ) ) ) ) ;;
	step 71 : wff = com12 (step 70) |- ( A = { x , y } → ( x = y → ( B = { x } → ( A = { x } ∧ B = { x , y } ) ) ) ) ;;
	step 72 : wff = adantr (step 71) |- ( ( A = { x , y } ∧ A = { w } ) → ( x = y → ( B = { x } → ( A = { x } ∧ B = { x , y } ) ) ) ) ;;
	step 73 : wff = mpd (step 59, step 72) |- ( ( A = { x , y } ∧ A = { w } ) → ( B = { x } → ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 74 : wff = expcom (step 73) |- ( A = { w } → ( A = { x , y } → ( B = { x } → ( A = { x } ∧ B = { x , y } ) ) ) ) ;;
	step 75 : wff = imp3a (step 74) |- ( A = { w } → ( ( A = { x , y } ∧ B = { x } ) → ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 76 : wff = jaod (step 52, step 75) |- ( A = { w } → ( ( ( A = { x } ∧ B = { x , y } ) ∨ ( A = { x , y } ∧ B = { x } ) ) → ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 77 : wff = syl5bi (step 51, step 76) |- ( A = { w } → ( { A , B } = 〈 x , y 〉 → ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 78 : wff = 2eximdv (step 77) |- ( A = { w } → ( ∃ x ∃ y { A , B } = 〈 x , y 〉 → ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 79 : wff = exlimiv (step 78) |- ( ∃ w A = { w } → ( ∃ x ∃ y { A , B } = 〈 x , y 〉 → ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ) ;;
	step 80 : wff = imp (step 79) |- ( ( ∃ w A = { w } ∧ ∃ x ∃ y { A , B } = 〈 x , y 〉 ) → ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ;;
	step 81 : wff = syl2an (step 38, step 46, step 80) |- ( ( ∀ z ( z = { A } → ∃ x ∃ y z = 〈 x , y 〉 ) ∧ ∀ z ( z = { A , B } → ∃ x ∃ y z = 〈 x , y 〉 ) ) → ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ;;
	step 82 : wff = sylbi (step 12, step 81) |- ( 〈 A , B 〉 ⊆ ( _V × _V ) → ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ;;
	step 83 : wff = simpr () |- ( ( A = { x } ∧ z = { A } ) → z = { A } ) ;;
	step 84 : wff = equid () |- x = x ;;
	step 85 : wff = jctl (step 84) |- ( A = { x } → ( x = x ∧ A = { x } ) ) ;;
	step 86 : wff = vex () |- x ∈ _V ;;
	step 87 : wff = vex () |- x ∈ _V ;;
	step 88 : wff = opeqsn (step 86, step 87, hyp 1) |- ( 〈 x , x 〉 = { A } ↔ ( x = x ∧ A = { x } ) ) ;;
	step 89 : wff = sylibr (step 85, step 88) |- ( A = { x } → 〈 x , x 〉 = { A } ) ;;
	step 90 : wff = adantr (step 89) |- ( ( A = { x } ∧ z = { A } ) → 〈 x , x 〉 = { A } ) ;;
	step 91 : wff = eqtr4d (step 83, step 90) |- ( ( A = { x } ∧ z = { A } ) → z = 〈 x , x 〉 ) ;;
	step 92 : wff = vex () |- x ∈ _V ;;
	step 93 : wff = vex () |- x ∈ _V ;;
	step 94 : wff = opeq12 () |- ( ( w = x ∧ v = x ) → 〈 w , v 〉 = 〈 x , x 〉 ) ;;
	step 95 : wff = eqeq2d (step 94) |- ( ( w = x ∧ v = x ) → ( z = 〈 w , v 〉 ↔ z = 〈 x , x 〉 ) ) ;;
	step 96 : wff = spc2ev (step 92, step 93, step 95) |- ( z = 〈 x , x 〉 → ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 97 : wff = syl (step 91, step 96) |- ( ( A = { x } ∧ z = { A } ) → ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 98 : wff = adantlr (step 97) |- ( ( ( A = { x } ∧ B = { x , y } ) ∧ z = { A } ) → ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 99 : wff = preq12 () |- ( ( A = { x } ∧ B = { x , y } ) → { A , B } = { { x } , { x , y } } ) ;;
	step 100 : wff = eqeq2d (step 99) |- ( ( A = { x } ∧ B = { x , y } ) → ( z = { A , B } ↔ z = { { x } , { x , y } } ) ) ;;
	step 101 : wff = biimpa (step 100) |- ( ( ( A = { x } ∧ B = { x , y } ) ∧ z = { A , B } ) → z = { { x } , { x , y } } ) ;;
	step 102 : wff = vex () |- x ∈ _V ;;
	step 103 : wff = vex () |- y ∈ _V ;;
	step 104 : wff = dfop (step 102, step 103) |- 〈 x , y 〉 = { { x } , { x , y } } ;;
	step 105 : wff = syl6eqr (step 101, step 104) |- ( ( ( A = { x } ∧ B = { x , y } ) ∧ z = { A , B } ) → z = 〈 x , y 〉 ) ;;
	step 106 : wff = vex () |- x ∈ _V ;;
	step 107 : wff = vex () |- y ∈ _V ;;
	step 108 : wff = opeq12 () |- ( ( w = x ∧ v = y ) → 〈 w , v 〉 = 〈 x , y 〉 ) ;;
	step 109 : wff = eqeq2d (step 108) |- ( ( w = x ∧ v = y ) → ( z = 〈 w , v 〉 ↔ z = 〈 x , y 〉 ) ) ;;
	step 110 : wff = spc2ev (step 106, step 107, step 109) |- ( z = 〈 x , y 〉 → ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 111 : wff = syl (step 105, step 110) |- ( ( ( A = { x } ∧ B = { x , y } ) ∧ z = { A , B } ) → ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 112 : wff = jaodan (step 98, step 111) |- ( ( ( A = { x } ∧ B = { x , y } ) ∧ ( z = { A } ∨ z = { A , B } ) ) → ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 113 : wff = ex (step 112) |- ( ( A = { x } ∧ B = { x , y } ) → ( ( z = { A } ∨ z = { A , B } ) → ∃ w ∃ v z = 〈 w , v 〉 ) ) ;;
	step 114 : wff = vex () |- z ∈ _V ;;
	step 115 : wff = elop (step 114, hyp 1, hyp 2) |- ( z ∈ 〈 A , B 〉 ↔ ( z = { A } ∨ z = { A , B } ) ) ;;
	step 116 : wff = elvv () |- ( z ∈ ( _V × _V ) ↔ ∃ w ∃ v z = 〈 w , v 〉 ) ;;
	step 117 : wff = 3imtr4g (step 113, step 115, step 116) |- ( ( A = { x } ∧ B = { x , y } ) → ( z ∈ 〈 A , B 〉 → z ∈ ( _V × _V ) ) ) ;;
	step 118 : wff = ssrdv (step 117) |- ( ( A = { x } ∧ B = { x , y } ) → 〈 A , B 〉 ⊆ ( _V × _V ) ) ;;
	step 119 : wff = exlimivv (step 118) |- ( ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) → 〈 A , B 〉 ⊆ ( _V × _V ) ) ;;
	step 120 : wff = impbii (step 82, step 119) |- ( 〈 A , B 〉 ⊆ ( _V × _V ) ↔ ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ;;
	step 121 : wff = bitri (step 1, step 120) |- ( Rel 〈 A , B 〉 ↔ ∃ x ∃ y ( A = { x } ∧ B = { x , y } ) ) ;;
	qed prop 1 = step 121 ;;
}

/*For sets, the identity relation is the same as equality.  (Contributed
       by NM, 30-Apr-2004.)  (Proof shortened by Andrew Salmon,
       27-Aug-2011.) */

theorem ideqg (A : class, B : class, V : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( B ∈ V → ( A _I B ↔ A = B ) ) ;;
}

proof of ideqg {
	var x : set, y : set;;
	step 1 : wff = reli () |- Rel _I ;;
	step 2 : wff = brrelexi (step 1) |- ( A _I B → A ∈ _V ) ;;
	step 3 : wff = adantl (step 2) |- ( ( B ∈ V ∧ A _I B ) → A ∈ _V ) ;;
	step 4 : wff = simpl () |- ( ( B ∈ V ∧ A _I B ) → B ∈ V ) ;;
	step 5 : wff = jca (step 3, step 4) |- ( ( B ∈ V ∧ A _I B ) → ( A ∈ _V ∧ B ∈ V ) ) ;;
	step 6 : wff = eleq1 () |- ( A = B → ( A ∈ V ↔ B ∈ V ) ) ;;
	step 7 : wff = biimparc (step 6) |- ( ( B ∈ V ∧ A = B ) → A ∈ V ) ;;
	step 8 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( ( B ∈ V ∧ A = B ) → A ∈ _V ) ;;
	step 10 : wff = simpl () |- ( ( B ∈ V ∧ A = B ) → B ∈ V ) ;;
	step 11 : wff = jca (step 9, step 10) |- ( ( B ∈ V ∧ A = B ) → ( A ∈ _V ∧ B ∈ V ) ) ;;
	step 12 : wff = eqeq1 () |- ( x = A → ( x = y ↔ A = y ) ) ;;
	step 13 : wff = eqeq2 () |- ( y = B → ( A = y ↔ A = B ) ) ;;
	step 14 : wff = df-id () |- _I = { 〈 x , y 〉 | x = y } ;;
	step 15 : wff = brabg (step 12, step 13, step 14) |- ( ( A ∈ _V ∧ B ∈ V ) → ( A _I B ↔ A = B ) ) ;;
	step 16 : wff = pm5.21nd (step 5, step 11, step 15) |- ( B ∈ V → ( A _I B ↔ A = B ) ) ;;
	qed prop 1 = step 16 ;;
}

/*For sets, the identity relation is the same as equality.  (Contributed
       by NM, 13-Aug-1995.) */

theorem ideq (A : class, B : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A _I B ↔ A = B ) ;;
}

proof of ideq {
	step 1 : wff = ideqg () |- ( B ∈ _V → ( A _I B ↔ A = B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A _I B ↔ A = B ) ;;
	qed prop 1 = step 2 ;;
}

/*A set is identical to itself.  (Contributed by NM, 28-May-2008.)  (Proof
       shortened by Andrew Salmon, 27-Aug-2011.) */

theorem ididg (A : class, V : class) disjointed(A) {
	prop 1 : wff = |- ( A ∈ V → A _I A ) ;;
}

proof of ididg {
	step 1 : wff = eqid () |- A = A ;;
	step 2 : wff = ideqg () |- ( A ∈ V → ( A _I A ↔ A = A ) ) ;;
	step 3 : wff = mpbiri (step 1, step 2) |- ( A ∈ V → A _I A ) ;;
	qed prop 1 = step 3 ;;
}

/*Two ways of expressing set existence.  (Contributed by NM, 16-Feb-2008.)
     (Proof shortened by Andrew Salmon, 27-Aug-2011.)  (Revised by Mario
     Carneiro, 26-Apr-2015.) */

theorem issetid (A : class)  {
	prop 1 : wff = |- ( A ∈ _V ↔ A _I A ) ;;
}

proof of issetid {
	step 1 : wff = ididg () |- ( A ∈ _V → A _I A ) ;;
	step 2 : wff = reli () |- Rel _I ;;
	step 3 : wff = brrelexi (step 2) |- ( A _I A → A ∈ _V ) ;;
	step 4 : wff = impbii (step 1, step 3) |- ( A ∈ _V ↔ A _I A ) ;;
	qed prop 1 = step 4 ;;
}

/*Subclass theorem for composition.  (Contributed by FL, 30-Dec-2010.) */

theorem coss1 (A : class, B : class, C : class) disjointed(A x y z, B x y z, C x y z) {
	prop 1 : wff = |- ( A ⊆ B → ( A ∘ C ) ⊆ ( B ∘ C ) ) ;;
}

proof of coss1 {
	var x : set, y : set, z : set;;
	step 1 : wff = id () |- ( A ⊆ B → A ⊆ B ) ;;
	step 2 : wff = ssbrd (step 1) |- ( A ⊆ B → ( y A z → y B z ) ) ;;
	step 3 : wff = anim2d (step 2) |- ( A ⊆ B → ( ( x C y ∧ y A z ) → ( x C y ∧ y B z ) ) ) ;;
	step 4 : wff = eximdv (step 3) |- ( A ⊆ B → ( ∃ y ( x C y ∧ y A z ) → ∃ y ( x C y ∧ y B z ) ) ) ;;
	step 5 : wff = ssopab2dv (step 4) |- ( A ⊆ B → { 〈 x , z 〉 | ∃ y ( x C y ∧ y A z ) } ⊆ { 〈 x , z 〉 | ∃ y ( x C y ∧ y B z ) } ) ;;
	step 6 : wff = df-co () |- ( A ∘ C ) = { 〈 x , z 〉 | ∃ y ( x C y ∧ y A z ) } ;;
	step 7 : wff = df-co () |- ( B ∘ C ) = { 〈 x , z 〉 | ∃ y ( x C y ∧ y B z ) } ;;
	step 8 : wff = 3sstr4g (step 5, step 6, step 7) |- ( A ⊆ B → ( A ∘ C ) ⊆ ( B ∘ C ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Subclass theorem for composition.  (Contributed by NM, 5-Apr-2013.) */

theorem coss2 (A : class, B : class, C : class) disjointed(A x y z, B x y z, C x y z) {
	prop 1 : wff = |- ( A ⊆ B → ( C ∘ A ) ⊆ ( C ∘ B ) ) ;;
}

proof of coss2 {
	var x : set, y : set, z : set;;
	step 1 : wff = id () |- ( A ⊆ B → A ⊆ B ) ;;
	step 2 : wff = ssbrd (step 1) |- ( A ⊆ B → ( x A y → x B y ) ) ;;
	step 3 : wff = anim1d (step 2) |- ( A ⊆ B → ( ( x A y ∧ y C z ) → ( x B y ∧ y C z ) ) ) ;;
	step 4 : wff = eximdv (step 3) |- ( A ⊆ B → ( ∃ y ( x A y ∧ y C z ) → ∃ y ( x B y ∧ y C z ) ) ) ;;
	step 5 : wff = ssopab2dv (step 4) |- ( A ⊆ B → { 〈 x , z 〉 | ∃ y ( x A y ∧ y C z ) } ⊆ { 〈 x , z 〉 | ∃ y ( x B y ∧ y C z ) } ) ;;
	step 6 : wff = df-co () |- ( C ∘ A ) = { 〈 x , z 〉 | ∃ y ( x A y ∧ y C z ) } ;;
	step 7 : wff = df-co () |- ( C ∘ B ) = { 〈 x , z 〉 | ∃ y ( x B y ∧ y C z ) } ;;
	step 8 : wff = 3sstr4g (step 5, step 6, step 7) |- ( A ⊆ B → ( C ∘ A ) ⊆ ( C ∘ B ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Equality theorem for composition of two classes.  (Contributed by NM,
     3-Jan-1997.) */

theorem coeq1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( A ∘ C ) = ( B ∘ C ) ) ;;
}

proof of coeq1 {
	step 1 : wff = coss1 () |- ( A ⊆ B → ( A ∘ C ) ⊆ ( B ∘ C ) ) ;;
	step 2 : wff = coss1 () |- ( B ⊆ A → ( B ∘ C ) ⊆ ( A ∘ C ) ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) → ( ( A ∘ C ) ⊆ ( B ∘ C ) ∧ ( B ∘ C ) ⊆ ( A ∘ C ) ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = eqss () |- ( ( A ∘ C ) = ( B ∘ C ) ↔ ( ( A ∘ C ) ⊆ ( B ∘ C ) ∧ ( B ∘ C ) ⊆ ( A ∘ C ) ) ) ;;
	step 6 : wff = 3imtr4i (step 3, step 4, step 5) |- ( A = B → ( A ∘ C ) = ( B ∘ C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality theorem for composition of two classes.  (Contributed by NM,
     3-Jan-1997.) */

theorem coeq2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( C ∘ A ) = ( C ∘ B ) ) ;;
}

proof of coeq2 {
	step 1 : wff = coss2 () |- ( A ⊆ B → ( C ∘ A ) ⊆ ( C ∘ B ) ) ;;
	step 2 : wff = coss2 () |- ( B ⊆ A → ( C ∘ B ) ⊆ ( C ∘ A ) ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) → ( ( C ∘ A ) ⊆ ( C ∘ B ) ∧ ( C ∘ B ) ⊆ ( C ∘ A ) ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = eqss () |- ( ( C ∘ A ) = ( C ∘ B ) ↔ ( ( C ∘ A ) ⊆ ( C ∘ B ) ∧ ( C ∘ B ) ⊆ ( C ∘ A ) ) ) ;;
	step 6 : wff = 3imtr4i (step 3, step 4, step 5) |- ( A = B → ( C ∘ A ) = ( C ∘ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality inference for composition of two classes.  (Contributed by NM,
       16-Nov-2000.) */

theorem coeq1i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A ∘ C ) = ( B ∘ C ) ;;
}

proof of coeq1i {
	step 1 : wff = coeq1 () |- ( A = B → ( A ∘ C ) = ( B ∘ C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∘ C ) = ( B ∘ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for composition of two classes.  (Contributed by NM,
       16-Nov-2000.) */

theorem coeq2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C ∘ A ) = ( C ∘ B ) ;;
}

proof of coeq2i {
	step 1 : wff = coeq2 () |- ( A = B → ( C ∘ A ) = ( C ∘ B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C ∘ A ) = ( C ∘ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for composition of two classes.  (Contributed by NM,
       16-Nov-2000.) */

theorem coeq1d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ∘ C ) = ( B ∘ C ) ) ;;
}

proof of coeq1d {
	step 1 : wff = coeq1 () |- ( A = B → ( A ∘ C ) = ( B ∘ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A ∘ C ) = ( B ∘ C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for composition of two classes.  (Contributed by NM,
       16-Nov-2000.) */

theorem coeq2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C ∘ A ) = ( C ∘ B ) ) ;;
}

proof of coeq2d {
	step 1 : wff = coeq2 () |- ( A = B → ( C ∘ A ) = ( C ∘ B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C ∘ A ) = ( C ∘ B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for composition of two classes.  (Contributed by FL,
       7-Jun-2012.) */

theorem coeq12i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A ∘ C ) = ( B ∘ D ) ;;
}

proof of coeq12i {
	step 1 : wff = coeq1i (hyp 1) |- ( A ∘ C ) = ( B ∘ C ) ;;
	step 2 : wff = coeq2i (hyp 2) |- ( B ∘ C ) = ( B ∘ D ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( A ∘ C ) = ( B ∘ D ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for composition of two classes.  (Contributed by FL,
       7-Jun-2012.) */

theorem coeq12d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ∘ C ) = ( B ∘ D ) ) ;;
}

proof of coeq12d {
	step 1 : wff = coeq1d (hyp 1) |- ( ph → ( A ∘ C ) = ( B ∘ C ) ) ;;
	step 2 : wff = coeq2d (hyp 2) |- ( ph → ( B ∘ C ) = ( B ∘ D ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → ( A ∘ C ) = ( B ∘ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for function value.  (Contributed by
       NM, 1-Sep-1999.) */

theorem nfco (x : set, A : class, B : class) disjointed(w x y z, y z w A, y z w B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x ( A ∘ B ) ;;
}

proof of nfco {
	var y : set, z : set, w : set;;
	step 1 : wff = df-co () |- ( A ∘ B ) = { 〈 y , z 〉 | ∃ w ( y B w ∧ w A z ) } ;;
	step 2 : wff = nfcv () |- F/_ x y ;;
	step 3 : wff = nfcv () |- F/_ x w ;;
	step 4 : wff = nfbr (step 2, hyp 2, step 3) |- F/ x y B w ;;
	step 5 : wff = nfcv () |- F/_ x w ;;
	step 6 : wff = nfcv () |- F/_ x z ;;
	step 7 : wff = nfbr (step 5, hyp 1, step 6) |- F/ x w A z ;;
	step 8 : wff = nfan (step 4, step 7) |- F/ x ( y B w ∧ w A z ) ;;
	step 9 : wff = nfex (step 8) |- F/ x ∃ w ( y B w ∧ w A z ) ;;
	step 10 : wff = nfopab (step 9) |- F/_ x { 〈 y , z 〉 | ∃ w ( y B w ∧ w A z ) } ;;
	step 11 : wff = nfcxfr (step 1, step 10) |- F/_ x ( A ∘ B ) ;;
	qed prop 1 = step 11 ;;
}

/*Ordered pair membership in a composition.  (Contributed by NM,
       24-Feb-2015.) */

theorem brcog (x : set, A : class, B : class, C : class, D : class, V : class, W : class) disjointed(x y z A, x y z B, x y z C, x y z D) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ) ;;
}

proof of brcog {
	var y : set, z : set;;
	step 1 : wff = breq1 () |- ( y = A → ( y D x ↔ A D x ) ) ;;
	step 2 : wff = breq2 () |- ( z = B → ( x C z ↔ x C B ) ) ;;
	step 3 : wff = bi2anan9 (step 1, step 2) |- ( ( y = A ∧ z = B ) → ( ( y D x ∧ x C z ) ↔ ( A D x ∧ x C B ) ) ) ;;
	step 4 : wff = exbidv (step 3) |- ( ( y = A ∧ z = B ) → ( ∃ x ( y D x ∧ x C z ) ↔ ∃ x ( A D x ∧ x C B ) ) ) ;;
	step 5 : wff = df-co () |- ( C ∘ D ) = { 〈 y , z 〉 | ∃ x ( y D x ∧ x C z ) } ;;
	step 6 : wff = brabga (step 4, step 5) |- ( ( A ∈ V ∧ B ∈ W ) → ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Ordered pair membership in a composition.  (Contributed by NM,
       27-Jan-1997.)  (Revised by Mario Carneiro, 24-Feb-2015.) */

theorem opelco2g (x : set, A : class, B : class, C : class, D : class, V : class, W : class) disjointed(x A, x B, x C, x D) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ ( C ∘ D ) ↔ ∃ x ( 〈 A , x 〉 ∈ D ∧ 〈 x , B 〉 ∈ C ) ) ) ;;
}

proof of opelco2g {
	step 1 : wff = brcog () |- ( ( A ∈ V ∧ B ∈ W ) → ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ) ;;
	step 2 : wff = df-br () |- ( A ( C ∘ D ) B ↔ 〈 A , B 〉 ∈ ( C ∘ D ) ) ;;
	step 3 : wff = df-br () |- ( A D x ↔ 〈 A , x 〉 ∈ D ) ;;
	step 4 : wff = df-br () |- ( x C B ↔ 〈 x , B 〉 ∈ C ) ;;
	step 5 : wff = anbi12i (step 3, step 4) |- ( ( A D x ∧ x C B ) ↔ ( 〈 A , x 〉 ∈ D ∧ 〈 x , B 〉 ∈ C ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ x ( A D x ∧ x C B ) ↔ ∃ x ( 〈 A , x 〉 ∈ D ∧ 〈 x , B 〉 ∈ C ) ) ;;
	step 7 : wff = 3bitr3g (step 1, step 2, step 6) |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ ( C ∘ D ) ↔ ∃ x ( 〈 A , x 〉 ∈ D ∧ 〈 x , B 〉 ∈ C ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Binary relation on a composition.  (Contributed by NM, 21-Sep-2004.)
       (Revised by Mario Carneiro, 24-Feb-2015.) */

theorem brco (x : set, A : class, B : class, C : class, D : class) disjointed(x A, x B, x C, x D) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ;;
}

proof of brco {
	step 1 : wff = brcog () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Ordered pair membership in a composition.  (Contributed by NM,
       27-Dec-1996.)  (Revised by Mario Carneiro, 24-Feb-2015.) */

theorem opelco (x : set, A : class, B : class, C : class, D : class) disjointed(x A, x B, x C, x D) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ ( C ∘ D ) ↔ ∃ x ( A D x ∧ x C B ) ) ;;
}

proof of opelco {
	step 1 : wff = df-br () |- ( A ( C ∘ D ) B ↔ 〈 A , B 〉 ∈ ( C ∘ D ) ) ;;
	step 2 : wff = brco (hyp 1, hyp 2) |- ( A ( C ∘ D ) B ↔ ∃ x ( A D x ∧ x C B ) ) ;;
	step 3 : wff = bitr3i (step 1, step 2) |- ( 〈 A , B 〉 ∈ ( C ∘ D ) ↔ ∃ x ( A D x ∧ x C B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Subset theorem for converse.  (Contributed by NM, 22-Mar-1998.) */

theorem cnvss (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ⊆ B → ⁻¹ A ⊆ ⁻¹ B ) ;;
}

proof of cnvss {
	var x : set, y : set;;
	step 1 : wff = ssel () |- ( A ⊆ B → ( 〈 y , x 〉 ∈ A → 〈 y , x 〉 ∈ B ) ) ;;
	step 2 : wff = df-br () |- ( y A x ↔ 〈 y , x 〉 ∈ A ) ;;
	step 3 : wff = df-br () |- ( y B x ↔ 〈 y , x 〉 ∈ B ) ;;
	step 4 : wff = 3imtr4g (step 1, step 2, step 3) |- ( A ⊆ B → ( y A x → y B x ) ) ;;
	step 5 : wff = ssopab2dv (step 4) |- ( A ⊆ B → { 〈 x , y 〉 | y A x } ⊆ { 〈 x , y 〉 | y B x } ) ;;
	step 6 : wff = df-cnv () |- ⁻¹ A = { 〈 x , y 〉 | y A x } ;;
	step 7 : wff = df-cnv () |- ⁻¹ B = { 〈 x , y 〉 | y B x } ;;
	step 8 : wff = 3sstr4g (step 5, step 6, step 7) |- ( A ⊆ B → ⁻¹ A ⊆ ⁻¹ B ) ;;
	qed prop 1 = step 8 ;;
}

/*Equality theorem for converse.  (Contributed by NM, 13-Aug-1995.) */

theorem cnveq (A : class, B : class)  {
	prop 1 : wff = |- ( A = B → ⁻¹ A = ⁻¹ B ) ;;
}

proof of cnveq {
	step 1 : wff = cnvss () |- ( A ⊆ B → ⁻¹ A ⊆ ⁻¹ B ) ;;
	step 2 : wff = cnvss () |- ( B ⊆ A → ⁻¹ B ⊆ ⁻¹ A ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) → ( ⁻¹ A ⊆ ⁻¹ B ∧ ⁻¹ B ⊆ ⁻¹ A ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = eqss () |- ( ⁻¹ A = ⁻¹ B ↔ ( ⁻¹ A ⊆ ⁻¹ B ∧ ⁻¹ B ⊆ ⁻¹ A ) ) ;;
	step 6 : wff = 3imtr4i (step 3, step 4, step 5) |- ( A = B → ⁻¹ A = ⁻¹ B ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality inference for converse.  (Contributed by NM, 23-Dec-2008.) */

theorem cnveqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ⁻¹ A = ⁻¹ B ;;
}

proof of cnveqi {
	step 1 : wff = cnveq () |- ( A = B → ⁻¹ A = ⁻¹ B ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ⁻¹ A = ⁻¹ B ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for converse.  (Contributed by NM, 6-Dec-2013.) */

theorem cnveqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ⁻¹ A = ⁻¹ B ) ;;
}

proof of cnveqd {
	step 1 : wff = cnveq () |- ( A = B → ⁻¹ A = ⁻¹ B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ⁻¹ A = ⁻¹ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Membership in a converse.  Equation 5 of [Suppes] p. 62.  (Contributed
       by NM, 24-Mar-1998.) */

theorem elcnv (x : set, y : set, A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( A ∈ ⁻¹ R ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ y R x ) ) ;;
}

proof of elcnv {
	step 1 : wff = df-cnv () |- ⁻¹ R = { 〈 x , y 〉 | y R x } ;;
	step 2 : wff = eleq2i (step 1) |- ( A ∈ ⁻¹ R ↔ A ∈ { 〈 x , y 〉 | y R x } ) ;;
	step 3 : wff = elopab () |- ( A ∈ { 〈 x , y 〉 | y R x } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ y R x ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( A ∈ ⁻¹ R ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ y R x ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Membership in a converse.  Equation 5 of [Suppes] p. 62.  (Contributed
       by NM, 11-Aug-2004.) */

theorem elcnv2 (x : set, y : set, A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( A ∈ ⁻¹ R ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ 〈 y , x 〉 ∈ R ) ) ;;
}

proof of elcnv2 {
	step 1 : wff = elcnv () |- ( A ∈ ⁻¹ R ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ y R x ) ) ;;
	step 2 : wff = df-br () |- ( y R x ↔ 〈 y , x 〉 ∈ R ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( A = 〈 x , y 〉 ∧ y R x ) ↔ ( A = 〈 x , y 〉 ∧ 〈 y , x 〉 ∈ R ) ) ;;
	step 4 : wff = 2exbii (step 3) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ y R x ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ 〈 y , x 〉 ∈ R ) ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( A ∈ ⁻¹ R ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ 〈 y , x 〉 ∈ R ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for converse.  (Contributed by NM,
       31-Jan-2004.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nfcnv (x : set, A : class) disjointed(y z A, x y z) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x ⁻¹ A ;;
}

proof of nfcnv {
	var y : set, z : set;;
	step 1 : wff = df-cnv () |- ⁻¹ A = { 〈 y , z 〉 | z A y } ;;
	step 2 : wff = nfcv () |- F/_ x z ;;
	step 3 : wff = nfcv () |- F/_ x y ;;
	step 4 : wff = nfbr (step 2, hyp 1, step 3) |- F/ x z A y ;;
	step 5 : wff = nfopab (step 4) |- F/_ x { 〈 y , z 〉 | z A y } ;;
	step 6 : wff = nfcxfr (step 1, step 5) |- F/_ x ⁻¹ A ;;
	qed prop 1 = step 6 ;;
}

/*Ordered-pair membership in converse.  (Contributed by NM, 13-May-1999.)
       (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem opelcnvg (A : class, B : class, C : class, D : class, R : class) disjointed(x y A, x y B, x y R) {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ ⁻¹ R ↔ 〈 B , A 〉 ∈ R ) ) ;;
}

proof of opelcnvg {
	var x : set, y : set;;
	step 1 : wff = breq2 () |- ( x = A → ( y R x ↔ y R A ) ) ;;
	step 2 : wff = breq1 () |- ( y = B → ( y R A ↔ B R A ) ) ;;
	step 3 : wff = df-cnv () |- ⁻¹ R = { 〈 x , y 〉 | y R x } ;;
	step 4 : wff = brabg (step 1, step 2, step 3) |- ( ( A ∈ C ∧ B ∈ D ) → ( A ⁻¹ R B ↔ B R A ) ) ;;
	step 5 : wff = df-br () |- ( A ⁻¹ R B ↔ 〈 A , B 〉 ∈ ⁻¹ R ) ;;
	step 6 : wff = df-br () |- ( B R A ↔ 〈 B , A 〉 ∈ R ) ;;
	step 7 : wff = 3bitr3g (step 4, step 5, step 6) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ ⁻¹ R ↔ 〈 B , A 〉 ∈ R ) ) ;;
	qed prop 1 = step 7 ;;
}

/*The converse of a binary relation swaps arguments.  Theorem 11 of [Suppes]
     p. 61.  (Contributed by NM, 10-Oct-2005.) */

theorem brcnvg (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( A ⁻¹ R B ↔ B R A ) ) ;;
}

proof of brcnvg {
	step 1 : wff = opelcnvg () |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ ⁻¹ R ↔ 〈 B , A 〉 ∈ R ) ) ;;
	step 2 : wff = df-br () |- ( A ⁻¹ R B ↔ 〈 A , B 〉 ∈ ⁻¹ R ) ;;
	step 3 : wff = df-br () |- ( B R A ↔ 〈 B , A 〉 ∈ R ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( ( A ∈ C ∧ B ∈ D ) → ( A ⁻¹ R B ↔ B R A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Ordered-pair membership in converse.  (Contributed by NM,
       13-Aug-1995.) */

theorem opelcnv (A : class, B : class, R : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ ⁻¹ R ↔ 〈 B , A 〉 ∈ R ) ;;
}

proof of opelcnv {
	step 1 : wff = opelcnvg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 ∈ ⁻¹ R ↔ 〈 B , A 〉 ∈ R ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( 〈 A , B 〉 ∈ ⁻¹ R ↔ 〈 B , A 〉 ∈ R ) ;;
	qed prop 1 = step 2 ;;
}

/*The converse of a binary relation swaps arguments.  Theorem 11 of
       [Suppes] p. 61.  (Contributed by NM, 13-Aug-1995.) */

theorem brcnv (A : class, B : class, R : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ⁻¹ R B ↔ B R A ) ;;
}

proof of brcnv {
	step 1 : wff = brcnvg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A ⁻¹ R B ↔ B R A ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A ⁻¹ R B ↔ B R A ) ;;
	qed prop 1 = step 2 ;;
}

/*Distributive law of converse over class composition.  Theorem 26 of
       [Suppes] p. 64.  (Contributed by NM, 19-Mar-1998.)  (Proof shortened by
       Andrew Salmon, 27-Aug-2011.) */

theorem cnvco (A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- ⁻¹ ( A ∘ B ) = ( ⁻¹ B ∘ ⁻¹ A ) ;;
}

proof of cnvco {
	var x : set, y : set, z : set;;
	step 1 : wff = exancom () |- ( ∃ z ( x B z ∧ z A y ) ↔ ∃ z ( z A y ∧ x B z ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = brco (step 2, step 3) |- ( x ( A ∘ B ) y ↔ ∃ z ( x B z ∧ z A y ) ) ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = vex () |- z ∈ _V ;;
	step 7 : wff = brcnv (step 5, step 6) |- ( y ⁻¹ A z ↔ z A y ) ;;
	step 8 : wff = vex () |- z ∈ _V ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = brcnv (step 8, step 9) |- ( z ⁻¹ B x ↔ x B z ) ;;
	step 11 : wff = anbi12i (step 7, step 10) |- ( ( y ⁻¹ A z ∧ z ⁻¹ B x ) ↔ ( z A y ∧ x B z ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ z ( y ⁻¹ A z ∧ z ⁻¹ B x ) ↔ ∃ z ( z A y ∧ x B z ) ) ;;
	step 13 : wff = 3bitr4i (step 1, step 4, step 12) |- ( x ( A ∘ B ) y ↔ ∃ z ( y ⁻¹ A z ∧ z ⁻¹ B x ) ) ;;
	step 14 : wff = opabbii (step 13) |- { 〈 y , x 〉 | x ( A ∘ B ) y } = { 〈 y , x 〉 | ∃ z ( y ⁻¹ A z ∧ z ⁻¹ B x ) } ;;
	step 15 : wff = df-cnv () |- ⁻¹ ( A ∘ B ) = { 〈 y , x 〉 | x ( A ∘ B ) y } ;;
	step 16 : wff = df-co () |- ( ⁻¹ B ∘ ⁻¹ A ) = { 〈 y , x 〉 | ∃ z ( y ⁻¹ A z ∧ z ⁻¹ B x ) } ;;
	step 17 : wff = 3eqtr4i (step 14, step 15, step 16) |- ⁻¹ ( A ∘ B ) = ( ⁻¹ B ∘ ⁻¹ A ) ;;
	qed prop 1 = step 17 ;;
}

/*The converse of a class union is the (indexed) union of the converses of
       its members.  (Contributed by NM, 11-Aug-2004.) */

theorem cnvuni (x : set, A : class) disjointed(x y z w A) {
	prop 1 : wff = |- ⁻¹ ⋃ A = ⋃_ x ∈ A ⁻¹ x ;;
}

proof of cnvuni {
	var y : set, z : set, w : set;;
	step 1 : wff = elcnv2 () |- ( y ∈ ⁻¹ ⋃ A ↔ ∃ z ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ ⋃ A ) ) ;;
	step 2 : wff = eluni2 () |- ( 〈 w , z 〉 ∈ ⋃ A ↔ ∃ x ∈ A 〈 w , z 〉 ∈ x ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ ⋃ A ) ↔ ( y = 〈 z , w 〉 ∧ ∃ x ∈ A 〈 w , z 〉 ∈ x ) ) ;;
	step 4 : wff = r19.42v () |- ( ∃ x ∈ A ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ↔ ( y = 〈 z , w 〉 ∧ ∃ x ∈ A 〈 w , z 〉 ∈ x ) ) ;;
	step 5 : wff = bitr4i (step 3, step 4) |- ( ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ ⋃ A ) ↔ ∃ x ∈ A ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 6 : wff = 2exbii (step 5) |- ( ∃ z ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ ⋃ A ) ↔ ∃ z ∃ w ∃ x ∈ A ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 7 : wff = elcnv2 () |- ( y ∈ ⁻¹ x ↔ ∃ z ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 8 : wff = rexbii (step 7) |- ( ∃ x ∈ A y ∈ ⁻¹ x ↔ ∃ x ∈ A ∃ z ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 9 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ z ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ↔ ∃ z ∃ x ∈ A ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 10 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ↔ ∃ w ∃ x ∈ A ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 11 : wff = exbii (step 10) |- ( ∃ z ∃ x ∈ A ∃ w ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ↔ ∃ z ∃ w ∃ x ∈ A ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ) ;;
	step 12 : wff = 3bitrri (step 8, step 9, step 11) |- ( ∃ z ∃ w ∃ x ∈ A ( y = 〈 z , w 〉 ∧ 〈 w , z 〉 ∈ x ) ↔ ∃ x ∈ A y ∈ ⁻¹ x ) ;;
	step 13 : wff = 3bitri (step 1, step 6, step 12) |- ( y ∈ ⁻¹ ⋃ A ↔ ∃ x ∈ A y ∈ ⁻¹ x ) ;;
	step 14 : wff = eliun () |- ( y ∈ ⋃_ x ∈ A ⁻¹ x ↔ ∃ x ∈ A y ∈ ⁻¹ x ) ;;
	step 15 : wff = bitr4i (step 13, step 14) |- ( y ∈ ⁻¹ ⋃ A ↔ y ∈ ⋃_ x ∈ A ⁻¹ x ) ;;
	step 16 : wff = eqriv (step 15) |- ⁻¹ ⋃ A = ⋃_ x ∈ A ⁻¹ x ;;
	qed prop 1 = step 16 ;;
}

/*Alternate definition of domain.  Definition 6.5(1) of [TakeutiZaring]
       p. 24.  (Contributed by NM, 28-Dec-1996.) */

theorem dfdm3 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- dom A = { x | ∃ y 〈 x , y 〉 ∈ A } ;;
}

proof of dfdm3 {
	step 1 : wff = df-dm () |- dom A = { x | ∃ y x A y } ;;
	step 2 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ y x A y ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 4 : wff = abbii (step 3) |- { x | ∃ y x A y } = { x | ∃ y 〈 x , y 〉 ∈ A } ;;
	step 5 : wff = eqtri (step 1, step 4) |- dom A = { x | ∃ y 〈 x , y 〉 ∈ A } ;;
	qed prop 1 = step 5 ;;
}

/*Alternate definition of range.  Definition 4 of [Suppes] p. 60.
       (Contributed by NM, 27-Dec-1996.) */

theorem dfrn2 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ran A = { y | ∃ x x A y } ;;
}

proof of dfrn2 {
	step 1 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 2 : wff = df-dm () |- dom ⁻¹ A = { y | ∃ x y ⁻¹ A x } ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = brcnv (step 3, step 4) |- ( y ⁻¹ A x ↔ x A y ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ x y ⁻¹ A x ↔ ∃ x x A y ) ;;
	step 7 : wff = abbii (step 6) |- { y | ∃ x y ⁻¹ A x } = { y | ∃ x x A y } ;;
	step 8 : wff = 3eqtri (step 1, step 2, step 7) |- ran A = { y | ∃ x x A y } ;;
	qed prop 1 = step 8 ;;
}

/*Alternate definition of range.  Definition 6.5(2) of [TakeutiZaring]
       p. 24.  (Contributed by NM, 28-Dec-1996.) */

theorem dfrn3 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ran A = { y | ∃ x 〈 x , y 〉 ∈ A } ;;
}

proof of dfrn3 {
	step 1 : wff = dfrn2 () |- ran A = { y | ∃ x x A y } ;;
	step 2 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x x A y ↔ ∃ x 〈 x , y 〉 ∈ A ) ;;
	step 4 : wff = abbii (step 3) |- { y | ∃ x x A y } = { y | ∃ x 〈 x , y 〉 ∈ A } ;;
	step 5 : wff = eqtri (step 1, step 4) |- ran A = { y | ∃ x 〈 x , y 〉 ∈ A } ;;
	qed prop 1 = step 5 ;;
}

/*Membership in a range.  (Contributed by Scott Fenton, 2-Feb-2011.) */

theorem elrn2g (x : set, A : class, B : class, V : class) disjointed(A x y, B x y) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ ran B ↔ ∃ x 〈 x , A 〉 ∈ B ) ) ;;
}

proof of elrn2g {
	var y : set;;
	step 1 : wff = opeq2 () |- ( y = A → 〈 x , y 〉 = 〈 x , A 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( y = A → ( 〈 x , y 〉 ∈ B ↔ 〈 x , A 〉 ∈ B ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( y = A → ( ∃ x 〈 x , y 〉 ∈ B ↔ ∃ x 〈 x , A 〉 ∈ B ) ) ;;
	step 4 : wff = dfrn3 () |- ran B = { y | ∃ x 〈 x , y 〉 ∈ B } ;;
	step 5 : wff = elab2g (step 3, step 4) |- ( A ∈ V → ( A ∈ ran B ↔ ∃ x 〈 x , A 〉 ∈ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Membership in a range.  (Contributed by Scott Fenton, 2-Feb-2011.) */

theorem elrng (x : set, A : class, B : class, V : class) disjointed(A x, B x) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ ran B ↔ ∃ x x B A ) ) ;;
}

proof of elrng {
	step 1 : wff = elrn2g () |- ( A ∈ V → ( A ∈ ran B ↔ ∃ x 〈 x , A 〉 ∈ B ) ) ;;
	step 2 : wff = df-br () |- ( x B A ↔ 〈 x , A 〉 ∈ B ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x x B A ↔ ∃ x 〈 x , A 〉 ∈ B ) ;;
	step 4 : wff = syl6bbr (step 1, step 3) |- ( A ∈ V → ( A ∈ ran B ↔ ∃ x x B A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Alternate definition of domain.  (Contributed by NM, 28-Dec-1996.) */

theorem dfdm4 (A : class) disjointed(x y A) {
	prop 1 : wff = |- dom A = ran ⁻¹ A ;;
}

proof of dfdm4 {
	var x : set, y : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = brcnv (step 1, step 2) |- ( y ⁻¹ A x ↔ x A y ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y y ⁻¹ A x ↔ ∃ y x A y ) ;;
	step 5 : wff = abbii (step 4) |- { x | ∃ y y ⁻¹ A x } = { x | ∃ y x A y } ;;
	step 6 : wff = dfrn2 () |- ran ⁻¹ A = { x | ∃ y y ⁻¹ A x } ;;
	step 7 : wff = df-dm () |- dom A = { x | ∃ y x A y } ;;
	step 8 : wff = 3eqtr4ri (step 5, step 6, step 7) |- dom A = ran ⁻¹ A ;;
	qed prop 1 = step 8 ;;
}

/*Definition of domain, using bound-variable hypotheses instead of
       distinct variable conditions.  (Contributed by NM, 8-Mar-1995.)
       (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem dfdmf (x : set, y : set, A : class) disjointed(x y w v, w v A) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	-----------------------
	prop 1 : wff = |- dom A = { x | ∃ y x A y } ;;
}

proof of dfdmf {
	var w : set, v : set;;
	step 1 : wff = df-dm () |- dom A = { w | ∃ v w A v } ;;
	step 2 : wff = nfcv () |- F/_ y w ;;
	step 3 : wff = nfcv () |- F/_ y v ;;
	step 4 : wff = nfbr (step 2, hyp 2, step 3) |- F/ y w A v ;;
	step 5 : wff = nfv () |- F/ v w A y ;;
	step 6 : wff = breq2 () |- ( v = y → ( w A v ↔ w A y ) ) ;;
	step 7 : wff = cbvex (step 4, step 5, step 6) |- ( ∃ v w A v ↔ ∃ y w A y ) ;;
	step 8 : wff = abbii (step 7) |- { w | ∃ v w A v } = { w | ∃ y w A y } ;;
	step 9 : wff = nfcv () |- F/_ x w ;;
	step 10 : wff = nfcv () |- F/_ x y ;;
	step 11 : wff = nfbr (step 9, hyp 1, step 10) |- F/ x w A y ;;
	step 12 : wff = nfex (step 11) |- F/ x ∃ y w A y ;;
	step 13 : wff = nfv () |- F/ w ∃ y x A y ;;
	step 14 : wff = breq1 () |- ( w = x → ( w A y ↔ x A y ) ) ;;
	step 15 : wff = exbidv (step 14) |- ( w = x → ( ∃ y w A y ↔ ∃ y x A y ) ) ;;
	step 16 : wff = cbvab (step 12, step 13, step 15) |- { w | ∃ y w A y } = { x | ∃ y x A y } ;;
	step 17 : wff = 3eqtri (step 1, step 8, step 16) |- dom A = { x | ∃ y x A y } ;;
	qed prop 1 = step 17 ;;
}

/*Domain membership.  Theorem 4 of [Suppes] p. 59.  (Contributed by Mario
       Carneiro, 9-Jul-2014.) */

theorem eldmg (y : set, A : class, B : class, V : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ dom B ↔ ∃ y A B y ) ) ;;
}

proof of eldmg {
	var x : set;;
	step 1 : wff = breq1 () |- ( x = A → ( x B y ↔ A B y ) ) ;;
	step 2 : wff = exbidv (step 1) |- ( x = A → ( ∃ y x B y ↔ ∃ y A B y ) ) ;;
	step 3 : wff = df-dm () |- dom B = { x | ∃ y x B y } ;;
	step 4 : wff = elab2g (step 2, step 3) |- ( A ∈ V → ( A ∈ dom B ↔ ∃ y A B y ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Domain membership.  Theorem 4 of [Suppes] p. 59.  (Contributed by NM,
       27-Jan-1997.)  (Revised by Mario Carneiro, 9-Jul-2014.) */

theorem eldm2g (y : set, A : class, B : class, V : class) disjointed(y A, y B) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ dom B ↔ ∃ y 〈 A , y 〉 ∈ B ) ) ;;
}

proof of eldm2g {
	step 1 : wff = eldmg () |- ( A ∈ V → ( A ∈ dom B ↔ ∃ y A B y ) ) ;;
	step 2 : wff = df-br () |- ( A B y ↔ 〈 A , y 〉 ∈ B ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ y A B y ↔ ∃ y 〈 A , y 〉 ∈ B ) ;;
	step 4 : wff = syl6bb (step 1, step 3) |- ( A ∈ V → ( A ∈ dom B ↔ ∃ y 〈 A , y 〉 ∈ B ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Membership in a domain.  Theorem 4 of [Suppes] p. 59.  (Contributed by
       NM, 2-Apr-2004.) */

theorem eldm (y : set, A : class, B : class) disjointed(y A, y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ dom B ↔ ∃ y A B y ) ;;
}

proof of eldm {
	step 1 : wff = eldmg () |- ( A ∈ _V → ( A ∈ dom B ↔ ∃ y A B y ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ dom B ↔ ∃ y A B y ) ;;
	qed prop 1 = step 2 ;;
}

/*Membership in a domain.  Theorem 4 of [Suppes] p. 59.  (Contributed by
       NM, 1-Aug-1994.) */

theorem eldm2 (y : set, A : class, B : class) disjointed(y A, y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ dom B ↔ ∃ y 〈 A , y 〉 ∈ B ) ;;
}

proof of eldm2 {
	step 1 : wff = eldm2g () |- ( A ∈ _V → ( A ∈ dom B ↔ ∃ y 〈 A , y 〉 ∈ B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ dom B ↔ ∃ y 〈 A , y 〉 ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Subset theorem for domain.  (Contributed by NM, 11-Aug-1994.) */

theorem dmss (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ⊆ B → dom A ⊆ dom B ) ;;
}

proof of dmss {
	var x : set, y : set;;
	step 1 : wff = ssel () |- ( A ⊆ B → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = eximdv (step 1) |- ( A ⊆ B → ( ∃ y 〈 x , y 〉 ∈ A → ∃ y 〈 x , y 〉 ∈ B ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = eldm2 (step 3) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = eldm2 (step 5) |- ( x ∈ dom B ↔ ∃ y 〈 x , y 〉 ∈ B ) ;;
	step 7 : wff = 3imtr4g (step 2, step 4, step 6) |- ( A ⊆ B → ( x ∈ dom A → x ∈ dom B ) ) ;;
	step 8 : wff = ssrdv (step 7) |- ( A ⊆ B → dom A ⊆ dom B ) ;;
	qed prop 1 = step 8 ;;
}

/*Equality theorem for domain.  (Contributed by NM, 11-Aug-1994.) */

theorem dmeq (A : class, B : class)  {
	prop 1 : wff = |- ( A = B → dom A = dom B ) ;;
}

proof of dmeq {
	step 1 : wff = dmss () |- ( A ⊆ B → dom A ⊆ dom B ) ;;
	step 2 : wff = dmss () |- ( B ⊆ A → dom B ⊆ dom A ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) → ( dom A ⊆ dom B ∧ dom B ⊆ dom A ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = eqss () |- ( dom A = dom B ↔ ( dom A ⊆ dom B ∧ dom B ⊆ dom A ) ) ;;
	step 6 : wff = 3imtr4i (step 3, step 4, step 5) |- ( A = B → dom A = dom B ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality inference for domain.  (Contributed by NM, 4-Mar-2004.) */

theorem dmeqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- dom A = dom B ;;
}

proof of dmeqi {
	step 1 : wff = dmeq () |- ( A = B → dom A = dom B ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- dom A = dom B ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for domain.  (Contributed by NM, 4-Mar-2004.) */

theorem dmeqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → dom A = dom B ) ;;
}

proof of dmeqd {
	step 1 : wff = dmeq () |- ( A = B → dom A = dom B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → dom A = dom B ) ;;
	qed prop 1 = step 2 ;;
}

/*Membership of first of an ordered pair in a domain.  (Contributed by NM,
       30-Jul-1995.) */

theorem opeldm (A : class, B : class, C : class) disjointed(y A, y B, y C) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ C → A ∈ dom C ) ;;
}

proof of opeldm {
	var y : set;;
	step 1 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( y = B → ( 〈 A , y 〉 ∈ C ↔ 〈 A , B 〉 ∈ C ) ) ;;
	step 3 : wff = spcev (hyp 2, step 2) |- ( 〈 A , B 〉 ∈ C → ∃ y 〈 A , y 〉 ∈ C ) ;;
	step 4 : wff = eldm2 (hyp 1) |- ( A ∈ dom C ↔ ∃ y 〈 A , y 〉 ∈ C ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( 〈 A , B 〉 ∈ C → A ∈ dom C ) ;;
	qed prop 1 = step 5 ;;
}

/*Membership of first of a binary relation in a domain.  (Contributed by
       NM, 30-Jul-1995.) */

theorem breldm (A : class, B : class, R : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A R B → A ∈ dom R ) ;;
}

proof of breldm {
	step 1 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 2 : wff = opeldm (hyp 1, hyp 2) |- ( 〈 A , B 〉 ∈ R → A ∈ dom R ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( A R B → A ∈ dom R ) ;;
	qed prop 1 = step 3 ;;
}

/*Membership of first of a binary relation in a domain.  (Contributed by
       NM, 21-Mar-2007.) */

theorem breldmg (A : class, B : class, C : class, D : class, R : class) disjointed(x A, x B, x R) {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ∧ A R B ) → A ∈ dom R ) ;;
}

proof of breldmg {
	var x : set;;
	step 1 : wff = breq2 () |- ( x = B → ( A R x ↔ A R B ) ) ;;
	step 2 : wff = spcegv (step 1) |- ( B ∈ D → ( A R B → ∃ x A R x ) ) ;;
	step 3 : wff = imp (step 2) |- ( ( B ∈ D ∧ A R B ) → ∃ x A R x ) ;;
	step 4 : wff = 3adant1 (step 3) |- ( ( A ∈ C ∧ B ∈ D ∧ A R B ) → ∃ x A R x ) ;;
	step 5 : wff = eldmg () |- ( A ∈ C → ( A ∈ dom R ↔ ∃ x A R x ) ) ;;
	step 6 : wff = 3ad2ant1 (step 5) |- ( ( A ∈ C ∧ B ∈ D ∧ A R B ) → ( A ∈ dom R ↔ ∃ x A R x ) ) ;;
	step 7 : wff = mpbird (step 4, step 6) |- ( ( A ∈ C ∧ B ∈ D ∧ A R B ) → A ∈ dom R ) ;;
	qed prop 1 = step 7 ;;
}

/*The domain of a union is the union of domains.  Exercise 56(a) of
       [Enderton] p. 65.  (Contributed by NM, 12-Aug-1994.)  (Proof shortened
       by Andrew Salmon, 27-Aug-2011.) */

theorem dmun (A : class, B : class) disjointed(x y A, x y B, x) {
	prop 1 : wff = |- dom ( A ∪ B ) = ( dom A ∪ dom B ) ;;
}

proof of dmun {
	var x : set, y : set;;
	step 1 : wff = unab () |- ( { y | ∃ x y A x } ∪ { y | ∃ x y B x } ) = { y | ( ∃ x y A x ∨ ∃ x y B x ) } ;;
	step 2 : wff = brun () |- ( y ( A ∪ B ) x ↔ ( y A x ∨ y B x ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x y ( A ∪ B ) x ↔ ∃ x ( y A x ∨ y B x ) ) ;;
	step 4 : wff = 19.43 () |- ( ∃ x ( y A x ∨ y B x ) ↔ ( ∃ x y A x ∨ ∃ x y B x ) ) ;;
	step 5 : wff = bitr2i (step 3, step 4) |- ( ( ∃ x y A x ∨ ∃ x y B x ) ↔ ∃ x y ( A ∪ B ) x ) ;;
	step 6 : wff = abbii (step 5) |- { y | ( ∃ x y A x ∨ ∃ x y B x ) } = { y | ∃ x y ( A ∪ B ) x } ;;
	step 7 : wff = eqtri (step 1, step 6) |- ( { y | ∃ x y A x } ∪ { y | ∃ x y B x } ) = { y | ∃ x y ( A ∪ B ) x } ;;
	step 8 : wff = df-dm () |- dom A = { y | ∃ x y A x } ;;
	step 9 : wff = df-dm () |- dom B = { y | ∃ x y B x } ;;
	step 10 : wff = uneq12i (step 8, step 9) |- ( dom A ∪ dom B ) = ( { y | ∃ x y A x } ∪ { y | ∃ x y B x } ) ;;
	step 11 : wff = df-dm () |- dom ( A ∪ B ) = { y | ∃ x y ( A ∪ B ) x } ;;
	step 12 : wff = 3eqtr4ri (step 7, step 10, step 11) |- dom ( A ∪ B ) = ( dom A ∪ dom B ) ;;
	qed prop 1 = step 12 ;;
}

/*The domain of an intersection belong to the intersection of domains.
       Theorem 6 of [Suppes] p. 60.  (Contributed by NM, 15-Sep-2004.) */

theorem dmin (A : class, B : class) disjointed(x y A, x y B, x) {
	prop 1 : wff = |- dom ( A ∩ B ) ⊆ ( dom A ∩ dom B ) ;;
}

proof of dmin {
	var x : set, y : set;;
	step 1 : wff = 19.40 () |- ( ∃ y ( 〈 x , y 〉 ∈ A ∧ 〈 x , y 〉 ∈ B ) → ( ∃ y 〈 x , y 〉 ∈ A ∧ ∃ y 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = eldm2 (step 2) |- ( x ∈ dom ( A ∩ B ) ↔ ∃ y 〈 x , y 〉 ∈ ( A ∩ B ) ) ;;
	step 4 : wff = elin () |- ( 〈 x , y 〉 ∈ ( A ∩ B ) ↔ ( 〈 x , y 〉 ∈ A ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y 〈 x , y 〉 ∈ ( A ∩ B ) ↔ ∃ y ( 〈 x , y 〉 ∈ A ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 6 : wff = bitri (step 3, step 5) |- ( x ∈ dom ( A ∩ B ) ↔ ∃ y ( 〈 x , y 〉 ∈ A ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 7 : wff = elin () |- ( x ∈ ( dom A ∩ dom B ) ↔ ( x ∈ dom A ∧ x ∈ dom B ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = eldm2 (step 8) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = eldm2 (step 10) |- ( x ∈ dom B ↔ ∃ y 〈 x , y 〉 ∈ B ) ;;
	step 12 : wff = anbi12i (step 9, step 11) |- ( ( x ∈ dom A ∧ x ∈ dom B ) ↔ ( ∃ y 〈 x , y 〉 ∈ A ∧ ∃ y 〈 x , y 〉 ∈ B ) ) ;;
	step 13 : wff = bitri (step 7, step 12) |- ( x ∈ ( dom A ∩ dom B ) ↔ ( ∃ y 〈 x , y 〉 ∈ A ∧ ∃ y 〈 x , y 〉 ∈ B ) ) ;;
	step 14 : wff = 3imtr4i (step 1, step 6, step 13) |- ( x ∈ dom ( A ∩ B ) → x ∈ ( dom A ∩ dom B ) ) ;;
	step 15 : wff = ssriv (step 14) |- dom ( A ∩ B ) ⊆ ( dom A ∩ dom B ) ;;
	qed prop 1 = step 15 ;;
}

/*The domain of an indexed union.  (Contributed by Mario Carneiro,
       26-Apr-2016.) */

theorem dmiun (x : set, A : class, B : class) disjointed(x y z, y z A, y z B) {
	prop 1 : wff = |- dom ⋃_ x ∈ A B = ⋃_ x ∈ A dom B ;;
}

proof of dmiun {
	var y : set, z : set;;
	step 1 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ z 〈 y , z 〉 ∈ B ↔ ∃ z ∃ x ∈ A 〈 y , z 〉 ∈ B ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = eldm2 (step 2) |- ( y ∈ dom B ↔ ∃ z 〈 y , z 〉 ∈ B ) ;;
	step 4 : wff = rexbii (step 3) |- ( ∃ x ∈ A y ∈ dom B ↔ ∃ x ∈ A ∃ z 〈 y , z 〉 ∈ B ) ;;
	step 5 : wff = eliun () |- ( 〈 y , z 〉 ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A 〈 y , z 〉 ∈ B ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ z 〈 y , z 〉 ∈ ⋃_ x ∈ A B ↔ ∃ z ∃ x ∈ A 〈 y , z 〉 ∈ B ) ;;
	step 7 : wff = 3bitr4ri (step 1, step 4, step 6) |- ( ∃ z 〈 y , z 〉 ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A y ∈ dom B ) ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = eldm2 (step 8) |- ( y ∈ dom ⋃_ x ∈ A B ↔ ∃ z 〈 y , z 〉 ∈ ⋃_ x ∈ A B ) ;;
	step 10 : wff = eliun () |- ( y ∈ ⋃_ x ∈ A dom B ↔ ∃ x ∈ A y ∈ dom B ) ;;
	step 11 : wff = 3bitr4i (step 7, step 9, step 10) |- ( y ∈ dom ⋃_ x ∈ A B ↔ y ∈ ⋃_ x ∈ A dom B ) ;;
	step 12 : wff = eqriv (step 11) |- dom ⋃_ x ∈ A B = ⋃_ x ∈ A dom B ;;
	qed prop 1 = step 12 ;;
}

/*The domain of a union.  Part of Exercise 8 of [Enderton] p. 41.
       (Contributed by NM, 3-Feb-2004.) */

theorem dmuni (x : set, A : class) disjointed(x y z, y z A, y z, x A) {
	prop 1 : wff = |- dom ⋃ A = ⋃_ x ∈ A dom x ;;
}

proof of dmuni {
	var y : set, z : set;;
	step 1 : wff = excom () |- ( ∃ z ∃ x ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ↔ ∃ x ∃ z ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ) ;;
	step 2 : wff = ancom () |- ( ( ∃ z 〈 y , z 〉 ∈ x ∧ x ∈ A ) ↔ ( x ∈ A ∧ ∃ z 〈 y , z 〉 ∈ x ) ) ;;
	step 3 : wff = 19.41v () |- ( ∃ z ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ↔ ( ∃ z 〈 y , z 〉 ∈ x ∧ x ∈ A ) ) ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = eldm2 (step 4) |- ( y ∈ dom x ↔ ∃ z 〈 y , z 〉 ∈ x ) ;;
	step 6 : wff = anbi2i (step 5) |- ( ( x ∈ A ∧ y ∈ dom x ) ↔ ( x ∈ A ∧ ∃ z 〈 y , z 〉 ∈ x ) ) ;;
	step 7 : wff = 3bitr4i (step 2, step 3, step 6) |- ( ∃ z ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ↔ ( x ∈ A ∧ y ∈ dom x ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ x ∃ z ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ↔ ∃ x ( x ∈ A ∧ y ∈ dom x ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( ∃ z ∃ x ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ↔ ∃ x ( x ∈ A ∧ y ∈ dom x ) ) ;;
	step 10 : wff = eluni () |- ( 〈 y , z 〉 ∈ ⋃ A ↔ ∃ x ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ) ;;
	step 11 : wff = exbii (step 10) |- ( ∃ z 〈 y , z 〉 ∈ ⋃ A ↔ ∃ z ∃ x ( 〈 y , z 〉 ∈ x ∧ x ∈ A ) ) ;;
	step 12 : wff = df-rex () |- ( ∃ x ∈ A y ∈ dom x ↔ ∃ x ( x ∈ A ∧ y ∈ dom x ) ) ;;
	step 13 : wff = 3bitr4i (step 9, step 11, step 12) |- ( ∃ z 〈 y , z 〉 ∈ ⋃ A ↔ ∃ x ∈ A y ∈ dom x ) ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = eldm2 (step 14) |- ( y ∈ dom ⋃ A ↔ ∃ z 〈 y , z 〉 ∈ ⋃ A ) ;;
	step 16 : wff = eliun () |- ( y ∈ ⋃_ x ∈ A dom x ↔ ∃ x ∈ A y ∈ dom x ) ;;
	step 17 : wff = 3bitr4i (step 13, step 15, step 16) |- ( y ∈ dom ⋃ A ↔ y ∈ ⋃_ x ∈ A dom x ) ;;
	step 18 : wff = eqriv (step 17) |- dom ⋃ A = ⋃_ x ∈ A dom x ;;
	qed prop 1 = step 18 ;;
}

/*The domain of a class of ordered pairs.  (Contributed by NM,
       16-May-1995.)  (Revised by Mario Carneiro, 4-Dec-2016.) */

theorem dmopab (ph : wff, x : set, y : set) disjointed(x y, ph) {
	prop 1 : wff = |- dom { 〈 x , y 〉 | ph } = { x | ∃ y ph } ;;
}

proof of dmopab {
	step 1 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ph } ;;
	step 2 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ph } ;;
	step 3 : wff = dfdmf (step 1, step 2) |- dom { 〈 x , y 〉 | ph } = { x | ∃ y x { 〈 x , y 〉 | ph } y } ;;
	step 4 : wff = df-br () |- ( x { 〈 x , y 〉 | ph } y ↔ 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 5 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( x { 〈 x , y 〉 | ph } y ↔ ph ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ y x { 〈 x , y 〉 | ph } y ↔ ∃ y ph ) ;;
	step 8 : wff = abbii (step 7) |- { x | ∃ y x { 〈 x , y 〉 | ph } y } = { x | ∃ y ph } ;;
	step 9 : wff = eqtri (step 3, step 8) |- dom { 〈 x , y 〉 | ph } = { x | ∃ y ph } ;;
	qed prop 1 = step 9 ;;
}

/*Upper bound for the domain of a restricted class of ordered pairs.
       (Contributed by NM, 31-Jan-2004.) */

theorem dmopabss (ph : wff, x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ⊆ A ;;
}

proof of dmopabss {
	step 1 : wff = dmopab () |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = { x | ∃ y ( x ∈ A ∧ ph ) } ;;
	step 2 : wff = 19.42v () |- ( ∃ y ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ∃ y ph ) ) ;;
	step 3 : wff = abbii (step 2) |- { x | ∃ y ( x ∈ A ∧ ph ) } = { x | ( x ∈ A ∧ ∃ y ph ) } ;;
	step 4 : wff = ssab2 () |- { x | ( x ∈ A ∧ ∃ y ph ) } ⊆ A ;;
	step 5 : wff = eqsstri (step 3, step 4) |- { x | ∃ y ( x ∈ A ∧ ph ) } ⊆ A ;;
	step 6 : wff = eqsstri (step 1, step 5) |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ⊆ A ;;
	qed prop 1 = step 6 ;;
}

/*The domain of a restricted class of ordered pairs.  (Contributed by NM,
       31-Jan-2004.) */

theorem dmopab3 (ph : wff, x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( ∀ x ∈ A ∃ y ph ↔ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ) ;;
}

proof of dmopab3 {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ∃ y ph ↔ ∀ x ( x ∈ A → ∃ y ph ) ) ;;
	step 2 : wff = pm4.71 () |- ( ( x ∈ A → ∃ y ph ) ↔ ( x ∈ A ↔ ( x ∈ A ∧ ∃ y ph ) ) ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ x ( x ∈ A → ∃ y ph ) ↔ ∀ x ( x ∈ A ↔ ( x ∈ A ∧ ∃ y ph ) ) ) ;;
	step 4 : wff = dmopab () |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = { x | ∃ y ( x ∈ A ∧ ph ) } ;;
	step 5 : wff = 19.42v () |- ( ∃ y ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ∃ y ph ) ) ;;
	step 6 : wff = abbii (step 5) |- { x | ∃ y ( x ∈ A ∧ ph ) } = { x | ( x ∈ A ∧ ∃ y ph ) } ;;
	step 7 : wff = eqtri (step 4, step 6) |- dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = { x | ( x ∈ A ∧ ∃ y ph ) } ;;
	step 8 : wff = eqeq1i (step 7) |- ( dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ↔ { x | ( x ∈ A ∧ ∃ y ph ) } = A ) ;;
	step 9 : wff = eqcom () |- ( A = { x | ( x ∈ A ∧ ∃ y ph ) } ↔ { x | ( x ∈ A ∧ ∃ y ph ) } = A ) ;;
	step 10 : wff = abeq2 () |- ( A = { x | ( x ∈ A ∧ ∃ y ph ) } ↔ ∀ x ( x ∈ A ↔ ( x ∈ A ∧ ∃ y ph ) ) ) ;;
	step 11 : wff = 3bitr2ri (step 8, step 9, step 10) |- ( ∀ x ( x ∈ A ↔ ( x ∈ A ∧ ∃ y ph ) ) ↔ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ) ;;
	step 12 : wff = 3bitri (step 1, step 3, step 11) |- ( ∀ x ∈ A ∃ y ph ↔ dom { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } = A ) ;;
	qed prop 1 = step 12 ;;
}

/*The domain of the empty set is empty.  Part of Theorem 3.8(v) of [Monk1]
       p. 36.  (Contributed by NM, 4-Jul-1994.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem dm0 () disjointed(x y) {
	prop 1 : wff = |- dom ∅ = ∅ ;;
}

proof of dm0 {
	var x : set, y : set;;
	step 1 : wff = eq0 () |- ( dom ∅ = ∅ ↔ ∀ x ¬ x ∈ dom ∅ ) ;;
	step 2 : wff = noel () |- ¬ 〈 x , y 〉 ∈ ∅ ;;
	step 3 : wff = nex (step 2) |- ¬ ∃ y 〈 x , y 〉 ∈ ∅ ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = eldm2 (step 4) |- ( x ∈ dom ∅ ↔ ∃ y 〈 x , y 〉 ∈ ∅ ) ;;
	step 6 : wff = mtbir (step 3, step 5) |- ¬ x ∈ dom ∅ ;;
	step 7 : wff = mpgbir (step 1, step 6) |- dom ∅ = ∅ ;;
	qed prop 1 = step 7 ;;
}

/*The domain of the identity relation is the universe.  (Contributed by
       NM, 30-Apr-1998.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem dmi () disjointed(x y) {
	prop 1 : wff = |- dom _I = _V ;;
}

proof of dmi {
	var x : set, y : set;;
	step 1 : wff = eqv () |- ( dom _I = _V ↔ ∀ x x ∈ dom _I ) ;;
	step 2 : wff = a9ev () |- ∃ y y = x ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = ideq (step 3) |- ( x _I y ↔ x = y ) ;;
	step 5 : wff = equcom () |- ( x = y ↔ y = x ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( x _I y ↔ y = x ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ y x _I y ↔ ∃ y y = x ) ;;
	step 8 : wff = mpbir (step 2, step 7) |- ∃ y x _I y ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = eldm (step 9) |- ( x ∈ dom _I ↔ ∃ y x _I y ) ;;
	step 11 : wff = mpbir (step 8, step 10) |- x ∈ dom _I ;;
	step 12 : wff = mpgbir (step 1, step 11) |- dom _I = _V ;;
	qed prop 1 = step 12 ;;
}

/*The domain of the universe is the universe.  (Contributed by NM,
       8-Aug-2003.) */

theorem dmv ()  {
	prop 1 : wff = |- dom _V = _V ;;
}

proof of dmv {
	step 1 : wff = ssv () |- dom _V ⊆ _V ;;
	step 2 : wff = dmi () |- dom _I = _V ;;
	step 3 : wff = ssv () |- _I ⊆ _V ;;
	step 4 : wff = dmss () |- ( _I ⊆ _V → dom _I ⊆ dom _V ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- dom _I ⊆ dom _V ;;
	step 6 : wff = eqsstr3i (step 2, step 5) |- _V ⊆ dom _V ;;
	step 7 : wff = eqssi (step 1, step 6) |- dom _V = _V ;;
	qed prop 1 = step 7 ;;
}

/*An empty domain implies an empty range.  (Contributed by NM,
       21-May-1998.) */

theorem dm0rn0 (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( dom A = ∅ ↔ ran A = ∅ ) ;;
}

proof of dm0rn0 {
	var x : set, y : set;;
	step 1 : wff = alnex () |- ( ∀ x ¬ ∃ y x A y ↔ ¬ ∃ x ∃ y x A y ) ;;
	step 2 : wff = excom () |- ( ∃ x ∃ y x A y ↔ ∃ y ∃ x x A y ) ;;
	step 3 : wff = xchbinx (step 1, step 2) |- ( ∀ x ¬ ∃ y x A y ↔ ¬ ∃ y ∃ x x A y ) ;;
	step 4 : wff = alnex () |- ( ∀ y ¬ ∃ x x A y ↔ ¬ ∃ y ∃ x x A y ) ;;
	step 5 : wff = bitr4i (step 3, step 4) |- ( ∀ x ¬ ∃ y x A y ↔ ∀ y ¬ ∃ x x A y ) ;;
	step 6 : wff = noel () |- ¬ x ∈ ∅ ;;
	step 7 : wff = nbn (step 6) |- ( ¬ ∃ y x A y ↔ ( ∃ y x A y ↔ x ∈ ∅ ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ¬ ∃ y x A y ↔ ∀ x ( ∃ y x A y ↔ x ∈ ∅ ) ) ;;
	step 9 : wff = noel () |- ¬ y ∈ ∅ ;;
	step 10 : wff = nbn (step 9) |- ( ¬ ∃ x x A y ↔ ( ∃ x x A y ↔ y ∈ ∅ ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ y ¬ ∃ x x A y ↔ ∀ y ( ∃ x x A y ↔ y ∈ ∅ ) ) ;;
	step 12 : wff = 3bitr3i (step 5, step 8, step 11) |- ( ∀ x ( ∃ y x A y ↔ x ∈ ∅ ) ↔ ∀ y ( ∃ x x A y ↔ y ∈ ∅ ) ) ;;
	step 13 : wff = abeq1 () |- ( { x | ∃ y x A y } = ∅ ↔ ∀ x ( ∃ y x A y ↔ x ∈ ∅ ) ) ;;
	step 14 : wff = abeq1 () |- ( { y | ∃ x x A y } = ∅ ↔ ∀ y ( ∃ x x A y ↔ y ∈ ∅ ) ) ;;
	step 15 : wff = 3bitr4i (step 12, step 13, step 14) |- ( { x | ∃ y x A y } = ∅ ↔ { y | ∃ x x A y } = ∅ ) ;;
	step 16 : wff = df-dm () |- dom A = { x | ∃ y x A y } ;;
	step 17 : wff = eqeq1i (step 16) |- ( dom A = ∅ ↔ { x | ∃ y x A y } = ∅ ) ;;
	step 18 : wff = dfrn2 () |- ran A = { y | ∃ x x A y } ;;
	step 19 : wff = eqeq1i (step 18) |- ( ran A = ∅ ↔ { y | ∃ x x A y } = ∅ ) ;;
	step 20 : wff = 3bitr4i (step 15, step 17, step 19) |- ( dom A = ∅ ↔ ran A = ∅ ) ;;
	qed prop 1 = step 20 ;;
}

/*A relation is empty iff its domain is empty.  (Contributed by NM,
       15-Sep-2004.) */

theorem reldm0 (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Rel A → ( A = ∅ ↔ dom A = ∅ ) ) ;;
}

proof of reldm0 {
	var x : set, y : set;;
	step 1 : wff = rel0 () |- Rel ∅ ;;
	step 2 : wff = eqrel () |- ( ( Rel A ∧ Rel ∅ ) → ( A = ∅ ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( Rel A → ( A = ∅ ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ) ) ;;
	step 4 : wff = eq0 () |- ( dom A = ∅ ↔ ∀ x ¬ x ∈ dom A ) ;;
	step 5 : wff = alnex () |- ( ∀ y ¬ 〈 x , y 〉 ∈ A ↔ ¬ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 6 : wff = vex () |- x ∈ _V ;;
	step 7 : wff = eldm2 (step 6) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 8 : wff = xchbinxr (step 5, step 7) |- ( ∀ y ¬ 〈 x , y 〉 ∈ A ↔ ¬ x ∈ dom A ) ;;
	step 9 : wff = noel () |- ¬ 〈 x , y 〉 ∈ ∅ ;;
	step 10 : wff = nbn (step 9) |- ( ¬ 〈 x , y 〉 ∈ A ↔ ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ y ¬ 〈 x , y 〉 ∈ A ↔ ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 12 : wff = bitr3i (step 8, step 11) |- ( ¬ x ∈ dom A ↔ ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ x ¬ x ∈ dom A ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 14 : wff = bitr2i (step 4, step 13) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ∅ ) ↔ dom A = ∅ ) ;;
	step 15 : wff = syl6bb (step 3, step 14) |- ( Rel A → ( A = ∅ ↔ dom A = ∅ ) ) ;;
	qed prop 1 = step 15 ;;
}

/*The domain of a cross product.  Part of Theorem 3.13(x) of [Monk1]
       p. 37.  (Contributed by NM, 28-Jul-1995.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem dmxp (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
}

proof of dmxp {
	var x : set, y : set;;
	step 1 : wff = df-xp () |- ( A × B ) = { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } ;;
	step 2 : wff = dmeqi (step 1) |- dom ( A × B ) = dom { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } ;;
	step 3 : wff = n0 () |- ( B ≠ ∅ ↔ ∃ x x ∈ B ) ;;
	step 4 : wff = biimpi (step 3) |- ( B ≠ ∅ → ∃ x x ∈ B ) ;;
	step 5 : wff = ralrimivw (step 4) |- ( B ≠ ∅ → ∀ y ∈ A ∃ x x ∈ B ) ;;
	step 6 : wff = dmopab3 () |- ( ∀ y ∈ A ∃ x x ∈ B ↔ dom { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } = A ) ;;
	step 7 : wff = sylib (step 5, step 6) |- ( B ≠ ∅ → dom { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } = A ) ;;
	step 8 : wff = syl5eq (step 2, step 7) |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
	qed prop 1 = step 8 ;;
}

/*The domain of a square cross product.  (Contributed by NM,
     28-Jul-1995.) */

theorem dmxpid (A : class)  {
	prop 1 : wff = |- dom ( A × A ) = A ;;
}

proof of dmxpid {
	step 1 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 2 : wff = xpeq1 () |- ( A = ∅ → ( A × A ) = ( ∅ × A ) ) ;;
	step 3 : wff = xp0r () |- ( ∅ × A ) = ∅ ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( A = ∅ → ( A × A ) = ∅ ) ;;
	step 5 : wff = dmeqd (step 4) |- ( A = ∅ → dom ( A × A ) = dom ∅ ) ;;
	step 6 : wff = id () |- ( A = ∅ → A = ∅ ) ;;
	step 7 : wff = 3eqtr4a (step 1, step 5, step 6) |- ( A = ∅ → dom ( A × A ) = A ) ;;
	step 8 : wff = dmxp () |- ( A ≠ ∅ → dom ( A × A ) = A ) ;;
	step 9 : wff = pm2.61ine (step 7, step 8) |- dom ( A × A ) = A ;;
	qed prop 1 = step 9 ;;
}

/*The domain of the intersection of two square cross products.  Unlike
     ~ dmin , equality holds.  (Contributed by NM, 29-Jan-2008.) */

theorem dmxpin (A : class, B : class)  {
	prop 1 : wff = |- dom ( ( A × A ) ∩ ( B × B ) ) = ( A ∩ B ) ;;
}

proof of dmxpin {
	step 1 : wff = inxp () |- ( ( A × A ) ∩ ( B × B ) ) = ( ( A ∩ B ) × ( A ∩ B ) ) ;;
	step 2 : wff = dmeqi (step 1) |- dom ( ( A × A ) ∩ ( B × B ) ) = dom ( ( A ∩ B ) × ( A ∩ B ) ) ;;
	step 3 : wff = dmxpid () |- dom ( ( A ∩ B ) × ( A ∩ B ) ) = ( A ∩ B ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- dom ( ( A × A ) ∩ ( B × B ) ) = ( A ∩ B ) ;;
	qed prop 1 = step 4 ;;
}

/*The cross product of a class with itself is one-to-one.  (Contributed by
     NM, 5-Nov-2006.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem xpid11 (A : class, B : class)  {
	prop 1 : wff = |- ( ( A × A ) = ( B × B ) ↔ A = B ) ;;
}

proof of xpid11 {
	step 1 : wff = dmeq () |- ( ( A × A ) = ( B × B ) → dom ( A × A ) = dom ( B × B ) ) ;;
	step 2 : wff = dmxpid () |- dom ( A × A ) = A ;;
	step 3 : wff = dmxpid () |- dom ( B × B ) = B ;;
	step 4 : wff = 3eqtr3g (step 1, step 2, step 3) |- ( ( A × A ) = ( B × B ) → A = B ) ;;
	step 5 : wff = xpeq12 () |- ( ( A = B ∧ A = B ) → ( A × A ) = ( B × B ) ) ;;
	step 6 : wff = anidms (step 5) |- ( A = B → ( A × A ) = ( B × B ) ) ;;
	step 7 : wff = impbii (step 4, step 6) |- ( ( A × A ) = ( B × B ) ↔ A = B ) ;;
	qed prop 1 = step 7 ;;
}

/*The domain of the double converse of a class (which doesn't have to be a
     relation as in ~ dfrel2 ).  (Contributed by NM, 8-Apr-2007.) */

theorem dmcnvcnv (A : class)  {
	prop 1 : wff = |- dom ⁻¹ ⁻¹ A = dom A ;;
}

proof of dmcnvcnv {
	step 1 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 2 : wff = df-rn () |- ran ⁻¹ A = dom ⁻¹ ⁻¹ A ;;
	step 3 : wff = eqtr2i (step 1, step 2) |- dom ⁻¹ ⁻¹ A = dom A ;;
	qed prop 1 = step 3 ;;
}

/*The range of the double converse of a class.  (Contributed by NM,
     8-Apr-2007.) */

theorem rncnvcnv (A : class)  {
	prop 1 : wff = |- ran ⁻¹ ⁻¹ A = ran A ;;
}

proof of rncnvcnv {
	step 1 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 2 : wff = dfdm4 () |- dom ⁻¹ A = ran ⁻¹ ⁻¹ A ;;
	step 3 : wff = eqtr2i (step 1, step 2) |- ran ⁻¹ ⁻¹ A = ran A ;;
	qed prop 1 = step 3 ;;
}

/*The first member of an ordered pair in a relation belongs to the domain
       of the relation.  (Contributed by NM, 28-Jul-2004.) */

theorem elreldm (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ( Rel A ∧ B ∈ A ) → ⋂ ⋂ B ∈ dom A ) ;;
}

proof of elreldm {
	var x : set, y : set;;
	step 1 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 2 : wff = ssel () |- ( A ⊆ ( _V × _V ) → ( B ∈ A → B ∈ ( _V × _V ) ) ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( Rel A → ( B ∈ A → B ∈ ( _V × _V ) ) ) ;;
	step 4 : wff = elvv () |- ( B ∈ ( _V × _V ) ↔ ∃ x ∃ y B = 〈 x , y 〉 ) ;;
	step 5 : wff = syl6ib (step 3, step 4) |- ( Rel A → ( B ∈ A → ∃ x ∃ y B = 〈 x , y 〉 ) ) ;;
	step 6 : wff = eleq1 () |- ( B = 〈 x , y 〉 → ( B ∈ A ↔ 〈 x , y 〉 ∈ A ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opeldm (step 7, step 8) |- ( 〈 x , y 〉 ∈ A → x ∈ dom A ) ;;
	step 10 : wff = syl6bi (step 6, step 9) |- ( B = 〈 x , y 〉 → ( B ∈ A → x ∈ dom A ) ) ;;
	step 11 : wff = inteq () |- ( B = 〈 x , y 〉 → ⋂ B = ⋂ 〈 x , y 〉 ) ;;
	step 12 : wff = inteqd (step 11) |- ( B = 〈 x , y 〉 → ⋂ ⋂ B = ⋂ ⋂ 〈 x , y 〉 ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = op1stb (step 13, step 14) |- ⋂ ⋂ 〈 x , y 〉 = x ;;
	step 16 : wff = syl6eq (step 12, step 15) |- ( B = 〈 x , y 〉 → ⋂ ⋂ B = x ) ;;
	step 17 : wff = eleq1d (step 16) |- ( B = 〈 x , y 〉 → ( ⋂ ⋂ B ∈ dom A ↔ x ∈ dom A ) ) ;;
	step 18 : wff = sylibrd (step 10, step 17) |- ( B = 〈 x , y 〉 → ( B ∈ A → ⋂ ⋂ B ∈ dom A ) ) ;;
	step 19 : wff = exlimivv (step 18) |- ( ∃ x ∃ y B = 〈 x , y 〉 → ( B ∈ A → ⋂ ⋂ B ∈ dom A ) ) ;;
	step 20 : wff = syli (step 5, step 19) |- ( Rel A → ( B ∈ A → ⋂ ⋂ B ∈ dom A ) ) ;;
	step 21 : wff = imp (step 20) |- ( ( Rel A ∧ B ∈ A ) → ⋂ ⋂ B ∈ dom A ) ;;
	qed prop 1 = step 21 ;;
}

/*Equality theorem for range.  (Contributed by NM, 29-Dec-1996.) */

theorem rneq (A : class, B : class)  {
	prop 1 : wff = |- ( A = B → ran A = ran B ) ;;
}

proof of rneq {
	step 1 : wff = cnveq () |- ( A = B → ⁻¹ A = ⁻¹ B ) ;;
	step 2 : wff = dmeqd (step 1) |- ( A = B → dom ⁻¹ A = dom ⁻¹ B ) ;;
	step 3 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 4 : wff = df-rn () |- ran B = dom ⁻¹ B ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ran A = ran B ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality inference for range.  (Contributed by NM, 4-Mar-2004.) */

theorem rneqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ran A = ran B ;;
}

proof of rneqi {
	step 1 : wff = rneq () |- ( A = B → ran A = ran B ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ran A = ran B ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for range.  (Contributed by NM, 4-Mar-2004.) */

theorem rneqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ran A = ran B ) ;;
}

proof of rneqd {
	step 1 : wff = rneq () |- ( A = B → ran A = ran B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ran A = ran B ) ;;
	qed prop 1 = step 2 ;;
}

/*Subset theorem for range.  (Contributed by NM, 22-Mar-1998.) */

theorem rnss (A : class, B : class)  {
	prop 1 : wff = |- ( A ⊆ B → ran A ⊆ ran B ) ;;
}

proof of rnss {
	step 1 : wff = cnvss () |- ( A ⊆ B → ⁻¹ A ⊆ ⁻¹ B ) ;;
	step 2 : wff = dmss () |- ( ⁻¹ A ⊆ ⁻¹ B → dom ⁻¹ A ⊆ dom ⁻¹ B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ⊆ B → dom ⁻¹ A ⊆ dom ⁻¹ B ) ;;
	step 4 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 5 : wff = df-rn () |- ran B = dom ⁻¹ B ;;
	step 6 : wff = 3sstr4g (step 3, step 4, step 5) |- ( A ⊆ B → ran A ⊆ ran B ) ;;
	qed prop 1 = step 6 ;;
}

/*The second argument of a binary relation belongs to its range.
     (Contributed by NM, 29-Jun-2008.) */

theorem brelrng (A : class, B : class, C : class, F : class, G : class)  {
	prop 1 : wff = |- ( ( A ∈ F ∧ B ∈ G ∧ A C B ) → B ∈ ran C ) ;;
}

proof of brelrng {
	step 1 : wff = brcnvg () |- ( ( B ∈ G ∧ A ∈ F ) → ( B ⁻¹ C A ↔ A C B ) ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( A ∈ F ∧ B ∈ G ) → ( B ⁻¹ C A ↔ A C B ) ) ;;
	step 3 : wff = biimp3ar (step 2) |- ( ( A ∈ F ∧ B ∈ G ∧ A C B ) → B ⁻¹ C A ) ;;
	step 4 : wff = breldmg () |- ( ( B ∈ G ∧ A ∈ F ∧ B ⁻¹ C A ) → B ∈ dom ⁻¹ C ) ;;
	step 5 : wff = 3com12 (step 4) |- ( ( A ∈ F ∧ B ∈ G ∧ B ⁻¹ C A ) → B ∈ dom ⁻¹ C ) ;;
	step 6 : wff = syld3an3 (step 3, step 5) |- ( ( A ∈ F ∧ B ∈ G ∧ A C B ) → B ∈ dom ⁻¹ C ) ;;
	step 7 : wff = df-rn () |- ran C = dom ⁻¹ C ;;
	step 8 : wff = syl6eleqr (step 6, step 7) |- ( ( A ∈ F ∧ B ∈ G ∧ A C B ) → B ∈ ran C ) ;;
	qed prop 1 = step 8 ;;
}

/*The second argument of a binary relation belongs to its range.
       (Contributed by NM, 13-Aug-2004.) */

theorem brelrn (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A C B → B ∈ ran C ) ;;
}

proof of brelrn {
	step 1 : wff = brelrng () |- ( ( A ∈ _V ∧ B ∈ _V ∧ A C B ) → B ∈ ran C ) ;;
	step 2 : wff = mp3an12 (hyp 1, hyp 2, step 1) |- ( A C B → B ∈ ran C ) ;;
	qed prop 1 = step 2 ;;
}

/*Membership of second member of an ordered pair in a range.  (Contributed
       by NM, 23-Feb-1997.) */

theorem opelrn (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ C → B ∈ ran C ) ;;
}

proof of opelrn {
	step 1 : wff = df-br () |- ( A C B ↔ 〈 A , B 〉 ∈ C ) ;;
	step 2 : wff = brelrn (hyp 1, hyp 2) |- ( A C B → B ∈ ran C ) ;;
	step 3 : wff = sylbir (step 1, step 2) |- ( 〈 A , B 〉 ∈ C → B ∈ ran C ) ;;
	qed prop 1 = step 3 ;;
}

/*The first argument of a binary relation belongs to its domain.
     (Contributed by NM, 2-Jul-2008.) */

theorem releldm (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A R B ) → A ∈ dom R ) ;;
}

proof of releldm {
	step 1 : wff = brrelex () |- ( ( Rel R ∧ A R B ) → A ∈ _V ) ;;
	step 2 : wff = brrelex2 () |- ( ( Rel R ∧ A R B ) → B ∈ _V ) ;;
	step 3 : wff = simpr () |- ( ( Rel R ∧ A R B ) → A R B ) ;;
	step 4 : wff = breldmg () |- ( ( A ∈ _V ∧ B ∈ _V ∧ A R B ) → A ∈ dom R ) ;;
	step 5 : wff = syl3anc (step 1, step 2, step 3, step 4) |- ( ( Rel R ∧ A R B ) → A ∈ dom R ) ;;
	qed prop 1 = step 5 ;;
}

/*The second argument of a binary relation belongs to its range.
     (Contributed by NM, 2-Jul-2008.) */

theorem relelrn (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A R B ) → B ∈ ran R ) ;;
}

proof of relelrn {
	step 1 : wff = brrelex () |- ( ( Rel R ∧ A R B ) → A ∈ _V ) ;;
	step 2 : wff = brrelex2 () |- ( ( Rel R ∧ A R B ) → B ∈ _V ) ;;
	step 3 : wff = simpr () |- ( ( Rel R ∧ A R B ) → A R B ) ;;
	step 4 : wff = brelrng () |- ( ( A ∈ _V ∧ B ∈ _V ∧ A R B ) → B ∈ ran R ) ;;
	step 5 : wff = syl3anc (step 1, step 2, step 3, step 4) |- ( ( Rel R ∧ A R B ) → B ∈ ran R ) ;;
	qed prop 1 = step 5 ;;
}

/*Membership in a domain.  (Contributed by Mario Carneiro, 5-Nov-2015.) */

theorem releldmb (x : set, A : class, R : class) disjointed(x A, x R) {
	prop 1 : wff = |- ( Rel R → ( A ∈ dom R ↔ ∃ x A R x ) ) ;;
}

proof of releldmb {
	step 1 : wff = eldmg () |- ( A ∈ dom R → ( A ∈ dom R ↔ ∃ x A R x ) ) ;;
	step 2 : wff = ibi (step 1) |- ( A ∈ dom R → ∃ x A R x ) ;;
	step 3 : wff = releldm () |- ( ( Rel R ∧ A R x ) → A ∈ dom R ) ;;
	step 4 : wff = ex (step 3) |- ( Rel R → ( A R x → A ∈ dom R ) ) ;;
	step 5 : wff = exlimdv (step 4) |- ( Rel R → ( ∃ x A R x → A ∈ dom R ) ) ;;
	step 6 : wff = impbid2 (step 2, step 5) |- ( Rel R → ( A ∈ dom R ↔ ∃ x A R x ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Membership in a range.  (Contributed by Mario Carneiro, 5-Nov-2015.) */

theorem relelrnb (x : set, A : class, R : class) disjointed(x A, x R) {
	prop 1 : wff = |- ( Rel R → ( A ∈ ran R ↔ ∃ x x R A ) ) ;;
}

proof of relelrnb {
	step 1 : wff = elrng () |- ( A ∈ ran R → ( A ∈ ran R ↔ ∃ x x R A ) ) ;;
	step 2 : wff = ibi (step 1) |- ( A ∈ ran R → ∃ x x R A ) ;;
	step 3 : wff = relelrn () |- ( ( Rel R ∧ x R A ) → A ∈ ran R ) ;;
	step 4 : wff = ex (step 3) |- ( Rel R → ( x R A → A ∈ ran R ) ) ;;
	step 5 : wff = exlimdv (step 4) |- ( Rel R → ( ∃ x x R A → A ∈ ran R ) ) ;;
	step 6 : wff = impbid2 (step 2, step 5) |- ( Rel R → ( A ∈ ran R ↔ ∃ x x R A ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The first argument of a binary relation belongs to its domain.
       (Contributed by NM, 28-Apr-2015.) */

theorem releldmi (A : class, B : class, R : class)  {
	hyp 1 : wff = |- Rel R ;;
	-----------------------
	prop 1 : wff = |- ( A R B → A ∈ dom R ) ;;
}

proof of releldmi {
	step 1 : wff = releldm () |- ( ( Rel R ∧ A R B ) → A ∈ dom R ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( A R B → A ∈ dom R ) ;;
	qed prop 1 = step 2 ;;
}

/*The second argument of a binary relation belongs to its range.
       (Contributed by NM, 28-Apr-2015.) */

theorem relelrni (A : class, B : class, R : class)  {
	hyp 1 : wff = |- Rel R ;;
	-----------------------
	prop 1 : wff = |- ( A R B → B ∈ ran R ) ;;
}

proof of relelrni {
	step 1 : wff = relelrn () |- ( ( Rel R ∧ A R B ) → B ∈ ran R ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( A R B → B ∈ ran R ) ;;
	qed prop 1 = step 2 ;;
}

/*Definition of range, using bound-variable hypotheses instead of distinct
       variable conditions.  (Contributed by NM, 14-Aug-1995.)  (Revised by
       Mario Carneiro, 15-Oct-2016.) */

theorem dfrnf (x : set, y : set, A : class) disjointed(x y w v, w v A) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	-----------------------
	prop 1 : wff = |- ran A = { y | ∃ x x A y } ;;
}

proof of dfrnf {
	var w : set, v : set;;
	step 1 : wff = dfrn2 () |- ran A = { w | ∃ v v A w } ;;
	step 2 : wff = nfcv () |- F/_ x v ;;
	step 3 : wff = nfcv () |- F/_ x w ;;
	step 4 : wff = nfbr (step 2, hyp 1, step 3) |- F/ x v A w ;;
	step 5 : wff = nfv () |- F/ v x A w ;;
	step 6 : wff = breq1 () |- ( v = x → ( v A w ↔ x A w ) ) ;;
	step 7 : wff = cbvex (step 4, step 5, step 6) |- ( ∃ v v A w ↔ ∃ x x A w ) ;;
	step 8 : wff = abbii (step 7) |- { w | ∃ v v A w } = { w | ∃ x x A w } ;;
	step 9 : wff = nfcv () |- F/_ y x ;;
	step 10 : wff = nfcv () |- F/_ y w ;;
	step 11 : wff = nfbr (step 9, hyp 2, step 10) |- F/ y x A w ;;
	step 12 : wff = nfex (step 11) |- F/ y ∃ x x A w ;;
	step 13 : wff = nfv () |- F/ w ∃ x x A y ;;
	step 14 : wff = breq2 () |- ( w = y → ( x A w ↔ x A y ) ) ;;
	step 15 : wff = exbidv (step 14) |- ( w = y → ( ∃ x x A w ↔ ∃ x x A y ) ) ;;
	step 16 : wff = cbvab (step 12, step 13, step 15) |- { w | ∃ x x A w } = { y | ∃ x x A y } ;;
	step 17 : wff = 3eqtri (step 1, step 8, step 16) |- ran A = { y | ∃ x x A y } ;;
	qed prop 1 = step 17 ;;
}

/*Membership in a range.  (Contributed by NM, 10-Jul-1994.) */

theorem elrn2 (x : set, A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ran B ↔ ∃ x 〈 x , A 〉 ∈ B ) ;;
}

proof of elrn2 {
	var y : set;;
	step 1 : wff = opeq2 () |- ( y = A → 〈 x , y 〉 = 〈 x , A 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( y = A → ( 〈 x , y 〉 ∈ B ↔ 〈 x , A 〉 ∈ B ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( y = A → ( ∃ x 〈 x , y 〉 ∈ B ↔ ∃ x 〈 x , A 〉 ∈ B ) ) ;;
	step 4 : wff = dfrn3 () |- ran B = { y | ∃ x 〈 x , y 〉 ∈ B } ;;
	step 5 : wff = elab2 (hyp 1, step 3, step 4) |- ( A ∈ ran B ↔ ∃ x 〈 x , A 〉 ∈ B ) ;;
	qed prop 1 = step 5 ;;
}

/*Membership in a range.  (Contributed by NM, 2-Apr-2004.) */

theorem elrn (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ran B ↔ ∃ x x B A ) ;;
}

proof of elrn {
	step 1 : wff = elrn2 (hyp 1) |- ( A ∈ ran B ↔ ∃ x 〈 x , A 〉 ∈ B ) ;;
	step 2 : wff = df-br () |- ( x B A ↔ 〈 x , A 〉 ∈ B ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x x B A ↔ ∃ x 〈 x , A 〉 ∈ B ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( A ∈ ran B ↔ ∃ x x B A ) ;;
	qed prop 1 = step 4 ;;
}

/*Bound-variable hypothesis builder for domain.  (Contributed by NM,
       30-Jan-2004.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nfdm (x : set, A : class) disjointed(x y z, y z A) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x dom A ;;
}

proof of nfdm {
	var y : set, z : set;;
	step 1 : wff = df-dm () |- dom A = { y | ∃ z y A z } ;;
	step 2 : wff = nfcv () |- F/_ x y ;;
	step 3 : wff = nfcv () |- F/_ x z ;;
	step 4 : wff = nfbr (step 2, hyp 1, step 3) |- F/ x y A z ;;
	step 5 : wff = nfex (step 4) |- F/ x ∃ z y A z ;;
	step 6 : wff = nfab (step 5) |- F/_ x { y | ∃ z y A z } ;;
	step 7 : wff = nfcxfr (step 1, step 6) |- F/_ x dom A ;;
	qed prop 1 = step 7 ;;
}

/*Bound-variable hypothesis builder for range.  (Contributed by NM,
       1-Sep-1999.)  (Revised by Mario Carneiro, 15-Oct-2016.) */

theorem nfrn (x : set, A : class) disjointed(x, A) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x ran A ;;
}

proof of nfrn {
	step 1 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 2 : wff = nfcnv (hyp 1) |- F/_ x ⁻¹ A ;;
	step 3 : wff = nfdm (step 2) |- F/_ x dom ⁻¹ A ;;
	step 4 : wff = nfcxfr (step 1, step 3) |- F/_ x ran A ;;
	qed prop 1 = step 4 ;;
}

/*Domain of an intersection.  (Contributed by FL, 15-Oct-2012.) */

theorem dmiin (x : set, A : class, B : class) disjointed(A, B, x) {
	prop 1 : wff = |- dom ⋂_ x ∈ A B ⊆ ⋂_ x ∈ A dom B ;;
}

proof of dmiin {
	step 1 : wff = nfii1 () |- F/_ x ⋂_ x ∈ A B ;;
	step 2 : wff = nfdm (step 1) |- F/_ x dom ⋂_ x ∈ A B ;;
	step 3 : wff = ssiinf (step 2) |- ( dom ⋂_ x ∈ A B ⊆ ⋂_ x ∈ A dom B ↔ ∀ x ∈ A dom ⋂_ x ∈ A B ⊆ dom B ) ;;
	step 4 : wff = iinss2 () |- ( x ∈ A → ⋂_ x ∈ A B ⊆ B ) ;;
	step 5 : wff = dmss () |- ( ⋂_ x ∈ A B ⊆ B → dom ⋂_ x ∈ A B ⊆ dom B ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( x ∈ A → dom ⋂_ x ∈ A B ⊆ dom B ) ;;
	step 7 : wff = mprgbir (step 3, step 6) |- dom ⋂_ x ∈ A B ⊆ ⋂_ x ∈ A dom B ;;
	qed prop 1 = step 7 ;;
}

/*Distribute proper substitution through the range of a class.
       (Contributed by Alan Sare, 10-Nov-2012.) */

theorem csbrng (x : set, A : class, B : class, V : class) disjointed(A w y, B w y, V w y, x w y) {
	prop 1 : wff = |- ( A ∈ V → [_ A / x ]_ ran B = ran [_ A / x ]_ B ) ;;
}

proof of csbrng {
	var y : set, w : set;;
	step 1 : wff = csbabg () |- ( A ∈ V → [_ A / x ]_ { y | ∃ w 〈 w , y 〉 ∈ B } = { y | [. A / x ]. ∃ w 〈 w , y 〉 ∈ B } ) ;;
	step 2 : wff = sbcexg () |- ( A ∈ V → ( [. A / x ]. ∃ w 〈 w , y 〉 ∈ B ↔ ∃ w [. A / x ]. 〈 w , y 〉 ∈ B ) ) ;;
	step 3 : wff = sbcel2g () |- ( A ∈ V → ( [. A / x ]. 〈 w , y 〉 ∈ B ↔ 〈 w , y 〉 ∈ [_ A / x ]_ B ) ) ;;
	step 4 : wff = exbidv (step 3) |- ( A ∈ V → ( ∃ w [. A / x ]. 〈 w , y 〉 ∈ B ↔ ∃ w 〈 w , y 〉 ∈ [_ A / x ]_ B ) ) ;;
	step 5 : wff = bitrd (step 2, step 4) |- ( A ∈ V → ( [. A / x ]. ∃ w 〈 w , y 〉 ∈ B ↔ ∃ w 〈 w , y 〉 ∈ [_ A / x ]_ B ) ) ;;
	step 6 : wff = abbidv (step 5) |- ( A ∈ V → { y | [. A / x ]. ∃ w 〈 w , y 〉 ∈ B } = { y | ∃ w 〈 w , y 〉 ∈ [_ A / x ]_ B } ) ;;
	step 7 : wff = eqtrd (step 1, step 6) |- ( A ∈ V → [_ A / x ]_ { y | ∃ w 〈 w , y 〉 ∈ B } = { y | ∃ w 〈 w , y 〉 ∈ [_ A / x ]_ B } ) ;;
	step 8 : wff = dfrn3 () |- ran B = { y | ∃ w 〈 w , y 〉 ∈ B } ;;
	step 9 : wff = csbeq2i (step 8) |- [_ A / x ]_ ran B = [_ A / x ]_ { y | ∃ w 〈 w , y 〉 ∈ B } ;;
	step 10 : wff = dfrn3 () |- ran [_ A / x ]_ B = { y | ∃ w 〈 w , y 〉 ∈ [_ A / x ]_ B } ;;
	step 11 : wff = 3eqtr4g (step 7, step 9, step 10) |- ( A ∈ V → [_ A / x ]_ ran B = ran [_ A / x ]_ B ) ;;
	qed prop 1 = step 11 ;;
}

/*The range of a class of ordered pairs.  (Contributed by NM,
       14-Aug-1995.)  (Revised by Mario Carneiro, 4-Dec-2016.) */

theorem rnopab (ph : wff, x : set, y : set) disjointed(x y, ph) {
	prop 1 : wff = |- ran { 〈 x , y 〉 | ph } = { y | ∃ x ph } ;;
}

proof of rnopab {
	step 1 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ph } ;;
	step 2 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ph } ;;
	step 3 : wff = dfrnf (step 1, step 2) |- ran { 〈 x , y 〉 | ph } = { y | ∃ x x { 〈 x , y 〉 | ph } y } ;;
	step 4 : wff = df-br () |- ( x { 〈 x , y 〉 | ph } y ↔ 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 5 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( x { 〈 x , y 〉 | ph } y ↔ ph ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ x x { 〈 x , y 〉 | ph } y ↔ ∃ x ph ) ;;
	step 8 : wff = abbii (step 7) |- { y | ∃ x x { 〈 x , y 〉 | ph } y } = { y | ∃ x ph } ;;
	step 9 : wff = eqtri (step 3, step 8) |- ran { 〈 x , y 〉 | ph } = { y | ∃ x ph } ;;
	qed prop 1 = step 9 ;;
}

/*The range of a function in maps-to notation.  (Contributed by Scott
       Fenton, 21-Mar-2011.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem rnmpt (x : set, y : set, A : class, B : class, F : class) disjointed(y A, y B, x y) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ran F = { y | ∃ x ∈ A y = B } ;;
}

proof of rnmpt {
	step 1 : wff = rnopab () |- ran { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } = { y | ∃ x ( x ∈ A ∧ y = B ) } ;;
	step 2 : wff = df-mpt () |- ( x ∈ A ↦ B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 3 : wff = eqtri (hyp 1, step 2) |- F = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 4 : wff = rneqi (step 3) |- ran F = ran { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 5 : wff = df-rex () |- ( ∃ x ∈ A y = B ↔ ∃ x ( x ∈ A ∧ y = B ) ) ;;
	step 6 : wff = abbii (step 5) |- { y | ∃ x ∈ A y = B } = { y | ∃ x ( x ∈ A ∧ y = B ) } ;;
	step 7 : wff = 3eqtr4i (step 1, step 4, step 6) |- ran F = { y | ∃ x ∈ A y = B } ;;
	qed prop 1 = step 7 ;;
}

/*The range of a function in maps-to notation.  (Contributed by Mario
       Carneiro, 20-Feb-2015.) */

theorem elrnmpt (x : set, A : class, B : class, C : class, F : class, V : class) disjointed(y A, y B, x y C) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ V → ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ) ;;
}

proof of elrnmpt {
	var y : set;;
	step 1 : wff = eqeq1 () |- ( y = C → ( y = B ↔ C = B ) ) ;;
	step 2 : wff = rexbidv (step 1) |- ( y = C → ( ∃ x ∈ A y = B ↔ ∃ x ∈ A C = B ) ) ;;
	step 3 : wff = rnmpt (hyp 1) |- ran F = { y | ∃ x ∈ A y = B } ;;
	step 4 : wff = elab2g (step 2, step 3) |- ( C ∈ V → ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Elementhood in an image set.  (Contributed by Mario Carneiro,
         12-Sep-2015.) */

theorem elrnmpt1s (x : set, A : class, B : class, C : class, D : class, F : class, V : class) disjointed(A, B, x C, x A, x D) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	hyp 2 : wff = |- ( x = D → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( D ∈ A ∧ C ∈ V ) → C ∈ ran F ) ;;
}

proof of elrnmpt1s {
	step 1 : wff = eqid () |- C = C ;;
	step 2 : wff = eqeq2d (hyp 2) |- ( x = D → ( C = B ↔ C = C ) ) ;;
	step 3 : wff = rspcev (step 2) |- ( ( D ∈ A ∧ C = C ) → ∃ x ∈ A C = B ) ;;
	step 4 : wff = mpan2 (step 1, step 3) |- ( D ∈ A → ∃ x ∈ A C = B ) ;;
	step 5 : wff = elrnmpt (hyp 1) |- ( C ∈ V → ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ) ;;
	step 6 : wff = biimparc (step 5) |- ( ( ∃ x ∈ A C = B ∧ C ∈ V ) → C ∈ ran F ) ;;
	step 7 : wff = sylan (step 4, step 6) |- ( ( D ∈ A ∧ C ∈ V ) → C ∈ ran F ) ;;
	qed prop 1 = step 7 ;;
}

/*Elementhood in an image set.  (Contributed by Mario Carneiro,
       31-Aug-2015.) */

theorem elrnmpt1 (x : set, A : class, B : class, F : class, V : class) disjointed(y z A, y z B, x y z) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ A ∧ B ∈ V ) → B ∈ ran F ) ;;
}

proof of elrnmpt1 {
	var y : set, z : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = id () |- ( x = z → x = z ) ;;
	step 3 : wff = csbeq1a () |- ( x = z → A = [_ z / x ]_ A ) ;;
	step 4 : wff = eleq12d (step 2, step 3) |- ( x = z → ( x ∈ A ↔ z ∈ [_ z / x ]_ A ) ) ;;
	step 5 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 6 : wff = biantrud (step 5) |- ( x = z → ( z ∈ [_ z / x ]_ A ↔ ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ) ) ;;
	step 7 : wff = bitr2d (step 4, step 6) |- ( x = z → ( ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ↔ x ∈ A ) ) ;;
	step 8 : wff = eqcoms (step 7) |- ( z = x → ( ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ↔ x ∈ A ) ) ;;
	step 9 : wff = spcev (step 1, step 8) |- ( x ∈ A → ∃ z ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ) ;;
	step 10 : wff = df-rex () |- ( ∃ x ∈ A y = B ↔ ∃ x ( x ∈ A ∧ y = B ) ) ;;
	step 11 : wff = nfv () |- F/ z ( x ∈ A ∧ y = B ) ;;
	step 12 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ A ;;
	step 13 : wff = nfel2 (step 12) |- F/ x z ∈ [_ z / x ]_ A ;;
	step 14 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ B ;;
	step 15 : wff = nfeq2 (step 14) |- F/ x y = [_ z / x ]_ B ;;
	step 16 : wff = nfan (step 13, step 15) |- F/ x ( z ∈ [_ z / x ]_ A ∧ y = [_ z / x ]_ B ) ;;
	step 17 : wff = id () |- ( x = z → x = z ) ;;
	step 18 : wff = csbeq1a () |- ( x = z → A = [_ z / x ]_ A ) ;;
	step 19 : wff = eleq12d (step 17, step 18) |- ( x = z → ( x ∈ A ↔ z ∈ [_ z / x ]_ A ) ) ;;
	step 20 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 21 : wff = eqeq2d (step 20) |- ( x = z → ( y = B ↔ y = [_ z / x ]_ B ) ) ;;
	step 22 : wff = anbi12d (step 19, step 21) |- ( x = z → ( ( x ∈ A ∧ y = B ) ↔ ( z ∈ [_ z / x ]_ A ∧ y = [_ z / x ]_ B ) ) ) ;;
	step 23 : wff = cbvex (step 11, step 16, step 22) |- ( ∃ x ( x ∈ A ∧ y = B ) ↔ ∃ z ( z ∈ [_ z / x ]_ A ∧ y = [_ z / x ]_ B ) ) ;;
	step 24 : wff = bitri (step 10, step 23) |- ( ∃ x ∈ A y = B ↔ ∃ z ( z ∈ [_ z / x ]_ A ∧ y = [_ z / x ]_ B ) ) ;;
	step 25 : wff = eqeq1 () |- ( y = B → ( y = [_ z / x ]_ B ↔ B = [_ z / x ]_ B ) ) ;;
	step 26 : wff = anbi2d (step 25) |- ( y = B → ( ( z ∈ [_ z / x ]_ A ∧ y = [_ z / x ]_ B ) ↔ ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ) ) ;;
	step 27 : wff = exbidv (step 26) |- ( y = B → ( ∃ z ( z ∈ [_ z / x ]_ A ∧ y = [_ z / x ]_ B ) ↔ ∃ z ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ) ) ;;
	step 28 : wff = syl5bb (step 24, step 27) |- ( y = B → ( ∃ x ∈ A y = B ↔ ∃ z ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ) ) ;;
	step 29 : wff = rnmpt (hyp 1) |- ran F = { y | ∃ x ∈ A y = B } ;;
	step 30 : wff = elab2g (step 28, step 29) |- ( B ∈ V → ( B ∈ ran F ↔ ∃ z ( z ∈ [_ z / x ]_ A ∧ B = [_ z / x ]_ B ) ) ) ;;
	step 31 : wff = syl5ibr (step 9, step 30) |- ( B ∈ V → ( x ∈ A → B ∈ ran F ) ) ;;
	step 32 : wff = impcom (step 31) |- ( ( x ∈ A ∧ B ∈ V ) → B ∈ ran F ) ;;
	qed prop 1 = step 32 ;;
}

/*Membership in the range of a function.  (Contributed by NM,
       27-Aug-2007.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem elrnmptg (x : set, A : class, B : class, C : class, F : class, V : class) disjointed(y A, y B, x y C) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ V → ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ) ;;
}

proof of elrnmptg {
	var y : set;;
	step 1 : wff = rnmpt (hyp 1) |- ran F = { y | ∃ x ∈ A y = B } ;;
	step 2 : wff = eleq2i (step 1) |- ( C ∈ ran F ↔ C ∈ { y | ∃ x ∈ A y = B } ) ;;
	step 3 : wff = r19.29 () |- ( ( ∀ x ∈ A B ∈ V ∧ ∃ x ∈ A C = B ) → ∃ x ∈ A ( B ∈ V ∧ C = B ) ) ;;
	step 4 : wff = eleq1 () |- ( C = B → ( C ∈ V ↔ B ∈ V ) ) ;;
	step 5 : wff = biimparc (step 4) |- ( ( B ∈ V ∧ C = B ) → C ∈ V ) ;;
	step 6 : wff = elex () |- ( C ∈ V → C ∈ _V ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ( B ∈ V ∧ C = B ) → C ∈ _V ) ;;
	step 8 : wff = rexlimivw (step 7) |- ( ∃ x ∈ A ( B ∈ V ∧ C = B ) → C ∈ _V ) ;;
	step 9 : wff = syl (step 3, step 8) |- ( ( ∀ x ∈ A B ∈ V ∧ ∃ x ∈ A C = B ) → C ∈ _V ) ;;
	step 10 : wff = ex (step 9) |- ( ∀ x ∈ A B ∈ V → ( ∃ x ∈ A C = B → C ∈ _V ) ) ;;
	step 11 : wff = eqeq1 () |- ( y = C → ( y = B ↔ C = B ) ) ;;
	step 12 : wff = rexbidv (step 11) |- ( y = C → ( ∃ x ∈ A y = B ↔ ∃ x ∈ A C = B ) ) ;;
	step 13 : wff = elab3g (step 12) |- ( ( ∃ x ∈ A C = B → C ∈ _V ) → ( C ∈ { y | ∃ x ∈ A y = B } ↔ ∃ x ∈ A C = B ) ) ;;
	step 14 : wff = syl (step 10, step 13) |- ( ∀ x ∈ A B ∈ V → ( C ∈ { y | ∃ x ∈ A y = B } ↔ ∃ x ∈ A C = B ) ) ;;
	step 15 : wff = syl5bb (step 2, step 14) |- ( ∀ x ∈ A B ∈ V → ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Membership in the range of a function.  (Contributed by NM,
       30-Aug-2004.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem elrnmpti (x : set, A : class, B : class, C : class, F : class) disjointed(A, B, x C) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ;;
}

proof of elrnmpti {
	step 1 : wff = rgenw (hyp 2) |- ∀ x ∈ A B ∈ _V ;;
	step 2 : wff = elrnmptg (hyp 1) |- ( ∀ x ∈ A B ∈ _V → ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( C ∈ ran F ↔ ∃ x ∈ A C = B ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of indexed union when ` B ` is a set.  (Contributed
       by Mario Carneiro, 31-Aug-2015.) */

theorem dfiun3g (x : set, A : class, B : class, C : class) disjointed(y A, y B, C, x y) {
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ C → ⋃_ x ∈ A B = ⋃ ran ( x ∈ A ↦ B ) ) ;;
}

proof of dfiun3g {
	var y : set;;
	step 1 : wff = dfiun2g () |- ( ∀ x ∈ A B ∈ C → ⋃_ x ∈ A B = ⋃ { y | ∃ x ∈ A y = B } ) ;;
	step 2 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 3 : wff = rnmpt (step 2) |- ran ( x ∈ A ↦ B ) = { y | ∃ x ∈ A y = B } ;;
	step 4 : wff = unieqi (step 3) |- ⋃ ran ( x ∈ A ↦ B ) = ⋃ { y | ∃ x ∈ A y = B } ;;
	step 5 : wff = syl6eqr (step 1, step 4) |- ( ∀ x ∈ A B ∈ C → ⋃_ x ∈ A B = ⋃ ran ( x ∈ A ↦ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Alternate definition of indexed intersection when ` B ` is a set.
       (Contributed by Mario Carneiro, 31-Aug-2015.) */

theorem dfiin3g (x : set, A : class, B : class, C : class) disjointed(y A, y B, C, x y) {
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ C → ⋂_ x ∈ A B = ⋂ ran ( x ∈ A ↦ B ) ) ;;
}

proof of dfiin3g {
	var y : set;;
	step 1 : wff = dfiin2g () |- ( ∀ x ∈ A B ∈ C → ⋂_ x ∈ A B = ⋂ { y | ∃ x ∈ A y = B } ) ;;
	step 2 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 3 : wff = rnmpt (step 2) |- ran ( x ∈ A ↦ B ) = { y | ∃ x ∈ A y = B } ;;
	step 4 : wff = inteqi (step 3) |- ⋂ ran ( x ∈ A ↦ B ) = ⋂ { y | ∃ x ∈ A y = B } ;;
	step 5 : wff = syl6eqr (step 1, step 4) |- ( ∀ x ∈ A B ∈ C → ⋂_ x ∈ A B = ⋂ ran ( x ∈ A ↦ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Alternate definition of indexed union when ` B ` is a set.  (Contributed
       by Mario Carneiro, 31-Aug-2015.) */

theorem dfiun3 (x : set, A : class, B : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋃_ x ∈ A B = ⋃ ran ( x ∈ A ↦ B ) ;;
}

proof of dfiun3 {
	step 1 : wff = dfiun3g () |- ( ∀ x ∈ A B ∈ _V → ⋃_ x ∈ A B = ⋃ ran ( x ∈ A ↦ B ) ) ;;
	step 2 : wff = a1i (hyp 1) |- ( x ∈ A → B ∈ _V ) ;;
	step 3 : wff = mprg (step 1, step 2) |- ⋃_ x ∈ A B = ⋃ ran ( x ∈ A ↦ B ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of indexed intersection when ` B ` is a set.
       (Contributed by Mario Carneiro, 31-Aug-2015.) */

theorem dfiin3 (x : set, A : class, B : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂_ x ∈ A B = ⋂ ran ( x ∈ A ↦ B ) ;;
}

proof of dfiin3 {
	step 1 : wff = dfiin3g () |- ( ∀ x ∈ A B ∈ _V → ⋂_ x ∈ A B = ⋂ ran ( x ∈ A ↦ B ) ) ;;
	step 2 : wff = a1i (hyp 1) |- ( x ∈ A → B ∈ _V ) ;;
	step 3 : wff = mprg (step 1, step 2) |- ⋂_ x ∈ A B = ⋂ ran ( x ∈ A ↦ B ) ;;
	qed prop 1 = step 3 ;;
}

/*Express a relative indexed intersection as an intersection.
       (Contributed by Stefan O'Rear, 22-Feb-2015.) */

theorem riinint (S : class, k : set, I : class, V : class, X : class) disjointed(I, S, V k, X k, k) {
	prop 1 : wff = |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ( X ∩ ⋂_ k ∈ I S ) = ⋂ ( { X } ∪ ran ( k ∈ I ↦ S ) ) ) ;;
}

proof of riinint {
	step 1 : wff = ssexg () |- ( ( S ⊆ X ∧ X ∈ V ) → S ∈ _V ) ;;
	step 2 : wff = expcom (step 1) |- ( X ∈ V → ( S ⊆ X → S ∈ _V ) ) ;;
	step 3 : wff = ralimdv (step 2) |- ( X ∈ V → ( ∀ k ∈ I S ⊆ X → ∀ k ∈ I S ∈ _V ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ∀ k ∈ I S ∈ _V ) ;;
	step 5 : wff = dfiin3g () |- ( ∀ k ∈ I S ∈ _V → ⋂_ k ∈ I S = ⋂ ran ( k ∈ I ↦ S ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ⋂_ k ∈ I S = ⋂ ran ( k ∈ I ↦ S ) ) ;;
	step 7 : wff = ineq2d (step 6) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ( X ∩ ⋂_ k ∈ I S ) = ( X ∩ ⋂ ran ( k ∈ I ↦ S ) ) ) ;;
	step 8 : wff = intun () |- ⋂ ( { X } ∪ ran ( k ∈ I ↦ S ) ) = ( ⋂ { X } ∩ ⋂ ran ( k ∈ I ↦ S ) ) ;;
	step 9 : wff = intsng () |- ( X ∈ V → ⋂ { X } = X ) ;;
	step 10 : wff = adantr (step 9) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ⋂ { X } = X ) ;;
	step 11 : wff = ineq1d (step 10) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ( ⋂ { X } ∩ ⋂ ran ( k ∈ I ↦ S ) ) = ( X ∩ ⋂ ran ( k ∈ I ↦ S ) ) ) ;;
	step 12 : wff = syl5eq (step 8, step 11) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ⋂ ( { X } ∪ ran ( k ∈ I ↦ S ) ) = ( X ∩ ⋂ ran ( k ∈ I ↦ S ) ) ) ;;
	step 13 : wff = eqtr4d (step 7, step 12) |- ( ( X ∈ V ∧ ∀ k ∈ I S ⊆ X ) → ( X ∩ ⋂_ k ∈ I S ) = ⋂ ( { X } ∪ ran ( k ∈ I ↦ S ) ) ) ;;
	qed prop 1 = step 13 ;;
}

/*The range of the empty set is empty.  Part of Theorem 3.8(v) of [Monk1]
     p. 36.  (Contributed by NM, 4-Jul-1994.) */

theorem rn0 ()  {
	prop 1 : wff = |- ran ∅ = ∅ ;;
}

proof of rn0 {
	step 1 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 2 : wff = dm0rn0 () |- ( dom ∅ = ∅ ↔ ran ∅ = ∅ ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- ran ∅ = ∅ ;;
	qed prop 1 = step 3 ;;
}

/*A relation is empty iff its range is empty.  (Contributed by NM,
       15-Sep-2004.) */

theorem relrn0 (A : class) disjointed(A) {
	prop 1 : wff = |- ( Rel A → ( A = ∅ ↔ ran A = ∅ ) ) ;;
}

proof of relrn0 {
	step 1 : wff = reldm0 () |- ( Rel A → ( A = ∅ ↔ dom A = ∅ ) ) ;;
	step 2 : wff = dm0rn0 () |- ( dom A = ∅ ↔ ran A = ∅ ) ;;
	step 3 : wff = syl6bb (step 1, step 2) |- ( Rel A → ( A = ∅ ↔ ran A = ∅ ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain and range of a class are included in its double union.
       (Contributed by NM, 13-May-2008.) */

theorem dmrnssfld (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( dom A ∪ ran A ) ⊆ ⋃ ⋃ A ;;
}

proof of dmrnssfld {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = eldm2 (step 1) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = prid1 (step 3) |- x ∈ { x , y } ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = uniop (step 5, step 6) |- ⋃ 〈 x , y 〉 = { x , y } ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = uniopel (step 8, step 9) |- ( 〈 x , y 〉 ∈ A → ⋃ 〈 x , y 〉 ∈ ⋃ A ) ;;
	step 11 : wff = syl5eqelr (step 7, step 10) |- ( 〈 x , y 〉 ∈ A → { x , y } ∈ ⋃ A ) ;;
	step 12 : wff = elssuni () |- ( { x , y } ∈ ⋃ A → { x , y } ⊆ ⋃ ⋃ A ) ;;
	step 13 : wff = syl (step 11, step 12) |- ( 〈 x , y 〉 ∈ A → { x , y } ⊆ ⋃ ⋃ A ) ;;
	step 14 : wff = sseld (step 13) |- ( 〈 x , y 〉 ∈ A → ( x ∈ { x , y } → x ∈ ⋃ ⋃ A ) ) ;;
	step 15 : wff = mpi (step 4, step 14) |- ( 〈 x , y 〉 ∈ A → x ∈ ⋃ ⋃ A ) ;;
	step 16 : wff = exlimiv (step 15) |- ( ∃ y 〈 x , y 〉 ∈ A → x ∈ ⋃ ⋃ A ) ;;
	step 17 : wff = sylbi (step 2, step 16) |- ( x ∈ dom A → x ∈ ⋃ ⋃ A ) ;;
	step 18 : wff = ssriv (step 17) |- dom A ⊆ ⋃ ⋃ A ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = elrn2 (step 19) |- ( y ∈ ran A ↔ ∃ x 〈 x , y 〉 ∈ A ) ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = prid2 (step 21) |- y ∈ { x , y } ;;
	step 23 : wff = vex () |- x ∈ _V ;;
	step 24 : wff = vex () |- y ∈ _V ;;
	step 25 : wff = uniop (step 23, step 24) |- ⋃ 〈 x , y 〉 = { x , y } ;;
	step 26 : wff = vex () |- x ∈ _V ;;
	step 27 : wff = vex () |- y ∈ _V ;;
	step 28 : wff = uniopel (step 26, step 27) |- ( 〈 x , y 〉 ∈ A → ⋃ 〈 x , y 〉 ∈ ⋃ A ) ;;
	step 29 : wff = syl5eqelr (step 25, step 28) |- ( 〈 x , y 〉 ∈ A → { x , y } ∈ ⋃ A ) ;;
	step 30 : wff = elssuni () |- ( { x , y } ∈ ⋃ A → { x , y } ⊆ ⋃ ⋃ A ) ;;
	step 31 : wff = syl (step 29, step 30) |- ( 〈 x , y 〉 ∈ A → { x , y } ⊆ ⋃ ⋃ A ) ;;
	step 32 : wff = sseld (step 31) |- ( 〈 x , y 〉 ∈ A → ( y ∈ { x , y } → y ∈ ⋃ ⋃ A ) ) ;;
	step 33 : wff = mpi (step 22, step 32) |- ( 〈 x , y 〉 ∈ A → y ∈ ⋃ ⋃ A ) ;;
	step 34 : wff = exlimiv (step 33) |- ( ∃ x 〈 x , y 〉 ∈ A → y ∈ ⋃ ⋃ A ) ;;
	step 35 : wff = sylbi (step 20, step 34) |- ( y ∈ ran A → y ∈ ⋃ ⋃ A ) ;;
	step 36 : wff = ssriv (step 35) |- ran A ⊆ ⋃ ⋃ A ;;
	step 37 : wff = unssi (step 18, step 36) |- ( dom A ∪ ran A ) ⊆ ⋃ ⋃ A ;;
	qed prop 1 = step 37 ;;
}

/*The domain of a set is a set.  Corollary 6.8(2) of [TakeutiZaring] p. 26.
     (Contributed by NM, 7-Apr-1995.) */

theorem dmexg (A : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → dom A ∈ _V ) ;;
}

proof of dmexg {
	step 1 : wff = uniexg () |- ( A ∈ V → ⋃ A ∈ _V ) ;;
	step 2 : wff = uniexg () |- ( ⋃ A ∈ _V → ⋃ ⋃ A ∈ _V ) ;;
	step 3 : wff = ssun1 () |- dom A ⊆ ( dom A ∪ ran A ) ;;
	step 4 : wff = dmrnssfld () |- ( dom A ∪ ran A ) ⊆ ⋃ ⋃ A ;;
	step 5 : wff = sstri (step 3, step 4) |- dom A ⊆ ⋃ ⋃ A ;;
	step 6 : wff = ssexg () |- ( ( dom A ⊆ ⋃ ⋃ A ∧ ⋃ ⋃ A ∈ _V ) → dom A ∈ _V ) ;;
	step 7 : wff = mpan (step 5, step 6) |- ( ⋃ ⋃ A ∈ _V → dom A ∈ _V ) ;;
	step 8 : wff = 3syl (step 1, step 2, step 7) |- ( A ∈ V → dom A ∈ _V ) ;;
	qed prop 1 = step 8 ;;
}

/*The range of a set is a set.  Corollary 6.8(3) of [TakeutiZaring] p. 26.
     Similar to Lemma 3D of [Enderton] p. 41.  (Contributed by NM,
     31-Mar-1995.) */

theorem rnexg (A : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ran A ∈ _V ) ;;
}

proof of rnexg {
	step 1 : wff = uniexg () |- ( A ∈ V → ⋃ A ∈ _V ) ;;
	step 2 : wff = uniexg () |- ( ⋃ A ∈ _V → ⋃ ⋃ A ∈ _V ) ;;
	step 3 : wff = ssun2 () |- ran A ⊆ ( dom A ∪ ran A ) ;;
	step 4 : wff = dmrnssfld () |- ( dom A ∪ ran A ) ⊆ ⋃ ⋃ A ;;
	step 5 : wff = sstri (step 3, step 4) |- ran A ⊆ ⋃ ⋃ A ;;
	step 6 : wff = ssexg () |- ( ( ran A ⊆ ⋃ ⋃ A ∧ ⋃ ⋃ A ∈ _V ) → ran A ∈ _V ) ;;
	step 7 : wff = mpan (step 5, step 6) |- ( ⋃ ⋃ A ∈ _V → ran A ∈ _V ) ;;
	step 8 : wff = 3syl (step 1, step 2, step 7) |- ( A ∈ V → ran A ∈ _V ) ;;
	qed prop 1 = step 8 ;;
}

/*The domain of a set is a set.  Corollary 6.8(2) of [TakeutiZaring]
       p. 26.  (Contributed by NM, 7-Jul-2008.) */

theorem dmex (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- dom A ∈ _V ;;
}

proof of dmex {
	step 1 : wff = dmexg () |- ( A ∈ _V → dom A ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- dom A ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*The range of a set is a set.  Corollary 6.8(3) of [TakeutiZaring]
       p. 26.  Similar to Lemma 3D of [Enderton] p. 41.  (Contributed by NM,
       7-Jul-2008.) */

theorem rnex (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ran A ∈ _V ;;
}

proof of rnex {
	step 1 : wff = rnexg () |- ( A ∈ _V → ran A ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ran A ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*The identity function is a proper class.  This means, for example, that we
     cannot use it as a member of the class of continuous functions unless it
     is restricted to a set, as in ~ idcn .  (Contributed by NM,
     1-Jan-2007.) */

theorem iprc ()  {
	prop 1 : wff = |- ¬ _I ∈ _V ;;
}

proof of iprc {
	step 1 : wff = vprc () |- ¬ _V ∈ _V ;;
	step 2 : wff = dmi () |- dom _I = _V ;;
	step 3 : wff = eleq1i (step 2) |- ( dom _I ∈ _V ↔ _V ∈ _V ) ;;
	step 4 : wff = mtbir (step 1, step 3) |- ¬ dom _I ∈ _V ;;
	step 5 : wff = dmexg () |- ( _I ∈ _V → dom _I ∈ _V ) ;;
	step 6 : wff = mto (step 4, step 5) |- ¬ _I ∈ _V ;;
	qed prop 1 = step 6 ;;
}

/*Domain of a composition.  Theorem 21 of [Suppes] p. 63.  (Contributed by
       NM, 19-Mar-1998.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem dmcoss (A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- dom ( A ∘ B ) ⊆ dom B ;;
}

proof of dmcoss {
	var x : set, y : set, z : set;;
	step 1 : wff = nfe1 () |- F/ y ∃ y x B y ;;
	step 2 : wff = exsimpl () |- ( ∃ z ( x B z ∧ z A y ) → ∃ z x B z ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = opelco (step 3, step 4) |- ( 〈 x , y 〉 ∈ ( A ∘ B ) ↔ ∃ z ( x B z ∧ z A y ) ) ;;
	step 6 : wff = breq2 () |- ( y = z → ( x B y ↔ x B z ) ) ;;
	step 7 : wff = cbvexv (step 6) |- ( ∃ y x B y ↔ ∃ z x B z ) ;;
	step 8 : wff = 3imtr4i (step 2, step 5, step 7) |- ( 〈 x , y 〉 ∈ ( A ∘ B ) → ∃ y x B y ) ;;
	step 9 : wff = exlimi (step 1, step 8) |- ( ∃ y 〈 x , y 〉 ∈ ( A ∘ B ) → ∃ y x B y ) ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = eldm2 (step 10) |- ( x ∈ dom ( A ∘ B ) ↔ ∃ y 〈 x , y 〉 ∈ ( A ∘ B ) ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = eldm (step 12) |- ( x ∈ dom B ↔ ∃ y x B y ) ;;
	step 14 : wff = 3imtr4i (step 9, step 11, step 13) |- ( x ∈ dom ( A ∘ B ) → x ∈ dom B ) ;;
	step 15 : wff = ssriv (step 14) |- dom ( A ∘ B ) ⊆ dom B ;;
	qed prop 1 = step 15 ;;
}

/*Range of a composition.  (Contributed by NM, 19-Mar-1998.) */

theorem rncoss (A : class, B : class)  {
	prop 1 : wff = |- ran ( A ∘ B ) ⊆ ran A ;;
}

proof of rncoss {
	step 1 : wff = dmcoss () |- dom ( ⁻¹ B ∘ ⁻¹ A ) ⊆ dom ⁻¹ A ;;
	step 2 : wff = df-rn () |- ran ( A ∘ B ) = dom ⁻¹ ( A ∘ B ) ;;
	step 3 : wff = cnvco () |- ⁻¹ ( A ∘ B ) = ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 4 : wff = dmeqi (step 3) |- dom ⁻¹ ( A ∘ B ) = dom ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 5 : wff = eqtri (step 2, step 4) |- ran ( A ∘ B ) = dom ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 6 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 7 : wff = 3sstr4i (step 1, step 5, step 6) |- ran ( A ∘ B ) ⊆ ran A ;;
	qed prop 1 = step 7 ;;
}

/*Domain of a composition.  (Contributed by NM, 28-May-1998.)  (Proof
       shortened by Andrew Salmon, 27-Aug-2011.) */

theorem dmcosseq (A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- ( ran B ⊆ dom A → dom ( A ∘ B ) = dom B ) ;;
}

proof of dmcosseq {
	var x : set, y : set, z : set;;
	step 1 : wff = dmcoss () |- dom ( A ∘ B ) ⊆ dom B ;;
	step 2 : wff = a1i (step 1) |- ( ran B ⊆ dom A → dom ( A ∘ B ) ⊆ dom B ) ;;
	step 3 : wff = ssel () |- ( ran B ⊆ dom A → ( y ∈ ran B → y ∈ dom A ) ) ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = elrn (step 4) |- ( y ∈ ran B ↔ ∃ x x B y ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = eldm (step 6) |- ( y ∈ dom A ↔ ∃ z y A z ) ;;
	step 8 : wff = imbi12i (step 5, step 7) |- ( ( y ∈ ran B → y ∈ dom A ) ↔ ( ∃ x x B y → ∃ z y A z ) ) ;;
	step 9 : wff = 19.8a () |- ( x B y → ∃ x x B y ) ;;
	step 10 : wff = imim1i (step 9) |- ( ( ∃ x x B y → ∃ z y A z ) → ( x B y → ∃ z y A z ) ) ;;
	step 11 : wff = pm3.2 () |- ( x B y → ( y A z → ( x B y ∧ y A z ) ) ) ;;
	step 12 : wff = eximdv (step 11) |- ( x B y → ( ∃ z y A z → ∃ z ( x B y ∧ y A z ) ) ) ;;
	step 13 : wff = sylcom (step 10, step 12) |- ( ( ∃ x x B y → ∃ z y A z ) → ( x B y → ∃ z ( x B y ∧ y A z ) ) ) ;;
	step 14 : wff = sylbi (step 8, step 13) |- ( ( y ∈ ran B → y ∈ dom A ) → ( x B y → ∃ z ( x B y ∧ y A z ) ) ) ;;
	step 15 : wff = syl (step 3, step 14) |- ( ran B ⊆ dom A → ( x B y → ∃ z ( x B y ∧ y A z ) ) ) ;;
	step 16 : wff = eximdv (step 15) |- ( ran B ⊆ dom A → ( ∃ y x B y → ∃ y ∃ z ( x B y ∧ y A z ) ) ) ;;
	step 17 : wff = excom () |- ( ∃ z ∃ y ( x B y ∧ y A z ) ↔ ∃ y ∃ z ( x B y ∧ y A z ) ) ;;
	step 18 : wff = syl6ibr (step 16, step 17) |- ( ran B ⊆ dom A → ( ∃ y x B y → ∃ z ∃ y ( x B y ∧ y A z ) ) ) ;;
	step 19 : wff = vex () |- x ∈ _V ;;
	step 20 : wff = vex () |- z ∈ _V ;;
	step 21 : wff = opelco (step 19, step 20) |- ( 〈 x , z 〉 ∈ ( A ∘ B ) ↔ ∃ y ( x B y ∧ y A z ) ) ;;
	step 22 : wff = exbii (step 21) |- ( ∃ z 〈 x , z 〉 ∈ ( A ∘ B ) ↔ ∃ z ∃ y ( x B y ∧ y A z ) ) ;;
	step 23 : wff = syl6ibr (step 18, step 22) |- ( ran B ⊆ dom A → ( ∃ y x B y → ∃ z 〈 x , z 〉 ∈ ( A ∘ B ) ) ) ;;
	step 24 : wff = vex () |- x ∈ _V ;;
	step 25 : wff = eldm (step 24) |- ( x ∈ dom B ↔ ∃ y x B y ) ;;
	step 26 : wff = vex () |- x ∈ _V ;;
	step 27 : wff = eldm2 (step 26) |- ( x ∈ dom ( A ∘ B ) ↔ ∃ z 〈 x , z 〉 ∈ ( A ∘ B ) ) ;;
	step 28 : wff = 3imtr4g (step 23, step 25, step 27) |- ( ran B ⊆ dom A → ( x ∈ dom B → x ∈ dom ( A ∘ B ) ) ) ;;
	step 29 : wff = ssrdv (step 28) |- ( ran B ⊆ dom A → dom B ⊆ dom ( A ∘ B ) ) ;;
	step 30 : wff = eqssd (step 2, step 29) |- ( ran B ⊆ dom A → dom ( A ∘ B ) = dom B ) ;;
	qed prop 1 = step 30 ;;
}

/*Domain of a composition.  (Contributed by NM, 19-Mar-1998.) */

theorem dmcoeq (A : class, B : class) disjointed(A, B) {
	prop 1 : wff = |- ( dom A = ran B → dom ( A ∘ B ) = dom B ) ;;
}

proof of dmcoeq {
	step 1 : wff = eqimss2 () |- ( dom A = ran B → ran B ⊆ dom A ) ;;
	step 2 : wff = dmcosseq () |- ( ran B ⊆ dom A → dom ( A ∘ B ) = dom B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( dom A = ran B → dom ( A ∘ B ) = dom B ) ;;
	qed prop 1 = step 3 ;;
}

/*Range of a composition.  (Contributed by NM, 19-Mar-1998.) */

theorem rncoeq (A : class, B : class)  {
	prop 1 : wff = |- ( dom A = ran B → ran ( A ∘ B ) = ran A ) ;;
}

proof of rncoeq {
	step 1 : wff = dmcoeq () |- ( dom ⁻¹ B = ran ⁻¹ A → dom ( ⁻¹ B ∘ ⁻¹ A ) = dom ⁻¹ A ) ;;
	step 2 : wff = eqcom () |- ( dom A = ran B ↔ ran B = dom A ) ;;
	step 3 : wff = df-rn () |- ran B = dom ⁻¹ B ;;
	step 4 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 5 : wff = eqeq12i (step 3, step 4) |- ( ran B = dom A ↔ dom ⁻¹ B = ran ⁻¹ A ) ;;
	step 6 : wff = bitri (step 2, step 5) |- ( dom A = ran B ↔ dom ⁻¹ B = ran ⁻¹ A ) ;;
	step 7 : wff = df-rn () |- ran ( A ∘ B ) = dom ⁻¹ ( A ∘ B ) ;;
	step 8 : wff = cnvco () |- ⁻¹ ( A ∘ B ) = ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 9 : wff = dmeqi (step 8) |- dom ⁻¹ ( A ∘ B ) = dom ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 10 : wff = eqtri (step 7, step 9) |- ran ( A ∘ B ) = dom ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 11 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 12 : wff = eqeq12i (step 10, step 11) |- ( ran ( A ∘ B ) = ran A ↔ dom ( ⁻¹ B ∘ ⁻¹ A ) = dom ⁻¹ A ) ;;
	step 13 : wff = 3imtr4i (step 1, step 6, step 12) |- ( dom A = ran B → ran ( A ∘ B ) = ran A ) ;;
	qed prop 1 = step 13 ;;
}

/*Equality theorem for restrictions.  (Contributed by NM, 7-Aug-1994.) */

theorem reseq1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( A ↾ C ) = ( B ↾ C ) ) ;;
}

proof of reseq1 {
	step 1 : wff = ineq1 () |- ( A = B → ( A ∩ ( C × _V ) ) = ( B ∩ ( C × _V ) ) ) ;;
	step 2 : wff = df-res () |- ( A ↾ C ) = ( A ∩ ( C × _V ) ) ;;
	step 3 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 4 : wff = 3eqtr4g (step 1, step 2, step 3) |- ( A = B → ( A ↾ C ) = ( B ↾ C ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality theorem for restrictions.  (Contributed by NM, 8-Aug-1994.) */

theorem reseq2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( C ↾ A ) = ( C ↾ B ) ) ;;
}

proof of reseq2 {
	step 1 : wff = xpeq1 () |- ( A = B → ( A × _V ) = ( B × _V ) ) ;;
	step 2 : wff = ineq2d (step 1) |- ( A = B → ( C ∩ ( A × _V ) ) = ( C ∩ ( B × _V ) ) ) ;;
	step 3 : wff = df-res () |- ( C ↾ A ) = ( C ∩ ( A × _V ) ) ;;
	step 4 : wff = df-res () |- ( C ↾ B ) = ( C ∩ ( B × _V ) ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ( C ↾ A ) = ( C ↾ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality inference for restrictions.  (Contributed by NM,
       21-Oct-2014.) */

theorem reseq1i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A ↾ C ) = ( B ↾ C ) ;;
}

proof of reseq1i {
	step 1 : wff = reseq1 () |- ( A = B → ( A ↾ C ) = ( B ↾ C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ↾ C ) = ( B ↾ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for restrictions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem reseq2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C ↾ A ) = ( C ↾ B ) ;;
}

proof of reseq2i {
	step 1 : wff = reseq2 () |- ( A = B → ( C ↾ A ) = ( C ↾ B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C ↾ A ) = ( C ↾ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for restrictions.  (Contributed by NM,
       21-Oct-2014.) */

theorem reseq12i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A ↾ C ) = ( B ↾ D ) ;;
}

proof of reseq12i {
	step 1 : wff = reseq1i (hyp 1) |- ( A ↾ C ) = ( B ↾ C ) ;;
	step 2 : wff = reseq2i (hyp 2) |- ( B ↾ C ) = ( B ↾ D ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( A ↾ C ) = ( B ↾ D ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restrictions.  (Contributed by NM,
       21-Oct-2014.) */

theorem reseq1d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ↾ C ) = ( B ↾ C ) ) ;;
}

proof of reseq1d {
	step 1 : wff = reseq1 () |- ( A = B → ( A ↾ C ) = ( B ↾ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A ↾ C ) = ( B ↾ C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for restrictions.  (Contributed by Paul Chapman,
       22-Jun-2011.) */

theorem reseq2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C ↾ A ) = ( C ↾ B ) ) ;;
}

proof of reseq2d {
	step 1 : wff = reseq2 () |- ( A = B → ( C ↾ A ) = ( C ↾ B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C ↾ A ) = ( C ↾ B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for restrictions.  (Contributed by NM,
       21-Oct-2014.) */

theorem reseq12d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ↾ C ) = ( B ↾ D ) ) ;;
}

proof of reseq12d {
	step 1 : wff = reseq1d (hyp 1) |- ( ph → ( A ↾ C ) = ( B ↾ C ) ) ;;
	step 2 : wff = reseq2d (hyp 2) |- ( ph → ( B ↾ C ) = ( B ↾ D ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → ( A ↾ C ) = ( B ↾ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for restriction.  (Contributed by NM,
       15-Sep-2003.)  (Revised by David Abernethy, 19-Jun-2012.) */

theorem nfres (x : set, A : class, B : class) disjointed(B, x) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x ( A ↾ B ) ;;
}

proof of nfres {
	step 1 : wff = df-res () |- ( A ↾ B ) = ( A ∩ ( B × _V ) ) ;;
	step 2 : wff = nfcv () |- F/_ x _V ;;
	step 3 : wff = nfxp (hyp 2, step 2) |- F/_ x ( B × _V ) ;;
	step 4 : wff = nfin (hyp 1, step 3) |- F/_ x ( A ∩ ( B × _V ) ) ;;
	step 5 : wff = nfcxfr (step 1, step 4) |- F/_ x ( A ↾ B ) ;;
	qed prop 1 = step 5 ;;
}

/*Distribute proper substitution through the restriction of a class.
     ~ csbresg is derived from the virtual deduction proof ~ csbresgVD .
     (Contributed by Alan Sare, 10-Nov-2012.) */

theorem csbresg (x : set, A : class, B : class, C : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → [_ A / x ]_ ( B ↾ C ) = ( [_ A / x ]_ B ↾ [_ A / x ]_ C ) ) ;;
}

proof of csbresg {
	step 1 : wff = csbing () |- ( A ∈ V → [_ A / x ]_ ( B ∩ ( C × _V ) ) = ( [_ A / x ]_ B ∩ [_ A / x ]_ ( C × _V ) ) ) ;;
	step 2 : wff = csbxpg () |- ( A ∈ V → [_ A / x ]_ ( C × _V ) = ( [_ A / x ]_ C × [_ A / x ]_ _V ) ) ;;
	step 3 : wff = csbconstg () |- ( A ∈ V → [_ A / x ]_ _V = _V ) ;;
	step 4 : wff = xpeq2d (step 3) |- ( A ∈ V → ( [_ A / x ]_ C × [_ A / x ]_ _V ) = ( [_ A / x ]_ C × _V ) ) ;;
	step 5 : wff = eqtrd (step 2, step 4) |- ( A ∈ V → [_ A / x ]_ ( C × _V ) = ( [_ A / x ]_ C × _V ) ) ;;
	step 6 : wff = ineq2d (step 5) |- ( A ∈ V → ( [_ A / x ]_ B ∩ [_ A / x ]_ ( C × _V ) ) = ( [_ A / x ]_ B ∩ ( [_ A / x ]_ C × _V ) ) ) ;;
	step 7 : wff = eqtrd (step 1, step 6) |- ( A ∈ V → [_ A / x ]_ ( B ∩ ( C × _V ) ) = ( [_ A / x ]_ B ∩ ( [_ A / x ]_ C × _V ) ) ) ;;
	step 8 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 9 : wff = csbeq2i (step 8) |- [_ A / x ]_ ( B ↾ C ) = [_ A / x ]_ ( B ∩ ( C × _V ) ) ;;
	step 10 : wff = df-res () |- ( [_ A / x ]_ B ↾ [_ A / x ]_ C ) = ( [_ A / x ]_ B ∩ ( [_ A / x ]_ C × _V ) ) ;;
	step 11 : wff = 3eqtr4g (step 7, step 9, step 10) |- ( A ∈ V → [_ A / x ]_ ( B ↾ C ) = ( [_ A / x ]_ B ↾ [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 11 ;;
}

/*A restriction to the empty set is empty.  (Contributed by NM,
     12-Nov-1994.) */

theorem res0 (A : class)  {
	prop 1 : wff = |- ( A ↾ ∅ ) = ∅ ;;
}

proof of res0 {
	step 1 : wff = df-res () |- ( A ↾ ∅ ) = ( A ∩ ( ∅ × _V ) ) ;;
	step 2 : wff = xp0r () |- ( ∅ × _V ) = ∅ ;;
	step 3 : wff = ineq2i (step 2) |- ( A ∩ ( ∅ × _V ) ) = ( A ∩ ∅ ) ;;
	step 4 : wff = in0 () |- ( A ∩ ∅ ) = ∅ ;;
	step 5 : wff = 3eqtri (step 1, step 3, step 4) |- ( A ↾ ∅ ) = ∅ ;;
	qed prop 1 = step 5 ;;
}

/*Ordered pair membership in a restriction.  Exercise 13 of
       [TakeutiZaring] p. 25.  (Contributed by NM, 13-Nov-1995.) */

theorem opelres (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
}

proof of opelres {
	step 1 : wff = df-res () |- ( C ↾ D ) = ( C ∩ ( D × _V ) ) ;;
	step 2 : wff = eleq2i (step 1) |- ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ 〈 A , B 〉 ∈ ( C ∩ ( D × _V ) ) ) ;;
	step 3 : wff = elin () |- ( 〈 A , B 〉 ∈ ( C ∩ ( D × _V ) ) ↔ ( 〈 A , B 〉 ∈ C ∧ 〈 A , B 〉 ∈ ( D × _V ) ) ) ;;
	step 4 : wff = opelxp () |- ( 〈 A , B 〉 ∈ ( D × _V ) ↔ ( A ∈ D ∧ B ∈ _V ) ) ;;
	step 5 : wff = mpbiran2 (hyp 1, step 4) |- ( 〈 A , B 〉 ∈ ( D × _V ) ↔ A ∈ D ) ;;
	step 6 : wff = anbi2i (step 5) |- ( ( 〈 A , B 〉 ∈ C ∧ 〈 A , B 〉 ∈ ( D × _V ) ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
	step 7 : wff = 3bitri (step 2, step 3, step 6) |- ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Binary relation on a restriction.  (Contributed by NM, 12-Dec-2006.) */

theorem brres (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ( C ↾ D ) B ↔ ( A C B ∧ A ∈ D ) ) ;;
}

proof of brres {
	step 1 : wff = opelres (hyp 1) |- ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
	step 2 : wff = df-br () |- ( A ( C ↾ D ) B ↔ 〈 A , B 〉 ∈ ( C ↾ D ) ) ;;
	step 3 : wff = df-br () |- ( A C B ↔ 〈 A , B 〉 ∈ C ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( A C B ∧ A ∈ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
	step 5 : wff = 3bitr4i (step 1, step 2, step 4) |- ( A ( C ↾ D ) B ↔ ( A C B ∧ A ∈ D ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Ordered pair membership in a restriction.  Exercise 13 of
       [TakeutiZaring] p. 25.  (Contributed by NM, 14-Oct-2005.) */

theorem opelresg (A : class, B : class, C : class, D : class, V : class) disjointed(y A, y B, y C, y D) {
	prop 1 : wff = |- ( B ∈ V → ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ) ;;
}

proof of opelresg {
	var y : set;;
	step 1 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( y = B → ( 〈 A , y 〉 ∈ ( C ↾ D ) ↔ 〈 A , B 〉 ∈ ( C ↾ D ) ) ) ;;
	step 3 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 4 : wff = eleq1d (step 3) |- ( y = B → ( 〈 A , y 〉 ∈ C ↔ 〈 A , B 〉 ∈ C ) ) ;;
	step 5 : wff = anbi1d (step 4) |- ( y = B → ( ( 〈 A , y 〉 ∈ C ∧ A ∈ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = opelres (step 6) |- ( 〈 A , y 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , y 〉 ∈ C ∧ A ∈ D ) ) ;;
	step 8 : wff = vtoclbg (step 2, step 5, step 7) |- ( B ∈ V → ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Binary relation on a restriction.  (Contributed by Mario Carneiro,
       4-Nov-2015.) */

theorem brresg (A : class, B : class, C : class, D : class, V : class) disjointed(A, B, C, D) {
	prop 1 : wff = |- ( B ∈ V → ( A ( C ↾ D ) B ↔ ( A C B ∧ A ∈ D ) ) ) ;;
}

proof of brresg {
	step 1 : wff = opelresg () |- ( B ∈ V → ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ) ;;
	step 2 : wff = df-br () |- ( A ( C ↾ D ) B ↔ 〈 A , B 〉 ∈ ( C ↾ D ) ) ;;
	step 3 : wff = df-br () |- ( A C B ↔ 〈 A , B 〉 ∈ C ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( A C B ∧ A ∈ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
	step 5 : wff = 3bitr4g (step 1, step 2, step 4) |- ( B ∈ V → ( A ( C ↾ D ) B ↔ ( A C B ∧ A ∈ D ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Ordered pair membership in a restriction when the first member belongs
       to the restricting class.  (Contributed by NM, 30-Apr-2004.)  (Proof
       shortened by Andrew Salmon, 27-Aug-2011.) */

theorem opres (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ D → ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ 〈 A , B 〉 ∈ C ) ) ;;
}

proof of opres {
	step 1 : wff = opelres (hyp 1) |- ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ ( 〈 A , B 〉 ∈ C ∧ A ∈ D ) ) ;;
	step 2 : wff = rbaib (step 1) |- ( A ∈ D → ( 〈 A , B 〉 ∈ ( C ↾ D ) ↔ 〈 A , B 〉 ∈ C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*A restricted identity relation is equivalent to equality in its domain.
       (Contributed by NM, 30-Apr-2004.) */

theorem resieq (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( ( B ∈ A ∧ C ∈ A ) → ( B ( _I ↾ A ) C ↔ B = C ) ) ;;
}

proof of resieq {
	var x : set;;
	step 1 : wff = breq2 () |- ( x = C → ( B ( _I ↾ A ) x ↔ B ( _I ↾ A ) C ) ) ;;
	step 2 : wff = eqeq2 () |- ( x = C → ( B = x ↔ B = C ) ) ;;
	step 3 : wff = bibi12d (step 1, step 2) |- ( x = C → ( ( B ( _I ↾ A ) x ↔ B = x ) ↔ ( B ( _I ↾ A ) C ↔ B = C ) ) ) ;;
	step 4 : wff = imbi2d (step 3) |- ( x = C → ( ( B ∈ A → ( B ( _I ↾ A ) x ↔ B = x ) ) ↔ ( B ∈ A → ( B ( _I ↾ A ) C ↔ B = C ) ) ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = opres (step 5) |- ( B ∈ A → ( 〈 B , x 〉 ∈ ( _I ↾ A ) ↔ 〈 B , x 〉 ∈ _I ) ) ;;
	step 7 : wff = df-br () |- ( B ( _I ↾ A ) x ↔ 〈 B , x 〉 ∈ ( _I ↾ A ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = ideq (step 8) |- ( B _I x ↔ B = x ) ;;
	step 10 : wff = df-br () |- ( B _I x ↔ 〈 B , x 〉 ∈ _I ) ;;
	step 11 : wff = bitr3i (step 9, step 10) |- ( B = x ↔ 〈 B , x 〉 ∈ _I ) ;;
	step 12 : wff = 3bitr4g (step 6, step 7, step 11) |- ( B ∈ A → ( B ( _I ↾ A ) x ↔ B = x ) ) ;;
	step 13 : wff = vtoclg (step 4, step 12) |- ( C ∈ A → ( B ∈ A → ( B ( _I ↾ A ) C ↔ B = C ) ) ) ;;
	step 14 : wff = impcom (step 13) |- ( ( B ∈ A ∧ C ∈ A ) → ( B ( _I ↾ A ) C ↔ B = C ) ) ;;
	qed prop 1 = step 14 ;;
}

/*` <. A , A >. ` belongs to a restriction of the identity class iff ` A `
     belongs to the restricting class.  (Contributed by FL, 27-Oct-2008.)
     (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem opelresiOLD (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ B ↔ 〈 A , A 〉 ∈ ( _I ↾ B ) ) ) ;;
}

proof of opelresiOLD {
	step 1 : wff = ididg () |- ( A ∈ V → A _I A ) ;;
	step 2 : wff = df-br () |- ( A _I A ↔ 〈 A , A 〉 ∈ _I ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( A ∈ V → 〈 A , A 〉 ∈ _I ) ;;
	step 4 : wff = biantrurd (step 3) |- ( A ∈ V → ( A ∈ B ↔ ( 〈 A , A 〉 ∈ _I ∧ A ∈ B ) ) ) ;;
	step 5 : wff = opelresg () |- ( A ∈ V → ( 〈 A , A 〉 ∈ ( _I ↾ B ) ↔ ( 〈 A , A 〉 ∈ _I ∧ A ∈ B ) ) ) ;;
	step 6 : wff = bitr4d (step 4, step 5) |- ( A ∈ V → ( A ∈ B ↔ 〈 A , A 〉 ∈ ( _I ↾ B ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/*` <. A , A >. ` belongs to a restriction of the identity class iff ` A `
     belongs to the restricting class.  (Contributed by FL, 27-Oct-2008.)
     (Revised by NM, 30-Mar-2016.) */

theorem opelresi (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ( 〈 A , A 〉 ∈ ( _I ↾ B ) ↔ A ∈ B ) ) ;;
}

proof of opelresi {
	step 1 : wff = opelresg () |- ( A ∈ V → ( 〈 A , A 〉 ∈ ( _I ↾ B ) ↔ ( 〈 A , A 〉 ∈ _I ∧ A ∈ B ) ) ) ;;
	step 2 : wff = ididg () |- ( A ∈ V → A _I A ) ;;
	step 3 : wff = df-br () |- ( A _I A ↔ 〈 A , A 〉 ∈ _I ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( A ∈ V → 〈 A , A 〉 ∈ _I ) ;;
	step 5 : wff = biantrurd (step 4) |- ( A ∈ V → ( A ∈ B ↔ ( 〈 A , A 〉 ∈ _I ∧ A ∈ B ) ) ) ;;
	step 6 : wff = bitr4d (step 1, step 5) |- ( A ∈ V → ( 〈 A , A 〉 ∈ ( _I ↾ B ) ↔ A ∈ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The restriction of a restriction.  (Contributed by NM, 27-Mar-2008.) */

theorem resres (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ↾ B ) ↾ C ) = ( A ↾ ( B ∩ C ) ) ;;
}

proof of resres {
	step 1 : wff = df-res () |- ( ( A ↾ B ) ↾ C ) = ( ( A ↾ B ) ∩ ( C × _V ) ) ;;
	step 2 : wff = df-res () |- ( A ↾ B ) = ( A ∩ ( B × _V ) ) ;;
	step 3 : wff = ineq1i (step 2) |- ( ( A ↾ B ) ∩ ( C × _V ) ) = ( ( A ∩ ( B × _V ) ) ∩ ( C × _V ) ) ;;
	step 4 : wff = xpindir () |- ( ( B ∩ C ) × _V ) = ( ( B × _V ) ∩ ( C × _V ) ) ;;
	step 5 : wff = ineq2i (step 4) |- ( A ∩ ( ( B ∩ C ) × _V ) ) = ( A ∩ ( ( B × _V ) ∩ ( C × _V ) ) ) ;;
	step 6 : wff = df-res () |- ( A ↾ ( B ∩ C ) ) = ( A ∩ ( ( B ∩ C ) × _V ) ) ;;
	step 7 : wff = inass () |- ( ( A ∩ ( B × _V ) ) ∩ ( C × _V ) ) = ( A ∩ ( ( B × _V ) ∩ ( C × _V ) ) ) ;;
	step 8 : wff = 3eqtr4ri (step 5, step 6, step 7) |- ( ( A ∩ ( B × _V ) ) ∩ ( C × _V ) ) = ( A ↾ ( B ∩ C ) ) ;;
	step 9 : wff = 3eqtri (step 1, step 3, step 8) |- ( ( A ↾ B ) ↾ C ) = ( A ↾ ( B ∩ C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Distributive law for restriction over union.  Theorem 31 of [Suppes]
     p. 65.  (Contributed by NM, 30-Sep-2002.) */

theorem resundi (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ↾ ( B ∪ C ) ) = ( ( A ↾ B ) ∪ ( A ↾ C ) ) ;;
}

proof of resundi {
	step 1 : wff = xpundir () |- ( ( B ∪ C ) × _V ) = ( ( B × _V ) ∪ ( C × _V ) ) ;;
	step 2 : wff = ineq2i (step 1) |- ( A ∩ ( ( B ∪ C ) × _V ) ) = ( A ∩ ( ( B × _V ) ∪ ( C × _V ) ) ) ;;
	step 3 : wff = indi () |- ( A ∩ ( ( B × _V ) ∪ ( C × _V ) ) ) = ( ( A ∩ ( B × _V ) ) ∪ ( A ∩ ( C × _V ) ) ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- ( A ∩ ( ( B ∪ C ) × _V ) ) = ( ( A ∩ ( B × _V ) ) ∪ ( A ∩ ( C × _V ) ) ) ;;
	step 5 : wff = df-res () |- ( A ↾ ( B ∪ C ) ) = ( A ∩ ( ( B ∪ C ) × _V ) ) ;;
	step 6 : wff = df-res () |- ( A ↾ B ) = ( A ∩ ( B × _V ) ) ;;
	step 7 : wff = df-res () |- ( A ↾ C ) = ( A ∩ ( C × _V ) ) ;;
	step 8 : wff = uneq12i (step 6, step 7) |- ( ( A ↾ B ) ∪ ( A ↾ C ) ) = ( ( A ∩ ( B × _V ) ) ∪ ( A ∩ ( C × _V ) ) ) ;;
	step 9 : wff = 3eqtr4i (step 4, step 5, step 8) |- ( A ↾ ( B ∪ C ) ) = ( ( A ↾ B ) ∪ ( A ↾ C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Distributive law for restriction over union.  (Contributed by NM,
     23-Sep-2004.) */

theorem resundir (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∪ B ) ↾ C ) = ( ( A ↾ C ) ∪ ( B ↾ C ) ) ;;
}

proof of resundir {
	step 1 : wff = indir () |- ( ( A ∪ B ) ∩ ( C × _V ) ) = ( ( A ∩ ( C × _V ) ) ∪ ( B ∩ ( C × _V ) ) ) ;;
	step 2 : wff = df-res () |- ( ( A ∪ B ) ↾ C ) = ( ( A ∪ B ) ∩ ( C × _V ) ) ;;
	step 3 : wff = df-res () |- ( A ↾ C ) = ( A ∩ ( C × _V ) ) ;;
	step 4 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 5 : wff = uneq12i (step 3, step 4) |- ( ( A ↾ C ) ∪ ( B ↾ C ) ) = ( ( A ∩ ( C × _V ) ) ∪ ( B ∩ ( C × _V ) ) ) ;;
	step 6 : wff = 3eqtr4i (step 1, step 2, step 5) |- ( ( A ∪ B ) ↾ C ) = ( ( A ↾ C ) ∪ ( B ↾ C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Class restriction distributes over intersection.  (Contributed by FL,
     6-Oct-2008.) */

theorem resindi (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ↾ ( B ∩ C ) ) = ( ( A ↾ B ) ∩ ( A ↾ C ) ) ;;
}

proof of resindi {
	step 1 : wff = xpindir () |- ( ( B ∩ C ) × _V ) = ( ( B × _V ) ∩ ( C × _V ) ) ;;
	step 2 : wff = ineq2i (step 1) |- ( A ∩ ( ( B ∩ C ) × _V ) ) = ( A ∩ ( ( B × _V ) ∩ ( C × _V ) ) ) ;;
	step 3 : wff = inindi () |- ( A ∩ ( ( B × _V ) ∩ ( C × _V ) ) ) = ( ( A ∩ ( B × _V ) ) ∩ ( A ∩ ( C × _V ) ) ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- ( A ∩ ( ( B ∩ C ) × _V ) ) = ( ( A ∩ ( B × _V ) ) ∩ ( A ∩ ( C × _V ) ) ) ;;
	step 5 : wff = df-res () |- ( A ↾ ( B ∩ C ) ) = ( A ∩ ( ( B ∩ C ) × _V ) ) ;;
	step 6 : wff = df-res () |- ( A ↾ B ) = ( A ∩ ( B × _V ) ) ;;
	step 7 : wff = df-res () |- ( A ↾ C ) = ( A ∩ ( C × _V ) ) ;;
	step 8 : wff = ineq12i (step 6, step 7) |- ( ( A ↾ B ) ∩ ( A ↾ C ) ) = ( ( A ∩ ( B × _V ) ) ∩ ( A ∩ ( C × _V ) ) ) ;;
	step 9 : wff = 3eqtr4i (step 4, step 5, step 8) |- ( A ↾ ( B ∩ C ) ) = ( ( A ↾ B ) ∩ ( A ↾ C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Class restriction distributes over intersection.  (Contributed by NM,
     18-Dec-2008.) */

theorem resindir (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∩ B ) ↾ C ) = ( ( A ↾ C ) ∩ ( B ↾ C ) ) ;;
}

proof of resindir {
	step 1 : wff = inindir () |- ( ( A ∩ B ) ∩ ( C × _V ) ) = ( ( A ∩ ( C × _V ) ) ∩ ( B ∩ ( C × _V ) ) ) ;;
	step 2 : wff = df-res () |- ( ( A ∩ B ) ↾ C ) = ( ( A ∩ B ) ∩ ( C × _V ) ) ;;
	step 3 : wff = df-res () |- ( A ↾ C ) = ( A ∩ ( C × _V ) ) ;;
	step 4 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 5 : wff = ineq12i (step 3, step 4) |- ( ( A ↾ C ) ∩ ( B ↾ C ) ) = ( ( A ∩ ( C × _V ) ) ∩ ( B ∩ ( C × _V ) ) ) ;;
	step 6 : wff = 3eqtr4i (step 1, step 2, step 5) |- ( ( A ∩ B ) ↾ C ) = ( ( A ↾ C ) ∩ ( B ↾ C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Move intersection into class restriction.  (Contributed by NM,
     18-Dec-2008.) */

theorem inres (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∩ ( B ↾ C ) ) = ( ( A ∩ B ) ↾ C ) ;;
}

proof of inres {
	step 1 : wff = inass () |- ( ( A ∩ B ) ∩ ( C × _V ) ) = ( A ∩ ( B ∩ ( C × _V ) ) ) ;;
	step 2 : wff = df-res () |- ( ( A ∩ B ) ↾ C ) = ( ( A ∩ B ) ∩ ( C × _V ) ) ;;
	step 3 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 4 : wff = ineq2i (step 3) |- ( A ∩ ( B ↾ C ) ) = ( A ∩ ( B ∩ ( C × _V ) ) ) ;;
	step 5 : wff = 3eqtr4ri (step 1, step 2, step 4) |- ( A ∩ ( B ↾ C ) ) = ( ( A ∩ B ) ↾ C ) ;;
	qed prop 1 = step 5 ;;
}

/*Distribution of restriction over indexed union.  (Contributed by Mario
       Carneiro, 29-May-2015.) */

theorem resiun1 (x : set, A : class, B : class, C : class) disjointed(x C) {
	prop 1 : wff = |- ( ⋃_ x ∈ A B ↾ C ) = ⋃_ x ∈ A ( B ↾ C ) ;;
}

proof of resiun1 {
	step 1 : wff = iunin2 () |- ⋃_ x ∈ A ( ( C × _V ) ∩ B ) = ( ( C × _V ) ∩ ⋃_ x ∈ A B ) ;;
	step 2 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 3 : wff = incom () |- ( B ∩ ( C × _V ) ) = ( ( C × _V ) ∩ B ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- ( B ↾ C ) = ( ( C × _V ) ∩ B ) ;;
	step 5 : wff = a1i (step 4) |- ( x ∈ A → ( B ↾ C ) = ( ( C × _V ) ∩ B ) ) ;;
	step 6 : wff = iuneq2i (step 5) |- ⋃_ x ∈ A ( B ↾ C ) = ⋃_ x ∈ A ( ( C × _V ) ∩ B ) ;;
	step 7 : wff = df-res () |- ( ⋃_ x ∈ A B ↾ C ) = ( ⋃_ x ∈ A B ∩ ( C × _V ) ) ;;
	step 8 : wff = incom () |- ( ⋃_ x ∈ A B ∩ ( C × _V ) ) = ( ( C × _V ) ∩ ⋃_ x ∈ A B ) ;;
	step 9 : wff = eqtri (step 7, step 8) |- ( ⋃_ x ∈ A B ↾ C ) = ( ( C × _V ) ∩ ⋃_ x ∈ A B ) ;;
	step 10 : wff = 3eqtr4ri (step 1, step 6, step 9) |- ( ⋃_ x ∈ A B ↾ C ) = ⋃_ x ∈ A ( B ↾ C ) ;;
	qed prop 1 = step 10 ;;
}

/*Distribution of restriction over indexed union.  (Contributed by Mario
       Carneiro, 29-May-2015.) */

theorem resiun2 (x : set, A : class, B : class, C : class) disjointed(x C) {
	prop 1 : wff = |- ( C ↾ ⋃_ x ∈ A B ) = ⋃_ x ∈ A ( C ↾ B ) ;;
}

proof of resiun2 {
	step 1 : wff = df-res () |- ( C ↾ ⋃_ x ∈ A B ) = ( C ∩ ( ⋃_ x ∈ A B × _V ) ) ;;
	step 2 : wff = df-res () |- ( C ↾ B ) = ( C ∩ ( B × _V ) ) ;;
	step 3 : wff = a1i (step 2) |- ( x ∈ A → ( C ↾ B ) = ( C ∩ ( B × _V ) ) ) ;;
	step 4 : wff = iuneq2i (step 3) |- ⋃_ x ∈ A ( C ↾ B ) = ⋃_ x ∈ A ( C ∩ ( B × _V ) ) ;;
	step 5 : wff = xpiundir () |- ( ⋃_ x ∈ A B × _V ) = ⋃_ x ∈ A ( B × _V ) ;;
	step 6 : wff = ineq2i (step 5) |- ( C ∩ ( ⋃_ x ∈ A B × _V ) ) = ( C ∩ ⋃_ x ∈ A ( B × _V ) ) ;;
	step 7 : wff = iunin2 () |- ⋃_ x ∈ A ( C ∩ ( B × _V ) ) = ( C ∩ ⋃_ x ∈ A ( B × _V ) ) ;;
	step 8 : wff = eqtr4i (step 6, step 7) |- ( C ∩ ( ⋃_ x ∈ A B × _V ) ) = ⋃_ x ∈ A ( C ∩ ( B × _V ) ) ;;
	step 9 : wff = eqtr4i (step 4, step 8) |- ⋃_ x ∈ A ( C ↾ B ) = ( C ∩ ( ⋃_ x ∈ A B × _V ) ) ;;
	step 10 : wff = eqtr4i (step 1, step 9) |- ( C ↾ ⋃_ x ∈ A B ) = ⋃_ x ∈ A ( C ↾ B ) ;;
	qed prop 1 = step 10 ;;
}

/*The domain of a restriction.  Exercise 14 of [TakeutiZaring] p. 25.
       (Contributed by NM, 1-Aug-1994.) */

theorem dmres (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- dom ( A ↾ B ) = ( B ∩ dom A ) ;;
}

proof of dmres {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = eldm2 (step 1) |- ( x ∈ dom ( A ↾ B ) ↔ ∃ y 〈 x , y 〉 ∈ ( A ↾ B ) ) ;;
	step 3 : wff = 19.41v () |- ( ∃ y ( 〈 x , y 〉 ∈ A ∧ x ∈ B ) ↔ ( ∃ y 〈 x , y 〉 ∈ A ∧ x ∈ B ) ) ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = opelres (step 4) |- ( 〈 x , y 〉 ∈ ( A ↾ B ) ↔ ( 〈 x , y 〉 ∈ A ∧ x ∈ B ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y 〈 x , y 〉 ∈ ( A ↾ B ) ↔ ∃ y ( 〈 x , y 〉 ∈ A ∧ x ∈ B ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = eldm2 (step 7) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 9 : wff = anbi1i (step 8) |- ( ( x ∈ dom A ∧ x ∈ B ) ↔ ( ∃ y 〈 x , y 〉 ∈ A ∧ x ∈ B ) ) ;;
	step 10 : wff = 3bitr4i (step 3, step 6, step 9) |- ( ∃ y 〈 x , y 〉 ∈ ( A ↾ B ) ↔ ( x ∈ dom A ∧ x ∈ B ) ) ;;
	step 11 : wff = bitr2i (step 2, step 10) |- ( ( x ∈ dom A ∧ x ∈ B ) ↔ x ∈ dom ( A ↾ B ) ) ;;
	step 12 : wff = ineqri (step 11) |- ( dom A ∩ B ) = dom ( A ↾ B ) ;;
	step 13 : wff = incom () |- ( dom A ∩ B ) = ( B ∩ dom A ) ;;
	step 14 : wff = eqtr3i (step 12, step 13) |- dom ( A ↾ B ) = ( B ∩ dom A ) ;;
	qed prop 1 = step 14 ;;
}

/*A domain restricted to a subclass equals the subclass.  (Contributed by
     NM, 2-Mar-1997.) */

theorem ssdmres (A : class, B : class)  {
	prop 1 : wff = |- ( A ⊆ dom B ↔ dom ( B ↾ A ) = A ) ;;
}

proof of ssdmres {
	step 1 : wff = df-ss () |- ( A ⊆ dom B ↔ ( A ∩ dom B ) = A ) ;;
	step 2 : wff = dmres () |- dom ( B ↾ A ) = ( A ∩ dom B ) ;;
	step 3 : wff = eqeq1i (step 2) |- ( dom ( B ↾ A ) = A ↔ ( A ∩ dom B ) = A ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( A ⊆ dom B ↔ dom ( B ↾ A ) = A ) ;;
	qed prop 1 = step 4 ;;
}

/*The domain of a restriction to a set exists.  (Contributed by NM,
     7-Apr-1995.) */

theorem dmresexg (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( B ∈ V → dom ( A ↾ B ) ∈ _V ) ;;
}

proof of dmresexg {
	step 1 : wff = dmres () |- dom ( A ↾ B ) = ( B ∩ dom A ) ;;
	step 2 : wff = inex1g () |- ( B ∈ V → ( B ∩ dom A ) ∈ _V ) ;;
	step 3 : wff = syl5eqel (step 1, step 2) |- ( B ∈ V → dom ( A ↾ B ) ∈ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*A class includes its restriction.  Exercise 15 of [TakeutiZaring] p. 25.
     (Contributed by NM, 2-Aug-1994.) */

theorem resss (A : class, B : class)  {
	prop 1 : wff = |- ( A ↾ B ) ⊆ A ;;
}

proof of resss {
	step 1 : wff = df-res () |- ( A ↾ B ) = ( A ∩ ( B × _V ) ) ;;
	step 2 : wff = inss1 () |- ( A ∩ ( B × _V ) ) ⊆ A ;;
	step 3 : wff = eqsstri (step 1, step 2) |- ( A ↾ B ) ⊆ A ;;
	qed prop 1 = step 3 ;;
}

/*Commutative law for restriction.  (Contributed by NM, 27-Mar-1998.) */

theorem rescom (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ↾ B ) ↾ C ) = ( ( A ↾ C ) ↾ B ) ;;
}

proof of rescom {
	step 1 : wff = incom () |- ( B ∩ C ) = ( C ∩ B ) ;;
	step 2 : wff = reseq2i (step 1) |- ( A ↾ ( B ∩ C ) ) = ( A ↾ ( C ∩ B ) ) ;;
	step 3 : wff = resres () |- ( ( A ↾ B ) ↾ C ) = ( A ↾ ( B ∩ C ) ) ;;
	step 4 : wff = resres () |- ( ( A ↾ C ) ↾ B ) = ( A ↾ ( C ∩ B ) ) ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- ( ( A ↾ B ) ↾ C ) = ( ( A ↾ C ) ↾ B ) ;;
	qed prop 1 = step 5 ;;
}

/*Subclass theorem for restriction.  (Contributed by NM, 16-Aug-1994.) */

theorem ssres (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( A ↾ C ) ⊆ ( B ↾ C ) ) ;;
}

proof of ssres {
	step 1 : wff = ssrin () |- ( A ⊆ B → ( A ∩ ( C × _V ) ) ⊆ ( B ∩ ( C × _V ) ) ) ;;
	step 2 : wff = df-res () |- ( A ↾ C ) = ( A ∩ ( C × _V ) ) ;;
	step 3 : wff = df-res () |- ( B ↾ C ) = ( B ∩ ( C × _V ) ) ;;
	step 4 : wff = 3sstr4g (step 1, step 2, step 3) |- ( A ⊆ B → ( A ↾ C ) ⊆ ( B ↾ C ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Subclass theorem for restriction.  (Contributed by NM, 22-Mar-1998.)
     (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem ssres2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( C ↾ A ) ⊆ ( C ↾ B ) ) ;;
}

proof of ssres2 {
	step 1 : wff = xpss1 () |- ( A ⊆ B → ( A × _V ) ⊆ ( B × _V ) ) ;;
	step 2 : wff = sslin () |- ( ( A × _V ) ⊆ ( B × _V ) → ( C ∩ ( A × _V ) ) ⊆ ( C ∩ ( B × _V ) ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ⊆ B → ( C ∩ ( A × _V ) ) ⊆ ( C ∩ ( B × _V ) ) ) ;;
	step 4 : wff = df-res () |- ( C ↾ A ) = ( C ∩ ( A × _V ) ) ;;
	step 5 : wff = df-res () |- ( C ↾ B ) = ( C ∩ ( B × _V ) ) ;;
	step 6 : wff = 3sstr4g (step 3, step 4, step 5) |- ( A ⊆ B → ( C ↾ A ) ⊆ ( C ↾ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*A restriction is a relation.  Exercise 12 of [TakeutiZaring] p. 25.
     (Contributed by NM, 2-Aug-1994.)  (Proof shortened by Andrew Salmon,
     27-Aug-2011.) */

theorem relres (A : class, B : class)  {
	prop 1 : wff = |- Rel ( A ↾ B ) ;;
}

proof of relres {
	step 1 : wff = df-res () |- ( A ↾ B ) = ( A ∩ ( B × _V ) ) ;;
	step 2 : wff = inss2 () |- ( A ∩ ( B × _V ) ) ⊆ ( B × _V ) ;;
	step 3 : wff = eqsstri (step 1, step 2) |- ( A ↾ B ) ⊆ ( B × _V ) ;;
	step 4 : wff = relxp () |- Rel ( B × _V ) ;;
	step 5 : wff = relss () |- ( ( A ↾ B ) ⊆ ( B × _V ) → ( Rel ( B × _V ) → Rel ( A ↾ B ) ) ) ;;
	step 6 : wff = mp2 (step 3, step 4, step 5) |- Rel ( A ↾ B ) ;;
	qed prop 1 = step 6 ;;
}

/*Absorption law for restriction.  Exercise 17 of [TakeutiZaring] p. 25.
     (Contributed by NM, 9-Aug-1994.) */

theorem resabs1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( B ⊆ C → ( ( A ↾ C ) ↾ B ) = ( A ↾ B ) ) ;;
}

proof of resabs1 {
	step 1 : wff = resres () |- ( ( A ↾ C ) ↾ B ) = ( A ↾ ( C ∩ B ) ) ;;
	step 2 : wff = sseqin2 () |- ( B ⊆ C ↔ ( C ∩ B ) = B ) ;;
	step 3 : wff = reseq2 () |- ( ( C ∩ B ) = B → ( A ↾ ( C ∩ B ) ) = ( A ↾ B ) ) ;;
	step 4 : wff = sylbi (step 2, step 3) |- ( B ⊆ C → ( A ↾ ( C ∩ B ) ) = ( A ↾ B ) ) ;;
	step 5 : wff = syl5eq (step 1, step 4) |- ( B ⊆ C → ( ( A ↾ C ) ↾ B ) = ( A ↾ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Absorption law for restriction.  (Contributed by NM, 27-Mar-1998.) */

theorem resabs2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( B ⊆ C → ( ( A ↾ B ) ↾ C ) = ( A ↾ B ) ) ;;
}

proof of resabs2 {
	step 1 : wff = rescom () |- ( ( A ↾ B ) ↾ C ) = ( ( A ↾ C ) ↾ B ) ;;
	step 2 : wff = resabs1 () |- ( B ⊆ C → ( ( A ↾ C ) ↾ B ) = ( A ↾ B ) ) ;;
	step 3 : wff = syl5eq (step 1, step 2) |- ( B ⊆ C → ( ( A ↾ B ) ↾ C ) = ( A ↾ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Idempotent law for restriction.  (Contributed by NM, 27-Mar-1998.) */

theorem residm (A : class, B : class)  {
	prop 1 : wff = |- ( ( A ↾ B ) ↾ B ) = ( A ↾ B ) ;;
}

proof of residm {
	step 1 : wff = ssid () |- B ⊆ B ;;
	step 2 : wff = resabs2 () |- ( B ⊆ B → ( ( A ↾ B ) ↾ B ) = ( A ↾ B ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( ( A ↾ B ) ↾ B ) = ( A ↾ B ) ;;
	qed prop 1 = step 3 ;;
}

/*A restriction to an image.  (Contributed by NM, 29-Sep-2004.) */

theorem resima (A : class, B : class)  {
	prop 1 : wff = |- ( ( A ↾ B ) " B ) = ( A " B ) ;;
}

proof of resima {
	step 1 : wff = residm () |- ( ( A ↾ B ) ↾ B ) = ( A ↾ B ) ;;
	step 2 : wff = rneqi (step 1) |- ran ( ( A ↾ B ) ↾ B ) = ran ( A ↾ B ) ;;
	step 3 : wff = df-ima () |- ( ( A ↾ B ) " B ) = ran ( ( A ↾ B ) ↾ B ) ;;
	step 4 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- ( ( A ↾ B ) " B ) = ( A " B ) ;;
	qed prop 1 = step 5 ;;
}

/*Image under a restricted class.  (Contributed by FL, 31-Aug-2009.) */

theorem resima2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( B ⊆ C → ( ( A ↾ C ) " B ) = ( A " B ) ) ;;
}

proof of resima2 {
	step 1 : wff = df-ima () |- ( ( A ↾ C ) " B ) = ran ( ( A ↾ C ) ↾ B ) ;;
	step 2 : wff = resres () |- ( ( A ↾ C ) ↾ B ) = ( A ↾ ( C ∩ B ) ) ;;
	step 3 : wff = rneqi (step 2) |- ran ( ( A ↾ C ) ↾ B ) = ran ( A ↾ ( C ∩ B ) ) ;;
	step 4 : wff = df-ss () |- ( B ⊆ C ↔ ( B ∩ C ) = B ) ;;
	step 5 : wff = incom () |- ( C ∩ B ) = ( B ∩ C ) ;;
	step 6 : wff = a1i (step 5) |- ( ( B ∩ C ) = B → ( C ∩ B ) = ( B ∩ C ) ) ;;
	step 7 : wff = reseq2d (step 6) |- ( ( B ∩ C ) = B → ( A ↾ ( C ∩ B ) ) = ( A ↾ ( B ∩ C ) ) ) ;;
	step 8 : wff = rneqd (step 7) |- ( ( B ∩ C ) = B → ran ( A ↾ ( C ∩ B ) ) = ran ( A ↾ ( B ∩ C ) ) ) ;;
	step 9 : wff = reseq2 () |- ( ( B ∩ C ) = B → ( A ↾ ( B ∩ C ) ) = ( A ↾ B ) ) ;;
	step 10 : wff = rneqd (step 9) |- ( ( B ∩ C ) = B → ran ( A ↾ ( B ∩ C ) ) = ran ( A ↾ B ) ) ;;
	step 11 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 12 : wff = syl6eqr (step 10, step 11) |- ( ( B ∩ C ) = B → ran ( A ↾ ( B ∩ C ) ) = ( A " B ) ) ;;
	step 13 : wff = eqtrd (step 8, step 12) |- ( ( B ∩ C ) = B → ran ( A ↾ ( C ∩ B ) ) = ( A " B ) ) ;;
	step 14 : wff = sylbi (step 4, step 13) |- ( B ⊆ C → ran ( A ↾ ( C ∩ B ) ) = ( A " B ) ) ;;
	step 15 : wff = syl5eq (step 3, step 14) |- ( B ⊆ C → ran ( ( A ↾ C ) ↾ B ) = ( A " B ) ) ;;
	step 16 : wff = syl5eq (step 1, step 15) |- ( B ⊆ C → ( ( A ↾ C ) " B ) = ( A " B ) ) ;;
	qed prop 1 = step 16 ;;
}

/*Restriction of a constant function (or other cross product).  (Contributed
     by Stefan O'Rear, 24-Jan-2015.) */

theorem xpssres (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( C ⊆ A → ( ( A × B ) ↾ C ) = ( C × B ) ) ;;
}

proof of xpssres {
	step 1 : wff = df-res () |- ( ( A × B ) ↾ C ) = ( ( A × B ) ∩ ( C × _V ) ) ;;
	step 2 : wff = inxp () |- ( ( A × B ) ∩ ( C × _V ) ) = ( ( A ∩ C ) × ( B ∩ _V ) ) ;;
	step 3 : wff = incom () |- ( A ∩ C ) = ( C ∩ A ) ;;
	step 4 : wff = inv1 () |- ( B ∩ _V ) = B ;;
	step 5 : wff = xpeq12i (step 3, step 4) |- ( ( A ∩ C ) × ( B ∩ _V ) ) = ( ( C ∩ A ) × B ) ;;
	step 6 : wff = 3eqtri (step 1, step 2, step 5) |- ( ( A × B ) ↾ C ) = ( ( C ∩ A ) × B ) ;;
	step 7 : wff = df-ss () |- ( C ⊆ A ↔ ( C ∩ A ) = C ) ;;
	step 8 : wff = biimpi (step 7) |- ( C ⊆ A → ( C ∩ A ) = C ) ;;
	step 9 : wff = xpeq1d (step 8) |- ( C ⊆ A → ( ( C ∩ A ) × B ) = ( C × B ) ) ;;
	step 10 : wff = syl5eq (step 6, step 9) |- ( C ⊆ A → ( ( A × B ) ↾ C ) = ( C × B ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Membership in a restriction.  (Contributed by Scott Fenton,
       17-Mar-2011.) */

theorem elres (x : set, y : set, A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ ( B ↾ C ) ↔ ∃ x ∈ C ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ;;
}

proof of elres {
	step 1 : wff = relres () |- Rel ( B ↾ C ) ;;
	step 2 : wff = elrel () |- ( ( Rel ( B ↾ C ) ∧ A ∈ ( B ↾ C ) ) → ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( A ∈ ( B ↾ C ) → ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 4 : wff = eleq1 () |- ( A = 〈 x , y 〉 → ( A ∈ ( B ↾ C ) ↔ 〈 x , y 〉 ∈ ( B ↾ C ) ) ) ;;
	step 5 : wff = biimpd (step 4) |- ( A = 〈 x , y 〉 → ( A ∈ ( B ↾ C ) → 〈 x , y 〉 ∈ ( B ↾ C ) ) ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = opelres (step 6) |- ( 〈 x , y 〉 ∈ ( B ↾ C ) ↔ ( 〈 x , y 〉 ∈ B ∧ x ∈ C ) ) ;;
	step 8 : wff = biimpi (step 7) |- ( 〈 x , y 〉 ∈ ( B ↾ C ) → ( 〈 x , y 〉 ∈ B ∧ x ∈ C ) ) ;;
	step 9 : wff = ancomd (step 8) |- ( 〈 x , y 〉 ∈ ( B ↾ C ) → ( x ∈ C ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 10 : wff = syl6com (step 5, step 9) |- ( A ∈ ( B ↾ C ) → ( A = 〈 x , y 〉 → ( x ∈ C ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 11 : wff = ancld (step 10) |- ( A ∈ ( B ↾ C ) → ( A = 〈 x , y 〉 → ( A = 〈 x , y 〉 ∧ ( x ∈ C ∧ 〈 x , y 〉 ∈ B ) ) ) ) ;;
	step 12 : wff = an12 () |- ( ( A = 〈 x , y 〉 ∧ ( x ∈ C ∧ 〈 x , y 〉 ∈ B ) ) ↔ ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 13 : wff = syl6ib (step 11, step 12) |- ( A ∈ ( B ↾ C ) → ( A = 〈 x , y 〉 → ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ) ;;
	step 14 : wff = 2eximdv (step 13) |- ( A ∈ ( B ↾ C ) → ( ∃ x ∃ y A = 〈 x , y 〉 → ∃ x ∃ y ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ) ;;
	step 15 : wff = mpd (step 3, step 14) |- ( A ∈ ( B ↾ C ) → ∃ x ∃ y ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 16 : wff = rexcom4 () |- ( ∃ x ∈ C ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ∃ y ∃ x ∈ C ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 17 : wff = df-rex () |- ( ∃ x ∈ C ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ∃ x ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 18 : wff = exbii (step 17) |- ( ∃ y ∃ x ∈ C ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ∃ y ∃ x ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 19 : wff = excom () |- ( ∃ y ∃ x ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ↔ ∃ x ∃ y ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 20 : wff = 3bitri (step 16, step 18, step 19) |- ( ∃ x ∈ C ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ∃ x ∃ y ( x ∈ C ∧ ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ) ;;
	step 21 : wff = sylibr (step 15, step 20) |- ( A ∈ ( B ↾ C ) → ∃ x ∈ C ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 22 : wff = vex () |- y ∈ _V ;;
	step 23 : wff = opelres (step 22) |- ( 〈 x , y 〉 ∈ ( B ↾ C ) ↔ ( 〈 x , y 〉 ∈ B ∧ x ∈ C ) ) ;;
	step 24 : wff = simplbi2com (step 23) |- ( x ∈ C → ( 〈 x , y 〉 ∈ B → 〈 x , y 〉 ∈ ( B ↾ C ) ) ) ;;
	step 25 : wff = eleq1 () |- ( A = 〈 x , y 〉 → ( A ∈ ( B ↾ C ) ↔ 〈 x , y 〉 ∈ ( B ↾ C ) ) ) ;;
	step 26 : wff = biimprd (step 25) |- ( A = 〈 x , y 〉 → ( 〈 x , y 〉 ∈ ( B ↾ C ) → A ∈ ( B ↾ C ) ) ) ;;
	step 27 : wff = syl9 (step 24, step 26) |- ( x ∈ C → ( A = 〈 x , y 〉 → ( 〈 x , y 〉 ∈ B → A ∈ ( B ↾ C ) ) ) ) ;;
	step 28 : wff = imp3a (step 27) |- ( x ∈ C → ( ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) → A ∈ ( B ↾ C ) ) ) ;;
	step 29 : wff = exlimdv (step 28) |- ( x ∈ C → ( ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) → A ∈ ( B ↾ C ) ) ) ;;
	step 30 : wff = rexlimiv (step 29) |- ( ∃ x ∈ C ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) → A ∈ ( B ↾ C ) ) ;;
	step 31 : wff = impbii (step 21, step 30) |- ( A ∈ ( B ↾ C ) ↔ ∃ x ∈ C ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ;;
	qed prop 1 = step 31 ;;
}

/*Memebership in restriction to a singleton.  (Contributed by Scott
         Fenton, 17-Mar-2011.) */

theorem elsnres (y : set, A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	hyp 1 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ( B ↾ { C } ) ↔ ∃ y ( A = 〈 C , y 〉 ∧ 〈 C , y 〉 ∈ B ) ) ;;
}

proof of elsnres {
	var x : set;;
	step 1 : wff = elres () |- ( A ∈ ( B ↾ { C } ) ↔ ∃ x ∈ { C } ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 2 : wff = rexcom4 () |- ( ∃ x ∈ { C } ∃ y ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ∃ y ∃ x ∈ { C } ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ) ;;
	step 3 : wff = opeq1 () |- ( x = C → 〈 x , y 〉 = 〈 C , y 〉 ) ;;
	step 4 : wff = eqeq2d (step 3) |- ( x = C → ( A = 〈 x , y 〉 ↔ A = 〈 C , y 〉 ) ) ;;
	step 5 : wff = opeq1 () |- ( x = C → 〈 x , y 〉 = 〈 C , y 〉 ) ;;
	step 6 : wff = eleq1d (step 5) |- ( x = C → ( 〈 x , y 〉 ∈ B ↔ 〈 C , y 〉 ∈ B ) ) ;;
	step 7 : wff = anbi12d (step 4, step 6) |- ( x = C → ( ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ( A = 〈 C , y 〉 ∧ 〈 C , y 〉 ∈ B ) ) ) ;;
	step 8 : wff = rexsn (hyp 1, step 7) |- ( ∃ x ∈ { C } ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ( A = 〈 C , y 〉 ∧ 〈 C , y 〉 ∈ B ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ y ∃ x ∈ { C } ( A = 〈 x , y 〉 ∧ 〈 x , y 〉 ∈ B ) ↔ ∃ y ( A = 〈 C , y 〉 ∧ 〈 C , y 〉 ∈ B ) ) ;;
	step 10 : wff = 3bitri (step 1, step 2, step 9) |- ( A ∈ ( B ↾ { C } ) ↔ ∃ y ( A = 〈 C , y 〉 ∧ 〈 C , y 〉 ∈ B ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Simplification law for restriction.  (Contributed by NM,
       16-Aug-1994.) */

theorem relssres (A : class, B : class) disjointed(x y A, x y B, x y) {
	prop 1 : wff = |- ( ( Rel A ∧ dom A ⊆ B ) → ( A ↾ B ) = A ) ;;
}

proof of relssres {
	var x : set, y : set;;
	step 1 : wff = simpl () |- ( ( Rel A ∧ dom A ⊆ B ) → Rel A ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opeldm (step 2, step 3) |- ( 〈 x , y 〉 ∈ A → x ∈ dom A ) ;;
	step 5 : wff = ssel () |- ( dom A ⊆ B → ( x ∈ dom A → x ∈ B ) ) ;;
	step 6 : wff = syl5 (step 4, step 5) |- ( dom A ⊆ B → ( 〈 x , y 〉 ∈ A → x ∈ B ) ) ;;
	step 7 : wff = ancld (step 6) |- ( dom A ⊆ B → ( 〈 x , y 〉 ∈ A → ( 〈 x , y 〉 ∈ A ∧ x ∈ B ) ) ) ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opelres (step 8) |- ( 〈 x , y 〉 ∈ ( A ↾ B ) ↔ ( 〈 x , y 〉 ∈ A ∧ x ∈ B ) ) ;;
	step 10 : wff = syl6ibr (step 7, step 9) |- ( dom A ⊆ B → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ ( A ↾ B ) ) ) ;;
	step 11 : wff = adantl (step 10) |- ( ( Rel A ∧ dom A ⊆ B ) → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ ( A ↾ B ) ) ) ;;
	step 12 : wff = relssdv (step 1, step 11) |- ( ( Rel A ∧ dom A ⊆ B ) → A ⊆ ( A ↾ B ) ) ;;
	step 13 : wff = resss () |- ( A ↾ B ) ⊆ A ;;
	step 14 : wff = jctil (step 12, step 13) |- ( ( Rel A ∧ dom A ⊆ B ) → ( ( A ↾ B ) ⊆ A ∧ A ⊆ ( A ↾ B ) ) ) ;;
	step 15 : wff = eqss () |- ( ( A ↾ B ) = A ↔ ( ( A ↾ B ) ⊆ A ∧ A ⊆ ( A ↾ B ) ) ) ;;
	step 16 : wff = sylibr (step 14, step 15) |- ( ( Rel A ∧ dom A ⊆ B ) → ( A ↾ B ) = A ) ;;
	qed prop 1 = step 16 ;;
}

/*A relation restricted to its domain equals itself.  (Contributed by NM,
     12-Dec-2006.) */

theorem resdm (A : class)  {
	prop 1 : wff = |- ( Rel A → ( A ↾ dom A ) = A ) ;;
}

proof of resdm {
	step 1 : wff = ssid () |- dom A ⊆ dom A ;;
	step 2 : wff = relssres () |- ( ( Rel A ∧ dom A ⊆ dom A ) → ( A ↾ dom A ) = A ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( Rel A → ( A ↾ dom A ) = A ) ;;
	qed prop 1 = step 3 ;;
}

/*The restriction of a set is a set.  (Contributed by NM, 28-Mar-1998.)
     (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem resexg (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ( A ↾ B ) ∈ _V ) ;;
}

proof of resexg {
	step 1 : wff = resss () |- ( A ↾ B ) ⊆ A ;;
	step 2 : wff = ssexg () |- ( ( ( A ↾ B ) ⊆ A ∧ A ∈ V ) → ( A ↾ B ) ∈ _V ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( A ∈ V → ( A ↾ B ) ∈ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*The restriction of a set is a set.  (Contributed by Jeff Madsen,
       19-Jun-2011.) */

theorem resex (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ↾ B ) ∈ _V ;;
}

proof of resex {
	step 1 : wff = resexg () |- ( A ∈ _V → ( A ↾ B ) ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ↾ B ) ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*Restriction of a class abstraction of ordered pairs.  (Contributed by
       NM, 5-Nov-2002.) */

theorem resopab (ph : wff, x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( { 〈 x , y 〉 | ph } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
}

proof of resopab {
	step 1 : wff = df-res () |- ( { 〈 x , y 〉 | ph } ↾ A ) = ( { 〈 x , y 〉 | ph } ∩ ( A × _V ) ) ;;
	step 2 : wff = df-xp () |- ( A × _V ) = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ _V ) } ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = biantru (step 3) |- ( x ∈ A ↔ ( x ∈ A ∧ y ∈ _V ) ) ;;
	step 5 : wff = opabbii (step 4) |- { 〈 x , y 〉 | x ∈ A } = { 〈 x , y 〉 | ( x ∈ A ∧ y ∈ _V ) } ;;
	step 6 : wff = eqtr4i (step 2, step 5) |- ( A × _V ) = { 〈 x , y 〉 | x ∈ A } ;;
	step 7 : wff = ineq2i (step 6) |- ( { 〈 x , y 〉 | ph } ∩ ( A × _V ) ) = ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | x ∈ A } ) ;;
	step 8 : wff = incom () |- ( { 〈 x , y 〉 | ph } ∩ { 〈 x , y 〉 | x ∈ A } ) = ( { 〈 x , y 〉 | x ∈ A } ∩ { 〈 x , y 〉 | ph } ) ;;
	step 9 : wff = eqtri (step 7, step 8) |- ( { 〈 x , y 〉 | ph } ∩ ( A × _V ) ) = ( { 〈 x , y 〉 | x ∈ A } ∩ { 〈 x , y 〉 | ph } ) ;;
	step 10 : wff = inopab () |- ( { 〈 x , y 〉 | x ∈ A } ∩ { 〈 x , y 〉 | ph } ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 11 : wff = eqtri (step 9, step 10) |- ( { 〈 x , y 〉 | ph } ∩ ( A × _V ) ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	step 12 : wff = eqtri (step 1, step 11) |- ( { 〈 x , y 〉 | ph } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ;;
	qed prop 1 = step 12 ;;
}

/*The existence of a restricted identity function, proved without using
       the Axiom of Replacement (unlike ~ resfunexg ).  (Contributed by NM,
       13-Jan-2007.) */

theorem resiexg (A : class, V : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ∈ V → ( _I ↾ A ) ∈ _V ) ;;
}

proof of resiexg {
	var x : set, y : set;;
	step 1 : wff = relres () |- Rel ( _I ↾ A ) ;;
	step 2 : wff = simpr () |- ( ( x = y ∧ x ∈ A ) → x ∈ A ) ;;
	step 3 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 4 : wff = biimpa (step 3) |- ( ( x = y ∧ x ∈ A ) → y ∈ A ) ;;
	step 5 : wff = jca (step 2, step 4) |- ( ( x = y ∧ x ∈ A ) → ( x ∈ A ∧ y ∈ A ) ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = opelres (step 6) |- ( 〈 x , y 〉 ∈ ( _I ↾ A ) ↔ ( 〈 x , y 〉 ∈ _I ∧ x ∈ A ) ) ;;
	step 8 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = ideq (step 9) |- ( x _I y ↔ x = y ) ;;
	step 11 : wff = bitr3i (step 8, step 10) |- ( 〈 x , y 〉 ∈ _I ↔ x = y ) ;;
	step 12 : wff = anbi1i (step 11) |- ( ( 〈 x , y 〉 ∈ _I ∧ x ∈ A ) ↔ ( x = y ∧ x ∈ A ) ) ;;
	step 13 : wff = bitri (step 7, step 12) |- ( 〈 x , y 〉 ∈ ( _I ↾ A ) ↔ ( x = y ∧ x ∈ A ) ) ;;
	step 14 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × A ) ↔ ( x ∈ A ∧ y ∈ A ) ) ;;
	step 15 : wff = 3imtr4i (step 5, step 13, step 14) |- ( 〈 x , y 〉 ∈ ( _I ↾ A ) → 〈 x , y 〉 ∈ ( A × A ) ) ;;
	step 16 : wff = relssi (step 1, step 15) |- ( _I ↾ A ) ⊆ ( A × A ) ;;
	step 17 : wff = xpexg () |- ( ( A ∈ V ∧ A ∈ V ) → ( A × A ) ∈ _V ) ;;
	step 18 : wff = anidms (step 17) |- ( A ∈ V → ( A × A ) ∈ _V ) ;;
	step 19 : wff = ssexg () |- ( ( ( _I ↾ A ) ⊆ ( A × A ) ∧ ( A × A ) ∈ _V ) → ( _I ↾ A ) ∈ _V ) ;;
	step 20 : wff = sylancr (step 16, step 18, step 19) |- ( A ∈ V → ( _I ↾ A ) ∈ _V ) ;;
	qed prop 1 = step 20 ;;
}

/*A subclass of the identity function is the identity function restricted
       to its domain.  (Contributed by NM, 13-Dec-2003.)  (Proof shortened by
       Andrew Salmon, 27-Aug-2011.) */

theorem iss (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ⊆ _I ↔ A = ( _I ↾ dom A ) ) ;;
}

proof of iss {
	var x : set, y : set;;
	step 1 : wff = ssel () |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ _I ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opeldm (step 2, step 3) |- ( 〈 x , y 〉 ∈ A → x ∈ dom A ) ;;
	step 5 : wff = a1i (step 4) |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A → x ∈ dom A ) ) ;;
	step 6 : wff = jcad (step 1, step 5) |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A → ( 〈 x , y 〉 ∈ _I ∧ x ∈ dom A ) ) ) ;;
	step 7 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = ideq (step 8) |- ( x _I y ↔ x = y ) ;;
	step 10 : wff = bitr3i (step 7, step 9) |- ( 〈 x , y 〉 ∈ _I ↔ x = y ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = eldm2 (step 11) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 13 : wff = ssel () |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ _I ) ) ;;
	step 14 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = ideq (step 15) |- ( x _I y ↔ x = y ) ;;
	step 17 : wff = bitr3i (step 14, step 16) |- ( 〈 x , y 〉 ∈ _I ↔ x = y ) ;;
	step 18 : wff = opeq2 () |- ( x = y → 〈 x , x 〉 = 〈 x , y 〉 ) ;;
	step 19 : wff = eleq1d (step 18) |- ( x = y → ( 〈 x , x 〉 ∈ A ↔ 〈 x , y 〉 ∈ A ) ) ;;
	step 20 : wff = biimprcd (step 19) |- ( 〈 x , y 〉 ∈ A → ( x = y → 〈 x , x 〉 ∈ A ) ) ;;
	step 21 : wff = syl5bi (step 17, step 20) |- ( 〈 x , y 〉 ∈ A → ( 〈 x , y 〉 ∈ _I → 〈 x , x 〉 ∈ A ) ) ;;
	step 22 : wff = sylcom (step 13, step 21) |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A → 〈 x , x 〉 ∈ A ) ) ;;
	step 23 : wff = exlimdv (step 22) |- ( A ⊆ _I → ( ∃ y 〈 x , y 〉 ∈ A → 〈 x , x 〉 ∈ A ) ) ;;
	step 24 : wff = syl5bi (step 12, step 23) |- ( A ⊆ _I → ( x ∈ dom A → 〈 x , x 〉 ∈ A ) ) ;;
	step 25 : wff = opeq2 () |- ( x = y → 〈 x , x 〉 = 〈 x , y 〉 ) ;;
	step 26 : wff = eleq1d (step 25) |- ( x = y → ( 〈 x , x 〉 ∈ A ↔ 〈 x , y 〉 ∈ A ) ) ;;
	step 27 : wff = imbi2d (step 26) |- ( x = y → ( ( x ∈ dom A → 〈 x , x 〉 ∈ A ) ↔ ( x ∈ dom A → 〈 x , y 〉 ∈ A ) ) ) ;;
	step 28 : wff = syl5ibcom (step 24, step 27) |- ( A ⊆ _I → ( x = y → ( x ∈ dom A → 〈 x , y 〉 ∈ A ) ) ) ;;
	step 29 : wff = syl5bi (step 10, step 28) |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ _I → ( x ∈ dom A → 〈 x , y 〉 ∈ A ) ) ) ;;
	step 30 : wff = imp3a (step 29) |- ( A ⊆ _I → ( ( 〈 x , y 〉 ∈ _I ∧ x ∈ dom A ) → 〈 x , y 〉 ∈ A ) ) ;;
	step 31 : wff = impbid (step 6, step 30) |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A ↔ ( 〈 x , y 〉 ∈ _I ∧ x ∈ dom A ) ) ) ;;
	step 32 : wff = vex () |- y ∈ _V ;;
	step 33 : wff = opelres (step 32) |- ( 〈 x , y 〉 ∈ ( _I ↾ dom A ) ↔ ( 〈 x , y 〉 ∈ _I ∧ x ∈ dom A ) ) ;;
	step 34 : wff = syl6bbr (step 31, step 33) |- ( A ⊆ _I → ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ( _I ↾ dom A ) ) ) ;;
	step 35 : wff = alrimivv (step 34) |- ( A ⊆ _I → ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ( _I ↾ dom A ) ) ) ;;
	step 36 : wff = reli () |- Rel _I ;;
	step 37 : wff = relss () |- ( A ⊆ _I → ( Rel _I → Rel A ) ) ;;
	step 38 : wff = mpi (step 36, step 37) |- ( A ⊆ _I → Rel A ) ;;
	step 39 : wff = relres () |- Rel ( _I ↾ dom A ) ;;
	step 40 : wff = eqrel () |- ( ( Rel A ∧ Rel ( _I ↾ dom A ) ) → ( A = ( _I ↾ dom A ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ( _I ↾ dom A ) ) ) ) ;;
	step 41 : wff = sylancl (step 38, step 39, step 40) |- ( A ⊆ _I → ( A = ( _I ↾ dom A ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ A ↔ 〈 x , y 〉 ∈ ( _I ↾ dom A ) ) ) ) ;;
	step 42 : wff = mpbird (step 35, step 41) |- ( A ⊆ _I → A = ( _I ↾ dom A ) ) ;;
	step 43 : wff = resss () |- ( _I ↾ dom A ) ⊆ _I ;;
	step 44 : wff = sseq1 () |- ( A = ( _I ↾ dom A ) → ( A ⊆ _I ↔ ( _I ↾ dom A ) ⊆ _I ) ) ;;
	step 45 : wff = mpbiri (step 43, step 44) |- ( A = ( _I ↾ dom A ) → A ⊆ _I ) ;;
	step 46 : wff = impbii (step 42, step 45) |- ( A ⊆ _I ↔ A = ( _I ↾ dom A ) ) ;;
	qed prop 1 = step 46 ;;
}

/*Restriction of a class abstraction of ordered pairs.  (Contributed by
       NM, 24-Aug-2007.) */

theorem resopab2 (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, y) {
	prop 1 : wff = |- ( A ⊆ B → ( { 〈 x , y 〉 | ( x ∈ B ∧ ph ) } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ) ;;
}

proof of resopab2 {
	step 1 : wff = resopab () |- ( { 〈 x , y 〉 | ( x ∈ B ∧ ph ) } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ ( x ∈ B ∧ ph ) ) } ;;
	step 2 : wff = ssel () |- ( A ⊆ B → ( x ∈ A → x ∈ B ) ) ;;
	step 3 : wff = pm4.71d (step 2) |- ( A ⊆ B → ( x ∈ A ↔ ( x ∈ A ∧ x ∈ B ) ) ) ;;
	step 4 : wff = anbi1d (step 3) |- ( A ⊆ B → ( ( x ∈ A ∧ ph ) ↔ ( ( x ∈ A ∧ x ∈ B ) ∧ ph ) ) ) ;;
	step 5 : wff = anass () |- ( ( ( x ∈ A ∧ x ∈ B ) ∧ ph ) ↔ ( x ∈ A ∧ ( x ∈ B ∧ ph ) ) ) ;;
	step 6 : wff = syl6rbb (step 4, step 5) |- ( A ⊆ B → ( ( x ∈ A ∧ ( x ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ ph ) ) ) ;;
	step 7 : wff = opabbidv (step 6) |- ( A ⊆ B → { 〈 x , y 〉 | ( x ∈ A ∧ ( x ∈ B ∧ ph ) ) } = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ) ;;
	step 8 : wff = syl5eq (step 1, step 7) |- ( A ⊆ B → ( { 〈 x , y 〉 | ( x ∈ B ∧ ph ) } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ ph ) } ) ;;
	qed prop 1 = step 8 ;;
}

/*Restriction of the mapping operation.  (Contributed by Mario Carneiro,
       15-Jul-2013.) */

theorem resmpt (x : set, A : class, B : class, C : class) disjointed(x y A, x y B, y C) {
	prop 1 : wff = |- ( B ⊆ A → ( ( x ∈ A ↦ C ) ↾ B ) = ( x ∈ B ↦ C ) ) ;;
}

proof of resmpt {
	var y : set;;
	step 1 : wff = resopab2 () |- ( B ⊆ A → ( { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ↾ B ) = { 〈 x , y 〉 | ( x ∈ B ∧ y = C ) } ) ;;
	step 2 : wff = df-mpt () |- ( x ∈ A ↦ C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 3 : wff = reseq1i (step 2) |- ( ( x ∈ A ↦ C ) ↾ B ) = ( { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ↾ B ) ;;
	step 4 : wff = df-mpt () |- ( x ∈ B ↦ C ) = { 〈 x , y 〉 | ( x ∈ B ∧ y = C ) } ;;
	step 5 : wff = 3eqtr4g (step 1, step 3, step 4) |- ( B ⊆ A → ( ( x ∈ A ↦ C ) ↾ B ) = ( x ∈ B ↦ C ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Unconditional restriction of the mapping operation.  (Contributed by
       Stefan O'Rear, 24-Jan-2015.)  (Proof shortened by Mario Carneiro,
       22-Mar-2015.) */

theorem resmpt3 (x : set, A : class, B : class, C : class) disjointed(x A, x B, C) {
	prop 1 : wff = |- ( ( x ∈ A ↦ C ) ↾ B ) = ( x ∈ ( A ∩ B ) ↦ C ) ;;
}

proof of resmpt3 {
	step 1 : wff = resres () |- ( ( ( x ∈ A ↦ C ) ↾ A ) ↾ B ) = ( ( x ∈ A ↦ C ) ↾ ( A ∩ B ) ) ;;
	step 2 : wff = ssid () |- A ⊆ A ;;
	step 3 : wff = resmpt () |- ( A ⊆ A → ( ( x ∈ A ↦ C ) ↾ A ) = ( x ∈ A ↦ C ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ( x ∈ A ↦ C ) ↾ A ) = ( x ∈ A ↦ C ) ;;
	step 5 : wff = reseq1i (step 4) |- ( ( ( x ∈ A ↦ C ) ↾ A ) ↾ B ) = ( ( x ∈ A ↦ C ) ↾ B ) ;;
	step 6 : wff = inss1 () |- ( A ∩ B ) ⊆ A ;;
	step 7 : wff = resmpt () |- ( ( A ∩ B ) ⊆ A → ( ( x ∈ A ↦ C ) ↾ ( A ∩ B ) ) = ( x ∈ ( A ∩ B ) ↦ C ) ) ;;
	step 8 : wff = ax-mp (step 6, step 7) |- ( ( x ∈ A ↦ C ) ↾ ( A ∩ B ) ) = ( x ∈ ( A ∩ B ) ↦ C ) ;;
	step 9 : wff = 3eqtr3i (step 1, step 5, step 8) |- ( ( x ∈ A ↦ C ) ↾ B ) = ( x ∈ ( A ∩ B ) ↦ C ) ;;
	qed prop 1 = step 9 ;;
}

/*Alternate definition of the restriction operation.  (Contributed by
       Mario Carneiro, 5-Nov-2013.) */

theorem dfres2 (x : set, y : set, A : class, R : class) disjointed(w x y z A, w x y z R) {
	prop 1 : wff = |- ( R ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ x R y ) } ;;
}

proof of dfres2 {
	var z : set, w : set;;
	step 1 : wff = relres () |- Rel ( R ↾ A ) ;;
	step 2 : wff = relopab () |- Rel { 〈 x , y 〉 | ( x ∈ A ∧ x R y ) } ;;
	step 3 : wff = vex () |- w ∈ _V ;;
	step 4 : wff = brres (step 3) |- ( z ( R ↾ A ) w ↔ ( z R w ∧ z ∈ A ) ) ;;
	step 5 : wff = df-br () |- ( z ( R ↾ A ) w ↔ 〈 z , w 〉 ∈ ( R ↾ A ) ) ;;
	step 6 : wff = ancom () |- ( ( z R w ∧ z ∈ A ) ↔ ( z ∈ A ∧ z R w ) ) ;;
	step 7 : wff = 3bitr3i (step 4, step 5, step 6) |- ( 〈 z , w 〉 ∈ ( R ↾ A ) ↔ ( z ∈ A ∧ z R w ) ) ;;
	step 8 : wff = vex () |- z ∈ _V ;;
	step 9 : wff = vex () |- w ∈ _V ;;
	step 10 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 11 : wff = breq1 () |- ( x = z → ( x R y ↔ z R y ) ) ;;
	step 12 : wff = anbi12d (step 10, step 11) |- ( x = z → ( ( x ∈ A ∧ x R y ) ↔ ( z ∈ A ∧ z R y ) ) ) ;;
	step 13 : wff = breq2 () |- ( y = w → ( z R y ↔ z R w ) ) ;;
	step 14 : wff = anbi2d (step 13) |- ( y = w → ( ( z ∈ A ∧ z R y ) ↔ ( z ∈ A ∧ z R w ) ) ) ;;
	step 15 : wff = opelopab (step 8, step 9, step 12, step 14) |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ( x ∈ A ∧ x R y ) } ↔ ( z ∈ A ∧ z R w ) ) ;;
	step 16 : wff = bitr4i (step 7, step 15) |- ( 〈 z , w 〉 ∈ ( R ↾ A ) ↔ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ( x ∈ A ∧ x R y ) } ) ;;
	step 17 : wff = eqrelriiv (step 1, step 2, step 16) |- ( R ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ x R y ) } ;;
	qed prop 1 = step 17 ;;
}

/*The restricted identity expressed with the class builder.  (Contributed
       by FL, 25-Apr-2012.) */

theorem opabresid (x : set, y : set, A : class) disjointed(A x y) {
	prop 1 : wff = |- { 〈 x , y 〉 | ( x ∈ A ∧ y = x ) } = ( _I ↾ A ) ;;
}

proof of opabresid {
	step 1 : wff = resopab () |- ( { 〈 x , y 〉 | y = x } ↾ A ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = x ) } ;;
	step 2 : wff = equcom () |- ( y = x ↔ x = y ) ;;
	step 3 : wff = opabbii (step 2) |- { 〈 x , y 〉 | y = x } = { 〈 x , y 〉 | x = y } ;;
	step 4 : wff = dfid3 () |- _I = { 〈 x , y 〉 | x = y } ;;
	step 5 : wff = eqtr4i (step 3, step 4) |- { 〈 x , y 〉 | y = x } = _I ;;
	step 6 : wff = reseq1i (step 5) |- ( { 〈 x , y 〉 | y = x } ↾ A ) = ( _I ↾ A ) ;;
	step 7 : wff = eqtr3i (step 1, step 6) |- { 〈 x , y 〉 | ( x ∈ A ∧ y = x ) } = ( _I ↾ A ) ;;
	qed prop 1 = step 7 ;;
}

/*The restricted identity expressed with the "maps to" notation.
       (Contributed by FL, 25-Apr-2012.) */

theorem mptresid (x : set, A : class) disjointed(A x y) {
	prop 1 : wff = |- ( x ∈ A ↦ x ) = ( _I ↾ A ) ;;
}

proof of mptresid {
	var y : set;;
	step 1 : wff = df-mpt () |- ( x ∈ A ↦ x ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = x ) } ;;
	step 2 : wff = opabresid () |- { 〈 x , y 〉 | ( x ∈ A ∧ y = x ) } = ( _I ↾ A ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( x ∈ A ↦ x ) = ( _I ↾ A ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a restricted identity function.  (Contributed by NM,
     27-Aug-2004.) */

theorem dmresi (A : class)  {
	prop 1 : wff = |- dom ( _I ↾ A ) = A ;;
}

proof of dmresi {
	step 1 : wff = ssv () |- A ⊆ _V ;;
	step 2 : wff = dmi () |- dom _I = _V ;;
	step 3 : wff = sseqtr4i (step 1, step 2) |- A ⊆ dom _I ;;
	step 4 : wff = ssdmres () |- ( A ⊆ dom _I ↔ dom ( _I ↾ A ) = A ) ;;
	step 5 : wff = mpbi (step 3, step 4) |- dom ( _I ↾ A ) = A ;;
	qed prop 1 = step 5 ;;
}

/*TODO - delete this and replace w/ dfres3 (in FL's mathbox) */

/*Any relation restricted to the universe is itself.  (Contributed by NM,
     16-Mar-2004.) */

theorem resid (A : class)  {
	prop 1 : wff = |- ( Rel A → ( A ↾ _V ) = A ) ;;
}

proof of resid {
	step 1 : wff = ssv () |- dom A ⊆ _V ;;
	step 2 : wff = relssres () |- ( ( Rel A ∧ dom A ⊆ _V ) → ( A ↾ _V ) = A ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( Rel A → ( A ↾ _V ) = A ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality theorem for image.  (Contributed by NM, 14-Aug-1994.) */

theorem imaeq1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( A " C ) = ( B " C ) ) ;;
}

proof of imaeq1 {
	step 1 : wff = reseq1 () |- ( A = B → ( A ↾ C ) = ( B ↾ C ) ) ;;
	step 2 : wff = rneqd (step 1) |- ( A = B → ran ( A ↾ C ) = ran ( B ↾ C ) ) ;;
	step 3 : wff = df-ima () |- ( A " C ) = ran ( A ↾ C ) ;;
	step 4 : wff = df-ima () |- ( B " C ) = ran ( B ↾ C ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ( A " C ) = ( B " C ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for image.  (Contributed by NM, 14-Aug-1994.) */

theorem imaeq2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( C " A ) = ( C " B ) ) ;;
}

proof of imaeq2 {
	step 1 : wff = reseq2 () |- ( A = B → ( C ↾ A ) = ( C ↾ B ) ) ;;
	step 2 : wff = rneqd (step 1) |- ( A = B → ran ( C ↾ A ) = ran ( C ↾ B ) ) ;;
	step 3 : wff = df-ima () |- ( C " A ) = ran ( C ↾ A ) ;;
	step 4 : wff = df-ima () |- ( C " B ) = ran ( C ↾ B ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ( C " A ) = ( C " B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality theorem for image.  (Contributed by NM, 21-Dec-2008.) */

theorem imaeq1i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A " C ) = ( B " C ) ;;
}

proof of imaeq1i {
	step 1 : wff = imaeq1 () |- ( A = B → ( A " C ) = ( B " C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A " C ) = ( B " C ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for image.  (Contributed by NM, 21-Dec-2008.) */

theorem imaeq2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C " A ) = ( C " B ) ;;
}

proof of imaeq2i {
	step 1 : wff = imaeq2 () |- ( A = B → ( C " A ) = ( C " B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C " A ) = ( C " B ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for image.  (Contributed by FL, 15-Dec-2006.) */

theorem imaeq1d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A " C ) = ( B " C ) ) ;;
}

proof of imaeq1d {
	step 1 : wff = imaeq1 () |- ( A = B → ( A " C ) = ( B " C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A " C ) = ( B " C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for image.  (Contributed by FL, 15-Dec-2006.) */

theorem imaeq2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C " A ) = ( C " B ) ) ;;
}

proof of imaeq2d {
	step 1 : wff = imaeq2 () |- ( A = B → ( C " A ) = ( C " B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C " A ) = ( C " B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for image.  (Contributed by Mario Carneiro,
       4-Dec-2016.) */

theorem imaeq12d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A " C ) = ( B " D ) ) ;;
}

proof of imaeq12d {
	step 1 : wff = imaeq1d (hyp 1) |- ( ph → ( A " C ) = ( B " C ) ) ;;
	step 2 : wff = imaeq2d (hyp 2) |- ( ph → ( B " C ) = ( B " D ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → ( A " C ) = ( B " D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of image.  Compare definition (d) of [Enderton]
       p. 44.  (Contributed by NM, 19-Apr-2004.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem dfima2 (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A " B ) = { y | ∃ x ∈ B x A y } ;;
}

proof of dfima2 {
	step 1 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 2 : wff = dfrn2 () |- ran ( A ↾ B ) = { y | ∃ x x ( A ↾ B ) y } ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = brres (step 3) |- ( x ( A ↾ B ) y ↔ ( x A y ∧ x ∈ B ) ) ;;
	step 5 : wff = ancom () |- ( ( x A y ∧ x ∈ B ) ↔ ( x ∈ B ∧ x A y ) ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( x ( A ↾ B ) y ↔ ( x ∈ B ∧ x A y ) ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ x x ( A ↾ B ) y ↔ ∃ x ( x ∈ B ∧ x A y ) ) ;;
	step 8 : wff = df-rex () |- ( ∃ x ∈ B x A y ↔ ∃ x ( x ∈ B ∧ x A y ) ) ;;
	step 9 : wff = bitr4i (step 7, step 8) |- ( ∃ x x ( A ↾ B ) y ↔ ∃ x ∈ B x A y ) ;;
	step 10 : wff = abbii (step 9) |- { y | ∃ x x ( A ↾ B ) y } = { y | ∃ x ∈ B x A y } ;;
	step 11 : wff = 3eqtri (step 1, step 2, step 10) |- ( A " B ) = { y | ∃ x ∈ B x A y } ;;
	qed prop 1 = step 11 ;;
}

/*Alternate definition of image.  Compare definition (d) of [Enderton]
       p. 44.  (Contributed by NM, 14-Aug-1994.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem dfima3 (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A " B ) = { y | ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) } ;;
}

proof of dfima3 {
	step 1 : wff = dfima2 () |- ( A " B ) = { y | ∃ x ∈ B x A y } ;;
	step 2 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ x ∈ B x A y ↔ ∃ x ∈ B 〈 x , y 〉 ∈ A ) ;;
	step 4 : wff = df-rex () |- ( ∃ x ∈ B 〈 x , y 〉 ∈ A ↔ ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ∃ x ∈ B x A y ↔ ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) ) ;;
	step 6 : wff = abbii (step 5) |- { y | ∃ x ∈ B x A y } = { y | ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) } ;;
	step 7 : wff = eqtri (step 1, step 6) |- ( A " B ) = { y | ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) } ;;
	qed prop 1 = step 7 ;;
}

/*Membership in an image.  Theorem 34 of [Suppes] p. 65.  (Contributed by
       NM, 20-Jan-2007.) */

theorem elimag (x : set, A : class, B : class, C : class, V : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ ( B " C ) ↔ ∃ x ∈ C x B A ) ) ;;
}

proof of elimag {
	var y : set;;
	step 1 : wff = breq2 () |- ( y = A → ( x B y ↔ x B A ) ) ;;
	step 2 : wff = rexbidv (step 1) |- ( y = A → ( ∃ x ∈ C x B y ↔ ∃ x ∈ C x B A ) ) ;;
	step 3 : wff = dfima2 () |- ( B " C ) = { y | ∃ x ∈ C x B y } ;;
	step 4 : wff = elab2g (step 2, step 3) |- ( A ∈ V → ( A ∈ ( B " C ) ↔ ∃ x ∈ C x B A ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Membership in an image.  Theorem 34 of [Suppes] p. 65.  (Contributed by
       NM, 19-Apr-2004.) */

theorem elima (x : set, A : class, B : class, C : class) disjointed(x A, x B, x C) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ( B " C ) ↔ ∃ x ∈ C x B A ) ;;
}

proof of elima {
	step 1 : wff = elimag () |- ( A ∈ _V → ( A ∈ ( B " C ) ↔ ∃ x ∈ C x B A ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ ( B " C ) ↔ ∃ x ∈ C x B A ) ;;
	qed prop 1 = step 2 ;;
}

/*Membership in an image.  Theorem 34 of [Suppes] p. 65.  (Contributed by
       NM, 11-Aug-2004.) */

theorem elima2 (x : set, A : class, B : class, C : class) disjointed(x A, x B, x C) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ( B " C ) ↔ ∃ x ( x ∈ C ∧ x B A ) ) ;;
}

proof of elima2 {
	step 1 : wff = elima (hyp 1) |- ( A ∈ ( B " C ) ↔ ∃ x ∈ C x B A ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ C x B A ↔ ∃ x ( x ∈ C ∧ x B A ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A ∈ ( B " C ) ↔ ∃ x ( x ∈ C ∧ x B A ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Membership in an image.  Theorem 34 of [Suppes] p. 65.  (Contributed by
       NM, 14-Aug-1994.) */

theorem elima3 (x : set, A : class, B : class, C : class) disjointed(x A, x B, x C) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ( B " C ) ↔ ∃ x ( x ∈ C ∧ 〈 x , A 〉 ∈ B ) ) ;;
}

proof of elima3 {
	step 1 : wff = elima2 (hyp 1) |- ( A ∈ ( B " C ) ↔ ∃ x ( x ∈ C ∧ x B A ) ) ;;
	step 2 : wff = df-br () |- ( x B A ↔ 〈 x , A 〉 ∈ B ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( x ∈ C ∧ x B A ) ↔ ( x ∈ C ∧ 〈 x , A 〉 ∈ B ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ x ( x ∈ C ∧ x B A ) ↔ ∃ x ( x ∈ C ∧ 〈 x , A 〉 ∈ B ) ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( A ∈ ( B " C ) ↔ ∃ x ( x ∈ C ∧ 〈 x , A 〉 ∈ B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for image.  (Contributed by NM,
       30-Dec-1996.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem nfima (x : set, A : class, B : class) disjointed(A, B, x) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x ( A " B ) ;;
}

proof of nfima {
	step 1 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 2 : wff = nfres (hyp 1, hyp 2) |- F/_ x ( A ↾ B ) ;;
	step 3 : wff = nfrn (step 2) |- F/_ x ran ( A ↾ B ) ;;
	step 4 : wff = nfcxfr (step 1, step 3) |- F/_ x ( A " B ) ;;
	qed prop 1 = step 4 ;;
}

/*Deduction version of bound-variable hypothesis builder ~ nfima .
       (Contributed by FL, 15-Dec-2006.)  (Revised by Mario Carneiro,
       15-Oct-2016.) */

theorem nfimad (ph : wff, x : set, A : class, B : class) disjointed(x z, B z, A z, ph) {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	hyp 2 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x ( A " B ) ) ;;
}

proof of nfimad {
	var z : set;;
	step 1 : wff = nfaba1 () |- F/_ x { z | ∀ x z ∈ A } ;;
	step 2 : wff = nfaba1 () |- F/_ x { z | ∀ x z ∈ B } ;;
	step 3 : wff = nfima (step 1, step 2) |- F/_ x ( { z | ∀ x z ∈ A } " { z | ∀ x z ∈ B } ) ;;
	step 4 : wff = nfnfc1 () |- F/ x F/_ x A ;;
	step 5 : wff = nfnfc1 () |- F/ x F/_ x B ;;
	step 6 : wff = nfan (step 4, step 5) |- F/ x ( F/_ x A ∧ F/_ x B ) ;;
	step 7 : wff = abidnf () |- ( F/_ x A → { z | ∀ x z ∈ A } = A ) ;;
	step 8 : wff = imaeq1d (step 7) |- ( F/_ x A → ( { z | ∀ x z ∈ A } " { z | ∀ x z ∈ B } ) = ( A " { z | ∀ x z ∈ B } ) ) ;;
	step 9 : wff = abidnf () |- ( F/_ x B → { z | ∀ x z ∈ B } = B ) ;;
	step 10 : wff = imaeq2d (step 9) |- ( F/_ x B → ( A " { z | ∀ x z ∈ B } ) = ( A " B ) ) ;;
	step 11 : wff = sylan9eq (step 8, step 10) |- ( ( F/_ x A ∧ F/_ x B ) → ( { z | ∀ x z ∈ A } " { z | ∀ x z ∈ B } ) = ( A " B ) ) ;;
	step 12 : wff = nfceqdf (step 6, step 11) |- ( ( F/_ x A ∧ F/_ x B ) → ( F/_ x ( { z | ∀ x z ∈ A } " { z | ∀ x z ∈ B } ) ↔ F/_ x ( A " B ) ) ) ;;
	step 13 : wff = syl2anc (hyp 1, hyp 2, step 12) |- ( ph → ( F/_ x ( { z | ∀ x z ∈ A } " { z | ∀ x z ∈ B } ) ↔ F/_ x ( A " B ) ) ) ;;
	step 14 : wff = mpbii (step 3, step 13) |- ( ph → F/_ x ( A " B ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Move class substitution in and out of the image of a function.
       (Contributed by FL, 15-Dec-2006.)  (Proof shortened by Mario Carneiro,
       4-Dec-2016.) */

theorem csbima12g (x : set, A : class, B : class, C : class, F : class) disjointed(A y, B y, C y, x y, F y) {
	prop 1 : wff = |- ( A ∈ C → [_ A / x ]_ ( F " B ) = ( [_ A / x ]_ F " [_ A / x ]_ B ) ) ;;
}

proof of csbima12g {
	var y : set;;
	step 1 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ ( F " B ) = [_ A / x ]_ ( F " B ) ) ;;
	step 2 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ F = [_ A / x ]_ F ) ;;
	step 3 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ B = [_ A / x ]_ B ) ;;
	step 4 : wff = imaeq12d (step 2, step 3) |- ( y = A → ( [_ y / x ]_ F " [_ y / x ]_ B ) = ( [_ A / x ]_ F " [_ A / x ]_ B ) ) ;;
	step 5 : wff = eqeq12d (step 1, step 4) |- ( y = A → ( [_ y / x ]_ ( F " B ) = ( [_ y / x ]_ F " [_ y / x ]_ B ) ↔ [_ A / x ]_ ( F " B ) = ( [_ A / x ]_ F " [_ A / x ]_ B ) ) ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ F ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 9 : wff = nfima (step 7, step 8) |- F/_ x ( [_ y / x ]_ F " [_ y / x ]_ B ) ;;
	step 10 : wff = csbeq1a () |- ( x = y → F = [_ y / x ]_ F ) ;;
	step 11 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 12 : wff = imaeq12d (step 10, step 11) |- ( x = y → ( F " B ) = ( [_ y / x ]_ F " [_ y / x ]_ B ) ) ;;
	step 13 : wff = csbief (step 6, step 9, step 12) |- [_ y / x ]_ ( F " B ) = ( [_ y / x ]_ F " [_ y / x ]_ B ) ;;
	step 14 : wff = vtoclg (step 5, step 13) |- ( A ∈ C → [_ A / x ]_ ( F " B ) = ( [_ A / x ]_ F " [_ A / x ]_ B ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Move class substitution in and out of the image of a function.  (This is
     ~ csbima12g with a shortened proof, shortened by Alan Sare, 10-Nov-2012.)
     The proof is derived from the virtual deduction proof ~ csbima12gALTVD .
     Although the proof is shorter, the total number of steps of all theorems
     used in the proof is probably longer.  (Contributed by NM, 10-Nov-2012.)
     (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem csbima12gALT (x : set, A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( A ∈ C → [_ A / x ]_ ( F " B ) = ( [_ A / x ]_ F " [_ A / x ]_ B ) ) ;;
}

proof of csbima12gALT {
	step 1 : wff = csbrng () |- ( A ∈ C → [_ A / x ]_ ran ( F ↾ B ) = ran [_ A / x ]_ ( F ↾ B ) ) ;;
	step 2 : wff = csbresg () |- ( A ∈ C → [_ A / x ]_ ( F ↾ B ) = ( [_ A / x ]_ F ↾ [_ A / x ]_ B ) ) ;;
	step 3 : wff = rneqd (step 2) |- ( A ∈ C → ran [_ A / x ]_ ( F ↾ B ) = ran ( [_ A / x ]_ F ↾ [_ A / x ]_ B ) ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( A ∈ C → [_ A / x ]_ ran ( F ↾ B ) = ran ( [_ A / x ]_ F ↾ [_ A / x ]_ B ) ) ;;
	step 5 : wff = df-ima () |- ( F " B ) = ran ( F ↾ B ) ;;
	step 6 : wff = csbeq2i (step 5) |- [_ A / x ]_ ( F " B ) = [_ A / x ]_ ran ( F ↾ B ) ;;
	step 7 : wff = df-ima () |- ( [_ A / x ]_ F " [_ A / x ]_ B ) = ran ( [_ A / x ]_ F ↾ [_ A / x ]_ B ) ;;
	step 8 : wff = 3eqtr4g (step 4, step 6, step 7) |- ( A ∈ C → [_ A / x ]_ ( F " B ) = ( [_ A / x ]_ F " [_ A / x ]_ B ) ) ;;
	qed prop 1 = step 8 ;;
}

/*The image of the domain of a class is the range of the class.
       (Contributed by NM, 14-Aug-1994.) */

theorem imadmrn (A : class) disjointed(x y A, x y) {
	prop 1 : wff = |- ( A " dom A ) = ran A ;;
}

proof of imadmrn {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = opeldm (step 1, step 2) |- ( 〈 x , y 〉 ∈ A → x ∈ dom A ) ;;
	step 4 : wff = pm4.71i (step 3) |- ( 〈 x , y 〉 ∈ A ↔ ( 〈 x , y 〉 ∈ A ∧ x ∈ dom A ) ) ;;
	step 5 : wff = ancom () |- ( ( 〈 x , y 〉 ∈ A ∧ x ∈ dom A ) ↔ ( x ∈ dom A ∧ 〈 x , y 〉 ∈ A ) ) ;;
	step 6 : wff = bitr2i (step 4, step 5) |- ( ( x ∈ dom A ∧ 〈 x , y 〉 ∈ A ) ↔ 〈 x , y 〉 ∈ A ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ x ( x ∈ dom A ∧ 〈 x , y 〉 ∈ A ) ↔ ∃ x 〈 x , y 〉 ∈ A ) ;;
	step 8 : wff = abbii (step 7) |- { y | ∃ x ( x ∈ dom A ∧ 〈 x , y 〉 ∈ A ) } = { y | ∃ x 〈 x , y 〉 ∈ A } ;;
	step 9 : wff = dfima3 () |- ( A " dom A ) = { y | ∃ x ( x ∈ dom A ∧ 〈 x , y 〉 ∈ A ) } ;;
	step 10 : wff = dfrn3 () |- ran A = { y | ∃ x 〈 x , y 〉 ∈ A } ;;
	step 11 : wff = 3eqtr4i (step 8, step 9, step 10) |- ( A " dom A ) = ran A ;;
	qed prop 1 = step 11 ;;
}

/*The image of a class is a subset of its range.  Theorem 3.16(xi) of
       [Monk1] p. 39.  (Contributed by NM, 31-Mar-1995.) */

theorem imassrn (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A " B ) ⊆ ran A ;;
}

proof of imassrn {
	var x : set, y : set;;
	step 1 : wff = simpr () |- ( ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) → 〈 x , y 〉 ∈ A ) ;;
	step 2 : wff = eximi (step 1) |- ( ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) → ∃ x 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = ss2abi (step 2) |- { y | ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) } ⊆ { y | ∃ x 〈 x , y 〉 ∈ A } ;;
	step 4 : wff = dfima3 () |- ( A " B ) = { y | ∃ x ( x ∈ B ∧ 〈 x , y 〉 ∈ A ) } ;;
	step 5 : wff = dfrn3 () |- ran A = { y | ∃ x 〈 x , y 〉 ∈ A } ;;
	step 6 : wff = 3sstr4i (step 3, step 4, step 5) |- ( A " B ) ⊆ ran A ;;
	qed prop 1 = step 6 ;;
}

/*The image of a set is a set.  Theorem 3.17 of [Monk1] p. 39.  (Contributed
     by NM, 24-Jul-1995.) */

theorem imaexg (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ( A " B ) ∈ _V ) ;;
}

proof of imaexg {
	step 1 : wff = imassrn () |- ( A " B ) ⊆ ran A ;;
	step 2 : wff = rnexg () |- ( A ∈ V → ran A ∈ _V ) ;;
	step 3 : wff = ssexg () |- ( ( ( A " B ) ⊆ ran A ∧ ran A ∈ _V ) → ( A " B ) ∈ _V ) ;;
	step 4 : wff = sylancr (step 1, step 2, step 3) |- ( A ∈ V → ( A " B ) ∈ _V ) ;;
	qed prop 1 = step 4 ;;
}

/*Image under the identity relation.  Theorem 3.16(viii) of [Monk1]
       p. 38.  (Contributed by NM, 30-Apr-1998.) */

theorem imai (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( _I " A ) = A ;;
}

proof of imai {
	var x : set, y : set;;
	step 1 : wff = dfima3 () |- ( _I " A ) = { y | ∃ x ( x ∈ A ∧ 〈 x , y 〉 ∈ _I ) } ;;
	step 2 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = ideq (step 3) |- ( x _I y ↔ x = y ) ;;
	step 5 : wff = bitr3i (step 2, step 4) |- ( 〈 x , y 〉 ∈ _I ↔ x = y ) ;;
	step 6 : wff = anbi2i (step 5) |- ( ( x ∈ A ∧ 〈 x , y 〉 ∈ _I ) ↔ ( x ∈ A ∧ x = y ) ) ;;
	step 7 : wff = ancom () |- ( ( x ∈ A ∧ x = y ) ↔ ( x = y ∧ x ∈ A ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ( x ∈ A ∧ 〈 x , y 〉 ∈ _I ) ↔ ( x = y ∧ x ∈ A ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ x ( x ∈ A ∧ 〈 x , y 〉 ∈ _I ) ↔ ∃ x ( x = y ∧ x ∈ A ) ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 12 : wff = ceqsexv (step 10, step 11) |- ( ∃ x ( x = y ∧ x ∈ A ) ↔ y ∈ A ) ;;
	step 13 : wff = bitri (step 9, step 12) |- ( ∃ x ( x ∈ A ∧ 〈 x , y 〉 ∈ _I ) ↔ y ∈ A ) ;;
	step 14 : wff = abbii (step 13) |- { y | ∃ x ( x ∈ A ∧ 〈 x , y 〉 ∈ _I ) } = { y | y ∈ A } ;;
	step 15 : wff = abid2 () |- { y | y ∈ A } = A ;;
	step 16 : wff = 3eqtri (step 1, step 14, step 15) |- ( _I " A ) = A ;;
	qed prop 1 = step 16 ;;
}

/*The range of the restricted identity function.  (Contributed by NM,
     27-Aug-2004.) */

theorem rnresi (A : class)  {
	prop 1 : wff = |- ran ( _I ↾ A ) = A ;;
}

proof of rnresi {
	step 1 : wff = df-ima () |- ( _I " A ) = ran ( _I ↾ A ) ;;
	step 2 : wff = imai () |- ( _I " A ) = A ;;
	step 3 : wff = eqtr3i (step 1, step 2) |- ran ( _I ↾ A ) = A ;;
	qed prop 1 = step 3 ;;
}

/*The image of a restriction of the identity function.  (Contributed by FL,
     31-Dec-2006.) */

theorem resiima (A : class, B : class)  {
	prop 1 : wff = |- ( B ⊆ A → ( ( _I ↾ A ) " B ) = B ) ;;
}

proof of resiima {
	step 1 : wff = df-ima () |- ( ( _I ↾ A ) " B ) = ran ( ( _I ↾ A ) ↾ B ) ;;
	step 2 : wff = a1i (step 1) |- ( B ⊆ A → ( ( _I ↾ A ) " B ) = ran ( ( _I ↾ A ) ↾ B ) ) ;;
	step 3 : wff = resabs1 () |- ( B ⊆ A → ( ( _I ↾ A ) ↾ B ) = ( _I ↾ B ) ) ;;
	step 4 : wff = rneqd (step 3) |- ( B ⊆ A → ran ( ( _I ↾ A ) ↾ B ) = ran ( _I ↾ B ) ) ;;
	step 5 : wff = rnresi () |- ran ( _I ↾ B ) = B ;;
	step 6 : wff = a1i (step 5) |- ( B ⊆ A → ran ( _I ↾ B ) = B ) ;;
	step 7 : wff = 3eqtrd (step 2, step 4, step 6) |- ( B ⊆ A → ( ( _I ↾ A ) " B ) = B ) ;;
	qed prop 1 = step 7 ;;
}

/*Image of the empty set.  Theorem 3.16(ii) of [Monk1] p. 38.  (Contributed
     by NM, 20-May-1998.) */

theorem ima0 (A : class)  {
	prop 1 : wff = |- ( A " ∅ ) = ∅ ;;
}

proof of ima0 {
	step 1 : wff = df-ima () |- ( A " ∅ ) = ran ( A ↾ ∅ ) ;;
	step 2 : wff = res0 () |- ( A ↾ ∅ ) = ∅ ;;
	step 3 : wff = rneqi (step 2) |- ran ( A ↾ ∅ ) = ran ∅ ;;
	step 4 : wff = rn0 () |- ran ∅ = ∅ ;;
	step 5 : wff = 3eqtri (step 1, step 3, step 4) |- ( A " ∅ ) = ∅ ;;
	qed prop 1 = step 5 ;;
}

/*Image under the empty relation.  (Contributed by FL, 11-Jan-2007.) */

theorem 0ima (A : class)  {
	prop 1 : wff = |- ( ∅ " A ) = ∅ ;;
}

proof of 0ima {
	step 1 : wff = imassrn () |- ( ∅ " A ) ⊆ ran ∅ ;;
	step 2 : wff = rn0 () |- ran ∅ = ∅ ;;
	step 3 : wff = sseqtri (step 1, step 2) |- ( ∅ " A ) ⊆ ∅ ;;
	step 4 : wff = 0ss () |- ∅ ⊆ ( ∅ " A ) ;;
	step 5 : wff = eqssi (step 3, step 4) |- ( ∅ " A ) = ∅ ;;
	qed prop 1 = step 5 ;;
}

/*A class whose image under another is empty is disjoint with the other's
     domain.  (Contributed by FL, 24-Jan-2007.) */

theorem imadisj (A : class, B : class)  {
	prop 1 : wff = |- ( ( A " B ) = ∅ ↔ ( dom A ∩ B ) = ∅ ) ;;
}

proof of imadisj {
	step 1 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 2 : wff = eqeq1i (step 1) |- ( ( A " B ) = ∅ ↔ ran ( A ↾ B ) = ∅ ) ;;
	step 3 : wff = dm0rn0 () |- ( dom ( A ↾ B ) = ∅ ↔ ran ( A ↾ B ) = ∅ ) ;;
	step 4 : wff = dmres () |- dom ( A ↾ B ) = ( B ∩ dom A ) ;;
	step 5 : wff = incom () |- ( B ∩ dom A ) = ( dom A ∩ B ) ;;
	step 6 : wff = eqtri (step 4, step 5) |- dom ( A ↾ B ) = ( dom A ∩ B ) ;;
	step 7 : wff = eqeq1i (step 6) |- ( dom ( A ↾ B ) = ∅ ↔ ( dom A ∩ B ) = ∅ ) ;;
	step 8 : wff = 3bitr2i (step 2, step 3, step 7) |- ( ( A " B ) = ∅ ↔ ( dom A ∩ B ) = ∅ ) ;;
	qed prop 1 = step 8 ;;
}

/*A preimage under any class is included in the domain of the class.
     (Contributed by FL, 29-Jan-2007.) */

theorem cnvimass (A : class, B : class)  {
	prop 1 : wff = |- ( ⁻¹ A " B ) ⊆ dom A ;;
}

proof of cnvimass {
	step 1 : wff = imassrn () |- ( ⁻¹ A " B ) ⊆ ran ⁻¹ A ;;
	step 2 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 3 : wff = sseqtr4i (step 1, step 2) |- ( ⁻¹ A " B ) ⊆ dom A ;;
	qed prop 1 = step 3 ;;
}

/*The preimage of the range of a class is the domain of the class.
     (Contributed by Jeff Hankins, 15-Jul-2009.) */

theorem cnvimarndm (A : class)  {
	prop 1 : wff = |- ( ⁻¹ A " ran A ) = dom A ;;
}

proof of cnvimarndm {
	step 1 : wff = imadmrn () |- ( ⁻¹ A " dom ⁻¹ A ) = ran ⁻¹ A ;;
	step 2 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 3 : wff = imaeq2i (step 2) |- ( ⁻¹ A " ran A ) = ( ⁻¹ A " dom ⁻¹ A ) ;;
	step 4 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 5 : wff = 3eqtr4i (step 1, step 3, step 4) |- ( ⁻¹ A " ran A ) = dom A ;;
	qed prop 1 = step 5 ;;
}

/*The image of a singleton.  (Contributed by NM, 8-May-2005.) */

theorem imasng (y : set, A : class, B : class, R : class) disjointed(x y A, x B, x y R) {
	prop 1 : wff = |- ( A ∈ B → ( R " { A } ) = { y | A R y } ) ;;
}

proof of imasng {
	var x : set;;
	step 1 : wff = elex () |- ( A ∈ B → A ∈ _V ) ;;
	step 2 : wff = dfima2 () |- ( R " { A } ) = { y | ∃ x ∈ { A } x R y } ;;
	step 3 : wff = breq1 () |- ( x = A → ( x R y ↔ A R y ) ) ;;
	step 4 : wff = rexsng (step 3) |- ( A ∈ _V → ( ∃ x ∈ { A } x R y ↔ A R y ) ) ;;
	step 5 : wff = abbidv (step 4) |- ( A ∈ _V → { y | ∃ x ∈ { A } x R y } = { y | A R y } ) ;;
	step 6 : wff = syl5eq (step 2, step 5) |- ( A ∈ _V → ( R " { A } ) = { y | A R y } ) ;;
	step 7 : wff = syl (step 1, step 6) |- ( A ∈ B → ( R " { A } ) = { y | A R y } ) ;;
	qed prop 1 = step 7 ;;
}

/*The image of a singleton.  (Contributed by NM, 20-May-1998.) */

theorem relimasn (y : set, A : class, R : class) disjointed(y A, y R) {
	prop 1 : wff = |- ( Rel R → ( R " { A } ) = { y | A R y } ) ;;
}

proof of relimasn {
	step 1 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 2 : wff = imaeq2 () |- ( { A } = ∅ → ( R " { A } ) = ( R " ∅ ) ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( ¬ A ∈ _V → ( R " { A } ) = ( R " ∅ ) ) ;;
	step 4 : wff = ima0 () |- ( R " ∅ ) = ∅ ;;
	step 5 : wff = syl6eq (step 3, step 4) |- ( ¬ A ∈ _V → ( R " { A } ) = ∅ ) ;;
	step 6 : wff = adantl (step 5) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ( R " { A } ) = ∅ ) ;;
	step 7 : wff = brrelex () |- ( ( Rel R ∧ A R y ) → A ∈ _V ) ;;
	step 8 : wff = ex (step 7) |- ( Rel R → ( A R y → A ∈ _V ) ) ;;
	step 9 : wff = con3and (step 8) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ¬ A R y ) ;;
	step 10 : wff = nexdv (step 9) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ¬ ∃ y A R y ) ;;
	step 11 : wff = abn0 () |- ( { y | A R y } ≠ ∅ ↔ ∃ y A R y ) ;;
	step 12 : wff = necon1bbii (step 11) |- ( ¬ ∃ y A R y ↔ { y | A R y } = ∅ ) ;;
	step 13 : wff = sylib (step 10, step 12) |- ( ( Rel R ∧ ¬ A ∈ _V ) → { y | A R y } = ∅ ) ;;
	step 14 : wff = eqtr4d (step 6, step 13) |- ( ( Rel R ∧ ¬ A ∈ _V ) → ( R " { A } ) = { y | A R y } ) ;;
	step 15 : wff = ex (step 14) |- ( Rel R → ( ¬ A ∈ _V → ( R " { A } ) = { y | A R y } ) ) ;;
	step 16 : wff = imasng () |- ( A ∈ _V → ( R " { A } ) = { y | A R y } ) ;;
	step 17 : wff = pm2.61d2 (step 15, step 16) |- ( Rel R → ( R " { A } ) = { y | A R y } ) ;;
	qed prop 1 = step 17 ;;
}

/*Elementhood in the image of a singleton.  (Contributed by Mario
       Carneiro, 3-Nov-2015.) */

theorem elrelimasn (A : class, B : class, R : class) disjointed(x A, x B, x R) {
	prop 1 : wff = |- ( Rel R → ( B ∈ ( R " { A } ) ↔ A R B ) ) ;;
}

proof of elrelimasn {
	var x : set;;
	step 1 : wff = relimasn () |- ( Rel R → ( R " { A } ) = { x | A R x } ) ;;
	step 2 : wff = eleq2d (step 1) |- ( Rel R → ( B ∈ ( R " { A } ) ↔ B ∈ { x | A R x } ) ) ;;
	step 3 : wff = brrelex2 () |- ( ( Rel R ∧ A R B ) → B ∈ _V ) ;;
	step 4 : wff = ex (step 3) |- ( Rel R → ( A R B → B ∈ _V ) ) ;;
	step 5 : wff = breq2 () |- ( x = B → ( A R x ↔ A R B ) ) ;;
	step 6 : wff = elab3g (step 5) |- ( ( A R B → B ∈ _V ) → ( B ∈ { x | A R x } ↔ A R B ) ) ;;
	step 7 : wff = syl (step 4, step 6) |- ( Rel R → ( B ∈ { x | A R x } ↔ A R B ) ) ;;
	step 8 : wff = bitrd (step 2, step 7) |- ( Rel R → ( B ∈ ( R " { A } ) ↔ A R B ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Membership in an image of a singleton.  (Contributed by NM,
       15-Mar-2004.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem elimasn (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ ( A " { B } ) ↔ 〈 B , C 〉 ∈ A ) ;;
}

proof of elimasn {
	var x : set;;
	step 1 : wff = breq2 () |- ( x = C → ( B A x ↔ B A C ) ) ;;
	step 2 : wff = imasng () |- ( B ∈ _V → ( A " { B } ) = { x | B A x } ) ;;
	step 3 : wff = ax-mp (hyp 1, step 2) |- ( A " { B } ) = { x | B A x } ;;
	step 4 : wff = elab2 (hyp 2, step 1, step 3) |- ( C ∈ ( A " { B } ) ↔ B A C ) ;;
	step 5 : wff = df-br () |- ( B A C ↔ 〈 B , C 〉 ∈ A ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( C ∈ ( A " { B } ) ↔ 〈 B , C 〉 ∈ A ) ;;
	qed prop 1 = step 6 ;;
}

/*Membership in an image of a singleton.  (Contributed by Raph Levien,
       21-Oct-2006.) */

theorem elimasng (A : class, B : class, C : class, V : class, W : class) disjointed(A y z, B y z, C y z) {
	prop 1 : wff = |- ( ( B ∈ V ∧ C ∈ W ) → ( C ∈ ( A " { B } ) ↔ 〈 B , C 〉 ∈ A ) ) ;;
}

proof of elimasng {
	var y : set, z : set;;
	step 1 : wff = sneq () |- ( y = B → { y } = { B } ) ;;
	step 2 : wff = imaeq2d (step 1) |- ( y = B → ( A " { y } ) = ( A " { B } ) ) ;;
	step 3 : wff = eleq2d (step 2) |- ( y = B → ( z ∈ ( A " { y } ) ↔ z ∈ ( A " { B } ) ) ) ;;
	step 4 : wff = opeq1 () |- ( y = B → 〈 y , z 〉 = 〈 B , z 〉 ) ;;
	step 5 : wff = eleq1d (step 4) |- ( y = B → ( 〈 y , z 〉 ∈ A ↔ 〈 B , z 〉 ∈ A ) ) ;;
	step 6 : wff = bibi12d (step 3, step 5) |- ( y = B → ( ( z ∈ ( A " { y } ) ↔ 〈 y , z 〉 ∈ A ) ↔ ( z ∈ ( A " { B } ) ↔ 〈 B , z 〉 ∈ A ) ) ) ;;
	step 7 : wff = eleq1 () |- ( z = C → ( z ∈ ( A " { B } ) ↔ C ∈ ( A " { B } ) ) ) ;;
	step 8 : wff = opeq2 () |- ( z = C → 〈 B , z 〉 = 〈 B , C 〉 ) ;;
	step 9 : wff = eleq1d (step 8) |- ( z = C → ( 〈 B , z 〉 ∈ A ↔ 〈 B , C 〉 ∈ A ) ) ;;
	step 10 : wff = bibi12d (step 7, step 9) |- ( z = C → ( ( z ∈ ( A " { B } ) ↔ 〈 B , z 〉 ∈ A ) ↔ ( C ∈ ( A " { B } ) ↔ 〈 B , C 〉 ∈ A ) ) ) ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = vex () |- z ∈ _V ;;
	step 13 : wff = elimasn (step 11, step 12) |- ( z ∈ ( A " { y } ) ↔ 〈 y , z 〉 ∈ A ) ;;
	step 14 : wff = vtocl2g (step 6, step 10, step 13) |- ( ( B ∈ V ∧ C ∈ W ) → ( C ∈ ( A " { B } ) ↔ 〈 B , C 〉 ∈ A ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Membership in an image of a singleton.  (Contributed by NM,
     5-Aug-2010.) */

theorem elimasni (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( C ∈ ( A " { B } ) → B A C ) ;;
}

proof of elimasni {
	step 1 : wff = noel () |- ¬ C ∈ ∅ ;;
	step 2 : wff = snprc () |- ( ¬ B ∈ _V ↔ { B } = ∅ ) ;;
	step 3 : wff = biimpi (step 2) |- ( ¬ B ∈ _V → { B } = ∅ ) ;;
	step 4 : wff = imaeq2d (step 3) |- ( ¬ B ∈ _V → ( A " { B } ) = ( A " ∅ ) ) ;;
	step 5 : wff = ima0 () |- ( A " ∅ ) = ∅ ;;
	step 6 : wff = syl6eq (step 4, step 5) |- ( ¬ B ∈ _V → ( A " { B } ) = ∅ ) ;;
	step 7 : wff = eleq2d (step 6) |- ( ¬ B ∈ _V → ( C ∈ ( A " { B } ) ↔ C ∈ ∅ ) ) ;;
	step 8 : wff = mtbiri (step 1, step 7) |- ( ¬ B ∈ _V → ¬ C ∈ ( A " { B } ) ) ;;
	step 9 : wff = con4i (step 8) |- ( C ∈ ( A " { B } ) → B ∈ _V ) ;;
	step 10 : wff = elex () |- ( C ∈ ( A " { B } ) → C ∈ _V ) ;;
	step 11 : wff = jca (step 9, step 10) |- ( C ∈ ( A " { B } ) → ( B ∈ _V ∧ C ∈ _V ) ) ;;
	step 12 : wff = elimasng () |- ( ( B ∈ _V ∧ C ∈ _V ) → ( C ∈ ( A " { B } ) ↔ 〈 B , C 〉 ∈ A ) ) ;;
	step 13 : wff = df-br () |- ( B A C ↔ 〈 B , C 〉 ∈ A ) ;;
	step 14 : wff = syl6bbr (step 12, step 13) |- ( ( B ∈ _V ∧ C ∈ _V ) → ( C ∈ ( A " { B } ) ↔ B A C ) ) ;;
	step 15 : wff = biimpd (step 14) |- ( ( B ∈ _V ∧ C ∈ _V ) → ( C ∈ ( A " { B } ) → B A C ) ) ;;
	step 16 : wff = mpcom (step 11, step 15) |- ( C ∈ ( A " { B } ) → B A C ) ;;
	qed prop 1 = step 16 ;;
}

/*Two ways to express the class of unique-valued arguments of ` F ` ,
       which is the same as the domain of ` F ` whenever ` F ` is a function.
       The left-hand side of the equality is from Definition 10.2 of [Quine]
       p. 65.  Quine uses the notation "arg ` F ` " for this class (for which
       we have no separate notation).  Observe the resemblance to the
       alternative definition ~ dffv4 of function value, which is based on the
       idea in Quine's definition.  (Contributed by NM, 8-May-2005.) */

theorem args (x : set, y : set, F : class) disjointed(y F, x y) {
	prop 1 : wff = |- { x | ∃ y ( F " { x } ) = { y } } = { x | ∃! y x F y } ;;
}

proof of args {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = imasng () |- ( x ∈ _V → ( F " { x } ) = { y | x F y } ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( F " { x } ) = { y | x F y } ;;
	step 4 : wff = eqeq1i (step 3) |- ( ( F " { x } ) = { y } ↔ { y | x F y } = { y } ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ( F " { x } ) = { y } ↔ ∃ y { y | x F y } = { y } ) ;;
	step 6 : wff = euabsn () |- ( ∃! y x F y ↔ ∃ y { y | x F y } = { y } ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ∃ y ( F " { x } ) = { y } ↔ ∃! y x F y ) ;;
	step 8 : wff = abbii (step 7) |- { x | ∃ y ( F " { x } ) = { y } } = { x | ∃! y x F y } ;;
	qed prop 1 = step 8 ;;
}

/*Membership in an initial segment.  The idiom ` ( ``' A " { B } ) ` ,
       meaning ` { x | x A B } ` , is used to specify an initial segment in
       (for example) Definition 6.21 of [TakeutiZaring] p. 30.  (Contributed by
       NM, 28-Apr-2004.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem eliniseg (A : class, B : class, C : class, V : class) disjointed(A, B, C) {
	hyp 1 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( B ∈ V → ( C ∈ ( ⁻¹ A " { B } ) ↔ C A B ) ) ;;
}

proof of eliniseg {
	step 1 : wff = elimasng () |- ( ( B ∈ V ∧ C ∈ _V ) → ( C ∈ ( ⁻¹ A " { B } ) ↔ 〈 B , C 〉 ∈ ⁻¹ A ) ) ;;
	step 2 : wff = df-br () |- ( B ⁻¹ A C ↔ 〈 B , C 〉 ∈ ⁻¹ A ) ;;
	step 3 : wff = syl6bbr (step 1, step 2) |- ( ( B ∈ V ∧ C ∈ _V ) → ( C ∈ ( ⁻¹ A " { B } ) ↔ B ⁻¹ A C ) ) ;;
	step 4 : wff = brcnvg () |- ( ( B ∈ V ∧ C ∈ _V ) → ( B ⁻¹ A C ↔ C A B ) ) ;;
	step 5 : wff = bitrd (step 3, step 4) |- ( ( B ∈ V ∧ C ∈ _V ) → ( C ∈ ( ⁻¹ A " { B } ) ↔ C A B ) ) ;;
	step 6 : wff = mpan2 (hyp 1, step 5) |- ( B ∈ V → ( C ∈ ( ⁻¹ A " { B } ) ↔ C A B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Any set is equal to its preimage under the converse epsilon relation.
       (Contributed by Mario Carneiro, 9-Mar-2013.) */

theorem epini (A : class) disjointed(A x) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ⁻¹ 𝛜 " { A } ) = A ;;
}

proof of epini {
	var x : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = eliniseg (step 1) |- ( A ∈ _V → ( x ∈ ( ⁻¹ 𝛜 " { A } ) ↔ x 𝛜 A ) ) ;;
	step 3 : wff = ax-mp (hyp 1, step 2) |- ( x ∈ ( ⁻¹ 𝛜 " { A } ) ↔ x 𝛜 A ) ;;
	step 4 : wff = epelc (hyp 1) |- ( x 𝛜 A ↔ x ∈ A ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( x ∈ ( ⁻¹ 𝛜 " { A } ) ↔ x ∈ A ) ;;
	step 6 : wff = eqriv (step 5) |- ( ⁻¹ 𝛜 " { A } ) = A ;;
	qed prop 1 = step 6 ;;
}

/*An idiom that signifies an initial segment of an ordering, used, for
       example, in Definition 6.21 of [TakeutiZaring] p. 30.  (Contributed by
       NM, 28-Apr-2004.) */

theorem iniseg (x : set, A : class, B : class, V : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( B ∈ V → ( ⁻¹ A " { B } ) = { x | x A B } ) ;;
}

proof of iniseg {
	step 1 : wff = elex () |- ( B ∈ V → B ∈ _V ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = eliniseg (step 2) |- ( B ∈ _V → ( x ∈ ( ⁻¹ A " { B } ) ↔ x A B ) ) ;;
	step 4 : wff = abbi2dv (step 3) |- ( B ∈ _V → ( ⁻¹ A " { B } ) = { x | x A B } ) ;;
	step 5 : wff = syl (step 1, step 4) |- ( B ∈ V → ( ⁻¹ A " { B } ) = { x | x A B } ) ;;
	qed prop 1 = step 5 ;;
}

/*Alternate definition of well-founded relation.  Definition 6.21 of
       [TakeutiZaring] p. 30.  (Contributed by NM, 23-Apr-2004.)  (Revised by
       Mario Carneiro, 23-Jun-2015.) */

theorem dffr3 (x : set, y : set, A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( R Fr A ↔ ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ;;
}

proof of dffr3 {
	var z : set;;
	step 1 : wff = dffr2 () |- ( R Fr A ↔ ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x { z ∈ x | z R y } = ∅ ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = iniseg () |- ( y ∈ _V → ( ⁻¹ R " { y } ) = { z | z R y } ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ⁻¹ R " { y } ) = { z | z R y } ;;
	step 5 : wff = ineq2i (step 4) |- ( x ∩ ( ⁻¹ R " { y } ) ) = ( x ∩ { z | z R y } ) ;;
	step 6 : wff = dfrab3 () |- { z ∈ x | z R y } = ( x ∩ { z | z R y } ) ;;
	step 7 : wff = eqtr4i (step 5, step 6) |- ( x ∩ ( ⁻¹ R " { y } ) ) = { z ∈ x | z R y } ;;
	step 8 : wff = eqeq1i (step 7) |- ( ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ↔ { z ∈ x | z R y } = ∅ ) ;;
	step 9 : wff = rexbii (step 8) |- ( ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ↔ ∃ y ∈ x { z ∈ x | z R y } = ∅ ) ;;
	step 10 : wff = imbi2i (step 9) |- ( ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ↔ ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x { z ∈ x | z R y } = ∅ ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ↔ ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x { z ∈ x | z R y } = ∅ ) ) ;;
	step 12 : wff = bitr4i (step 1, step 11) |- ( R Fr A ↔ ∀ x ( ( x ⊆ A ∧ x ≠ ∅ ) → ∃ y ∈ x ( x ∩ ( ⁻¹ R " { y } ) ) = ∅ ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Alternate definition of set-like relation.  (Contributed by Mario
       Carneiro, 23-Jun-2015.) */

theorem dfse2 (x : set, A : class, R : class) disjointed(x y A, x y R, x) {
	prop 1 : wff = |- ( R Se A ↔ ∀ x ∈ A ( A ∩ ( ⁻¹ R " { x } ) ) ∈ _V ) ;;
}

proof of dfse2 {
	var y : set;;
	step 1 : wff = df-se () |- ( R Se A ↔ ∀ x ∈ A { y ∈ A | y R x } ∈ _V ) ;;
	step 2 : wff = dfrab3 () |- { y ∈ A | y R x } = ( A ∩ { y | y R x } ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = iniseg () |- ( x ∈ _V → ( ⁻¹ R " { x } ) = { y | y R x } ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- ( ⁻¹ R " { x } ) = { y | y R x } ;;
	step 6 : wff = ineq2i (step 5) |- ( A ∩ ( ⁻¹ R " { x } ) ) = ( A ∩ { y | y R x } ) ;;
	step 7 : wff = eqtr4i (step 2, step 6) |- { y ∈ A | y R x } = ( A ∩ ( ⁻¹ R " { x } ) ) ;;
	step 8 : wff = eleq1i (step 7) |- ( { y ∈ A | y R x } ∈ _V ↔ ( A ∩ ( ⁻¹ R " { x } ) ) ∈ _V ) ;;
	step 9 : wff = ralbii (step 8) |- ( ∀ x ∈ A { y ∈ A | y R x } ∈ _V ↔ ∀ x ∈ A ( A ∩ ( ⁻¹ R " { x } ) ) ∈ _V ) ;;
	step 10 : wff = bitri (step 1, step 9) |- ( R Se A ↔ ∀ x ∈ A ( A ∩ ( ⁻¹ R " { x } ) ) ∈ _V ) ;;
	qed prop 1 = step 10 ;;
}

/*Any set relation is set-like.  (Contributed by Mario Carneiro,
       22-Jun-2015.) */

theorem exse2 (A : class, R : class, V : class) disjointed(x y A, x y R, x V) {
	prop 1 : wff = |- ( R ∈ V → R Se A ) ;;
}

proof of exse2 {
	var x : set, y : set;;
	step 1 : wff = df-rab () |- { y ∈ A | y R x } = { y | ( y ∈ A ∧ y R x ) } ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = breldm (step 2, step 3) |- ( y R x → y ∈ dom R ) ;;
	step 5 : wff = adantl (step 4) |- ( ( y ∈ A ∧ y R x ) → y ∈ dom R ) ;;
	step 6 : wff = abssi (step 5) |- { y | ( y ∈ A ∧ y R x ) } ⊆ dom R ;;
	step 7 : wff = eqsstri (step 1, step 6) |- { y ∈ A | y R x } ⊆ dom R ;;
	step 8 : wff = dmexg () |- ( R ∈ V → dom R ∈ _V ) ;;
	step 9 : wff = ssexg () |- ( ( { y ∈ A | y R x } ⊆ dom R ∧ dom R ∈ _V ) → { y ∈ A | y R x } ∈ _V ) ;;
	step 10 : wff = sylancr (step 7, step 8, step 9) |- ( R ∈ V → { y ∈ A | y R x } ∈ _V ) ;;
	step 11 : wff = ralrimivw (step 10) |- ( R ∈ V → ∀ x ∈ A { y ∈ A | y R x } ∈ _V ) ;;
	step 12 : wff = df-se () |- ( R Se A ↔ ∀ x ∈ A { y ∈ A | y R x } ∈ _V ) ;;
	step 13 : wff = sylibr (step 11, step 12) |- ( R ∈ V → R Se A ) ;;
	qed prop 1 = step 13 ;;
}

/*Subset theorem for image.  (Contributed by NM, 16-Mar-2004.) */

theorem imass1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( A " C ) ⊆ ( B " C ) ) ;;
}

proof of imass1 {
	step 1 : wff = ssres () |- ( A ⊆ B → ( A ↾ C ) ⊆ ( B ↾ C ) ) ;;
	step 2 : wff = rnss () |- ( ( A ↾ C ) ⊆ ( B ↾ C ) → ran ( A ↾ C ) ⊆ ran ( B ↾ C ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ⊆ B → ran ( A ↾ C ) ⊆ ran ( B ↾ C ) ) ;;
	step 4 : wff = df-ima () |- ( A " C ) = ran ( A ↾ C ) ;;
	step 5 : wff = df-ima () |- ( B " C ) = ran ( B ↾ C ) ;;
	step 6 : wff = 3sstr4g (step 3, step 4, step 5) |- ( A ⊆ B → ( A " C ) ⊆ ( B " C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Subset theorem for image.  Exercise 22(a) of [Enderton] p. 53.
     (Contributed by NM, 22-Mar-1998.) */

theorem imass2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ⊆ B → ( C " A ) ⊆ ( C " B ) ) ;;
}

proof of imass2 {
	step 1 : wff = ssres2 () |- ( A ⊆ B → ( C ↾ A ) ⊆ ( C ↾ B ) ) ;;
	step 2 : wff = rnss () |- ( ( C ↾ A ) ⊆ ( C ↾ B ) → ran ( C ↾ A ) ⊆ ran ( C ↾ B ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ⊆ B → ran ( C ↾ A ) ⊆ ran ( C ↾ B ) ) ;;
	step 4 : wff = df-ima () |- ( C " A ) = ran ( C ↾ A ) ;;
	step 5 : wff = df-ima () |- ( C " B ) = ran ( C ↾ B ) ;;
	step 6 : wff = 3sstr4g (step 3, step 4, step 5) |- ( A ⊆ B → ( C " A ) ⊆ ( C " B ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The image of a singleton outside the domain is empty.  (Contributed by NM,
     22-May-1998.) */

theorem ndmima (A : class, B : class)  {
	prop 1 : wff = |- ( ¬ A ∈ dom B → ( B " { A } ) = ∅ ) ;;
}

proof of ndmima {
	step 1 : wff = df-ima () |- ( B " { A } ) = ran ( B ↾ { A } ) ;;
	step 2 : wff = dmres () |- dom ( B ↾ { A } ) = ( { A } ∩ dom B ) ;;
	step 3 : wff = incom () |- ( { A } ∩ dom B ) = ( dom B ∩ { A } ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- dom ( B ↾ { A } ) = ( dom B ∩ { A } ) ;;
	step 5 : wff = disjsn () |- ( ( dom B ∩ { A } ) = ∅ ↔ ¬ A ∈ dom B ) ;;
	step 6 : wff = biimpri (step 5) |- ( ¬ A ∈ dom B → ( dom B ∩ { A } ) = ∅ ) ;;
	step 7 : wff = syl5eq (step 4, step 6) |- ( ¬ A ∈ dom B → dom ( B ↾ { A } ) = ∅ ) ;;
	step 8 : wff = dm0rn0 () |- ( dom ( B ↾ { A } ) = ∅ ↔ ran ( B ↾ { A } ) = ∅ ) ;;
	step 9 : wff = sylib (step 7, step 8) |- ( ¬ A ∈ dom B → ran ( B ↾ { A } ) = ∅ ) ;;
	step 10 : wff = syl5eq (step 1, step 9) |- ( ¬ A ∈ dom B → ( B " { A } ) = ∅ ) ;;
	qed prop 1 = step 10 ;;
}

/*A converse is a relation.  Theorem 12 of [Suppes] p. 62.  (Contributed
       by NM, 29-Oct-1996.) */

theorem relcnv (A : class) disjointed(x y A) {
	prop 1 : wff = |- Rel ⁻¹ A ;;
}

proof of relcnv {
	var x : set, y : set;;
	step 1 : wff = df-cnv () |- ⁻¹ A = { 〈 x , y 〉 | y A x } ;;
	step 2 : wff = relopabi (step 1) |- Rel ⁻¹ A ;;
	qed prop 1 = step 2 ;;
}

/*When ` R ` is a relation, the sethood assumptions on ~ brcnv can be
       omitted.  (Contributed by Mario Carneiro, 28-Apr-2015.) */

theorem relbrcnvg (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( Rel R → ( A ⁻¹ R B ↔ B R A ) ) ;;
}

proof of relbrcnvg {
	step 1 : wff = relcnv () |- Rel ⁻¹ R ;;
	step 2 : wff = brrelex12 () |- ( ( Rel ⁻¹ R ∧ A ⁻¹ R B ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( A ⁻¹ R B → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 4 : wff = a1i (step 3) |- ( Rel R → ( A ⁻¹ R B → ( A ∈ _V ∧ B ∈ _V ) ) ) ;;
	step 5 : wff = brrelex12 () |- ( ( Rel R ∧ B R A ) → ( B ∈ _V ∧ A ∈ _V ) ) ;;
	step 6 : wff = ancomd (step 5) |- ( ( Rel R ∧ B R A ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 7 : wff = ex (step 6) |- ( Rel R → ( B R A → ( A ∈ _V ∧ B ∈ _V ) ) ) ;;
	step 8 : wff = brcnvg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A ⁻¹ R B ↔ B R A ) ) ;;
	step 9 : wff = a1i (step 8) |- ( Rel R → ( ( A ∈ _V ∧ B ∈ _V ) → ( A ⁻¹ R B ↔ B R A ) ) ) ;;
	step 10 : wff = pm5.21ndd (step 4, step 7, step 9) |- ( Rel R → ( A ⁻¹ R B ↔ B R A ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Eliminate the class existence constraint in ~ eliniseg .  (Contributed
       by Mario Carneiro, 5-Dec-2014.)  (Revised by Mario Carneiro,
       17-Nov-2015.) */

theorem eliniseg2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( Rel A → ( C ∈ ( ⁻¹ A " { B } ) ↔ C A B ) ) ;;
}

proof of eliniseg2 {
	step 1 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 2 : wff = elrelimasn () |- ( Rel ⁻¹ A → ( C ∈ ( ⁻¹ A " { B } ) ↔ B ⁻¹ A C ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( C ∈ ( ⁻¹ A " { B } ) ↔ B ⁻¹ A C ) ;;
	step 4 : wff = relbrcnvg () |- ( Rel A → ( B ⁻¹ A C ↔ C A B ) ) ;;
	step 5 : wff = syl5bb (step 3, step 4) |- ( Rel A → ( C ∈ ( ⁻¹ A " { B } ) ↔ C A B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*When ` R ` is a relation, the sethood assumptions on ~ brcnv can be
       omitted.  (Contributed by Mario Carneiro, 28-Apr-2015.) */

theorem relbrcnv (A : class, B : class, R : class)  {
	hyp 1 : wff = |- Rel R ;;
	-----------------------
	prop 1 : wff = |- ( A ⁻¹ R B ↔ B R A ) ;;
}

proof of relbrcnv {
	step 1 : wff = relbrcnvg () |- ( Rel R → ( A ⁻¹ R B ↔ B R A ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ⁻¹ R B ↔ B R A ) ;;
	qed prop 1 = step 2 ;;
}

/*Two ways of saying a relation is transitive.  Definition of transitivity
       in [Schechter] p. 51.  (Contributed by NM, 27-Dec-1996.)  (Proof
       shortened by Andrew Salmon, 27-Aug-2011.) */

theorem cotr (x : set, y : set, z : set, R : class) disjointed(x y, x y, x y z R) {
	prop 1 : wff = |- ( ( R ∘ R ) ⊆ R ↔ ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) ;;
}

proof of cotr {
	step 1 : wff = df-co () |- ( R ∘ R ) = { 〈 x , z 〉 | ∃ y ( x R y ∧ y R z ) } ;;
	step 2 : wff = relopabi (step 1) |- Rel ( R ∘ R ) ;;
	step 3 : wff = ssrel () |- ( Rel ( R ∘ R ) → ( ( R ∘ R ) ⊆ R ↔ ∀ x ∀ z ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ( R ∘ R ) ⊆ R ↔ ∀ x ∀ z ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- z ∈ _V ;;
	step 7 : wff = opelco (step 5, step 6) |- ( 〈 x , z 〉 ∈ ( R ∘ R ) ↔ ∃ y ( x R y ∧ y R z ) ) ;;
	step 8 : wff = df-br () |- ( x R z ↔ 〈 x , z 〉 ∈ R ) ;;
	step 9 : wff = bicomi (step 8) |- ( 〈 x , z 〉 ∈ R ↔ x R z ) ;;
	step 10 : wff = imbi12i (step 7, step 9) |- ( ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ↔ ( ∃ y ( x R y ∧ y R z ) → x R z ) ) ;;
	step 11 : wff = 19.23v () |- ( ∀ y ( ( x R y ∧ y R z ) → x R z ) ↔ ( ∃ y ( x R y ∧ y R z ) → x R z ) ) ;;
	step 12 : wff = bitr4i (step 10, step 11) |- ( ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ↔ ∀ y ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ z ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ↔ ∀ z ∀ y ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 14 : wff = alcom () |- ( ∀ z ∀ y ( ( x R y ∧ y R z ) → x R z ) ↔ ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 15 : wff = bitri (step 13, step 14) |- ( ∀ z ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ↔ ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 16 : wff = albii (step 15) |- ( ∀ x ∀ z ( 〈 x , z 〉 ∈ ( R ∘ R ) → 〈 x , z 〉 ∈ R ) ↔ ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 17 : wff = bitri (step 4, step 16) |- ( ( R ∘ R ) ⊆ R ↔ ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Two ways to state a relation is reflexive.  Adapted from Tarski.
       (Contributed by FL, 15-Jan-2012.)  (Revised by NM, 30-Mar-2016.) */

theorem issref (x : set, A : class, R : class) disjointed(x y z A, x y z, x y z R, x y z, z, z) {
	prop 1 : wff = |- ( ( _I ↾ A ) ⊆ R ↔ ∀ x ∈ A x R x ) ;;
}

proof of issref {
	var y : set, z : set;;
	step 1 : wff = df-ral () |- ( ∀ x ∈ A x R x ↔ ∀ x ( x ∈ A → x R x ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = opelresi () |- ( x ∈ _V → ( 〈 x , x 〉 ∈ ( _I ↾ A ) ↔ x ∈ A ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( 〈 x , x 〉 ∈ ( _I ↾ A ) ↔ x ∈ A ) ;;
	step 5 : wff = df-br () |- ( x R x ↔ 〈 x , x 〉 ∈ R ) ;;
	step 6 : wff = bicomi (step 5) |- ( 〈 x , x 〉 ∈ R ↔ x R x ) ;;
	step 7 : wff = imbi12i (step 4, step 6) |- ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ( x ∈ A → x R x ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ∀ x ( x ∈ A → x R x ) ) ;;
	step 9 : wff = ralidm () |- ( ∀ x ∈ _V ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ;;
	step 10 : wff = ralv () |- ( ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ;;
	step 11 : wff = bitri (step 9, step 10) |- ( ∀ x ∈ _V ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ;;
	step 12 : wff = df-ral () |- ( ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ∀ x ( x ∈ _V → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = pm2.27 () |- ( x ∈ _V → ( ( x ∈ _V → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ) ;;
	step 15 : wff = opelresg () |- ( z ∈ _V → ( 〈 x , z 〉 ∈ ( _I ↾ A ) ↔ ( 〈 x , z 〉 ∈ _I ∧ x ∈ A ) ) ) ;;
	step 16 : wff = df-br () |- ( x _I z ↔ 〈 x , z 〉 ∈ _I ) ;;
	step 17 : wff = vex () |- z ∈ _V ;;
	step 18 : wff = ideq (step 17) |- ( x _I z ↔ x = z ) ;;
	step 19 : wff = opelresi () |- ( x ∈ A → ( 〈 x , x 〉 ∈ ( _I ↾ A ) ↔ x ∈ A ) ) ;;
	step 20 : wff = pm2.27 () |- ( 〈 x , x 〉 ∈ ( _I ↾ A ) → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → 〈 x , x 〉 ∈ R ) ) ;;
	step 21 : wff = opeq2 () |- ( x = z → 〈 x , x 〉 = 〈 x , z 〉 ) ;;
	step 22 : wff = eleq1d (step 21) |- ( x = z → ( 〈 x , x 〉 ∈ R ↔ 〈 x , z 〉 ∈ R ) ) ;;
	step 23 : wff = biimpcd (step 22) |- ( 〈 x , x 〉 ∈ R → ( x = z → 〈 x , z 〉 ∈ R ) ) ;;
	step 24 : wff = syl6 (step 20, step 23) |- ( 〈 x , x 〉 ∈ ( _I ↾ A ) → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ( x = z → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 25 : wff = syl6bir (step 19, step 24) |- ( x ∈ A → ( x ∈ A → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ( x = z → 〈 x , z 〉 ∈ R ) ) ) ) ;;
	step 26 : wff = pm2.43i (step 25) |- ( x ∈ A → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ( x = z → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 27 : wff = com3r (step 26) |- ( x = z → ( x ∈ A → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 28 : wff = sylbi (step 18, step 27) |- ( x _I z → ( x ∈ A → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 29 : wff = sylbir (step 16, step 28) |- ( 〈 x , z 〉 ∈ _I → ( x ∈ A → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 30 : wff = imp (step 29) |- ( ( 〈 x , z 〉 ∈ _I ∧ x ∈ A ) → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 31 : wff = syl6bi (step 15, step 30) |- ( z ∈ _V → ( 〈 x , z 〉 ∈ ( _I ↾ A ) → ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 32 : wff = com3r (step 31) |- ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ( z ∈ _V → ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 33 : wff = ralrimiv (step 32) |- ( ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 34 : wff = syl6 (step 14, step 33) |- ( x ∈ _V → ( ( x ∈ _V → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) → ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 35 : wff = ax-mp (step 13, step 34) |- ( ( x ∈ _V → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) → ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 36 : wff = sps (step 35) |- ( ∀ x ( x ∈ _V → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) → ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 37 : wff = sylbi (step 12, step 36) |- ( ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 38 : wff = ralimi (step 37) |- ( ∀ x ∈ _V ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ∀ x ∈ _V ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 39 : wff = eleq1 () |- ( y = 〈 x , z 〉 → ( y ∈ ( _I ↾ A ) ↔ 〈 x , z 〉 ∈ ( _I ↾ A ) ) ) ;;
	step 40 : wff = eleq1 () |- ( y = 〈 x , z 〉 → ( y ∈ R ↔ 〈 x , z 〉 ∈ R ) ) ;;
	step 41 : wff = imbi12d (step 39, step 40) |- ( y = 〈 x , z 〉 → ( ( y ∈ ( _I ↾ A ) → y ∈ R ) ↔ ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ) ;;
	step 42 : wff = ralxp (step 41) |- ( ∀ y ∈ ( _V × _V ) ( y ∈ ( _I ↾ A ) → y ∈ R ) ↔ ∀ x ∈ _V ∀ z ∈ _V ( 〈 x , z 〉 ∈ ( _I ↾ A ) → 〈 x , z 〉 ∈ R ) ) ;;
	step 43 : wff = sylibr (step 38, step 42) |- ( ∀ x ∈ _V ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ∀ y ∈ ( _V × _V ) ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 44 : wff = df-ral () |- ( ∀ y ∈ ( _V × _V ) ( y ∈ ( _I ↾ A ) → y ∈ R ) ↔ ∀ y ( y ∈ ( _V × _V ) → ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ) ;;
	step 45 : wff = relres () |- Rel ( _I ↾ A ) ;;
	step 46 : wff = df-rel () |- ( Rel ( _I ↾ A ) ↔ ( _I ↾ A ) ⊆ ( _V × _V ) ) ;;
	step 47 : wff = mpbi (step 45, step 46) |- ( _I ↾ A ) ⊆ ( _V × _V ) ;;
	step 48 : wff = sseli (step 47) |- ( y ∈ ( _I ↾ A ) → y ∈ ( _V × _V ) ) ;;
	step 49 : wff = ancri (step 48) |- ( y ∈ ( _I ↾ A ) → ( y ∈ ( _V × _V ) ∧ y ∈ ( _I ↾ A ) ) ) ;;
	step 50 : wff = pm3.31 () |- ( ( y ∈ ( _V × _V ) → ( y ∈ ( _I ↾ A ) → y ∈ R ) ) → ( ( y ∈ ( _V × _V ) ∧ y ∈ ( _I ↾ A ) ) → y ∈ R ) ) ;;
	step 51 : wff = syl5 (step 49, step 50) |- ( ( y ∈ ( _V × _V ) → ( y ∈ ( _I ↾ A ) → y ∈ R ) ) → ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 52 : wff = alimi (step 51) |- ( ∀ y ( y ∈ ( _V × _V ) → ( y ∈ ( _I ↾ A ) → y ∈ R ) ) → ∀ y ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 53 : wff = sylbi (step 44, step 52) |- ( ∀ y ∈ ( _V × _V ) ( y ∈ ( _I ↾ A ) → y ∈ R ) → ∀ y ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 54 : wff = syl (step 43, step 53) |- ( ∀ x ∈ _V ∀ x ∈ _V ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ∀ y ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 55 : wff = sylbir (step 11, step 54) |- ( ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ∀ y ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 56 : wff = dfss2 () |- ( ( _I ↾ A ) ⊆ R ↔ ∀ y ( y ∈ ( _I ↾ A ) → y ∈ R ) ) ;;
	step 57 : wff = sylibr (step 55, step 56) |- ( ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) → ( _I ↾ A ) ⊆ R ) ;;
	step 58 : wff = ssel () |- ( ( _I ↾ A ) ⊆ R → ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ;;
	step 59 : wff = alrimiv (step 58) |- ( ( _I ↾ A ) ⊆ R → ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ) ;;
	step 60 : wff = impbii (step 57, step 59) |- ( ∀ x ( 〈 x , x 〉 ∈ ( _I ↾ A ) → 〈 x , x 〉 ∈ R ) ↔ ( _I ↾ A ) ⊆ R ) ;;
	step 61 : wff = 3bitr2ri (step 1, step 8, step 60) |- ( ( _I ↾ A ) ⊆ R ↔ ∀ x ∈ A x R x ) ;;
	qed prop 1 = step 61 ;;
}

/*Two ways of saying a relation is symmetric.  Similar to definition of
       symmetry in [Schechter] p. 51.  (Contributed by NM, 28-Dec-1996.)
       (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem cnvsym (x : set, y : set, R : class) disjointed(x y, x y, x y R, x y) {
	prop 1 : wff = |- ( ⁻¹ R ⊆ R ↔ ∀ x ∀ y ( x R y → y R x ) ) ;;
}

proof of cnvsym {
	step 1 : wff = alcom () |- ( ∀ y ∀ x ( 〈 y , x 〉 ∈ ⁻¹ R → 〈 y , x 〉 ∈ R ) ↔ ∀ x ∀ y ( 〈 y , x 〉 ∈ ⁻¹ R → 〈 y , x 〉 ∈ R ) ) ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ R ;;
	step 3 : wff = ssrel () |- ( Rel ⁻¹ R → ( ⁻¹ R ⊆ R ↔ ∀ y ∀ x ( 〈 y , x 〉 ∈ ⁻¹ R → 〈 y , x 〉 ∈ R ) ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ⁻¹ R ⊆ R ↔ ∀ y ∀ x ( 〈 y , x 〉 ∈ ⁻¹ R → 〈 y , x 〉 ∈ R ) ) ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = vex () |- x ∈ _V ;;
	step 7 : wff = brcnv (step 5, step 6) |- ( y ⁻¹ R x ↔ x R y ) ;;
	step 8 : wff = df-br () |- ( y ⁻¹ R x ↔ 〈 y , x 〉 ∈ ⁻¹ R ) ;;
	step 9 : wff = bitr3i (step 7, step 8) |- ( x R y ↔ 〈 y , x 〉 ∈ ⁻¹ R ) ;;
	step 10 : wff = df-br () |- ( y R x ↔ 〈 y , x 〉 ∈ R ) ;;
	step 11 : wff = imbi12i (step 9, step 10) |- ( ( x R y → y R x ) ↔ ( 〈 y , x 〉 ∈ ⁻¹ R → 〈 y , x 〉 ∈ R ) ) ;;
	step 12 : wff = 2albii (step 11) |- ( ∀ x ∀ y ( x R y → y R x ) ↔ ∀ x ∀ y ( 〈 y , x 〉 ∈ ⁻¹ R → 〈 y , x 〉 ∈ R ) ) ;;
	step 13 : wff = 3bitr4i (step 1, step 4, step 12) |- ( ⁻¹ R ⊆ R ↔ ∀ x ∀ y ( x R y → y R x ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Two ways of saying a relation is antisymmetric.  Definition of
       antisymmetry in [Schechter] p. 51.  (Contributed by NM, 9-Sep-2004.)
       (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem intasym (x : set, y : set, R : class) disjointed(x y, x y, x y R, x y) {
	prop 1 : wff = |- ( ( R ∩ ⁻¹ R ) ⊆ _I ↔ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
}

proof of intasym {
	step 1 : wff = relcnv () |- Rel ⁻¹ R ;;
	step 2 : wff = relin2 () |- ( Rel ⁻¹ R → Rel ( R ∩ ⁻¹ R ) ) ;;
	step 3 : wff = ssrel () |- ( Rel ( R ∩ ⁻¹ R ) → ( ( R ∩ ⁻¹ R ) ⊆ _I ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) → 〈 x , y 〉 ∈ _I ) ) ) ;;
	step 4 : wff = mp2b (step 1, step 2, step 3) |- ( ( R ∩ ⁻¹ R ) ⊆ _I ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) → 〈 x , y 〉 ∈ _I ) ) ;;
	step 5 : wff = elin () |- ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ ( 〈 x , y 〉 ∈ R ∧ 〈 x , y 〉 ∈ ⁻¹ R ) ) ;;
	step 6 : wff = df-br () |- ( x R y ↔ 〈 x , y 〉 ∈ R ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = brcnv (step 7, step 8) |- ( x ⁻¹ R y ↔ y R x ) ;;
	step 10 : wff = df-br () |- ( x ⁻¹ R y ↔ 〈 x , y 〉 ∈ ⁻¹ R ) ;;
	step 11 : wff = bitr3i (step 9, step 10) |- ( y R x ↔ 〈 x , y 〉 ∈ ⁻¹ R ) ;;
	step 12 : wff = anbi12i (step 6, step 11) |- ( ( x R y ∧ y R x ) ↔ ( 〈 x , y 〉 ∈ R ∧ 〈 x , y 〉 ∈ ⁻¹ R ) ) ;;
	step 13 : wff = bitr4i (step 5, step 12) |- ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ ( x R y ∧ y R x ) ) ;;
	step 14 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = ideq (step 15) |- ( x _I y ↔ x = y ) ;;
	step 17 : wff = bitr3i (step 14, step 16) |- ( 〈 x , y 〉 ∈ _I ↔ x = y ) ;;
	step 18 : wff = imbi12i (step 13, step 17) |- ( ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) → 〈 x , y 〉 ∈ _I ) ↔ ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 19 : wff = 2albii (step 18) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) → 〈 x , y 〉 ∈ _I ) ↔ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 20 : wff = bitri (step 4, step 19) |- ( ( R ∩ ⁻¹ R ) ⊆ _I ↔ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	qed prop 1 = step 20 ;;
}

/*Two ways of saying a relation is antisymmetric and reflexive.
       ` U. U. R ` is the field of a relation by ~ relfld .  (Contributed by
       NM, 6-May-2008.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem asymref (x : set, y : set, R : class) disjointed(x y, x y, x y R, x y) {
	prop 1 : wff = |- ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ;;
}

proof of asymref {
	step 1 : wff = df-br () |- ( x R y ↔ 〈 x , y 〉 ∈ R ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opeluu (step 2, step 3) |- ( 〈 x , y 〉 ∈ R → ( x ∈ ⋃ ⋃ R ∧ y ∈ ⋃ ⋃ R ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( x R y → ( x ∈ ⋃ ⋃ R ∧ y ∈ ⋃ ⋃ R ) ) ;;
	step 6 : wff = simpld (step 5) |- ( x R y → x ∈ ⋃ ⋃ R ) ;;
	step 7 : wff = adantr (step 6) |- ( ( x R y ∧ y R x ) → x ∈ ⋃ ⋃ R ) ;;
	step 8 : wff = pm4.71ri (step 7) |- ( ( x R y ∧ y R x ) ↔ ( x ∈ ⋃ ⋃ R ∧ ( x R y ∧ y R x ) ) ) ;;
	step 9 : wff = bibi1i (step 8) |- ( ( ( x R y ∧ y R x ) ↔ ( x ∈ ⋃ ⋃ R ∧ x = y ) ) ↔ ( ( x ∈ ⋃ ⋃ R ∧ ( x R y ∧ y R x ) ) ↔ ( x ∈ ⋃ ⋃ R ∧ x = y ) ) ) ;;
	step 10 : wff = elin () |- ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ ( 〈 x , y 〉 ∈ R ∧ 〈 x , y 〉 ∈ ⁻¹ R ) ) ;;
	step 11 : wff = df-br () |- ( x R y ↔ 〈 x , y 〉 ∈ R ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = vex () |- y ∈ _V ;;
	step 14 : wff = brcnv (step 12, step 13) |- ( x ⁻¹ R y ↔ y R x ) ;;
	step 15 : wff = df-br () |- ( x ⁻¹ R y ↔ 〈 x , y 〉 ∈ ⁻¹ R ) ;;
	step 16 : wff = bitr3i (step 14, step 15) |- ( y R x ↔ 〈 x , y 〉 ∈ ⁻¹ R ) ;;
	step 17 : wff = anbi12i (step 11, step 16) |- ( ( x R y ∧ y R x ) ↔ ( 〈 x , y 〉 ∈ R ∧ 〈 x , y 〉 ∈ ⁻¹ R ) ) ;;
	step 18 : wff = bitr4i (step 10, step 17) |- ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ ( x R y ∧ y R x ) ) ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = opelres (step 19) |- ( 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ↔ ( 〈 x , y 〉 ∈ _I ∧ x ∈ ⋃ ⋃ R ) ) ;;
	step 21 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 22 : wff = vex () |- y ∈ _V ;;
	step 23 : wff = ideq (step 22) |- ( x _I y ↔ x = y ) ;;
	step 24 : wff = bitr3i (step 21, step 23) |- ( 〈 x , y 〉 ∈ _I ↔ x = y ) ;;
	step 25 : wff = anbi2ci (step 24) |- ( ( 〈 x , y 〉 ∈ _I ∧ x ∈ ⋃ ⋃ R ) ↔ ( x ∈ ⋃ ⋃ R ∧ x = y ) ) ;;
	step 26 : wff = bitri (step 20, step 25) |- ( 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ↔ ( x ∈ ⋃ ⋃ R ∧ x = y ) ) ;;
	step 27 : wff = bibi12i (step 18, step 26) |- ( ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ↔ ( ( x R y ∧ y R x ) ↔ ( x ∈ ⋃ ⋃ R ∧ x = y ) ) ) ;;
	step 28 : wff = pm5.32 () |- ( ( x ∈ ⋃ ⋃ R → ( ( x R y ∧ y R x ) ↔ x = y ) ) ↔ ( ( x ∈ ⋃ ⋃ R ∧ ( x R y ∧ y R x ) ) ↔ ( x ∈ ⋃ ⋃ R ∧ x = y ) ) ) ;;
	step 29 : wff = 3bitr4i (step 9, step 27, step 28) |- ( ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ↔ ( x ∈ ⋃ ⋃ R → ( ( x R y ∧ y R x ) ↔ x = y ) ) ) ;;
	step 30 : wff = albii (step 29) |- ( ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ↔ ∀ y ( x ∈ ⋃ ⋃ R → ( ( x R y ∧ y R x ) ↔ x = y ) ) ) ;;
	step 31 : wff = 19.21v () |- ( ∀ y ( x ∈ ⋃ ⋃ R → ( ( x R y ∧ y R x ) ↔ x = y ) ) ↔ ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ) ;;
	step 32 : wff = bitri (step 30, step 31) |- ( ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ↔ ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ) ;;
	step 33 : wff = albii (step 32) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ↔ ∀ x ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ) ;;
	step 34 : wff = relcnv () |- Rel ⁻¹ R ;;
	step 35 : wff = relin2 () |- ( Rel ⁻¹ R → Rel ( R ∩ ⁻¹ R ) ) ;;
	step 36 : wff = ax-mp (step 34, step 35) |- Rel ( R ∩ ⁻¹ R ) ;;
	step 37 : wff = relres () |- Rel ( _I ↾ ⋃ ⋃ R ) ;;
	step 38 : wff = eqrel () |- ( ( Rel ( R ∩ ⁻¹ R ) ∧ Rel ( _I ↾ ⋃ ⋃ R ) ) → ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ) ) ;;
	step 39 : wff = mp2an (step 36, step 37, step 38) |- ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( R ∩ ⁻¹ R ) ↔ 〈 x , y 〉 ∈ ( _I ↾ ⋃ ⋃ R ) ) ) ;;
	step 40 : wff = df-ral () |- ( ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ↔ ∀ x ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ) ;;
	step 41 : wff = 3bitr4i (step 33, step 39, step 40) |- ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ;;
	qed prop 1 = step 41 ;;
}

/*Two ways of saying a relation is antisymmetric and reflexive.
       (Contributed by NM, 6-May-2008.)  (Proof shortened by Mario Carneiro,
       4-Dec-2016.) */

theorem asymref2 (x : set, y : set, R : class) disjointed(x y, x y, x y R, x y) {
	prop 1 : wff = |- ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ( ∀ x ∈ ⋃ ⋃ R x R x ∧ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
}

proof of asymref2 {
	step 1 : wff = asymref () |- ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ) ;;
	step 2 : wff = albiim () |- ( ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ↔ ( ∀ y ( ( x R y ∧ y R x ) → x = y ) ∧ ∀ y ( x = y → ( x R y ∧ y R x ) ) ) ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) ↔ x = y ) ↔ ∀ x ∈ ⋃ ⋃ R ( ∀ y ( ( x R y ∧ y R x ) → x = y ) ∧ ∀ y ( x = y → ( x R y ∧ y R x ) ) ) ) ;;
	step 4 : wff = r19.26 () |- ( ∀ x ∈ ⋃ ⋃ R ( ∀ y ( ( x R y ∧ y R x ) → x = y ) ∧ ∀ y ( x = y → ( x R y ∧ y R x ) ) ) ↔ ( ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) → x = y ) ∧ ∀ x ∈ ⋃ ⋃ R ∀ y ( x = y → ( x R y ∧ y R x ) ) ) ) ;;
	step 5 : wff = ancom () |- ( ( ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) → x = y ) ∧ ∀ x ∈ ⋃ ⋃ R ∀ y ( x = y → ( x R y ∧ y R x ) ) ) ↔ ( ∀ x ∈ ⋃ ⋃ R ∀ y ( x = y → ( x R y ∧ y R x ) ) ∧ ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
	step 6 : wff = equcom () |- ( x = y ↔ y = x ) ;;
	step 7 : wff = imbi1i (step 6) |- ( ( x = y → ( x R y ∧ y R x ) ) ↔ ( y = x → ( x R y ∧ y R x ) ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ y ( x = y → ( x R y ∧ y R x ) ) ↔ ∀ y ( y = x → ( x R y ∧ y R x ) ) ) ;;
	step 9 : wff = nfv () |- F/ y x R x ;;
	step 10 : wff = breq2 () |- ( y = x → ( x R y ↔ x R x ) ) ;;
	step 11 : wff = breq1 () |- ( y = x → ( y R x ↔ x R x ) ) ;;
	step 12 : wff = anbi12d (step 10, step 11) |- ( y = x → ( ( x R y ∧ y R x ) ↔ ( x R x ∧ x R x ) ) ) ;;
	step 13 : wff = anidm () |- ( ( x R x ∧ x R x ) ↔ x R x ) ;;
	step 14 : wff = syl6bb (step 12, step 13) |- ( y = x → ( ( x R y ∧ y R x ) ↔ x R x ) ) ;;
	step 15 : wff = equsal (step 9, step 14) |- ( ∀ y ( y = x → ( x R y ∧ y R x ) ) ↔ x R x ) ;;
	step 16 : wff = bitri (step 8, step 15) |- ( ∀ y ( x = y → ( x R y ∧ y R x ) ) ↔ x R x ) ;;
	step 17 : wff = ralbii (step 16) |- ( ∀ x ∈ ⋃ ⋃ R ∀ y ( x = y → ( x R y ∧ y R x ) ) ↔ ∀ x ∈ ⋃ ⋃ R x R x ) ;;
	step 18 : wff = df-ral () |- ( ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) → x = y ) ↔ ∀ x ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
	step 19 : wff = df-br () |- ( x R y ↔ 〈 x , y 〉 ∈ R ) ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = opeluu (step 20, step 21) |- ( 〈 x , y 〉 ∈ R → ( x ∈ ⋃ ⋃ R ∧ y ∈ ⋃ ⋃ R ) ) ;;
	step 23 : wff = simpld (step 22) |- ( 〈 x , y 〉 ∈ R → x ∈ ⋃ ⋃ R ) ;;
	step 24 : wff = sylbi (step 19, step 23) |- ( x R y → x ∈ ⋃ ⋃ R ) ;;
	step 25 : wff = adantr (step 24) |- ( ( x R y ∧ y R x ) → x ∈ ⋃ ⋃ R ) ;;
	step 26 : wff = pm2.24d (step 25) |- ( ( x R y ∧ y R x ) → ( ¬ x ∈ ⋃ ⋃ R → x = y ) ) ;;
	step 27 : wff = com12 (step 26) |- ( ¬ x ∈ ⋃ ⋃ R → ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 28 : wff = alrimiv (step 27) |- ( ¬ x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 29 : wff = id () |- ( ∀ y ( ( x R y ∧ y R x ) → x = y ) → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 30 : wff = ja (step 28, step 29) |- ( ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 31 : wff = ax-1 () |- ( ∀ y ( ( x R y ∧ y R x ) → x = y ) → ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
	step 32 : wff = impbii (step 30, step 31) |- ( ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ↔ ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 33 : wff = albii (step 32) |- ( ∀ x ( x ∈ ⋃ ⋃ R → ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ↔ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 34 : wff = bitri (step 18, step 33) |- ( ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) → x = y ) ↔ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ;;
	step 35 : wff = anbi12i (step 17, step 34) |- ( ( ∀ x ∈ ⋃ ⋃ R ∀ y ( x = y → ( x R y ∧ y R x ) ) ∧ ∀ x ∈ ⋃ ⋃ R ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ↔ ( ∀ x ∈ ⋃ ⋃ R x R x ∧ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
	step 36 : wff = 3bitri (step 4, step 5, step 35) |- ( ∀ x ∈ ⋃ ⋃ R ( ∀ y ( ( x R y ∧ y R x ) → x = y ) ∧ ∀ y ( x = y → ( x R y ∧ y R x ) ) ) ↔ ( ∀ x ∈ ⋃ ⋃ R x R x ∧ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
	step 37 : wff = 3bitri (step 1, step 3, step 36) |- ( ( R ∩ ⁻¹ R ) = ( _I ↾ ⋃ ⋃ R ) ↔ ( ∀ x ∈ ⋃ ⋃ R x R x ∧ ∀ x ∀ y ( ( x R y ∧ y R x ) → x = y ) ) ) ;;
	qed prop 1 = step 37 ;;
}

/*Two ways of saying a relation is irreflexive.  Definition of
       irreflexivity in [Schechter] p. 51.  (Contributed by NM, 9-Sep-2004.)
       (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem intirr (x : set, R : class) disjointed(x y, x y, x y R, x y) {
	prop 1 : wff = |- ( ( R ∩ _I ) = ∅ ↔ ∀ x ¬ x R x ) ;;
}

proof of intirr {
	var y : set;;
	step 1 : wff = incom () |- ( R ∩ _I ) = ( _I ∩ R ) ;;
	step 2 : wff = eqeq1i (step 1) |- ( ( R ∩ _I ) = ∅ ↔ ( _I ∩ R ) = ∅ ) ;;
	step 3 : wff = disj2 () |- ( ( _I ∩ R ) = ∅ ↔ _I ⊆ ( _V ∖ R ) ) ;;
	step 4 : wff = reli () |- Rel _I ;;
	step 5 : wff = ssrel () |- ( Rel _I → ( _I ⊆ ( _V ∖ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ _I → 〈 x , y 〉 ∈ ( _V ∖ R ) ) ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( _I ⊆ ( _V ∖ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ _I → 〈 x , y 〉 ∈ ( _V ∖ R ) ) ) ;;
	step 7 : wff = 3bitri (step 2, step 3, step 6) |- ( ( R ∩ _I ) = ∅ ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ _I → 〈 x , y 〉 ∈ ( _V ∖ R ) ) ) ;;
	step 8 : wff = eqcom () |- ( y = x ↔ x = y ) ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = ideq (step 9) |- ( x _I y ↔ x = y ) ;;
	step 11 : wff = df-br () |- ( x _I y ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 12 : wff = 3bitr2i (step 8, step 10, step 11) |- ( y = x ↔ 〈 x , y 〉 ∈ _I ) ;;
	step 13 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 14 : wff = biantrur (step 13) |- ( ¬ 〈 x , y 〉 ∈ R ↔ ( 〈 x , y 〉 ∈ _V ∧ ¬ 〈 x , y 〉 ∈ R ) ) ;;
	step 15 : wff = eldif () |- ( 〈 x , y 〉 ∈ ( _V ∖ R ) ↔ ( 〈 x , y 〉 ∈ _V ∧ ¬ 〈 x , y 〉 ∈ R ) ) ;;
	step 16 : wff = bitr4i (step 14, step 15) |- ( ¬ 〈 x , y 〉 ∈ R ↔ 〈 x , y 〉 ∈ ( _V ∖ R ) ) ;;
	step 17 : wff = df-br () |- ( x R y ↔ 〈 x , y 〉 ∈ R ) ;;
	step 18 : wff = xchnxbir (step 16, step 17) |- ( ¬ x R y ↔ 〈 x , y 〉 ∈ ( _V ∖ R ) ) ;;
	step 19 : wff = imbi12i (step 12, step 18) |- ( ( y = x → ¬ x R y ) ↔ ( 〈 x , y 〉 ∈ _I → 〈 x , y 〉 ∈ ( _V ∖ R ) ) ) ;;
	step 20 : wff = 2albii (step 19) |- ( ∀ x ∀ y ( y = x → ¬ x R y ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ _I → 〈 x , y 〉 ∈ ( _V ∖ R ) ) ) ;;
	step 21 : wff = nfv () |- F/ y ¬ x R x ;;
	step 22 : wff = breq2 () |- ( y = x → ( x R y ↔ x R x ) ) ;;
	step 23 : wff = notbid (step 22) |- ( y = x → ( ¬ x R y ↔ ¬ x R x ) ) ;;
	step 24 : wff = equsal (step 21, step 23) |- ( ∀ y ( y = x → ¬ x R y ) ↔ ¬ x R x ) ;;
	step 25 : wff = albii (step 24) |- ( ∀ x ∀ y ( y = x → ¬ x R y ) ↔ ∀ x ¬ x R x ) ;;
	step 26 : wff = 3bitr2i (step 7, step 20, step 25) |- ( ( R ∩ _I ) = ∅ ↔ ∀ x ¬ x R x ) ;;
	qed prop 1 = step 26 ;;
}

/*Two ways of saying that two elements have an upper bound.  (Contributed
       by Mario Carneiro, 3-Nov-2015.) */

theorem brcodir (z : set, A : class, B : class, R : class, V : class, W : class) disjointed(z A, z B, z R, z, z V, z W) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( A ( ⁻¹ R ∘ R ) B ↔ ∃ z ( A R z ∧ B R z ) ) ) ;;
}

proof of brcodir {
	step 1 : wff = brcog () |- ( ( A ∈ V ∧ B ∈ W ) → ( A ( ⁻¹ R ∘ R ) B ↔ ∃ z ( A R z ∧ z ⁻¹ R B ) ) ) ;;
	step 2 : wff = vex () |- z ∈ _V ;;
	step 3 : wff = brcnvg () |- ( ( z ∈ _V ∧ B ∈ W ) → ( z ⁻¹ R B ↔ B R z ) ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( B ∈ W → ( z ⁻¹ R B ↔ B R z ) ) ;;
	step 5 : wff = anbi2d (step 4) |- ( B ∈ W → ( ( A R z ∧ z ⁻¹ R B ) ↔ ( A R z ∧ B R z ) ) ) ;;
	step 6 : wff = adantl (step 5) |- ( ( A ∈ V ∧ B ∈ W ) → ( ( A R z ∧ z ⁻¹ R B ) ↔ ( A R z ∧ B R z ) ) ) ;;
	step 7 : wff = exbidv (step 6) |- ( ( A ∈ V ∧ B ∈ W ) → ( ∃ z ( A R z ∧ z ⁻¹ R B ) ↔ ∃ z ( A R z ∧ B R z ) ) ) ;;
	step 8 : wff = bitrd (step 1, step 7) |- ( ( A ∈ V ∧ B ∈ W ) → ( A ( ⁻¹ R ∘ R ) B ↔ ∃ z ( A R z ∧ B R z ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Two ways of saying a relation is directed.  (Contributed by Mario
       Carneiro, 22-Nov-2013.) */

theorem codir (x : set, y : set, z : set, A : class, B : class, R : class) disjointed(x y z A, x y z B, x y z R, x y z, z, z) {
	prop 1 : wff = |- ( ( A × B ) ⊆ ( ⁻¹ R ∘ R ) ↔ ∀ x ∈ A ∀ y ∈ B ∃ z ( x R z ∧ y R z ) ) ;;
}

proof of codir {
	step 1 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 2 : wff = df-br () |- ( x ( ⁻¹ R ∘ R ) y ↔ 〈 x , y 〉 ∈ ( ⁻¹ R ∘ R ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = brcodir () |- ( ( x ∈ _V ∧ y ∈ _V ) → ( x ( ⁻¹ R ∘ R ) y ↔ ∃ z ( x R z ∧ y R z ) ) ) ;;
	step 6 : wff = mp2an (step 3, step 4, step 5) |- ( x ( ⁻¹ R ∘ R ) y ↔ ∃ z ( x R z ∧ y R z ) ) ;;
	step 7 : wff = bitr3i (step 2, step 6) |- ( 〈 x , y 〉 ∈ ( ⁻¹ R ∘ R ) ↔ ∃ z ( x R z ∧ y R z ) ) ;;
	step 8 : wff = imbi12i (step 1, step 7) |- ( ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( ⁻¹ R ∘ R ) ) ↔ ( ( x ∈ A ∧ y ∈ B ) → ∃ z ( x R z ∧ y R z ) ) ) ;;
	step 9 : wff = 2albii (step 8) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( ⁻¹ R ∘ R ) ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ∃ z ( x R z ∧ y R z ) ) ) ;;
	step 10 : wff = relxp () |- Rel ( A × B ) ;;
	step 11 : wff = ssrel () |- ( Rel ( A × B ) → ( ( A × B ) ⊆ ( ⁻¹ R ∘ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( ⁻¹ R ∘ R ) ) ) ) ;;
	step 12 : wff = ax-mp (step 10, step 11) |- ( ( A × B ) ⊆ ( ⁻¹ R ∘ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( ⁻¹ R ∘ R ) ) ) ;;
	step 13 : wff = r2al () |- ( ∀ x ∈ A ∀ y ∈ B ∃ z ( x R z ∧ y R z ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ∃ z ( x R z ∧ y R z ) ) ) ;;
	step 14 : wff = 3bitr4i (step 9, step 12, step 13) |- ( ( A × B ) ⊆ ( ⁻¹ R ∘ R ) ↔ ∀ x ∈ A ∀ y ∈ B ∃ z ( x R z ∧ y R z ) ) ;;
	qed prop 1 = step 14 ;;
}

/*A quantifier-free way of expressing the total order predicate.
       (Contributed by Mario Carneiro, 22-Nov-2013.) */

theorem qfto (x : set, y : set, A : class, B : class, R : class) disjointed(x y A, x y B, x y R, x y) {
	prop 1 : wff = |- ( ( A × B ) ⊆ ( R ∪ ⁻¹ R ) ↔ ∀ x ∈ A ∀ y ∈ B ( x R y ∨ y R x ) ) ;;
}

proof of qfto {
	step 1 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 2 : wff = brun () |- ( x ( R ∪ ⁻¹ R ) y ↔ ( x R y ∨ x ⁻¹ R y ) ) ;;
	step 3 : wff = df-br () |- ( x ( R ∪ ⁻¹ R ) y ↔ 〈 x , y 〉 ∈ ( R ∪ ⁻¹ R ) ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = brcnv (step 4, step 5) |- ( x ⁻¹ R y ↔ y R x ) ;;
	step 7 : wff = orbi2i (step 6) |- ( ( x R y ∨ x ⁻¹ R y ) ↔ ( x R y ∨ y R x ) ) ;;
	step 8 : wff = 3bitr3i (step 2, step 3, step 7) |- ( 〈 x , y 〉 ∈ ( R ∪ ⁻¹ R ) ↔ ( x R y ∨ y R x ) ) ;;
	step 9 : wff = imbi12i (step 1, step 8) |- ( ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( R ∪ ⁻¹ R ) ) ↔ ( ( x ∈ A ∧ y ∈ B ) → ( x R y ∨ y R x ) ) ) ;;
	step 10 : wff = 2albii (step 9) |- ( ∀ x ∀ y ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( R ∪ ⁻¹ R ) ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ( x R y ∨ y R x ) ) ) ;;
	step 11 : wff = relxp () |- Rel ( A × B ) ;;
	step 12 : wff = ssrel () |- ( Rel ( A × B ) → ( ( A × B ) ⊆ ( R ∪ ⁻¹ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( R ∪ ⁻¹ R ) ) ) ) ;;
	step 13 : wff = ax-mp (step 11, step 12) |- ( ( A × B ) ⊆ ( R ∪ ⁻¹ R ) ↔ ∀ x ∀ y ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ∈ ( R ∪ ⁻¹ R ) ) ) ;;
	step 14 : wff = r2al () |- ( ∀ x ∈ A ∀ y ∈ B ( x R y ∨ y R x ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ( x R y ∨ y R x ) ) ) ;;
	step 15 : wff = 3bitr4i (step 10, step 13, step 14) |- ( ( A × B ) ⊆ ( R ∪ ⁻¹ R ) ↔ ∀ x ∈ A ∀ y ∈ B ( x R y ∨ y R x ) ) ;;
	qed prop 1 = step 15 ;;
}

/*A square cross product ` ( A X. A ) ` is a transitive relation.
       (Contributed by FL, 31-Jul-2009.) */

theorem xpidtr (A : class) disjointed(x y z A, x y z, x y z, x y z, z, z) {
	prop 1 : wff = |- ( ( A × A ) ∘ ( A × A ) ) ⊆ ( A × A ) ;;
}

proof of xpidtr {
	var x : set, y : set, z : set;;
	step 1 : wff = brxp () |- ( x ( A × A ) y ↔ ( x ∈ A ∧ y ∈ A ) ) ;;
	step 2 : wff = brxp () |- ( y ( A × A ) z ↔ ( y ∈ A ∧ z ∈ A ) ) ;;
	step 3 : wff = brxp () |- ( x ( A × A ) z ↔ ( x ∈ A ∧ z ∈ A ) ) ;;
	step 4 : wff = simplbi2com (step 3) |- ( z ∈ A → ( x ∈ A → x ( A × A ) z ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( y ∈ A ∧ z ∈ A ) → ( x ∈ A → x ( A × A ) z ) ) ;;
	step 6 : wff = sylbi (step 2, step 5) |- ( y ( A × A ) z → ( x ∈ A → x ( A × A ) z ) ) ;;
	step 7 : wff = com12 (step 6) |- ( x ∈ A → ( y ( A × A ) z → x ( A × A ) z ) ) ;;
	step 8 : wff = adantr (step 7) |- ( ( x ∈ A ∧ y ∈ A ) → ( y ( A × A ) z → x ( A × A ) z ) ) ;;
	step 9 : wff = sylbi (step 1, step 8) |- ( x ( A × A ) y → ( y ( A × A ) z → x ( A × A ) z ) ) ;;
	step 10 : wff = imp (step 9) |- ( ( x ( A × A ) y ∧ y ( A × A ) z ) → x ( A × A ) z ) ;;
	step 11 : wff = ax-gen (step 10) |- ∀ z ( ( x ( A × A ) y ∧ y ( A × A ) z ) → x ( A × A ) z ) ;;
	step 12 : wff = gen2 (step 11) |- ∀ x ∀ y ∀ z ( ( x ( A × A ) y ∧ y ( A × A ) z ) → x ( A × A ) z ) ;;
	step 13 : wff = cotr () |- ( ( ( A × A ) ∘ ( A × A ) ) ⊆ ( A × A ) ↔ ∀ x ∀ y ∀ z ( ( x ( A × A ) y ∧ y ( A × A ) z ) → x ( A × A ) z ) ) ;;
	step 14 : wff = mpbir (step 12, step 13) |- ( ( A × A ) ∘ ( A × A ) ) ⊆ ( A × A ) ;;
	qed prop 1 = step 14 ;;
}

/*The intersection of two transitive classes is transitive.  (Contributed
       by FL, 31-Jul-2009.) */

theorem trin2 (R : class, S : class) disjointed(x y z, x y z, x y z R, x y z S, z, z) {
	prop 1 : wff = |- ( ( ( R ∘ R ) ⊆ R ∧ ( S ∘ S ) ⊆ S ) → ( ( R ∩ S ) ∘ ( R ∩ S ) ) ⊆ ( R ∩ S ) ) ;;
}

proof of trin2 {
	var x : set, y : set, z : set;;
	step 1 : wff = cotr () |- ( ( R ∘ R ) ⊆ R ↔ ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 2 : wff = cotr () |- ( ( S ∘ S ) ⊆ S ↔ ∀ x ∀ y ∀ z ( ( x S y ∧ y S z ) → x S z ) ) ;;
	step 3 : wff = brin () |- ( x ( R ∩ S ) y ↔ ( x R y ∧ x S y ) ) ;;
	step 4 : wff = brin () |- ( y ( R ∩ S ) z ↔ ( y R z ∧ y S z ) ) ;;
	step 5 : wff = simpr () |- ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 6 : wff = simpl () |- ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( ( x S y ∧ y S z ) → x S z ) ) ;;
	step 7 : wff = anim12d (step 5, step 6) |- ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( ( ( x R y ∧ y R z ) ∧ ( x S y ∧ y S z ) ) → ( x R z ∧ x S z ) ) ) ;;
	step 8 : wff = com12 (step 7) |- ( ( ( x R y ∧ y R z ) ∧ ( x S y ∧ y S z ) ) → ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( x R z ∧ x S z ) ) ) ;;
	step 9 : wff = an4s (step 8) |- ( ( ( x R y ∧ x S y ) ∧ ( y R z ∧ y S z ) ) → ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( x R z ∧ x S z ) ) ) ;;
	step 10 : wff = syl2anb (step 3, step 4, step 9) |- ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( x R z ∧ x S z ) ) ) ;;
	step 11 : wff = com12 (step 10) |- ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → ( x R z ∧ x S z ) ) ) ;;
	step 12 : wff = brin () |- ( x ( R ∩ S ) z ↔ ( x R z ∧ x S z ) ) ;;
	step 13 : wff = syl6ibr (step 11, step 12) |- ( ( ( ( x S y ∧ y S z ) → x S z ) ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ;;
	step 14 : wff = alanimi (step 13) |- ( ( ∀ z ( ( x S y ∧ y S z ) → x S z ) ∧ ∀ z ( ( x R y ∧ y R z ) → x R z ) ) → ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ;;
	step 15 : wff = alanimi (step 14) |- ( ( ∀ y ∀ z ( ( x S y ∧ y S z ) → x S z ) ∧ ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) → ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ;;
	step 16 : wff = alanimi (step 15) |- ( ( ∀ x ∀ y ∀ z ( ( x S y ∧ y S z ) → x S z ) ∧ ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) ) → ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ;;
	step 17 : wff = ex (step 16) |- ( ∀ x ∀ y ∀ z ( ( x S y ∧ y S z ) → x S z ) → ( ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) → ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ) ;;
	step 18 : wff = sylbi (step 2, step 17) |- ( ( S ∘ S ) ⊆ S → ( ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) → ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ) ;;
	step 19 : wff = com12 (step 18) |- ( ∀ x ∀ y ∀ z ( ( x R y ∧ y R z ) → x R z ) → ( ( S ∘ S ) ⊆ S → ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ) ;;
	step 20 : wff = sylbi (step 1, step 19) |- ( ( R ∘ R ) ⊆ R → ( ( S ∘ S ) ⊆ S → ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ) ;;
	step 21 : wff = imp (step 20) |- ( ( ( R ∘ R ) ⊆ R ∧ ( S ∘ S ) ⊆ S ) → ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ;;
	step 22 : wff = cotr () |- ( ( ( R ∩ S ) ∘ ( R ∩ S ) ) ⊆ ( R ∩ S ) ↔ ∀ x ∀ y ∀ z ( ( x ( R ∩ S ) y ∧ y ( R ∩ S ) z ) → x ( R ∩ S ) z ) ) ;;
	step 23 : wff = sylibr (step 21, step 22) |- ( ( ( R ∘ R ) ⊆ R ∧ ( S ∘ S ) ⊆ S ) → ( ( R ∩ S ) ∘ ( R ∩ S ) ) ⊆ ( R ∩ S ) ) ;;
	qed prop 1 = step 23 ;;
}

/*A partial order relation is irreflexive.  (Contributed by Mario
       Carneiro, 2-Nov-2015.) */

theorem poirr2 (A : class, R : class) disjointed(x y A, x y, x y R, x y) {
	prop 1 : wff = |- ( R Po A → ( R ∩ ( _I ↾ A ) ) = ∅ ) ;;
}

proof of poirr2 {
	var x : set, y : set;;
	step 1 : wff = relres () |- Rel ( _I ↾ A ) ;;
	step 2 : wff = relin2 () |- ( Rel ( _I ↾ A ) → Rel ( R ∩ ( _I ↾ A ) ) ) ;;
	step 3 : wff = mp1i (step 1, step 2) |- ( R Po A → Rel ( R ∩ ( _I ↾ A ) ) ) ;;
	step 4 : wff = df-br () |- ( x ( R ∩ ( _I ↾ A ) ) y ↔ 〈 x , y 〉 ∈ ( R ∩ ( _I ↾ A ) ) ) ;;
	step 5 : wff = brin () |- ( x ( R ∩ ( _I ↾ A ) ) y ↔ ( x R y ∧ x ( _I ↾ A ) y ) ) ;;
	step 6 : wff = bitr3i (step 4, step 5) |- ( 〈 x , y 〉 ∈ ( R ∩ ( _I ↾ A ) ) ↔ ( x R y ∧ x ( _I ↾ A ) y ) ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = brres (step 7) |- ( x ( _I ↾ A ) y ↔ ( x _I y ∧ x ∈ A ) ) ;;
	step 9 : wff = poirr () |- ( ( R Po A ∧ x ∈ A ) → ¬ x R x ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = ideq (step 10) |- ( x _I y ↔ x = y ) ;;
	step 12 : wff = breq2 () |- ( x = y → ( x R x ↔ x R y ) ) ;;
	step 13 : wff = sylbi (step 11, step 12) |- ( x _I y → ( x R x ↔ x R y ) ) ;;
	step 14 : wff = notbid (step 13) |- ( x _I y → ( ¬ x R x ↔ ¬ x R y ) ) ;;
	step 15 : wff = syl5ibcom (step 9, step 14) |- ( ( R Po A ∧ x ∈ A ) → ( x _I y → ¬ x R y ) ) ;;
	step 16 : wff = expimpd (step 15) |- ( R Po A → ( ( x ∈ A ∧ x _I y ) → ¬ x R y ) ) ;;
	step 17 : wff = ancomsd (step 16) |- ( R Po A → ( ( x _I y ∧ x ∈ A ) → ¬ x R y ) ) ;;
	step 18 : wff = syl5bi (step 8, step 17) |- ( R Po A → ( x ( _I ↾ A ) y → ¬ x R y ) ) ;;
	step 19 : wff = con2d (step 18) |- ( R Po A → ( x R y → ¬ x ( _I ↾ A ) y ) ) ;;
	step 20 : wff = imnan () |- ( ( x R y → ¬ x ( _I ↾ A ) y ) ↔ ¬ ( x R y ∧ x ( _I ↾ A ) y ) ) ;;
	step 21 : wff = sylib (step 19, step 20) |- ( R Po A → ¬ ( x R y ∧ x ( _I ↾ A ) y ) ) ;;
	step 22 : wff = pm2.21d (step 21) |- ( R Po A → ( ( x R y ∧ x ( _I ↾ A ) y ) → 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 23 : wff = syl5bi (step 6, step 22) |- ( R Po A → ( 〈 x , y 〉 ∈ ( R ∩ ( _I ↾ A ) ) → 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 24 : wff = relssdv (step 3, step 23) |- ( R Po A → ( R ∩ ( _I ↾ A ) ) ⊆ ∅ ) ;;
	step 25 : wff = ss0 () |- ( ( R ∩ ( _I ↾ A ) ) ⊆ ∅ → ( R ∩ ( _I ↾ A ) ) = ∅ ) ;;
	step 26 : wff = syl (step 24, step 25) |- ( R Po A → ( R ∩ ( _I ↾ A ) ) = ∅ ) ;;
	qed prop 1 = step 26 ;;
}

/*The relation induced by a transitive relation on a part of its field is
     transitive.  (Taking the intersection of a relation with a square cross
     product is a way to restrict it to a subset of its field.)  (Contributed
     by FL, 31-Jul-2009.) */

theorem trinxp (A : class, R : class)  {
	prop 1 : wff = |- ( ( R ∘ R ) ⊆ R → ( ( R ∩ ( A × A ) ) ∘ ( R ∩ ( A × A ) ) ) ⊆ ( R ∩ ( A × A ) ) ) ;;
}

proof of trinxp {
	step 1 : wff = xpidtr () |- ( ( A × A ) ∘ ( A × A ) ) ⊆ ( A × A ) ;;
	step 2 : wff = trin2 () |- ( ( ( R ∘ R ) ⊆ R ∧ ( ( A × A ) ∘ ( A × A ) ) ⊆ ( A × A ) ) → ( ( R ∩ ( A × A ) ) ∘ ( R ∩ ( A × A ) ) ) ⊆ ( R ∩ ( A × A ) ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( ( R ∘ R ) ⊆ R → ( ( R ∩ ( A × A ) ) ∘ ( R ∩ ( A × A ) ) ) ⊆ ( R ∩ ( A × A ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A strict order relation is irreflexive.  (Contributed by NM,
       10-Feb-1996.)  (Revised by Mario Carneiro, 10-May-2013.) */

theorem soirri (A : class, R : class, S : class)  {
	hyp 1 : wff = |- R Or S ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ¬ A R A ;;
}

proof of soirri {
	step 1 : wff = sonr () |- ( ( R Or S ∧ A ∈ S ) → ¬ A R A ) ;;
	step 2 : wff = mpan (hyp 1, step 1) |- ( A ∈ S → ¬ A R A ) ;;
	step 3 : wff = adantl (step 2) |- ( ( A ∈ S ∧ A ∈ S ) → ¬ A R A ) ;;
	step 4 : wff = brel (hyp 2) |- ( A R A → ( A ∈ S ∧ A ∈ S ) ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ ( A ∈ S ∧ A ∈ S ) → ¬ A R A ) ;;
	step 6 : wff = pm2.61i (step 3, step 5) |- ¬ A R A ;;
	qed prop 1 = step 6 ;;
}

/*A strict order relation is a transitive relation.  (Contributed by NM,
         10-Feb-1996.)  (Revised by Mario Carneiro, 10-May-2013.) */

theorem sotri (A : class, B : class, C : class, R : class, S : class) disjointed(A, B, R) {
	hyp 1 : wff = |- R Or S ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A R B ∧ B R C ) → A R C ) ;;
}

proof of sotri {
	step 1 : wff = brel (hyp 2) |- ( A R B → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 2 : wff = simpld (step 1) |- ( A R B → A ∈ S ) ;;
	step 3 : wff = brel (hyp 2) |- ( B R C → ( B ∈ S ∧ C ∈ S ) ) ;;
	step 4 : wff = anim12i (step 2, step 3) |- ( ( A R B ∧ B R C ) → ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) ) ;;
	step 5 : wff = sotr () |- ( ( R Or S ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 6 : wff = mpan (hyp 1, step 5) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 7 : wff = 3expb (step 6) |- ( ( A ∈ S ∧ ( B ∈ S ∧ C ∈ S ) ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 8 : wff = mpcom (step 4, step 7) |- ( ( A R B ∧ B R C ) → A R C ) ;;
	qed prop 1 = step 8 ;;
}

/*A strict order relation has no 2-cycle loops.  (Contributed by NM,
         10-Feb-1996.)  (Revised by Mario Carneiro, 10-May-2013.) */

theorem son2lpi (A : class, B : class, R : class, S : class) disjointed(A, B, R) {
	hyp 1 : wff = |- R Or S ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ¬ ( A R B ∧ B R A ) ;;
}

proof of son2lpi {
	step 1 : wff = soirri (hyp 1, hyp 2) |- ¬ A R A ;;
	step 2 : wff = sotri (hyp 1, hyp 2) |- ( ( A R B ∧ B R A ) → A R A ) ;;
	step 3 : wff = mto (step 1, step 2) |- ¬ ( A R B ∧ B R A ) ;;
	qed prop 1 = step 3 ;;
}

/*A transitivity relation.  (Read ` A <_ B ` and ` B < C ` implies
         ` A < C ` .)  (Contributed by Mario Carneiro, 10-May-2013.) */

theorem sotri2 (A : class, B : class, C : class, R : class, S : class) disjointed(A, B, R) {
	hyp 1 : wff = |- R Or S ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ S ∧ ¬ B R A ∧ B R C ) → A R C ) ;;
}

proof of sotri2 {
	step 1 : wff = brel (hyp 2) |- ( B R C → ( B ∈ S ∧ C ∈ S ) ) ;;
	step 2 : wff = simpld (step 1) |- ( B R C → B ∈ S ) ;;
	step 3 : wff = sotric () |- ( ( R Or S ∧ ( B ∈ S ∧ A ∈ S ) ) → ( B R A ↔ ¬ ( B = A ∨ A R B ) ) ) ;;
	step 4 : wff = mpan (hyp 1, step 3) |- ( ( B ∈ S ∧ A ∈ S ) → ( B R A ↔ ¬ ( B = A ∨ A R B ) ) ) ;;
	step 5 : wff = con2bid (step 4) |- ( ( B ∈ S ∧ A ∈ S ) → ( ( B = A ∨ A R B ) ↔ ¬ B R A ) ) ;;
	step 6 : wff = breq1 () |- ( B = A → ( B R C ↔ A R C ) ) ;;
	step 7 : wff = biimpd (step 6) |- ( B = A → ( B R C → A R C ) ) ;;
	step 8 : wff = sotri (hyp 1, hyp 2) |- ( ( A R B ∧ B R C ) → A R C ) ;;
	step 9 : wff = ex (step 8) |- ( A R B → ( B R C → A R C ) ) ;;
	step 10 : wff = jaoi (step 7, step 9) |- ( ( B = A ∨ A R B ) → ( B R C → A R C ) ) ;;
	step 11 : wff = syl6bir (step 5, step 10) |- ( ( B ∈ S ∧ A ∈ S ) → ( ¬ B R A → ( B R C → A R C ) ) ) ;;
	step 12 : wff = com3r (step 11) |- ( B R C → ( ( B ∈ S ∧ A ∈ S ) → ( ¬ B R A → A R C ) ) ) ;;
	step 13 : wff = mpand (step 2, step 12) |- ( B R C → ( A ∈ S → ( ¬ B R A → A R C ) ) ) ;;
	step 14 : wff = com3l (step 13) |- ( A ∈ S → ( ¬ B R A → ( B R C → A R C ) ) ) ;;
	step 15 : wff = 3imp (step 14) |- ( ( A ∈ S ∧ ¬ B R A ∧ B R C ) → A R C ) ;;
	qed prop 1 = step 15 ;;
}

/*A transitivity relation.  (Read ` A < B ` and ` B <_ C ` implies
         ` A < C ` .)  (Contributed by Mario Carneiro, 10-May-2013.) */

theorem sotri3 (A : class, B : class, C : class, R : class, S : class) disjointed(A, B, R) {
	hyp 1 : wff = |- R Or S ;;
	hyp 2 : wff = |- R ⊆ ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ( ( C ∈ S ∧ A R B ∧ ¬ C R B ) → A R C ) ;;
}

proof of sotri3 {
	step 1 : wff = brel (hyp 2) |- ( A R B → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 2 : wff = simprd (step 1) |- ( A R B → B ∈ S ) ;;
	step 3 : wff = sotric () |- ( ( R Or S ∧ ( C ∈ S ∧ B ∈ S ) ) → ( C R B ↔ ¬ ( C = B ∨ B R C ) ) ) ;;
	step 4 : wff = mpan (hyp 1, step 3) |- ( ( C ∈ S ∧ B ∈ S ) → ( C R B ↔ ¬ ( C = B ∨ B R C ) ) ) ;;
	step 5 : wff = con2bid (step 4) |- ( ( C ∈ S ∧ B ∈ S ) → ( ( C = B ∨ B R C ) ↔ ¬ C R B ) ) ;;
	step 6 : wff = breq2 () |- ( C = B → ( A R C ↔ A R B ) ) ;;
	step 7 : wff = biimprd (step 6) |- ( C = B → ( A R B → A R C ) ) ;;
	step 8 : wff = sotri (hyp 1, hyp 2) |- ( ( A R B ∧ B R C ) → A R C ) ;;
	step 9 : wff = expcom (step 8) |- ( B R C → ( A R B → A R C ) ) ;;
	step 10 : wff = jaoi (step 7, step 9) |- ( ( C = B ∨ B R C ) → ( A R B → A R C ) ) ;;
	step 11 : wff = syl6bir (step 5, step 10) |- ( ( C ∈ S ∧ B ∈ S ) → ( ¬ C R B → ( A R B → A R C ) ) ) ;;
	step 12 : wff = com3r (step 11) |- ( A R B → ( ( C ∈ S ∧ B ∈ S ) → ( ¬ C R B → A R C ) ) ) ;;
	step 13 : wff = mpan2d (step 2, step 12) |- ( A R B → ( C ∈ S → ( ¬ C R B → A R C ) ) ) ;;
	step 14 : wff = com12 (step 13) |- ( C ∈ S → ( A R B → ( ¬ C R B → A R C ) ) ) ;;
	step 15 : wff = 3imp (step 14) |- ( ( C ∈ S ∧ A R B ∧ ¬ C R B ) → A R C ) ;;
	qed prop 1 = step 15 ;;
}

/*A strict order relation is irreflexive.  (Contributed by NM,
       10-Feb-1996.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem soirriOLD (A : class, R : class, S : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- R Or S ;;
	hyp 3 : wff = |- R ⊆ ( S × S ) ;;
	-----------------------
	prop 1 : wff = |- ¬ A R A ;;
}

proof of soirriOLD {
	step 1 : wff = sonr () |- ( ( R Or S ∧ A ∈ S ) → ¬ A R A ) ;;
	step 2 : wff = mpan (hyp 2, step 1) |- ( A ∈ S → ¬ A R A ) ;;
	step 3 : wff = adantl (step 2) |- ( ( A ∈ S ∧ A ∈ S ) → ¬ A R A ) ;;
	step 4 : wff = brel (hyp 3) |- ( A R A → ( A ∈ S ∧ A ∈ S ) ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ ( A ∈ S ∧ A ∈ S ) → ¬ A R A ) ;;
	step 6 : wff = pm2.61i (step 3, step 5) |- ¬ A R A ;;
	qed prop 1 = step 6 ;;
}

/*A strict order relation is a transitive relation.  (Contributed by NM,
         10-Feb-1996.)  (Proof modification is discouraged.)
         (New usage is discouraged.) */

theorem sotriOLD (A : class, B : class, C : class, R : class, S : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- R Or S ;;
	hyp 3 : wff = |- R ⊆ ( S × S ) ;;
	hyp 4 : wff = |- B ∈ _V ;;
	hyp 5 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ( A R B ∧ B R C ) → A R C ) ;;
}

proof of sotriOLD {
	step 1 : wff = brel (hyp 3) |- ( A R B → ( A ∈ S ∧ B ∈ S ) ) ;;
	step 2 : wff = brel (hyp 3) |- ( B R C → ( B ∈ S ∧ C ∈ S ) ) ;;
	step 3 : wff = id () |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 4 : wff = 3exp (step 3) |- ( A ∈ S → ( B ∈ S → ( C ∈ S → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ) ) ;;
	step 5 : wff = a1dd (step 4) |- ( A ∈ S → ( B ∈ S → ( B ∈ S → ( C ∈ S → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ) ) ) ;;
	step 6 : wff = imp43 (step 5) |- ( ( ( A ∈ S ∧ B ∈ S ) ∧ ( B ∈ S ∧ C ∈ S ) ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 7 : wff = syl2an (step 1, step 2, step 6) |- ( ( A R B ∧ B R C ) → ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) ;;
	step 8 : wff = sotr () |- ( ( R Or S ∧ ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 9 : wff = mpan (hyp 2, step 8) |- ( ( A ∈ S ∧ B ∈ S ∧ C ∈ S ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 10 : wff = mpcom (step 7, step 9) |- ( ( A R B ∧ B R C ) → A R C ) ;;
	qed prop 1 = step 10 ;;
}

/*A strict order relation has no 2-cycle loops.  (Contributed by NM,
         10-Feb-1996.)  (Proof modification is discouraged.)
         (New usage is discouraged.) */

theorem son2lpiOLD (A : class, B : class, R : class, S : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- R Or S ;;
	hyp 3 : wff = |- R ⊆ ( S × S ) ;;
	hyp 4 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ¬ ( A R B ∧ B R A ) ;;
}

proof of son2lpiOLD {
	step 1 : wff = soirri (hyp 2, hyp 3) |- ¬ A R A ;;
	step 2 : wff = sotri (hyp 2, hyp 3) |- ( ( A R B ∧ B R A ) → A R A ) ;;
	step 3 : wff = mto (step 1, step 2) |- ¬ ( A R B ∧ B R A ) ;;
	qed prop 1 = step 3 ;;
}

/*Express "less than or equals" for general strict orders.  (Contributed by
     Stefan O'Rear, 17-Jan-2015.) */

theorem poleloe (A : class, B : class, R : class, V : class)  {
	prop 1 : wff = |- ( B ∈ V → ( A ( R ∪ _I ) B ↔ ( A R B ∨ A = B ) ) ) ;;
}

proof of poleloe {
	step 1 : wff = brun () |- ( A ( R ∪ _I ) B ↔ ( A R B ∨ A _I B ) ) ;;
	step 2 : wff = ideqg () |- ( B ∈ V → ( A _I B ↔ A = B ) ) ;;
	step 3 : wff = orbi2d (step 2) |- ( B ∈ V → ( ( A R B ∨ A _I B ) ↔ ( A R B ∨ A = B ) ) ) ;;
	step 4 : wff = syl5bb (step 1, step 3) |- ( B ∈ V → ( A ( R ∪ _I ) B ↔ ( A R B ∨ A = B ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Transitive law for general strict orders.  (Contributed by Stefan O'Rear,
     17-Jan-2015.) */

theorem poltletr (A : class, B : class, C : class, R : class, X : class)  {
	prop 1 : wff = |- ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( ( A R B ∧ B ( R ∪ _I ) C ) → A R C ) ) ;;
}

proof of poltletr {
	step 1 : wff = poleloe () |- ( C ∈ X → ( B ( R ∪ _I ) C ↔ ( B R C ∨ B = C ) ) ) ;;
	step 2 : wff = 3ad2ant3 (step 1) |- ( ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) → ( B ( R ∪ _I ) C ↔ ( B R C ∨ B = C ) ) ) ;;
	step 3 : wff = adantl (step 2) |- ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( B ( R ∪ _I ) C ↔ ( B R C ∨ B = C ) ) ) ;;
	step 4 : wff = anbi2d (step 3) |- ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( ( A R B ∧ B ( R ∪ _I ) C ) ↔ ( A R B ∧ ( B R C ∨ B = C ) ) ) ) ;;
	step 5 : wff = potr () |- ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( ( A R B ∧ B R C ) → A R C ) ) ;;
	step 6 : wff = com12 (step 5) |- ( ( A R B ∧ B R C ) → ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → A R C ) ) ;;
	step 7 : wff = breq2 () |- ( B = C → ( A R B ↔ A R C ) ) ;;
	step 8 : wff = biimpac (step 7) |- ( ( A R B ∧ B = C ) → A R C ) ;;
	step 9 : wff = a1d (step 8) |- ( ( A R B ∧ B = C ) → ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → A R C ) ) ;;
	step 10 : wff = jaodan (step 6, step 9) |- ( ( A R B ∧ ( B R C ∨ B = C ) ) → ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → A R C ) ) ;;
	step 11 : wff = com12 (step 10) |- ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( ( A R B ∧ ( B R C ∨ B = C ) ) → A R C ) ) ;;
	step 12 : wff = sylbid (step 4, step 11) |- ( ( R Po X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( ( A R B ∧ B ( R ∪ _I ) C ) → A R C ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Property of a minimum in a strict order.  (Contributed by Stefan O'Rear,
     17-Jan-2015.) */

theorem somin1 (A : class, B : class, R : class, X : class)  {
	prop 1 : wff = |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) ( R ∪ _I ) A ) ;;
}

proof of somin1 {
	step 1 : wff = iftrue () |- ( A R B → if ( A R B , A , B ) = A ) ;;
	step 2 : wff = olcd (step 1) |- ( A R B → ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ) ;;
	step 4 : wff = sotric () |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( A R B ↔ ¬ ( A = B ∨ B R A ) ) ) ;;
	step 5 : wff = orcom () |- ( ( A = B ∨ B R A ) ↔ ( B R A ∨ A = B ) ) ;;
	step 6 : wff = eqcom () |- ( A = B ↔ B = A ) ;;
	step 7 : wff = orbi2i (step 6) |- ( ( B R A ∨ A = B ) ↔ ( B R A ∨ B = A ) ) ;;
	step 8 : wff = bitri (step 5, step 7) |- ( ( A = B ∨ B R A ) ↔ ( B R A ∨ B = A ) ) ;;
	step 9 : wff = notbii (step 8) |- ( ¬ ( A = B ∨ B R A ) ↔ ¬ ( B R A ∨ B = A ) ) ;;
	step 10 : wff = syl6bb (step 4, step 9) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( A R B ↔ ¬ ( B R A ∨ B = A ) ) ) ;;
	step 11 : wff = con2bid (step 10) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( ( B R A ∨ B = A ) ↔ ¬ A R B ) ) ;;
	step 12 : wff = biimpar (step 11) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ ¬ A R B ) → ( B R A ∨ B = A ) ) ;;
	step 13 : wff = iffalse () |- ( ¬ A R B → if ( A R B , A , B ) = B ) ;;
	step 14 : wff = breq1 () |- ( if ( A R B , A , B ) = B → ( if ( A R B , A , B ) R A ↔ B R A ) ) ;;
	step 15 : wff = eqeq1 () |- ( if ( A R B , A , B ) = B → ( if ( A R B , A , B ) = A ↔ B = A ) ) ;;
	step 16 : wff = orbi12d (step 14, step 15) |- ( if ( A R B , A , B ) = B → ( ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ↔ ( B R A ∨ B = A ) ) ) ;;
	step 17 : wff = syl (step 13, step 16) |- ( ¬ A R B → ( ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ↔ ( B R A ∨ B = A ) ) ) ;;
	step 18 : wff = adantl (step 17) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ ¬ A R B ) → ( ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ↔ ( B R A ∨ B = A ) ) ) ;;
	step 19 : wff = mpbird (step 12, step 18) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ ¬ A R B ) → ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ) ;;
	step 20 : wff = pm2.61dan (step 3, step 19) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ) ;;
	step 21 : wff = poleloe () |- ( A ∈ X → ( if ( A R B , A , B ) ( R ∪ _I ) A ↔ ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ) ) ;;
	step 22 : wff = ad2antrl (step 21) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( if ( A R B , A , B ) ( R ∪ _I ) A ↔ ( if ( A R B , A , B ) R A ∨ if ( A R B , A , B ) = A ) ) ) ;;
	step 23 : wff = mpbird (step 20, step 22) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) ( R ∪ _I ) A ) ;;
	qed prop 1 = step 23 ;;
}

/*Commutativity of minimum in a total order.  (Contributed by Stefan O'Rear,
     17-Jan-2015.) */

theorem somincom (A : class, B : class, R : class, X : class)  {
	prop 1 : wff = |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) = if ( B R A , B , A ) ) ;;
}

proof of somincom {
	step 1 : wff = iftrue () |- ( A R B → if ( A R B , A , B ) = A ) ;;
	step 2 : wff = adantl (step 1) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → if ( A R B , A , B ) = A ) ;;
	step 3 : wff = so2nr () |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ¬ ( A R B ∧ B R A ) ) ;;
	step 4 : wff = nan () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ¬ ( A R B ∧ B R A ) ) ↔ ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → ¬ B R A ) ) ;;
	step 5 : wff = mpbi (step 3, step 4) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → ¬ B R A ) ;;
	step 6 : wff = iffalse () |- ( ¬ B R A → if ( B R A , B , A ) = A ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → if ( B R A , B , A ) = A ) ;;
	step 8 : wff = eqcomd (step 7) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → A = if ( B R A , B , A ) ) ;;
	step 9 : wff = eqtrd (step 2, step 8) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ A R B ) → if ( A R B , A , B ) = if ( B R A , B , A ) ) ;;
	step 10 : wff = iffalse () |- ( ¬ A R B → if ( A R B , A , B ) = B ) ;;
	step 11 : wff = adantl (step 10) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ ¬ A R B ) → if ( A R B , A , B ) = B ) ;;
	step 12 : wff = sotric () |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( A R B ↔ ¬ ( A = B ∨ B R A ) ) ) ;;
	step 13 : wff = con2bid (step 12) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( ( A = B ∨ B R A ) ↔ ¬ A R B ) ) ;;
	step 14 : wff = ifeq2 () |- ( A = B → if ( B R A , B , A ) = if ( B R A , B , B ) ) ;;
	step 15 : wff = ifid () |- if ( B R A , B , B ) = B ;;
	step 16 : wff = syl6req (step 14, step 15) |- ( A = B → B = if ( B R A , B , A ) ) ;;
	step 17 : wff = iftrue () |- ( B R A → if ( B R A , B , A ) = B ) ;;
	step 18 : wff = eqcomd (step 17) |- ( B R A → B = if ( B R A , B , A ) ) ;;
	step 19 : wff = jaoi (step 16, step 18) |- ( ( A = B ∨ B R A ) → B = if ( B R A , B , A ) ) ;;
	step 20 : wff = syl6bir (step 13, step 19) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → ( ¬ A R B → B = if ( B R A , B , A ) ) ) ;;
	step 21 : wff = imp (step 20) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ ¬ A R B ) → B = if ( B R A , B , A ) ) ;;
	step 22 : wff = eqtrd (step 11, step 21) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) ∧ ¬ A R B ) → if ( A R B , A , B ) = if ( B R A , B , A ) ) ;;
	step 23 : wff = pm2.61dan (step 9, step 22) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) = if ( B R A , B , A ) ) ;;
	qed prop 1 = step 23 ;;
}

/*Property of a minimum in a strict order.  (Contributed by Stefan O'Rear,
     17-Jan-2015.) */

theorem somin2 (A : class, B : class, R : class, X : class)  {
	prop 1 : wff = |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) ( R ∪ _I ) B ) ;;
}

proof of somin2 {
	step 1 : wff = somincom () |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) = if ( B R A , B , A ) ) ;;
	step 2 : wff = somin1 () |- ( ( R Or X ∧ ( B ∈ X ∧ A ∈ X ) ) → if ( B R A , B , A ) ( R ∪ _I ) B ) ;;
	step 3 : wff = ancom2s (step 2) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( B R A , B , A ) ( R ∪ _I ) B ) ;;
	step 4 : wff = eqbrtrd (step 1, step 3) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ) ) → if ( A R B , A , B ) ( R ∪ _I ) B ) ;;
	qed prop 1 = step 4 ;;
}

/*Being less than a minimum, for a general total order.  (Contributed by
     Stefan O'Rear, 17-Jan-2015.) */

theorem soltmin (A : class, B : class, C : class, R : class, X : class)  {
	prop 1 : wff = |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( A R if ( B R C , B , C ) ↔ ( A R B ∧ A R C ) ) ) ;;
}

proof of soltmin {
	step 1 : wff = sopo () |- ( R Or X → R Po X ) ;;
	step 2 : wff = ad2antrr (step 1) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → R Po X ) ;;
	step 3 : wff = simplr1 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → A ∈ X ) ;;
	step 4 : wff = simplr2 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → B ∈ X ) ;;
	step 5 : wff = simplr3 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → C ∈ X ) ;;
	step 6 : wff = ifcl () |- ( ( B ∈ X ∧ C ∈ X ) → if ( B R C , B , C ) ∈ X ) ;;
	step 7 : wff = syl2anc (step 4, step 5, step 6) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → if ( B R C , B , C ) ∈ X ) ;;
	step 8 : wff = simplr2 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → B ∈ X ) ;;
	step 9 : wff = 3jca (step 3, step 7, step 8) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → ( A ∈ X ∧ if ( B R C , B , C ) ∈ X ∧ B ∈ X ) ) ;;
	step 10 : wff = simpr () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → A R if ( B R C , B , C ) ) ;;
	step 11 : wff = simpll () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → R Or X ) ;;
	step 12 : wff = simplr2 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → B ∈ X ) ;;
	step 13 : wff = simplr3 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → C ∈ X ) ;;
	step 14 : wff = somin1 () |- ( ( R Or X ∧ ( B ∈ X ∧ C ∈ X ) ) → if ( B R C , B , C ) ( R ∪ _I ) B ) ;;
	step 15 : wff = syl12anc (step 11, step 12, step 13, step 14) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → if ( B R C , B , C ) ( R ∪ _I ) B ) ;;
	step 16 : wff = poltletr () |- ( ( R Po X ∧ ( A ∈ X ∧ if ( B R C , B , C ) ∈ X ∧ B ∈ X ) ) → ( ( A R if ( B R C , B , C ) ∧ if ( B R C , B , C ) ( R ∪ _I ) B ) → A R B ) ) ;;
	step 17 : wff = imp (step 16) |- ( ( ( R Po X ∧ ( A ∈ X ∧ if ( B R C , B , C ) ∈ X ∧ B ∈ X ) ) ∧ ( A R if ( B R C , B , C ) ∧ if ( B R C , B , C ) ( R ∪ _I ) B ) ) → A R B ) ;;
	step 18 : wff = syl22anc (step 2, step 9, step 10, step 15, step 17) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → A R B ) ;;
	step 19 : wff = sopo () |- ( R Or X → R Po X ) ;;
	step 20 : wff = ad2antrr (step 19) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → R Po X ) ;;
	step 21 : wff = simplr1 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → A ∈ X ) ;;
	step 22 : wff = simplr2 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → B ∈ X ) ;;
	step 23 : wff = simplr3 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → C ∈ X ) ;;
	step 24 : wff = ifcl () |- ( ( B ∈ X ∧ C ∈ X ) → if ( B R C , B , C ) ∈ X ) ;;
	step 25 : wff = syl2anc (step 22, step 23, step 24) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → if ( B R C , B , C ) ∈ X ) ;;
	step 26 : wff = simplr3 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → C ∈ X ) ;;
	step 27 : wff = 3jca (step 21, step 25, step 26) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → ( A ∈ X ∧ if ( B R C , B , C ) ∈ X ∧ C ∈ X ) ) ;;
	step 28 : wff = simpr () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → A R if ( B R C , B , C ) ) ;;
	step 29 : wff = simpll () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → R Or X ) ;;
	step 30 : wff = simplr2 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → B ∈ X ) ;;
	step 31 : wff = simplr3 () |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → C ∈ X ) ;;
	step 32 : wff = somin2 () |- ( ( R Or X ∧ ( B ∈ X ∧ C ∈ X ) ) → if ( B R C , B , C ) ( R ∪ _I ) C ) ;;
	step 33 : wff = syl12anc (step 29, step 30, step 31, step 32) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → if ( B R C , B , C ) ( R ∪ _I ) C ) ;;
	step 34 : wff = poltletr () |- ( ( R Po X ∧ ( A ∈ X ∧ if ( B R C , B , C ) ∈ X ∧ C ∈ X ) ) → ( ( A R if ( B R C , B , C ) ∧ if ( B R C , B , C ) ( R ∪ _I ) C ) → A R C ) ) ;;
	step 35 : wff = imp (step 34) |- ( ( ( R Po X ∧ ( A ∈ X ∧ if ( B R C , B , C ) ∈ X ∧ C ∈ X ) ) ∧ ( A R if ( B R C , B , C ) ∧ if ( B R C , B , C ) ( R ∪ _I ) C ) ) → A R C ) ;;
	step 36 : wff = syl22anc (step 20, step 27, step 28, step 33, step 35) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → A R C ) ;;
	step 37 : wff = jca (step 18, step 36) |- ( ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) ∧ A R if ( B R C , B , C ) ) → ( A R B ∧ A R C ) ) ;;
	step 38 : wff = ex (step 37) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( A R if ( B R C , B , C ) → ( A R B ∧ A R C ) ) ) ;;
	step 39 : wff = breq2 () |- ( B = if ( B R C , B , C ) → ( A R B ↔ A R if ( B R C , B , C ) ) ) ;;
	step 40 : wff = breq2 () |- ( C = if ( B R C , B , C ) → ( A R C ↔ A R if ( B R C , B , C ) ) ) ;;
	step 41 : wff = ifboth (step 39, step 40) |- ( ( A R B ∧ A R C ) → A R if ( B R C , B , C ) ) ;;
	step 42 : wff = impbid1 (step 38, step 41) |- ( ( R Or X ∧ ( A ∈ X ∧ B ∈ X ∧ C ∈ X ) ) → ( A R if ( B R C , B , C ) ↔ ( A R B ∧ A R C ) ) ) ;;
	qed prop 1 = step 42 ;;
}

/*The converse of a class abstraction of ordered pairs.  (Contributed by
       NM, 11-Dec-2003.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem cnvopab (ph : wff, x : set, y : set) disjointed(x y z w, z w ph) {
	prop 1 : wff = |- ⁻¹ { 〈 x , y 〉 | ph } = { 〈 y , x 〉 | ph } ;;
}

proof of cnvopab {
	var z : set, w : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ { 〈 x , y 〉 | ph } ;;
	step 2 : wff = relopab () |- Rel { 〈 y , x 〉 | ph } ;;
	step 3 : wff = opelopabsbOLD () |- ( 〈 w , z 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ z / y ] [ w / x ] ph ) ;;
	step 4 : wff = sbcom2 () |- ( [ z / y ] [ w / x ] ph ↔ [ w / x ] [ z / y ] ph ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( 〈 w , z 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / x ] [ z / y ] ph ) ;;
	step 6 : wff = vex () |- z ∈ _V ;;
	step 7 : wff = vex () |- w ∈ _V ;;
	step 8 : wff = opelcnv (step 6, step 7) |- ( 〈 z , w 〉 ∈ ⁻¹ { 〈 x , y 〉 | ph } ↔ 〈 w , z 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 9 : wff = opelopabsbOLD () |- ( 〈 z , w 〉 ∈ { 〈 y , x 〉 | ph } ↔ [ w / x ] [ z / y ] ph ) ;;
	step 10 : wff = 3bitr4i (step 5, step 8, step 9) |- ( 〈 z , w 〉 ∈ ⁻¹ { 〈 x , y 〉 | ph } ↔ 〈 z , w 〉 ∈ { 〈 y , x 〉 | ph } ) ;;
	step 11 : wff = eqrelriiv (step 1, step 2, step 10) |- ⁻¹ { 〈 x , y 〉 | ph } = { 〈 y , x 〉 | ph } ;;
	qed prop 1 = step 11 ;;
}

/*The converse of the empty set.  (Contributed by NM, 6-Apr-1998.) */

theorem cnv0 () disjointed(x y) {
	prop 1 : wff = |- ⁻¹ ∅ = ∅ ;;
}

proof of cnv0 {
	var x : set, y : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ ∅ ;;
	step 2 : wff = rel0 () |- Rel ∅ ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = opelcnv (step 3, step 4) |- ( 〈 x , y 〉 ∈ ⁻¹ ∅ ↔ 〈 y , x 〉 ∈ ∅ ) ;;
	step 6 : wff = noel () |- ¬ 〈 x , y 〉 ∈ ∅ ;;
	step 7 : wff = noel () |- ¬ 〈 y , x 〉 ∈ ∅ ;;
	step 8 : wff = 2false (step 6, step 7) |- ( 〈 x , y 〉 ∈ ∅ ↔ 〈 y , x 〉 ∈ ∅ ) ;;
	step 9 : wff = bitr4i (step 5, step 8) |- ( 〈 x , y 〉 ∈ ⁻¹ ∅ ↔ 〈 x , y 〉 ∈ ∅ ) ;;
	step 10 : wff = eqrelriiv (step 1, step 2, step 9) |- ⁻¹ ∅ = ∅ ;;
	qed prop 1 = step 10 ;;
}

/*The converse of the identity relation.  Theorem 3.7(ii) of [Monk1]
       p. 36.  (Contributed by NM, 26-Apr-1998.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem cnvi () disjointed(x y) {
	prop 1 : wff = |- ⁻¹ _I = _I ;;
}

proof of cnvi {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = ideq (step 1) |- ( y _I x ↔ y = x ) ;;
	step 3 : wff = equcom () |- ( y = x ↔ x = y ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( y _I x ↔ x = y ) ;;
	step 5 : wff = opabbii (step 4) |- { 〈 x , y 〉 | y _I x } = { 〈 x , y 〉 | x = y } ;;
	step 6 : wff = df-cnv () |- ⁻¹ _I = { 〈 x , y 〉 | y _I x } ;;
	step 7 : wff = df-id () |- _I = { 〈 x , y 〉 | x = y } ;;
	step 8 : wff = 3eqtr4i (step 5, step 6, step 7) |- ⁻¹ _I = _I ;;
	qed prop 1 = step 8 ;;
}

/*The converse of a union is the union of converses.  Theorem 16 of
       [Suppes] p. 62.  (Contributed by NM, 25-Mar-1998.)  (Proof shortened by
       Andrew Salmon, 27-Aug-2011.) */

theorem cnvun (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⁻¹ ( A ∪ B ) = ( ⁻¹ A ∪ ⁻¹ B ) ;;
}

proof of cnvun {
	var x : set, y : set;;
	step 1 : wff = df-cnv () |- ⁻¹ ( A ∪ B ) = { 〈 x , y 〉 | y ( A ∪ B ) x } ;;
	step 2 : wff = unopab () |- ( { 〈 x , y 〉 | y A x } ∪ { 〈 x , y 〉 | y B x } ) = { 〈 x , y 〉 | ( y A x ∨ y B x ) } ;;
	step 3 : wff = brun () |- ( y ( A ∪ B ) x ↔ ( y A x ∨ y B x ) ) ;;
	step 4 : wff = opabbii (step 3) |- { 〈 x , y 〉 | y ( A ∪ B ) x } = { 〈 x , y 〉 | ( y A x ∨ y B x ) } ;;
	step 5 : wff = eqtr4i (step 2, step 4) |- ( { 〈 x , y 〉 | y A x } ∪ { 〈 x , y 〉 | y B x } ) = { 〈 x , y 〉 | y ( A ∪ B ) x } ;;
	step 6 : wff = eqtr4i (step 1, step 5) |- ⁻¹ ( A ∪ B ) = ( { 〈 x , y 〉 | y A x } ∪ { 〈 x , y 〉 | y B x } ) ;;
	step 7 : wff = df-cnv () |- ⁻¹ A = { 〈 x , y 〉 | y A x } ;;
	step 8 : wff = df-cnv () |- ⁻¹ B = { 〈 x , y 〉 | y B x } ;;
	step 9 : wff = uneq12i (step 7, step 8) |- ( ⁻¹ A ∪ ⁻¹ B ) = ( { 〈 x , y 〉 | y A x } ∪ { 〈 x , y 〉 | y B x } ) ;;
	step 10 : wff = eqtr4i (step 6, step 9) |- ⁻¹ ( A ∪ B ) = ( ⁻¹ A ∪ ⁻¹ B ) ;;
	qed prop 1 = step 10 ;;
}

/*Distributive law for converse over set difference.  (Contributed by
       Mario Carneiro, 26-Jun-2014.) */

theorem cnvdif (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⁻¹ ( A ∖ B ) = ( ⁻¹ A ∖ ⁻¹ B ) ;;
}

proof of cnvdif {
	var x : set, y : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ ( A ∖ B ) ;;
	step 2 : wff = difss () |- ( ⁻¹ A ∖ ⁻¹ B ) ⊆ ⁻¹ A ;;
	step 3 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 4 : wff = relss () |- ( ( ⁻¹ A ∖ ⁻¹ B ) ⊆ ⁻¹ A → ( Rel ⁻¹ A → Rel ( ⁻¹ A ∖ ⁻¹ B ) ) ) ;;
	step 5 : wff = mp2 (step 2, step 3, step 4) |- Rel ( ⁻¹ A ∖ ⁻¹ B ) ;;
	step 6 : wff = eldif () |- ( 〈 y , x 〉 ∈ ( A ∖ B ) ↔ ( 〈 y , x 〉 ∈ A ∧ ¬ 〈 y , x 〉 ∈ B ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opelcnv (step 7, step 8) |- ( 〈 x , y 〉 ∈ ⁻¹ ( A ∖ B ) ↔ 〈 y , x 〉 ∈ ( A ∖ B ) ) ;;
	step 10 : wff = eldif () |- ( 〈 x , y 〉 ∈ ( ⁻¹ A ∖ ⁻¹ B ) ↔ ( 〈 x , y 〉 ∈ ⁻¹ A ∧ ¬ 〈 x , y 〉 ∈ ⁻¹ B ) ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = opelcnv (step 11, step 12) |- ( 〈 x , y 〉 ∈ ⁻¹ A ↔ 〈 y , x 〉 ∈ A ) ;;
	step 14 : wff = vex () |- x ∈ _V ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = opelcnv (step 14, step 15) |- ( 〈 x , y 〉 ∈ ⁻¹ B ↔ 〈 y , x 〉 ∈ B ) ;;
	step 17 : wff = notbii (step 16) |- ( ¬ 〈 x , y 〉 ∈ ⁻¹ B ↔ ¬ 〈 y , x 〉 ∈ B ) ;;
	step 18 : wff = anbi12i (step 13, step 17) |- ( ( 〈 x , y 〉 ∈ ⁻¹ A ∧ ¬ 〈 x , y 〉 ∈ ⁻¹ B ) ↔ ( 〈 y , x 〉 ∈ A ∧ ¬ 〈 y , x 〉 ∈ B ) ) ;;
	step 19 : wff = bitri (step 10, step 18) |- ( 〈 x , y 〉 ∈ ( ⁻¹ A ∖ ⁻¹ B ) ↔ ( 〈 y , x 〉 ∈ A ∧ ¬ 〈 y , x 〉 ∈ B ) ) ;;
	step 20 : wff = 3bitr4i (step 6, step 9, step 19) |- ( 〈 x , y 〉 ∈ ⁻¹ ( A ∖ B ) ↔ 〈 x , y 〉 ∈ ( ⁻¹ A ∖ ⁻¹ B ) ) ;;
	step 21 : wff = eqrelriiv (step 1, step 5, step 20) |- ⁻¹ ( A ∖ B ) = ( ⁻¹ A ∖ ⁻¹ B ) ;;
	qed prop 1 = step 21 ;;
}

/*Distributive law for converse over intersection.  Theorem 15 of [Suppes]
       p. 62.  (Contributed by NM, 25-Mar-1998.)  (Revised by Mario Carneiro,
       26-Jun-2014.) */

theorem cnvin (A : class, B : class) disjointed(A, B) {
	prop 1 : wff = |- ⁻¹ ( A ∩ B ) = ( ⁻¹ A ∩ ⁻¹ B ) ;;
}

proof of cnvin {
	step 1 : wff = cnvdif () |- ⁻¹ ( A ∖ ( A ∖ B ) ) = ( ⁻¹ A ∖ ⁻¹ ( A ∖ B ) ) ;;
	step 2 : wff = cnvdif () |- ⁻¹ ( A ∖ B ) = ( ⁻¹ A ∖ ⁻¹ B ) ;;
	step 3 : wff = difeq2i (step 2) |- ( ⁻¹ A ∖ ⁻¹ ( A ∖ B ) ) = ( ⁻¹ A ∖ ( ⁻¹ A ∖ ⁻¹ B ) ) ;;
	step 4 : wff = eqtri (step 1, step 3) |- ⁻¹ ( A ∖ ( A ∖ B ) ) = ( ⁻¹ A ∖ ( ⁻¹ A ∖ ⁻¹ B ) ) ;;
	step 5 : wff = dfin4 () |- ( A ∩ B ) = ( A ∖ ( A ∖ B ) ) ;;
	step 6 : wff = cnveqi (step 5) |- ⁻¹ ( A ∩ B ) = ⁻¹ ( A ∖ ( A ∖ B ) ) ;;
	step 7 : wff = dfin4 () |- ( ⁻¹ A ∩ ⁻¹ B ) = ( ⁻¹ A ∖ ( ⁻¹ A ∖ ⁻¹ B ) ) ;;
	step 8 : wff = 3eqtr4i (step 4, step 6, step 7) |- ⁻¹ ( A ∩ B ) = ( ⁻¹ A ∩ ⁻¹ B ) ;;
	qed prop 1 = step 8 ;;
}

/*Distributive law for range over union.  Theorem 8 of [Suppes] p. 60.
     (Contributed by NM, 24-Mar-1998.) */

theorem rnun (A : class, B : class)  {
	prop 1 : wff = |- ran ( A ∪ B ) = ( ran A ∪ ran B ) ;;
}

proof of rnun {
	step 1 : wff = cnvun () |- ⁻¹ ( A ∪ B ) = ( ⁻¹ A ∪ ⁻¹ B ) ;;
	step 2 : wff = dmeqi (step 1) |- dom ⁻¹ ( A ∪ B ) = dom ( ⁻¹ A ∪ ⁻¹ B ) ;;
	step 3 : wff = dmun () |- dom ( ⁻¹ A ∪ ⁻¹ B ) = ( dom ⁻¹ A ∪ dom ⁻¹ B ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- dom ⁻¹ ( A ∪ B ) = ( dom ⁻¹ A ∪ dom ⁻¹ B ) ;;
	step 5 : wff = df-rn () |- ran ( A ∪ B ) = dom ⁻¹ ( A ∪ B ) ;;
	step 6 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 7 : wff = df-rn () |- ran B = dom ⁻¹ B ;;
	step 8 : wff = uneq12i (step 6, step 7) |- ( ran A ∪ ran B ) = ( dom ⁻¹ A ∪ dom ⁻¹ B ) ;;
	step 9 : wff = 3eqtr4i (step 4, step 5, step 8) |- ran ( A ∪ B ) = ( ran A ∪ ran B ) ;;
	qed prop 1 = step 9 ;;
}

/*The range of an intersection belongs the intersection of ranges.  Theorem
     9 of [Suppes] p. 60.  (Contributed by NM, 15-Sep-2004.) */

theorem rnin (A : class, B : class)  {
	prop 1 : wff = |- ran ( A ∩ B ) ⊆ ( ran A ∩ ran B ) ;;
}

proof of rnin {
	step 1 : wff = cnvin () |- ⁻¹ ( A ∩ B ) = ( ⁻¹ A ∩ ⁻¹ B ) ;;
	step 2 : wff = dmeqi (step 1) |- dom ⁻¹ ( A ∩ B ) = dom ( ⁻¹ A ∩ ⁻¹ B ) ;;
	step 3 : wff = dmin () |- dom ( ⁻¹ A ∩ ⁻¹ B ) ⊆ ( dom ⁻¹ A ∩ dom ⁻¹ B ) ;;
	step 4 : wff = eqsstri (step 2, step 3) |- dom ⁻¹ ( A ∩ B ) ⊆ ( dom ⁻¹ A ∩ dom ⁻¹ B ) ;;
	step 5 : wff = df-rn () |- ran ( A ∩ B ) = dom ⁻¹ ( A ∩ B ) ;;
	step 6 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 7 : wff = df-rn () |- ran B = dom ⁻¹ B ;;
	step 8 : wff = ineq12i (step 6, step 7) |- ( ran A ∩ ran B ) = ( dom ⁻¹ A ∩ dom ⁻¹ B ) ;;
	step 9 : wff = 3sstr4i (step 4, step 5, step 8) |- ran ( A ∩ B ) ⊆ ( ran A ∩ ran B ) ;;
	qed prop 1 = step 9 ;;
}

/*The range of an indexed union.  (Contributed by Mario Carneiro,
       29-May-2015.) */

theorem rniun (x : set, A : class, B : class) disjointed(x y z, y z A, y z B) {
	prop 1 : wff = |- ran ⋃_ x ∈ A B = ⋃_ x ∈ A ran B ;;
}

proof of rniun {
	var y : set, z : set;;
	step 1 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ y 〈 y , z 〉 ∈ B ↔ ∃ y ∃ x ∈ A 〈 y , z 〉 ∈ B ) ;;
	step 2 : wff = vex () |- z ∈ _V ;;
	step 3 : wff = elrn2 (step 2) |- ( z ∈ ran B ↔ ∃ y 〈 y , z 〉 ∈ B ) ;;
	step 4 : wff = rexbii (step 3) |- ( ∃ x ∈ A z ∈ ran B ↔ ∃ x ∈ A ∃ y 〈 y , z 〉 ∈ B ) ;;
	step 5 : wff = eliun () |- ( 〈 y , z 〉 ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A 〈 y , z 〉 ∈ B ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y 〈 y , z 〉 ∈ ⋃_ x ∈ A B ↔ ∃ y ∃ x ∈ A 〈 y , z 〉 ∈ B ) ;;
	step 7 : wff = 3bitr4ri (step 1, step 4, step 6) |- ( ∃ y 〈 y , z 〉 ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A z ∈ ran B ) ;;
	step 8 : wff = vex () |- z ∈ _V ;;
	step 9 : wff = elrn2 (step 8) |- ( z ∈ ran ⋃_ x ∈ A B ↔ ∃ y 〈 y , z 〉 ∈ ⋃_ x ∈ A B ) ;;
	step 10 : wff = eliun () |- ( z ∈ ⋃_ x ∈ A ran B ↔ ∃ x ∈ A z ∈ ran B ) ;;
	step 11 : wff = 3bitr4i (step 7, step 9, step 10) |- ( z ∈ ran ⋃_ x ∈ A B ↔ z ∈ ⋃_ x ∈ A ran B ) ;;
	step 12 : wff = eqriv (step 11) |- ran ⋃_ x ∈ A B = ⋃_ x ∈ A ran B ;;
	qed prop 1 = step 12 ;;
}

/*The range of a union.  Part of Exercise 8 of [Enderton] p. 41.
       (Contributed by NM, 17-Mar-2004.)  (Revised by Mario Carneiro,
       29-May-2015.) */

theorem rnuni (x : set, A : class) disjointed(x, A, x A) {
	prop 1 : wff = |- ran ⋃ A = ⋃_ x ∈ A ran x ;;
}

proof of rnuni {
	step 1 : wff = uniiun () |- ⋃ A = ⋃_ x ∈ A x ;;
	step 2 : wff = rneqi (step 1) |- ran ⋃ A = ran ⋃_ x ∈ A x ;;
	step 3 : wff = rniun () |- ran ⋃_ x ∈ A x = ⋃_ x ∈ A ran x ;;
	step 4 : wff = eqtri (step 2, step 3) |- ran ⋃ A = ⋃_ x ∈ A ran x ;;
	qed prop 1 = step 4 ;;
}

/*Distributive law for image over union.  Theorem 35 of [Suppes] p. 65.
     (Contributed by NM, 30-Sep-2002.) */

theorem imaundi (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A " ( B ∪ C ) ) = ( ( A " B ) ∪ ( A " C ) ) ;;
}

proof of imaundi {
	step 1 : wff = resundi () |- ( A ↾ ( B ∪ C ) ) = ( ( A ↾ B ) ∪ ( A ↾ C ) ) ;;
	step 2 : wff = rneqi (step 1) |- ran ( A ↾ ( B ∪ C ) ) = ran ( ( A ↾ B ) ∪ ( A ↾ C ) ) ;;
	step 3 : wff = rnun () |- ran ( ( A ↾ B ) ∪ ( A ↾ C ) ) = ( ran ( A ↾ B ) ∪ ran ( A ↾ C ) ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- ran ( A ↾ ( B ∪ C ) ) = ( ran ( A ↾ B ) ∪ ran ( A ↾ C ) ) ;;
	step 5 : wff = df-ima () |- ( A " ( B ∪ C ) ) = ran ( A ↾ ( B ∪ C ) ) ;;
	step 6 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 7 : wff = df-ima () |- ( A " C ) = ran ( A ↾ C ) ;;
	step 8 : wff = uneq12i (step 6, step 7) |- ( ( A " B ) ∪ ( A " C ) ) = ( ran ( A ↾ B ) ∪ ran ( A ↾ C ) ) ;;
	step 9 : wff = 3eqtr4i (step 4, step 5, step 8) |- ( A " ( B ∪ C ) ) = ( ( A " B ) ∪ ( A " C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*The image of a union.  (Contributed by Jeff Hoffman, 17-Feb-2008.) */

theorem imaundir (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∪ B ) " C ) = ( ( A " C ) ∪ ( B " C ) ) ;;
}

proof of imaundir {
	step 1 : wff = df-ima () |- ( ( A ∪ B ) " C ) = ran ( ( A ∪ B ) ↾ C ) ;;
	step 2 : wff = resundir () |- ( ( A ∪ B ) ↾ C ) = ( ( A ↾ C ) ∪ ( B ↾ C ) ) ;;
	step 3 : wff = rneqi (step 2) |- ran ( ( A ∪ B ) ↾ C ) = ran ( ( A ↾ C ) ∪ ( B ↾ C ) ) ;;
	step 4 : wff = rnun () |- ran ( ( A ↾ C ) ∪ ( B ↾ C ) ) = ( ran ( A ↾ C ) ∪ ran ( B ↾ C ) ) ;;
	step 5 : wff = 3eqtri (step 1, step 3, step 4) |- ( ( A ∪ B ) " C ) = ( ran ( A ↾ C ) ∪ ran ( B ↾ C ) ) ;;
	step 6 : wff = df-ima () |- ( A " C ) = ran ( A ↾ C ) ;;
	step 7 : wff = df-ima () |- ( B " C ) = ran ( B ↾ C ) ;;
	step 8 : wff = uneq12i (step 6, step 7) |- ( ( A " C ) ∪ ( B " C ) ) = ( ran ( A ↾ C ) ∪ ran ( B ↾ C ) ) ;;
	step 9 : wff = eqtr4i (step 5, step 8) |- ( ( A ∪ B ) " C ) = ( ( A " C ) ∪ ( B " C ) ) ;;
	qed prop 1 = step 9 ;;
}

/*An upper bound for intersection with a domain.  Theorem 40 of [Suppes]
       p. 66, who calls it "somewhat surprising."  (Contributed by NM,
       11-Aug-2004.) */

theorem dminss (A : class, R : class) disjointed(x y A, x y, x y R) {
	prop 1 : wff = |- ( dom R ∩ A ) ⊆ ( ⁻¹ R " ( R " A ) ) ;;
}

proof of dminss {
	var x : set, y : set;;
	step 1 : wff = 19.8a () |- ( ( x ∈ A ∧ x R y ) → ∃ x ( x ∈ A ∧ x R y ) ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( x R y ∧ x ∈ A ) → ∃ x ( x ∈ A ∧ x R y ) ) ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = elima2 (step 3) |- ( y ∈ ( R " A ) ↔ ∃ x ( x ∈ A ∧ x R y ) ) ;;
	step 5 : wff = sylibr (step 2, step 4) |- ( ( x R y ∧ x ∈ A ) → y ∈ ( R " A ) ) ;;
	step 6 : wff = simpl () |- ( ( x R y ∧ x ∈ A ) → x R y ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = brcnv (step 7, step 8) |- ( y ⁻¹ R x ↔ x R y ) ;;
	step 10 : wff = sylibr (step 6, step 9) |- ( ( x R y ∧ x ∈ A ) → y ⁻¹ R x ) ;;
	step 11 : wff = jca (step 5, step 10) |- ( ( x R y ∧ x ∈ A ) → ( y ∈ ( R " A ) ∧ y ⁻¹ R x ) ) ;;
	step 12 : wff = eximi (step 11) |- ( ∃ y ( x R y ∧ x ∈ A ) → ∃ y ( y ∈ ( R " A ) ∧ y ⁻¹ R x ) ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = eldm (step 13) |- ( x ∈ dom R ↔ ∃ y x R y ) ;;
	step 15 : wff = anbi1i (step 14) |- ( ( x ∈ dom R ∧ x ∈ A ) ↔ ( ∃ y x R y ∧ x ∈ A ) ) ;;
	step 16 : wff = elin () |- ( x ∈ ( dom R ∩ A ) ↔ ( x ∈ dom R ∧ x ∈ A ) ) ;;
	step 17 : wff = 19.41v () |- ( ∃ y ( x R y ∧ x ∈ A ) ↔ ( ∃ y x R y ∧ x ∈ A ) ) ;;
	step 18 : wff = 3bitr4i (step 15, step 16, step 17) |- ( x ∈ ( dom R ∩ A ) ↔ ∃ y ( x R y ∧ x ∈ A ) ) ;;
	step 19 : wff = vex () |- x ∈ _V ;;
	step 20 : wff = elima2 (step 19) |- ( x ∈ ( ⁻¹ R " ( R " A ) ) ↔ ∃ y ( y ∈ ( R " A ) ∧ y ⁻¹ R x ) ) ;;
	step 21 : wff = 3imtr4i (step 12, step 18, step 20) |- ( x ∈ ( dom R ∩ A ) → x ∈ ( ⁻¹ R " ( R " A ) ) ) ;;
	step 22 : wff = ssriv (step 21) |- ( dom R ∩ A ) ⊆ ( ⁻¹ R " ( R " A ) ) ;;
	qed prop 1 = step 22 ;;
}

/*An upper bound for intersection with an image.  Theorem 41 of [Suppes]
       p. 66.  (Contributed by NM, 11-Aug-2004.) */

theorem imainss (A : class, B : class, R : class) disjointed(x y A, x y B, x y R) {
	prop 1 : wff = |- ( ( R " A ) ∩ B ) ⊆ ( R " ( A ∩ ( ⁻¹ R " B ) ) ) ;;
}

proof of imainss {
	var x : set, y : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = brcnv (step 1, step 2) |- ( y ⁻¹ R x ↔ x R y ) ;;
	step 4 : wff = 19.8a () |- ( ( y ∈ B ∧ y ⁻¹ R x ) → ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ;;
	step 5 : wff = sylan2br (step 3, step 4) |- ( ( y ∈ B ∧ x R y ) → ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ;;
	step 6 : wff = ancoms (step 5) |- ( ( x R y ∧ y ∈ B ) → ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( x ∈ A ∧ ( x R y ∧ y ∈ B ) ) → ( x ∈ A ∧ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ) ;;
	step 8 : wff = simprl () |- ( ( x ∈ A ∧ ( x R y ∧ y ∈ B ) ) → x R y ) ;;
	step 9 : wff = jca (step 7, step 8) |- ( ( x ∈ A ∧ ( x R y ∧ y ∈ B ) ) → ( ( x ∈ A ∧ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ∧ x R y ) ) ;;
	step 10 : wff = anassrs (step 9) |- ( ( ( x ∈ A ∧ x R y ) ∧ y ∈ B ) → ( ( x ∈ A ∧ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ∧ x R y ) ) ;;
	step 11 : wff = elin () |- ( x ∈ ( A ∩ ( ⁻¹ R " B ) ) ↔ ( x ∈ A ∧ x ∈ ( ⁻¹ R " B ) ) ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = elima2 (step 12) |- ( x ∈ ( ⁻¹ R " B ) ↔ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ;;
	step 14 : wff = anbi2i (step 13) |- ( ( x ∈ A ∧ x ∈ ( ⁻¹ R " B ) ) ↔ ( x ∈ A ∧ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ) ;;
	step 15 : wff = bitri (step 11, step 14) |- ( x ∈ ( A ∩ ( ⁻¹ R " B ) ) ↔ ( x ∈ A ∧ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ) ;;
	step 16 : wff = anbi1i (step 15) |- ( ( x ∈ ( A ∩ ( ⁻¹ R " B ) ) ∧ x R y ) ↔ ( ( x ∈ A ∧ ∃ y ( y ∈ B ∧ y ⁻¹ R x ) ) ∧ x R y ) ) ;;
	step 17 : wff = sylibr (step 10, step 16) |- ( ( ( x ∈ A ∧ x R y ) ∧ y ∈ B ) → ( x ∈ ( A ∩ ( ⁻¹ R " B ) ) ∧ x R y ) ) ;;
	step 18 : wff = eximi (step 17) |- ( ∃ x ( ( x ∈ A ∧ x R y ) ∧ y ∈ B ) → ∃ x ( x ∈ ( A ∩ ( ⁻¹ R " B ) ) ∧ x R y ) ) ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = elima2 (step 19) |- ( y ∈ ( R " A ) ↔ ∃ x ( x ∈ A ∧ x R y ) ) ;;
	step 21 : wff = anbi1i (step 20) |- ( ( y ∈ ( R " A ) ∧ y ∈ B ) ↔ ( ∃ x ( x ∈ A ∧ x R y ) ∧ y ∈ B ) ) ;;
	step 22 : wff = elin () |- ( y ∈ ( ( R " A ) ∩ B ) ↔ ( y ∈ ( R " A ) ∧ y ∈ B ) ) ;;
	step 23 : wff = 19.41v () |- ( ∃ x ( ( x ∈ A ∧ x R y ) ∧ y ∈ B ) ↔ ( ∃ x ( x ∈ A ∧ x R y ) ∧ y ∈ B ) ) ;;
	step 24 : wff = 3bitr4i (step 21, step 22, step 23) |- ( y ∈ ( ( R " A ) ∩ B ) ↔ ∃ x ( ( x ∈ A ∧ x R y ) ∧ y ∈ B ) ) ;;
	step 25 : wff = vex () |- y ∈ _V ;;
	step 26 : wff = elima2 (step 25) |- ( y ∈ ( R " ( A ∩ ( ⁻¹ R " B ) ) ) ↔ ∃ x ( x ∈ ( A ∩ ( ⁻¹ R " B ) ) ∧ x R y ) ) ;;
	step 27 : wff = 3imtr4i (step 18, step 24, step 26) |- ( y ∈ ( ( R " A ) ∩ B ) → y ∈ ( R " ( A ∩ ( ⁻¹ R " B ) ) ) ) ;;
	step 28 : wff = ssriv (step 27) |- ( ( R " A ) ∩ B ) ⊆ ( R " ( A ∩ ( ⁻¹ R " B ) ) ) ;;
	qed prop 1 = step 28 ;;
}

/*The converse of a cross product.  Exercise 11 of [Suppes] p. 67.
       (Contributed by NM, 14-Aug-1999.)  (Proof shortened by Andrew Salmon,
       27-Aug-2011.) */

theorem cnvxp (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⁻¹ ( A × B ) = ( B × A ) ;;
}

proof of cnvxp {
	var x : set, y : set;;
	step 1 : wff = cnvopab () |- ⁻¹ { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } = { 〈 x , y 〉 | ( y ∈ A ∧ x ∈ B ) } ;;
	step 2 : wff = ancom () |- ( ( y ∈ A ∧ x ∈ B ) ↔ ( x ∈ B ∧ y ∈ A ) ) ;;
	step 3 : wff = opabbii (step 2) |- { 〈 x , y 〉 | ( y ∈ A ∧ x ∈ B ) } = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ A ) } ;;
	step 4 : wff = eqtri (step 1, step 3) |- ⁻¹ { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ A ) } ;;
	step 5 : wff = df-xp () |- ( A × B ) = { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } ;;
	step 6 : wff = cnveqi (step 5) |- ⁻¹ ( A × B ) = ⁻¹ { 〈 y , x 〉 | ( y ∈ A ∧ x ∈ B ) } ;;
	step 7 : wff = df-xp () |- ( B × A ) = { 〈 x , y 〉 | ( x ∈ B ∧ y ∈ A ) } ;;
	step 8 : wff = 3eqtr4i (step 4, step 6, step 7) |- ⁻¹ ( A × B ) = ( B × A ) ;;
	qed prop 1 = step 8 ;;
}

/*The cross product with the empty set is empty.  Part of Theorem 3.13(ii)
     of [Monk1] p. 37.  (Contributed by NM, 12-Apr-2004.) */

theorem xp0 (A : class)  {
	prop 1 : wff = |- ( A × ∅ ) = ∅ ;;
}

proof of xp0 {
	step 1 : wff = xp0r () |- ( ∅ × A ) = ∅ ;;
	step 2 : wff = cnveqi (step 1) |- ⁻¹ ( ∅ × A ) = ⁻¹ ∅ ;;
	step 3 : wff = cnvxp () |- ⁻¹ ( ∅ × A ) = ( A × ∅ ) ;;
	step 4 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 5 : wff = 3eqtr3i (step 2, step 3, step 4) |- ( A × ∅ ) = ∅ ;;
	qed prop 1 = step 5 ;;
}

/*The cross product of nonempty classes is nonempty.  (Variation of a
       theorem contributed by Raph Levien, 30-Jun-2006.)  (Contributed by NM,
       30-Jun-2006.) */

theorem xpnz (A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
}

proof of xpnz {
	var x : set, y : set, z : set;;
	step 1 : wff = n0 () |- ( A ≠ ∅ ↔ ∃ x x ∈ A ) ;;
	step 2 : wff = n0 () |- ( B ≠ ∅ ↔ ∃ y y ∈ B ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( ∃ x x ∈ A ∧ ∃ y y ∈ B ) ) ;;
	step 4 : wff = eeanv () |- ( ∃ x ∃ y ( x ∈ A ∧ y ∈ B ) ↔ ( ∃ x x ∈ A ∧ ∃ y y ∈ B ) ) ;;
	step 5 : wff = bitr4i (step 3, step 4) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ∃ x ∃ y ( x ∈ A ∧ y ∈ B ) ) ;;
	step 6 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 7 : wff = eleq1 () |- ( z = 〈 x , y 〉 → ( z ∈ ( A × B ) ↔ 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 8 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 9 : wff = syl6bb (step 7, step 8) |- ( z = 〈 x , y 〉 → ( z ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 10 : wff = spcev (step 6, step 9) |- ( ( x ∈ A ∧ y ∈ B ) → ∃ z z ∈ ( A × B ) ) ;;
	step 11 : wff = n0 () |- ( ( A × B ) ≠ ∅ ↔ ∃ z z ∈ ( A × B ) ) ;;
	step 12 : wff = sylibr (step 10, step 11) |- ( ( x ∈ A ∧ y ∈ B ) → ( A × B ) ≠ ∅ ) ;;
	step 13 : wff = exlimivv (step 12) |- ( ∃ x ∃ y ( x ∈ A ∧ y ∈ B ) → ( A × B ) ≠ ∅ ) ;;
	step 14 : wff = sylbi (step 5, step 13) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) → ( A × B ) ≠ ∅ ) ;;
	step 15 : wff = xpeq1 () |- ( A = ∅ → ( A × B ) = ( ∅ × B ) ) ;;
	step 16 : wff = xp0r () |- ( ∅ × B ) = ∅ ;;
	step 17 : wff = syl6eq (step 15, step 16) |- ( A = ∅ → ( A × B ) = ∅ ) ;;
	step 18 : wff = necon3i (step 17) |- ( ( A × B ) ≠ ∅ → A ≠ ∅ ) ;;
	step 19 : wff = xpeq2 () |- ( B = ∅ → ( A × B ) = ( A × ∅ ) ) ;;
	step 20 : wff = xp0 () |- ( A × ∅ ) = ∅ ;;
	step 21 : wff = syl6eq (step 19, step 20) |- ( B = ∅ → ( A × B ) = ∅ ) ;;
	step 22 : wff = necon3i (step 21) |- ( ( A × B ) ≠ ∅ → B ≠ ∅ ) ;;
	step 23 : wff = jca (step 18, step 22) |- ( ( A × B ) ≠ ∅ → ( A ≠ ∅ ∧ B ≠ ∅ ) ) ;;
	step 24 : wff = impbii (step 14, step 23) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	qed prop 1 = step 24 ;;
}

/*At least one member of an empty cross product is empty.  (Contributed by
     NM, 27-Aug-2006.) */

theorem xpeq0 (A : class, B : class)  {
	prop 1 : wff = |- ( ( A × B ) = ∅ ↔ ( A = ∅ ∨ B = ∅ ) ) ;;
}

proof of xpeq0 {
	step 1 : wff = xpnz () |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 2 : wff = necon2bbii (step 1) |- ( ( A × B ) = ∅ ↔ ¬ ( A ≠ ∅ ∧ B ≠ ∅ ) ) ;;
	step 3 : wff = ianor () |- ( ¬ ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( ¬ A ≠ ∅ ∨ ¬ B ≠ ∅ ) ) ;;
	step 4 : wff = nne () |- ( ¬ A ≠ ∅ ↔ A = ∅ ) ;;
	step 5 : wff = nne () |- ( ¬ B ≠ ∅ ↔ B = ∅ ) ;;
	step 6 : wff = orbi12i (step 4, step 5) |- ( ( ¬ A ≠ ∅ ∨ ¬ B ≠ ∅ ) ↔ ( A = ∅ ∨ B = ∅ ) ) ;;
	step 7 : wff = 3bitri (step 2, step 3, step 6) |- ( ( A × B ) = ∅ ↔ ( A = ∅ ∨ B = ∅ ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Cross products with disjoint sets are disjoint.  (Contributed by NM,
     13-Sep-2004.) */

theorem xpdisj1 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A ∩ B ) = ∅ → ( ( A × C ) ∩ ( B × D ) ) = ∅ ) ;;
}

proof of xpdisj1 {
	step 1 : wff = inxp () |- ( ( A × C ) ∩ ( B × D ) ) = ( ( A ∩ B ) × ( C ∩ D ) ) ;;
	step 2 : wff = xpeq1 () |- ( ( A ∩ B ) = ∅ → ( ( A ∩ B ) × ( C ∩ D ) ) = ( ∅ × ( C ∩ D ) ) ) ;;
	step 3 : wff = xp0r () |- ( ∅ × ( C ∩ D ) ) = ∅ ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( ( A ∩ B ) = ∅ → ( ( A ∩ B ) × ( C ∩ D ) ) = ∅ ) ;;
	step 5 : wff = syl5eq (step 1, step 4) |- ( ( A ∩ B ) = ∅ → ( ( A × C ) ∩ ( B × D ) ) = ∅ ) ;;
	qed prop 1 = step 5 ;;
}

/*Cross products with disjoint sets are disjoint.  (Contributed by NM,
     13-Sep-2004.) */

theorem xpdisj2 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A ∩ B ) = ∅ → ( ( C × A ) ∩ ( D × B ) ) = ∅ ) ;;
}

proof of xpdisj2 {
	step 1 : wff = inxp () |- ( ( C × A ) ∩ ( D × B ) ) = ( ( C ∩ D ) × ( A ∩ B ) ) ;;
	step 2 : wff = xpeq2 () |- ( ( A ∩ B ) = ∅ → ( ( C ∩ D ) × ( A ∩ B ) ) = ( ( C ∩ D ) × ∅ ) ) ;;
	step 3 : wff = xp0 () |- ( ( C ∩ D ) × ∅ ) = ∅ ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( ( A ∩ B ) = ∅ → ( ( C ∩ D ) × ( A ∩ B ) ) = ∅ ) ;;
	step 5 : wff = syl5eq (step 1, step 4) |- ( ( A ∩ B ) = ∅ → ( ( C × A ) ∩ ( D × B ) ) = ∅ ) ;;
	qed prop 1 = step 5 ;;
}

/*Cross products with two different singletons are disjoint.  (Contributed
     by NM, 28-Jul-2004.) */

theorem xpsndisj (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( B ≠ D → ( ( A × { B } ) ∩ ( C × { D } ) ) = ∅ ) ;;
}

proof of xpsndisj {
	step 1 : wff = disjsn2 () |- ( B ≠ D → ( { B } ∩ { D } ) = ∅ ) ;;
	step 2 : wff = xpdisj2 () |- ( ( { B } ∩ { D } ) = ∅ → ( ( A × { B } ) ∩ ( C × { D } ) ) = ∅ ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( B ≠ D → ( ( A × { B } ) ∩ ( C × { D } ) ) = ∅ ) ;;
	qed prop 1 = step 3 ;;
}

/*Disjoint unions with disjoint index sets are disjoint.  (Contributed by
       Stefan O'Rear, 21-Nov-2014.) */

theorem djudisj (x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x A, y B) {
	prop 1 : wff = |- ( ( A ∩ B ) = ∅ → ( ⋃_ x ∈ A ( { x } × C ) ∩ ⋃_ y ∈ B ( { y } × D ) ) = ∅ ) ;;
}

proof of djudisj {
	step 1 : wff = djussxp () |- ⋃_ x ∈ A ( { x } × C ) ⊆ ( A × _V ) ;;
	step 2 : wff = incom () |- ( ( A × _V ) ∩ ⋃_ y ∈ B ( { y } × D ) ) = ( ⋃_ y ∈ B ( { y } × D ) ∩ ( A × _V ) ) ;;
	step 3 : wff = djussxp () |- ⋃_ y ∈ B ( { y } × D ) ⊆ ( B × _V ) ;;
	step 4 : wff = incom () |- ( ( B × _V ) ∩ ( A × _V ) ) = ( ( A × _V ) ∩ ( B × _V ) ) ;;
	step 5 : wff = xpdisj1 () |- ( ( A ∩ B ) = ∅ → ( ( A × _V ) ∩ ( B × _V ) ) = ∅ ) ;;
	step 6 : wff = syl5eq (step 4, step 5) |- ( ( A ∩ B ) = ∅ → ( ( B × _V ) ∩ ( A × _V ) ) = ∅ ) ;;
	step 7 : wff = ssdisj () |- ( ( ⋃_ y ∈ B ( { y } × D ) ⊆ ( B × _V ) ∧ ( ( B × _V ) ∩ ( A × _V ) ) = ∅ ) → ( ⋃_ y ∈ B ( { y } × D ) ∩ ( A × _V ) ) = ∅ ) ;;
	step 8 : wff = sylancr (step 3, step 6, step 7) |- ( ( A ∩ B ) = ∅ → ( ⋃_ y ∈ B ( { y } × D ) ∩ ( A × _V ) ) = ∅ ) ;;
	step 9 : wff = syl5eq (step 2, step 8) |- ( ( A ∩ B ) = ∅ → ( ( A × _V ) ∩ ⋃_ y ∈ B ( { y } × D ) ) = ∅ ) ;;
	step 10 : wff = ssdisj () |- ( ( ⋃_ x ∈ A ( { x } × C ) ⊆ ( A × _V ) ∧ ( ( A × _V ) ∩ ⋃_ y ∈ B ( { y } × D ) ) = ∅ ) → ( ⋃_ x ∈ A ( { x } × C ) ∩ ⋃_ y ∈ B ( { y } × D ) ) = ∅ ) ;;
	step 11 : wff = sylancr (step 1, step 9, step 10) |- ( ( A ∩ B ) = ∅ → ( ⋃_ x ∈ A ( { x } × C ) ∩ ⋃_ y ∈ B ( { y } × D ) ) = ∅ ) ;;
	qed prop 1 = step 11 ;;
}

/*A double restriction to disjoint classes is the empty set.  (Contributed
     by NM, 7-Oct-2004.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem resdisj (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∩ B ) = ∅ → ( ( C ↾ A ) ↾ B ) = ∅ ) ;;
}

proof of resdisj {
	step 1 : wff = resres () |- ( ( C ↾ A ) ↾ B ) = ( C ↾ ( A ∩ B ) ) ;;
	step 2 : wff = reseq2 () |- ( ( A ∩ B ) = ∅ → ( C ↾ ( A ∩ B ) ) = ( C ↾ ∅ ) ) ;;
	step 3 : wff = res0 () |- ( C ↾ ∅ ) = ∅ ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( ( A ∩ B ) = ∅ → ( C ↾ ( A ∩ B ) ) = ∅ ) ;;
	step 5 : wff = syl5eq (step 1, step 4) |- ( ( A ∩ B ) = ∅ → ( ( C ↾ A ) ↾ B ) = ∅ ) ;;
	qed prop 1 = step 5 ;;
}

/*The range of a cross product.  Part of Theorem 3.13(x) of [Monk1] p. 37.
     (Contributed by NM, 12-Apr-2004.) */

theorem rnxp (A : class, B : class)  {
	prop 1 : wff = |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
}

proof of rnxp {
	step 1 : wff = df-rn () |- ran ( A × B ) = dom ⁻¹ ( A × B ) ;;
	step 2 : wff = cnvxp () |- ⁻¹ ( A × B ) = ( B × A ) ;;
	step 3 : wff = dmeqi (step 2) |- dom ⁻¹ ( A × B ) = dom ( B × A ) ;;
	step 4 : wff = eqtri (step 1, step 3) |- ran ( A × B ) = dom ( B × A ) ;;
	step 5 : wff = dmxp () |- ( A ≠ ∅ → dom ( B × A ) = B ) ;;
	step 6 : wff = syl5eq (step 4, step 5) |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
	qed prop 1 = step 6 ;;
}

/*The domain of a cross product is a subclass of the first factor.
     (Contributed by NM, 19-Mar-2007.) */

theorem dmxpss (A : class, B : class)  {
	prop 1 : wff = |- dom ( A × B ) ⊆ A ;;
}

proof of dmxpss {
	step 1 : wff = 0ss () |- ∅ ⊆ A ;;
	step 2 : wff = xpeq2 () |- ( B = ∅ → ( A × B ) = ( A × ∅ ) ) ;;
	step 3 : wff = xp0 () |- ( A × ∅ ) = ∅ ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( B = ∅ → ( A × B ) = ∅ ) ;;
	step 5 : wff = dmeqd (step 4) |- ( B = ∅ → dom ( A × B ) = dom ∅ ) ;;
	step 6 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 7 : wff = syl6eq (step 5, step 6) |- ( B = ∅ → dom ( A × B ) = ∅ ) ;;
	step 8 : wff = sseq1d (step 7) |- ( B = ∅ → ( dom ( A × B ) ⊆ A ↔ ∅ ⊆ A ) ) ;;
	step 9 : wff = mpbiri (step 1, step 8) |- ( B = ∅ → dom ( A × B ) ⊆ A ) ;;
	step 10 : wff = dmxp () |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
	step 11 : wff = eqimss () |- ( dom ( A × B ) = A → dom ( A × B ) ⊆ A ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( B ≠ ∅ → dom ( A × B ) ⊆ A ) ;;
	step 13 : wff = pm2.61ine (step 9, step 12) |- dom ( A × B ) ⊆ A ;;
	qed prop 1 = step 13 ;;
}

/*The range of a cross product is a subclass of the second factor.
     (Contributed by NM, 16-Jan-2006.)  (Proof shortened by Andrew Salmon,
     27-Aug-2011.) */

theorem rnxpss (A : class, B : class)  {
	prop 1 : wff = |- ran ( A × B ) ⊆ B ;;
}

proof of rnxpss {
	step 1 : wff = df-rn () |- ran ( A × B ) = dom ⁻¹ ( A × B ) ;;
	step 2 : wff = cnvxp () |- ⁻¹ ( A × B ) = ( B × A ) ;;
	step 3 : wff = dmeqi (step 2) |- dom ⁻¹ ( A × B ) = dom ( B × A ) ;;
	step 4 : wff = dmxpss () |- dom ( B × A ) ⊆ B ;;
	step 5 : wff = eqsstri (step 3, step 4) |- dom ⁻¹ ( A × B ) ⊆ B ;;
	step 6 : wff = eqsstri (step 1, step 5) |- ran ( A × B ) ⊆ B ;;
	qed prop 1 = step 6 ;;
}

/*The range of a square cross product.  (Contributed by FL, 17-May-2010.) */

theorem rnxpid (A : class)  {
	prop 1 : wff = |- ran ( A × A ) = A ;;
}

proof of rnxpid {
	step 1 : wff = rn0 () |- ran ∅ = ∅ ;;
	step 2 : wff = xpeq2 () |- ( A = ∅ → ( A × A ) = ( A × ∅ ) ) ;;
	step 3 : wff = xp0 () |- ( A × ∅ ) = ∅ ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( A = ∅ → ( A × A ) = ∅ ) ;;
	step 5 : wff = rneqd (step 4) |- ( A = ∅ → ran ( A × A ) = ran ∅ ) ;;
	step 6 : wff = id () |- ( A = ∅ → A = ∅ ) ;;
	step 7 : wff = 3eqtr4a (step 1, step 5, step 6) |- ( A = ∅ → ran ( A × A ) = A ) ;;
	step 8 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × A ) = A ) ;;
	step 9 : wff = pm2.61ine (step 7, step 8) |- ran ( A × A ) = A ;;
	qed prop 1 = step 9 ;;
}

/*A cross-product subclass relationship is equivalent to the relationship
     for it components.  (Contributed by NM, 17-Dec-2008.) */

theorem ssxpb (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A × B ) ≠ ∅ → ( ( A × B ) ⊆ ( C × D ) ↔ ( A ⊆ C ∧ B ⊆ D ) ) ) ;;
}

proof of ssxpb {
	step 1 : wff = xpnz () |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 2 : wff = dmxp () |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
	step 3 : wff = adantl (step 2) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) → dom ( A × B ) = A ) ;;
	step 4 : wff = sylbir (step 1, step 3) |- ( ( A × B ) ≠ ∅ → dom ( A × B ) = A ) ;;
	step 5 : wff = adantr (step 4) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → dom ( A × B ) = A ) ;;
	step 6 : wff = dmss () |- ( ( A × B ) ⊆ ( C × D ) → dom ( A × B ) ⊆ dom ( C × D ) ) ;;
	step 7 : wff = adantl (step 6) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → dom ( A × B ) ⊆ dom ( C × D ) ) ;;
	step 8 : wff = eqsstr3d (step 5, step 7) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → A ⊆ dom ( C × D ) ) ;;
	step 9 : wff = dmxpss () |- dom ( C × D ) ⊆ C ;;
	step 10 : wff = syl6ss (step 8, step 9) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → A ⊆ C ) ;;
	step 11 : wff = xpnz () |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 12 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
	step 13 : wff = adantr (step 12) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) → ran ( A × B ) = B ) ;;
	step 14 : wff = sylbir (step 11, step 13) |- ( ( A × B ) ≠ ∅ → ran ( A × B ) = B ) ;;
	step 15 : wff = adantr (step 14) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → ran ( A × B ) = B ) ;;
	step 16 : wff = rnss () |- ( ( A × B ) ⊆ ( C × D ) → ran ( A × B ) ⊆ ran ( C × D ) ) ;;
	step 17 : wff = adantl (step 16) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → ran ( A × B ) ⊆ ran ( C × D ) ) ;;
	step 18 : wff = eqsstr3d (step 15, step 17) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → B ⊆ ran ( C × D ) ) ;;
	step 19 : wff = rnxpss () |- ran ( C × D ) ⊆ D ;;
	step 20 : wff = syl6ss (step 18, step 19) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → B ⊆ D ) ;;
	step 21 : wff = jca (step 10, step 20) |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ⊆ ( C × D ) ) → ( A ⊆ C ∧ B ⊆ D ) ) ;;
	step 22 : wff = ex (step 21) |- ( ( A × B ) ≠ ∅ → ( ( A × B ) ⊆ ( C × D ) → ( A ⊆ C ∧ B ⊆ D ) ) ) ;;
	step 23 : wff = xpss12 () |- ( ( A ⊆ C ∧ B ⊆ D ) → ( A × B ) ⊆ ( C × D ) ) ;;
	step 24 : wff = impbid1 (step 22, step 23) |- ( ( A × B ) ≠ ∅ → ( ( A × B ) ⊆ ( C × D ) ↔ ( A ⊆ C ∧ B ⊆ D ) ) ) ;;
	qed prop 1 = step 24 ;;
}

/*The cross product of non-empty classes is one-to-one.  (Contributed by NM,
     31-May-2008.) */

theorem xp11 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) → ( ( A × B ) = ( C × D ) ↔ ( A = C ∧ B = D ) ) ) ;;
}

proof of xp11 {
	step 1 : wff = xpnz () |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 2 : wff = anidm () |- ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 3 : wff = neeq1 () |- ( ( A × B ) = ( C × D ) → ( ( A × B ) ≠ ∅ ↔ ( C × D ) ≠ ∅ ) ) ;;
	step 4 : wff = anbi2d (step 3) |- ( ( A × B ) = ( C × D ) → ( ( ( A × B ) ≠ ∅ ∧ ( A × B ) ≠ ∅ ) ↔ ( ( A × B ) ≠ ∅ ∧ ( C × D ) ≠ ∅ ) ) ) ;;
	step 5 : wff = syl5bbr (step 2, step 4) |- ( ( A × B ) = ( C × D ) → ( ( A × B ) ≠ ∅ ↔ ( ( A × B ) ≠ ∅ ∧ ( C × D ) ≠ ∅ ) ) ) ;;
	step 6 : wff = eqimss () |- ( ( A × B ) = ( C × D ) → ( A × B ) ⊆ ( C × D ) ) ;;
	step 7 : wff = ssxpb () |- ( ( A × B ) ≠ ∅ → ( ( A × B ) ⊆ ( C × D ) ↔ ( A ⊆ C ∧ B ⊆ D ) ) ) ;;
	step 8 : wff = syl5ibcom (step 6, step 7) |- ( ( A × B ) = ( C × D ) → ( ( A × B ) ≠ ∅ → ( A ⊆ C ∧ B ⊆ D ) ) ) ;;
	step 9 : wff = eqimss2 () |- ( ( A × B ) = ( C × D ) → ( C × D ) ⊆ ( A × B ) ) ;;
	step 10 : wff = ssxpb () |- ( ( C × D ) ≠ ∅ → ( ( C × D ) ⊆ ( A × B ) ↔ ( C ⊆ A ∧ D ⊆ B ) ) ) ;;
	step 11 : wff = syl5ibcom (step 9, step 10) |- ( ( A × B ) = ( C × D ) → ( ( C × D ) ≠ ∅ → ( C ⊆ A ∧ D ⊆ B ) ) ) ;;
	step 12 : wff = anim12d (step 8, step 11) |- ( ( A × B ) = ( C × D ) → ( ( ( A × B ) ≠ ∅ ∧ ( C × D ) ≠ ∅ ) → ( ( A ⊆ C ∧ B ⊆ D ) ∧ ( C ⊆ A ∧ D ⊆ B ) ) ) ) ;;
	step 13 : wff = an4 () |- ( ( ( A ⊆ C ∧ B ⊆ D ) ∧ ( C ⊆ A ∧ D ⊆ B ) ) ↔ ( ( A ⊆ C ∧ C ⊆ A ) ∧ ( B ⊆ D ∧ D ⊆ B ) ) ) ;;
	step 14 : wff = eqss () |- ( A = C ↔ ( A ⊆ C ∧ C ⊆ A ) ) ;;
	step 15 : wff = eqss () |- ( B = D ↔ ( B ⊆ D ∧ D ⊆ B ) ) ;;
	step 16 : wff = anbi12i (step 14, step 15) |- ( ( A = C ∧ B = D ) ↔ ( ( A ⊆ C ∧ C ⊆ A ) ∧ ( B ⊆ D ∧ D ⊆ B ) ) ) ;;
	step 17 : wff = bitr4i (step 13, step 16) |- ( ( ( A ⊆ C ∧ B ⊆ D ) ∧ ( C ⊆ A ∧ D ⊆ B ) ) ↔ ( A = C ∧ B = D ) ) ;;
	step 18 : wff = syl6ib (step 12, step 17) |- ( ( A × B ) = ( C × D ) → ( ( ( A × B ) ≠ ∅ ∧ ( C × D ) ≠ ∅ ) → ( A = C ∧ B = D ) ) ) ;;
	step 19 : wff = sylbid (step 5, step 18) |- ( ( A × B ) = ( C × D ) → ( ( A × B ) ≠ ∅ → ( A = C ∧ B = D ) ) ) ;;
	step 20 : wff = com12 (step 19) |- ( ( A × B ) ≠ ∅ → ( ( A × B ) = ( C × D ) → ( A = C ∧ B = D ) ) ) ;;
	step 21 : wff = sylbi (step 1, step 20) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) → ( ( A × B ) = ( C × D ) → ( A = C ∧ B = D ) ) ) ;;
	step 22 : wff = xpeq12 () |- ( ( A = C ∧ B = D ) → ( A × B ) = ( C × D ) ) ;;
	step 23 : wff = impbid1 (step 21, step 22) |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) → ( ( A × B ) = ( C × D ) ↔ ( A = C ∧ B = D ) ) ) ;;
	qed prop 1 = step 23 ;;
}

/*Cancellation law for cross-product.  (Contributed by NM, 30-Aug-2011.) */

theorem xpcan (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( C ≠ ∅ → ( ( C × A ) = ( C × B ) ↔ A = B ) ) ;;
}

proof of xpcan {
	step 1 : wff = xp11 () |- ( ( C ≠ ∅ ∧ A ≠ ∅ ) → ( ( C × A ) = ( C × B ) ↔ ( C = C ∧ A = B ) ) ) ;;
	step 2 : wff = eqid () |- C = C ;;
	step 3 : wff = biantrur (step 2) |- ( A = B ↔ ( C = C ∧ A = B ) ) ;;
	step 4 : wff = syl6bbr (step 1, step 3) |- ( ( C ≠ ∅ ∧ A ≠ ∅ ) → ( ( C × A ) = ( C × B ) ↔ A = B ) ) ;;
	step 5 : wff = nne () |- ( ¬ A ≠ ∅ ↔ A = ∅ ) ;;
	step 6 : wff = simpr () |- ( ( C ≠ ∅ ∧ A = ∅ ) → A = ∅ ) ;;
	step 7 : wff = xpeq2 () |- ( A = ∅ → ( C × A ) = ( C × ∅ ) ) ;;
	step 8 : wff = xp0 () |- ( C × ∅ ) = ∅ ;;
	step 9 : wff = syl6eq (step 7, step 8) |- ( A = ∅ → ( C × A ) = ∅ ) ;;
	step 10 : wff = eqeq1d (step 9) |- ( A = ∅ → ( ( C × A ) = ( C × B ) ↔ ∅ = ( C × B ) ) ) ;;
	step 11 : wff = eqcom () |- ( ∅ = ( C × B ) ↔ ( C × B ) = ∅ ) ;;
	step 12 : wff = syl6bb (step 10, step 11) |- ( A = ∅ → ( ( C × A ) = ( C × B ) ↔ ( C × B ) = ∅ ) ) ;;
	step 13 : wff = adantl (step 12) |- ( ( C ≠ ∅ ∧ A = ∅ ) → ( ( C × A ) = ( C × B ) ↔ ( C × B ) = ∅ ) ) ;;
	step 14 : wff = df-ne () |- ( C ≠ ∅ ↔ ¬ C = ∅ ) ;;
	step 15 : wff = xpeq0 () |- ( ( C × B ) = ∅ ↔ ( C = ∅ ∨ B = ∅ ) ) ;;
	step 16 : wff = orel1 () |- ( ¬ C = ∅ → ( ( C = ∅ ∨ B = ∅ ) → B = ∅ ) ) ;;
	step 17 : wff = syl5bi (step 15, step 16) |- ( ¬ C = ∅ → ( ( C × B ) = ∅ → B = ∅ ) ) ;;
	step 18 : wff = sylbi (step 14, step 17) |- ( C ≠ ∅ → ( ( C × B ) = ∅ → B = ∅ ) ) ;;
	step 19 : wff = adantr (step 18) |- ( ( C ≠ ∅ ∧ A = ∅ ) → ( ( C × B ) = ∅ → B = ∅ ) ) ;;
	step 20 : wff = sylbid (step 13, step 19) |- ( ( C ≠ ∅ ∧ A = ∅ ) → ( ( C × A ) = ( C × B ) → B = ∅ ) ) ;;
	step 21 : wff = eqtr3 () |- ( ( A = ∅ ∧ B = ∅ ) → A = B ) ;;
	step 22 : wff = ee12an (step 6, step 20, step 21) |- ( ( C ≠ ∅ ∧ A = ∅ ) → ( ( C × A ) = ( C × B ) → A = B ) ) ;;
	step 23 : wff = sylan2b (step 5, step 22) |- ( ( C ≠ ∅ ∧ ¬ A ≠ ∅ ) → ( ( C × A ) = ( C × B ) → A = B ) ) ;;
	step 24 : wff = xpeq2 () |- ( A = B → ( C × A ) = ( C × B ) ) ;;
	step 25 : wff = impbid1 (step 23, step 24) |- ( ( C ≠ ∅ ∧ ¬ A ≠ ∅ ) → ( ( C × A ) = ( C × B ) ↔ A = B ) ) ;;
	step 26 : wff = pm2.61dan (step 4, step 25) |- ( C ≠ ∅ → ( ( C × A ) = ( C × B ) ↔ A = B ) ) ;;
	qed prop 1 = step 26 ;;
}

/*Cancellation law for cross-product.  (Contributed by NM, 30-Aug-2011.) */

theorem xpcan2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( C ≠ ∅ → ( ( A × C ) = ( B × C ) ↔ A = B ) ) ;;
}

proof of xpcan2 {
	step 1 : wff = xp11 () |- ( ( A ≠ ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) ↔ ( A = B ∧ C = C ) ) ) ;;
	step 2 : wff = eqid () |- C = C ;;
	step 3 : wff = biantru (step 2) |- ( A = B ↔ ( A = B ∧ C = C ) ) ;;
	step 4 : wff = syl6bbr (step 1, step 3) |- ( ( A ≠ ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) ↔ A = B ) ) ;;
	step 5 : wff = nne () |- ( ¬ A ≠ ∅ ↔ A = ∅ ) ;;
	step 6 : wff = simpl () |- ( ( A = ∅ ∧ C ≠ ∅ ) → A = ∅ ) ;;
	step 7 : wff = xpeq1 () |- ( A = ∅ → ( A × C ) = ( ∅ × C ) ) ;;
	step 8 : wff = xp0r () |- ( ∅ × C ) = ∅ ;;
	step 9 : wff = syl6eq (step 7, step 8) |- ( A = ∅ → ( A × C ) = ∅ ) ;;
	step 10 : wff = eqeq1d (step 9) |- ( A = ∅ → ( ( A × C ) = ( B × C ) ↔ ∅ = ( B × C ) ) ) ;;
	step 11 : wff = eqcom () |- ( ∅ = ( B × C ) ↔ ( B × C ) = ∅ ) ;;
	step 12 : wff = syl6bb (step 10, step 11) |- ( A = ∅ → ( ( A × C ) = ( B × C ) ↔ ( B × C ) = ∅ ) ) ;;
	step 13 : wff = adantr (step 12) |- ( ( A = ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) ↔ ( B × C ) = ∅ ) ) ;;
	step 14 : wff = df-ne () |- ( C ≠ ∅ ↔ ¬ C = ∅ ) ;;
	step 15 : wff = xpeq0 () |- ( ( B × C ) = ∅ ↔ ( B = ∅ ∨ C = ∅ ) ) ;;
	step 16 : wff = orel2 () |- ( ¬ C = ∅ → ( ( B = ∅ ∨ C = ∅ ) → B = ∅ ) ) ;;
	step 17 : wff = syl5bi (step 15, step 16) |- ( ¬ C = ∅ → ( ( B × C ) = ∅ → B = ∅ ) ) ;;
	step 18 : wff = sylbi (step 14, step 17) |- ( C ≠ ∅ → ( ( B × C ) = ∅ → B = ∅ ) ) ;;
	step 19 : wff = adantl (step 18) |- ( ( A = ∅ ∧ C ≠ ∅ ) → ( ( B × C ) = ∅ → B = ∅ ) ) ;;
	step 20 : wff = sylbid (step 13, step 19) |- ( ( A = ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) → B = ∅ ) ) ;;
	step 21 : wff = eqtr3 () |- ( ( A = ∅ ∧ B = ∅ ) → A = B ) ;;
	step 22 : wff = ee12an (step 6, step 20, step 21) |- ( ( A = ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) → A = B ) ) ;;
	step 23 : wff = xpeq1 () |- ( A = B → ( A × C ) = ( B × C ) ) ;;
	step 24 : wff = impbid1 (step 22, step 23) |- ( ( A = ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) ↔ A = B ) ) ;;
	step 25 : wff = sylanb (step 5, step 24) |- ( ( ¬ A ≠ ∅ ∧ C ≠ ∅ ) → ( ( A × C ) = ( B × C ) ↔ A = B ) ) ;;
	step 26 : wff = pm2.61ian (step 4, step 25) |- ( C ≠ ∅ → ( ( A × C ) = ( B × C ) ↔ A = B ) ) ;;
	qed prop 1 = step 26 ;;
}

/*If a cross product is a set, one of its components must be a set.
     (Contributed by NM, 27-Aug-2006.) */

theorem xpexr (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A × B ) ∈ C → ( A ∈ _V ∨ B ∈ _V ) ) ;;
}

proof of xpexr {
	step 1 : wff = 0ex () |- ∅ ∈ _V ;;
	step 2 : wff = eleq1 () |- ( A = ∅ → ( A ∈ _V ↔ ∅ ∈ _V ) ) ;;
	step 3 : wff = mpbiri (step 1, step 2) |- ( A = ∅ → A ∈ _V ) ;;
	step 4 : wff = pm2.24d (step 3) |- ( A = ∅ → ( ¬ A ∈ _V → B ∈ _V ) ) ;;
	step 5 : wff = a1d (step 4) |- ( A = ∅ → ( ( A × B ) ∈ C → ( ¬ A ∈ _V → B ∈ _V ) ) ) ;;
	step 6 : wff = rnexg () |- ( ( A × B ) ∈ C → ran ( A × B ) ∈ _V ) ;;
	step 7 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
	step 8 : wff = eleq1d (step 7) |- ( A ≠ ∅ → ( ran ( A × B ) ∈ _V ↔ B ∈ _V ) ) ;;
	step 9 : wff = syl5ib (step 6, step 8) |- ( A ≠ ∅ → ( ( A × B ) ∈ C → B ∈ _V ) ) ;;
	step 10 : wff = a1dd (step 9) |- ( A ≠ ∅ → ( ( A × B ) ∈ C → ( ¬ A ∈ _V → B ∈ _V ) ) ) ;;
	step 11 : wff = pm2.61ine (step 5, step 10) |- ( ( A × B ) ∈ C → ( ¬ A ∈ _V → B ∈ _V ) ) ;;
	step 12 : wff = orrd (step 11) |- ( ( A × B ) ∈ C → ( A ∈ _V ∨ B ∈ _V ) ) ;;
	qed prop 1 = step 12 ;;
}

/*If a nonempty cross product is a set, so are both of its components.
     (Contributed by NM, 27-Aug-2006.) */

theorem xpexr2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( ( A × B ) ∈ C ∧ ( A × B ) ≠ ∅ ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
}

proof of xpexr2 {
	step 1 : wff = xpnz () |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 2 : wff = dmxp () |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ( A × B ) ∈ C ∧ B ≠ ∅ ) → dom ( A × B ) = A ) ;;
	step 4 : wff = dmexg () |- ( ( A × B ) ∈ C → dom ( A × B ) ∈ _V ) ;;
	step 5 : wff = adantr (step 4) |- ( ( ( A × B ) ∈ C ∧ B ≠ ∅ ) → dom ( A × B ) ∈ _V ) ;;
	step 6 : wff = eqeltrrd (step 3, step 5) |- ( ( ( A × B ) ∈ C ∧ B ≠ ∅ ) → A ∈ _V ) ;;
	step 7 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
	step 8 : wff = adantl (step 7) |- ( ( ( A × B ) ∈ C ∧ A ≠ ∅ ) → ran ( A × B ) = B ) ;;
	step 9 : wff = rnexg () |- ( ( A × B ) ∈ C → ran ( A × B ) ∈ _V ) ;;
	step 10 : wff = adantr (step 9) |- ( ( ( A × B ) ∈ C ∧ A ≠ ∅ ) → ran ( A × B ) ∈ _V ) ;;
	step 11 : wff = eqeltrrd (step 8, step 10) |- ( ( ( A × B ) ∈ C ∧ A ≠ ∅ ) → B ∈ _V ) ;;
	step 12 : wff = anim12dan (step 6, step 11) |- ( ( ( A × B ) ∈ C ∧ ( B ≠ ∅ ∧ A ≠ ∅ ) ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 13 : wff = ancom2s (step 12) |- ( ( ( A × B ) ∈ C ∧ ( A ≠ ∅ ∧ B ≠ ∅ ) ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 14 : wff = sylan2br (step 1, step 13) |- ( ( ( A × B ) ∈ C ∧ ( A × B ) ≠ ∅ ) → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Subset of the range of a restriction.  (Contributed by NM,
       16-Jan-2006.) */

theorem ssrnres (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( B ⊆ ran ( C ↾ A ) ↔ ran ( C ∩ ( A × B ) ) = B ) ;;
}

proof of ssrnres {
	var x : set, y : set;;
	step 1 : wff = inss2 () |- ( C ∩ ( A × B ) ) ⊆ ( A × B ) ;;
	step 2 : wff = rnss () |- ( ( C ∩ ( A × B ) ) ⊆ ( A × B ) → ran ( C ∩ ( A × B ) ) ⊆ ran ( A × B ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ran ( C ∩ ( A × B ) ) ⊆ ran ( A × B ) ;;
	step 4 : wff = rnxpss () |- ran ( A × B ) ⊆ B ;;
	step 5 : wff = sstri (step 3, step 4) |- ran ( C ∩ ( A × B ) ) ⊆ B ;;
	step 6 : wff = eqss () |- ( ran ( C ∩ ( A × B ) ) = B ↔ ( ran ( C ∩ ( A × B ) ) ⊆ B ∧ B ⊆ ran ( C ∩ ( A × B ) ) ) ) ;;
	step 7 : wff = mpbiran (step 5, step 6) |- ( ran ( C ∩ ( A × B ) ) = B ↔ B ⊆ ran ( C ∩ ( A × B ) ) ) ;;
	step 8 : wff = ssid () |- A ⊆ A ;;
	step 9 : wff = ssv () |- B ⊆ _V ;;
	step 10 : wff = xpss12 () |- ( ( A ⊆ A ∧ B ⊆ _V ) → ( A × B ) ⊆ ( A × _V ) ) ;;
	step 11 : wff = mp2an (step 8, step 9, step 10) |- ( A × B ) ⊆ ( A × _V ) ;;
	step 12 : wff = sslin () |- ( ( A × B ) ⊆ ( A × _V ) → ( C ∩ ( A × B ) ) ⊆ ( C ∩ ( A × _V ) ) ) ;;
	step 13 : wff = ax-mp (step 11, step 12) |- ( C ∩ ( A × B ) ) ⊆ ( C ∩ ( A × _V ) ) ;;
	step 14 : wff = df-res () |- ( C ↾ A ) = ( C ∩ ( A × _V ) ) ;;
	step 15 : wff = sseqtr4i (step 13, step 14) |- ( C ∩ ( A × B ) ) ⊆ ( C ↾ A ) ;;
	step 16 : wff = rnss () |- ( ( C ∩ ( A × B ) ) ⊆ ( C ↾ A ) → ran ( C ∩ ( A × B ) ) ⊆ ran ( C ↾ A ) ) ;;
	step 17 : wff = ax-mp (step 15, step 16) |- ran ( C ∩ ( A × B ) ) ⊆ ran ( C ↾ A ) ;;
	step 18 : wff = sstr () |- ( ( B ⊆ ran ( C ∩ ( A × B ) ) ∧ ran ( C ∩ ( A × B ) ) ⊆ ran ( C ↾ A ) ) → B ⊆ ran ( C ↾ A ) ) ;;
	step 19 : wff = mpan2 (step 17, step 18) |- ( B ⊆ ran ( C ∩ ( A × B ) ) → B ⊆ ran ( C ↾ A ) ) ;;
	step 20 : wff = ssel () |- ( B ⊆ ran ( C ↾ A ) → ( y ∈ B → y ∈ ran ( C ↾ A ) ) ) ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = elrn2 (step 21) |- ( y ∈ ran ( C ↾ A ) ↔ ∃ x 〈 x , y 〉 ∈ ( C ↾ A ) ) ;;
	step 23 : wff = syl6ib (step 20, step 22) |- ( B ⊆ ran ( C ↾ A ) → ( y ∈ B → ∃ x 〈 x , y 〉 ∈ ( C ↾ A ) ) ) ;;
	step 24 : wff = ancrd (step 23) |- ( B ⊆ ran ( C ↾ A ) → ( y ∈ B → ( ∃ x 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ) ) ;;
	step 25 : wff = vex () |- y ∈ _V ;;
	step 26 : wff = elrn2 (step 25) |- ( y ∈ ran ( C ∩ ( A × B ) ) ↔ ∃ x 〈 x , y 〉 ∈ ( C ∩ ( A × B ) ) ) ;;
	step 27 : wff = elin () |- ( 〈 x , y 〉 ∈ ( C ∩ ( A × B ) ) ↔ ( 〈 x , y 〉 ∈ C ∧ 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 28 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 29 : wff = anbi2i (step 28) |- ( ( 〈 x , y 〉 ∈ C ∧ 〈 x , y 〉 ∈ ( A × B ) ) ↔ ( 〈 x , y 〉 ∈ C ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 30 : wff = vex () |- y ∈ _V ;;
	step 31 : wff = opelres (step 30) |- ( 〈 x , y 〉 ∈ ( C ↾ A ) ↔ ( 〈 x , y 〉 ∈ C ∧ x ∈ A ) ) ;;
	step 32 : wff = anbi1i (step 31) |- ( ( 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ↔ ( ( 〈 x , y 〉 ∈ C ∧ x ∈ A ) ∧ y ∈ B ) ) ;;
	step 33 : wff = anass () |- ( ( ( 〈 x , y 〉 ∈ C ∧ x ∈ A ) ∧ y ∈ B ) ↔ ( 〈 x , y 〉 ∈ C ∧ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 34 : wff = bitr2i (step 32, step 33) |- ( ( 〈 x , y 〉 ∈ C ∧ ( x ∈ A ∧ y ∈ B ) ) ↔ ( 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ) ;;
	step 35 : wff = 3bitri (step 27, step 29, step 34) |- ( 〈 x , y 〉 ∈ ( C ∩ ( A × B ) ) ↔ ( 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ) ;;
	step 36 : wff = exbii (step 35) |- ( ∃ x 〈 x , y 〉 ∈ ( C ∩ ( A × B ) ) ↔ ∃ x ( 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ) ;;
	step 37 : wff = 19.41v () |- ( ∃ x ( 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ↔ ( ∃ x 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ) ;;
	step 38 : wff = 3bitri (step 26, step 36, step 37) |- ( y ∈ ran ( C ∩ ( A × B ) ) ↔ ( ∃ x 〈 x , y 〉 ∈ ( C ↾ A ) ∧ y ∈ B ) ) ;;
	step 39 : wff = syl6ibr (step 24, step 38) |- ( B ⊆ ran ( C ↾ A ) → ( y ∈ B → y ∈ ran ( C ∩ ( A × B ) ) ) ) ;;
	step 40 : wff = ssrdv (step 39) |- ( B ⊆ ran ( C ↾ A ) → B ⊆ ran ( C ∩ ( A × B ) ) ) ;;
	step 41 : wff = impbii (step 19, step 40) |- ( B ⊆ ran ( C ∩ ( A × B ) ) ↔ B ⊆ ran ( C ↾ A ) ) ;;
	step 42 : wff = bitr2i (step 7, step 41) |- ( B ⊆ ran ( C ↾ A ) ↔ ran ( C ∩ ( A × B ) ) = B ) ;;
	qed prop 1 = step 42 ;;
}

/*Range of the intersection with a cross product.  (Contributed by NM,
       17-Jan-2006.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem rninxp (x : set, y : set, A : class, B : class, C : class) disjointed(x y A, y B, x y C) {
	prop 1 : wff = |- ( ran ( C ∩ ( A × B ) ) = B ↔ ∀ y ∈ B ∃ x ∈ A x C y ) ;;
}

proof of rninxp {
	step 1 : wff = dfss3 () |- ( B ⊆ ran ( C ↾ A ) ↔ ∀ y ∈ B y ∈ ran ( C ↾ A ) ) ;;
	step 2 : wff = ssrnres () |- ( B ⊆ ran ( C ↾ A ) ↔ ran ( C ∩ ( A × B ) ) = B ) ;;
	step 3 : wff = df-ima () |- ( C " A ) = ran ( C ↾ A ) ;;
	step 4 : wff = eleq2i (step 3) |- ( y ∈ ( C " A ) ↔ y ∈ ran ( C ↾ A ) ) ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = elima (step 5) |- ( y ∈ ( C " A ) ↔ ∃ x ∈ A x C y ) ;;
	step 7 : wff = bitr3i (step 4, step 6) |- ( y ∈ ran ( C ↾ A ) ↔ ∃ x ∈ A x C y ) ;;
	step 8 : wff = ralbii (step 7) |- ( ∀ y ∈ B y ∈ ran ( C ↾ A ) ↔ ∀ y ∈ B ∃ x ∈ A x C y ) ;;
	step 9 : wff = 3bitr3i (step 1, step 2, step 8) |- ( ran ( C ∩ ( A × B ) ) = B ↔ ∀ y ∈ B ∃ x ∈ A x C y ) ;;
	qed prop 1 = step 9 ;;
}

/*Domain of the intersection with a cross product.  (Contributed by NM,
       17-Jan-2006.) */

theorem dminxp (x : set, y : set, A : class, B : class, C : class) disjointed(x A, x y B, x y C) {
	prop 1 : wff = |- ( dom ( C ∩ ( A × B ) ) = A ↔ ∀ x ∈ A ∃ y ∈ B x C y ) ;;
}

proof of dminxp {
	step 1 : wff = dfdm4 () |- dom ( C ∩ ( A × B ) ) = ran ⁻¹ ( C ∩ ( A × B ) ) ;;
	step 2 : wff = cnvin () |- ⁻¹ ( C ∩ ( A × B ) ) = ( ⁻¹ C ∩ ⁻¹ ( A × B ) ) ;;
	step 3 : wff = cnvxp () |- ⁻¹ ( A × B ) = ( B × A ) ;;
	step 4 : wff = ineq2i (step 3) |- ( ⁻¹ C ∩ ⁻¹ ( A × B ) ) = ( ⁻¹ C ∩ ( B × A ) ) ;;
	step 5 : wff = eqtri (step 2, step 4) |- ⁻¹ ( C ∩ ( A × B ) ) = ( ⁻¹ C ∩ ( B × A ) ) ;;
	step 6 : wff = rneqi (step 5) |- ran ⁻¹ ( C ∩ ( A × B ) ) = ran ( ⁻¹ C ∩ ( B × A ) ) ;;
	step 7 : wff = eqtri (step 1, step 6) |- dom ( C ∩ ( A × B ) ) = ran ( ⁻¹ C ∩ ( B × A ) ) ;;
	step 8 : wff = eqeq1i (step 7) |- ( dom ( C ∩ ( A × B ) ) = A ↔ ran ( ⁻¹ C ∩ ( B × A ) ) = A ) ;;
	step 9 : wff = rninxp () |- ( ran ( ⁻¹ C ∩ ( B × A ) ) = A ↔ ∀ x ∈ A ∃ y ∈ B y ⁻¹ C x ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = brcnv (step 10, step 11) |- ( y ⁻¹ C x ↔ x C y ) ;;
	step 13 : wff = rexbii (step 12) |- ( ∃ y ∈ B y ⁻¹ C x ↔ ∃ y ∈ B x C y ) ;;
	step 14 : wff = ralbii (step 13) |- ( ∀ x ∈ A ∃ y ∈ B y ⁻¹ C x ↔ ∀ x ∈ A ∃ y ∈ B x C y ) ;;
	step 15 : wff = 3bitri (step 8, step 9, step 14) |- ( dom ( C ∩ ( A × B ) ) = A ↔ ∀ x ∈ A ∃ y ∈ B x C y ) ;;
	qed prop 1 = step 15 ;;
}

/*Image of a relation restricted to a rectangular region.  (Contributed by
     Stefan O'Rear, 19-Feb-2015.) */

theorem imainrect (A : class, B : class, G : class, Y : class)  {
	prop 1 : wff = |- ( ( G ∩ ( A × B ) ) " Y ) = ( ( G " ( Y ∩ A ) ) ∩ B ) ;;
}

proof of imainrect {
	step 1 : wff = df-res () |- ( ( G ∩ ( A × B ) ) ↾ Y ) = ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) ;;
	step 2 : wff = rneqi (step 1) |- ran ( ( G ∩ ( A × B ) ) ↾ Y ) = ran ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) ;;
	step 3 : wff = df-ima () |- ( ( G ∩ ( A × B ) ) " Y ) = ran ( ( G ∩ ( A × B ) ) ↾ Y ) ;;
	step 4 : wff = df-ima () |- ( G " ( Y ∩ A ) ) = ran ( G ↾ ( Y ∩ A ) ) ;;
	step 5 : wff = df-res () |- ( G ↾ ( Y ∩ A ) ) = ( G ∩ ( ( Y ∩ A ) × _V ) ) ;;
	step 6 : wff = rneqi (step 5) |- ran ( G ↾ ( Y ∩ A ) ) = ran ( G ∩ ( ( Y ∩ A ) × _V ) ) ;;
	step 7 : wff = eqtri (step 4, step 6) |- ( G " ( Y ∩ A ) ) = ran ( G ∩ ( ( Y ∩ A ) × _V ) ) ;;
	step 8 : wff = ineq1i (step 7) |- ( ( G " ( Y ∩ A ) ) ∩ B ) = ( ran ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ B ) ;;
	step 9 : wff = cnvin () |- ⁻¹ ( ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( _V × B ) ) = ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ⁻¹ ( _V × B ) ) ;;
	step 10 : wff = inxp () |- ( ( A × _V ) ∩ ( _V × B ) ) = ( ( A ∩ _V ) × ( _V ∩ B ) ) ;;
	step 11 : wff = inv1 () |- ( A ∩ _V ) = A ;;
	step 12 : wff = incom () |- ( _V ∩ B ) = ( B ∩ _V ) ;;
	step 13 : wff = inv1 () |- ( B ∩ _V ) = B ;;
	step 14 : wff = eqtri (step 12, step 13) |- ( _V ∩ B ) = B ;;
	step 15 : wff = xpeq12i (step 11, step 14) |- ( ( A ∩ _V ) × ( _V ∩ B ) ) = ( A × B ) ;;
	step 16 : wff = eqtr2i (step 10, step 15) |- ( A × B ) = ( ( A × _V ) ∩ ( _V × B ) ) ;;
	step 17 : wff = ineq2i (step 16) |- ( ( G ∩ ( Y × _V ) ) ∩ ( A × B ) ) = ( ( G ∩ ( Y × _V ) ) ∩ ( ( A × _V ) ∩ ( _V × B ) ) ) ;;
	step 18 : wff = in32 () |- ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) = ( ( G ∩ ( Y × _V ) ) ∩ ( A × B ) ) ;;
	step 19 : wff = xpindir () |- ( ( Y ∩ A ) × _V ) = ( ( Y × _V ) ∩ ( A × _V ) ) ;;
	step 20 : wff = ineq2i (step 19) |- ( G ∩ ( ( Y ∩ A ) × _V ) ) = ( G ∩ ( ( Y × _V ) ∩ ( A × _V ) ) ) ;;
	step 21 : wff = inass () |- ( ( G ∩ ( Y × _V ) ) ∩ ( A × _V ) ) = ( G ∩ ( ( Y × _V ) ∩ ( A × _V ) ) ) ;;
	step 22 : wff = eqtr4i (step 20, step 21) |- ( G ∩ ( ( Y ∩ A ) × _V ) ) = ( ( G ∩ ( Y × _V ) ) ∩ ( A × _V ) ) ;;
	step 23 : wff = ineq1i (step 22) |- ( ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( _V × B ) ) = ( ( ( G ∩ ( Y × _V ) ) ∩ ( A × _V ) ) ∩ ( _V × B ) ) ;;
	step 24 : wff = inass () |- ( ( ( G ∩ ( Y × _V ) ) ∩ ( A × _V ) ) ∩ ( _V × B ) ) = ( ( G ∩ ( Y × _V ) ) ∩ ( ( A × _V ) ∩ ( _V × B ) ) ) ;;
	step 25 : wff = eqtri (step 23, step 24) |- ( ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( _V × B ) ) = ( ( G ∩ ( Y × _V ) ) ∩ ( ( A × _V ) ∩ ( _V × B ) ) ) ;;
	step 26 : wff = 3eqtr4i (step 17, step 18, step 25) |- ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) = ( ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( _V × B ) ) ;;
	step 27 : wff = cnveqi (step 26) |- ⁻¹ ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) = ⁻¹ ( ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( _V × B ) ) ;;
	step 28 : wff = df-res () |- ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ↾ B ) = ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( B × _V ) ) ;;
	step 29 : wff = cnvxp () |- ⁻¹ ( _V × B ) = ( B × _V ) ;;
	step 30 : wff = ineq2i (step 29) |- ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ⁻¹ ( _V × B ) ) = ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ( B × _V ) ) ;;
	step 31 : wff = eqtr4i (step 28, step 30) |- ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ↾ B ) = ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ ⁻¹ ( _V × B ) ) ;;
	step 32 : wff = 3eqtr4ri (step 9, step 27, step 31) |- ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ↾ B ) = ⁻¹ ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) ;;
	step 33 : wff = dmeqi (step 32) |- dom ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ↾ B ) = dom ⁻¹ ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) ;;
	step 34 : wff = incom () |- ( B ∩ dom ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ) = ( dom ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ B ) ;;
	step 35 : wff = dmres () |- dom ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ↾ B ) = ( B ∩ dom ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ) ;;
	step 36 : wff = df-rn () |- ran ( G ∩ ( ( Y ∩ A ) × _V ) ) = dom ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ;;
	step 37 : wff = ineq1i (step 36) |- ( ran ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ B ) = ( dom ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ B ) ;;
	step 38 : wff = 3eqtr4ri (step 34, step 35, step 37) |- ( ran ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ B ) = dom ( ⁻¹ ( G ∩ ( ( Y ∩ A ) × _V ) ) ↾ B ) ;;
	step 39 : wff = df-rn () |- ran ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) = dom ⁻¹ ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) ;;
	step 40 : wff = 3eqtr4ri (step 33, step 38, step 39) |- ran ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) = ( ran ( G ∩ ( ( Y ∩ A ) × _V ) ) ∩ B ) ;;
	step 41 : wff = eqtr4i (step 8, step 40) |- ( ( G " ( Y ∩ A ) ) ∩ B ) = ran ( ( G ∩ ( A × B ) ) ∩ ( Y × _V ) ) ;;
	step 42 : wff = 3eqtr4i (step 2, step 3, step 41) |- ( ( G ∩ ( A × B ) ) " Y ) = ( ( G " ( Y ∩ A ) ) ∩ B ) ;;
	qed prop 1 = step 42 ;;
}

/*The base set of a strict order is contained in the field of the
       relation, except possibly for one element (note that
       ` (/) Or { B } ` ).  (Contributed by Mario Carneiro, 27-Apr-2015.) */

theorem sossfld (A : class, B : class, R : class) disjointed(x A, x B, x R, x) {
	prop 1 : wff = |- ( ( R Or A ∧ B ∈ A ) → ( A ∖ { B } ) ⊆ ( dom R ∪ ran R ) ) ;;
}

proof of sossfld {
	var x : set;;
	step 1 : wff = eldifsn () |- ( x ∈ ( A ∖ { B } ) ↔ ( x ∈ A ∧ x ≠ B ) ) ;;
	step 2 : wff = sotrieq () |- ( ( R Or A ∧ ( x ∈ A ∧ B ∈ A ) ) → ( x = B ↔ ¬ ( x R B ∨ B R x ) ) ) ;;
	step 3 : wff = necon2abid (step 2) |- ( ( R Or A ∧ ( x ∈ A ∧ B ∈ A ) ) → ( ( x R B ∨ B R x ) ↔ x ≠ B ) ) ;;
	step 4 : wff = anass1rs (step 3) |- ( ( ( R Or A ∧ B ∈ A ) ∧ x ∈ A ) → ( ( x R B ∨ B R x ) ↔ x ≠ B ) ) ;;
	step 5 : wff = breldmg () |- ( ( x ∈ A ∧ B ∈ A ∧ x R B ) → x ∈ dom R ) ;;
	step 6 : wff = 3expia (step 5) |- ( ( x ∈ A ∧ B ∈ A ) → ( x R B → x ∈ dom R ) ) ;;
	step 7 : wff = adantll (step 6) |- ( ( ( R Or A ∧ x ∈ A ) ∧ B ∈ A ) → ( x R B → x ∈ dom R ) ) ;;
	step 8 : wff = an32s (step 7) |- ( ( ( R Or A ∧ B ∈ A ) ∧ x ∈ A ) → ( x R B → x ∈ dom R ) ) ;;
	step 9 : wff = brelrng () |- ( ( B ∈ A ∧ x ∈ A ∧ B R x ) → x ∈ ran R ) ;;
	step 10 : wff = 3expia (step 9) |- ( ( B ∈ A ∧ x ∈ A ) → ( B R x → x ∈ ran R ) ) ;;
	step 11 : wff = adantll (step 10) |- ( ( ( R Or A ∧ B ∈ A ) ∧ x ∈ A ) → ( B R x → x ∈ ran R ) ) ;;
	step 12 : wff = orim12d (step 8, step 11) |- ( ( ( R Or A ∧ B ∈ A ) ∧ x ∈ A ) → ( ( x R B ∨ B R x ) → ( x ∈ dom R ∨ x ∈ ran R ) ) ) ;;
	step 13 : wff = elun () |- ( x ∈ ( dom R ∪ ran R ) ↔ ( x ∈ dom R ∨ x ∈ ran R ) ) ;;
	step 14 : wff = syl6ibr (step 12, step 13) |- ( ( ( R Or A ∧ B ∈ A ) ∧ x ∈ A ) → ( ( x R B ∨ B R x ) → x ∈ ( dom R ∪ ran R ) ) ) ;;
	step 15 : wff = sylbird (step 4, step 14) |- ( ( ( R Or A ∧ B ∈ A ) ∧ x ∈ A ) → ( x ≠ B → x ∈ ( dom R ∪ ran R ) ) ) ;;
	step 16 : wff = expimpd (step 15) |- ( ( R Or A ∧ B ∈ A ) → ( ( x ∈ A ∧ x ≠ B ) → x ∈ ( dom R ∪ ran R ) ) ) ;;
	step 17 : wff = syl5bi (step 1, step 16) |- ( ( R Or A ∧ B ∈ A ) → ( x ∈ ( A ∖ { B } ) → x ∈ ( dom R ∪ ran R ) ) ) ;;
	step 18 : wff = ssrdv (step 17) |- ( ( R Or A ∧ B ∈ A ) → ( A ∖ { B } ) ⊆ ( dom R ∪ ran R ) ) ;;
	qed prop 1 = step 18 ;;
}

/*The base set of a nonempty strict order is the same as the field of the
       relation.  (Contributed by Mario Carneiro, 15-May-2015.) */

theorem sofld (A : class, R : class) disjointed(x y A, x, x y R, x) {
	prop 1 : wff = |- ( ( R Or A ∧ R ⊆ ( A × A ) ∧ R ≠ ∅ ) → A = ( dom R ∪ ran R ) ) ;;
}

proof of sofld {
	var x : set, y : set;;
	step 1 : wff = relxp () |- Rel ( A × A ) ;;
	step 2 : wff = relss () |- ( R ⊆ ( A × A ) → ( Rel ( A × A ) → Rel R ) ) ;;
	step 3 : wff = mpi (step 1, step 2) |- ( R ⊆ ( A × A ) → Rel R ) ;;
	step 4 : wff = ad2antlr (step 3) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ ¬ A ⊆ ( dom R ∪ ran R ) ) → Rel R ) ;;
	step 5 : wff = df-br () |- ( x R y ↔ 〈 x , y 〉 ∈ R ) ;;
	step 6 : wff = ssun1 () |- A ⊆ ( A ∪ { x } ) ;;
	step 7 : wff = undif1 () |- ( ( A ∖ { x } ) ∪ { x } ) = ( A ∪ { x } ) ;;
	step 8 : wff = sseqtr4i (step 6, step 7) |- A ⊆ ( ( A ∖ { x } ) ∪ { x } ) ;;
	step 9 : wff = simpll () |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → R Or A ) ;;
	step 10 : wff = dmss () |- ( R ⊆ ( A × A ) → dom R ⊆ dom ( A × A ) ) ;;
	step 11 : wff = dmxpid () |- dom ( A × A ) = A ;;
	step 12 : wff = syl6sseq (step 10, step 11) |- ( R ⊆ ( A × A ) → dom R ⊆ A ) ;;
	step 13 : wff = ad2antlr (step 12) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → dom R ⊆ A ) ;;
	step 14 : wff = relxp () |- Rel ( A × A ) ;;
	step 15 : wff = relss () |- ( R ⊆ ( A × A ) → ( Rel ( A × A ) → Rel R ) ) ;;
	step 16 : wff = mpi (step 14, step 15) |- ( R ⊆ ( A × A ) → Rel R ) ;;
	step 17 : wff = ad2antlr (step 16) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → Rel R ) ;;
	step 18 : wff = releldm () |- ( ( Rel R ∧ x R y ) → x ∈ dom R ) ;;
	step 19 : wff = sylancom (step 17, step 18) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → x ∈ dom R ) ;;
	step 20 : wff = sseldd (step 13, step 19) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → x ∈ A ) ;;
	step 21 : wff = sossfld () |- ( ( R Or A ∧ x ∈ A ) → ( A ∖ { x } ) ⊆ ( dom R ∪ ran R ) ) ;;
	step 22 : wff = syl2anc (step 9, step 20, step 21) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → ( A ∖ { x } ) ⊆ ( dom R ∪ ran R ) ) ;;
	step 23 : wff = ssun1 () |- dom R ⊆ ( dom R ∪ ran R ) ;;
	step 24 : wff = relxp () |- Rel ( A × A ) ;;
	step 25 : wff = relss () |- ( R ⊆ ( A × A ) → ( Rel ( A × A ) → Rel R ) ) ;;
	step 26 : wff = mpi (step 24, step 25) |- ( R ⊆ ( A × A ) → Rel R ) ;;
	step 27 : wff = ad2antlr (step 26) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → Rel R ) ;;
	step 28 : wff = releldm () |- ( ( Rel R ∧ x R y ) → x ∈ dom R ) ;;
	step 29 : wff = sylancom (step 27, step 28) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → x ∈ dom R ) ;;
	step 30 : wff = sseldi (step 23, step 29) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → x ∈ ( dom R ∪ ran R ) ) ;;
	step 31 : wff = snssd (step 30) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → { x } ⊆ ( dom R ∪ ran R ) ) ;;
	step 32 : wff = unssd (step 22, step 31) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → ( ( A ∖ { x } ) ∪ { x } ) ⊆ ( dom R ∪ ran R ) ) ;;
	step 33 : wff = syl5ss (step 8, step 32) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ x R y ) → A ⊆ ( dom R ∪ ran R ) ) ;;
	step 34 : wff = ex (step 33) |- ( ( R Or A ∧ R ⊆ ( A × A ) ) → ( x R y → A ⊆ ( dom R ∪ ran R ) ) ) ;;
	step 35 : wff = syl5bir (step 5, step 34) |- ( ( R Or A ∧ R ⊆ ( A × A ) ) → ( 〈 x , y 〉 ∈ R → A ⊆ ( dom R ∪ ran R ) ) ) ;;
	step 36 : wff = con3and (step 35) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ ¬ A ⊆ ( dom R ∪ ran R ) ) → ¬ 〈 x , y 〉 ∈ R ) ;;
	step 37 : wff = pm2.21d (step 36) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ ¬ A ⊆ ( dom R ∪ ran R ) ) → ( 〈 x , y 〉 ∈ R → 〈 x , y 〉 ∈ ∅ ) ) ;;
	step 38 : wff = relssdv (step 4, step 37) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ ¬ A ⊆ ( dom R ∪ ran R ) ) → R ⊆ ∅ ) ;;
	step 39 : wff = ss0 () |- ( R ⊆ ∅ → R = ∅ ) ;;
	step 40 : wff = syl (step 38, step 39) |- ( ( ( R Or A ∧ R ⊆ ( A × A ) ) ∧ ¬ A ⊆ ( dom R ∪ ran R ) ) → R = ∅ ) ;;
	step 41 : wff = ex (step 40) |- ( ( R Or A ∧ R ⊆ ( A × A ) ) → ( ¬ A ⊆ ( dom R ∪ ran R ) → R = ∅ ) ) ;;
	step 42 : wff = necon1ad (step 41) |- ( ( R Or A ∧ R ⊆ ( A × A ) ) → ( R ≠ ∅ → A ⊆ ( dom R ∪ ran R ) ) ) ;;
	step 43 : wff = 3impia (step 42) |- ( ( R Or A ∧ R ⊆ ( A × A ) ∧ R ≠ ∅ ) → A ⊆ ( dom R ∪ ran R ) ) ;;
	step 44 : wff = dmss () |- ( R ⊆ ( A × A ) → dom R ⊆ dom ( A × A ) ) ;;
	step 45 : wff = dmxpid () |- dom ( A × A ) = A ;;
	step 46 : wff = syl6sseq (step 44, step 45) |- ( R ⊆ ( A × A ) → dom R ⊆ A ) ;;
	step 47 : wff = rnss () |- ( R ⊆ ( A × A ) → ran R ⊆ ran ( A × A ) ) ;;
	step 48 : wff = rnxpid () |- ran ( A × A ) = A ;;
	step 49 : wff = syl6sseq (step 47, step 48) |- ( R ⊆ ( A × A ) → ran R ⊆ A ) ;;
	step 50 : wff = unssd (step 46, step 49) |- ( R ⊆ ( A × A ) → ( dom R ∪ ran R ) ⊆ A ) ;;
	step 51 : wff = 3ad2ant2 (step 50) |- ( ( R Or A ∧ R ⊆ ( A × A ) ∧ R ≠ ∅ ) → ( dom R ∪ ran R ) ⊆ A ) ;;
	step 52 : wff = eqssd (step 43, step 51) |- ( ( R Or A ∧ R ⊆ ( A × A ) ∧ R ≠ ∅ ) → A = ( dom R ∪ ran R ) ) ;;
	qed prop 1 = step 52 ;;
}

/*If the relation in a strict order is a set, then the base field is also
       a set.  (Contributed by Mario Carneiro, 27-Apr-2015.) */

theorem soex (A : class, R : class, V : class) disjointed(x A, x, x R, x V) {
	prop 1 : wff = |- ( ( R Or A ∧ R ∈ V ) → A ∈ _V ) ;;
}

proof of soex {
	var x : set;;
	step 1 : wff = simpr () |- ( ( ( R Or A ∧ R ∈ V ) ∧ A = ∅ ) → A = ∅ ) ;;
	step 2 : wff = 0ex () |- ∅ ∈ _V ;;
	step 3 : wff = syl6eqel (step 1, step 2) |- ( ( ( R Or A ∧ R ∈ V ) ∧ A = ∅ ) → A ∈ _V ) ;;
	step 4 : wff = n0 () |- ( A ≠ ∅ ↔ ∃ x x ∈ A ) ;;
	step 5 : wff = sossfld () |- ( ( R Or A ∧ x ∈ A ) → ( A ∖ { x } ) ⊆ ( dom R ∪ ran R ) ) ;;
	step 6 : wff = adantlr (step 5) |- ( ( ( R Or A ∧ R ∈ V ) ∧ x ∈ A ) → ( A ∖ { x } ) ⊆ ( dom R ∪ ran R ) ) ;;
	step 7 : wff = ssundif () |- ( A ⊆ ( { x } ∪ ( dom R ∪ ran R ) ) ↔ ( A ∖ { x } ) ⊆ ( dom R ∪ ran R ) ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( ( R Or A ∧ R ∈ V ) ∧ x ∈ A ) → A ⊆ ( { x } ∪ ( dom R ∪ ran R ) ) ) ;;
	step 9 : wff = snex () |- { x } ∈ _V ;;
	step 10 : wff = dmexg () |- ( R ∈ V → dom R ∈ _V ) ;;
	step 11 : wff = rnexg () |- ( R ∈ V → ran R ∈ _V ) ;;
	step 12 : wff = unexg () |- ( ( dom R ∈ _V ∧ ran R ∈ _V ) → ( dom R ∪ ran R ) ∈ _V ) ;;
	step 13 : wff = syl2anc (step 10, step 11, step 12) |- ( R ∈ V → ( dom R ∪ ran R ) ∈ _V ) ;;
	step 14 : wff = unexg () |- ( ( { x } ∈ _V ∧ ( dom R ∪ ran R ) ∈ _V ) → ( { x } ∪ ( dom R ∪ ran R ) ) ∈ _V ) ;;
	step 15 : wff = sylancr (step 9, step 13, step 14) |- ( R ∈ V → ( { x } ∪ ( dom R ∪ ran R ) ) ∈ _V ) ;;
	step 16 : wff = ad2antlr (step 15) |- ( ( ( R Or A ∧ R ∈ V ) ∧ x ∈ A ) → ( { x } ∪ ( dom R ∪ ran R ) ) ∈ _V ) ;;
	step 17 : wff = ssexg () |- ( ( A ⊆ ( { x } ∪ ( dom R ∪ ran R ) ) ∧ ( { x } ∪ ( dom R ∪ ran R ) ) ∈ _V ) → A ∈ _V ) ;;
	step 18 : wff = syl2anc (step 8, step 16, step 17) |- ( ( ( R Or A ∧ R ∈ V ) ∧ x ∈ A ) → A ∈ _V ) ;;
	step 19 : wff = ex (step 18) |- ( ( R Or A ∧ R ∈ V ) → ( x ∈ A → A ∈ _V ) ) ;;
	step 20 : wff = exlimdv (step 19) |- ( ( R Or A ∧ R ∈ V ) → ( ∃ x x ∈ A → A ∈ _V ) ) ;;
	step 21 : wff = imp (step 20) |- ( ( ( R Or A ∧ R ∈ V ) ∧ ∃ x x ∈ A ) → A ∈ _V ) ;;
	step 22 : wff = sylan2b (step 4, step 21) |- ( ( ( R Or A ∧ R ∈ V ) ∧ A ≠ ∅ ) → A ∈ _V ) ;;
	step 23 : wff = pm2.61dane (step 3, step 22) |- ( ( R Or A ∧ R ∈ V ) → A ∈ _V ) ;;
	qed prop 1 = step 23 ;;
}

/*The set of all ordered pairs in a class is the same as the double
       converse.  (Contributed by Mario Carneiro, 16-Aug-2015.) */

theorem cnvcnv3 (x : set, y : set, R : class) disjointed(x y R) {
	prop 1 : wff = |- ⁻¹ ⁻¹ R = { 〈 x , y 〉 | x R y } ;;
}

proof of cnvcnv3 {
	step 1 : wff = df-cnv () |- ⁻¹ ⁻¹ R = { 〈 x , y 〉 | y ⁻¹ R x } ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = brcnv (step 2, step 3) |- ( y ⁻¹ R x ↔ x R y ) ;;
	step 5 : wff = opabbii (step 4) |- { 〈 x , y 〉 | y ⁻¹ R x } = { 〈 x , y 〉 | x R y } ;;
	step 6 : wff = eqtri (step 1, step 5) |- ⁻¹ ⁻¹ R = { 〈 x , y 〉 | x R y } ;;
	qed prop 1 = step 6 ;;
}

/*Alternate definition of relation.  Exercise 2 of [TakeutiZaring] p. 25.
       (Contributed by NM, 29-Dec-1996.) */

theorem dfrel2 (R : class) disjointed(x y R) {
	prop 1 : wff = |- ( Rel R ↔ ⁻¹ ⁻¹ R = R ) ;;
}

proof of dfrel2 {
	var x : set, y : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ ⁻¹ R ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opelcnv (step 2, step 3) |- ( 〈 x , y 〉 ∈ ⁻¹ ⁻¹ R ↔ 〈 y , x 〉 ∈ ⁻¹ R ) ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = vex () |- x ∈ _V ;;
	step 7 : wff = opelcnv (step 5, step 6) |- ( 〈 y , x 〉 ∈ ⁻¹ R ↔ 〈 x , y 〉 ∈ R ) ;;
	step 8 : wff = bitri (step 4, step 7) |- ( 〈 x , y 〉 ∈ ⁻¹ ⁻¹ R ↔ 〈 x , y 〉 ∈ R ) ;;
	step 9 : wff = eqrelriv (step 8) |- ( ( Rel ⁻¹ ⁻¹ R ∧ Rel R ) → ⁻¹ ⁻¹ R = R ) ;;
	step 10 : wff = mpan (step 1, step 9) |- ( Rel R → ⁻¹ ⁻¹ R = R ) ;;
	step 11 : wff = relcnv () |- Rel ⁻¹ ⁻¹ R ;;
	step 12 : wff = releq () |- ( ⁻¹ ⁻¹ R = R → ( Rel ⁻¹ ⁻¹ R ↔ Rel R ) ) ;;
	step 13 : wff = mpbii (step 11, step 12) |- ( ⁻¹ ⁻¹ R = R → Rel R ) ;;
	step 14 : wff = impbii (step 10, step 13) |- ( Rel R ↔ ⁻¹ ⁻¹ R = R ) ;;
	qed prop 1 = step 14 ;;
}

/*A relation can be expressed as the set of ordered pairs in it.  An
       analogue of ~ dffn5 for relations.  (Contributed by Mario Carneiro,
       16-Aug-2015.) */

theorem dfrel4v (x : set, y : set, R : class) disjointed(x y R) {
	prop 1 : wff = |- ( Rel R ↔ R = { 〈 x , y 〉 | x R y } ) ;;
}

proof of dfrel4v {
	step 1 : wff = dfrel2 () |- ( Rel R ↔ ⁻¹ ⁻¹ R = R ) ;;
	step 2 : wff = eqcom () |- ( ⁻¹ ⁻¹ R = R ↔ R = ⁻¹ ⁻¹ R ) ;;
	step 3 : wff = cnvcnv3 () |- ⁻¹ ⁻¹ R = { 〈 x , y 〉 | x R y } ;;
	step 4 : wff = eqeq2i (step 3) |- ( R = ⁻¹ ⁻¹ R ↔ R = { 〈 x , y 〉 | x R y } ) ;;
	step 5 : wff = 3bitri (step 1, step 2, step 4) |- ( Rel R ↔ R = { 〈 x , y 〉 | x R y } ) ;;
	qed prop 1 = step 5 ;;
}

/*The double converse of a class strips out all elements that are not
     ordered pairs.  (Contributed by NM, 8-Dec-2003.) */

theorem cnvcnv (A : class)  {
	prop 1 : wff = |- ⁻¹ ⁻¹ A = ( A ∩ ( _V × _V ) ) ;;
}

proof of cnvcnv {
	step 1 : wff = relcnv () |- Rel ⁻¹ ⁻¹ A ;;
	step 2 : wff = df-rel () |- ( Rel ⁻¹ ⁻¹ A ↔ ⁻¹ ⁻¹ A ⊆ ( _V × _V ) ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- ⁻¹ ⁻¹ A ⊆ ( _V × _V ) ;;
	step 4 : wff = relxp () |- Rel ( _V × _V ) ;;
	step 5 : wff = dfrel2 () |- ( Rel ( _V × _V ) ↔ ⁻¹ ⁻¹ ( _V × _V ) = ( _V × _V ) ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- ⁻¹ ⁻¹ ( _V × _V ) = ( _V × _V ) ;;
	step 7 : wff = sseqtr4i (step 3, step 6) |- ⁻¹ ⁻¹ A ⊆ ⁻¹ ⁻¹ ( _V × _V ) ;;
	step 8 : wff = dfss () |- ( ⁻¹ ⁻¹ A ⊆ ⁻¹ ⁻¹ ( _V × _V ) ↔ ⁻¹ ⁻¹ A = ( ⁻¹ ⁻¹ A ∩ ⁻¹ ⁻¹ ( _V × _V ) ) ) ;;
	step 9 : wff = mpbi (step 7, step 8) |- ⁻¹ ⁻¹ A = ( ⁻¹ ⁻¹ A ∩ ⁻¹ ⁻¹ ( _V × _V ) ) ;;
	step 10 : wff = cnvin () |- ⁻¹ ( ⁻¹ A ∩ ⁻¹ ( _V × _V ) ) = ( ⁻¹ ⁻¹ A ∩ ⁻¹ ⁻¹ ( _V × _V ) ) ;;
	step 11 : wff = cnvin () |- ⁻¹ ( A ∩ ( _V × _V ) ) = ( ⁻¹ A ∩ ⁻¹ ( _V × _V ) ) ;;
	step 12 : wff = cnveqi (step 11) |- ⁻¹ ⁻¹ ( A ∩ ( _V × _V ) ) = ⁻¹ ( ⁻¹ A ∩ ⁻¹ ( _V × _V ) ) ;;
	step 13 : wff = inss2 () |- ( A ∩ ( _V × _V ) ) ⊆ ( _V × _V ) ;;
	step 14 : wff = df-rel () |- ( Rel ( A ∩ ( _V × _V ) ) ↔ ( A ∩ ( _V × _V ) ) ⊆ ( _V × _V ) ) ;;
	step 15 : wff = mpbir (step 13, step 14) |- Rel ( A ∩ ( _V × _V ) ) ;;
	step 16 : wff = dfrel2 () |- ( Rel ( A ∩ ( _V × _V ) ) ↔ ⁻¹ ⁻¹ ( A ∩ ( _V × _V ) ) = ( A ∩ ( _V × _V ) ) ) ;;
	step 17 : wff = mpbi (step 15, step 16) |- ⁻¹ ⁻¹ ( A ∩ ( _V × _V ) ) = ( A ∩ ( _V × _V ) ) ;;
	step 18 : wff = eqtr3i (step 12, step 17) |- ⁻¹ ( ⁻¹ A ∩ ⁻¹ ( _V × _V ) ) = ( A ∩ ( _V × _V ) ) ;;
	step 19 : wff = 3eqtr2i (step 9, step 10, step 18) |- ⁻¹ ⁻¹ A = ( A ∩ ( _V × _V ) ) ;;
	qed prop 1 = step 19 ;;
}

/*The double converse of a class equals its restriction to the universe.
     (Contributed by NM, 8-Oct-2007.) */

theorem cnvcnv2 (A : class)  {
	prop 1 : wff = |- ⁻¹ ⁻¹ A = ( A ↾ _V ) ;;
}

proof of cnvcnv2 {
	step 1 : wff = cnvcnv () |- ⁻¹ ⁻¹ A = ( A ∩ ( _V × _V ) ) ;;
	step 2 : wff = df-res () |- ( A ↾ _V ) = ( A ∩ ( _V × _V ) ) ;;
	step 3 : wff = eqtr4i (step 1, step 2) |- ⁻¹ ⁻¹ A = ( A ↾ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*The double converse of a class is a subclass.  Exercise 2 of
     [TakeutiZaring] p. 25.  (Contributed by NM, 23-Jul-2004.) */

theorem cnvcnvss (A : class)  {
	prop 1 : wff = |- ⁻¹ ⁻¹ A ⊆ A ;;
}

proof of cnvcnvss {
	step 1 : wff = cnvcnv () |- ⁻¹ ⁻¹ A = ( A ∩ ( _V × _V ) ) ;;
	step 2 : wff = inss1 () |- ( A ∩ ( _V × _V ) ) ⊆ A ;;
	step 3 : wff = eqsstri (step 1, step 2) |- ⁻¹ ⁻¹ A ⊆ A ;;
	qed prop 1 = step 3 ;;
}

/*Equality theorem for converse.  (Contributed by FL, 19-Sep-2011.) */

theorem cnveqb (A : class, B : class)  {
	prop 1 : wff = |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ⁻¹ A = ⁻¹ B ) ) ;;
}

proof of cnveqb {
	step 1 : wff = cnveq () |- ( A = B → ⁻¹ A = ⁻¹ B ) ;;
	step 2 : wff = dfrel2 () |- ( Rel A ↔ ⁻¹ ⁻¹ A = A ) ;;
	step 3 : wff = dfrel2 () |- ( Rel B ↔ ⁻¹ ⁻¹ B = B ) ;;
	step 4 : wff = cnveq () |- ( ⁻¹ A = ⁻¹ B → ⁻¹ ⁻¹ A = ⁻¹ ⁻¹ B ) ;;
	step 5 : wff = eqeq2 () |- ( B = ⁻¹ ⁻¹ B → ( ⁻¹ ⁻¹ A = B ↔ ⁻¹ ⁻¹ A = ⁻¹ ⁻¹ B ) ) ;;
	step 6 : wff = syl5ibr (step 4, step 5) |- ( B = ⁻¹ ⁻¹ B → ( ⁻¹ A = ⁻¹ B → ⁻¹ ⁻¹ A = B ) ) ;;
	step 7 : wff = eqcoms (step 6) |- ( ⁻¹ ⁻¹ B = B → ( ⁻¹ A = ⁻¹ B → ⁻¹ ⁻¹ A = B ) ) ;;
	step 8 : wff = sylbi (step 3, step 7) |- ( Rel B → ( ⁻¹ A = ⁻¹ B → ⁻¹ ⁻¹ A = B ) ) ;;
	step 9 : wff = eqeq1 () |- ( A = ⁻¹ ⁻¹ A → ( A = B ↔ ⁻¹ ⁻¹ A = B ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( A = ⁻¹ ⁻¹ A → ( ( ⁻¹ A = ⁻¹ B → A = B ) ↔ ( ⁻¹ A = ⁻¹ B → ⁻¹ ⁻¹ A = B ) ) ) ;;
	step 11 : wff = syl5ibr (step 8, step 10) |- ( A = ⁻¹ ⁻¹ A → ( Rel B → ( ⁻¹ A = ⁻¹ B → A = B ) ) ) ;;
	step 12 : wff = eqcoms (step 11) |- ( ⁻¹ ⁻¹ A = A → ( Rel B → ( ⁻¹ A = ⁻¹ B → A = B ) ) ) ;;
	step 13 : wff = sylbi (step 2, step 12) |- ( Rel A → ( Rel B → ( ⁻¹ A = ⁻¹ B → A = B ) ) ) ;;
	step 14 : wff = imp (step 13) |- ( ( Rel A ∧ Rel B ) → ( ⁻¹ A = ⁻¹ B → A = B ) ) ;;
	step 15 : wff = impbid2 (step 1, step 14) |- ( ( Rel A ∧ Rel B ) → ( A = B ↔ ⁻¹ A = ⁻¹ B ) ) ;;
	qed prop 1 = step 15 ;;
}

/*A relation empty iff its converse is empty.  (Contributed by FL,
     19-Sep-2011.) */

theorem cnveq0 (A : class)  {
	prop 1 : wff = |- ( Rel A → ( A = ∅ ↔ ⁻¹ A = ∅ ) ) ;;
}

proof of cnveq0 {
	step 1 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 2 : wff = rel0 () |- Rel ∅ ;;
	step 3 : wff = cnveqb () |- ( ( Rel A ∧ Rel ∅ ) → ( A = ∅ ↔ ⁻¹ A = ⁻¹ ∅ ) ) ;;
	step 4 : wff = mpan2 (step 2, step 3) |- ( Rel A → ( A = ∅ ↔ ⁻¹ A = ⁻¹ ∅ ) ) ;;
	step 5 : wff = eqeq2 () |- ( ∅ = ⁻¹ ∅ → ( ⁻¹ A = ∅ ↔ ⁻¹ A = ⁻¹ ∅ ) ) ;;
	step 6 : wff = bibi2d (step 5) |- ( ∅ = ⁻¹ ∅ → ( ( A = ∅ ↔ ⁻¹ A = ∅ ) ↔ ( A = ∅ ↔ ⁻¹ A = ⁻¹ ∅ ) ) ) ;;
	step 7 : wff = syl5ibr (step 4, step 6) |- ( ∅ = ⁻¹ ∅ → ( Rel A → ( A = ∅ ↔ ⁻¹ A = ∅ ) ) ) ;;
	step 8 : wff = eqcoms (step 7) |- ( ⁻¹ ∅ = ∅ → ( Rel A → ( A = ∅ ↔ ⁻¹ A = ∅ ) ) ) ;;
	step 9 : wff = ax-mp (step 1, step 8) |- ( Rel A → ( A = ∅ ↔ ⁻¹ A = ∅ ) ) ;;
	qed prop 1 = step 9 ;;
}

/*[19-Sep-2011] */

/*Alternate definition of relation.  (Contributed by NM, 14-May-2008.) */

theorem dfrel3 (R : class)  {
	prop 1 : wff = |- ( Rel R ↔ ( R ↾ _V ) = R ) ;;
}

proof of dfrel3 {
	step 1 : wff = dfrel2 () |- ( Rel R ↔ ⁻¹ ⁻¹ R = R ) ;;
	step 2 : wff = cnvcnv2 () |- ⁻¹ ⁻¹ R = ( R ↾ _V ) ;;
	step 3 : wff = eqeq1i (step 2) |- ( ⁻¹ ⁻¹ R = R ↔ ( R ↾ _V ) = R ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( Rel R ↔ ( R ↾ _V ) = R ) ;;
	qed prop 1 = step 4 ;;
}

/*The domain of a universal restriction.  (Contributed by NM,
     14-May-2008.) */

theorem dmresv (A : class)  {
	prop 1 : wff = |- dom ( A ↾ _V ) = dom A ;;
}

proof of dmresv {
	step 1 : wff = dmres () |- dom ( A ↾ _V ) = ( _V ∩ dom A ) ;;
	step 2 : wff = incom () |- ( _V ∩ dom A ) = ( dom A ∩ _V ) ;;
	step 3 : wff = inv1 () |- ( dom A ∩ _V ) = dom A ;;
	step 4 : wff = 3eqtri (step 1, step 2, step 3) |- dom ( A ↾ _V ) = dom A ;;
	qed prop 1 = step 4 ;;
}

/*The range of a universal restriction.  (Contributed by NM,
     14-May-2008.) */

theorem rnresv (A : class)  {
	prop 1 : wff = |- ran ( A ↾ _V ) = ran A ;;
}

proof of rnresv {
	step 1 : wff = cnvcnv2 () |- ⁻¹ ⁻¹ A = ( A ↾ _V ) ;;
	step 2 : wff = rneqi (step 1) |- ran ⁻¹ ⁻¹ A = ran ( A ↾ _V ) ;;
	step 3 : wff = rncnvcnv () |- ran ⁻¹ ⁻¹ A = ran A ;;
	step 4 : wff = eqtr3i (step 2, step 3) |- ran ( A ↾ _V ) = ran A ;;
	qed prop 1 = step 4 ;;
}

/*Range defined in terms of image.  (Contributed by NM, 14-May-2008.) */

theorem dfrn4 (A : class)  {
	prop 1 : wff = |- ran A = ( A " _V ) ;;
}

proof of dfrn4 {
	step 1 : wff = df-ima () |- ( A " _V ) = ran ( A ↾ _V ) ;;
	step 2 : wff = rnresv () |- ran ( A ↾ _V ) = ran A ;;
	step 3 : wff = eqtr2i (step 1, step 2) |- ran A = ( A " _V ) ;;
	qed prop 1 = step 3 ;;
}

/*The restriction of the double converse of a class.  (Contributed by NM,
     8-Apr-2007.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem rescnvcnv (A : class, B : class)  {
	prop 1 : wff = |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ↾ B ) ;;
}

proof of rescnvcnv {
	step 1 : wff = cnvcnv2 () |- ⁻¹ ⁻¹ A = ( A ↾ _V ) ;;
	step 2 : wff = reseq1i (step 1) |- ( ⁻¹ ⁻¹ A ↾ B ) = ( ( A ↾ _V ) ↾ B ) ;;
	step 3 : wff = resres () |- ( ( A ↾ _V ) ↾ B ) = ( A ↾ ( _V ∩ B ) ) ;;
	step 4 : wff = ssv () |- B ⊆ _V ;;
	step 5 : wff = sseqin2 () |- ( B ⊆ _V ↔ ( _V ∩ B ) = B ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- ( _V ∩ B ) = B ;;
	step 7 : wff = reseq2i (step 6) |- ( A ↾ ( _V ∩ B ) ) = ( A ↾ B ) ;;
	step 8 : wff = 3eqtri (step 2, step 3, step 7) |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ↾ B ) ;;
	qed prop 1 = step 8 ;;
}

/*The double converse of the restriction of a class.  (Contributed by NM,
     3-Jun-2007.) */

theorem cnvcnvres (A : class, B : class)  {
	prop 1 : wff = |- ⁻¹ ⁻¹ ( A ↾ B ) = ( ⁻¹ ⁻¹ A ↾ B ) ;;
}

proof of cnvcnvres {
	step 1 : wff = relres () |- Rel ( A ↾ B ) ;;
	step 2 : wff = dfrel2 () |- ( Rel ( A ↾ B ) ↔ ⁻¹ ⁻¹ ( A ↾ B ) = ( A ↾ B ) ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- ⁻¹ ⁻¹ ( A ↾ B ) = ( A ↾ B ) ;;
	step 4 : wff = rescnvcnv () |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ↾ B ) ;;
	step 5 : wff = eqtr4i (step 3, step 4) |- ⁻¹ ⁻¹ ( A ↾ B ) = ( ⁻¹ ⁻¹ A ↾ B ) ;;
	qed prop 1 = step 5 ;;
}

/*The image of the double converse of a class.  (Contributed by NM,
     8-Apr-2007.) */

theorem imacnvcnv (A : class, B : class)  {
	prop 1 : wff = |- ( ⁻¹ ⁻¹ A " B ) = ( A " B ) ;;
}

proof of imacnvcnv {
	step 1 : wff = rescnvcnv () |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ↾ B ) ;;
	step 2 : wff = rneqi (step 1) |- ran ( ⁻¹ ⁻¹ A ↾ B ) = ran ( A ↾ B ) ;;
	step 3 : wff = df-ima () |- ( ⁻¹ ⁻¹ A " B ) = ran ( ⁻¹ ⁻¹ A ↾ B ) ;;
	step 4 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- ( ⁻¹ ⁻¹ A " B ) = ( A " B ) ;;
	qed prop 1 = step 5 ;;
}

/*The domain of a singleton is nonzero iff the singleton argument is an
       ordered pair.  (Contributed by NM, 14-Dec-2008.)  (Proof shortened by
       Andrew Salmon, 27-Aug-2011.) */

theorem dmsnn0 (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) ↔ dom { A } ≠ ∅ ) ;;
}

proof of dmsnn0 {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = eldm (step 1) |- ( x ∈ dom { A } ↔ ∃ y x { A } y ) ;;
	step 3 : wff = df-br () |- ( x { A } y ↔ 〈 x , y 〉 ∈ { A } ) ;;
	step 4 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 5 : wff = elsnc (step 4) |- ( 〈 x , y 〉 ∈ { A } ↔ 〈 x , y 〉 = A ) ;;
	step 6 : wff = eqcom () |- ( 〈 x , y 〉 = A ↔ A = 〈 x , y 〉 ) ;;
	step 7 : wff = 3bitri (step 3, step 5, step 6) |- ( x { A } y ↔ A = 〈 x , y 〉 ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ y x { A } y ↔ ∃ y A = 〈 x , y 〉 ) ;;
	step 9 : wff = bitr2i (step 2, step 8) |- ( ∃ y A = 〈 x , y 〉 ↔ x ∈ dom { A } ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ x ∃ y A = 〈 x , y 〉 ↔ ∃ x x ∈ dom { A } ) ;;
	step 11 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 12 : wff = n0 () |- ( dom { A } ≠ ∅ ↔ ∃ x x ∈ dom { A } ) ;;
	step 13 : wff = 3bitr4i (step 10, step 11, step 12) |- ( A ∈ ( _V × _V ) ↔ dom { A } ≠ ∅ ) ;;
	qed prop 1 = step 13 ;;
}

/*The range of a singleton is nonzero iff the singleton argument is an
     ordered pair.  (Contributed by NM, 14-Dec-2008.) */

theorem rnsnn0 (A : class)  {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) ↔ ran { A } ≠ ∅ ) ;;
}

proof of rnsnn0 {
	step 1 : wff = dmsnn0 () |- ( A ∈ ( _V × _V ) ↔ dom { A } ≠ ∅ ) ;;
	step 2 : wff = dm0rn0 () |- ( dom { A } = ∅ ↔ ran { A } = ∅ ) ;;
	step 3 : wff = necon3bii (step 2) |- ( dom { A } ≠ ∅ ↔ ran { A } ≠ ∅ ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( A ∈ ( _V × _V ) ↔ ran { A } ≠ ∅ ) ;;
	qed prop 1 = step 4 ;;
}

/*The domain of the singleton of the empty set is empty.  (Contributed by
     NM, 30-Jan-2004.) */

theorem dmsn0 ()  {
	prop 1 : wff = |- dom { ∅ } = ∅ ;;
}

proof of dmsn0 {
	step 1 : wff = 0nelxp () |- ¬ ∅ ∈ ( _V × _V ) ;;
	step 2 : wff = dmsnn0 () |- ( ∅ ∈ ( _V × _V ) ↔ dom { ∅ } ≠ ∅ ) ;;
	step 3 : wff = necon2bbii (step 2) |- ( dom { ∅ } = ∅ ↔ ¬ ∅ ∈ ( _V × _V ) ) ;;
	step 4 : wff = mpbir (step 1, step 3) |- dom { ∅ } = ∅ ;;
	qed prop 1 = step 4 ;;
}

/*The converse of the singleton of the empty set is empty.  (Contributed by
     Mario Carneiro, 30-Aug-2015.) */

theorem cnvsn0 ()  {
	prop 1 : wff = |- ⁻¹ { ∅ } = ∅ ;;
}

proof of cnvsn0 {
	step 1 : wff = dfdm4 () |- dom { ∅ } = ran ⁻¹ { ∅ } ;;
	step 2 : wff = dmsn0 () |- dom { ∅ } = ∅ ;;
	step 3 : wff = eqtr3i (step 1, step 2) |- ran ⁻¹ { ∅ } = ∅ ;;
	step 4 : wff = relcnv () |- Rel ⁻¹ { ∅ } ;;
	step 5 : wff = relrn0 () |- ( Rel ⁻¹ { ∅ } → ( ⁻¹ { ∅ } = ∅ ↔ ran ⁻¹ { ∅ } = ∅ ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( ⁻¹ { ∅ } = ∅ ↔ ran ⁻¹ { ∅ } = ∅ ) ;;
	step 7 : wff = mpbir (step 3, step 6) |- ⁻¹ { ∅ } = ∅ ;;
	qed prop 1 = step 7 ;;
}

/*The domain of a singleton is empty if the singleton's argument contains
     the empty set.  (Contributed by NM, 15-Dec-2008.) */

theorem dmsn0el (A : class)  {
	prop 1 : wff = |- ( ∅ ∈ A → dom { A } = ∅ ) ;;
}

proof of dmsn0el {
	step 1 : wff = dmsnn0 () |- ( A ∈ ( _V × _V ) ↔ dom { A } ≠ ∅ ) ;;
	step 2 : wff = 0nelelxp () |- ( A ∈ ( _V × _V ) → ¬ ∅ ∈ A ) ;;
	step 3 : wff = sylbir (step 1, step 2) |- ( dom { A } ≠ ∅ → ¬ ∅ ∈ A ) ;;
	step 4 : wff = necon4ai (step 3) |- ( ∅ ∈ A → dom { A } = ∅ ) ;;
	qed prop 1 = step 4 ;;
}

/*A singleton is a relation iff it has a nonempty domain.  (Contributed by
       NM, 25-Sep-2013.) */

theorem relsn2 (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( Rel { A } ↔ dom { A } ≠ ∅ ) ;;
}

proof of relsn2 {
	step 1 : wff = relsn (hyp 1) |- ( Rel { A } ↔ A ∈ ( _V × _V ) ) ;;
	step 2 : wff = dmsnn0 () |- ( A ∈ ( _V × _V ) ↔ dom { A } ≠ ∅ ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( Rel { A } ↔ dom { A } ≠ ∅ ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a singleton of an ordered pair is the singleton of the
       first member.  (Contributed by Mario Carneiro, 26-Apr-2015.) */

theorem dmsnopg (A : class, B : class, V : class) disjointed(x y A, x y B, x V) {
	prop 1 : wff = |- ( B ∈ V → dom { 〈 A , B 〉 } = { A } ) ;;
}

proof of dmsnopg {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = opth1 (step 1, step 2) |- ( 〈 x , y 〉 = 〈 A , B 〉 → x = A ) ;;
	step 4 : wff = exlimiv (step 3) |- ( ∃ y 〈 x , y 〉 = 〈 A , B 〉 → x = A ) ;;
	step 5 : wff = opeq1 () |- ( x = A → 〈 x , B 〉 = 〈 A , B 〉 ) ;;
	step 6 : wff = opeq2 () |- ( y = B → 〈 x , y 〉 = 〈 x , B 〉 ) ;;
	step 7 : wff = eqeq1d (step 6) |- ( y = B → ( 〈 x , y 〉 = 〈 A , B 〉 ↔ 〈 x , B 〉 = 〈 A , B 〉 ) ) ;;
	step 8 : wff = spcegv (step 7) |- ( B ∈ V → ( 〈 x , B 〉 = 〈 A , B 〉 → ∃ y 〈 x , y 〉 = 〈 A , B 〉 ) ) ;;
	step 9 : wff = syl5 (step 5, step 8) |- ( B ∈ V → ( x = A → ∃ y 〈 x , y 〉 = 〈 A , B 〉 ) ) ;;
	step 10 : wff = impbid2 (step 4, step 9) |- ( B ∈ V → ( ∃ y 〈 x , y 〉 = 〈 A , B 〉 ↔ x = A ) ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = eldm2 (step 11) |- ( x ∈ dom { 〈 A , B 〉 } ↔ ∃ y 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ;;
	step 13 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 14 : wff = elsnc (step 13) |- ( 〈 x , y 〉 ∈ { 〈 A , B 〉 } ↔ 〈 x , y 〉 = 〈 A , B 〉 ) ;;
	step 15 : wff = exbii (step 14) |- ( ∃ y 〈 x , y 〉 ∈ { 〈 A , B 〉 } ↔ ∃ y 〈 x , y 〉 = 〈 A , B 〉 ) ;;
	step 16 : wff = bitri (step 12, step 15) |- ( x ∈ dom { 〈 A , B 〉 } ↔ ∃ y 〈 x , y 〉 = 〈 A , B 〉 ) ;;
	step 17 : wff = elsn () |- ( x ∈ { A } ↔ x = A ) ;;
	step 18 : wff = 3bitr4g (step 10, step 16, step 17) |- ( B ∈ V → ( x ∈ dom { 〈 A , B 〉 } ↔ x ∈ { A } ) ) ;;
	step 19 : wff = eqrdv (step 18) |- ( B ∈ V → dom { 〈 A , B 〉 } = { A } ) ;;
	qed prop 1 = step 19 ;;
}

/*The domain of a singleton of an ordered pair is a subset of the
       singleton of the first member (with no sethood assumptions on ` B ` ).
       (Contributed by Mario Carneiro, 30-Apr-2015.) */

theorem dmsnopss (A : class, B : class) disjointed(A, B) {
	prop 1 : wff = |- dom { 〈 A , B 〉 } ⊆ { A } ;;
}

proof of dmsnopss {
	step 1 : wff = dmsnopg () |- ( B ∈ _V → dom { 〈 A , B 〉 } = { A } ) ;;
	step 2 : wff = eqimss () |- ( dom { 〈 A , B 〉 } = { A } → dom { 〈 A , B 〉 } ⊆ { A } ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( B ∈ _V → dom { 〈 A , B 〉 } ⊆ { A } ) ;;
	step 4 : wff = opprc2 () |- ( ¬ B ∈ _V → 〈 A , B 〉 = ∅ ) ;;
	step 5 : wff = sneqd (step 4) |- ( ¬ B ∈ _V → { 〈 A , B 〉 } = { ∅ } ) ;;
	step 6 : wff = dmeqd (step 5) |- ( ¬ B ∈ _V → dom { 〈 A , B 〉 } = dom { ∅ } ) ;;
	step 7 : wff = dmsn0 () |- dom { ∅ } = ∅ ;;
	step 8 : wff = syl6eq (step 6, step 7) |- ( ¬ B ∈ _V → dom { 〈 A , B 〉 } = ∅ ) ;;
	step 9 : wff = 0ss () |- ∅ ⊆ { A } ;;
	step 10 : wff = a1i (step 9) |- ( ¬ B ∈ _V → ∅ ⊆ { A } ) ;;
	step 11 : wff = eqsstrd (step 8, step 10) |- ( ¬ B ∈ _V → dom { 〈 A , B 〉 } ⊆ { A } ) ;;
	step 12 : wff = pm2.61i (step 3, step 11) |- dom { 〈 A , B 〉 } ⊆ { A } ;;
	qed prop 1 = step 12 ;;
}

/*The domain of an unordered pair of ordered pairs.  (Contributed by Mario
       Carneiro, 26-Apr-2015.) */

theorem dmpropg (A : class, B : class, C : class, D : class, V : class, W : class) disjointed(A, B, V) {
	prop 1 : wff = |- ( ( B ∈ V ∧ D ∈ W ) → dom { 〈 A , B 〉 , 〈 C , D 〉 } = { A , C } ) ;;
}

proof of dmpropg {
	step 1 : wff = dmsnopg () |- ( B ∈ V → dom { 〈 A , B 〉 } = { A } ) ;;
	step 2 : wff = dmsnopg () |- ( D ∈ W → dom { 〈 C , D 〉 } = { C } ) ;;
	step 3 : wff = uneq12 () |- ( ( dom { 〈 A , B 〉 } = { A } ∧ dom { 〈 C , D 〉 } = { C } ) → ( dom { 〈 A , B 〉 } ∪ dom { 〈 C , D 〉 } ) = ( { A } ∪ { C } ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( B ∈ V ∧ D ∈ W ) → ( dom { 〈 A , B 〉 } ∪ dom { 〈 C , D 〉 } ) = ( { A } ∪ { C } ) ) ;;
	step 5 : wff = df-pr () |- { 〈 A , B 〉 , 〈 C , D 〉 } = ( { 〈 A , B 〉 } ∪ { 〈 C , D 〉 } ) ;;
	step 6 : wff = dmeqi (step 5) |- dom { 〈 A , B 〉 , 〈 C , D 〉 } = dom ( { 〈 A , B 〉 } ∪ { 〈 C , D 〉 } ) ;;
	step 7 : wff = dmun () |- dom ( { 〈 A , B 〉 } ∪ { 〈 C , D 〉 } ) = ( dom { 〈 A , B 〉 } ∪ dom { 〈 C , D 〉 } ) ;;
	step 8 : wff = eqtri (step 6, step 7) |- dom { 〈 A , B 〉 , 〈 C , D 〉 } = ( dom { 〈 A , B 〉 } ∪ dom { 〈 C , D 〉 } ) ;;
	step 9 : wff = df-pr () |- { A , C } = ( { A } ∪ { C } ) ;;
	step 10 : wff = 3eqtr4g (step 4, step 8, step 9) |- ( ( B ∈ V ∧ D ∈ W ) → dom { 〈 A , B 〉 , 〈 C , D 〉 } = { A , C } ) ;;
	qed prop 1 = step 10 ;;
}

/*The domain of a singleton of an ordered pair is the singleton of the
       first member.  (Contributed by NM, 30-Jan-2004.)  (Proof shortened by
       Andrew Salmon, 27-Aug-2011.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem dmsnop (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- dom { 〈 A , B 〉 } = { A } ;;
}

proof of dmsnop {
	step 1 : wff = dmsnopg () |- ( B ∈ _V → dom { 〈 A , B 〉 } = { A } ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- dom { 〈 A , B 〉 } = { A } ;;
	qed prop 1 = step 2 ;;
}

/*The domain of an unordered pair of ordered pairs.  (Contributed by NM,
       13-Sep-2011.) */

theorem dmprop (A : class, B : class, C : class, D : class) disjointed(A, B) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- D ∈ _V ;;
	-----------------------
	prop 1 : wff = |- dom { 〈 A , B 〉 , 〈 C , D 〉 } = { A , C } ;;
}

proof of dmprop {
	step 1 : wff = dmpropg () |- ( ( B ∈ _V ∧ D ∈ _V ) → dom { 〈 A , B 〉 , 〈 C , D 〉 } = { A , C } ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- dom { 〈 A , B 〉 , 〈 C , D 〉 } = { A , C } ;;
	qed prop 1 = step 2 ;;
}

/*The domain of an unordered triple of ordered pairs.  (Contributed by NM,
       14-Sep-2011.) */

theorem dmtpop (A : class, B : class, C : class, D : class, E : class, F : class) disjointed(A, B) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- D ∈ _V ;;
	hyp 3 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- dom { 〈 A , B 〉 , 〈 C , D 〉 , 〈 E , F 〉 } = { A , C , E } ;;
}

proof of dmtpop {
	step 1 : wff = df-tp () |- { 〈 A , B 〉 , 〈 C , D 〉 , 〈 E , F 〉 } = ( { 〈 A , B 〉 , 〈 C , D 〉 } ∪ { 〈 E , F 〉 } ) ;;
	step 2 : wff = dmeqi (step 1) |- dom { 〈 A , B 〉 , 〈 C , D 〉 , 〈 E , F 〉 } = dom ( { 〈 A , B 〉 , 〈 C , D 〉 } ∪ { 〈 E , F 〉 } ) ;;
	step 3 : wff = dmun () |- dom ( { 〈 A , B 〉 , 〈 C , D 〉 } ∪ { 〈 E , F 〉 } ) = ( dom { 〈 A , B 〉 , 〈 C , D 〉 } ∪ dom { 〈 E , F 〉 } ) ;;
	step 4 : wff = dmprop (hyp 1, hyp 2) |- dom { 〈 A , B 〉 , 〈 C , D 〉 } = { A , C } ;;
	step 5 : wff = dmsnop (hyp 3) |- dom { 〈 E , F 〉 } = { E } ;;
	step 6 : wff = uneq12i (step 4, step 5) |- ( dom { 〈 A , B 〉 , 〈 C , D 〉 } ∪ dom { 〈 E , F 〉 } ) = ( { A , C } ∪ { E } ) ;;
	step 7 : wff = 3eqtri (step 2, step 3, step 6) |- dom { 〈 A , B 〉 , 〈 C , D 〉 , 〈 E , F 〉 } = ( { A , C } ∪ { E } ) ;;
	step 8 : wff = df-tp () |- { A , C , E } = ( { A , C } ∪ { E } ) ;;
	step 9 : wff = eqtr4i (step 7, step 8) |- dom { 〈 A , B 〉 , 〈 C , D 〉 , 〈 E , F 〉 } = { A , C , E } ;;
	qed prop 1 = step 9 ;;
}

/*Double converse of a singleton of an ordered pair.  (Unlike ~ cnvsn ,
       this does not need any sethood assumptions on ` A ` and ` B ` .)
       (Contributed by Mario Carneiro, 26-Apr-2015.) */

theorem cnvcnvsn (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⁻¹ ⁻¹ { 〈 A , B 〉 } = ⁻¹ { 〈 B , A 〉 } ;;
}

proof of cnvcnvsn {
	var x : set, y : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ ⁻¹ { 〈 A , B 〉 } ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ { 〈 B , A 〉 } ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = opelcnv (step 3, step 4) |- ( 〈 x , y 〉 ∈ ⁻¹ ⁻¹ { 〈 A , B 〉 } ↔ 〈 y , x 〉 ∈ ⁻¹ { 〈 A , B 〉 } ) ;;
	step 6 : wff = ancom () |- ( ( x = A ∧ y = B ) ↔ ( y = B ∧ x = A ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opth (step 7, step 8) |- ( 〈 x , y 〉 = 〈 A , B 〉 ↔ ( x = A ∧ y = B ) ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = opth (step 10, step 11) |- ( 〈 y , x 〉 = 〈 B , A 〉 ↔ ( y = B ∧ x = A ) ) ;;
	step 13 : wff = 3bitr4i (step 6, step 9, step 12) |- ( 〈 x , y 〉 = 〈 A , B 〉 ↔ 〈 y , x 〉 = 〈 B , A 〉 ) ;;
	step 14 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 15 : wff = elsnc (step 14) |- ( 〈 x , y 〉 ∈ { 〈 A , B 〉 } ↔ 〈 x , y 〉 = 〈 A , B 〉 ) ;;
	step 16 : wff = opex () |- 〈 y , x 〉 ∈ _V ;;
	step 17 : wff = elsnc (step 16) |- ( 〈 y , x 〉 ∈ { 〈 B , A 〉 } ↔ 〈 y , x 〉 = 〈 B , A 〉 ) ;;
	step 18 : wff = 3bitr4i (step 13, step 15, step 17) |- ( 〈 x , y 〉 ∈ { 〈 A , B 〉 } ↔ 〈 y , x 〉 ∈ { 〈 B , A 〉 } ) ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = opelcnv (step 19, step 20) |- ( 〈 y , x 〉 ∈ ⁻¹ { 〈 A , B 〉 } ↔ 〈 x , y 〉 ∈ { 〈 A , B 〉 } ) ;;
	step 22 : wff = vex () |- x ∈ _V ;;
	step 23 : wff = vex () |- y ∈ _V ;;
	step 24 : wff = opelcnv (step 22, step 23) |- ( 〈 x , y 〉 ∈ ⁻¹ { 〈 B , A 〉 } ↔ 〈 y , x 〉 ∈ { 〈 B , A 〉 } ) ;;
	step 25 : wff = 3bitr4i (step 18, step 21, step 24) |- ( 〈 y , x 〉 ∈ ⁻¹ { 〈 A , B 〉 } ↔ 〈 x , y 〉 ∈ ⁻¹ { 〈 B , A 〉 } ) ;;
	step 26 : wff = bitri (step 5, step 25) |- ( 〈 x , y 〉 ∈ ⁻¹ ⁻¹ { 〈 A , B 〉 } ↔ 〈 x , y 〉 ∈ ⁻¹ { 〈 B , A 〉 } ) ;;
	step 27 : wff = eqrelriiv (step 1, step 2, step 26) |- ⁻¹ ⁻¹ { 〈 A , B 〉 } = ⁻¹ { 〈 B , A 〉 } ;;
	qed prop 1 = step 27 ;;
}

/*The domain of the singleton of the singleton of a singleton.
       (Contributed by NM, 15-Sep-2004.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem dmsnsnsn (A : class) disjointed(x A, x) {
	prop 1 : wff = |- dom { { { A } } } = { A } ;;
}

proof of dmsnsnsn {
	var x : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = opid (step 1) |- 〈 x , x 〉 = { { x } } ;;
	step 3 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 4 : wff = sneqd (step 3) |- ( x = A → { { x } } = { { A } } ) ;;
	step 5 : wff = syl5eq (step 2, step 4) |- ( x = A → 〈 x , x 〉 = { { A } } ) ;;
	step 6 : wff = sneqd (step 5) |- ( x = A → { 〈 x , x 〉 } = { { { A } } } ) ;;
	step 7 : wff = dmeqd (step 6) |- ( x = A → dom { 〈 x , x 〉 } = dom { { { A } } } ) ;;
	step 8 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 9 : wff = eqeq12d (step 7, step 8) |- ( x = A → ( dom { 〈 x , x 〉 } = { x } ↔ dom { { { A } } } = { A } ) ) ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = dmsnop (step 10) |- dom { 〈 x , x 〉 } = { x } ;;
	step 12 : wff = vtoclg (step 9, step 11) |- ( A ∈ _V → dom { { { A } } } = { A } ) ;;
	step 13 : wff = 0ex () |- ∅ ∈ _V ;;
	step 14 : wff = snid (step 13) |- ∅ ∈ { ∅ } ;;
	step 15 : wff = dmsn0el () |- ( ∅ ∈ { ∅ } → dom { { ∅ } } = ∅ ) ;;
	step 16 : wff = ax-mp (step 14, step 15) |- dom { { ∅ } } = ∅ ;;
	step 17 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 18 : wff = biimpi (step 17) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 19 : wff = sneqd (step 18) |- ( ¬ A ∈ _V → { { A } } = { ∅ } ) ;;
	step 20 : wff = sneqd (step 19) |- ( ¬ A ∈ _V → { { { A } } } = { { ∅ } } ) ;;
	step 21 : wff = dmeqd (step 20) |- ( ¬ A ∈ _V → dom { { { A } } } = dom { { ∅ } } ) ;;
	step 22 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 23 : wff = biimpi (step 22) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 24 : wff = 3eqtr4a (step 16, step 21, step 23) |- ( ¬ A ∈ _V → dom { { { A } } } = { A } ) ;;
	step 25 : wff = pm2.61i (step 12, step 24) |- dom { { { A } } } = { A } ;;
	qed prop 1 = step 25 ;;
}

/*The range of a singleton of an ordered pair is the singleton of the second
     member.  (Contributed by NM, 24-Jul-2004.)  (Revised by Mario Carneiro,
     30-Apr-2015.) */

theorem rnsnopg (A : class, B : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ran { 〈 A , B 〉 } = { B } ) ;;
}

proof of rnsnopg {
	step 1 : wff = df-rn () |- ran { 〈 A , B 〉 } = dom ⁻¹ { 〈 A , B 〉 } ;;
	step 2 : wff = dfdm4 () |- dom { 〈 B , A 〉 } = ran ⁻¹ { 〈 B , A 〉 } ;;
	step 3 : wff = df-rn () |- ran ⁻¹ { 〈 B , A 〉 } = dom ⁻¹ ⁻¹ { 〈 B , A 〉 } ;;
	step 4 : wff = cnvcnvsn () |- ⁻¹ ⁻¹ { 〈 B , A 〉 } = ⁻¹ { 〈 A , B 〉 } ;;
	step 5 : wff = dmeqi (step 4) |- dom ⁻¹ ⁻¹ { 〈 B , A 〉 } = dom ⁻¹ { 〈 A , B 〉 } ;;
	step 6 : wff = 3eqtri (step 2, step 3, step 5) |- dom { 〈 B , A 〉 } = dom ⁻¹ { 〈 A , B 〉 } ;;
	step 7 : wff = eqtr4i (step 1, step 6) |- ran { 〈 A , B 〉 } = dom { 〈 B , A 〉 } ;;
	step 8 : wff = dmsnopg () |- ( A ∈ V → dom { 〈 B , A 〉 } = { B } ) ;;
	step 9 : wff = syl5eq (step 7, step 8) |- ( A ∈ V → ran { 〈 A , B 〉 } = { B } ) ;;
	qed prop 1 = step 9 ;;
}

/*The range of a singleton of an ordered pair is the singleton of the
       second member.  (Contributed by NM, 24-Jul-2004.)  (Revised by Mario
       Carneiro, 26-Apr-2015.) */

theorem rnsnop (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ran { 〈 A , B 〉 } = { B } ;;
}

proof of rnsnop {
	step 1 : wff = rnsnopg () |- ( A ∈ _V → ran { 〈 A , B 〉 } = { B } ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ran { 〈 A , B 〉 } = { B } ;;
	qed prop 1 = step 2 ;;
}

/*Extract the first member of an ordered pair.  (See ~ op2nda to extract
       the second member, ~ op1stb for an alternate version, and ~ op1st for
       the preferred version.)  (Contributed by Raph Levien, 4-Dec-2003.) */

theorem op1sta (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋃ dom { 〈 A , B 〉 } = A ;;
}

proof of op1sta {
	step 1 : wff = dmsnop (hyp 2) |- dom { 〈 A , B 〉 } = { A } ;;
	step 2 : wff = unieqi (step 1) |- ⋃ dom { 〈 A , B 〉 } = ⋃ { A } ;;
	step 3 : wff = unisn (hyp 1) |- ⋃ { A } = A ;;
	step 4 : wff = eqtri (step 2, step 3) |- ⋃ dom { 〈 A , B 〉 } = A ;;
	qed prop 1 = step 4 ;;
}

/*Converse of a singleton of an ordered pair.  (Contributed by NM,
       11-May-1998.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem cnvsn (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ;;
}

proof of cnvsn {
	step 1 : wff = cnvcnvsn () |- ⁻¹ ⁻¹ { 〈 B , A 〉 } = ⁻¹ { 〈 A , B 〉 } ;;
	step 2 : wff = relsnop (hyp 2, hyp 1) |- Rel { 〈 B , A 〉 } ;;
	step 3 : wff = dfrel2 () |- ( Rel { 〈 B , A 〉 } ↔ ⁻¹ ⁻¹ { 〈 B , A 〉 } = { 〈 B , A 〉 } ) ;;
	step 4 : wff = mpbi (step 2, step 3) |- ⁻¹ ⁻¹ { 〈 B , A 〉 } = { 〈 B , A 〉 } ;;
	step 5 : wff = eqtr3i (step 1, step 4) |- ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ;;
	qed prop 1 = step 5 ;;
}

/*Extract the second member of an ordered pair.  Theorem 5.12(ii) of
       [Monk1] p. 52.  (See ~ op1stb to extract the first member, ~ op2nda for
       an alternate version, and ~ op2nd for the preferred version.)
       (Contributed by NM, 25-Nov-2003.) */

theorem op2ndb (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ ⋂ ⋂ ⁻¹ { 〈 A , B 〉 } = B ;;
}

proof of op2ndb {
	step 1 : wff = cnvsn (hyp 1, hyp 2) |- ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ;;
	step 2 : wff = inteqi (step 1) |- ⋂ ⁻¹ { 〈 A , B 〉 } = ⋂ { 〈 B , A 〉 } ;;
	step 3 : wff = opex () |- 〈 B , A 〉 ∈ _V ;;
	step 4 : wff = intsn (step 3) |- ⋂ { 〈 B , A 〉 } = 〈 B , A 〉 ;;
	step 5 : wff = eqtri (step 2, step 4) |- ⋂ ⁻¹ { 〈 A , B 〉 } = 〈 B , A 〉 ;;
	step 6 : wff = inteqi (step 5) |- ⋂ ⋂ ⁻¹ { 〈 A , B 〉 } = ⋂ 〈 B , A 〉 ;;
	step 7 : wff = inteqi (step 6) |- ⋂ ⋂ ⋂ ⁻¹ { 〈 A , B 〉 } = ⋂ ⋂ 〈 B , A 〉 ;;
	step 8 : wff = op1stb (hyp 2, hyp 1) |- ⋂ ⋂ 〈 B , A 〉 = B ;;
	step 9 : wff = eqtri (step 7, step 8) |- ⋂ ⋂ ⋂ ⁻¹ { 〈 A , B 〉 } = B ;;
	qed prop 1 = step 9 ;;
}

/*Extract the second member of an ordered pair.  (See ~ op1sta to extract
       the first member, ~ op2ndb for an alternate version, and ~ op2nd for the
       preferred version.)  (Contributed by NM, 17-Feb-2004.)  (Proof shortened
       by Andrew Salmon, 27-Aug-2011.) */

theorem op2nda (A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋃ ran { 〈 A , B 〉 } = B ;;
}

proof of op2nda {
	step 1 : wff = rnsnop (hyp 1) |- ran { 〈 A , B 〉 } = { B } ;;
	step 2 : wff = unieqi (step 1) |- ⋃ ran { 〈 A , B 〉 } = ⋃ { B } ;;
	step 3 : wff = unisn (hyp 2) |- ⋃ { B } = B ;;
	step 4 : wff = eqtri (step 2, step 3) |- ⋃ ran { 〈 A , B 〉 } = B ;;
	qed prop 1 = step 4 ;;
}

/*Converse of a singleton of an ordered pair.  (Contributed by NM,
       23-Jan-2015.) */

theorem cnvsng (A : class, B : class, V : class, W : class) disjointed(x y A, x y B, x y) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ) ;;
}

proof of cnvsng {
	var x : set, y : set;;
	step 1 : wff = opeq1 () |- ( x = A → 〈 x , y 〉 = 〈 A , y 〉 ) ;;
	step 2 : wff = sneqd (step 1) |- ( x = A → { 〈 x , y 〉 } = { 〈 A , y 〉 } ) ;;
	step 3 : wff = cnveqd (step 2) |- ( x = A → ⁻¹ { 〈 x , y 〉 } = ⁻¹ { 〈 A , y 〉 } ) ;;
	step 4 : wff = opeq2 () |- ( x = A → 〈 y , x 〉 = 〈 y , A 〉 ) ;;
	step 5 : wff = sneqd (step 4) |- ( x = A → { 〈 y , x 〉 } = { 〈 y , A 〉 } ) ;;
	step 6 : wff = eqeq12d (step 3, step 5) |- ( x = A → ( ⁻¹ { 〈 x , y 〉 } = { 〈 y , x 〉 } ↔ ⁻¹ { 〈 A , y 〉 } = { 〈 y , A 〉 } ) ) ;;
	step 7 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 8 : wff = sneqd (step 7) |- ( y = B → { 〈 A , y 〉 } = { 〈 A , B 〉 } ) ;;
	step 9 : wff = cnveqd (step 8) |- ( y = B → ⁻¹ { 〈 A , y 〉 } = ⁻¹ { 〈 A , B 〉 } ) ;;
	step 10 : wff = opeq1 () |- ( y = B → 〈 y , A 〉 = 〈 B , A 〉 ) ;;
	step 11 : wff = sneqd (step 10) |- ( y = B → { 〈 y , A 〉 } = { 〈 B , A 〉 } ) ;;
	step 12 : wff = eqeq12d (step 9, step 11) |- ( y = B → ( ⁻¹ { 〈 A , y 〉 } = { 〈 y , A 〉 } ↔ ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ) ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = cnvsn (step 13, step 14) |- ⁻¹ { 〈 x , y 〉 } = { 〈 y , x 〉 } ;;
	step 16 : wff = vtocl2g (step 6, step 12, step 15) |- ( ( A ∈ V ∧ B ∈ W ) → ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ) ;;
	qed prop 1 = step 16 ;;
}

/*Swap the members of an ordered pair.  (Contributed by NM, 14-Dec-2008.)
       (Revised by Mario Carneiro, 30-Aug-2015.) */

theorem opswap (A : class, B : class) disjointed(A, B) {
	prop 1 : wff = |- ⋃ ⁻¹ { 〈 A , B 〉 } = 〈 B , A 〉 ;;
}

proof of opswap {
	step 1 : wff = cnvsng () |- ( ( A ∈ _V ∧ B ∈ _V ) → ⁻¹ { 〈 A , B 〉 } = { 〈 B , A 〉 } ) ;;
	step 2 : wff = unieqd (step 1) |- ( ( A ∈ _V ∧ B ∈ _V ) → ⋃ ⁻¹ { 〈 A , B 〉 } = ⋃ { 〈 B , A 〉 } ) ;;
	step 3 : wff = opex () |- 〈 B , A 〉 ∈ _V ;;
	step 4 : wff = unisn (step 3) |- ⋃ { 〈 B , A 〉 } = 〈 B , A 〉 ;;
	step 5 : wff = syl6eq (step 2, step 4) |- ( ( A ∈ _V ∧ B ∈ _V ) → ⋃ ⁻¹ { 〈 A , B 〉 } = 〈 B , A 〉 ) ;;
	step 6 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 7 : wff = opprc () |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → 〈 A , B 〉 = ∅ ) ;;
	step 8 : wff = sneqd (step 7) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → { 〈 A , B 〉 } = { ∅ } ) ;;
	step 9 : wff = cnveqd (step 8) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ⁻¹ { 〈 A , B 〉 } = ⁻¹ { ∅ } ) ;;
	step 10 : wff = cnvsn0 () |- ⁻¹ { ∅ } = ∅ ;;
	step 11 : wff = syl6eq (step 9, step 10) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ⁻¹ { 〈 A , B 〉 } = ∅ ) ;;
	step 12 : wff = unieqd (step 11) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ⋃ ⁻¹ { 〈 A , B 〉 } = ⋃ ∅ ) ;;
	step 13 : wff = ancom () |- ( ( A ∈ _V ∧ B ∈ _V ) ↔ ( B ∈ _V ∧ A ∈ _V ) ) ;;
	step 14 : wff = opprc () |- ( ¬ ( B ∈ _V ∧ A ∈ _V ) → 〈 B , A 〉 = ∅ ) ;;
	step 15 : wff = sylnbi (step 13, step 14) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → 〈 B , A 〉 = ∅ ) ;;
	step 16 : wff = 3eqtr4a (step 6, step 12, step 15) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ⋃ ⁻¹ { 〈 A , B 〉 } = 〈 B , A 〉 ) ;;
	step 17 : wff = pm2.61i (step 5, step 16) |- ⋃ ⁻¹ { 〈 A , B 〉 } = 〈 B , A 〉 ;;
	qed prop 1 = step 17 ;;
}

/*Membership in a cross product.  This version requires no quantifiers or
       dummy variables.  See also ~ elxp5 , ~ elxp6 , and ~ elxp7 .
       (Contributed by NM, 17-Feb-2004.) */

theorem elxp4 (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ( A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ∧ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
}

proof of elxp4 {
	var x : set, y : set;;
	step 1 : wff = elxp () |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 2 : wff = sneq () |- ( A = 〈 x , y 〉 → { A } = { 〈 x , y 〉 } ) ;;
	step 3 : wff = rneqd (step 2) |- ( A = 〈 x , y 〉 → ran { A } = ran { 〈 x , y 〉 } ) ;;
	step 4 : wff = unieqd (step 3) |- ( A = 〈 x , y 〉 → ⋃ ran { A } = ⋃ ran { 〈 x , y 〉 } ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = op2nda (step 5, step 6) |- ⋃ ran { 〈 x , y 〉 } = y ;;
	step 8 : wff = syl6req (step 4, step 7) |- ( A = 〈 x , y 〉 → y = ⋃ ran { A } ) ;;
	step 9 : wff = pm4.71ri (step 8) |- ( A = 〈 x , y 〉 ↔ ( y = ⋃ ran { A } ∧ A = 〈 x , y 〉 ) ) ;;
	step 10 : wff = anbi1i (step 9) |- ( ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( ( y = ⋃ ran { A } ∧ A = 〈 x , y 〉 ) ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 11 : wff = anass () |- ( ( ( y = ⋃ ran { A } ∧ A = 〈 x , y 〉 ) ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ∃ y ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 14 : wff = snex () |- { A } ∈ _V ;;
	step 15 : wff = rnex (step 14) |- ran { A } ∈ _V ;;
	step 16 : wff = uniex (step 15) |- ⋃ ran { A } ∈ _V ;;
	step 17 : wff = opeq2 () |- ( y = ⋃ ran { A } → 〈 x , y 〉 = 〈 x , ⋃ ran { A } 〉 ) ;;
	step 18 : wff = eqeq2d (step 17) |- ( y = ⋃ ran { A } → ( A = 〈 x , y 〉 ↔ A = 〈 x , ⋃ ran { A } 〉 ) ) ;;
	step 19 : wff = eleq1 () |- ( y = ⋃ ran { A } → ( y ∈ C ↔ ⋃ ran { A } ∈ C ) ) ;;
	step 20 : wff = anbi2d (step 19) |- ( y = ⋃ ran { A } → ( ( x ∈ B ∧ y ∈ C ) ↔ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 21 : wff = anbi12d (step 18, step 20) |- ( y = ⋃ ran { A } → ( ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 22 : wff = ceqsexv (step 16, step 21) |- ( ∃ y ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ↔ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 23 : wff = bitri (step 13, step 22) |- ( ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 24 : wff = sneq () |- ( A = 〈 x , ⋃ ran { A } 〉 → { A } = { 〈 x , ⋃ ran { A } 〉 } ) ;;
	step 25 : wff = dmeqd (step 24) |- ( A = 〈 x , ⋃ ran { A } 〉 → dom { A } = dom { 〈 x , ⋃ ran { A } 〉 } ) ;;
	step 26 : wff = unieqd (step 25) |- ( A = 〈 x , ⋃ ran { A } 〉 → ⋃ dom { A } = ⋃ dom { 〈 x , ⋃ ran { A } 〉 } ) ;;
	step 27 : wff = vex () |- x ∈ _V ;;
	step 28 : wff = snex () |- { A } ∈ _V ;;
	step 29 : wff = rnex (step 28) |- ran { A } ∈ _V ;;
	step 30 : wff = uniex (step 29) |- ⋃ ran { A } ∈ _V ;;
	step 31 : wff = op1sta (step 27, step 30) |- ⋃ dom { 〈 x , ⋃ ran { A } 〉 } = x ;;
	step 32 : wff = syl6req (step 26, step 31) |- ( A = 〈 x , ⋃ ran { A } 〉 → x = ⋃ dom { A } ) ;;
	step 33 : wff = pm4.71ri (step 32) |- ( A = 〈 x , ⋃ ran { A } 〉 ↔ ( x = ⋃ dom { A } ∧ A = 〈 x , ⋃ ran { A } 〉 ) ) ;;
	step 34 : wff = anbi1i (step 33) |- ( ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ↔ ( ( x = ⋃ dom { A } ∧ A = 〈 x , ⋃ ran { A } 〉 ) ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 35 : wff = anass () |- ( ( ( x = ⋃ dom { A } ∧ A = 〈 x , ⋃ ran { A } 〉 ) ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ↔ ( x = ⋃ dom { A } ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 36 : wff = 3bitri (step 23, step 34, step 35) |- ( ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( x = ⋃ dom { A } ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 37 : wff = exbii (step 36) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ∃ x ( x = ⋃ dom { A } ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 38 : wff = snex () |- { A } ∈ _V ;;
	step 39 : wff = dmex (step 38) |- dom { A } ∈ _V ;;
	step 40 : wff = uniex (step 39) |- ⋃ dom { A } ∈ _V ;;
	step 41 : wff = opeq1 () |- ( x = ⋃ dom { A } → 〈 x , ⋃ ran { A } 〉 = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ) ;;
	step 42 : wff = eqeq2d (step 41) |- ( x = ⋃ dom { A } → ( A = 〈 x , ⋃ ran { A } 〉 ↔ A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ) ) ;;
	step 43 : wff = eleq1 () |- ( x = ⋃ dom { A } → ( x ∈ B ↔ ⋃ dom { A } ∈ B ) ) ;;
	step 44 : wff = anbi1d (step 43) |- ( x = ⋃ dom { A } → ( ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ↔ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 45 : wff = anbi12d (step 42, step 44) |- ( x = ⋃ dom { A } → ( ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ↔ ( A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ∧ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 46 : wff = ceqsexv (step 40, step 45) |- ( ∃ x ( x = ⋃ dom { A } ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ↔ ( A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ∧ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 47 : wff = 3bitri (step 1, step 37, step 46) |- ( A ∈ ( B × C ) ↔ ( A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ∧ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	qed prop 1 = step 47 ;;
}

/*Membership in a cross product requiring no quantifiers or dummy
       variables.  Provides a slightly shorter version of ~ elxp4 when the
       double intersection does not create class existence problems (caused by
       ~ int0 ).  (Contributed by NM, 1-Aug-2004.) */

theorem elxp5 (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ( A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ∧ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
}

proof of elxp5 {
	var x : set, y : set;;
	step 1 : wff = elxp () |- ( A ∈ ( B × C ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 2 : wff = sneq () |- ( A = 〈 x , y 〉 → { A } = { 〈 x , y 〉 } ) ;;
	step 3 : wff = rneqd (step 2) |- ( A = 〈 x , y 〉 → ran { A } = ran { 〈 x , y 〉 } ) ;;
	step 4 : wff = unieqd (step 3) |- ( A = 〈 x , y 〉 → ⋃ ran { A } = ⋃ ran { 〈 x , y 〉 } ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = op2nda (step 5, step 6) |- ⋃ ran { 〈 x , y 〉 } = y ;;
	step 8 : wff = syl6req (step 4, step 7) |- ( A = 〈 x , y 〉 → y = ⋃ ran { A } ) ;;
	step 9 : wff = pm4.71ri (step 8) |- ( A = 〈 x , y 〉 ↔ ( y = ⋃ ran { A } ∧ A = 〈 x , y 〉 ) ) ;;
	step 10 : wff = anbi1i (step 9) |- ( ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( ( y = ⋃ ran { A } ∧ A = 〈 x , y 〉 ) ∧ ( x ∈ B ∧ y ∈ C ) ) ) ;;
	step 11 : wff = anass () |- ( ( ( y = ⋃ ran { A } ∧ A = 〈 x , y 〉 ) ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ∃ y ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ) ;;
	step 14 : wff = snex () |- { A } ∈ _V ;;
	step 15 : wff = rnex (step 14) |- ran { A } ∈ _V ;;
	step 16 : wff = uniex (step 15) |- ⋃ ran { A } ∈ _V ;;
	step 17 : wff = opeq2 () |- ( y = ⋃ ran { A } → 〈 x , y 〉 = 〈 x , ⋃ ran { A } 〉 ) ;;
	step 18 : wff = eqeq2d (step 17) |- ( y = ⋃ ran { A } → ( A = 〈 x , y 〉 ↔ A = 〈 x , ⋃ ran { A } 〉 ) ) ;;
	step 19 : wff = eleq1 () |- ( y = ⋃ ran { A } → ( y ∈ C ↔ ⋃ ran { A } ∈ C ) ) ;;
	step 20 : wff = anbi2d (step 19) |- ( y = ⋃ ran { A } → ( ( x ∈ B ∧ y ∈ C ) ↔ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 21 : wff = anbi12d (step 18, step 20) |- ( y = ⋃ ran { A } → ( ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 22 : wff = ceqsexv (step 16, step 21) |- ( ∃ y ( y = ⋃ ran { A } ∧ ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ) ↔ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 23 : wff = bitri (step 13, step 22) |- ( ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 24 : wff = inteq () |- ( A = 〈 x , ⋃ ran { A } 〉 → ⋂ A = ⋂ 〈 x , ⋃ ran { A } 〉 ) ;;
	step 25 : wff = inteqd (step 24) |- ( A = 〈 x , ⋃ ran { A } 〉 → ⋂ ⋂ A = ⋂ ⋂ 〈 x , ⋃ ran { A } 〉 ) ;;
	step 26 : wff = vex () |- x ∈ _V ;;
	step 27 : wff = snex () |- { A } ∈ _V ;;
	step 28 : wff = rnex (step 27) |- ran { A } ∈ _V ;;
	step 29 : wff = uniex (step 28) |- ⋃ ran { A } ∈ _V ;;
	step 30 : wff = op1stb (step 26, step 29) |- ⋂ ⋂ 〈 x , ⋃ ran { A } 〉 = x ;;
	step 31 : wff = syl6req (step 25, step 30) |- ( A = 〈 x , ⋃ ran { A } 〉 → x = ⋂ ⋂ A ) ;;
	step 32 : wff = pm4.71ri (step 31) |- ( A = 〈 x , ⋃ ran { A } 〉 ↔ ( x = ⋂ ⋂ A ∧ A = 〈 x , ⋃ ran { A } 〉 ) ) ;;
	step 33 : wff = anbi1i (step 32) |- ( ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ↔ ( ( x = ⋂ ⋂ A ∧ A = 〈 x , ⋃ ran { A } 〉 ) ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 34 : wff = anass () |- ( ( ( x = ⋂ ⋂ A ∧ A = 〈 x , ⋃ ran { A } 〉 ) ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ↔ ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 35 : wff = 3bitri (step 23, step 33, step 34) |- ( ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 36 : wff = exbii (step 35) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ( x ∈ B ∧ y ∈ C ) ) ↔ ∃ x ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 37 : wff = vex () |- x ∈ _V ;;
	step 38 : wff = eleq1 () |- ( x = ⋂ ⋂ A → ( x ∈ _V ↔ ⋂ ⋂ A ∈ _V ) ) ;;
	step 39 : wff = mpbii (step 37, step 38) |- ( x = ⋂ ⋂ A → ⋂ ⋂ A ∈ _V ) ;;
	step 40 : wff = adantr (step 39) |- ( ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) → ⋂ ⋂ A ∈ _V ) ;;
	step 41 : wff = exlimiv (step 40) |- ( ∃ x ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) → ⋂ ⋂ A ∈ _V ) ;;
	step 42 : wff = elex () |- ( ⋂ ⋂ A ∈ B → ⋂ ⋂ A ∈ _V ) ;;
	step 43 : wff = ad2antrl (step 42) |- ( ( A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ∧ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) → ⋂ ⋂ A ∈ _V ) ;;
	step 44 : wff = opeq1 () |- ( x = ⋂ ⋂ A → 〈 x , ⋃ ran { A } 〉 = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ) ;;
	step 45 : wff = eqeq2d (step 44) |- ( x = ⋂ ⋂ A → ( A = 〈 x , ⋃ ran { A } 〉 ↔ A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ) ) ;;
	step 46 : wff = eleq1 () |- ( x = ⋂ ⋂ A → ( x ∈ B ↔ ⋂ ⋂ A ∈ B ) ) ;;
	step 47 : wff = anbi1d (step 46) |- ( x = ⋂ ⋂ A → ( ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ↔ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 48 : wff = anbi12d (step 45, step 47) |- ( x = ⋂ ⋂ A → ( ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ↔ ( A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ∧ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 49 : wff = ceqsexgv (step 48) |- ( ⋂ ⋂ A ∈ _V → ( ∃ x ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ↔ ( A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ∧ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ) ;;
	step 50 : wff = pm5.21nii (step 41, step 43, step 49) |- ( ∃ x ( x = ⋂ ⋂ A ∧ ( A = 〈 x , ⋃ ran { A } 〉 ∧ ( x ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ↔ ( A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ∧ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 51 : wff = 3bitri (step 1, step 36, step 50) |- ( A ∈ ( B × C ) ↔ ( A = 〈 ⋂ ⋂ A , ⋃ ran { A } 〉 ∧ ( ⋂ ⋂ A ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	qed prop 1 = step 51 ;;
}

/*An image under the converse of a restriction.  (Contributed by Jeff
       Hankins, 12-Jul-2009.) */

theorem cnvresima (A : class, B : class, F : class) disjointed(s t A, s t B, s t F) {
	prop 1 : wff = |- ( ⁻¹ ( F ↾ A ) " B ) = ( ( ⁻¹ F " B ) ∩ A ) ;;
}

proof of cnvresima {
	var t : set, s : set;;
	step 1 : wff = vex () |- t ∈ _V ;;
	step 2 : wff = elima3 (step 1) |- ( t ∈ ( ⁻¹ ( F ↾ A ) " B ) ↔ ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ) ) ;;
	step 3 : wff = vex () |- t ∈ _V ;;
	step 4 : wff = elima3 (step 3) |- ( t ∈ ( ⁻¹ F " B ) ↔ ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( t ∈ ( ⁻¹ F " B ) ∧ t ∈ A ) ↔ ( ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ) ;;
	step 6 : wff = elin () |- ( t ∈ ( ( ⁻¹ F " B ) ∩ A ) ↔ ( t ∈ ( ⁻¹ F " B ) ∧ t ∈ A ) ) ;;
	step 7 : wff = vex () |- s ∈ _V ;;
	step 8 : wff = vex () |- t ∈ _V ;;
	step 9 : wff = opelcnv (step 7, step 8) |- ( 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ↔ 〈 t , s 〉 ∈ ( F ↾ A ) ) ;;
	step 10 : wff = vex () |- s ∈ _V ;;
	step 11 : wff = opelres (step 10) |- ( 〈 t , s 〉 ∈ ( F ↾ A ) ↔ ( 〈 t , s 〉 ∈ F ∧ t ∈ A ) ) ;;
	step 12 : wff = vex () |- s ∈ _V ;;
	step 13 : wff = vex () |- t ∈ _V ;;
	step 14 : wff = opelcnv (step 12, step 13) |- ( 〈 s , t 〉 ∈ ⁻¹ F ↔ 〈 t , s 〉 ∈ F ) ;;
	step 15 : wff = anbi1i (step 14) |- ( ( 〈 s , t 〉 ∈ ⁻¹ F ∧ t ∈ A ) ↔ ( 〈 t , s 〉 ∈ F ∧ t ∈ A ) ) ;;
	step 16 : wff = bitr4i (step 11, step 15) |- ( 〈 t , s 〉 ∈ ( F ↾ A ) ↔ ( 〈 s , t 〉 ∈ ⁻¹ F ∧ t ∈ A ) ) ;;
	step 17 : wff = bitri (step 9, step 16) |- ( 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ↔ ( 〈 s , t 〉 ∈ ⁻¹ F ∧ t ∈ A ) ) ;;
	step 18 : wff = anbi2i (step 17) |- ( ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ) ↔ ( s ∈ B ∧ ( 〈 s , t 〉 ∈ ⁻¹ F ∧ t ∈ A ) ) ) ;;
	step 19 : wff = anass () |- ( ( ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ↔ ( s ∈ B ∧ ( 〈 s , t 〉 ∈ ⁻¹ F ∧ t ∈ A ) ) ) ;;
	step 20 : wff = bitr4i (step 18, step 19) |- ( ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ) ↔ ( ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ) ;;
	step 21 : wff = exbii (step 20) |- ( ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ) ↔ ∃ s ( ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ) ;;
	step 22 : wff = 19.41v () |- ( ∃ s ( ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ↔ ( ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ) ;;
	step 23 : wff = bitri (step 21, step 22) |- ( ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ) ↔ ( ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ F ) ∧ t ∈ A ) ) ;;
	step 24 : wff = 3bitr4ri (step 5, step 6, step 23) |- ( ∃ s ( s ∈ B ∧ 〈 s , t 〉 ∈ ⁻¹ ( F ↾ A ) ) ↔ t ∈ ( ( ⁻¹ F " B ) ∩ A ) ) ;;
	step 25 : wff = bitri (step 2, step 24) |- ( t ∈ ( ⁻¹ ( F ↾ A ) " B ) ↔ t ∈ ( ( ⁻¹ F " B ) ∩ A ) ) ;;
	step 26 : wff = eqriv (step 25) |- ( ⁻¹ ( F ↾ A ) " B ) = ( ( ⁻¹ F " B ) ∩ A ) ;;
	qed prop 1 = step 26 ;;
}

/*A class restricted to its domain equals its double converse.  (Contributed
     by NM, 8-Apr-2007.) */

theorem resdm2 (A : class)  {
	prop 1 : wff = |- ( A ↾ dom A ) = ⁻¹ ⁻¹ A ;;
}

proof of resdm2 {
	step 1 : wff = rescnvcnv () |- ( ⁻¹ ⁻¹ A ↾ dom ⁻¹ ⁻¹ A ) = ( A ↾ dom ⁻¹ ⁻¹ A ) ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ ⁻¹ A ;;
	step 3 : wff = resdm () |- ( Rel ⁻¹ ⁻¹ A → ( ⁻¹ ⁻¹ A ↾ dom ⁻¹ ⁻¹ A ) = ⁻¹ ⁻¹ A ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ⁻¹ ⁻¹ A ↾ dom ⁻¹ ⁻¹ A ) = ⁻¹ ⁻¹ A ;;
	step 5 : wff = dmcnvcnv () |- dom ⁻¹ ⁻¹ A = dom A ;;
	step 6 : wff = reseq2i (step 5) |- ( A ↾ dom ⁻¹ ⁻¹ A ) = ( A ↾ dom A ) ;;
	step 7 : wff = 3eqtr3ri (step 1, step 4, step 6) |- ( A ↾ dom A ) = ⁻¹ ⁻¹ A ;;
	qed prop 1 = step 7 ;;
}

/*Restriction to the domain of a restriction.  (Contributed by NM,
     8-Apr-2007.) */

theorem resdmres (A : class, B : class)  {
	prop 1 : wff = |- ( A ↾ dom ( A ↾ B ) ) = ( A ↾ B ) ;;
}

proof of resdmres {
	step 1 : wff = in12 () |- ( A ∩ ( ( B × _V ) ∩ ( dom A × _V ) ) ) = ( ( B × _V ) ∩ ( A ∩ ( dom A × _V ) ) ) ;;
	step 2 : wff = df-res () |- ( A ↾ dom A ) = ( A ∩ ( dom A × _V ) ) ;;
	step 3 : wff = resdm2 () |- ( A ↾ dom A ) = ⁻¹ ⁻¹ A ;;
	step 4 : wff = eqtr3i (step 2, step 3) |- ( A ∩ ( dom A × _V ) ) = ⁻¹ ⁻¹ A ;;
	step 5 : wff = ineq2i (step 4) |- ( ( B × _V ) ∩ ( A ∩ ( dom A × _V ) ) ) = ( ( B × _V ) ∩ ⁻¹ ⁻¹ A ) ;;
	step 6 : wff = incom () |- ( ( B × _V ) ∩ ⁻¹ ⁻¹ A ) = ( ⁻¹ ⁻¹ A ∩ ( B × _V ) ) ;;
	step 7 : wff = 3eqtri (step 1, step 5, step 6) |- ( A ∩ ( ( B × _V ) ∩ ( dom A × _V ) ) ) = ( ⁻¹ ⁻¹ A ∩ ( B × _V ) ) ;;
	step 8 : wff = df-res () |- ( A ↾ dom ( A ↾ B ) ) = ( A ∩ ( dom ( A ↾ B ) × _V ) ) ;;
	step 9 : wff = dmres () |- dom ( A ↾ B ) = ( B ∩ dom A ) ;;
	step 10 : wff = xpeq1i (step 9) |- ( dom ( A ↾ B ) × _V ) = ( ( B ∩ dom A ) × _V ) ;;
	step 11 : wff = xpindir () |- ( ( B ∩ dom A ) × _V ) = ( ( B × _V ) ∩ ( dom A × _V ) ) ;;
	step 12 : wff = eqtri (step 10, step 11) |- ( dom ( A ↾ B ) × _V ) = ( ( B × _V ) ∩ ( dom A × _V ) ) ;;
	step 13 : wff = ineq2i (step 12) |- ( A ∩ ( dom ( A ↾ B ) × _V ) ) = ( A ∩ ( ( B × _V ) ∩ ( dom A × _V ) ) ) ;;
	step 14 : wff = eqtri (step 8, step 13) |- ( A ↾ dom ( A ↾ B ) ) = ( A ∩ ( ( B × _V ) ∩ ( dom A × _V ) ) ) ;;
	step 15 : wff = df-res () |- ( ⁻¹ ⁻¹ A ↾ B ) = ( ⁻¹ ⁻¹ A ∩ ( B × _V ) ) ;;
	step 16 : wff = 3eqtr4i (step 7, step 14, step 15) |- ( A ↾ dom ( A ↾ B ) ) = ( ⁻¹ ⁻¹ A ↾ B ) ;;
	step 17 : wff = rescnvcnv () |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ↾ B ) ;;
	step 18 : wff = eqtri (step 16, step 17) |- ( A ↾ dom ( A ↾ B ) ) = ( A ↾ B ) ;;
	qed prop 1 = step 18 ;;
}

/*The image of the domain of a restriction.  (Contributed by NM,
     8-Apr-2007.) */

theorem imadmres (A : class, B : class)  {
	prop 1 : wff = |- ( A " dom ( A ↾ B ) ) = ( A " B ) ;;
}

proof of imadmres {
	step 1 : wff = resdmres () |- ( A ↾ dom ( A ↾ B ) ) = ( A ↾ B ) ;;
	step 2 : wff = rneqi (step 1) |- ran ( A ↾ dom ( A ↾ B ) ) = ran ( A ↾ B ) ;;
	step 3 : wff = df-ima () |- ( A " dom ( A ↾ B ) ) = ran ( A ↾ dom ( A ↾ B ) ) ;;
	step 4 : wff = df-ima () |- ( A " B ) = ran ( A ↾ B ) ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- ( A " dom ( A ↾ B ) ) = ( A " B ) ;;
	qed prop 1 = step 5 ;;
}

/*The preimage of a function in maps-to notation.  (Contributed by Stefan
       O'Rear, 25-Jan-2015.) */

theorem mptpreima (x : set, A : class, B : class, C : class, F : class) disjointed(x y C, y A, y B, y F, x) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ⁻¹ F " C ) = { x ∈ A | B ∈ C } ;;
}

proof of mptpreima {
	var y : set;;
	step 1 : wff = df-mpt () |- ( x ∈ A ↦ B ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- F = { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 3 : wff = cnveqi (step 2) |- ⁻¹ F = ⁻¹ { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 4 : wff = cnvopab () |- ⁻¹ { 〈 x , y 〉 | ( x ∈ A ∧ y = B ) } = { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 5 : wff = eqtri (step 3, step 4) |- ⁻¹ F = { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } ;;
	step 6 : wff = imaeq1i (step 5) |- ( ⁻¹ F " C ) = ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } " C ) ;;
	step 7 : wff = df-ima () |- ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } " C ) = ran ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } ↾ C ) ;;
	step 8 : wff = resopab () |- ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } ↾ C ) = { 〈 y , x 〉 | ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) } ;;
	step 9 : wff = rneqi (step 8) |- ran ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } ↾ C ) = ran { 〈 y , x 〉 | ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) } ;;
	step 10 : wff = ancom () |- ( ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) ↔ ( ( x ∈ A ∧ y = B ) ∧ y ∈ C ) ) ;;
	step 11 : wff = anass () |- ( ( ( x ∈ A ∧ y = B ) ∧ y ∈ C ) ↔ ( x ∈ A ∧ ( y = B ∧ y ∈ C ) ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) ↔ ( x ∈ A ∧ ( y = B ∧ y ∈ C ) ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ y ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) ↔ ∃ y ( x ∈ A ∧ ( y = B ∧ y ∈ C ) ) ) ;;
	step 14 : wff = 19.42v () |- ( ∃ y ( x ∈ A ∧ ( y = B ∧ y ∈ C ) ) ↔ ( x ∈ A ∧ ∃ y ( y = B ∧ y ∈ C ) ) ) ;;
	step 15 : wff = df-clel () |- ( B ∈ C ↔ ∃ y ( y = B ∧ y ∈ C ) ) ;;
	step 16 : wff = bicomi (step 15) |- ( ∃ y ( y = B ∧ y ∈ C ) ↔ B ∈ C ) ;;
	step 17 : wff = anbi2i (step 16) |- ( ( x ∈ A ∧ ∃ y ( y = B ∧ y ∈ C ) ) ↔ ( x ∈ A ∧ B ∈ C ) ) ;;
	step 18 : wff = bitri (step 14, step 17) |- ( ∃ y ( x ∈ A ∧ ( y = B ∧ y ∈ C ) ) ↔ ( x ∈ A ∧ B ∈ C ) ) ;;
	step 19 : wff = bitri (step 13, step 18) |- ( ∃ y ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) ↔ ( x ∈ A ∧ B ∈ C ) ) ;;
	step 20 : wff = abbii (step 19) |- { x | ∃ y ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) } = { x | ( x ∈ A ∧ B ∈ C ) } ;;
	step 21 : wff = rnopab () |- ran { 〈 y , x 〉 | ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) } = { x | ∃ y ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) } ;;
	step 22 : wff = df-rab () |- { x ∈ A | B ∈ C } = { x | ( x ∈ A ∧ B ∈ C ) } ;;
	step 23 : wff = 3eqtr4i (step 20, step 21, step 22) |- ran { 〈 y , x 〉 | ( y ∈ C ∧ ( x ∈ A ∧ y = B ) ) } = { x ∈ A | B ∈ C } ;;
	step 24 : wff = eqtri (step 9, step 23) |- ran ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } ↾ C ) = { x ∈ A | B ∈ C } ;;
	step 25 : wff = eqtri (step 7, step 24) |- ( { 〈 y , x 〉 | ( x ∈ A ∧ y = B ) } " C ) = { x ∈ A | B ∈ C } ;;
	step 26 : wff = eqtri (step 6, step 25) |- ( ⁻¹ F " C ) = { x ∈ A | B ∈ C } ;;
	qed prop 1 = step 26 ;;
}

/*Converse singleton image of a function defined by maps-to.  (Contributed
       by Stefan O'Rear, 25-Jan-2015.) */

theorem mptiniseg (x : set, A : class, B : class, C : class, F : class, V : class) disjointed(x C, A, B, F, x V) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ V → ( ⁻¹ F " { C } ) = { x ∈ A | B = C } ) ;;
}

proof of mptiniseg {
	step 1 : wff = mptpreima (hyp 1) |- ( ⁻¹ F " { C } ) = { x ∈ A | B ∈ { C } } ;;
	step 2 : wff = elsnc2g () |- ( C ∈ V → ( B ∈ { C } ↔ B = C ) ) ;;
	step 3 : wff = rabbidv (step 2) |- ( C ∈ V → { x ∈ A | B ∈ { C } } = { x ∈ A | B = C } ) ;;
	step 4 : wff = syl5eq (step 1, step 3) |- ( C ∈ V → ( ⁻¹ F " { C } ) = { x ∈ A | B = C } ) ;;
	qed prop 1 = step 4 ;;
}

/*The domain of the mapping operation in general.  (Contributed by NM,
       16-May-1995.)  (Revised by Mario Carneiro, 22-Mar-2015.) */

theorem dmmpt (x : set, A : class, B : class, F : class) disjointed(x, A, B, F, x) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- dom F = { x ∈ A | B ∈ _V } ;;
}

proof of dmmpt {
	step 1 : wff = dfdm4 () |- dom F = ran ⁻¹ F ;;
	step 2 : wff = dfrn4 () |- ran ⁻¹ F = ( ⁻¹ F " _V ) ;;
	step 3 : wff = mptpreima (hyp 1) |- ( ⁻¹ F " _V ) = { x ∈ A | B ∈ _V } ;;
	step 4 : wff = 3eqtri (step 1, step 2, step 3) |- dom F = { x ∈ A | B ∈ _V } ;;
	qed prop 1 = step 4 ;;
}

/*The domain of a mapping is a subset of its base class.  (Contributed by
       Scott Fenton, 17-Jun-2013.) */

theorem dmmptss (x : set, A : class, B : class, F : class) disjointed(x, A, B, F, x, x A) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ B ) ;;
	-----------------------
	prop 1 : wff = |- dom F ⊆ A ;;
}

proof of dmmptss {
	step 1 : wff = dmmpt (hyp 1) |- dom F = { x ∈ A | B ∈ _V } ;;
	step 2 : wff = ssrab2 () |- { x ∈ A | B ∈ _V } ⊆ A ;;
	step 3 : wff = eqsstri (step 1, step 2) |- dom F ⊆ A ;;
	qed prop 1 = step 3 ;;
}

/*The domain of the mapping operation is the stated domain, if the
       function value is always a set.  (Contributed by Mario Carneiro,
       9-Feb-2013.)  (Revised by Mario Carneiro, 14-Sep-2013.) */

theorem dmmptg (x : set, A : class, B : class, V : class) disjointed(A x, B) {
	prop 1 : wff = |- ( ∀ x ∈ A B ∈ V → dom ( x ∈ A ↦ B ) = A ) ;;
}

proof of dmmptg {
	step 1 : wff = elex () |- ( B ∈ V → B ∈ _V ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ x ∈ A B ∈ V → ∀ x ∈ A B ∈ _V ) ;;
	step 3 : wff = rabid2 () |- ( A = { x ∈ A | B ∈ _V } ↔ ∀ x ∈ A B ∈ _V ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( ∀ x ∈ A B ∈ V → A = { x ∈ A | B ∈ _V } ) ;;
	step 5 : wff = eqid () |- ( x ∈ A ↦ B ) = ( x ∈ A ↦ B ) ;;
	step 6 : wff = dmmpt (step 5) |- dom ( x ∈ A ↦ B ) = { x ∈ A | B ∈ _V } ;;
	step 7 : wff = syl6reqr (step 4, step 6) |- ( ∀ x ∈ A B ∈ V → dom ( x ∈ A ↦ B ) = A ) ;;
	qed prop 1 = step 7 ;;
}

/*A composition is a relation.  Exercise 24 of [TakeutiZaring] p. 25.
       (Contributed by NM, 26-Jan-1997.) */

theorem relco (A : class, B : class) disjointed(x y z A, x y z B, x y z) {
	prop 1 : wff = |- Rel ( A ∘ B ) ;;
}

proof of relco {
	var x : set, y : set, z : set;;
	step 1 : wff = df-co () |- ( A ∘ B ) = { 〈 x , y 〉 | ∃ z ( x B z ∧ z A y ) } ;;
	step 2 : wff = relopabi (step 1) |- Rel ( A ∘ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Alternate definition of a class composition, using only one bound
       variable.  (Contributed by NM, 19-Dec-2008.) */

theorem dfco2 (x : set, A : class, B : class) disjointed(x y z A, x y z B, x y z) {
	prop 1 : wff = |- ( A ∘ B ) = ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ;;
}

proof of dfco2 {
	var y : set, z : set;;
	step 1 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 2 : wff = reliun () |- ( Rel ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∀ x ∈ _V Rel ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 3 : wff = relxp () |- Rel ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ;;
	step 4 : wff = a1i (step 3) |- ( x ∈ _V → Rel ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 5 : wff = mprgbir (step 2, step 4) |- Rel ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = vex () |- z ∈ _V ;;
	step 8 : wff = opelco2g () |- ( ( y ∈ _V ∧ z ∈ _V ) → ( 〈 y , z 〉 ∈ ( A ∘ B ) ↔ ∃ x ( 〈 y , x 〉 ∈ B ∧ 〈 x , z 〉 ∈ A ) ) ) ;;
	step 9 : wff = mp2an (step 6, step 7, step 8) |- ( 〈 y , z 〉 ∈ ( A ∘ B ) ↔ ∃ x ( 〈 y , x 〉 ∈ B ∧ 〈 x , z 〉 ∈ A ) ) ;;
	step 10 : wff = eliun () |- ( 〈 y , z 〉 ∈ ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ∈ _V 〈 y , z 〉 ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 11 : wff = rexv () |- ( ∃ x ∈ _V 〈 y , z 〉 ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x 〈 y , z 〉 ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 12 : wff = opelxp () |- ( 〈 y , z 〉 ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ( y ∈ ( ⁻¹ B " { x } ) ∧ z ∈ ( A " { x } ) ) ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = elimasn (step 13, step 14) |- ( y ∈ ( ⁻¹ B " { x } ) ↔ 〈 x , y 〉 ∈ ⁻¹ B ) ;;
	step 16 : wff = vex () |- x ∈ _V ;;
	step 17 : wff = vex () |- y ∈ _V ;;
	step 18 : wff = opelcnv (step 16, step 17) |- ( 〈 x , y 〉 ∈ ⁻¹ B ↔ 〈 y , x 〉 ∈ B ) ;;
	step 19 : wff = bitri (step 15, step 18) |- ( y ∈ ( ⁻¹ B " { x } ) ↔ 〈 y , x 〉 ∈ B ) ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- z ∈ _V ;;
	step 22 : wff = elimasn (step 20, step 21) |- ( z ∈ ( A " { x } ) ↔ 〈 x , z 〉 ∈ A ) ;;
	step 23 : wff = anbi12i (step 19, step 22) |- ( ( y ∈ ( ⁻¹ B " { x } ) ∧ z ∈ ( A " { x } ) ) ↔ ( 〈 y , x 〉 ∈ B ∧ 〈 x , z 〉 ∈ A ) ) ;;
	step 24 : wff = bitri (step 12, step 23) |- ( 〈 y , z 〉 ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ( 〈 y , x 〉 ∈ B ∧ 〈 x , z 〉 ∈ A ) ) ;;
	step 25 : wff = exbii (step 24) |- ( ∃ x 〈 y , z 〉 ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ( 〈 y , x 〉 ∈ B ∧ 〈 x , z 〉 ∈ A ) ) ;;
	step 26 : wff = 3bitrri (step 10, step 11, step 25) |- ( ∃ x ( 〈 y , x 〉 ∈ B ∧ 〈 x , z 〉 ∈ A ) ↔ 〈 y , z 〉 ∈ ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 27 : wff = bitri (step 9, step 26) |- ( 〈 y , z 〉 ∈ ( A ∘ B ) ↔ 〈 y , z 〉 ∈ ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 28 : wff = eqrelriiv (step 1, step 5, step 27) |- ( A ∘ B ) = ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ;;
	qed prop 1 = step 28 ;;
}

/*Generalization of ~ dfco2 , where ` C ` can have any value between
       ` dom A i^i ran B ` and ` _V ` .  (Contributed by NM, 21-Dec-2008.)
       (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem dfco2a (x : set, A : class, B : class, C : class) disjointed(w x y z A, w x y z B, w x y z C) {
	prop 1 : wff = |- ( ( dom A ∩ ran B ) ⊆ C → ( A ∘ B ) = ⋃_ x ∈ C ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
}

proof of dfco2a {
	var y : set, z : set, w : set;;
	step 1 : wff = dfco2 () |- ( A ∘ B ) = ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- z ∈ _V ;;
	step 4 : wff = eliniseg (step 3) |- ( x ∈ _V → ( z ∈ ( ⁻¹ B " { x } ) ↔ z B x ) ) ;;
	step 5 : wff = ax-mp (step 2, step 4) |- ( z ∈ ( ⁻¹ B " { x } ) ↔ z B x ) ;;
	step 6 : wff = vex () |- z ∈ _V ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = brelrn (step 6, step 7) |- ( z B x → x ∈ ran B ) ;;
	step 9 : wff = sylbi (step 5, step 8) |- ( z ∈ ( ⁻¹ B " { x } ) → x ∈ ran B ) ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = vex () |- w ∈ _V ;;
	step 12 : wff = elimasn (step 10, step 11) |- ( w ∈ ( A " { x } ) ↔ 〈 x , w 〉 ∈ A ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = vex () |- w ∈ _V ;;
	step 15 : wff = opeldm (step 13, step 14) |- ( 〈 x , w 〉 ∈ A → x ∈ dom A ) ;;
	step 16 : wff = sylbi (step 12, step 15) |- ( w ∈ ( A " { x } ) → x ∈ dom A ) ;;
	step 17 : wff = anim12ci (step 9, step 16) |- ( ( z ∈ ( ⁻¹ B " { x } ) ∧ w ∈ ( A " { x } ) ) → ( x ∈ dom A ∧ x ∈ ran B ) ) ;;
	step 18 : wff = adantl (step 17) |- ( ( y = 〈 z , w 〉 ∧ ( z ∈ ( ⁻¹ B " { x } ) ∧ w ∈ ( A " { x } ) ) ) → ( x ∈ dom A ∧ x ∈ ran B ) ) ;;
	step 19 : wff = exlimivv (step 18) |- ( ∃ z ∃ w ( y = 〈 z , w 〉 ∧ ( z ∈ ( ⁻¹ B " { x } ) ∧ w ∈ ( A " { x } ) ) ) → ( x ∈ dom A ∧ x ∈ ran B ) ) ;;
	step 20 : wff = elxp () |- ( y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ z ∃ w ( y = 〈 z , w 〉 ∧ ( z ∈ ( ⁻¹ B " { x } ) ∧ w ∈ ( A " { x } ) ) ) ) ;;
	step 21 : wff = elin () |- ( x ∈ ( dom A ∩ ran B ) ↔ ( x ∈ dom A ∧ x ∈ ran B ) ) ;;
	step 22 : wff = 3imtr4i (step 19, step 20, step 21) |- ( y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) → x ∈ ( dom A ∩ ran B ) ) ;;
	step 23 : wff = ssel () |- ( ( dom A ∩ ran B ) ⊆ C → ( x ∈ ( dom A ∩ ran B ) → x ∈ C ) ) ;;
	step 24 : wff = syl5 (step 22, step 23) |- ( ( dom A ∩ ran B ) ⊆ C → ( y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) → x ∈ C ) ) ;;
	step 25 : wff = pm4.71rd (step 24) |- ( ( dom A ∩ ran B ) ⊆ C → ( y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ( x ∈ C ∧ y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ) ) ;;
	step 26 : wff = exbidv (step 25) |- ( ( dom A ∩ ran B ) ⊆ C → ( ∃ x y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ( x ∈ C ∧ y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ) ) ;;
	step 27 : wff = rexv () |- ( ∃ x ∈ _V y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 28 : wff = df-rex () |- ( ∃ x ∈ C y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ( x ∈ C ∧ y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ) ;;
	step 29 : wff = 3bitr4g (step 26, step 27, step 28) |- ( ( dom A ∩ ran B ) ⊆ C → ( ∃ x ∈ _V y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ∈ C y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ) ;;
	step 30 : wff = eliun () |- ( y ∈ ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ∈ _V y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 31 : wff = eliun () |- ( y ∈ ⋃_ x ∈ C ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ ∃ x ∈ C y ∈ ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 32 : wff = 3bitr4g (step 29, step 30, step 31) |- ( ( dom A ∩ ran B ) ⊆ C → ( y ∈ ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ↔ y ∈ ⋃_ x ∈ C ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ) ;;
	step 33 : wff = eqrdv (step 32) |- ( ( dom A ∩ ran B ) ⊆ C → ⋃_ x ∈ _V ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) = ⋃_ x ∈ C ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	step 34 : wff = syl5eq (step 1, step 33) |- ( ( dom A ∩ ran B ) ⊆ C → ( A ∘ B ) = ⋃_ x ∈ C ( ( ⁻¹ B " { x } ) × ( A " { x } ) ) ) ;;
	qed prop 1 = step 34 ;;
}

/*Class composition distributes over union.  (Contributed by NM,
       21-Dec-2008.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem coundi (A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C) {
	prop 1 : wff = |- ( A ∘ ( B ∪ C ) ) = ( ( A ∘ B ) ∪ ( A ∘ C ) ) ;;
}

proof of coundi {
	var x : set, y : set, z : set;;
	step 1 : wff = unopab () |- ( { 〈 x , y 〉 | ∃ z ( x B z ∧ z A y ) } ∪ { 〈 x , y 〉 | ∃ z ( x C z ∧ z A y ) } ) = { 〈 x , y 〉 | ( ∃ z ( x B z ∧ z A y ) ∨ ∃ z ( x C z ∧ z A y ) ) } ;;
	step 2 : wff = brun () |- ( x ( B ∪ C ) z ↔ ( x B z ∨ x C z ) ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( x ( B ∪ C ) z ∧ z A y ) ↔ ( ( x B z ∨ x C z ) ∧ z A y ) ) ;;
	step 4 : wff = andir () |- ( ( ( x B z ∨ x C z ) ∧ z A y ) ↔ ( ( x B z ∧ z A y ) ∨ ( x C z ∧ z A y ) ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ( x ( B ∪ C ) z ∧ z A y ) ↔ ( ( x B z ∧ z A y ) ∨ ( x C z ∧ z A y ) ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ z ( x ( B ∪ C ) z ∧ z A y ) ↔ ∃ z ( ( x B z ∧ z A y ) ∨ ( x C z ∧ z A y ) ) ) ;;
	step 7 : wff = 19.43 () |- ( ∃ z ( ( x B z ∧ z A y ) ∨ ( x C z ∧ z A y ) ) ↔ ( ∃ z ( x B z ∧ z A y ) ∨ ∃ z ( x C z ∧ z A y ) ) ) ;;
	step 8 : wff = bitr2i (step 6, step 7) |- ( ( ∃ z ( x B z ∧ z A y ) ∨ ∃ z ( x C z ∧ z A y ) ) ↔ ∃ z ( x ( B ∪ C ) z ∧ z A y ) ) ;;
	step 9 : wff = opabbii (step 8) |- { 〈 x , y 〉 | ( ∃ z ( x B z ∧ z A y ) ∨ ∃ z ( x C z ∧ z A y ) ) } = { 〈 x , y 〉 | ∃ z ( x ( B ∪ C ) z ∧ z A y ) } ;;
	step 10 : wff = eqtri (step 1, step 9) |- ( { 〈 x , y 〉 | ∃ z ( x B z ∧ z A y ) } ∪ { 〈 x , y 〉 | ∃ z ( x C z ∧ z A y ) } ) = { 〈 x , y 〉 | ∃ z ( x ( B ∪ C ) z ∧ z A y ) } ;;
	step 11 : wff = df-co () |- ( A ∘ B ) = { 〈 x , y 〉 | ∃ z ( x B z ∧ z A y ) } ;;
	step 12 : wff = df-co () |- ( A ∘ C ) = { 〈 x , y 〉 | ∃ z ( x C z ∧ z A y ) } ;;
	step 13 : wff = uneq12i (step 11, step 12) |- ( ( A ∘ B ) ∪ ( A ∘ C ) ) = ( { 〈 x , y 〉 | ∃ z ( x B z ∧ z A y ) } ∪ { 〈 x , y 〉 | ∃ z ( x C z ∧ z A y ) } ) ;;
	step 14 : wff = df-co () |- ( A ∘ ( B ∪ C ) ) = { 〈 x , y 〉 | ∃ z ( x ( B ∪ C ) z ∧ z A y ) } ;;
	step 15 : wff = 3eqtr4ri (step 10, step 13, step 14) |- ( A ∘ ( B ∪ C ) ) = ( ( A ∘ B ) ∪ ( A ∘ C ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Class composition distributes over union.  (Contributed by NM,
       21-Dec-2008.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem coundir (A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C) {
	prop 1 : wff = |- ( ( A ∪ B ) ∘ C ) = ( ( A ∘ C ) ∪ ( B ∘ C ) ) ;;
}

proof of coundir {
	var x : set, y : set, z : set;;
	step 1 : wff = unopab () |- ( { 〈 x , z 〉 | ∃ y ( x C y ∧ y A z ) } ∪ { 〈 x , z 〉 | ∃ y ( x C y ∧ y B z ) } ) = { 〈 x , z 〉 | ( ∃ y ( x C y ∧ y A z ) ∨ ∃ y ( x C y ∧ y B z ) ) } ;;
	step 2 : wff = brun () |- ( y ( A ∪ B ) z ↔ ( y A z ∨ y B z ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( x C y ∧ y ( A ∪ B ) z ) ↔ ( x C y ∧ ( y A z ∨ y B z ) ) ) ;;
	step 4 : wff = andi () |- ( ( x C y ∧ ( y A z ∨ y B z ) ) ↔ ( ( x C y ∧ y A z ) ∨ ( x C y ∧ y B z ) ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ( x C y ∧ y ( A ∪ B ) z ) ↔ ( ( x C y ∧ y A z ) ∨ ( x C y ∧ y B z ) ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ( x C y ∧ y ( A ∪ B ) z ) ↔ ∃ y ( ( x C y ∧ y A z ) ∨ ( x C y ∧ y B z ) ) ) ;;
	step 7 : wff = 19.43 () |- ( ∃ y ( ( x C y ∧ y A z ) ∨ ( x C y ∧ y B z ) ) ↔ ( ∃ y ( x C y ∧ y A z ) ∨ ∃ y ( x C y ∧ y B z ) ) ) ;;
	step 8 : wff = bitr2i (step 6, step 7) |- ( ( ∃ y ( x C y ∧ y A z ) ∨ ∃ y ( x C y ∧ y B z ) ) ↔ ∃ y ( x C y ∧ y ( A ∪ B ) z ) ) ;;
	step 9 : wff = opabbii (step 8) |- { 〈 x , z 〉 | ( ∃ y ( x C y ∧ y A z ) ∨ ∃ y ( x C y ∧ y B z ) ) } = { 〈 x , z 〉 | ∃ y ( x C y ∧ y ( A ∪ B ) z ) } ;;
	step 10 : wff = eqtri (step 1, step 9) |- ( { 〈 x , z 〉 | ∃ y ( x C y ∧ y A z ) } ∪ { 〈 x , z 〉 | ∃ y ( x C y ∧ y B z ) } ) = { 〈 x , z 〉 | ∃ y ( x C y ∧ y ( A ∪ B ) z ) } ;;
	step 11 : wff = df-co () |- ( A ∘ C ) = { 〈 x , z 〉 | ∃ y ( x C y ∧ y A z ) } ;;
	step 12 : wff = df-co () |- ( B ∘ C ) = { 〈 x , z 〉 | ∃ y ( x C y ∧ y B z ) } ;;
	step 13 : wff = uneq12i (step 11, step 12) |- ( ( A ∘ C ) ∪ ( B ∘ C ) ) = ( { 〈 x , z 〉 | ∃ y ( x C y ∧ y A z ) } ∪ { 〈 x , z 〉 | ∃ y ( x C y ∧ y B z ) } ) ;;
	step 14 : wff = df-co () |- ( ( A ∪ B ) ∘ C ) = { 〈 x , z 〉 | ∃ y ( x C y ∧ y ( A ∪ B ) z ) } ;;
	step 15 : wff = 3eqtr4ri (step 10, step 13, step 14) |- ( ( A ∪ B ) ∘ C ) = ( ( A ∘ C ) ∪ ( B ∘ C ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Restricted first member of a class composition.  (Contributed by NM,
       12-Oct-2004.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem cores (A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C) {
	prop 1 : wff = |- ( ran B ⊆ C → ( ( A ↾ C ) ∘ B ) = ( A ∘ B ) ) ;;
}

proof of cores {
	var x : set, y : set, z : set;;
	step 1 : wff = vex () |- z ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = brelrn (step 1, step 2) |- ( z B y → y ∈ ran B ) ;;
	step 4 : wff = ssel () |- ( ran B ⊆ C → ( y ∈ ran B → y ∈ C ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = brres (step 5) |- ( y ( A ↾ C ) x ↔ ( y A x ∧ y ∈ C ) ) ;;
	step 7 : wff = rbaib (step 6) |- ( y ∈ C → ( y ( A ↾ C ) x ↔ y A x ) ) ;;
	step 8 : wff = syl56 (step 3, step 4, step 7) |- ( ran B ⊆ C → ( z B y → ( y ( A ↾ C ) x ↔ y A x ) ) ) ;;
	step 9 : wff = pm5.32d (step 8) |- ( ran B ⊆ C → ( ( z B y ∧ y ( A ↾ C ) x ) ↔ ( z B y ∧ y A x ) ) ) ;;
	step 10 : wff = exbidv (step 9) |- ( ran B ⊆ C → ( ∃ y ( z B y ∧ y ( A ↾ C ) x ) ↔ ∃ y ( z B y ∧ y A x ) ) ) ;;
	step 11 : wff = opabbidv (step 10) |- ( ran B ⊆ C → { 〈 z , x 〉 | ∃ y ( z B y ∧ y ( A ↾ C ) x ) } = { 〈 z , x 〉 | ∃ y ( z B y ∧ y A x ) } ) ;;
	step 12 : wff = df-co () |- ( ( A ↾ C ) ∘ B ) = { 〈 z , x 〉 | ∃ y ( z B y ∧ y ( A ↾ C ) x ) } ;;
	step 13 : wff = df-co () |- ( A ∘ B ) = { 〈 z , x 〉 | ∃ y ( z B y ∧ y A x ) } ;;
	step 14 : wff = 3eqtr4g (step 11, step 12, step 13) |- ( ran B ⊆ C → ( ( A ↾ C ) ∘ B ) = ( A ∘ B ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Associative law for the restriction of a composition.  (Contributed by
       NM, 12-Dec-2006.) */

theorem resco (A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C) {
	prop 1 : wff = |- ( ( A ∘ B ) ↾ C ) = ( A ∘ ( B ↾ C ) ) ;;
}

proof of resco {
	var x : set, y : set, z : set;;
	step 1 : wff = relres () |- Rel ( ( A ∘ B ) ↾ C ) ;;
	step 2 : wff = relco () |- Rel ( A ∘ ( B ↾ C ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = brco (step 3, step 4) |- ( x ( A ∘ B ) y ↔ ∃ z ( x B z ∧ z A y ) ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( x ( A ∘ B ) y ∧ x ∈ C ) ↔ ( ∃ z ( x B z ∧ z A y ) ∧ x ∈ C ) ) ;;
	step 7 : wff = 19.41v () |- ( ∃ z ( ( x B z ∧ z A y ) ∧ x ∈ C ) ↔ ( ∃ z ( x B z ∧ z A y ) ∧ x ∈ C ) ) ;;
	step 8 : wff = an32 () |- ( ( ( x B z ∧ z A y ) ∧ x ∈ C ) ↔ ( ( x B z ∧ x ∈ C ) ∧ z A y ) ) ;;
	step 9 : wff = vex () |- z ∈ _V ;;
	step 10 : wff = brres (step 9) |- ( x ( B ↾ C ) z ↔ ( x B z ∧ x ∈ C ) ) ;;
	step 11 : wff = anbi1i (step 10) |- ( ( x ( B ↾ C ) z ∧ z A y ) ↔ ( ( x B z ∧ x ∈ C ) ∧ z A y ) ) ;;
	step 12 : wff = bitr4i (step 8, step 11) |- ( ( ( x B z ∧ z A y ) ∧ x ∈ C ) ↔ ( x ( B ↾ C ) z ∧ z A y ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ z ( ( x B z ∧ z A y ) ∧ x ∈ C ) ↔ ∃ z ( x ( B ↾ C ) z ∧ z A y ) ) ;;
	step 14 : wff = 3bitr2i (step 6, step 7, step 13) |- ( ( x ( A ∘ B ) y ∧ x ∈ C ) ↔ ∃ z ( x ( B ↾ C ) z ∧ z A y ) ) ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = brres (step 15) |- ( x ( ( A ∘ B ) ↾ C ) y ↔ ( x ( A ∘ B ) y ∧ x ∈ C ) ) ;;
	step 17 : wff = vex () |- x ∈ _V ;;
	step 18 : wff = vex () |- y ∈ _V ;;
	step 19 : wff = brco (step 17, step 18) |- ( x ( A ∘ ( B ↾ C ) ) y ↔ ∃ z ( x ( B ↾ C ) z ∧ z A y ) ) ;;
	step 20 : wff = 3bitr4i (step 14, step 16, step 19) |- ( x ( ( A ∘ B ) ↾ C ) y ↔ x ( A ∘ ( B ↾ C ) ) y ) ;;
	step 21 : wff = eqbrriv (step 1, step 2, step 20) |- ( ( A ∘ B ) ↾ C ) = ( A ∘ ( B ↾ C ) ) ;;
	qed prop 1 = step 21 ;;
}

/*Image of the composition of two classes.  (Contributed by Jason
       Orendorff, 12-Dec-2006.) */

theorem imaco (A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C) {
	prop 1 : wff = |- ( ( A ∘ B ) " C ) = ( A " ( B " C ) ) ;;
}

proof of imaco {
	var x : set, y : set, z : set;;
	step 1 : wff = df-rex () |- ( ∃ y ∈ ( B " C ) y A x ↔ ∃ y ( y ∈ ( B " C ) ∧ y A x ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = elima (step 2) |- ( x ∈ ( A " ( B " C ) ) ↔ ∃ y ∈ ( B " C ) y A x ) ;;
	step 4 : wff = rexcom4 () |- ( ∃ z ∈ C ∃ y ( z B y ∧ y A x ) ↔ ∃ y ∃ z ∈ C ( z B y ∧ y A x ) ) ;;
	step 5 : wff = r19.41v () |- ( ∃ z ∈ C ( z B y ∧ y A x ) ↔ ( ∃ z ∈ C z B y ∧ y A x ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ∃ z ∈ C ( z B y ∧ y A x ) ↔ ∃ y ( ∃ z ∈ C z B y ∧ y A x ) ) ;;
	step 7 : wff = bitri (step 4, step 6) |- ( ∃ z ∈ C ∃ y ( z B y ∧ y A x ) ↔ ∃ y ( ∃ z ∈ C z B y ∧ y A x ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = elima (step 8) |- ( x ∈ ( ( A ∘ B ) " C ) ↔ ∃ z ∈ C z ( A ∘ B ) x ) ;;
	step 10 : wff = vex () |- z ∈ _V ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = brco (step 10, step 11) |- ( z ( A ∘ B ) x ↔ ∃ y ( z B y ∧ y A x ) ) ;;
	step 13 : wff = rexbii (step 12) |- ( ∃ z ∈ C z ( A ∘ B ) x ↔ ∃ z ∈ C ∃ y ( z B y ∧ y A x ) ) ;;
	step 14 : wff = bitri (step 9, step 13) |- ( x ∈ ( ( A ∘ B ) " C ) ↔ ∃ z ∈ C ∃ y ( z B y ∧ y A x ) ) ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = elima (step 15) |- ( y ∈ ( B " C ) ↔ ∃ z ∈ C z B y ) ;;
	step 17 : wff = anbi1i (step 16) |- ( ( y ∈ ( B " C ) ∧ y A x ) ↔ ( ∃ z ∈ C z B y ∧ y A x ) ) ;;
	step 18 : wff = exbii (step 17) |- ( ∃ y ( y ∈ ( B " C ) ∧ y A x ) ↔ ∃ y ( ∃ z ∈ C z B y ∧ y A x ) ) ;;
	step 19 : wff = 3bitr4i (step 7, step 14, step 18) |- ( x ∈ ( ( A ∘ B ) " C ) ↔ ∃ y ( y ∈ ( B " C ) ∧ y A x ) ) ;;
	step 20 : wff = 3bitr4ri (step 1, step 3, step 19) |- ( x ∈ ( ( A ∘ B ) " C ) ↔ x ∈ ( A " ( B " C ) ) ) ;;
	step 21 : wff = eqriv (step 20) |- ( ( A ∘ B ) " C ) = ( A " ( B " C ) ) ;;
	qed prop 1 = step 21 ;;
}

/*The range of the composition of two classes.  (Contributed by NM,
       12-Dec-2006.) */

theorem rnco (A : class, B : class) disjointed(x y z A, x y z B, x y z) {
	prop 1 : wff = |- ran ( A ∘ B ) = ran ( A ↾ ran B ) ;;
}

proof of rnco {
	var x : set, y : set, z : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = brco (step 1, step 2) |- ( x ( A ∘ B ) y ↔ ∃ z ( x B z ∧ z A y ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ x x ( A ∘ B ) y ↔ ∃ x ∃ z ( x B z ∧ z A y ) ) ;;
	step 5 : wff = excom () |- ( ∃ x ∃ z ( x B z ∧ z A y ) ↔ ∃ z ∃ x ( x B z ∧ z A y ) ) ;;
	step 6 : wff = ancom () |- ( ( ∃ x x B z ∧ z A y ) ↔ ( z A y ∧ ∃ x x B z ) ) ;;
	step 7 : wff = 19.41v () |- ( ∃ x ( x B z ∧ z A y ) ↔ ( ∃ x x B z ∧ z A y ) ) ;;
	step 8 : wff = vex () |- z ∈ _V ;;
	step 9 : wff = elrn (step 8) |- ( z ∈ ran B ↔ ∃ x x B z ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( z A y ∧ z ∈ ran B ) ↔ ( z A y ∧ ∃ x x B z ) ) ;;
	step 11 : wff = 3bitr4i (step 6, step 7, step 10) |- ( ∃ x ( x B z ∧ z A y ) ↔ ( z A y ∧ z ∈ ran B ) ) ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = brres (step 12) |- ( z ( A ↾ ran B ) y ↔ ( z A y ∧ z ∈ ran B ) ) ;;
	step 14 : wff = bitr4i (step 11, step 13) |- ( ∃ x ( x B z ∧ z A y ) ↔ z ( A ↾ ran B ) y ) ;;
	step 15 : wff = exbii (step 14) |- ( ∃ z ∃ x ( x B z ∧ z A y ) ↔ ∃ z z ( A ↾ ran B ) y ) ;;
	step 16 : wff = 3bitri (step 4, step 5, step 15) |- ( ∃ x x ( A ∘ B ) y ↔ ∃ z z ( A ↾ ran B ) y ) ;;
	step 17 : wff = vex () |- y ∈ _V ;;
	step 18 : wff = elrn (step 17) |- ( y ∈ ran ( A ∘ B ) ↔ ∃ x x ( A ∘ B ) y ) ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = elrn (step 19) |- ( y ∈ ran ( A ↾ ran B ) ↔ ∃ z z ( A ↾ ran B ) y ) ;;
	step 21 : wff = 3bitr4i (step 16, step 18, step 20) |- ( y ∈ ran ( A ∘ B ) ↔ y ∈ ran ( A ↾ ran B ) ) ;;
	step 22 : wff = eqriv (step 21) |- ran ( A ∘ B ) = ran ( A ↾ ran B ) ;;
	qed prop 1 = step 22 ;;
}

/*The range of the composition of two classes.  (Contributed by NM,
     27-Mar-2008.) */

theorem rnco2 (A : class, B : class)  {
	prop 1 : wff = |- ran ( A ∘ B ) = ( A " ran B ) ;;
}

proof of rnco2 {
	step 1 : wff = rnco () |- ran ( A ∘ B ) = ran ( A ↾ ran B ) ;;
	step 2 : wff = df-ima () |- ( A " ran B ) = ran ( A ↾ ran B ) ;;
	step 3 : wff = eqtr4i (step 1, step 2) |- ran ( A ∘ B ) = ( A " ran B ) ;;
	qed prop 1 = step 3 ;;
}

/*The domain of a composition.  Exercise 27 of [Enderton] p. 53.
     (Contributed by NM, 4-Feb-2004.) */

theorem dmco (A : class, B : class)  {
	prop 1 : wff = |- dom ( A ∘ B ) = ( ⁻¹ B " dom A ) ;;
}

proof of dmco {
	step 1 : wff = dfdm4 () |- dom ( A ∘ B ) = ran ⁻¹ ( A ∘ B ) ;;
	step 2 : wff = cnvco () |- ⁻¹ ( A ∘ B ) = ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 3 : wff = rneqi (step 2) |- ran ⁻¹ ( A ∘ B ) = ran ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 4 : wff = rnco2 () |- ran ( ⁻¹ B ∘ ⁻¹ A ) = ( ⁻¹ B " ran ⁻¹ A ) ;;
	step 5 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 6 : wff = imaeq2i (step 5) |- ( ⁻¹ B " dom A ) = ( ⁻¹ B " ran ⁻¹ A ) ;;
	step 7 : wff = eqtr4i (step 4, step 6) |- ran ( ⁻¹ B ∘ ⁻¹ A ) = ( ⁻¹ B " dom A ) ;;
	step 8 : wff = 3eqtri (step 1, step 3, step 7) |- dom ( A ∘ B ) = ( ⁻¹ B " dom A ) ;;
	qed prop 1 = step 8 ;;
}

/*Composition with an indexed union.  (Contributed by NM, 21-Dec-2008.) */

theorem coiun (x : set, A : class, B : class, C : class) disjointed(w x y z A, w y z B, w y z C) {
	prop 1 : wff = |- ( A ∘ ⋃_ x ∈ C B ) = ⋃_ x ∈ C ( A ∘ B ) ;;
}

proof of coiun {
	var y : set, z : set, w : set;;
	step 1 : wff = relco () |- Rel ( A ∘ ⋃_ x ∈ C B ) ;;
	step 2 : wff = reliun () |- ( Rel ⋃_ x ∈ C ( A ∘ B ) ↔ ∀ x ∈ C Rel ( A ∘ B ) ) ;;
	step 3 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 4 : wff = a1i (step 3) |- ( x ∈ C → Rel ( A ∘ B ) ) ;;
	step 5 : wff = mprgbir (step 2, step 4) |- Rel ⋃_ x ∈ C ( A ∘ B ) ;;
	step 6 : wff = eliun () |- ( 〈 y , w 〉 ∈ ⋃_ x ∈ C B ↔ ∃ x ∈ C 〈 y , w 〉 ∈ B ) ;;
	step 7 : wff = df-br () |- ( y ⋃_ x ∈ C B w ↔ 〈 y , w 〉 ∈ ⋃_ x ∈ C B ) ;;
	step 8 : wff = df-br () |- ( y B w ↔ 〈 y , w 〉 ∈ B ) ;;
	step 9 : wff = rexbii (step 8) |- ( ∃ x ∈ C y B w ↔ ∃ x ∈ C 〈 y , w 〉 ∈ B ) ;;
	step 10 : wff = 3bitr4i (step 6, step 7, step 9) |- ( y ⋃_ x ∈ C B w ↔ ∃ x ∈ C y B w ) ;;
	step 11 : wff = anbi1i (step 10) |- ( ( y ⋃_ x ∈ C B w ∧ w A z ) ↔ ( ∃ x ∈ C y B w ∧ w A z ) ) ;;
	step 12 : wff = r19.41v () |- ( ∃ x ∈ C ( y B w ∧ w A z ) ↔ ( ∃ x ∈ C y B w ∧ w A z ) ) ;;
	step 13 : wff = bitr4i (step 11, step 12) |- ( ( y ⋃_ x ∈ C B w ∧ w A z ) ↔ ∃ x ∈ C ( y B w ∧ w A z ) ) ;;
	step 14 : wff = exbii (step 13) |- ( ∃ w ( y ⋃_ x ∈ C B w ∧ w A z ) ↔ ∃ w ∃ x ∈ C ( y B w ∧ w A z ) ) ;;
	step 15 : wff = rexcom4 () |- ( ∃ x ∈ C ∃ w ( y B w ∧ w A z ) ↔ ∃ w ∃ x ∈ C ( y B w ∧ w A z ) ) ;;
	step 16 : wff = bitr4i (step 14, step 15) |- ( ∃ w ( y ⋃_ x ∈ C B w ∧ w A z ) ↔ ∃ x ∈ C ∃ w ( y B w ∧ w A z ) ) ;;
	step 17 : wff = vex () |- y ∈ _V ;;
	step 18 : wff = vex () |- z ∈ _V ;;
	step 19 : wff = opelco (step 17, step 18) |- ( 〈 y , z 〉 ∈ ( A ∘ ⋃_ x ∈ C B ) ↔ ∃ w ( y ⋃_ x ∈ C B w ∧ w A z ) ) ;;
	step 20 : wff = eliun () |- ( 〈 y , z 〉 ∈ ⋃_ x ∈ C ( A ∘ B ) ↔ ∃ x ∈ C 〈 y , z 〉 ∈ ( A ∘ B ) ) ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = vex () |- z ∈ _V ;;
	step 23 : wff = opelco (step 21, step 22) |- ( 〈 y , z 〉 ∈ ( A ∘ B ) ↔ ∃ w ( y B w ∧ w A z ) ) ;;
	step 24 : wff = rexbii (step 23) |- ( ∃ x ∈ C 〈 y , z 〉 ∈ ( A ∘ B ) ↔ ∃ x ∈ C ∃ w ( y B w ∧ w A z ) ) ;;
	step 25 : wff = bitri (step 20, step 24) |- ( 〈 y , z 〉 ∈ ⋃_ x ∈ C ( A ∘ B ) ↔ ∃ x ∈ C ∃ w ( y B w ∧ w A z ) ) ;;
	step 26 : wff = 3bitr4i (step 16, step 19, step 25) |- ( 〈 y , z 〉 ∈ ( A ∘ ⋃_ x ∈ C B ) ↔ 〈 y , z 〉 ∈ ⋃_ x ∈ C ( A ∘ B ) ) ;;
	step 27 : wff = eqrelriiv (step 1, step 5, step 26) |- ( A ∘ ⋃_ x ∈ C B ) = ⋃_ x ∈ C ( A ∘ B ) ;;
	qed prop 1 = step 27 ;;
}

/*A composition is not affected by a double converse of its first argument.
     (Contributed by NM, 8-Oct-2007.) */

theorem cocnvcnv1 (A : class, B : class)  {
	prop 1 : wff = |- ( ⁻¹ ⁻¹ A ∘ B ) = ( A ∘ B ) ;;
}

proof of cocnvcnv1 {
	step 1 : wff = cnvcnv2 () |- ⁻¹ ⁻¹ A = ( A ↾ _V ) ;;
	step 2 : wff = coeq1i (step 1) |- ( ⁻¹ ⁻¹ A ∘ B ) = ( ( A ↾ _V ) ∘ B ) ;;
	step 3 : wff = ssv () |- ran B ⊆ _V ;;
	step 4 : wff = cores () |- ( ran B ⊆ _V → ( ( A ↾ _V ) ∘ B ) = ( A ∘ B ) ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- ( ( A ↾ _V ) ∘ B ) = ( A ∘ B ) ;;
	step 6 : wff = eqtri (step 2, step 5) |- ( ⁻¹ ⁻¹ A ∘ B ) = ( A ∘ B ) ;;
	qed prop 1 = step 6 ;;
}

/*A composition is not affected by a double converse of its second
     argument.  (Contributed by NM, 8-Oct-2007.) */

theorem cocnvcnv2 (A : class, B : class)  {
	prop 1 : wff = |- ( A ∘ ⁻¹ ⁻¹ B ) = ( A ∘ B ) ;;
}

proof of cocnvcnv2 {
	step 1 : wff = cnvcnv2 () |- ⁻¹ ⁻¹ B = ( B ↾ _V ) ;;
	step 2 : wff = coeq2i (step 1) |- ( A ∘ ⁻¹ ⁻¹ B ) = ( A ∘ ( B ↾ _V ) ) ;;
	step 3 : wff = resco () |- ( ( A ∘ B ) ↾ _V ) = ( A ∘ ( B ↾ _V ) ) ;;
	step 4 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 5 : wff = dfrel3 () |- ( Rel ( A ∘ B ) ↔ ( ( A ∘ B ) ↾ _V ) = ( A ∘ B ) ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- ( ( A ∘ B ) ↾ _V ) = ( A ∘ B ) ;;
	step 7 : wff = 3eqtr2i (step 2, step 3, step 6) |- ( A ∘ ⁻¹ ⁻¹ B ) = ( A ∘ B ) ;;
	qed prop 1 = step 7 ;;
}

/*Absorption of a reverse (preimage) restriction of the second member of a
     class composition.  (Contributed by NM, 11-Dec-2006.) */

theorem cores2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( dom A ⊆ C → ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ( A ∘ B ) ) ;;
}

proof of cores2 {
	step 1 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 2 : wff = sseq1i (step 1) |- ( dom A ⊆ C ↔ ran ⁻¹ A ⊆ C ) ;;
	step 3 : wff = cores () |- ( ran ⁻¹ A ⊆ C → ( ( ⁻¹ B ↾ C ) ∘ ⁻¹ A ) = ( ⁻¹ B ∘ ⁻¹ A ) ) ;;
	step 4 : wff = sylbi (step 2, step 3) |- ( dom A ⊆ C → ( ( ⁻¹ B ↾ C ) ∘ ⁻¹ A ) = ( ⁻¹ B ∘ ⁻¹ A ) ) ;;
	step 5 : wff = cnvco () |- ⁻¹ ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ( ⁻¹ ⁻¹ ( ⁻¹ B ↾ C ) ∘ ⁻¹ A ) ;;
	step 6 : wff = cocnvcnv1 () |- ( ⁻¹ ⁻¹ ( ⁻¹ B ↾ C ) ∘ ⁻¹ A ) = ( ( ⁻¹ B ↾ C ) ∘ ⁻¹ A ) ;;
	step 7 : wff = eqtri (step 5, step 6) |- ⁻¹ ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ( ( ⁻¹ B ↾ C ) ∘ ⁻¹ A ) ;;
	step 8 : wff = cnvco () |- ⁻¹ ( A ∘ B ) = ( ⁻¹ B ∘ ⁻¹ A ) ;;
	step 9 : wff = 3eqtr4g (step 4, step 7, step 8) |- ( dom A ⊆ C → ⁻¹ ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ⁻¹ ( A ∘ B ) ) ;;
	step 10 : wff = cnveqd (step 9) |- ( dom A ⊆ C → ⁻¹ ⁻¹ ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ⁻¹ ⁻¹ ( A ∘ B ) ) ;;
	step 11 : wff = relco () |- Rel ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) ;;
	step 12 : wff = dfrel2 () |- ( Rel ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) ↔ ⁻¹ ⁻¹ ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) ) ;;
	step 13 : wff = mpbi (step 11, step 12) |- ⁻¹ ⁻¹ ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) ;;
	step 14 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 15 : wff = dfrel2 () |- ( Rel ( A ∘ B ) ↔ ⁻¹ ⁻¹ ( A ∘ B ) = ( A ∘ B ) ) ;;
	step 16 : wff = mpbi (step 14, step 15) |- ⁻¹ ⁻¹ ( A ∘ B ) = ( A ∘ B ) ;;
	step 17 : wff = 3eqtr3g (step 10, step 13, step 16) |- ( dom A ⊆ C → ( A ∘ ⁻¹ ( ⁻¹ B ↾ C ) ) = ( A ∘ B ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Composition with the empty set.  Theorem 20 of [Suppes] p. 63.
       (Contributed by NM, 24-Apr-2004.) */

theorem co02 (A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( A ∘ ∅ ) = ∅ ;;
}

proof of co02 {
	var x : set, y : set, z : set;;
	step 1 : wff = relco () |- Rel ( A ∘ ∅ ) ;;
	step 2 : wff = rel0 () |- Rel ∅ ;;
	step 3 : wff = noel () |- ¬ 〈 x , z 〉 ∈ ∅ ;;
	step 4 : wff = df-br () |- ( x ∅ z ↔ 〈 x , z 〉 ∈ ∅ ) ;;
	step 5 : wff = mtbir (step 3, step 4) |- ¬ x ∅ z ;;
	step 6 : wff = intnanr (step 5) |- ¬ ( x ∅ z ∧ z A y ) ;;
	step 7 : wff = nex (step 6) |- ¬ ∃ z ( x ∅ z ∧ z A y ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = opelco (step 8, step 9) |- ( 〈 x , y 〉 ∈ ( A ∘ ∅ ) ↔ ∃ z ( x ∅ z ∧ z A y ) ) ;;
	step 11 : wff = mtbir (step 7, step 10) |- ¬ 〈 x , y 〉 ∈ ( A ∘ ∅ ) ;;
	step 12 : wff = noel () |- ¬ 〈 x , y 〉 ∈ ∅ ;;
	step 13 : wff = 2false (step 11, step 12) |- ( 〈 x , y 〉 ∈ ( A ∘ ∅ ) ↔ 〈 x , y 〉 ∈ ∅ ) ;;
	step 14 : wff = eqrelriiv (step 1, step 2, step 13) |- ( A ∘ ∅ ) = ∅ ;;
	qed prop 1 = step 14 ;;
}

/*Composition with the empty set.  (Contributed by NM, 24-Apr-2004.) */

theorem co01 (A : class) disjointed(A) {
	prop 1 : wff = |- ( ∅ ∘ A ) = ∅ ;;
}

proof of co01 {
	step 1 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 2 : wff = cnvco () |- ⁻¹ ( ∅ ∘ A ) = ( ⁻¹ A ∘ ⁻¹ ∅ ) ;;
	step 3 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 4 : wff = coeq2i (step 3) |- ( ⁻¹ A ∘ ⁻¹ ∅ ) = ( ⁻¹ A ∘ ∅ ) ;;
	step 5 : wff = co02 () |- ( ⁻¹ A ∘ ∅ ) = ∅ ;;
	step 6 : wff = 3eqtri (step 2, step 4, step 5) |- ⁻¹ ( ∅ ∘ A ) = ∅ ;;
	step 7 : wff = eqtr4i (step 1, step 6) |- ⁻¹ ∅ = ⁻¹ ( ∅ ∘ A ) ;;
	step 8 : wff = cnveqi (step 7) |- ⁻¹ ⁻¹ ∅ = ⁻¹ ⁻¹ ( ∅ ∘ A ) ;;
	step 9 : wff = rel0 () |- Rel ∅ ;;
	step 10 : wff = dfrel2 () |- ( Rel ∅ ↔ ⁻¹ ⁻¹ ∅ = ∅ ) ;;
	step 11 : wff = mpbi (step 9, step 10) |- ⁻¹ ⁻¹ ∅ = ∅ ;;
	step 12 : wff = relco () |- Rel ( ∅ ∘ A ) ;;
	step 13 : wff = dfrel2 () |- ( Rel ( ∅ ∘ A ) ↔ ⁻¹ ⁻¹ ( ∅ ∘ A ) = ( ∅ ∘ A ) ) ;;
	step 14 : wff = mpbi (step 12, step 13) |- ⁻¹ ⁻¹ ( ∅ ∘ A ) = ( ∅ ∘ A ) ;;
	step 15 : wff = 3eqtr3ri (step 8, step 11, step 14) |- ( ∅ ∘ A ) = ∅ ;;
	qed prop 1 = step 15 ;;
}

/*Composition with the identity relation.  Part of Theorem 3.7(i) of
       [Monk1] p. 36.  (Contributed by NM, 22-Apr-2004.) */

theorem coi1 (A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( Rel A → ( A ∘ _I ) = A ) ;;
}

proof of coi1 {
	var x : set, y : set, z : set;;
	step 1 : wff = relco () |- Rel ( A ∘ _I ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = opelco (step 2, step 3) |- ( 〈 x , y 〉 ∈ ( A ∘ _I ) ↔ ∃ z ( x _I z ∧ z A y ) ) ;;
	step 5 : wff = vex () |- z ∈ _V ;;
	step 6 : wff = ideq (step 5) |- ( x _I z ↔ x = z ) ;;
	step 7 : wff = equcom () |- ( x = z ↔ z = x ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( x _I z ↔ z = x ) ;;
	step 9 : wff = anbi1i (step 8) |- ( ( x _I z ∧ z A y ) ↔ ( z = x ∧ z A y ) ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ z ( x _I z ∧ z A y ) ↔ ∃ z ( z = x ∧ z A y ) ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = breq1 () |- ( z = x → ( z A y ↔ x A y ) ) ;;
	step 13 : wff = ceqsexv (step 11, step 12) |- ( ∃ z ( z = x ∧ z A y ) ↔ x A y ) ;;
	step 14 : wff = bitri (step 10, step 13) |- ( ∃ z ( x _I z ∧ z A y ) ↔ x A y ) ;;
	step 15 : wff = bitri (step 4, step 14) |- ( 〈 x , y 〉 ∈ ( A ∘ _I ) ↔ x A y ) ;;
	step 16 : wff = df-br () |- ( x A y ↔ 〈 x , y 〉 ∈ A ) ;;
	step 17 : wff = bitri (step 15, step 16) |- ( 〈 x , y 〉 ∈ ( A ∘ _I ) ↔ 〈 x , y 〉 ∈ A ) ;;
	step 18 : wff = eqrelriv (step 17) |- ( ( Rel ( A ∘ _I ) ∧ Rel A ) → ( A ∘ _I ) = A ) ;;
	step 19 : wff = mpan (step 1, step 18) |- ( Rel A → ( A ∘ _I ) = A ) ;;
	qed prop 1 = step 19 ;;
}

/*Composition with the identity relation.  Part of Theorem 3.7(i) of
       [Monk1] p. 36.  (Contributed by NM, 22-Apr-2004.) */

theorem coi2 (A : class) disjointed(A) {
	prop 1 : wff = |- ( Rel A → ( _I ∘ A ) = A ) ;;
}

proof of coi2 {
	step 1 : wff = cnvco () |- ⁻¹ ( ⁻¹ A ∘ _I ) = ( ⁻¹ _I ∘ ⁻¹ ⁻¹ A ) ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 3 : wff = coi1 () |- ( Rel ⁻¹ A → ( ⁻¹ A ∘ _I ) = ⁻¹ A ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ⁻¹ A ∘ _I ) = ⁻¹ A ;;
	step 5 : wff = cnveqi (step 4) |- ⁻¹ ( ⁻¹ A ∘ _I ) = ⁻¹ ⁻¹ A ;;
	step 6 : wff = eqtr3i (step 1, step 5) |- ( ⁻¹ _I ∘ ⁻¹ ⁻¹ A ) = ⁻¹ ⁻¹ A ;;
	step 7 : wff = dfrel2 () |- ( Rel A ↔ ⁻¹ ⁻¹ A = A ) ;;
	step 8 : wff = cnvi () |- ⁻¹ _I = _I ;;
	step 9 : wff = coeq2 () |- ( ⁻¹ ⁻¹ A = A → ( ⁻¹ _I ∘ ⁻¹ ⁻¹ A ) = ( ⁻¹ _I ∘ A ) ) ;;
	step 10 : wff = coeq1 () |- ( ⁻¹ _I = _I → ( ⁻¹ _I ∘ A ) = ( _I ∘ A ) ) ;;
	step 11 : wff = sylan9eq (step 9, step 10) |- ( ( ⁻¹ ⁻¹ A = A ∧ ⁻¹ _I = _I ) → ( ⁻¹ _I ∘ ⁻¹ ⁻¹ A ) = ( _I ∘ A ) ) ;;
	step 12 : wff = mpan2 (step 8, step 11) |- ( ⁻¹ ⁻¹ A = A → ( ⁻¹ _I ∘ ⁻¹ ⁻¹ A ) = ( _I ∘ A ) ) ;;
	step 13 : wff = sylbi (step 7, step 12) |- ( Rel A → ( ⁻¹ _I ∘ ⁻¹ ⁻¹ A ) = ( _I ∘ A ) ) ;;
	step 14 : wff = dfrel2 () |- ( Rel A ↔ ⁻¹ ⁻¹ A = A ) ;;
	step 15 : wff = biimpi (step 14) |- ( Rel A → ⁻¹ ⁻¹ A = A ) ;;
	step 16 : wff = 3eqtr3a (step 6, step 13, step 15) |- ( Rel A → ( _I ∘ A ) = A ) ;;
	qed prop 1 = step 16 ;;
}

/*Composition with a restricted identity relation.  (Contributed by FL,
     19-Jun-2011.)  (Revised by Stefan O'Rear, 7-Mar-2015.) */

theorem coires1 (A : class, B : class)  {
	prop 1 : wff = |- ( A ∘ ( _I ↾ B ) ) = ( A ↾ B ) ;;
}

proof of coires1 {
	step 1 : wff = cocnvcnv1 () |- ( ⁻¹ ⁻¹ A ∘ _I ) = ( A ∘ _I ) ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ ⁻¹ A ;;
	step 3 : wff = coi1 () |- ( Rel ⁻¹ ⁻¹ A → ( ⁻¹ ⁻¹ A ∘ _I ) = ⁻¹ ⁻¹ A ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( ⁻¹ ⁻¹ A ∘ _I ) = ⁻¹ ⁻¹ A ;;
	step 5 : wff = eqtr3i (step 1, step 4) |- ( A ∘ _I ) = ⁻¹ ⁻¹ A ;;
	step 6 : wff = reseq1i (step 5) |- ( ( A ∘ _I ) ↾ B ) = ( ⁻¹ ⁻¹ A ↾ B ) ;;
	step 7 : wff = resco () |- ( ( A ∘ _I ) ↾ B ) = ( A ∘ ( _I ↾ B ) ) ;;
	step 8 : wff = eqtr3i (step 6, step 7) |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ∘ ( _I ↾ B ) ) ;;
	step 9 : wff = rescnvcnv () |- ( ⁻¹ ⁻¹ A ↾ B ) = ( A ↾ B ) ;;
	step 10 : wff = eqtr3i (step 8, step 9) |- ( A ∘ ( _I ↾ B ) ) = ( A ↾ B ) ;;
	qed prop 1 = step 10 ;;
}

/*Associative law for class composition.  Theorem 27 of [Suppes] p. 64.
       Also Exercise 21 of [Enderton] p. 53.  Interestingly, this law holds for
       any classes whatsoever, not just functions or even relations.
       (Contributed by NM, 27-Jan-1997.) */

theorem coass (A : class, B : class, C : class) disjointed(x y z w A, x y z w B, x y z w C) {
	prop 1 : wff = |- ( ( A ∘ B ) ∘ C ) = ( A ∘ ( B ∘ C ) ) ;;
}

proof of coass {
	var x : set, y : set, z : set, w : set;;
	step 1 : wff = relco () |- Rel ( ( A ∘ B ) ∘ C ) ;;
	step 2 : wff = relco () |- Rel ( A ∘ ( B ∘ C ) ) ;;
	step 3 : wff = excom () |- ( ∃ z ∃ w ( x C z ∧ ( z B w ∧ w A y ) ) ↔ ∃ w ∃ z ( x C z ∧ ( z B w ∧ w A y ) ) ) ;;
	step 4 : wff = anass () |- ( ( ( x C z ∧ z B w ) ∧ w A y ) ↔ ( x C z ∧ ( z B w ∧ w A y ) ) ) ;;
	step 5 : wff = 2exbii (step 4) |- ( ∃ w ∃ z ( ( x C z ∧ z B w ) ∧ w A y ) ↔ ∃ w ∃ z ( x C z ∧ ( z B w ∧ w A y ) ) ) ;;
	step 6 : wff = bitr4i (step 3, step 5) |- ( ∃ z ∃ w ( x C z ∧ ( z B w ∧ w A y ) ) ↔ ∃ w ∃ z ( ( x C z ∧ z B w ) ∧ w A y ) ) ;;
	step 7 : wff = vex () |- z ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = brco (step 7, step 8) |- ( z ( A ∘ B ) y ↔ ∃ w ( z B w ∧ w A y ) ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( x C z ∧ z ( A ∘ B ) y ) ↔ ( x C z ∧ ∃ w ( z B w ∧ w A y ) ) ) ;;
	step 11 : wff = exbii (step 10) |- ( ∃ z ( x C z ∧ z ( A ∘ B ) y ) ↔ ∃ z ( x C z ∧ ∃ w ( z B w ∧ w A y ) ) ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = vex () |- y ∈ _V ;;
	step 14 : wff = opelco (step 12, step 13) |- ( 〈 x , y 〉 ∈ ( ( A ∘ B ) ∘ C ) ↔ ∃ z ( x C z ∧ z ( A ∘ B ) y ) ) ;;
	step 15 : wff = exdistr () |- ( ∃ z ∃ w ( x C z ∧ ( z B w ∧ w A y ) ) ↔ ∃ z ( x C z ∧ ∃ w ( z B w ∧ w A y ) ) ) ;;
	step 16 : wff = 3bitr4i (step 11, step 14, step 15) |- ( 〈 x , y 〉 ∈ ( ( A ∘ B ) ∘ C ) ↔ ∃ z ∃ w ( x C z ∧ ( z B w ∧ w A y ) ) ) ;;
	step 17 : wff = vex () |- x ∈ _V ;;
	step 18 : wff = vex () |- w ∈ _V ;;
	step 19 : wff = brco (step 17, step 18) |- ( x ( B ∘ C ) w ↔ ∃ z ( x C z ∧ z B w ) ) ;;
	step 20 : wff = anbi1i (step 19) |- ( ( x ( B ∘ C ) w ∧ w A y ) ↔ ( ∃ z ( x C z ∧ z B w ) ∧ w A y ) ) ;;
	step 21 : wff = exbii (step 20) |- ( ∃ w ( x ( B ∘ C ) w ∧ w A y ) ↔ ∃ w ( ∃ z ( x C z ∧ z B w ) ∧ w A y ) ) ;;
	step 22 : wff = vex () |- x ∈ _V ;;
	step 23 : wff = vex () |- y ∈ _V ;;
	step 24 : wff = opelco (step 22, step 23) |- ( 〈 x , y 〉 ∈ ( A ∘ ( B ∘ C ) ) ↔ ∃ w ( x ( B ∘ C ) w ∧ w A y ) ) ;;
	step 25 : wff = 19.41v () |- ( ∃ z ( ( x C z ∧ z B w ) ∧ w A y ) ↔ ( ∃ z ( x C z ∧ z B w ) ∧ w A y ) ) ;;
	step 26 : wff = exbii (step 25) |- ( ∃ w ∃ z ( ( x C z ∧ z B w ) ∧ w A y ) ↔ ∃ w ( ∃ z ( x C z ∧ z B w ) ∧ w A y ) ) ;;
	step 27 : wff = 3bitr4i (step 21, step 24, step 26) |- ( 〈 x , y 〉 ∈ ( A ∘ ( B ∘ C ) ) ↔ ∃ w ∃ z ( ( x C z ∧ z B w ) ∧ w A y ) ) ;;
	step 28 : wff = 3bitr4i (step 6, step 16, step 27) |- ( 〈 x , y 〉 ∈ ( ( A ∘ B ) ∘ C ) ↔ 〈 x , y 〉 ∈ ( A ∘ ( B ∘ C ) ) ) ;;
	step 29 : wff = eqrelriiv (step 1, step 2, step 28) |- ( ( A ∘ B ) ∘ C ) = ( A ∘ ( B ∘ C ) ) ;;
	qed prop 1 = step 29 ;;
}

/*A relation is transitive iff its converse is transitive.  (Contributed by
     FL, 19-Sep-2011.) */

theorem relcnvtr (R : class)  {
	prop 1 : wff = |- ( Rel R → ( ( R ∘ R ) ⊆ R ↔ ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ R ) ) ;;
}

proof of relcnvtr {
	step 1 : wff = cnvco () |- ⁻¹ ( R ∘ R ) = ( ⁻¹ R ∘ ⁻¹ R ) ;;
	step 2 : wff = cnvss () |- ( ( R ∘ R ) ⊆ R → ⁻¹ ( R ∘ R ) ⊆ ⁻¹ R ) ;;
	step 3 : wff = syl5eqssr (step 1, step 2) |- ( ( R ∘ R ) ⊆ R → ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ R ) ;;
	step 4 : wff = cnvco () |- ⁻¹ ( ⁻¹ R ∘ ⁻¹ R ) = ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) ;;
	step 5 : wff = cnvss () |- ( ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ R → ⁻¹ ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R ) ;;
	step 6 : wff = sseq1 () |- ( ⁻¹ ( ⁻¹ R ∘ ⁻¹ R ) = ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) → ( ⁻¹ ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R ↔ ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R ) ) ;;
	step 7 : wff = dfrel2 () |- ( Rel R ↔ ⁻¹ ⁻¹ R = R ) ;;
	step 8 : wff = coeq1 () |- ( ⁻¹ ⁻¹ R = R → ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) = ( R ∘ ⁻¹ ⁻¹ R ) ) ;;
	step 9 : wff = coeq2 () |- ( ⁻¹ ⁻¹ R = R → ( R ∘ ⁻¹ ⁻¹ R ) = ( R ∘ R ) ) ;;
	step 10 : wff = eqtrd (step 8, step 9) |- ( ⁻¹ ⁻¹ R = R → ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) = ( R ∘ R ) ) ;;
	step 11 : wff = id () |- ( ⁻¹ ⁻¹ R = R → ⁻¹ ⁻¹ R = R ) ;;
	step 12 : wff = sseq12d (step 10, step 11) |- ( ⁻¹ ⁻¹ R = R → ( ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R ↔ ( R ∘ R ) ⊆ R ) ) ;;
	step 13 : wff = biimpd (step 12) |- ( ⁻¹ ⁻¹ R = R → ( ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R → ( R ∘ R ) ⊆ R ) ) ;;
	step 14 : wff = sylbi (step 7, step 13) |- ( Rel R → ( ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R → ( R ∘ R ) ⊆ R ) ) ;;
	step 15 : wff = com12 (step 14) |- ( ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R → ( Rel R → ( R ∘ R ) ⊆ R ) ) ;;
	step 16 : wff = syl6bi (step 6, step 15) |- ( ⁻¹ ( ⁻¹ R ∘ ⁻¹ R ) = ( ⁻¹ ⁻¹ R ∘ ⁻¹ ⁻¹ R ) → ( ⁻¹ ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ ⁻¹ R → ( Rel R → ( R ∘ R ) ⊆ R ) ) ) ;;
	step 17 : wff = mpsyl (step 4, step 5, step 16) |- ( ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ R → ( Rel R → ( R ∘ R ) ⊆ R ) ) ;;
	step 18 : wff = com12 (step 17) |- ( Rel R → ( ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ R → ( R ∘ R ) ⊆ R ) ) ;;
	step 19 : wff = impbid2 (step 3, step 18) |- ( Rel R → ( ( R ∘ R ) ⊆ R ↔ ( ⁻¹ R ∘ ⁻¹ R ) ⊆ ⁻¹ R ) ) ;;
	qed prop 1 = step 19 ;;
}

/*A relation is included in the cross product of its domain and range.
       Exercise 4.12(t) of [Mendelson] p. 235.  (Contributed by NM,
       3-Aug-1994.) */

theorem relssdmrn (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Rel A → A ⊆ ( dom A × ran A ) ) ;;
}

proof of relssdmrn {
	var x : set, y : set;;
	step 1 : wff = id () |- ( Rel A → Rel A ) ;;
	step 2 : wff = 19.8a () |- ( 〈 x , y 〉 ∈ A → ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 3 : wff = 19.8a () |- ( 〈 x , y 〉 ∈ A → ∃ x 〈 x , y 〉 ∈ A ) ;;
	step 4 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( dom A × ran A ) ↔ ( x ∈ dom A ∧ y ∈ ran A ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = eldm2 (step 5) |- ( x ∈ dom A ↔ ∃ y 〈 x , y 〉 ∈ A ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = elrn2 (step 7) |- ( y ∈ ran A ↔ ∃ x 〈 x , y 〉 ∈ A ) ;;
	step 9 : wff = anbi12i (step 6, step 8) |- ( ( x ∈ dom A ∧ y ∈ ran A ) ↔ ( ∃ y 〈 x , y 〉 ∈ A ∧ ∃ x 〈 x , y 〉 ∈ A ) ) ;;
	step 10 : wff = bitri (step 4, step 9) |- ( 〈 x , y 〉 ∈ ( dom A × ran A ) ↔ ( ∃ y 〈 x , y 〉 ∈ A ∧ ∃ x 〈 x , y 〉 ∈ A ) ) ;;
	step 11 : wff = sylanbrc (step 2, step 3, step 10) |- ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ ( dom A × ran A ) ) ;;
	step 12 : wff = a1i (step 11) |- ( Rel A → ( 〈 x , y 〉 ∈ A → 〈 x , y 〉 ∈ ( dom A × ran A ) ) ) ;;
	step 13 : wff = relssdv (step 1, step 12) |- ( Rel A → A ⊆ ( dom A × ran A ) ) ;;
	qed prop 1 = step 13 ;;
}

/*The converse is a subset of the cartesian product of range and domain.
     (Contributed by Mario Carneiro, 2-Jan-2017.) */

theorem cnvssrndm (A : class)  {
	prop 1 : wff = |- ⁻¹ A ⊆ ( ran A × dom A ) ;;
}

proof of cnvssrndm {
	step 1 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 2 : wff = relssdmrn () |- ( Rel ⁻¹ A → ⁻¹ A ⊆ ( dom ⁻¹ A × ran ⁻¹ A ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ⁻¹ A ⊆ ( dom ⁻¹ A × ran ⁻¹ A ) ;;
	step 4 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 5 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 6 : wff = xpeq12i (step 4, step 5) |- ( ran A × dom A ) = ( dom ⁻¹ A × ran ⁻¹ A ) ;;
	step 7 : wff = sseqtr4i (step 3, step 6) |- ⁻¹ A ⊆ ( ran A × dom A ) ;;
	qed prop 1 = step 7 ;;
}

/*Composition as a subset of the cross product of factors.  (Contributed by
     Mario Carneiro, 12-Jan-2017.) */

theorem cossxp (A : class, B : class)  {
	prop 1 : wff = |- ( A ∘ B ) ⊆ ( dom B × ran A ) ;;
}

proof of cossxp {
	step 1 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 2 : wff = relssdmrn () |- ( Rel ( A ∘ B ) → ( A ∘ B ) ⊆ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( A ∘ B ) ⊆ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ;;
	step 4 : wff = dmcoss () |- dom ( A ∘ B ) ⊆ dom B ;;
	step 5 : wff = rncoss () |- ran ( A ∘ B ) ⊆ ran A ;;
	step 6 : wff = xpss12 () |- ( ( dom ( A ∘ B ) ⊆ dom B ∧ ran ( A ∘ B ) ⊆ ran A ) → ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ⊆ ( dom B × ran A ) ) ;;
	step 7 : wff = mp2an (step 4, step 5, step 6) |- ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ⊆ ( dom B × ran A ) ;;
	step 8 : wff = sstri (step 3, step 7) |- ( A ∘ B ) ⊆ ( dom B × ran A ) ;;
	qed prop 1 = step 8 ;;
}

/*Two ways to describe the structure of a two-place operation.  (Contributed
     by NM, 17-Dec-2008.) */

theorem relrelss (A : class)  {
	prop 1 : wff = |- ( ( Rel A ∧ Rel dom A ) ↔ A ⊆ ( ( _V × _V ) × _V ) ) ;;
}

proof of relrelss {
	step 1 : wff = df-rel () |- ( Rel dom A ↔ dom A ⊆ ( _V × _V ) ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( Rel A ∧ Rel dom A ) ↔ ( Rel A ∧ dom A ⊆ ( _V × _V ) ) ) ;;
	step 3 : wff = relssdmrn () |- ( Rel A → A ⊆ ( dom A × ran A ) ) ;;
	step 4 : wff = ssv () |- ran A ⊆ _V ;;
	step 5 : wff = xpss12 () |- ( ( dom A ⊆ ( _V × _V ) ∧ ran A ⊆ _V ) → ( dom A × ran A ) ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 6 : wff = mpan2 (step 4, step 5) |- ( dom A ⊆ ( _V × _V ) → ( dom A × ran A ) ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 7 : wff = sylan9ss (step 3, step 6) |- ( ( Rel A ∧ dom A ⊆ ( _V × _V ) ) → A ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 8 : wff = xpss () |- ( ( _V × _V ) × _V ) ⊆ ( _V × _V ) ;;
	step 9 : wff = sstr () |- ( ( A ⊆ ( ( _V × _V ) × _V ) ∧ ( ( _V × _V ) × _V ) ⊆ ( _V × _V ) ) → A ⊆ ( _V × _V ) ) ;;
	step 10 : wff = mpan2 (step 8, step 9) |- ( A ⊆ ( ( _V × _V ) × _V ) → A ⊆ ( _V × _V ) ) ;;
	step 11 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 12 : wff = sylibr (step 10, step 11) |- ( A ⊆ ( ( _V × _V ) × _V ) → Rel A ) ;;
	step 13 : wff = dmss () |- ( A ⊆ ( ( _V × _V ) × _V ) → dom A ⊆ dom ( ( _V × _V ) × _V ) ) ;;
	step 14 : wff = vn0 () |- _V ≠ ∅ ;;
	step 15 : wff = dmxp () |- ( _V ≠ ∅ → dom ( ( _V × _V ) × _V ) = ( _V × _V ) ) ;;
	step 16 : wff = ax-mp (step 14, step 15) |- dom ( ( _V × _V ) × _V ) = ( _V × _V ) ;;
	step 17 : wff = syl6sseq (step 13, step 16) |- ( A ⊆ ( ( _V × _V ) × _V ) → dom A ⊆ ( _V × _V ) ) ;;
	step 18 : wff = jca (step 12, step 17) |- ( A ⊆ ( ( _V × _V ) × _V ) → ( Rel A ∧ dom A ⊆ ( _V × _V ) ) ) ;;
	step 19 : wff = impbii (step 7, step 18) |- ( ( Rel A ∧ dom A ⊆ ( _V × _V ) ) ↔ A ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 20 : wff = bitri (step 2, step 19) |- ( ( Rel A ∧ Rel dom A ) ↔ A ⊆ ( ( _V × _V ) × _V ) ) ;;
	qed prop 1 = step 20 ;;
}

/*The membership relation for a relation is inherited by class union.
       (Contributed by NM, 17-Sep-2006.) */

theorem unielrel (A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( ( Rel R ∧ A ∈ R ) → ⋃ A ∈ ⋃ R ) ;;
}

proof of unielrel {
	var x : set, y : set;;
	step 1 : wff = elrel () |- ( ( Rel R ∧ A ∈ R ) → ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 2 : wff = simpr () |- ( ( Rel R ∧ A ∈ R ) → A ∈ R ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = uniopel (step 3, step 4) |- ( 〈 x , y 〉 ∈ R → ⋃ 〈 x , y 〉 ∈ ⋃ R ) ;;
	step 6 : wff = a1i (step 5) |- ( A = 〈 x , y 〉 → ( 〈 x , y 〉 ∈ R → ⋃ 〈 x , y 〉 ∈ ⋃ R ) ) ;;
	step 7 : wff = eleq1 () |- ( A = 〈 x , y 〉 → ( A ∈ R ↔ 〈 x , y 〉 ∈ R ) ) ;;
	step 8 : wff = unieq () |- ( A = 〈 x , y 〉 → ⋃ A = ⋃ 〈 x , y 〉 ) ;;
	step 9 : wff = eleq1d (step 8) |- ( A = 〈 x , y 〉 → ( ⋃ A ∈ ⋃ R ↔ ⋃ 〈 x , y 〉 ∈ ⋃ R ) ) ;;
	step 10 : wff = 3imtr4d (step 6, step 7, step 9) |- ( A = 〈 x , y 〉 → ( A ∈ R → ⋃ A ∈ ⋃ R ) ) ;;
	step 11 : wff = exlimivv (step 10) |- ( ∃ x ∃ y A = 〈 x , y 〉 → ( A ∈ R → ⋃ A ∈ ⋃ R ) ) ;;
	step 12 : wff = sylc (step 1, step 2, step 11) |- ( ( Rel R ∧ A ∈ R ) → ⋃ A ∈ ⋃ R ) ;;
	qed prop 1 = step 12 ;;
}

/*The double union of a relation is its field.  (Contributed by NM,
     17-Sep-2006.) */

theorem relfld (R : class)  {
	prop 1 : wff = |- ( Rel R → ⋃ ⋃ R = ( dom R ∪ ran R ) ) ;;
}

proof of relfld {
	step 1 : wff = relssdmrn () |- ( Rel R → R ⊆ ( dom R × ran R ) ) ;;
	step 2 : wff = uniss () |- ( R ⊆ ( dom R × ran R ) → ⋃ R ⊆ ⋃ ( dom R × ran R ) ) ;;
	step 3 : wff = uniss () |- ( ⋃ R ⊆ ⋃ ( dom R × ran R ) → ⋃ ⋃ R ⊆ ⋃ ⋃ ( dom R × ran R ) ) ;;
	step 4 : wff = 3syl (step 1, step 2, step 3) |- ( Rel R → ⋃ ⋃ R ⊆ ⋃ ⋃ ( dom R × ran R ) ) ;;
	step 5 : wff = unixpss () |- ⋃ ⋃ ( dom R × ran R ) ⊆ ( dom R ∪ ran R ) ;;
	step 6 : wff = syl6ss (step 4, step 5) |- ( Rel R → ⋃ ⋃ R ⊆ ( dom R ∪ ran R ) ) ;;
	step 7 : wff = dmrnssfld () |- ( dom R ∪ ran R ) ⊆ ⋃ ⋃ R ;;
	step 8 : wff = a1i (step 7) |- ( Rel R → ( dom R ∪ ran R ) ⊆ ⋃ ⋃ R ) ;;
	step 9 : wff = eqssd (step 6, step 8) |- ( Rel R → ⋃ ⋃ R = ( dom R ∪ ran R ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Restriction of a relation to its field.  (Contributed by FL,
     15-Apr-2012.) */

theorem relresfld (R : class)  {
	prop 1 : wff = |- ( Rel R → ( R ↾ ⋃ ⋃ R ) = R ) ;;
}

proof of relresfld {
	step 1 : wff = relfld () |- ( Rel R → ⋃ ⋃ R = ( dom R ∪ ran R ) ) ;;
	step 2 : wff = reseq2d (step 1) |- ( Rel R → ( R ↾ ⋃ ⋃ R ) = ( R ↾ ( dom R ∪ ran R ) ) ) ;;
	step 3 : wff = resundi () |- ( R ↾ ( dom R ∪ ran R ) ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) ;;
	step 4 : wff = eqtr () |- ( ( ( R ↾ ⋃ ⋃ R ) = ( R ↾ ( dom R ∪ ran R ) ) ∧ ( R ↾ ( dom R ∪ ran R ) ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) ) → ( R ↾ ⋃ ⋃ R ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) ) ;;
	step 5 : wff = resss () |- ( R ↾ ran R ) ⊆ R ;;
	step 6 : wff = resdm () |- ( Rel R → ( R ↾ dom R ) = R ) ;;
	step 7 : wff = ssequn2 () |- ( ( R ↾ ran R ) ⊆ R ↔ ( R ∪ ( R ↾ ran R ) ) = R ) ;;
	step 8 : wff = uneq1 () |- ( ( R ↾ dom R ) = R → ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) = ( R ∪ ( R ↾ ran R ) ) ) ;;
	step 9 : wff = eqeq2d (step 8) |- ( ( R ↾ dom R ) = R → ( ( R ↾ ⋃ ⋃ R ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) ↔ ( R ↾ ⋃ ⋃ R ) = ( R ∪ ( R ↾ ran R ) ) ) ) ;;
	step 10 : wff = eqtr () |- ( ( ( R ↾ ⋃ ⋃ R ) = ( R ∪ ( R ↾ ran R ) ) ∧ ( R ∪ ( R ↾ ran R ) ) = R ) → ( R ↾ ⋃ ⋃ R ) = R ) ;;
	step 11 : wff = ex (step 10) |- ( ( R ↾ ⋃ ⋃ R ) = ( R ∪ ( R ↾ ran R ) ) → ( ( R ∪ ( R ↾ ran R ) ) = R → ( R ↾ ⋃ ⋃ R ) = R ) ) ;;
	step 12 : wff = syl6bi (step 9, step 11) |- ( ( R ↾ dom R ) = R → ( ( R ↾ ⋃ ⋃ R ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) → ( ( R ∪ ( R ↾ ran R ) ) = R → ( R ↾ ⋃ ⋃ R ) = R ) ) ) ;;
	step 13 : wff = com3r (step 12) |- ( ( R ∪ ( R ↾ ran R ) ) = R → ( ( R ↾ dom R ) = R → ( ( R ↾ ⋃ ⋃ R ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) → ( R ↾ ⋃ ⋃ R ) = R ) ) ) ;;
	step 14 : wff = sylbi (step 7, step 13) |- ( ( R ↾ ran R ) ⊆ R → ( ( R ↾ dom R ) = R → ( ( R ↾ ⋃ ⋃ R ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) → ( R ↾ ⋃ ⋃ R ) = R ) ) ) ;;
	step 15 : wff = mpsyl (step 5, step 6, step 14) |- ( Rel R → ( ( R ↾ ⋃ ⋃ R ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) → ( R ↾ ⋃ ⋃ R ) = R ) ) ;;
	step 16 : wff = syl5com (step 4, step 15) |- ( ( ( R ↾ ⋃ ⋃ R ) = ( R ↾ ( dom R ∪ ran R ) ) ∧ ( R ↾ ( dom R ∪ ran R ) ) = ( ( R ↾ dom R ) ∪ ( R ↾ ran R ) ) ) → ( Rel R → ( R ↾ ⋃ ⋃ R ) = R ) ) ;;
	step 17 : wff = sylancl (step 2, step 3, step 16) |- ( Rel R → ( Rel R → ( R ↾ ⋃ ⋃ R ) = R ) ) ;;
	step 18 : wff = pm2.43i (step 17) |- ( Rel R → ( R ↾ ⋃ ⋃ R ) = R ) ;;
	qed prop 1 = step 18 ;;
}

/*Composition with the identity relation restricted to a relation's field.
     (Contributed by FL, 2-May-2011.) */

theorem relcoi2 (R : class)  {
	prop 1 : wff = |- ( Rel R → ( ( _I ↾ ⋃ ⋃ R ) ∘ R ) = R ) ;;
}

proof of relcoi2 {
	step 1 : wff = dmrnssfld () |- ( dom R ∪ ran R ) ⊆ ⋃ ⋃ R ;;
	step 2 : wff = unss () |- ( ( dom R ⊆ ⋃ ⋃ R ∧ ran R ⊆ ⋃ ⋃ R ) ↔ ( dom R ∪ ran R ) ⊆ ⋃ ⋃ R ) ;;
	step 3 : wff = simpr () |- ( ( dom R ⊆ ⋃ ⋃ R ∧ ran R ⊆ ⋃ ⋃ R ) → ran R ⊆ ⋃ ⋃ R ) ;;
	step 4 : wff = sylbir (step 2, step 3) |- ( ( dom R ∪ ran R ) ⊆ ⋃ ⋃ R → ran R ⊆ ⋃ ⋃ R ) ;;
	step 5 : wff = ax-mp (step 1, step 4) |- ran R ⊆ ⋃ ⋃ R ;;
	step 6 : wff = cores () |- ( ran R ⊆ ⋃ ⋃ R → ( ( _I ↾ ⋃ ⋃ R ) ∘ R ) = ( _I ∘ R ) ) ;;
	step 7 : wff = mp1i (step 5, step 6) |- ( Rel R → ( ( _I ↾ ⋃ ⋃ R ) ∘ R ) = ( _I ∘ R ) ) ;;
	step 8 : wff = coi2 () |- ( Rel R → ( _I ∘ R ) = R ) ;;
	step 9 : wff = eqtrd (step 7, step 8) |- ( Rel R → ( ( _I ↾ ⋃ ⋃ R ) ∘ R ) = R ) ;;
	qed prop 1 = step 9 ;;
}

/*Composition with the identity relation restricted to a relation's field.
     (Contributed by FL, 8-May-2011.) */

theorem relcoi1 (R : class)  {
	prop 1 : wff = |- ( Rel R → ( R ∘ ( _I ↾ ⋃ ⋃ R ) ) = R ) ;;
}

proof of relcoi1 {
	step 1 : wff = relfld () |- ( Rel R → ⋃ ⋃ R = ( dom R ∪ ran R ) ) ;;
	step 2 : wff = resundi () |- ( _I ↾ ( dom R ∪ ran R ) ) = ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ;;
	step 3 : wff = coeq2 () |- ( ( _I ↾ ( dom R ∪ ran R ) ) = ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) → ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ) ) ;;
	step 4 : wff = coundi () |- ( R ∘ ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ) = ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) ;;
	step 5 : wff = resco () |- ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) ;;
	step 6 : wff = coi1 () |- ( Rel R → ( R ∘ _I ) = R ) ;;
	step 7 : wff = reseq1 () |- ( ( R ∘ _I ) = R → ( ( R ∘ _I ) ↾ dom R ) = ( R ↾ dom R ) ) ;;
	step 8 : wff = resdm () |- ( Rel R → ( R ↾ dom R ) = R ) ;;
	step 9 : wff = eqtr () |- ( ( ( ( R ∘ _I ) ↾ dom R ) = ( R ↾ dom R ) ∧ ( R ↾ dom R ) = R ) → ( ( R ∘ _I ) ↾ dom R ) = R ) ;;
	step 10 : wff = eqtr () |- ( ( ( R ∘ ( _I ↾ dom R ) ) = ( ( R ∘ _I ) ↾ dom R ) ∧ ( ( R ∘ _I ) ↾ dom R ) = R ) → ( R ∘ ( _I ↾ dom R ) ) = R ) ;;
	step 11 : wff = resco () |- ( ( R ∘ _I ) ↾ ran R ) = ( R ∘ ( _I ↾ ran R ) ) ;;
	step 12 : wff = uneq1 () |- ( ( R ∘ ( _I ↾ dom R ) ) = R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) ) ;;
	step 13 : wff = coi1 () |- ( Rel R → ( R ∘ _I ) = R ) ;;
	step 14 : wff = reseq1 () |- ( ( R ∘ _I ) = R → ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) ) ;;
	step 15 : wff = eqtr () |- ( ( ( R ∘ ( _I ↾ ran R ) ) = ( ( R ∘ _I ) ↾ ran R ) ∧ ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) ) → ( R ∘ ( _I ↾ ran R ) ) = ( R ↾ ran R ) ) ;;
	step 16 : wff = uneq2d (step 15) |- ( ( ( R ∘ ( _I ↾ ran R ) ) = ( ( R ∘ _I ) ↾ ran R ) ∧ ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) ) → ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) ) ;;
	step 17 : wff = eqtr () |- ( ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) ∧ ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) ) ;;
	step 18 : wff = coi1 () |- ( Rel R → ( R ∘ _I ) = R ) ;;
	step 19 : wff = resss () |- ( R ↾ ran R ) ⊆ R ;;
	step 20 : wff = ssequn2 () |- ( ( R ↾ ran R ) ⊆ R ↔ ( R ∪ ( R ↾ ran R ) ) = R ) ;;
	step 21 : wff = mpbi (step 19, step 20) |- ( R ∪ ( R ↾ ran R ) ) = R ;;
	step 22 : wff = syl6reqr (step 18, step 21) |- ( Rel R → ( R ∪ ( R ↾ ran R ) ) = ( R ∘ _I ) ) ;;
	step 23 : wff = eqeq1 () |- ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ↔ ( R ∪ ( R ↾ ran R ) ) = ( R ∘ _I ) ) ) ;;
	step 24 : wff = syl5ibr (step 22, step 23) |- ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 25 : wff = syl (step 17, step 24) |- ( ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) ∧ ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) ) → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 26 : wff = ex (step 25) |- ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 27 : wff = com3l (step 26) |- ( ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ↾ ran R ) ) → ( Rel R → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 28 : wff = syl (step 16, step 27) |- ( ( ( R ∘ ( _I ↾ ran R ) ) = ( ( R ∘ _I ) ↾ ran R ) ∧ ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) ) → ( Rel R → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 29 : wff = ex (step 28) |- ( ( R ∘ ( _I ↾ ran R ) ) = ( ( R ∘ _I ) ↾ ran R ) → ( ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) → ( Rel R → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ) ;;
	step 30 : wff = eqcoms (step 29) |- ( ( ( R ∘ _I ) ↾ ran R ) = ( R ∘ ( _I ↾ ran R ) ) → ( ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) → ( Rel R → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ) ;;
	step 31 : wff = com3l (step 30) |- ( ( ( R ∘ _I ) ↾ ran R ) = ( R ↾ ran R ) → ( Rel R → ( ( ( R ∘ _I ) ↾ ran R ) = ( R ∘ ( _I ↾ ran R ) ) → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ) ;;
	step 32 : wff = syl (step 14, step 31) |- ( ( R ∘ _I ) = R → ( Rel R → ( ( ( R ∘ _I ) ↾ ran R ) = ( R ∘ ( _I ↾ ran R ) ) → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ) ;;
	step 33 : wff = mpcom (step 13, step 32) |- ( Rel R → ( ( ( R ∘ _I ) ↾ ran R ) = ( R ∘ ( _I ↾ ran R ) ) → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 34 : wff = com3l (step 33) |- ( ( ( R ∘ _I ) ↾ ran R ) = ( R ∘ ( _I ↾ ran R ) ) → ( ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∪ ( R ∘ ( _I ↾ ran R ) ) ) → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 35 : wff = mpsyl (step 11, step 12, step 34) |- ( ( R ∘ ( _I ↾ dom R ) ) = R → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 36 : wff = syl (step 10, step 35) |- ( ( ( R ∘ ( _I ↾ dom R ) ) = ( ( R ∘ _I ) ↾ dom R ) ∧ ( ( R ∘ _I ) ↾ dom R ) = R ) → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 37 : wff = ex (step 36) |- ( ( R ∘ ( _I ↾ dom R ) ) = ( ( R ∘ _I ) ↾ dom R ) → ( ( ( R ∘ _I ) ↾ dom R ) = R → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 38 : wff = eqcoms (step 37) |- ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( ( R ∘ _I ) ↾ dom R ) = R → ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 39 : wff = com3l (step 38) |- ( ( ( R ∘ _I ) ↾ dom R ) = R → ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 40 : wff = syl (step 9, step 39) |- ( ( ( ( R ∘ _I ) ↾ dom R ) = ( R ↾ dom R ) ∧ ( R ↾ dom R ) = R ) → ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 41 : wff = ex (step 40) |- ( ( ( R ∘ _I ) ↾ dom R ) = ( R ↾ dom R ) → ( ( R ↾ dom R ) = R → ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ) ;;
	step 42 : wff = com3l (step 41) |- ( ( R ↾ dom R ) = R → ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ↾ dom R ) → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ) ;;
	step 43 : wff = mpcom (step 8, step 42) |- ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ↾ dom R ) → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 44 : wff = syl5com (step 7, step 43) |- ( ( R ∘ _I ) = R → ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ) ;;
	step 45 : wff = mpcom (step 6, step 44) |- ( Rel R → ( ( ( R ∘ _I ) ↾ dom R ) = ( R ∘ ( _I ↾ dom R ) ) → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 46 : wff = mpi (step 5, step 45) |- ( Rel R → ( ( R ∘ ( _I ↾ dom R ) ) ∪ ( R ∘ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ;;
	step 47 : wff = syl5eq (step 4, step 46) |- ( Rel R → ( R ∘ ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ;;
	step 48 : wff = eqeq1 () |- ( ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ) → ( ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ _I ) ↔ ( R ∘ ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 49 : wff = syl5ibr (step 47, step 48) |- ( ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ ( ( _I ↾ dom R ) ∪ ( _I ↾ ran R ) ) ) → ( Rel R → ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 50 : wff = mp2b (step 2, step 3, step 49) |- ( Rel R → ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ _I ) ) ;;
	step 51 : wff = reseq2 () |- ( ⋃ ⋃ R = ( dom R ∪ ran R ) → ( _I ↾ ⋃ ⋃ R ) = ( _I ↾ ( dom R ∪ ran R ) ) ) ;;
	step 52 : wff = coeq2d (step 51) |- ( ⋃ ⋃ R = ( dom R ∪ ran R ) → ( R ∘ ( _I ↾ ⋃ ⋃ R ) ) = ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) ) ;;
	step 53 : wff = eqeq1d (step 52) |- ( ⋃ ⋃ R = ( dom R ∪ ran R ) → ( ( R ∘ ( _I ↾ ⋃ ⋃ R ) ) = ( R ∘ _I ) ↔ ( R ∘ ( _I ↾ ( dom R ∪ ran R ) ) ) = ( R ∘ _I ) ) ) ;;
	step 54 : wff = syl5ibr (step 50, step 53) |- ( ⋃ ⋃ R = ( dom R ∪ ran R ) → ( Rel R → ( R ∘ ( _I ↾ ⋃ ⋃ R ) ) = ( R ∘ _I ) ) ) ;;
	step 55 : wff = mpcom (step 1, step 54) |- ( Rel R → ( R ∘ ( _I ↾ ⋃ ⋃ R ) ) = ( R ∘ _I ) ) ;;
	step 56 : wff = coi1 () |- ( Rel R → ( R ∘ _I ) = R ) ;;
	step 57 : wff = eqtrd (step 55, step 56) |- ( Rel R → ( R ∘ ( _I ↾ ⋃ ⋃ R ) ) = R ) ;;
	qed prop 1 = step 57 ;;
}

/*The double union of the converse of a class is its field.  (Contributed by
     NM, 4-Jun-2008.) */

theorem unidmrn (A : class)  {
	prop 1 : wff = |- ⋃ ⋃ ⁻¹ A = ( dom A ∪ ran A ) ;;
}

proof of unidmrn {
	step 1 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 2 : wff = relfld () |- ( Rel ⁻¹ A → ⋃ ⋃ ⁻¹ A = ( dom ⁻¹ A ∪ ran ⁻¹ A ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ⋃ ⋃ ⁻¹ A = ( dom ⁻¹ A ∪ ran ⁻¹ A ) ;;
	step 4 : wff = equncomi (step 3) |- ⋃ ⋃ ⁻¹ A = ( ran ⁻¹ A ∪ dom ⁻¹ A ) ;;
	step 5 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 6 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 7 : wff = uneq12i (step 5, step 6) |- ( dom A ∪ ran A ) = ( ran ⁻¹ A ∪ dom ⁻¹ A ) ;;
	step 8 : wff = eqtr4i (step 4, step 7) |- ⋃ ⋃ ⁻¹ A = ( dom A ∪ ran A ) ;;
	qed prop 1 = step 8 ;;
}

/*if ` R ` is a relation, its double union equals the double union of its
     converse.  (Contributed by FL, 5-Jan-2009.) */

theorem relcnvfld (R : class)  {
	prop 1 : wff = |- ( Rel R → ⋃ ⋃ R = ⋃ ⋃ ⁻¹ R ) ;;
}

proof of relcnvfld {
	step 1 : wff = relfld () |- ( Rel R → ⋃ ⋃ R = ( dom R ∪ ran R ) ) ;;
	step 2 : wff = unidmrn () |- ⋃ ⋃ ⁻¹ R = ( dom R ∪ ran R ) ;;
	step 3 : wff = syl6eqr (step 1, step 2) |- ( Rel R → ⋃ ⋃ R = ⋃ ⋃ ⁻¹ R ) ;;
	qed prop 1 = step 3 ;;
}

/*Alternate definition of domain ~ df-dm that doesn't require dummy
     variables.  (Contributed by NM, 2-Aug-2010.) */

theorem dfdm2 (A : class)  {
	prop 1 : wff = |- dom A = ⋃ ⋃ ( ⁻¹ A ∘ A ) ;;
}

proof of dfdm2 {
	step 1 : wff = cnvco () |- ⁻¹ ( ⁻¹ A ∘ A ) = ( ⁻¹ A ∘ ⁻¹ ⁻¹ A ) ;;
	step 2 : wff = cocnvcnv2 () |- ( ⁻¹ A ∘ ⁻¹ ⁻¹ A ) = ( ⁻¹ A ∘ A ) ;;
	step 3 : wff = eqtri (step 1, step 2) |- ⁻¹ ( ⁻¹ A ∘ A ) = ( ⁻¹ A ∘ A ) ;;
	step 4 : wff = unieqi (step 3) |- ⋃ ⁻¹ ( ⁻¹ A ∘ A ) = ⋃ ( ⁻¹ A ∘ A ) ;;
	step 5 : wff = unieqi (step 4) |- ⋃ ⋃ ⁻¹ ( ⁻¹ A ∘ A ) = ⋃ ⋃ ( ⁻¹ A ∘ A ) ;;
	step 6 : wff = unidmrn () |- ⋃ ⋃ ⁻¹ ( ⁻¹ A ∘ A ) = ( dom ( ⁻¹ A ∘ A ) ∪ ran ( ⁻¹ A ∘ A ) ) ;;
	step 7 : wff = eqtr3i (step 5, step 6) |- ⋃ ⋃ ( ⁻¹ A ∘ A ) = ( dom ( ⁻¹ A ∘ A ) ∪ ran ( ⁻¹ A ∘ A ) ) ;;
	step 8 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 9 : wff = eqcomi (step 8) |- dom ⁻¹ A = ran A ;;
	step 10 : wff = dmcoeq () |- ( dom ⁻¹ A = ran A → dom ( ⁻¹ A ∘ A ) = dom A ) ;;
	step 11 : wff = ax-mp (step 9, step 10) |- dom ( ⁻¹ A ∘ A ) = dom A ;;
	step 12 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 13 : wff = eqcomi (step 12) |- dom ⁻¹ A = ran A ;;
	step 14 : wff = rncoeq () |- ( dom ⁻¹ A = ran A → ran ( ⁻¹ A ∘ A ) = ran ⁻¹ A ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- ran ( ⁻¹ A ∘ A ) = ran ⁻¹ A ;;
	step 16 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 17 : wff = eqtr4i (step 15, step 16) |- ran ( ⁻¹ A ∘ A ) = dom A ;;
	step 18 : wff = uneq12i (step 11, step 17) |- ( dom ( ⁻¹ A ∘ A ) ∪ ran ( ⁻¹ A ∘ A ) ) = ( dom A ∪ dom A ) ;;
	step 19 : wff = unidm () |- ( dom A ∪ dom A ) = dom A ;;
	step 20 : wff = 3eqtrri (step 7, step 18, step 19) |- dom A = ⋃ ⋃ ( ⁻¹ A ∘ A ) ;;
	qed prop 1 = step 20 ;;
}

/*The double class union of a non-empty cross product is the union of it
     members.  (Contributed by NM, 17-Sep-2006.) */

theorem unixp (A : class, B : class)  {
	prop 1 : wff = |- ( ( A × B ) ≠ ∅ → ⋃ ⋃ ( A × B ) = ( A ∪ B ) ) ;;
}

proof of unixp {
	step 1 : wff = relxp () |- Rel ( A × B ) ;;
	step 2 : wff = relfld () |- ( Rel ( A × B ) → ⋃ ⋃ ( A × B ) = ( dom ( A × B ) ∪ ran ( A × B ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ⋃ ⋃ ( A × B ) = ( dom ( A × B ) ∪ ran ( A × B ) ) ;;
	step 4 : wff = xpeq2 () |- ( B = ∅ → ( A × B ) = ( A × ∅ ) ) ;;
	step 5 : wff = xp0 () |- ( A × ∅ ) = ∅ ;;
	step 6 : wff = syl6eq (step 4, step 5) |- ( B = ∅ → ( A × B ) = ∅ ) ;;
	step 7 : wff = necon3i (step 6) |- ( ( A × B ) ≠ ∅ → B ≠ ∅ ) ;;
	step 8 : wff = xpeq1 () |- ( A = ∅ → ( A × B ) = ( ∅ × B ) ) ;;
	step 9 : wff = xp0r () |- ( ∅ × B ) = ∅ ;;
	step 10 : wff = syl6eq (step 8, step 9) |- ( A = ∅ → ( A × B ) = ∅ ) ;;
	step 11 : wff = necon3i (step 10) |- ( ( A × B ) ≠ ∅ → A ≠ ∅ ) ;;
	step 12 : wff = dmxp () |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
	step 13 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
	step 14 : wff = uneq12 () |- ( ( dom ( A × B ) = A ∧ ran ( A × B ) = B ) → ( dom ( A × B ) ∪ ran ( A × B ) ) = ( A ∪ B ) ) ;;
	step 15 : wff = syl2an (step 12, step 13, step 14) |- ( ( B ≠ ∅ ∧ A ≠ ∅ ) → ( dom ( A × B ) ∪ ran ( A × B ) ) = ( A ∪ B ) ) ;;
	step 16 : wff = syl2anc (step 7, step 11, step 15) |- ( ( A × B ) ≠ ∅ → ( dom ( A × B ) ∪ ran ( A × B ) ) = ( A ∪ B ) ) ;;
	step 17 : wff = syl5eq (step 3, step 16) |- ( ( A × B ) ≠ ∅ → ⋃ ⋃ ( A × B ) = ( A ∪ B ) ) ;;
	qed prop 1 = step 17 ;;
}

/*A cross product is empty iff its union is empty.  (Contributed by NM,
       20-Sep-2006.) */

theorem unixp0 (A : class, B : class) disjointed(x y z A, x y z B) {
	prop 1 : wff = |- ( ( A × B ) = ∅ ↔ ⋃ ( A × B ) = ∅ ) ;;
}

proof of unixp0 {
	var x : set, y : set, z : set;;
	step 1 : wff = unieq () |- ( ( A × B ) = ∅ → ⋃ ( A × B ) = ⋃ ∅ ) ;;
	step 2 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 3 : wff = syl6eq (step 1, step 2) |- ( ( A × B ) = ∅ → ⋃ ( A × B ) = ∅ ) ;;
	step 4 : wff = n0 () |- ( ( A × B ) ≠ ∅ ↔ ∃ z z ∈ ( A × B ) ) ;;
	step 5 : wff = elxp3 () |- ( z ∈ ( A × B ) ↔ ∃ x ∃ y ( 〈 x , y 〉 = z ∧ 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 6 : wff = elssuni () |- ( 〈 x , y 〉 ∈ ( A × B ) → 〈 x , y 〉 ⊆ ⋃ ( A × B ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opnzi (step 7, step 8) |- 〈 x , y 〉 ≠ ∅ ;;
	step 10 : wff = ssn0 () |- ( ( 〈 x , y 〉 ⊆ ⋃ ( A × B ) ∧ 〈 x , y 〉 ≠ ∅ ) → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 11 : wff = sylancl (step 6, step 9, step 10) |- ( 〈 x , y 〉 ∈ ( A × B ) → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 12 : wff = adantl (step 11) |- ( ( 〈 x , y 〉 = z ∧ 〈 x , y 〉 ∈ ( A × B ) ) → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 13 : wff = exlimivv (step 12) |- ( ∃ x ∃ y ( 〈 x , y 〉 = z ∧ 〈 x , y 〉 ∈ ( A × B ) ) → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 14 : wff = sylbi (step 5, step 13) |- ( z ∈ ( A × B ) → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 15 : wff = exlimiv (step 14) |- ( ∃ z z ∈ ( A × B ) → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 16 : wff = sylbi (step 4, step 15) |- ( ( A × B ) ≠ ∅ → ⋃ ( A × B ) ≠ ∅ ) ;;
	step 17 : wff = necon4i (step 16) |- ( ⋃ ( A × B ) = ∅ → ( A × B ) = ∅ ) ;;
	step 18 : wff = impbii (step 3, step 17) |- ( ( A × B ) = ∅ ↔ ⋃ ( A × B ) = ∅ ) ;;
	qed prop 1 = step 18 ;;
}

/*Field of a square cross product.  (Contributed by FL, 10-Oct-2009.) */

theorem unixpid (A : class)  {
	prop 1 : wff = |- ⋃ ⋃ ( A × A ) = A ;;
}

proof of unixpid {
	step 1 : wff = xpeq1 () |- ( A = ∅ → ( A × A ) = ( ∅ × A ) ) ;;
	step 2 : wff = xp0r () |- ( ∅ × A ) = ∅ ;;
	step 3 : wff = syl6eq (step 1, step 2) |- ( A = ∅ → ( A × A ) = ∅ ) ;;
	step 4 : wff = unieq () |- ( ( A × A ) = ∅ → ⋃ ( A × A ) = ⋃ ∅ ) ;;
	step 5 : wff = unieqd (step 4) |- ( ( A × A ) = ∅ → ⋃ ⋃ ( A × A ) = ⋃ ⋃ ∅ ) ;;
	step 6 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 7 : wff = unieqi (step 6) |- ⋃ ⋃ ∅ = ⋃ ∅ ;;
	step 8 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 9 : wff = eqtri (step 7, step 8) |- ⋃ ⋃ ∅ = ∅ ;;
	step 10 : wff = eqtr () |- ( ( ⋃ ⋃ ( A × A ) = ⋃ ⋃ ∅ ∧ ⋃ ⋃ ∅ = ∅ ) → ⋃ ⋃ ( A × A ) = ∅ ) ;;
	step 11 : wff = eqtr () |- ( ( ⋃ ⋃ ( A × A ) = ∅ ∧ ∅ = A ) → ⋃ ⋃ ( A × A ) = A ) ;;
	step 12 : wff = expcom (step 11) |- ( ∅ = A → ( ⋃ ⋃ ( A × A ) = ∅ → ⋃ ⋃ ( A × A ) = A ) ) ;;
	step 13 : wff = eqcoms (step 12) |- ( A = ∅ → ( ⋃ ⋃ ( A × A ) = ∅ → ⋃ ⋃ ( A × A ) = A ) ) ;;
	step 14 : wff = syl5com (step 10, step 13) |- ( ( ⋃ ⋃ ( A × A ) = ⋃ ⋃ ∅ ∧ ⋃ ⋃ ∅ = ∅ ) → ( A = ∅ → ⋃ ⋃ ( A × A ) = A ) ) ;;
	step 15 : wff = sylancl (step 5, step 9, step 14) |- ( ( A × A ) = ∅ → ( A = ∅ → ⋃ ⋃ ( A × A ) = A ) ) ;;
	step 16 : wff = mpcom (step 3, step 15) |- ( A = ∅ → ⋃ ⋃ ( A × A ) = A ) ;;
	step 17 : wff = df-ne () |- ( A ≠ ∅ ↔ ¬ A = ∅ ) ;;
	step 18 : wff = df-ne () |- ( A ≠ ∅ ↔ ¬ A = ∅ ) ;;
	step 19 : wff = xpnz () |- ( ( A ≠ ∅ ∧ A ≠ ∅ ) ↔ ( A × A ) ≠ ∅ ) ;;
	step 20 : wff = unixp () |- ( ( A × A ) ≠ ∅ → ⋃ ⋃ ( A × A ) = ( A ∪ A ) ) ;;
	step 21 : wff = unidm () |- ( A ∪ A ) = A ;;
	step 22 : wff = syl6eq (step 20, step 21) |- ( ( A × A ) ≠ ∅ → ⋃ ⋃ ( A × A ) = A ) ;;
	step 23 : wff = sylbi (step 19, step 22) |- ( ( A ≠ ∅ ∧ A ≠ ∅ ) → ⋃ ⋃ ( A × A ) = A ) ;;
	step 24 : wff = sylancbr (step 17, step 18, step 23) |- ( ¬ A = ∅ → ⋃ ⋃ ( A × A ) = A ) ;;
	step 25 : wff = pm2.61i (step 16, step 24) |- ⋃ ⋃ ( A × A ) = A ;;
	qed prop 1 = step 25 ;;
}

/*The converse of a set is a set.  Corollary 6.8(1) of [TakeutiZaring]
     p. 26.  (Contributed by NM, 17-Mar-1998.) */

theorem cnvexg (A : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ⁻¹ A ∈ _V ) ;;
}

proof of cnvexg {
	step 1 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 2 : wff = relssdmrn () |- ( Rel ⁻¹ A → ⁻¹ A ⊆ ( dom ⁻¹ A × ran ⁻¹ A ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ⁻¹ A ⊆ ( dom ⁻¹ A × ran ⁻¹ A ) ;;
	step 4 : wff = df-rn () |- ran A = dom ⁻¹ A ;;
	step 5 : wff = rnexg () |- ( A ∈ V → ran A ∈ _V ) ;;
	step 6 : wff = syl5eqelr (step 4, step 5) |- ( A ∈ V → dom ⁻¹ A ∈ _V ) ;;
	step 7 : wff = dfdm4 () |- dom A = ran ⁻¹ A ;;
	step 8 : wff = dmexg () |- ( A ∈ V → dom A ∈ _V ) ;;
	step 9 : wff = syl5eqelr (step 7, step 8) |- ( A ∈ V → ran ⁻¹ A ∈ _V ) ;;
	step 10 : wff = xpexg () |- ( ( dom ⁻¹ A ∈ _V ∧ ran ⁻¹ A ∈ _V ) → ( dom ⁻¹ A × ran ⁻¹ A ) ∈ _V ) ;;
	step 11 : wff = syl2anc (step 6, step 9, step 10) |- ( A ∈ V → ( dom ⁻¹ A × ran ⁻¹ A ) ∈ _V ) ;;
	step 12 : wff = ssexg () |- ( ( ⁻¹ A ⊆ ( dom ⁻¹ A × ran ⁻¹ A ) ∧ ( dom ⁻¹ A × ran ⁻¹ A ) ∈ _V ) → ⁻¹ A ∈ _V ) ;;
	step 13 : wff = sylancr (step 3, step 11, step 12) |- ( A ∈ V → ⁻¹ A ∈ _V ) ;;
	qed prop 1 = step 13 ;;
}

/*The converse of a set is a set.  Corollary 6.8(1) of [TakeutiZaring]
       p. 26.  (Contributed by NM, 19-Dec-2003.) */

theorem cnvex (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⁻¹ A ∈ _V ;;
}

proof of cnvex {
	step 1 : wff = cnvexg () |- ( A ∈ _V → ⁻¹ A ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ⁻¹ A ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/*A relation is a set iff its converse is a set.  (Contributed by FL,
     3-Mar-2007.) */

theorem relcnvexb (R : class)  {
	prop 1 : wff = |- ( Rel R → ( R ∈ _V ↔ ⁻¹ R ∈ _V ) ) ;;
}

proof of relcnvexb {
	step 1 : wff = cnvexg () |- ( R ∈ _V → ⁻¹ R ∈ _V ) ;;
	step 2 : wff = dfrel2 () |- ( Rel R ↔ ⁻¹ ⁻¹ R = R ) ;;
	step 3 : wff = cnvexg () |- ( ⁻¹ R ∈ _V → ⁻¹ ⁻¹ R ∈ _V ) ;;
	step 4 : wff = eleq1 () |- ( ⁻¹ ⁻¹ R = R → ( ⁻¹ ⁻¹ R ∈ _V ↔ R ∈ _V ) ) ;;
	step 5 : wff = syl5ib (step 3, step 4) |- ( ⁻¹ ⁻¹ R = R → ( ⁻¹ R ∈ _V → R ∈ _V ) ) ;;
	step 6 : wff = sylbi (step 2, step 5) |- ( Rel R → ( ⁻¹ R ∈ _V → R ∈ _V ) ) ;;
	step 7 : wff = impbid2 (step 1, step 6) |- ( Rel R → ( R ∈ _V ↔ ⁻¹ R ∈ _V ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Restriction of a class to a singleton.  (Contributed by Mario Carneiro,
       28-Dec-2014.) */

theorem ressn (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ↾ { B } ) = ( { B } × ( A " { B } ) ) ;;
}

proof of ressn {
	var x : set, y : set;;
	step 1 : wff = relres () |- Rel ( A ↾ { B } ) ;;
	step 2 : wff = relxp () |- Rel ( { B } × ( A " { B } ) ) ;;
	step 3 : wff = ancom () |- ( ( 〈 x , y 〉 ∈ A ∧ x ∈ { B } ) ↔ ( x ∈ { B } ∧ 〈 x , y 〉 ∈ A ) ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = elimasn (step 4, step 5) |- ( y ∈ ( A " { x } ) ↔ 〈 x , y 〉 ∈ A ) ;;
	step 7 : wff = elsni () |- ( x ∈ { B } → x = B ) ;;
	step 8 : wff = sneqd (step 7) |- ( x ∈ { B } → { x } = { B } ) ;;
	step 9 : wff = imaeq2d (step 8) |- ( x ∈ { B } → ( A " { x } ) = ( A " { B } ) ) ;;
	step 10 : wff = eleq2d (step 9) |- ( x ∈ { B } → ( y ∈ ( A " { x } ) ↔ y ∈ ( A " { B } ) ) ) ;;
	step 11 : wff = syl5bbr (step 6, step 10) |- ( x ∈ { B } → ( 〈 x , y 〉 ∈ A ↔ y ∈ ( A " { B } ) ) ) ;;
	step 12 : wff = pm5.32i (step 11) |- ( ( x ∈ { B } ∧ 〈 x , y 〉 ∈ A ) ↔ ( x ∈ { B } ∧ y ∈ ( A " { B } ) ) ) ;;
	step 13 : wff = bitri (step 3, step 12) |- ( ( 〈 x , y 〉 ∈ A ∧ x ∈ { B } ) ↔ ( x ∈ { B } ∧ y ∈ ( A " { B } ) ) ) ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = opelres (step 14) |- ( 〈 x , y 〉 ∈ ( A ↾ { B } ) ↔ ( 〈 x , y 〉 ∈ A ∧ x ∈ { B } ) ) ;;
	step 16 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( { B } × ( A " { B } ) ) ↔ ( x ∈ { B } ∧ y ∈ ( A " { B } ) ) ) ;;
	step 17 : wff = 3bitr4i (step 13, step 15, step 16) |- ( 〈 x , y 〉 ∈ ( A ↾ { B } ) ↔ 〈 x , y 〉 ∈ ( { B } × ( A " { B } ) ) ) ;;
	step 18 : wff = eqrelriiv (step 1, step 2, step 17) |- ( A ↾ { B } ) = ( { B } × ( A " { B } ) ) ;;
	qed prop 1 = step 18 ;;
}

/*The converse of an intersection is the intersection of the converse.
       (Contributed by FL, 15-Oct-2012.) */

theorem cnviin (x : set, A : class, B : class) disjointed(A a b x, B a b) {
	prop 1 : wff = |- ( A ≠ ∅ → ⁻¹ ⋂_ x ∈ A B = ⋂_ x ∈ A ⁻¹ B ) ;;
}

proof of cnviin {
	var a : set, b : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ ⋂_ x ∈ A B ;;
	step 2 : wff = r19.2z () |- ( ( A ≠ ∅ ∧ ∀ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) → ∃ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 3 : wff = expcom (step 2) |- ( ∀ x ∈ A ⁻¹ B ⊆ ( _V × _V ) → ( A ≠ ∅ → ∃ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) ) ;;
	step 4 : wff = relcnv () |- Rel ⁻¹ B ;;
	step 5 : wff = df-rel () |- ( Rel ⁻¹ B ↔ ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- ⁻¹ B ⊆ ( _V × _V ) ;;
	step 7 : wff = a1i (step 6) |- ( x ∈ A → ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 8 : wff = mprg (step 3, step 7) |- ( A ≠ ∅ → ∃ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 9 : wff = iinss () |- ( ∃ x ∈ A ⁻¹ B ⊆ ( _V × _V ) → ⋂_ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( A ≠ ∅ → ⋂_ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 11 : wff = df-rel () |- ( Rel ⋂_ x ∈ A ⁻¹ B ↔ ⋂_ x ∈ A ⁻¹ B ⊆ ( _V × _V ) ) ;;
	step 12 : wff = sylibr (step 10, step 11) |- ( A ≠ ∅ → Rel ⋂_ x ∈ A ⁻¹ B ) ;;
	step 13 : wff = opex () |- 〈 b , a 〉 ∈ _V ;;
	step 14 : wff = eliin () |- ( 〈 b , a 〉 ∈ _V → ( 〈 b , a 〉 ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A 〈 b , a 〉 ∈ B ) ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- ( 〈 b , a 〉 ∈ ⋂_ x ∈ A B ↔ ∀ x ∈ A 〈 b , a 〉 ∈ B ) ;;
	step 16 : wff = vex () |- a ∈ _V ;;
	step 17 : wff = vex () |- b ∈ _V ;;
	step 18 : wff = opelcnv (step 16, step 17) |- ( 〈 a , b 〉 ∈ ⁻¹ ⋂_ x ∈ A B ↔ 〈 b , a 〉 ∈ ⋂_ x ∈ A B ) ;;
	step 19 : wff = opex () |- 〈 a , b 〉 ∈ _V ;;
	step 20 : wff = eliin () |- ( 〈 a , b 〉 ∈ _V → ( 〈 a , b 〉 ∈ ⋂_ x ∈ A ⁻¹ B ↔ ∀ x ∈ A 〈 a , b 〉 ∈ ⁻¹ B ) ) ;;
	step 21 : wff = ax-mp (step 19, step 20) |- ( 〈 a , b 〉 ∈ ⋂_ x ∈ A ⁻¹ B ↔ ∀ x ∈ A 〈 a , b 〉 ∈ ⁻¹ B ) ;;
	step 22 : wff = vex () |- a ∈ _V ;;
	step 23 : wff = vex () |- b ∈ _V ;;
	step 24 : wff = opelcnv (step 22, step 23) |- ( 〈 a , b 〉 ∈ ⁻¹ B ↔ 〈 b , a 〉 ∈ B ) ;;
	step 25 : wff = ralbii (step 24) |- ( ∀ x ∈ A 〈 a , b 〉 ∈ ⁻¹ B ↔ ∀ x ∈ A 〈 b , a 〉 ∈ B ) ;;
	step 26 : wff = bitri (step 21, step 25) |- ( 〈 a , b 〉 ∈ ⋂_ x ∈ A ⁻¹ B ↔ ∀ x ∈ A 〈 b , a 〉 ∈ B ) ;;
	step 27 : wff = 3bitr4i (step 15, step 18, step 26) |- ( 〈 a , b 〉 ∈ ⁻¹ ⋂_ x ∈ A B ↔ 〈 a , b 〉 ∈ ⋂_ x ∈ A ⁻¹ B ) ;;
	step 28 : wff = eqrelriv (step 27) |- ( ( Rel ⁻¹ ⋂_ x ∈ A B ∧ Rel ⋂_ x ∈ A ⁻¹ B ) → ⁻¹ ⋂_ x ∈ A B = ⋂_ x ∈ A ⁻¹ B ) ;;
	step 29 : wff = sylancr (step 1, step 12, step 28) |- ( A ≠ ∅ → ⁻¹ ⋂_ x ∈ A B = ⋂_ x ∈ A ⁻¹ B ) ;;
	qed prop 1 = step 29 ;;
}

/*The converse of a partial order relation is a partial order relation.
       (Contributed by NM, 15-Jun-2005.) */

theorem cnvpo (A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( R Po A ↔ ⁻¹ R Po A ) ;;
}

proof of cnvpo {
	var x : set, y : set, z : set;;
	step 1 : wff = r19.26 () |- ( ∀ x ∈ A ( ∀ z ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ∀ x ∈ A ∀ z ∈ A ¬ x R x ∧ ∀ x ∈ A ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 2 : wff = ralidm () |- ( ∀ x ∈ A ∀ x ∈ A ¬ x R x ↔ ∀ x ∈ A ¬ x R x ) ;;
	step 3 : wff = rzal () |- ( A = ∅ → ∀ x ∈ A ¬ x R x ) ;;
	step 4 : wff = rzal () |- ( A = ∅ → ∀ x ∈ A ∀ z ∈ A ¬ x R x ) ;;
	step 5 : wff = 2thd (step 3, step 4) |- ( A = ∅ → ( ∀ x ∈ A ¬ x R x ↔ ∀ x ∈ A ∀ z ∈ A ¬ x R x ) ) ;;
	step 6 : wff = r19.3rzv () |- ( A ≠ ∅ → ( ¬ x R x ↔ ∀ z ∈ A ¬ x R x ) ) ;;
	step 7 : wff = ralbidv (step 6) |- ( A ≠ ∅ → ( ∀ x ∈ A ¬ x R x ↔ ∀ x ∈ A ∀ z ∈ A ¬ x R x ) ) ;;
	step 8 : wff = pm2.61ine (step 5, step 7) |- ( ∀ x ∈ A ¬ x R x ↔ ∀ x ∈ A ∀ z ∈ A ¬ x R x ) ;;
	step 9 : wff = bitr2i (step 2, step 8) |- ( ∀ x ∈ A ∀ z ∈ A ¬ x R x ↔ ∀ x ∈ A ∀ x ∈ A ¬ x R x ) ;;
	step 10 : wff = anbi1i (step 9) |- ( ( ∀ x ∈ A ∀ z ∈ A ¬ x R x ∧ ∀ x ∈ A ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ∀ x ∈ A ∀ x ∈ A ¬ x R x ∧ ∀ x ∈ A ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( ∀ x ∈ A ( ∀ z ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ∀ x ∈ A ∀ x ∈ A ¬ x R x ∧ ∀ x ∈ A ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 12 : wff = r19.26 () |- ( ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ∀ z ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 13 : wff = ralbii (step 12) |- ( ∀ x ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∈ A ( ∀ z ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 14 : wff = r19.26 () |- ( ∀ x ∈ A ( ∀ x ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ∀ x ∈ A ∀ x ∈ A ¬ x R x ∧ ∀ x ∈ A ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 15 : wff = 3bitr4i (step 11, step 13, step 14) |- ( ∀ x ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∈ A ( ∀ x ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 16 : wff = r19.26 () |- ( ∀ z ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ↔ ( ∀ z ∈ A ¬ z ⁻¹ R z ∧ ∀ z ∈ A ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 17 : wff = vex () |- z ∈ _V ;;
	step 18 : wff = vex () |- z ∈ _V ;;
	step 19 : wff = brcnv (step 17, step 18) |- ( z ⁻¹ R z ↔ z R z ) ;;
	step 20 : wff = id () |- ( z = x → z = x ) ;;
	step 21 : wff = id () |- ( z = x → z = x ) ;;
	step 22 : wff = breq12d (step 20, step 21) |- ( z = x → ( z R z ↔ x R x ) ) ;;
	step 23 : wff = syl5bb (step 19, step 22) |- ( z = x → ( z ⁻¹ R z ↔ x R x ) ) ;;
	step 24 : wff = notbid (step 23) |- ( z = x → ( ¬ z ⁻¹ R z ↔ ¬ x R x ) ) ;;
	step 25 : wff = cbvralv (step 24) |- ( ∀ z ∈ A ¬ z ⁻¹ R z ↔ ∀ x ∈ A ¬ x R x ) ;;
	step 26 : wff = vex () |- z ∈ _V ;;
	step 27 : wff = vex () |- y ∈ _V ;;
	step 28 : wff = brcnv (step 26, step 27) |- ( z ⁻¹ R y ↔ y R z ) ;;
	step 29 : wff = vex () |- y ∈ _V ;;
	step 30 : wff = vex () |- x ∈ _V ;;
	step 31 : wff = brcnv (step 29, step 30) |- ( y ⁻¹ R x ↔ x R y ) ;;
	step 32 : wff = anbi12ci (step 28, step 31) |- ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) ↔ ( x R y ∧ y R z ) ) ;;
	step 33 : wff = vex () |- z ∈ _V ;;
	step 34 : wff = vex () |- x ∈ _V ;;
	step 35 : wff = brcnv (step 33, step 34) |- ( z ⁻¹ R x ↔ x R z ) ;;
	step 36 : wff = imbi12i (step 32, step 35) |- ( ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ↔ ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 37 : wff = ralbii (step 36) |- ( ∀ z ∈ A ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ↔ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 38 : wff = anbi12i (step 25, step 37) |- ( ( ∀ z ∈ A ¬ z ⁻¹ R z ∧ ∀ z ∈ A ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ↔ ( ∀ x ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 39 : wff = bitr2i (step 16, step 38) |- ( ( ∀ x ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ z ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 40 : wff = ralbii (step 39) |- ( ∀ x ∈ A ( ∀ x ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∈ A ∀ z ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 41 : wff = ralcom () |- ( ∀ x ∈ A ∀ z ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ↔ ∀ z ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 42 : wff = bitri (step 40, step 41) |- ( ∀ x ∈ A ( ∀ x ∈ A ¬ x R x ∧ ∀ z ∈ A ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ z ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 43 : wff = bitri (step 15, step 42) |- ( ∀ x ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ z ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 44 : wff = ralbii (step 43) |- ( ∀ y ∈ A ∀ x ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ y ∈ A ∀ z ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 45 : wff = ralcom () |- ( ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ y ∈ A ∀ x ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 46 : wff = ralcom () |- ( ∀ z ∈ A ∀ y ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ↔ ∀ y ∈ A ∀ z ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 47 : wff = 3bitr4i (step 44, step 45, step 46) |- ( ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ z ∈ A ∀ y ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 48 : wff = df-po () |- ( R Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 49 : wff = df-po () |- ( ⁻¹ R Po A ↔ ∀ z ∈ A ∀ y ∈ A ∀ x ∈ A ( ¬ z ⁻¹ R z ∧ ( ( z ⁻¹ R y ∧ y ⁻¹ R x ) → z ⁻¹ R x ) ) ) ;;
	step 50 : wff = 3bitr4i (step 47, step 48, step 49) |- ( R Po A ↔ ⁻¹ R Po A ) ;;
	qed prop 1 = step 50 ;;
}

/*The converse of a strict order relation is a strict order relation.
       (Contributed by NM, 15-Jun-2005.) */

theorem cnvso (A : class, R : class) disjointed(x y A, x y R) {
	prop 1 : wff = |- ( R Or A ↔ ⁻¹ R Or A ) ;;
}

proof of cnvso {
	var x : set, y : set;;
	step 1 : wff = cnvpo () |- ( R Po A ↔ ⁻¹ R Po A ) ;;
	step 2 : wff = ralcom () |- ( ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ↔ ∀ y ∈ A ∀ x ∈ A ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = brcnv (step 3, step 4) |- ( y ⁻¹ R x ↔ x R y ) ;;
	step 6 : wff = equcom () |- ( y = x ↔ x = y ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = brcnv (step 7, step 8) |- ( x ⁻¹ R y ↔ y R x ) ;;
	step 10 : wff = 3orbi123i (step 5, step 6, step 9) |- ( ( y ⁻¹ R x ∨ y = x ∨ x ⁻¹ R y ) ↔ ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 11 : wff = 2ralbii (step 10) |- ( ∀ y ∈ A ∀ x ∈ A ( y ⁻¹ R x ∨ y = x ∨ x ⁻¹ R y ) ↔ ∀ y ∈ A ∀ x ∈ A ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 12 : wff = bitr4i (step 2, step 11) |- ( ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ↔ ∀ y ∈ A ∀ x ∈ A ( y ⁻¹ R x ∨ y = x ∨ x ⁻¹ R y ) ) ;;
	step 13 : wff = anbi12i (step 1, step 12) |- ( ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ↔ ( ⁻¹ R Po A ∧ ∀ y ∈ A ∀ x ∈ A ( y ⁻¹ R x ∨ y = x ∨ x ⁻¹ R y ) ) ) ;;
	step 14 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 15 : wff = df-so () |- ( ⁻¹ R Or A ↔ ( ⁻¹ R Po A ∧ ∀ y ∈ A ∀ x ∈ A ( y ⁻¹ R x ∨ y = x ∨ x ⁻¹ R y ) ) ) ;;
	step 16 : wff = 3bitr4i (step 13, step 14, step 15) |- ( R Or A ↔ ⁻¹ R Or A ) ;;
	qed prop 1 = step 16 ;;
}

/*The composition of two sets is a set.  (Contributed by NM,
     19-Mar-1998.) */

theorem coexg (A : class, B : class, V : class, W : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( A ∘ B ) ∈ _V ) ;;
}

proof of coexg {
	step 1 : wff = relco () |- Rel ( A ∘ B ) ;;
	step 2 : wff = relssdmrn () |- ( Rel ( A ∘ B ) → ( A ∘ B ) ⊆ ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ) ;;
	step 3 : wff = dmcoss () |- dom ( A ∘ B ) ⊆ dom B ;;
	step 4 : wff = rncoss () |- ran ( A ∘ B ) ⊆ ran A ;;
	step 5 : wff = xpss12 () |- ( ( dom ( A ∘ B ) ⊆ dom B ∧ ran ( A ∘ B ) ⊆ ran A ) → ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ⊆ ( dom B × ran A ) ) ;;
	step 6 : wff = mp2an (step 3, step 4, step 5) |- ( dom ( A ∘ B ) × ran ( A ∘ B ) ) ⊆ ( dom B × ran A ) ;;
	step 7 : wff = syl6ss (step 2, step 6) |- ( Rel ( A ∘ B ) → ( A ∘ B ) ⊆ ( dom B × ran A ) ) ;;
	step 8 : wff = ax-mp (step 1, step 7) |- ( A ∘ B ) ⊆ ( dom B × ran A ) ;;
	step 9 : wff = dmexg () |- ( B ∈ W → dom B ∈ _V ) ;;
	step 10 : wff = rnexg () |- ( A ∈ V → ran A ∈ _V ) ;;
	step 11 : wff = xpexg () |- ( ( dom B ∈ _V ∧ ran A ∈ _V ) → ( dom B × ran A ) ∈ _V ) ;;
	step 12 : wff = syl2anr (step 9, step 10, step 11) |- ( ( A ∈ V ∧ B ∈ W ) → ( dom B × ran A ) ∈ _V ) ;;
	step 13 : wff = ssexg () |- ( ( ( A ∘ B ) ⊆ ( dom B × ran A ) ∧ ( dom B × ran A ) ∈ _V ) → ( A ∘ B ) ∈ _V ) ;;
	step 14 : wff = sylancr (step 8, step 12, step 13) |- ( ( A ∈ V ∧ B ∈ W ) → ( A ∘ B ) ∈ _V ) ;;
	qed prop 1 = step 14 ;;
}

/*The composition of two sets is a set.  (Contributed by NM,
       15-Dec-2003.) */

theorem coex (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∘ B ) ∈ _V ;;
}

proof of coex {
	step 1 : wff = coexg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A ∘ B ) ∈ _V ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A ∘ B ) ∈ _V ;;
	qed prop 1 = step 2 ;;
}


