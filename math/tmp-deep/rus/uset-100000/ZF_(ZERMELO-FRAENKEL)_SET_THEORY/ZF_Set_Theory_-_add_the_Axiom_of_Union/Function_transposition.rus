import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/First_and_second_members_of_an_ordered_pair.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Function transposition

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

constant {
	symbol tpos ;;
}

/* Function transposition */

/* The transposition of a function. */

rule ctpos (F : class) {
	term : class = # tpos F ;;
}

/* Define the transposition of a function, which is a function
       ` G = tpos F ` satisfying ` G ( x , y ) = F ( y , x ) ` .  (Contributed
       by Mario Carneiro, 10-Sep-2015.) */

definition df-tpos (x : set, F : class) disjointed(F x) {
	defiendum : class = # tpos F ;;
	definiens : class = # ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Subset theorem for transposition.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem tposss (F : class, G : class) disjointed(x F, x G) {
	prop 1 : wff = |- ( F ⊆ G → tpos F ⊆ tpos G ) ;;
}

proof of tposss {
	var x : set;;
	step 1 : wff = coss1 () |- ( F ⊆ G → ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( G ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 2 : wff = resss () |- ( ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) ⊆ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 3 : wff = dmss () |- ( F ⊆ G → dom F ⊆ dom G ) ;;
	step 4 : wff = cnvss () |- ( dom F ⊆ dom G → ⁻¹ dom F ⊆ ⁻¹ dom G ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( F ⊆ G → ⁻¹ dom F ⊆ ⁻¹ dom G ) ;;
	step 6 : wff = unss1 () |- ( ⁻¹ dom F ⊆ ⁻¹ dom G → ( ⁻¹ dom F ∪ { ∅ } ) ⊆ ( ⁻¹ dom G ∪ { ∅ } ) ) ;;
	step 7 : wff = resmpt () |- ( ( ⁻¹ dom F ∪ { ∅ } ) ⊆ ( ⁻¹ dom G ∪ { ∅ } ) → ( ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 8 : wff = 3syl (step 5, step 6, step 7) |- ( F ⊆ G → ( ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 9 : wff = sseq1d (step 8) |- ( F ⊆ G → ( ( ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) ⊆ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↔ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 10 : wff = mpbii (step 2, step 9) |- ( F ⊆ G → ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 11 : wff = coss2 () |- ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) → ( G ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( G ∘ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( F ⊆ G → ( G ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( G ∘ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 13 : wff = sstrd (step 1, step 12) |- ( F ⊆ G → ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( G ∘ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 14 : wff = df-tpos () |- tpos F = ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 15 : wff = df-tpos () |- tpos G = ( G ∘ ( x ∈ ( ⁻¹ dom G ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 16 : wff = 3sstr4g (step 13, step 14, step 15) |- ( F ⊆ G → tpos F ⊆ tpos G ) ;;
	qed prop 1 = step 16 ;;
}

/* Equality theorem for transposition.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem tposeq (F : class, G : class)  {
	prop 1 : wff = |- ( F = G → tpos F = tpos G ) ;;
}

proof of tposeq {
	step 1 : wff = eqimss () |- ( F = G → F ⊆ G ) ;;
	step 2 : wff = tposss () |- ( F ⊆ G → tpos F ⊆ tpos G ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( F = G → tpos F ⊆ tpos G ) ;;
	step 4 : wff = eqimss2 () |- ( F = G → G ⊆ F ) ;;
	step 5 : wff = tposss () |- ( G ⊆ F → tpos G ⊆ tpos F ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( F = G → tpos G ⊆ tpos F ) ;;
	step 7 : wff = eqssd (step 3, step 6) |- ( F = G → tpos F = tpos G ) ;;
	qed prop 1 = step 7 ;;
}

/* Equality theorem for transposition.  (Contributed by Mario Carneiro,
         7-Jan-2017.) */

theorem tposeqd (ph : wff, F : class, G : class)  {
	hyp 1 : wff = |- ( ph → F = G ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → tpos F = tpos G ) ;;
}

proof of tposeqd {
	step 1 : wff = tposeq () |- ( F = G → tpos F = tpos G ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → tpos F = tpos G ) ;;
	qed prop 1 = step 2 ;;
}

/* The transposition is a subset of a cross product.  (Contributed by Mario
       Carneiro, 12-Jan-2017.) */

theorem tposssxp (F : class) disjointed(x F) {
	prop 1 : wff = |- tpos F ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ;;
}

proof of tposssxp {
	var x : set;;
	step 1 : wff = df-tpos () |- tpos F = ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 2 : wff = cossxp () |- ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) × ran F ) ;;
	step 3 : wff = eqsstri (step 1, step 2) |- tpos F ⊆ ( dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) × ran F ) ;;
	step 4 : wff = eqid () |- ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 5 : wff = dmmptss (step 4) |- dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( ⁻¹ dom F ∪ { ∅ } ) ;;
	step 6 : wff = xpss1 () |- ( dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( ⁻¹ dom F ∪ { ∅ } ) → ( dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) × ran F ) ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ) ;;
	step 7 : wff = ax-mp (step 5, step 6) |- ( dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) × ran F ) ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ;;
	step 8 : wff = sstri (step 3, step 7) |- tpos F ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ;;
	qed prop 1 = step 8 ;;
}

/* The transposition is a relation.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem reltpos (F : class)  {
	prop 1 : wff = |- Rel tpos F ;;
}

proof of reltpos {
	step 1 : wff = tposssxp () |- tpos F ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ;;
	step 2 : wff = relxp () |- Rel ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ;;
	step 3 : wff = relss () |- ( tpos F ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) → ( Rel ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) → Rel tpos F ) ) ;;
	step 4 : wff = mp2 (step 1, step 2, step 3) |- Rel tpos F ;;
	qed prop 1 = step 4 ;;
}

/* Value of the transposition at a pair ` <. A , B >. ` .  (Contributed by
       Mario Carneiro, 10-Sep-2015.) */

theorem brtpos2 (A : class, B : class, F : class, V : class) disjointed(x y A, x y B, x y F) {
	prop 1 : wff = |- ( B ∈ V → ( A tpos F B ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ) ;;
}

proof of brtpos2 {
	var x : set, y : set;;
	step 1 : wff = reltpos () |- Rel tpos F ;;
	step 2 : wff = brrelexi (step 1) |- ( A tpos F B → A ∈ _V ) ;;
	step 3 : wff = a1i (step 2) |- ( B ∈ V → ( A tpos F B → A ∈ _V ) ) ;;
	step 4 : wff = elex () |- ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) → A ∈ _V ) ;;
	step 5 : wff = adantr (step 4) |- ( ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) → A ∈ _V ) ;;
	step 6 : wff = a1i (step 5) |- ( B ∈ V → ( ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) → A ∈ _V ) ) ;;
	step 7 : wff = df-tpos () |- tpos F = ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 8 : wff = breqi (step 7) |- ( A tpos F B ↔ A ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) B ) ;;
	step 9 : wff = brcog () |- ( ( A ∈ _V ∧ B ∈ V ) → ( A ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) B ↔ ∃ y ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ∧ y F B ) ) ) ;;
	step 10 : wff = syl5bb (step 8, step 9) |- ( ( A ∈ _V ∧ B ∈ V ) → ( A tpos F B ↔ ∃ y ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ∧ y F B ) ) ) ;;
	step 11 : wff = funmpt () |- Fun ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 12 : wff = funbrfv2b () |- ( Fun ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) → ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ↔ ( A ∈ dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ∧ ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) = y ) ) ) ;;
	step 13 : wff = ax-mp (step 11, step 12) |- ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ↔ ( A ∈ dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ∧ ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) = y ) ) ;;
	step 14 : wff = snex () |- { x } ∈ _V ;;
	step 15 : wff = cnvex (step 14) |- ⁻¹ { x } ∈ _V ;;
	step 16 : wff = uniex (step 15) |- ⋃ ⁻¹ { x } ∈ _V ;;
	step 17 : wff = eqid () |- ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 18 : wff = dmmpti (step 16, step 17) |- dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) = ( ⁻¹ dom F ∪ { ∅ } ) ;;
	step 19 : wff = eleq2i (step 18) |- ( A ∈ dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↔ A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ;;
	step 20 : wff = eqcom () |- ( ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) = y ↔ y = ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) ) ;;
	step 21 : wff = anbi12i (step 19, step 20) |- ( ( A ∈ dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ∧ ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) = y ) ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y = ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) ) ) ;;
	step 22 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 23 : wff = cnveqd (step 22) |- ( x = A → ⁻¹ { x } = ⁻¹ { A } ) ;;
	step 24 : wff = unieqd (step 23) |- ( x = A → ⋃ ⁻¹ { x } = ⋃ ⁻¹ { A } ) ;;
	step 25 : wff = eqid () |- ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 26 : wff = snex () |- { A } ∈ _V ;;
	step 27 : wff = cnvex (step 26) |- ⁻¹ { A } ∈ _V ;;
	step 28 : wff = uniex (step 27) |- ⋃ ⁻¹ { A } ∈ _V ;;
	step 29 : wff = fvmpt (step 24, step 25, step 28) |- ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) → ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) = ⋃ ⁻¹ { A } ) ;;
	step 30 : wff = eqeq2d (step 29) |- ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) → ( y = ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) ↔ y = ⋃ ⁻¹ { A } ) ) ;;
	step 31 : wff = pm5.32i (step 30) |- ( ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y = ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) ) ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y = ⋃ ⁻¹ { A } ) ) ;;
	step 32 : wff = bitri (step 21, step 31) |- ( ( A ∈ dom ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ∧ ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ` A ) = y ) ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y = ⋃ ⁻¹ { A } ) ) ;;
	step 33 : wff = bitri (step 13, step 32) |- ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y = ⋃ ⁻¹ { A } ) ) ;;
	step 34 : wff = ancom () |- ( ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y = ⋃ ⁻¹ { A } ) ↔ ( y = ⋃ ⁻¹ { A } ∧ A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ) ;;
	step 35 : wff = bitri (step 33, step 34) |- ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ↔ ( y = ⋃ ⁻¹ { A } ∧ A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ) ;;
	step 36 : wff = anbi1i (step 35) |- ( ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ∧ y F B ) ↔ ( ( y = ⋃ ⁻¹ { A } ∧ A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ∧ y F B ) ) ;;
	step 37 : wff = anass () |- ( ( ( y = ⋃ ⁻¹ { A } ∧ A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ∧ y F B ) ↔ ( y = ⋃ ⁻¹ { A } ∧ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y F B ) ) ) ;;
	step 38 : wff = bitri (step 36, step 37) |- ( ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ∧ y F B ) ↔ ( y = ⋃ ⁻¹ { A } ∧ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y F B ) ) ) ;;
	step 39 : wff = exbii (step 38) |- ( ∃ y ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ∧ y F B ) ↔ ∃ y ( y = ⋃ ⁻¹ { A } ∧ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y F B ) ) ) ;;
	step 40 : wff = snex () |- { A } ∈ _V ;;
	step 41 : wff = cnvex (step 40) |- ⁻¹ { A } ∈ _V ;;
	step 42 : wff = uniex (step 41) |- ⋃ ⁻¹ { A } ∈ _V ;;
	step 43 : wff = breq1 () |- ( y = ⋃ ⁻¹ { A } → ( y F B ↔ ⋃ ⁻¹ { A } F B ) ) ;;
	step 44 : wff = anbi2d (step 43) |- ( y = ⋃ ⁻¹ { A } → ( ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y F B ) ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ) ;;
	step 45 : wff = ceqsexv (step 42, step 44) |- ( ∃ y ( y = ⋃ ⁻¹ { A } ∧ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ y F B ) ) ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ;;
	step 46 : wff = bitri (step 39, step 45) |- ( ∃ y ( A ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) y ∧ y F B ) ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ;;
	step 47 : wff = syl6bb (step 10, step 46) |- ( ( A ∈ _V ∧ B ∈ V ) → ( A tpos F B ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ) ;;
	step 48 : wff = expcom (step 47) |- ( B ∈ V → ( A ∈ _V → ( A tpos F B ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ) ) ;;
	step 49 : wff = pm5.21ndd (step 3, step 6, step 48) |- ( B ∈ V → ( A tpos F B ↔ ( A ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { A } F B ) ) ) ;;
	qed prop 1 = step 49 ;;
}

/* The behavior of ` tpos ` when the left argument is the empty set (which
       is not an ordered pair but is the "default" value of an ordered pair
       when the arguments are proper classes).  This allows us to eliminate
       sethood hypotheses on ` A , B ` in ~ brtpos .  (Contributed by Mario
       Carneiro, 10-Sep-2015.) */

theorem brtpos0 (A : class, F : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ( ∅ tpos F A ↔ ∅ F A ) ) ;;
}

proof of brtpos0 {
	step 1 : wff = brtpos2 () |- ( A ∈ V → ( ∅ tpos F A ↔ ( ∅ ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { ∅ } F A ) ) ) ;;
	step 2 : wff = ssun2 () |- { ∅ } ⊆ ( ⁻¹ dom F ∪ { ∅ } ) ;;
	step 3 : wff = 0ex () |- ∅ ∈ _V ;;
	step 4 : wff = snid (step 3) |- ∅ ∈ { ∅ } ;;
	step 5 : wff = sselii (step 2, step 4) |- ∅ ∈ ( ⁻¹ dom F ∪ { ∅ } ) ;;
	step 6 : wff = biantrur (step 5) |- ( ⋃ ⁻¹ { ∅ } F A ↔ ( ∅ ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { ∅ } F A ) ) ;;
	step 7 : wff = cnvsn0 () |- ⁻¹ { ∅ } = ∅ ;;
	step 8 : wff = unieqi (step 7) |- ⋃ ⁻¹ { ∅ } = ⋃ ∅ ;;
	step 9 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 10 : wff = eqtri (step 8, step 9) |- ⋃ ⁻¹ { ∅ } = ∅ ;;
	step 11 : wff = breq1i (step 10) |- ( ⋃ ⁻¹ { ∅ } F A ↔ ∅ F A ) ;;
	step 12 : wff = bitr3i (step 6, step 11) |- ( ( ∅ ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { ∅ } F A ) ↔ ∅ F A ) ;;
	step 13 : wff = syl6bb (step 1, step 12) |- ( A ∈ V → ( ∅ tpos F A ↔ ∅ F A ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Necessary and sufficient condition for ` dom tpos F ` to be a relation.
       (Contributed by Mario Carneiro, 10-Sep-2015.) */

theorem reldmtpos (F : class) disjointed(x y, x y, x y F) {
	prop 1 : wff = |- ( Rel dom tpos F ↔ ¬ ∅ ∈ dom F ) ;;
}

proof of reldmtpos {
	var x : set, y : set;;
	step 1 : wff = 0ex () |- ∅ ∈ _V ;;
	step 2 : wff = eldm (step 1) |- ( ∅ ∈ dom F ↔ ∃ y ∅ F y ) ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = brtpos0 () |- ( y ∈ _V → ( ∅ tpos F y ↔ ∅ F y ) ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- ( ∅ tpos F y ↔ ∅ F y ) ;;
	step 6 : wff = 0nelxp () |- ¬ ∅ ∈ ( _V × _V ) ;;
	step 7 : wff = df-rel () |- ( Rel dom tpos F ↔ dom tpos F ⊆ ( _V × _V ) ) ;;
	step 8 : wff = ssel () |- ( dom tpos F ⊆ ( _V × _V ) → ( ∅ ∈ dom tpos F → ∅ ∈ ( _V × _V ) ) ) ;;
	step 9 : wff = sylbi (step 7, step 8) |- ( Rel dom tpos F → ( ∅ ∈ dom tpos F → ∅ ∈ ( _V × _V ) ) ) ;;
	step 10 : wff = mtoi (step 6, step 9) |- ( Rel dom tpos F → ¬ ∅ ∈ dom tpos F ) ;;
	step 11 : wff = 0ex () |- ∅ ∈ _V ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = breldm (step 11, step 12) |- ( ∅ tpos F y → ∅ ∈ dom tpos F ) ;;
	step 14 : wff = nsyl3 (step 10, step 13) |- ( ∅ tpos F y → ¬ Rel dom tpos F ) ;;
	step 15 : wff = sylbir (step 5, step 14) |- ( ∅ F y → ¬ Rel dom tpos F ) ;;
	step 16 : wff = exlimiv (step 15) |- ( ∃ y ∅ F y → ¬ Rel dom tpos F ) ;;
	step 17 : wff = sylbi (step 2, step 16) |- ( ∅ ∈ dom F → ¬ Rel dom tpos F ) ;;
	step 18 : wff = con2i (step 17) |- ( Rel dom tpos F → ¬ ∅ ∈ dom F ) ;;
	step 19 : wff = vex () |- x ∈ _V ;;
	step 20 : wff = eldm (step 19) |- ( x ∈ dom tpos F ↔ ∃ y x tpos F y ) ;;
	step 21 : wff = relcnv () |- Rel ⁻¹ dom F ;;
	step 22 : wff = df-rel () |- ( Rel ⁻¹ dom F ↔ ⁻¹ dom F ⊆ ( _V × _V ) ) ;;
	step 23 : wff = mpbi (step 21, step 22) |- ⁻¹ dom F ⊆ ( _V × _V ) ;;
	step 24 : wff = sseli (step 23) |- ( x ∈ ⁻¹ dom F → x ∈ ( _V × _V ) ) ;;
	step 25 : wff = a1i (step 24) |- ( ( ¬ ∅ ∈ dom F ∧ x tpos F y ) → ( x ∈ ⁻¹ dom F → x ∈ ( _V × _V ) ) ) ;;
	step 26 : wff = elsni () |- ( x ∈ { ∅ } → x = ∅ ) ;;
	step 27 : wff = breq1d (step 26) |- ( x ∈ { ∅ } → ( x tpos F y ↔ ∅ tpos F y ) ) ;;
	step 28 : wff = vex () |- y ∈ _V ;;
	step 29 : wff = brtpos0 () |- ( y ∈ _V → ( ∅ tpos F y ↔ ∅ F y ) ) ;;
	step 30 : wff = ax-mp (step 28, step 29) |- ( ∅ tpos F y ↔ ∅ F y ) ;;
	step 31 : wff = 0ex () |- ∅ ∈ _V ;;
	step 32 : wff = vex () |- y ∈ _V ;;
	step 33 : wff = breldm (step 31, step 32) |- ( ∅ F y → ∅ ∈ dom F ) ;;
	step 34 : wff = pm2.24d (step 33) |- ( ∅ F y → ( ¬ ∅ ∈ dom F → x ∈ ( _V × _V ) ) ) ;;
	step 35 : wff = sylbi (step 30, step 34) |- ( ∅ tpos F y → ( ¬ ∅ ∈ dom F → x ∈ ( _V × _V ) ) ) ;;
	step 36 : wff = syl6bi (step 27, step 35) |- ( x ∈ { ∅ } → ( x tpos F y → ( ¬ ∅ ∈ dom F → x ∈ ( _V × _V ) ) ) ) ;;
	step 37 : wff = com3l (step 36) |- ( x tpos F y → ( ¬ ∅ ∈ dom F → ( x ∈ { ∅ } → x ∈ ( _V × _V ) ) ) ) ;;
	step 38 : wff = impcom (step 37) |- ( ( ¬ ∅ ∈ dom F ∧ x tpos F y ) → ( x ∈ { ∅ } → x ∈ ( _V × _V ) ) ) ;;
	step 39 : wff = vex () |- y ∈ _V ;;
	step 40 : wff = brtpos2 () |- ( y ∈ _V → ( x tpos F y ↔ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { x } F y ) ) ) ;;
	step 41 : wff = ax-mp (step 39, step 40) |- ( x tpos F y ↔ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { x } F y ) ) ;;
	step 42 : wff = simplbi (step 41) |- ( x tpos F y → x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ;;
	step 43 : wff = elun () |- ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↔ ( x ∈ ⁻¹ dom F ∨ x ∈ { ∅ } ) ) ;;
	step 44 : wff = sylib (step 42, step 43) |- ( x tpos F y → ( x ∈ ⁻¹ dom F ∨ x ∈ { ∅ } ) ) ;;
	step 45 : wff = adantl (step 44) |- ( ( ¬ ∅ ∈ dom F ∧ x tpos F y ) → ( x ∈ ⁻¹ dom F ∨ x ∈ { ∅ } ) ) ;;
	step 46 : wff = mpjaod (step 25, step 38, step 45) |- ( ( ¬ ∅ ∈ dom F ∧ x tpos F y ) → x ∈ ( _V × _V ) ) ;;
	step 47 : wff = ex (step 46) |- ( ¬ ∅ ∈ dom F → ( x tpos F y → x ∈ ( _V × _V ) ) ) ;;
	step 48 : wff = exlimdv (step 47) |- ( ¬ ∅ ∈ dom F → ( ∃ y x tpos F y → x ∈ ( _V × _V ) ) ) ;;
	step 49 : wff = syl5bi (step 20, step 48) |- ( ¬ ∅ ∈ dom F → ( x ∈ dom tpos F → x ∈ ( _V × _V ) ) ) ;;
	step 50 : wff = ssrdv (step 49) |- ( ¬ ∅ ∈ dom F → dom tpos F ⊆ ( _V × _V ) ) ;;
	step 51 : wff = df-rel () |- ( Rel dom tpos F ↔ dom tpos F ⊆ ( _V × _V ) ) ;;
	step 52 : wff = sylibr (step 50, step 51) |- ( ¬ ∅ ∈ dom F → Rel dom tpos F ) ;;
	step 53 : wff = impbii (step 18, step 52) |- ( Rel dom tpos F ↔ ¬ ∅ ∈ dom F ) ;;
	qed prop 1 = step 53 ;;
}

/* The transposition swaps arguments of a three-parameter relation.
       (Contributed by Mario Carneiro, 10-Sep-2015.) */

theorem brtpos (A : class, B : class, C : class, F : class, V : class)  {
	prop 1 : wff = |- ( C ∈ V → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
}

proof of brtpos {
	step 1 : wff = brtpos2 () |- ( C ∈ V → ( 〈 A , B 〉 tpos F C ↔ ( 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { 〈 A , B 〉 } F C ) ) ) ;;
	step 2 : wff = adantr (step 1) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 A , B 〉 tpos F C ↔ ( 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { 〈 A , B 〉 } F C ) ) ) ;;
	step 3 : wff = opex () |- 〈 B , A 〉 ∈ _V ;;
	step 4 : wff = breldmg () |- ( ( 〈 B , A 〉 ∈ _V ∧ C ∈ V ∧ 〈 B , A 〉 F C ) → 〈 B , A 〉 ∈ dom F ) ;;
	step 5 : wff = 3expia (step 4) |- ( ( 〈 B , A 〉 ∈ _V ∧ C ∈ V ) → ( 〈 B , A 〉 F C → 〈 B , A 〉 ∈ dom F ) ) ;;
	step 6 : wff = mpan (step 3, step 5) |- ( C ∈ V → ( 〈 B , A 〉 F C → 〈 B , A 〉 ∈ dom F ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 B , A 〉 F C → 〈 B , A 〉 ∈ dom F ) ) ;;
	step 8 : wff = opelcnvg () |- ( ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 ∈ ⁻¹ dom F ↔ 〈 B , A 〉 ∈ dom F ) ) ;;
	step 9 : wff = adantl (step 8) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 A , B 〉 ∈ ⁻¹ dom F ↔ 〈 B , A 〉 ∈ dom F ) ) ;;
	step 10 : wff = sylibrd (step 7, step 9) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 B , A 〉 F C → 〈 A , B 〉 ∈ ⁻¹ dom F ) ) ;;
	step 11 : wff = elun1 () |- ( 〈 A , B 〉 ∈ ⁻¹ dom F → 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ;;
	step 12 : wff = syl6 (step 10, step 11) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 B , A 〉 F C → 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ) ;;
	step 13 : wff = pm4.71rd (step 12) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 B , A 〉 F C ↔ ( 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ 〈 B , A 〉 F C ) ) ) ;;
	step 14 : wff = opswap () |- ⋃ ⁻¹ { 〈 A , B 〉 } = 〈 B , A 〉 ;;
	step 15 : wff = breq1i (step 14) |- ( ⋃ ⁻¹ { 〈 A , B 〉 } F C ↔ 〈 B , A 〉 F C ) ;;
	step 16 : wff = anbi2i (step 15) |- ( ( 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { 〈 A , B 〉 } F C ) ↔ ( 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ 〈 B , A 〉 F C ) ) ;;
	step 17 : wff = syl6bbr (step 13, step 16) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 B , A 〉 F C ↔ ( 〈 A , B 〉 ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { 〈 A , B 〉 } F C ) ) ) ;;
	step 18 : wff = bitr4d (step 2, step 17) |- ( ( C ∈ V ∧ ( A ∈ _V ∧ B ∈ _V ) ) → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
	step 19 : wff = ex (step 18) |- ( C ∈ V → ( ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ) ;;
	step 20 : wff = brtpos0 () |- ( C ∈ V → ( ∅ tpos F C ↔ ∅ F C ) ) ;;
	step 21 : wff = opprc () |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → 〈 A , B 〉 = ∅ ) ;;
	step 22 : wff = breq1d (step 21) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 tpos F C ↔ ∅ tpos F C ) ) ;;
	step 23 : wff = ancom () |- ( ( A ∈ _V ∧ B ∈ _V ) ↔ ( B ∈ _V ∧ A ∈ _V ) ) ;;
	step 24 : wff = opprc () |- ( ¬ ( B ∈ _V ∧ A ∈ _V ) → 〈 B , A 〉 = ∅ ) ;;
	step 25 : wff = breq1d (step 24) |- ( ¬ ( B ∈ _V ∧ A ∈ _V ) → ( 〈 B , A 〉 F C ↔ ∅ F C ) ) ;;
	step 26 : wff = sylnbi (step 23, step 25) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( 〈 B , A 〉 F C ↔ ∅ F C ) ) ;;
	step 27 : wff = bibi12d (step 22, step 26) |- ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ↔ ( ∅ tpos F C ↔ ∅ F C ) ) ) ;;
	step 28 : wff = syl5ibrcom (step 20, step 27) |- ( C ∈ V → ( ¬ ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ) ;;
	step 29 : wff = pm2.61d (step 19, step 28) |- ( C ∈ V → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
	qed prop 1 = step 29 ;;
}

/* The transposition swaps the first two elements in a collection of
       ordered triples.  (Contributed by Mario Carneiro, 1-Dec-2014.) */

theorem ottpos (A : class, B : class, C : class, F : class, V : class)  {
	prop 1 : wff = |- ( C ∈ V → ( 〈 A , B , C 〉 ∈ tpos F ↔ 〈 B , A , C 〉 ∈ F ) ) ;;
}

proof of ottpos {
	step 1 : wff = brtpos () |- ( C ∈ V → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
	step 2 : wff = df-br () |- ( 〈 A , B 〉 tpos F C ↔ 〈 〈 A , B 〉 , C 〉 ∈ tpos F ) ;;
	step 3 : wff = df-br () |- ( 〈 B , A 〉 F C ↔ 〈 〈 B , A 〉 , C 〉 ∈ F ) ;;
	step 4 : wff = 3bitr3g (step 1, step 2, step 3) |- ( C ∈ V → ( 〈 〈 A , B 〉 , C 〉 ∈ tpos F ↔ 〈 〈 B , A 〉 , C 〉 ∈ F ) ) ;;
	step 5 : wff = df-ot () |- 〈 A , B , C 〉 = 〈 〈 A , B 〉 , C 〉 ;;
	step 6 : wff = eleq1i (step 5) |- ( 〈 A , B , C 〉 ∈ tpos F ↔ 〈 〈 A , B 〉 , C 〉 ∈ tpos F ) ;;
	step 7 : wff = df-ot () |- 〈 B , A , C 〉 = 〈 〈 B , A 〉 , C 〉 ;;
	step 8 : wff = eleq1i (step 7) |- ( 〈 B , A , C 〉 ∈ F ↔ 〈 〈 B , A 〉 , C 〉 ∈ F ) ;;
	step 9 : wff = 3bitr4g (step 4, step 6, step 8) |- ( C ∈ V → ( 〈 A , B , C 〉 ∈ tpos F ↔ 〈 B , A , C 〉 ∈ F ) ) ;;
	qed prop 1 = step 9 ;;
}

/* The transposition swaps arguments of a three-parameter relation.
       (Contributed by Mario Carneiro, 3-Nov-2015.) */

theorem relbrtpos (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( Rel F → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
}

proof of relbrtpos {
	step 1 : wff = reltpos () |- Rel tpos F ;;
	step 2 : wff = a1i (step 1) |- ( Rel F → Rel tpos F ) ;;
	step 3 : wff = brrelex2 () |- ( ( Rel tpos F ∧ 〈 A , B 〉 tpos F C ) → C ∈ _V ) ;;
	step 4 : wff = sylan (step 2, step 3) |- ( ( Rel F ∧ 〈 A , B 〉 tpos F C ) → C ∈ _V ) ;;
	step 5 : wff = brrelex2 () |- ( ( Rel F ∧ 〈 B , A 〉 F C ) → C ∈ _V ) ;;
	step 6 : wff = brtpos () |- ( C ∈ _V → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
	step 7 : wff = pm5.21nd (step 4, step 5, step 6) |- ( Rel F → ( 〈 A , B 〉 tpos F C ↔ 〈 B , A 〉 F C ) ) ;;
	qed prop 1 = step 7 ;;
}

/* The domain of ` tpos F ` when ` dom F ` is a relation.  (Contributed by
       Mario Carneiro, 10-Sep-2015.) */

theorem dmtpos (F : class) disjointed(x y, x y, x y z F) {
	prop 1 : wff = |- ( Rel dom F → dom tpos F = ⁻¹ dom F ) ;;
}

proof of dmtpos {
	var x : set, y : set, z : set;;
	step 1 : wff = 0nelxp () |- ¬ ∅ ∈ ( _V × _V ) ;;
	step 2 : wff = ssel () |- ( dom F ⊆ ( _V × _V ) → ( ∅ ∈ dom F → ∅ ∈ ( _V × _V ) ) ) ;;
	step 3 : wff = mtoi (step 1, step 2) |- ( dom F ⊆ ( _V × _V ) → ¬ ∅ ∈ dom F ) ;;
	step 4 : wff = df-rel () |- ( Rel dom F ↔ dom F ⊆ ( _V × _V ) ) ;;
	step 5 : wff = reldmtpos () |- ( Rel dom tpos F ↔ ¬ ∅ ∈ dom F ) ;;
	step 6 : wff = 3imtr4i (step 3, step 4, step 5) |- ( Rel dom F → Rel dom tpos F ) ;;
	step 7 : wff = relcnv () |- Rel ⁻¹ dom F ;;
	step 8 : wff = jctir (step 6, step 7) |- ( Rel dom F → ( Rel dom tpos F ∧ Rel ⁻¹ dom F ) ) ;;
	step 9 : wff = vex () |- z ∈ _V ;;
	step 10 : wff = brtpos () |- ( z ∈ _V → ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 11 : wff = mp1i (step 9, step 10) |- ( Rel dom F → ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 12 : wff = exbidv (step 11) |- ( Rel dom F → ( ∃ z 〈 x , y 〉 tpos F z ↔ ∃ z 〈 y , x 〉 F z ) ) ;;
	step 13 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 14 : wff = eldm (step 13) |- ( 〈 x , y 〉 ∈ dom tpos F ↔ ∃ z 〈 x , y 〉 tpos F z ) ;;
	step 15 : wff = vex () |- x ∈ _V ;;
	step 16 : wff = vex () |- y ∈ _V ;;
	step 17 : wff = opelcnv (step 15, step 16) |- ( 〈 x , y 〉 ∈ ⁻¹ dom F ↔ 〈 y , x 〉 ∈ dom F ) ;;
	step 18 : wff = opex () |- 〈 y , x 〉 ∈ _V ;;
	step 19 : wff = eldm (step 18) |- ( 〈 y , x 〉 ∈ dom F ↔ ∃ z 〈 y , x 〉 F z ) ;;
	step 20 : wff = bitri (step 17, step 19) |- ( 〈 x , y 〉 ∈ ⁻¹ dom F ↔ ∃ z 〈 y , x 〉 F z ) ;;
	step 21 : wff = 3bitr4g (step 12, step 14, step 20) |- ( Rel dom F → ( 〈 x , y 〉 ∈ dom tpos F ↔ 〈 x , y 〉 ∈ ⁻¹ dom F ) ) ;;
	step 22 : wff = eqrelrdv2 (step 21) |- ( ( ( Rel dom tpos F ∧ Rel ⁻¹ dom F ) ∧ Rel dom F ) → dom tpos F = ⁻¹ dom F ) ;;
	step 23 : wff = mpancom (step 8, step 22) |- ( Rel dom F → dom tpos F = ⁻¹ dom F ) ;;
	qed prop 1 = step 23 ;;
}

/* The range of ` tpos F ` when ` dom F ` is a relation.  (Contributed by
       Mario Carneiro, 10-Sep-2015.) */

theorem rntpos (F : class) disjointed(x y, x y, w x y z F) {
	prop 1 : wff = |- ( Rel dom F → ran tpos F = ran F ) ;;
}

proof of rntpos {
	var x : set, y : set, z : set, w : set;;
	step 1 : wff = vex () |- z ∈ _V ;;
	step 2 : wff = elrn (step 1) |- ( z ∈ ran tpos F ↔ ∃ w w tpos F z ) ;;
	step 3 : wff = vex () |- w ∈ _V ;;
	step 4 : wff = vex () |- z ∈ _V ;;
	step 5 : wff = breldm (step 3, step 4) |- ( w tpos F z → w ∈ dom tpos F ) ;;
	step 6 : wff = dmtpos () |- ( Rel dom F → dom tpos F = ⁻¹ dom F ) ;;
	step 7 : wff = eleq2d (step 6) |- ( Rel dom F → ( w ∈ dom tpos F ↔ w ∈ ⁻¹ dom F ) ) ;;
	step 8 : wff = syl5ib (step 5, step 7) |- ( Rel dom F → ( w tpos F z → w ∈ ⁻¹ dom F ) ) ;;
	step 9 : wff = relcnv () |- Rel ⁻¹ dom F ;;
	step 10 : wff = elrel () |- ( ( Rel ⁻¹ dom F ∧ w ∈ ⁻¹ dom F ) → ∃ x ∃ y w = 〈 x , y 〉 ) ;;
	step 11 : wff = mpan (step 9, step 10) |- ( w ∈ ⁻¹ dom F → ∃ x ∃ y w = 〈 x , y 〉 ) ;;
	step 12 : wff = syl6 (step 8, step 11) |- ( Rel dom F → ( w tpos F z → ∃ x ∃ y w = 〈 x , y 〉 ) ) ;;
	step 13 : wff = breq1 () |- ( w = 〈 x , y 〉 → ( w tpos F z ↔ 〈 x , y 〉 tpos F z ) ) ;;
	step 14 : wff = vex () |- z ∈ _V ;;
	step 15 : wff = brtpos () |- ( z ∈ _V → ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 16 : wff = ax-mp (step 14, step 15) |- ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ;;
	step 17 : wff = syl6bb (step 13, step 16) |- ( w = 〈 x , y 〉 → ( w tpos F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 18 : wff = opex () |- 〈 y , x 〉 ∈ _V ;;
	step 19 : wff = vex () |- z ∈ _V ;;
	step 20 : wff = brelrn (step 18, step 19) |- ( 〈 y , x 〉 F z → z ∈ ran F ) ;;
	step 21 : wff = syl6bi (step 17, step 20) |- ( w = 〈 x , y 〉 → ( w tpos F z → z ∈ ran F ) ) ;;
	step 22 : wff = exlimivv (step 21) |- ( ∃ x ∃ y w = 〈 x , y 〉 → ( w tpos F z → z ∈ ran F ) ) ;;
	step 23 : wff = syli (step 12, step 22) |- ( Rel dom F → ( w tpos F z → z ∈ ran F ) ) ;;
	step 24 : wff = exlimdv (step 23) |- ( Rel dom F → ( ∃ w w tpos F z → z ∈ ran F ) ) ;;
	step 25 : wff = syl5bi (step 2, step 24) |- ( Rel dom F → ( z ∈ ran tpos F → z ∈ ran F ) ) ;;
	step 26 : wff = vex () |- z ∈ _V ;;
	step 27 : wff = elrn (step 26) |- ( z ∈ ran F ↔ ∃ w w F z ) ;;
	step 28 : wff = vex () |- w ∈ _V ;;
	step 29 : wff = vex () |- z ∈ _V ;;
	step 30 : wff = breldm (step 28, step 29) |- ( w F z → w ∈ dom F ) ;;
	step 31 : wff = elrel () |- ( ( Rel dom F ∧ w ∈ dom F ) → ∃ y ∃ x w = 〈 y , x 〉 ) ;;
	step 32 : wff = ex (step 31) |- ( Rel dom F → ( w ∈ dom F → ∃ y ∃ x w = 〈 y , x 〉 ) ) ;;
	step 33 : wff = syl5 (step 30, step 32) |- ( Rel dom F → ( w F z → ∃ y ∃ x w = 〈 y , x 〉 ) ) ;;
	step 34 : wff = breq1 () |- ( w = 〈 y , x 〉 → ( w F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 35 : wff = vex () |- z ∈ _V ;;
	step 36 : wff = brtpos () |- ( z ∈ _V → ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 37 : wff = ax-mp (step 35, step 36) |- ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ;;
	step 38 : wff = syl6bbr (step 34, step 37) |- ( w = 〈 y , x 〉 → ( w F z ↔ 〈 x , y 〉 tpos F z ) ) ;;
	step 39 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 40 : wff = vex () |- z ∈ _V ;;
	step 41 : wff = brelrn (step 39, step 40) |- ( 〈 x , y 〉 tpos F z → z ∈ ran tpos F ) ;;
	step 42 : wff = syl6bi (step 38, step 41) |- ( w = 〈 y , x 〉 → ( w F z → z ∈ ran tpos F ) ) ;;
	step 43 : wff = exlimivv (step 42) |- ( ∃ y ∃ x w = 〈 y , x 〉 → ( w F z → z ∈ ran tpos F ) ) ;;
	step 44 : wff = syli (step 33, step 43) |- ( Rel dom F → ( w F z → z ∈ ran tpos F ) ) ;;
	step 45 : wff = exlimdv (step 44) |- ( Rel dom F → ( ∃ w w F z → z ∈ ran tpos F ) ) ;;
	step 46 : wff = syl5bi (step 27, step 45) |- ( Rel dom F → ( z ∈ ran F → z ∈ ran tpos F ) ) ;;
	step 47 : wff = impbid (step 25, step 46) |- ( Rel dom F → ( z ∈ ran tpos F ↔ z ∈ ran F ) ) ;;
	step 48 : wff = eqrdv (step 47) |- ( Rel dom F → ran tpos F = ran F ) ;;
	qed prop 1 = step 48 ;;
}

/* The transposition of a set is a set.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem tposexg (F : class, V : class)  {
	prop 1 : wff = |- ( F ∈ V → tpos F ∈ _V ) ;;
}

proof of tposexg {
	step 1 : wff = tposssxp () |- tpos F ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ;;
	step 2 : wff = dmexg () |- ( F ∈ V → dom F ∈ _V ) ;;
	step 3 : wff = cnvexg () |- ( dom F ∈ _V → ⁻¹ dom F ∈ _V ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( F ∈ V → ⁻¹ dom F ∈ _V ) ;;
	step 5 : wff = snex () |- { ∅ } ∈ _V ;;
	step 6 : wff = unexg () |- ( ( ⁻¹ dom F ∈ _V ∧ { ∅ } ∈ _V ) → ( ⁻¹ dom F ∪ { ∅ } ) ∈ _V ) ;;
	step 7 : wff = sylancl (step 4, step 5, step 6) |- ( F ∈ V → ( ⁻¹ dom F ∪ { ∅ } ) ∈ _V ) ;;
	step 8 : wff = rnexg () |- ( F ∈ V → ran F ∈ _V ) ;;
	step 9 : wff = xpexg () |- ( ( ( ⁻¹ dom F ∪ { ∅ } ) ∈ _V ∧ ran F ∈ _V ) → ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ∈ _V ) ;;
	step 10 : wff = syl2anc (step 7, step 8, step 9) |- ( F ∈ V → ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ∈ _V ) ;;
	step 11 : wff = ssexg () |- ( ( tpos F ⊆ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ∧ ( ( ⁻¹ dom F ∪ { ∅ } ) × ran F ) ∈ _V ) → tpos F ∈ _V ) ;;
	step 12 : wff = sylancr (step 1, step 10, step 11) |- ( F ∈ V → tpos F ∈ _V ) ;;
	qed prop 1 = step 12 ;;
}

/* The transposition swaps the arguments in a two-argument function.  When
       ` F ` is a matrix, which is to say a function from
       ` ( 1 ... m ) X. ( 1 ... n ) ` to ` RR ` or some ring, ` tpos F ` is the
       transposition of ` F ` , which is where the name comes from.
       (Contributed by Mario Carneiro, 10-Sep-2015.) */

theorem ovtpos (A : class, B : class, F : class) disjointed(y A, y B, y F) {
	prop 1 : wff = |- ( A tpos F B ) = ( B F A ) ;;
}

proof of ovtpos {
	var y : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = brtpos () |- ( y ∈ _V → ( 〈 A , B 〉 tpos F y ↔ 〈 B , A 〉 F y ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( 〈 A , B 〉 tpos F y ↔ 〈 B , A 〉 F y ) ;;
	step 4 : wff = iotabii (step 3) |- ( iota y 〈 A , B 〉 tpos F y ) = ( iota y 〈 B , A 〉 F y ) ;;
	step 5 : wff = df-fv () |- ( tpos F ` 〈 A , B 〉 ) = ( iota y 〈 A , B 〉 tpos F y ) ;;
	step 6 : wff = df-fv () |- ( F ` 〈 B , A 〉 ) = ( iota y 〈 B , A 〉 F y ) ;;
	step 7 : wff = 3eqtr4i (step 4, step 5, step 6) |- ( tpos F ` 〈 A , B 〉 ) = ( F ` 〈 B , A 〉 ) ;;
	step 8 : wff = df-ov () |- ( A tpos F B ) = ( tpos F ` 〈 A , B 〉 ) ;;
	step 9 : wff = df-ov () |- ( B F A ) = ( F ` 〈 B , A 〉 ) ;;
	step 10 : wff = 3eqtr4i (step 7, step 8, step 9) |- ( A tpos F B ) = ( B F A ) ;;
	qed prop 1 = step 10 ;;
}

/* The transposition of a function is a function.  (Contributed by Mario
       Carneiro, 10-Sep-2015.) */

theorem tposfun (F : class) disjointed(x F) {
	prop 1 : wff = |- ( Fun F → Fun tpos F ) ;;
}

proof of tposfun {
	var x : set;;
	step 1 : wff = funmpt () |- Fun ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 2 : wff = funco () |- ( ( Fun F ∧ Fun ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) → Fun ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( Fun F → Fun ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 4 : wff = df-tpos () |- tpos F = ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 5 : wff = funeqi (step 4) |- ( Fun tpos F ↔ Fun ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 6 : wff = sylibr (step 3, step 5) |- ( Fun F → Fun tpos F ) ;;
	qed prop 1 = step 6 ;;
}

/* Alternate definition of ` tpos ` when ` F ` has relational domain.
       (Contributed by Mario Carneiro, 10-Sep-2015.) */

theorem dftpos2 (x : set, F : class) disjointed(x F) {
	prop 1 : wff = |- ( Rel dom F → tpos F = ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) ) ;;
}

proof of dftpos2 {
	step 1 : wff = dmtpos () |- ( Rel dom F → dom tpos F = ⁻¹ dom F ) ;;
	step 2 : wff = reseq2d (step 1) |- ( Rel dom F → ( tpos F ↾ dom tpos F ) = ( tpos F ↾ ⁻¹ dom F ) ) ;;
	step 3 : wff = reltpos () |- Rel tpos F ;;
	step 4 : wff = resdm () |- ( Rel tpos F → ( tpos F ↾ dom tpos F ) = tpos F ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- ( tpos F ↾ dom tpos F ) = tpos F ;;
	step 6 : wff = df-tpos () |- tpos F = ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 7 : wff = reseq1i (step 6) |- ( tpos F ↾ ⁻¹ dom F ) = ( ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ↾ ⁻¹ dom F ) ;;
	step 8 : wff = resco () |- ( ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ↾ ⁻¹ dom F ) = ( F ∘ ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ⁻¹ dom F ) ) ;;
	step 9 : wff = ssun1 () |- ⁻¹ dom F ⊆ ( ⁻¹ dom F ∪ { ∅ } ) ;;
	step 10 : wff = resmpt () |- ( ⁻¹ dom F ⊆ ( ⁻¹ dom F ∪ { ∅ } ) → ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ⁻¹ dom F ) = ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 11 : wff = ax-mp (step 9, step 10) |- ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ⁻¹ dom F ) = ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ;;
	step 12 : wff = coeq2i (step 11) |- ( F ∘ ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ⁻¹ dom F ) ) = ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 13 : wff = 3eqtri (step 7, step 8, step 12) |- ( tpos F ↾ ⁻¹ dom F ) = ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 14 : wff = 3eqtr3g (step 2, step 5, step 13) |- ( Rel dom F → tpos F = ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	qed prop 1 = step 14 ;;
}

/* Alternate definition of ` tpos ` when ` F ` has relational domain.
       Compare ~ df-cnv .  (Contributed by Mario Carneiro, 10-Sep-2015.) */

theorem dftpos3 (x : set, y : set, z : set, F : class) disjointed(x y, x y, w x y z F) {
	prop 1 : wff = |- ( Rel dom F → tpos F = { 〈 〈 x , y 〉 , z 〉 | 〈 y , x 〉 F z } ) ;;
}

proof of dftpos3 {
	var w : set;;
	step 1 : wff = relcnv () |- Rel ⁻¹ dom F ;;
	step 2 : wff = dmtpos () |- ( Rel dom F → dom tpos F = ⁻¹ dom F ) ;;
	step 3 : wff = releqd (step 2) |- ( Rel dom F → ( Rel dom tpos F ↔ Rel ⁻¹ dom F ) ) ;;
	step 4 : wff = mpbiri (step 1, step 3) |- ( Rel dom F → Rel dom tpos F ) ;;
	step 5 : wff = reltpos () |- Rel tpos F ;;
	step 6 : wff = jctil (step 4, step 5) |- ( Rel dom F → ( Rel tpos F ∧ Rel dom tpos F ) ) ;;
	step 7 : wff = relrelss () |- ( ( Rel tpos F ∧ Rel dom tpos F ) ↔ tpos F ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 8 : wff = sylib (step 6, step 7) |- ( Rel dom F → tpos F ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 9 : wff = sseld (step 8) |- ( Rel dom F → ( w ∈ tpos F → w ∈ ( ( _V × _V ) × _V ) ) ) ;;
	step 10 : wff = elvvv () |- ( w ∈ ( ( _V × _V ) × _V ) ↔ ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 ) ;;
	step 11 : wff = syl6ib (step 9, step 10) |- ( Rel dom F → ( w ∈ tpos F → ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 12 : wff = pm4.71rd (step 11) |- ( Rel dom F → ( w ∈ tpos F ↔ ( ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 ∧ w ∈ tpos F ) ) ) ;;
	step 13 : wff = 19.41vvv () |- ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ w ∈ tpos F ) ↔ ( ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 ∧ w ∈ tpos F ) ) ;;
	step 14 : wff = eleq1 () |- ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ tpos F ↔ 〈 〈 x , y 〉 , z 〉 ∈ tpos F ) ) ;;
	step 15 : wff = df-br () |- ( 〈 x , y 〉 tpos F z ↔ 〈 〈 x , y 〉 , z 〉 ∈ tpos F ) ;;
	step 16 : wff = vex () |- z ∈ _V ;;
	step 17 : wff = brtpos () |- ( z ∈ _V → ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ) ;;
	step 18 : wff = ax-mp (step 16, step 17) |- ( 〈 x , y 〉 tpos F z ↔ 〈 y , x 〉 F z ) ;;
	step 19 : wff = bitr3i (step 15, step 18) |- ( 〈 〈 x , y 〉 , z 〉 ∈ tpos F ↔ 〈 y , x 〉 F z ) ;;
	step 20 : wff = syl6bb (step 14, step 19) |- ( w = 〈 〈 x , y 〉 , z 〉 → ( w ∈ tpos F ↔ 〈 y , x 〉 F z ) ) ;;
	step 21 : wff = pm5.32i (step 20) |- ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ w ∈ tpos F ) ↔ ( w = 〈 〈 x , y 〉 , z 〉 ∧ 〈 y , x 〉 F z ) ) ;;
	step 22 : wff = 3exbii (step 21) |- ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ w ∈ tpos F ) ↔ ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ 〈 y , x 〉 F z ) ) ;;
	step 23 : wff = bitr3i (step 13, step 22) |- ( ( ∃ x ∃ y ∃ z w = 〈 〈 x , y 〉 , z 〉 ∧ w ∈ tpos F ) ↔ ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ 〈 y , x 〉 F z ) ) ;;
	step 24 : wff = syl6bb (step 12, step 23) |- ( Rel dom F → ( w ∈ tpos F ↔ ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ 〈 y , x 〉 F z ) ) ) ;;
	step 25 : wff = abbi2dv (step 24) |- ( Rel dom F → tpos F = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ 〈 y , x 〉 F z ) } ) ;;
	step 26 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | 〈 y , x 〉 F z } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ 〈 y , x 〉 F z ) } ;;
	step 27 : wff = syl6eqr (step 25, step 26) |- ( Rel dom F → tpos F = { 〈 〈 x , y 〉 , z 〉 | 〈 y , x 〉 F z } ) ;;
	qed prop 1 = step 27 ;;
}

/* Alternate definition of ` tpos ` .  (Contributed by Mario Carneiro,
       4-Oct-2015.) */

theorem dftpos4 (x : set, F : class) disjointed(x y, x y, w x y z F) {
	prop 1 : wff = |- tpos F = ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
}

proof of dftpos4 {
	var y : set, z : set, w : set;;
	step 1 : wff = df-tpos () |- tpos F = ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ dom F ;;
	step 3 : wff = df-rel () |- ( Rel ⁻¹ dom F ↔ ⁻¹ dom F ⊆ ( _V × _V ) ) ;;
	step 4 : wff = mpbi (step 2, step 3) |- ⁻¹ dom F ⊆ ( _V × _V ) ;;
	step 5 : wff = unss1 () |- ( ⁻¹ dom F ⊆ ( _V × _V ) → ( ⁻¹ dom F ∪ { ∅ } ) ⊆ ( ( _V × _V ) ∪ { ∅ } ) ) ;;
	step 6 : wff = resmpt () |- ( ( ⁻¹ dom F ∪ { ∅ } ) ⊆ ( ( _V × _V ) ∪ { ∅ } ) → ( ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 7 : wff = mp2b (step 4, step 5, step 6) |- ( ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) = ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 8 : wff = resss () |- ( ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ↾ ( ⁻¹ dom F ∪ { ∅ } ) ) ⊆ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 9 : wff = eqsstr3i (step 7, step 8) |- ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ;;
	step 10 : wff = coss2 () |- ( ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ⊆ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) → ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 11 : wff = ax-mp (step 9, step 10) |- ( F ∘ ( x ∈ ( ⁻¹ dom F ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 12 : wff = eqsstri (step 1, step 11) |- tpos F ⊆ ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 13 : wff = relco () |- Rel ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = vex () |- z ∈ _V ;;
	step 16 : wff = opelco (step 14, step 15) |- ( 〈 y , z 〉 ∈ ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ↔ ∃ w ( y ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) w ∧ w F z ) ) ;;
	step 17 : wff = vex () |- y ∈ _V ;;
	step 18 : wff = vex () |- w ∈ _V ;;
	step 19 : wff = eleq1 () |- ( x = y → ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↔ y ∈ ( ( _V × _V ) ∪ { ∅ } ) ) ) ;;
	step 20 : wff = sneq () |- ( x = y → { x } = { y } ) ;;
	step 21 : wff = cnveqd (step 20) |- ( x = y → ⁻¹ { x } = ⁻¹ { y } ) ;;
	step 22 : wff = unieqd (step 21) |- ( x = y → ⋃ ⁻¹ { x } = ⋃ ⁻¹ { y } ) ;;
	step 23 : wff = eqeq2d (step 22) |- ( x = y → ( z = ⋃ ⁻¹ { x } ↔ z = ⋃ ⁻¹ { y } ) ) ;;
	step 24 : wff = anbi12d (step 19, step 23) |- ( x = y → ( ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ z = ⋃ ⁻¹ { x } ) ↔ ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ z = ⋃ ⁻¹ { y } ) ) ) ;;
	step 25 : wff = eqeq1 () |- ( z = w → ( z = ⋃ ⁻¹ { y } ↔ w = ⋃ ⁻¹ { y } ) ) ;;
	step 26 : wff = anbi2d (step 25) |- ( z = w → ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ z = ⋃ ⁻¹ { y } ) ↔ ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ) ) ;;
	step 27 : wff = df-mpt () |- ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) = { 〈 x , z 〉 | ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ z = ⋃ ⁻¹ { x } ) } ;;
	step 28 : wff = brab (step 17, step 18, step 24, step 26, step 27) |- ( y ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) w ↔ ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ) ;;
	step 29 : wff = simplr () |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → w = ⋃ ⁻¹ { y } ) ;;
	step 30 : wff = vex () |- w ∈ _V ;;
	step 31 : wff = vex () |- z ∈ _V ;;
	step 32 : wff = breldm (step 30, step 31) |- ( w F z → w ∈ dom F ) ;;
	step 33 : wff = adantl (step 32) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → w ∈ dom F ) ;;
	step 34 : wff = eqeltrrd (step 29, step 33) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → ⋃ ⁻¹ { y } ∈ dom F ) ;;
	step 35 : wff = elvv () |- ( y ∈ ( _V × _V ) ↔ ∃ z ∃ w y = 〈 z , w 〉 ) ;;
	step 36 : wff = opswap () |- ⋃ ⁻¹ { 〈 z , w 〉 } = 〈 w , z 〉 ;;
	step 37 : wff = eleq1i (step 36) |- ( ⋃ ⁻¹ { 〈 z , w 〉 } ∈ dom F ↔ 〈 w , z 〉 ∈ dom F ) ;;
	step 38 : wff = vex () |- z ∈ _V ;;
	step 39 : wff = vex () |- w ∈ _V ;;
	step 40 : wff = opelcnv (step 38, step 39) |- ( 〈 z , w 〉 ∈ ⁻¹ dom F ↔ 〈 w , z 〉 ∈ dom F ) ;;
	step 41 : wff = bitr4i (step 37, step 40) |- ( ⋃ ⁻¹ { 〈 z , w 〉 } ∈ dom F ↔ 〈 z , w 〉 ∈ ⁻¹ dom F ) ;;
	step 42 : wff = sneq () |- ( y = 〈 z , w 〉 → { y } = { 〈 z , w 〉 } ) ;;
	step 43 : wff = cnveqd (step 42) |- ( y = 〈 z , w 〉 → ⁻¹ { y } = ⁻¹ { 〈 z , w 〉 } ) ;;
	step 44 : wff = unieqd (step 43) |- ( y = 〈 z , w 〉 → ⋃ ⁻¹ { y } = ⋃ ⁻¹ { 〈 z , w 〉 } ) ;;
	step 45 : wff = eleq1d (step 44) |- ( y = 〈 z , w 〉 → ( ⋃ ⁻¹ { y } ∈ dom F ↔ ⋃ ⁻¹ { 〈 z , w 〉 } ∈ dom F ) ) ;;
	step 46 : wff = eleq1 () |- ( y = 〈 z , w 〉 → ( y ∈ ⁻¹ dom F ↔ 〈 z , w 〉 ∈ ⁻¹ dom F ) ) ;;
	step 47 : wff = bibi12d (step 45, step 46) |- ( y = 〈 z , w 〉 → ( ( ⋃ ⁻¹ { y } ∈ dom F ↔ y ∈ ⁻¹ dom F ) ↔ ( ⋃ ⁻¹ { 〈 z , w 〉 } ∈ dom F ↔ 〈 z , w 〉 ∈ ⁻¹ dom F ) ) ) ;;
	step 48 : wff = mpbiri (step 41, step 47) |- ( y = 〈 z , w 〉 → ( ⋃ ⁻¹ { y } ∈ dom F ↔ y ∈ ⁻¹ dom F ) ) ;;
	step 49 : wff = exlimivv (step 48) |- ( ∃ z ∃ w y = 〈 z , w 〉 → ( ⋃ ⁻¹ { y } ∈ dom F ↔ y ∈ ⁻¹ dom F ) ) ;;
	step 50 : wff = sylbi (step 35, step 49) |- ( y ∈ ( _V × _V ) → ( ⋃ ⁻¹ { y } ∈ dom F ↔ y ∈ ⁻¹ dom F ) ) ;;
	step 51 : wff = biimpcd (step 50) |- ( ⋃ ⁻¹ { y } ∈ dom F → ( y ∈ ( _V × _V ) → y ∈ ⁻¹ dom F ) ) ;;
	step 52 : wff = elun1 () |- ( y ∈ ⁻¹ dom F → y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ;;
	step 53 : wff = syl6 (step 51, step 52) |- ( ⋃ ⁻¹ { y } ∈ dom F → ( y ∈ ( _V × _V ) → y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ) ;;
	step 54 : wff = syl (step 34, step 53) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → ( y ∈ ( _V × _V ) → y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ) ;;
	step 55 : wff = elun2 () |- ( y ∈ { ∅ } → y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ;;
	step 56 : wff = a1i (step 55) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → ( y ∈ { ∅ } → y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ) ;;
	step 57 : wff = simpll () |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → y ∈ ( ( _V × _V ) ∪ { ∅ } ) ) ;;
	step 58 : wff = elun () |- ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ↔ ( y ∈ ( _V × _V ) ∨ y ∈ { ∅ } ) ) ;;
	step 59 : wff = sylib (step 57, step 58) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → ( y ∈ ( _V × _V ) ∨ y ∈ { ∅ } ) ) ;;
	step 60 : wff = mpjaod (step 54, step 56, step 59) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ) ;;
	step 61 : wff = simplr () |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → w = ⋃ ⁻¹ { y } ) ;;
	step 62 : wff = simpr () |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → w F z ) ;;
	step 63 : wff = eqbrtrrd (step 61, step 62) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → ⋃ ⁻¹ { y } F z ) ;;
	step 64 : wff = jca (step 60, step 63) |- ( ( ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ w = ⋃ ⁻¹ { y } ) ∧ w F z ) → ( y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { y } F z ) ) ;;
	step 65 : wff = sylanb (step 28, step 64) |- ( ( y ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) w ∧ w F z ) → ( y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { y } F z ) ) ;;
	step 66 : wff = vex () |- z ∈ _V ;;
	step 67 : wff = brtpos2 () |- ( z ∈ _V → ( y tpos F z ↔ ( y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { y } F z ) ) ) ;;
	step 68 : wff = ax-mp (step 66, step 67) |- ( y tpos F z ↔ ( y ∈ ( ⁻¹ dom F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { y } F z ) ) ;;
	step 69 : wff = sylibr (step 65, step 68) |- ( ( y ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) w ∧ w F z ) → y tpos F z ) ;;
	step 70 : wff = df-br () |- ( y tpos F z ↔ 〈 y , z 〉 ∈ tpos F ) ;;
	step 71 : wff = sylib (step 69, step 70) |- ( ( y ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) w ∧ w F z ) → 〈 y , z 〉 ∈ tpos F ) ;;
	step 72 : wff = exlimiv (step 71) |- ( ∃ w ( y ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) w ∧ w F z ) → 〈 y , z 〉 ∈ tpos F ) ;;
	step 73 : wff = sylbi (step 16, step 72) |- ( 〈 y , z 〉 ∈ ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) → 〈 y , z 〉 ∈ tpos F ) ;;
	step 74 : wff = relssi (step 13, step 73) |- ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ⊆ tpos F ;;
	step 75 : wff = eqssi (step 12, step 74) |- tpos F = ( F ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	qed prop 1 = step 75 ;;
}

/* Value of the double transposition for a general class ` F ` .
       (Contributed by Mario Carneiro, 16-Sep-2015.) */

theorem tpostpos (F : class) disjointed(x y, x y, w x y z F) {
	prop 1 : wff = |- tpos tpos F = ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
}

proof of tpostpos {
	var x : set, y : set, z : set, w : set;;
	step 1 : wff = reltpos () |- Rel tpos tpos F ;;
	step 2 : wff = inss2 () |- ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ;;
	step 3 : wff = relxp () |- Rel ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ;;
	step 4 : wff = relss () |- ( ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) → ( Rel ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) → Rel ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ) ) ;;
	step 5 : wff = mp2 (step 2, step 3, step 4) |- Rel ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	step 6 : wff = relcnv () |- Rel ⁻¹ dom tpos F ;;
	step 7 : wff = df-rel () |- ( Rel ⁻¹ dom tpos F ↔ ⁻¹ dom tpos F ⊆ ( _V × _V ) ) ;;
	step 8 : wff = mpbi (step 6, step 7) |- ⁻¹ dom tpos F ⊆ ( _V × _V ) ;;
	step 9 : wff = simpl () |- ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) → w ∈ ⁻¹ dom tpos F ) ;;
	step 10 : wff = sseldi (step 8, step 9) |- ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) → w ∈ ( _V × _V ) ) ;;
	step 11 : wff = simpr () |- ( ( w F z ∧ w ∈ ( _V × _V ) ) → w ∈ ( _V × _V ) ) ;;
	step 12 : wff = elvv () |- ( w ∈ ( _V × _V ) ↔ ∃ x ∃ y w = 〈 x , y 〉 ) ;;
	step 13 : wff = eleq1 () |- ( w = 〈 x , y 〉 → ( w ∈ ⁻¹ dom tpos F ↔ 〈 x , y 〉 ∈ ⁻¹ dom tpos F ) ) ;;
	step 14 : wff = vex () |- x ∈ _V ;;
	step 15 : wff = vex () |- y ∈ _V ;;
	step 16 : wff = opelcnv (step 14, step 15) |- ( 〈 x , y 〉 ∈ ⁻¹ dom tpos F ↔ 〈 y , x 〉 ∈ dom tpos F ) ;;
	step 17 : wff = syl6bb (step 13, step 16) |- ( w = 〈 x , y 〉 → ( w ∈ ⁻¹ dom tpos F ↔ 〈 y , x 〉 ∈ dom tpos F ) ) ;;
	step 18 : wff = sneq () |- ( w = 〈 x , y 〉 → { w } = { 〈 x , y 〉 } ) ;;
	step 19 : wff = cnveqd (step 18) |- ( w = 〈 x , y 〉 → ⁻¹ { w } = ⁻¹ { 〈 x , y 〉 } ) ;;
	step 20 : wff = unieqd (step 19) |- ( w = 〈 x , y 〉 → ⋃ ⁻¹ { w } = ⋃ ⁻¹ { 〈 x , y 〉 } ) ;;
	step 21 : wff = opswap () |- ⋃ ⁻¹ { 〈 x , y 〉 } = 〈 y , x 〉 ;;
	step 22 : wff = syl6eq (step 20, step 21) |- ( w = 〈 x , y 〉 → ⋃ ⁻¹ { w } = 〈 y , x 〉 ) ;;
	step 23 : wff = breq1d (step 22) |- ( w = 〈 x , y 〉 → ( ⋃ ⁻¹ { w } tpos F z ↔ 〈 y , x 〉 tpos F z ) ) ;;
	step 24 : wff = anbi12d (step 17, step 23) |- ( w = 〈 x , y 〉 → ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( 〈 y , x 〉 ∈ dom tpos F ∧ 〈 y , x 〉 tpos F z ) ) ) ;;
	step 25 : wff = opex () |- 〈 y , x 〉 ∈ _V ;;
	step 26 : wff = vex () |- z ∈ _V ;;
	step 27 : wff = breldm (step 25, step 26) |- ( 〈 y , x 〉 tpos F z → 〈 y , x 〉 ∈ dom tpos F ) ;;
	step 28 : wff = pm4.71ri (step 27) |- ( 〈 y , x 〉 tpos F z ↔ ( 〈 y , x 〉 ∈ dom tpos F ∧ 〈 y , x 〉 tpos F z ) ) ;;
	step 29 : wff = vex () |- z ∈ _V ;;
	step 30 : wff = brtpos () |- ( z ∈ _V → ( 〈 y , x 〉 tpos F z ↔ 〈 x , y 〉 F z ) ) ;;
	step 31 : wff = ax-mp (step 29, step 30) |- ( 〈 y , x 〉 tpos F z ↔ 〈 x , y 〉 F z ) ;;
	step 32 : wff = bitr3i (step 28, step 31) |- ( ( 〈 y , x 〉 ∈ dom tpos F ∧ 〈 y , x 〉 tpos F z ) ↔ 〈 x , y 〉 F z ) ;;
	step 33 : wff = syl6bb (step 24, step 32) |- ( w = 〈 x , y 〉 → ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ 〈 x , y 〉 F z ) ) ;;
	step 34 : wff = breq1 () |- ( w = 〈 x , y 〉 → ( w F z ↔ 〈 x , y 〉 F z ) ) ;;
	step 35 : wff = bitr4d (step 33, step 34) |- ( w = 〈 x , y 〉 → ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ w F z ) ) ;;
	step 36 : wff = exlimivv (step 35) |- ( ∃ x ∃ y w = 〈 x , y 〉 → ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ w F z ) ) ;;
	step 37 : wff = sylbi (step 12, step 36) |- ( w ∈ ( _V × _V ) → ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ w F z ) ) ;;
	step 38 : wff = iba () |- ( w ∈ ( _V × _V ) → ( w F z ↔ ( w F z ∧ w ∈ ( _V × _V ) ) ) ) ;;
	step 39 : wff = bitrd (step 37, step 38) |- ( w ∈ ( _V × _V ) → ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( w F z ∧ w ∈ ( _V × _V ) ) ) ) ;;
	step 40 : wff = pm5.21nii (step 10, step 11, step 39) |- ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( w F z ∧ w ∈ ( _V × _V ) ) ) ;;
	step 41 : wff = elsni () |- ( w ∈ { ∅ } → w = ∅ ) ;;
	step 42 : wff = sneqd (step 41) |- ( w ∈ { ∅ } → { w } = { ∅ } ) ;;
	step 43 : wff = cnveqd (step 42) |- ( w ∈ { ∅ } → ⁻¹ { w } = ⁻¹ { ∅ } ) ;;
	step 44 : wff = cnvsn0 () |- ⁻¹ { ∅ } = ∅ ;;
	step 45 : wff = syl6eq (step 43, step 44) |- ( w ∈ { ∅ } → ⁻¹ { w } = ∅ ) ;;
	step 46 : wff = unieqd (step 45) |- ( w ∈ { ∅ } → ⋃ ⁻¹ { w } = ⋃ ∅ ) ;;
	step 47 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 48 : wff = syl6eq (step 46, step 47) |- ( w ∈ { ∅ } → ⋃ ⁻¹ { w } = ∅ ) ;;
	step 49 : wff = breq1d (step 48) |- ( w ∈ { ∅ } → ( ⋃ ⁻¹ { w } tpos F z ↔ ∅ tpos F z ) ) ;;
	step 50 : wff = vex () |- z ∈ _V ;;
	step 51 : wff = brtpos0 () |- ( z ∈ _V → ( ∅ tpos F z ↔ ∅ F z ) ) ;;
	step 52 : wff = ax-mp (step 50, step 51) |- ( ∅ tpos F z ↔ ∅ F z ) ;;
	step 53 : wff = syl6bb (step 49, step 52) |- ( w ∈ { ∅ } → ( ⋃ ⁻¹ { w } tpos F z ↔ ∅ F z ) ) ;;
	step 54 : wff = elsni () |- ( w ∈ { ∅ } → w = ∅ ) ;;
	step 55 : wff = breq1d (step 54) |- ( w ∈ { ∅ } → ( w F z ↔ ∅ F z ) ) ;;
	step 56 : wff = bitr4d (step 53, step 55) |- ( w ∈ { ∅ } → ( ⋃ ⁻¹ { w } tpos F z ↔ w F z ) ) ;;
	step 57 : wff = pm5.32i (step 56) |- ( ( w ∈ { ∅ } ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( w ∈ { ∅ } ∧ w F z ) ) ;;
	step 58 : wff = ancom () |- ( ( w ∈ { ∅ } ∧ w F z ) ↔ ( w F z ∧ w ∈ { ∅ } ) ) ;;
	step 59 : wff = bitri (step 57, step 58) |- ( ( w ∈ { ∅ } ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( w F z ∧ w ∈ { ∅ } ) ) ;;
	step 60 : wff = orbi12i (step 40, step 59) |- ( ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ∨ ( w ∈ { ∅ } ∧ ⋃ ⁻¹ { w } tpos F z ) ) ↔ ( ( w F z ∧ w ∈ ( _V × _V ) ) ∨ ( w F z ∧ w ∈ { ∅ } ) ) ) ;;
	step 61 : wff = andir () |- ( ( ( w ∈ ⁻¹ dom tpos F ∨ w ∈ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( ( w ∈ ⁻¹ dom tpos F ∧ ⋃ ⁻¹ { w } tpos F z ) ∨ ( w ∈ { ∅ } ∧ ⋃ ⁻¹ { w } tpos F z ) ) ) ;;
	step 62 : wff = andi () |- ( ( w F z ∧ ( w ∈ ( _V × _V ) ∨ w ∈ { ∅ } ) ) ↔ ( ( w F z ∧ w ∈ ( _V × _V ) ) ∨ ( w F z ∧ w ∈ { ∅ } ) ) ) ;;
	step 63 : wff = 3bitr4i (step 60, step 61, step 62) |- ( ( ( w ∈ ⁻¹ dom tpos F ∨ w ∈ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( w F z ∧ ( w ∈ ( _V × _V ) ∨ w ∈ { ∅ } ) ) ) ;;
	step 64 : wff = elun () |- ( w ∈ ( ⁻¹ dom tpos F ∪ { ∅ } ) ↔ ( w ∈ ⁻¹ dom tpos F ∨ w ∈ { ∅ } ) ) ;;
	step 65 : wff = anbi1i (step 64) |- ( ( w ∈ ( ⁻¹ dom tpos F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( ( w ∈ ⁻¹ dom tpos F ∨ w ∈ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ) ;;
	step 66 : wff = vex () |- z ∈ _V ;;
	step 67 : wff = brxp () |- ( w ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) z ↔ ( w ∈ ( ( _V × _V ) ∪ { ∅ } ) ∧ z ∈ _V ) ) ;;
	step 68 : wff = mpbiran2 (step 66, step 67) |- ( w ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) z ↔ w ∈ ( ( _V × _V ) ∪ { ∅ } ) ) ;;
	step 69 : wff = elun () |- ( w ∈ ( ( _V × _V ) ∪ { ∅ } ) ↔ ( w ∈ ( _V × _V ) ∨ w ∈ { ∅ } ) ) ;;
	step 70 : wff = bitri (step 68, step 69) |- ( w ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) z ↔ ( w ∈ ( _V × _V ) ∨ w ∈ { ∅ } ) ) ;;
	step 71 : wff = anbi2i (step 70) |- ( ( w F z ∧ w ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) z ) ↔ ( w F z ∧ ( w ∈ ( _V × _V ) ∨ w ∈ { ∅ } ) ) ) ;;
	step 72 : wff = 3bitr4i (step 63, step 65, step 71) |- ( ( w ∈ ( ⁻¹ dom tpos F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ↔ ( w F z ∧ w ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) z ) ) ;;
	step 73 : wff = vex () |- z ∈ _V ;;
	step 74 : wff = brtpos2 () |- ( z ∈ _V → ( w tpos tpos F z ↔ ( w ∈ ( ⁻¹ dom tpos F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ) ) ;;
	step 75 : wff = ax-mp (step 73, step 74) |- ( w tpos tpos F z ↔ ( w ∈ ( ⁻¹ dom tpos F ∪ { ∅ } ) ∧ ⋃ ⁻¹ { w } tpos F z ) ) ;;
	step 76 : wff = brin () |- ( w ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) z ↔ ( w F z ∧ w ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) z ) ) ;;
	step 77 : wff = 3bitr4i (step 72, step 75, step 76) |- ( w tpos tpos F z ↔ w ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) z ) ;;
	step 78 : wff = eqbrriv (step 1, step 5, step 77) |- tpos tpos F = ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	qed prop 1 = step 78 ;;
}

/* Value of the double transposition for a relation on triples.
       (Contributed by Mario Carneiro, 16-Sep-2015.) */

theorem tpostpos2 (F : class)  {
	prop 1 : wff = |- ( ( Rel F ∧ Rel dom F ) → tpos tpos F = F ) ;;
}

proof of tpostpos2 {
	step 1 : wff = tpostpos () |- tpos tpos F = ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	step 2 : wff = relrelss () |- ( ( Rel F ∧ Rel dom F ) ↔ F ⊆ ( ( _V × _V ) × _V ) ) ;;
	step 3 : wff = ssun1 () |- ( _V × _V ) ⊆ ( ( _V × _V ) ∪ { ∅ } ) ;;
	step 4 : wff = xpss1 () |- ( ( _V × _V ) ⊆ ( ( _V × _V ) ∪ { ∅ } ) → ( ( _V × _V ) × _V ) ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	step 5 : wff = ax-mp (step 3, step 4) |- ( ( _V × _V ) × _V ) ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ;;
	step 6 : wff = sstr () |- ( ( F ⊆ ( ( _V × _V ) × _V ) ∧ ( ( _V × _V ) × _V ) ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) → F ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	step 7 : wff = mpan2 (step 5, step 6) |- ( F ⊆ ( ( _V × _V ) × _V ) → F ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	step 8 : wff = sylbi (step 2, step 7) |- ( ( Rel F ∧ Rel dom F ) → F ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) ;;
	step 9 : wff = df-ss () |- ( F ⊆ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ↔ ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) = F ) ;;
	step 10 : wff = sylib (step 8, step 9) |- ( ( Rel F ∧ Rel dom F ) → ( F ∩ ( ( ( _V × _V ) ∪ { ∅ } ) × _V ) ) = F ) ;;
	step 11 : wff = syl5eq (step 1, step 10) |- ( ( Rel F ∧ Rel dom F ) → tpos tpos F = F ) ;;
	qed prop 1 = step 11 ;;
}

/* The domain of a transposition.  (Contributed by NM, 10-Sep-2015.) */

theorem tposfn2 (A : class, F : class)  {
	prop 1 : wff = |- ( Rel A → ( F Fn A → tpos F Fn ⁻¹ A ) ) ;;
}

proof of tposfn2 {
	step 1 : wff = tposfun () |- ( Fun F → Fun tpos F ) ;;
	step 2 : wff = a1i (step 1) |- ( Rel A → ( Fun F → Fun tpos F ) ) ;;
	step 3 : wff = dmtpos () |- ( Rel dom F → dom tpos F = ⁻¹ dom F ) ;;
	step 4 : wff = a1i (step 3) |- ( dom F = A → ( Rel dom F → dom tpos F = ⁻¹ dom F ) ) ;;
	step 5 : wff = releq () |- ( dom F = A → ( Rel dom F ↔ Rel A ) ) ;;
	step 6 : wff = cnveq () |- ( dom F = A → ⁻¹ dom F = ⁻¹ A ) ;;
	step 7 : wff = eqeq2d (step 6) |- ( dom F = A → ( dom tpos F = ⁻¹ dom F ↔ dom tpos F = ⁻¹ A ) ) ;;
	step 8 : wff = 3imtr3d (step 4, step 5, step 7) |- ( dom F = A → ( Rel A → dom tpos F = ⁻¹ A ) ) ;;
	step 9 : wff = com12 (step 8) |- ( Rel A → ( dom F = A → dom tpos F = ⁻¹ A ) ) ;;
	step 10 : wff = anim12d (step 2, step 9) |- ( Rel A → ( ( Fun F ∧ dom F = A ) → ( Fun tpos F ∧ dom tpos F = ⁻¹ A ) ) ) ;;
	step 11 : wff = df-fn () |- ( F Fn A ↔ ( Fun F ∧ dom F = A ) ) ;;
	step 12 : wff = df-fn () |- ( tpos F Fn ⁻¹ A ↔ ( Fun tpos F ∧ dom tpos F = ⁻¹ A ) ) ;;
	step 13 : wff = 3imtr4g (step 10, step 11, step 12) |- ( Rel A → ( F Fn A → tpos F Fn ⁻¹ A ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Condition for a surjective transposition.  (Contributed by NM,
       10-Sep-2015.) */

theorem tposfo2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( Rel A → ( F : A ↠ B → tpos F : ⁻¹ A ↠ B ) ) ;;
}

proof of tposfo2 {
	step 1 : wff = tposfn2 () |- ( Rel A → ( F Fn A → tpos F Fn ⁻¹ A ) ) ;;
	step 2 : wff = adantrd (step 1) |- ( Rel A → ( ( F Fn A ∧ ran F = B ) → tpos F Fn ⁻¹ A ) ) ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = releqd (step 3) |- ( F Fn A → ( Rel dom F ↔ Rel A ) ) ;;
	step 5 : wff = biimparc (step 4) |- ( ( Rel A ∧ F Fn A ) → Rel dom F ) ;;
	step 6 : wff = rntpos () |- ( Rel dom F → ran tpos F = ran F ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ( Rel A ∧ F Fn A ) → ran tpos F = ran F ) ;;
	step 8 : wff = eqeq1d (step 7) |- ( ( Rel A ∧ F Fn A ) → ( ran tpos F = B ↔ ran F = B ) ) ;;
	step 9 : wff = biimprd (step 8) |- ( ( Rel A ∧ F Fn A ) → ( ran F = B → ran tpos F = B ) ) ;;
	step 10 : wff = expimpd (step 9) |- ( Rel A → ( ( F Fn A ∧ ran F = B ) → ran tpos F = B ) ) ;;
	step 11 : wff = jcad (step 2, step 10) |- ( Rel A → ( ( F Fn A ∧ ran F = B ) → ( tpos F Fn ⁻¹ A ∧ ran tpos F = B ) ) ) ;;
	step 12 : wff = df-fo () |- ( F : A ↠ B ↔ ( F Fn A ∧ ran F = B ) ) ;;
	step 13 : wff = df-fo () |- ( tpos F : ⁻¹ A ↠ B ↔ ( tpos F Fn ⁻¹ A ∧ ran tpos F = B ) ) ;;
	step 14 : wff = 3imtr4g (step 11, step 12, step 13) |- ( Rel A → ( F : A ↠ B → tpos F : ⁻¹ A ↠ B ) ) ;;
	qed prop 1 = step 14 ;;
}

/* The domain and range of a transposition.  (Contributed by NM,
       10-Sep-2015.) */

theorem tposf2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( Rel A → ( F : A ⟶ B → tpos F : ⁻¹ A ⟶ B ) ) ;;
}

proof of tposf2 {
	step 1 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 2 : wff = dffn4 () |- ( F Fn A ↔ F : A ↠ ran F ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( F : A ⟶ B → F : A ↠ ran F ) ;;
	step 4 : wff = tposfo2 () |- ( Rel A → ( F : A ↠ ran F → tpos F : ⁻¹ A ↠ ran F ) ) ;;
	step 5 : wff = syl5 (step 3, step 4) |- ( Rel A → ( F : A ⟶ B → tpos F : ⁻¹ A ↠ ran F ) ) ;;
	step 6 : wff = imp (step 5) |- ( ( Rel A ∧ F : A ⟶ B ) → tpos F : ⁻¹ A ↠ ran F ) ;;
	step 7 : wff = fof () |- ( tpos F : ⁻¹ A ↠ ran F → tpos F : ⁻¹ A ⟶ ran F ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ( Rel A ∧ F : A ⟶ B ) → tpos F : ⁻¹ A ⟶ ran F ) ;;
	step 9 : wff = frn () |- ( F : A ⟶ B → ran F ⊆ B ) ;;
	step 10 : wff = adantl (step 9) |- ( ( Rel A ∧ F : A ⟶ B ) → ran F ⊆ B ) ;;
	step 11 : wff = fss () |- ( ( tpos F : ⁻¹ A ⟶ ran F ∧ ran F ⊆ B ) → tpos F : ⁻¹ A ⟶ B ) ;;
	step 12 : wff = syl2anc (step 8, step 10, step 11) |- ( ( Rel A ∧ F : A ⟶ B ) → tpos F : ⁻¹ A ⟶ B ) ;;
	step 13 : wff = ex (step 12) |- ( Rel A → ( F : A ⟶ B → tpos F : ⁻¹ A ⟶ B ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Condition for an injective transposition.  (Contributed by NM,
       10-Sep-2015.) */

theorem tposf12 (A : class, B : class, F : class) disjointed(x A, x B, x F) {
	prop 1 : wff = |- ( Rel A → ( F : A ↣ B → tpos F : ⁻¹ A ↣ B ) ) ;;
}

proof of tposf12 {
	var x : set;;
	step 1 : wff = simpr () |- ( ( Rel A ∧ F : A ↣ B ) → F : A ↣ B ) ;;
	step 2 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 3 : wff = cnvf1o () |- ( Rel ⁻¹ A → ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ⤖ ⁻¹ ⁻¹ A ) ;;
	step 4 : wff = f1of1 () |- ( ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ⤖ ⁻¹ ⁻¹ A → ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ ⁻¹ ⁻¹ A ) ;;
	step 5 : wff = mp2b (step 2, step 3, step 4) |- ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ ⁻¹ ⁻¹ A ;;
	step 6 : wff = simpl () |- ( ( Rel A ∧ F : A ↣ B ) → Rel A ) ;;
	step 7 : wff = dfrel2 () |- ( Rel A ↔ ⁻¹ ⁻¹ A = A ) ;;
	step 8 : wff = sylib (step 6, step 7) |- ( ( Rel A ∧ F : A ↣ B ) → ⁻¹ ⁻¹ A = A ) ;;
	step 9 : wff = f1eq3 () |- ( ⁻¹ ⁻¹ A = A → ( ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ ⁻¹ ⁻¹ A ↔ ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ( Rel A ∧ F : A ↣ B ) → ( ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ ⁻¹ ⁻¹ A ↔ ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) ) ;;
	step 11 : wff = mpbii (step 5, step 10) |- ( ( Rel A ∧ F : A ↣ B ) → ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) ;;
	step 12 : wff = simpr () |- ( ( Rel A ∧ F : A ↣ B ) → F : A ↣ B ) ;;
	step 13 : wff = f1dm () |- ( F : A ↣ B → dom F = A ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( ( Rel A ∧ F : A ↣ B ) → dom F = A ) ;;
	step 15 : wff = cnveqd (step 14) |- ( ( Rel A ∧ F : A ↣ B ) → ⁻¹ dom F = ⁻¹ A ) ;;
	step 16 : wff = mpteq1 () |- ( ⁻¹ dom F = ⁻¹ A → ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) = ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 17 : wff = f1eq1 () |- ( ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) = ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) → ( ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ↔ ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) ) ;;
	step 18 : wff = 3syl (step 15, step 16, step 17) |- ( ( Rel A ∧ F : A ↣ B ) → ( ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ↔ ( x ∈ ⁻¹ A ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) ) ;;
	step 19 : wff = mpbird (step 11, step 18) |- ( ( Rel A ∧ F : A ↣ B ) → ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) ;;
	step 20 : wff = f1co () |- ( ( F : A ↣ B ∧ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) : ⁻¹ A ↣ A ) → ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) : ⁻¹ A ↣ B ) ;;
	step 21 : wff = syl2anc (step 1, step 19, step 20) |- ( ( Rel A ∧ F : A ↣ B ) → ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) : ⁻¹ A ↣ B ) ;;
	step 22 : wff = f1dm () |- ( F : A ↣ B → dom F = A ) ;;
	step 23 : wff = releqd (step 22) |- ( F : A ↣ B → ( Rel dom F ↔ Rel A ) ) ;;
	step 24 : wff = biimparc (step 23) |- ( ( Rel A ∧ F : A ↣ B ) → Rel dom F ) ;;
	step 25 : wff = dftpos2 () |- ( Rel dom F → tpos F = ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 26 : wff = f1eq1 () |- ( tpos F = ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) → ( tpos F : ⁻¹ A ↣ B ↔ ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) : ⁻¹ A ↣ B ) ) ;;
	step 27 : wff = 3syl (step 24, step 25, step 26) |- ( ( Rel A ∧ F : A ↣ B ) → ( tpos F : ⁻¹ A ↣ B ↔ ( F ∘ ( x ∈ ⁻¹ dom F ↦ ⋃ ⁻¹ { x } ) ) : ⁻¹ A ↣ B ) ) ;;
	step 28 : wff = mpbird (step 21, step 27) |- ( ( Rel A ∧ F : A ↣ B ) → tpos F : ⁻¹ A ↣ B ) ;;
	step 29 : wff = ex (step 28) |- ( Rel A → ( F : A ↣ B → tpos F : ⁻¹ A ↣ B ) ) ;;
	qed prop 1 = step 29 ;;
}

/* Condition of a bijective transposition.  (Contributed by NM,
       10-Sep-2015.) */

theorem tposf1o2 (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( Rel A → ( F : A ⤖ B → tpos F : ⁻¹ A ⤖ B ) ) ;;
}

proof of tposf1o2 {
	step 1 : wff = tposf12 () |- ( Rel A → ( F : A ↣ B → tpos F : ⁻¹ A ↣ B ) ) ;;
	step 2 : wff = tposfo2 () |- ( Rel A → ( F : A ↠ B → tpos F : ⁻¹ A ↠ B ) ) ;;
	step 3 : wff = anim12d (step 1, step 2) |- ( Rel A → ( ( F : A ↣ B ∧ F : A ↠ B ) → ( tpos F : ⁻¹ A ↣ B ∧ tpos F : ⁻¹ A ↠ B ) ) ) ;;
	step 4 : wff = df-f1o () |- ( F : A ⤖ B ↔ ( F : A ↣ B ∧ F : A ↠ B ) ) ;;
	step 5 : wff = df-f1o () |- ( tpos F : ⁻¹ A ⤖ B ↔ ( tpos F : ⁻¹ A ↣ B ∧ tpos F : ⁻¹ A ↠ B ) ) ;;
	step 6 : wff = 3imtr4g (step 3, step 4, step 5) |- ( Rel A → ( F : A ⤖ B → tpos F : ⁻¹ A ⤖ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* The domain and range of a transposition.  (Contributed by NM,
       10-Sep-2015.) */

theorem tposfo (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( F : ( A × B ) ↠ C → tpos F : ( B × A ) ↠ C ) ;;
}

proof of tposfo {
	step 1 : wff = relxp () |- Rel ( A × B ) ;;
	step 2 : wff = tposfo2 () |- ( Rel ( A × B ) → ( F : ( A × B ) ↠ C → tpos F : ⁻¹ ( A × B ) ↠ C ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( F : ( A × B ) ↠ C → tpos F : ⁻¹ ( A × B ) ↠ C ) ;;
	step 4 : wff = cnvxp () |- ⁻¹ ( A × B ) = ( B × A ) ;;
	step 5 : wff = foeq2 () |- ( ⁻¹ ( A × B ) = ( B × A ) → ( tpos F : ⁻¹ ( A × B ) ↠ C ↔ tpos F : ( B × A ) ↠ C ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( tpos F : ⁻¹ ( A × B ) ↠ C ↔ tpos F : ( B × A ) ↠ C ) ;;
	step 7 : wff = sylib (step 3, step 6) |- ( F : ( A × B ) ↠ C → tpos F : ( B × A ) ↠ C ) ;;
	qed prop 1 = step 7 ;;
}

/* The domain and range of a transposition.  (Contributed by NM,
       10-Sep-2015.) */

theorem tposf (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( F : ( A × B ) ⟶ C → tpos F : ( B × A ) ⟶ C ) ;;
}

proof of tposf {
	step 1 : wff = relxp () |- Rel ( A × B ) ;;
	step 2 : wff = tposf2 () |- ( Rel ( A × B ) → ( F : ( A × B ) ⟶ C → tpos F : ⁻¹ ( A × B ) ⟶ C ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( F : ( A × B ) ⟶ C → tpos F : ⁻¹ ( A × B ) ⟶ C ) ;;
	step 4 : wff = cnvxp () |- ⁻¹ ( A × B ) = ( B × A ) ;;
	step 5 : wff = feq2i (step 4) |- ( tpos F : ⁻¹ ( A × B ) ⟶ C ↔ tpos F : ( B × A ) ⟶ C ) ;;
	step 6 : wff = sylib (step 3, step 5) |- ( F : ( A × B ) ⟶ C → tpos F : ( B × A ) ⟶ C ) ;;
	qed prop 1 = step 6 ;;
}

/* Functionality of a transposition.  (Contributed by Mario Carneiro,
       4-Oct-2015.) */

theorem tposfn (A : class, B : class, F : class)  {
	prop 1 : wff = |- ( F Fn ( A × B ) → tpos F Fn ( B × A ) ) ;;
}

proof of tposfn {
	step 1 : wff = tposf () |- ( F : ( A × B ) ⟶ _V → tpos F : ( B × A ) ⟶ _V ) ;;
	step 2 : wff = dffn2 () |- ( F Fn ( A × B ) ↔ F : ( A × B ) ⟶ _V ) ;;
	step 3 : wff = dffn2 () |- ( tpos F Fn ( B × A ) ↔ tpos F : ( B × A ) ⟶ _V ) ;;
	step 4 : wff = 3imtr4i (step 1, step 2, step 3) |- ( F Fn ( A × B ) → tpos F Fn ( B × A ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Transposition of the empty set.  (Contributed by NM, 10-Sep-2015.) */

theorem tpos0 ()  {
	prop 1 : wff = |- tpos ∅ = ∅ ;;
}

proof of tpos0 {
	step 1 : wff = rel0 () |- Rel ∅ ;;
	step 2 : wff = eqid () |- ∅ = ∅ ;;
	step 3 : wff = fn0 () |- ( ∅ Fn ∅ ↔ ∅ = ∅ ) ;;
	step 4 : wff = mpbir (step 2, step 3) |- ∅ Fn ∅ ;;
	step 5 : wff = tposfn2 () |- ( Rel ∅ → ( ∅ Fn ∅ → tpos ∅ Fn ⁻¹ ∅ ) ) ;;
	step 6 : wff = mp2 (step 1, step 4, step 5) |- tpos ∅ Fn ⁻¹ ∅ ;;
	step 7 : wff = cnv0 () |- ⁻¹ ∅ = ∅ ;;
	step 8 : wff = fneq2i (step 7) |- ( tpos ∅ Fn ⁻¹ ∅ ↔ tpos ∅ Fn ∅ ) ;;
	step 9 : wff = mpbi (step 6, step 8) |- tpos ∅ Fn ∅ ;;
	step 10 : wff = fn0 () |- ( tpos ∅ Fn ∅ ↔ tpos ∅ = ∅ ) ;;
	step 11 : wff = mpbi (step 9, step 10) |- tpos ∅ = ∅ ;;
	qed prop 1 = step 11 ;;
}

/* Transposition of a composition.  (Contributed by Mario Carneiro,
       4-Oct-2015.) */

theorem tposco (F : class, G : class) disjointed(x F, x G) {
	prop 1 : wff = |- tpos ( F ∘ G ) = ( F ∘ tpos G ) ;;
}

proof of tposco {
	var x : set;;
	step 1 : wff = coass () |- ( ( F ∘ G ) ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) = ( F ∘ ( G ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 2 : wff = dftpos4 () |- tpos ( F ∘ G ) = ( ( F ∘ G ) ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 3 : wff = dftpos4 () |- tpos G = ( G ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ;;
	step 4 : wff = coeq2i (step 3) |- ( F ∘ tpos G ) = ( F ∘ ( G ∘ ( x ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { x } ) ) ) ;;
	step 5 : wff = 3eqtr4i (step 1, step 2, step 4) |- tpos ( F ∘ G ) = ( F ∘ tpos G ) ;;
	qed prop 1 = step 5 ;;
}

/* Two ways to say a function is symmetric.  (Contributed by Mario
       Carneiro, 4-Oct-2015.) */

theorem tpossym (x : set, y : set, A : class, F : class) disjointed(x y A, x y, x y F) {
	prop 1 : wff = |- ( F Fn ( A × A ) → ( tpos F = F ↔ ∀ x ∈ A ∀ y ∈ A ( x F y ) = ( y F x ) ) ) ;;
}

proof of tpossym {
	step 1 : wff = tposfn () |- ( F Fn ( A × A ) → tpos F Fn ( A × A ) ) ;;
	step 2 : wff = eqfnov2 () |- ( ( tpos F Fn ( A × A ) ∧ F Fn ( A × A ) ) → ( tpos F = F ↔ ∀ x ∈ A ∀ y ∈ A ( x tpos F y ) = ( x F y ) ) ) ;;
	step 3 : wff = mpancom (step 1, step 2) |- ( F Fn ( A × A ) → ( tpos F = F ↔ ∀ x ∈ A ∀ y ∈ A ( x tpos F y ) = ( x F y ) ) ) ;;
	step 4 : wff = eqcom () |- ( ( x tpos F y ) = ( x F y ) ↔ ( x F y ) = ( x tpos F y ) ) ;;
	step 5 : wff = ovtpos () |- ( x tpos F y ) = ( y F x ) ;;
	step 6 : wff = eqeq2i (step 5) |- ( ( x F y ) = ( x tpos F y ) ↔ ( x F y ) = ( y F x ) ) ;;
	step 7 : wff = bitri (step 4, step 6) |- ( ( x tpos F y ) = ( x F y ) ↔ ( x F y ) = ( y F x ) ) ;;
	step 8 : wff = 2ralbii (step 7) |- ( ∀ x ∈ A ∀ y ∈ A ( x tpos F y ) = ( x F y ) ↔ ∀ x ∈ A ∀ y ∈ A ( x F y ) = ( y F x ) ) ;;
	step 9 : wff = syl6bb (step 3, step 8) |- ( F Fn ( A × A ) → ( tpos F = F ↔ ∀ x ∈ A ∀ y ∈ A ( x F y ) = ( y F x ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Equality theorem for transposition.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem tposeqi (F : class, G : class)  {
	hyp 1 : wff = |- F = G ;;
	-----------------------
	prop 1 : wff = |- tpos F = tpos G ;;
}

proof of tposeqi {
	step 1 : wff = tposeq () |- ( F = G → tpos F = tpos G ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- tpos F = tpos G ;;
	qed prop 1 = step 2 ;;
}

/* A transposition is a set.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem tposex (F : class)  {
	hyp 1 : wff = |- F ∈ _V ;;
	-----------------------
	prop 1 : wff = |- tpos F ∈ _V ;;
}

proof of tposex {
	step 1 : wff = tposexg () |- ( F ∈ _V → tpos F ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- tpos F ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/* Hypothesis builder for transposition.  (Contributed by Mario Carneiro,
       10-Sep-2015.) */

theorem nftpos (x : set, F : class) disjointed(x y, y F) {
	hyp 1 : wff = |- F/_ x F ;;
	-----------------------
	prop 1 : wff = |- F/_ x tpos F ;;
}

proof of nftpos {
	var y : set;;
	step 1 : wff = dftpos4 () |- tpos F = ( F ∘ ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { y } ) ) ;;
	step 2 : wff = nfcv () |- F/_ x ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { y } ) ;;
	step 3 : wff = nfco (hyp 1, step 2) |- F/_ x ( F ∘ ( y ∈ ( ( _V × _V ) ∪ { ∅ } ) ↦ ⋃ ⁻¹ { y } ) ) ;;
	step 4 : wff = nfcxfr (step 1, step 3) |- F/_ x tpos F ;;
	qed prop 1 = step 4 ;;
}

/* Transposition of a class of ordered triples.  (Contributed by Mario
       Carneiro, 10-Sep-2015.) */

theorem tposoprab (ph : wff, x : set, y : set, z : set, F : class) disjointed(a b c x y z, a b c ph) {
	hyp 1 : wff = |- F = { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- tpos F = { 〈 〈 y , x 〉 , z 〉 | ph } ;;
}

proof of tposoprab {
	var a : set, b : set, c : set;;
	step 1 : wff = tposeqi (hyp 1) |- tpos F = tpos { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 2 : wff = reldmoprab () |- Rel dom { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 3 : wff = dftpos3 () |- ( Rel dom { 〈 〈 x , y 〉 , z 〉 | ph } → tpos { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 a , b 〉 , c 〉 | 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c } ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- tpos { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 〈 a , b 〉 , c 〉 | 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c } ;;
	step 5 : wff = nfcv () |- F/_ y 〈 b , a 〉 ;;
	step 6 : wff = nfoprab2 () |- F/_ y { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 7 : wff = nfcv () |- F/_ y c ;;
	step 8 : wff = nfbr (step 5, step 6, step 7) |- F/ y 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ;;
	step 9 : wff = nfcv () |- F/_ x 〈 b , a 〉 ;;
	step 10 : wff = nfoprab1 () |- F/_ x { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 11 : wff = nfcv () |- F/_ x c ;;
	step 12 : wff = nfbr (step 9, step 10, step 11) |- F/ x 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ;;
	step 13 : wff = nfv () |- F/ a 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ;;
	step 14 : wff = nfv () |- F/ b 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ;;
	step 15 : wff = opeq12 () |- ( ( b = x ∧ a = y ) → 〈 b , a 〉 = 〈 x , y 〉 ) ;;
	step 16 : wff = ancoms (step 15) |- ( ( a = y ∧ b = x ) → 〈 b , a 〉 = 〈 x , y 〉 ) ;;
	step 17 : wff = breq1d (step 16) |- ( ( a = y ∧ b = x ) → ( 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ↔ 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ) ) ;;
	step 18 : wff = cbvoprab12 (step 8, step 12, step 13, step 14, step 17) |- { 〈 〈 a , b 〉 , c 〉 | 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c } = { 〈 〈 y , x 〉 , c 〉 | 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c } ;;
	step 19 : wff = nfcv () |- F/_ z 〈 x , y 〉 ;;
	step 20 : wff = nfoprab3 () |- F/_ z { 〈 〈 x , y 〉 , z 〉 | ph } ;;
	step 21 : wff = nfcv () |- F/_ z c ;;
	step 22 : wff = nfbr (step 19, step 20, step 21) |- F/ z 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ;;
	step 23 : wff = nfv () |- F/ c ph ;;
	step 24 : wff = breq2 () |- ( c = z → ( 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ↔ 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } z ) ) ;;
	step 25 : wff = df-br () |- ( 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } z ↔ 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ) ;;
	step 26 : wff = oprabid () |- ( 〈 〈 x , y 〉 , z 〉 ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ph ) ;;
	step 27 : wff = bitri (step 25, step 26) |- ( 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } z ↔ ph ) ;;
	step 28 : wff = syl6bb (step 24, step 27) |- ( c = z → ( 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c ↔ ph ) ) ;;
	step 29 : wff = cbvoprab3 (step 22, step 23, step 28) |- { 〈 〈 y , x 〉 , c 〉 | 〈 x , y 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c } = { 〈 〈 y , x 〉 , z 〉 | ph } ;;
	step 30 : wff = eqtri (step 18, step 29) |- { 〈 〈 a , b 〉 , c 〉 | 〈 b , a 〉 { 〈 〈 x , y 〉 , z 〉 | ph } c } = { 〈 〈 y , x 〉 , z 〉 | ph } ;;
	step 31 : wff = 3eqtri (step 1, step 4, step 30) |- tpos F = { 〈 〈 y , x 〉 , z 〉 | ph } ;;
	qed prop 1 = step 31 ;;
}

/* Transposition of a two-argument mapping.  (Contributed by Mario
       Carneiro, 10-Sep-2015.) */

theorem tposmpt2 (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(x y z, z A, z B, z C) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- tpos F = ( y ∈ B , x ∈ A ↦ C ) ;;
}

proof of tposmpt2 {
	var z : set;;
	step 1 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = ancom () |- ( ( x ∈ A ∧ y ∈ B ) ↔ ( y ∈ B ∧ x ∈ A ) ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) ↔ ( ( y ∈ B ∧ x ∈ A ) ∧ z = C ) ) ;;
	step 4 : wff = oprabbii (step 3) |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( y ∈ B ∧ x ∈ A ) ∧ z = C ) } ;;
	step 5 : wff = 3eqtri (hyp 1, step 1, step 4) |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( y ∈ B ∧ x ∈ A ) ∧ z = C ) } ;;
	step 6 : wff = tposoprab (step 5) |- tpos F = { 〈 〈 y , x 〉 , z 〉 | ( ( y ∈ B ∧ x ∈ A ) ∧ z = C ) } ;;
	step 7 : wff = df-mpt2 () |- ( y ∈ B , x ∈ A ↦ C ) = { 〈 〈 y , x 〉 , z 〉 | ( ( y ∈ B ∧ x ∈ A ) ∧ z = C ) } ;;
	step 8 : wff = eqtr4i (step 6, step 7) |- tpos F = ( y ∈ B , x ∈ A ↦ C ) ;;
	qed prop 1 = step 8 ;;
}


