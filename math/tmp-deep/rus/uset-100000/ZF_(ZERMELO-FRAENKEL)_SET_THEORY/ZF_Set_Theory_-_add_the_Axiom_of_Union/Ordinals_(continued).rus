import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Introduce_the_Axiom_of_Union.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Ordinals (continued)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*The class of all ordinal numbers is ordinal.  Proposition 7.12 of
       [TakeutiZaring] p. 38, but without using the Axiom of Regularity.
       (Contributed by NM, 17-May-1994.) */

theorem ordon () disjointed(x y) {
	prop 1 : wff = |- Ord On ;;
}

proof of ordon {
	var x : set, y : set;;
	step 1 : wff = tron () |- Tr On ;;
	step 2 : wff = onfr () |- ğ›œ Fr On ;;
	step 3 : wff = eloni () |- ( x âˆˆ On â†’ Ord x ) ;;
	step 4 : wff = eloni () |- ( y âˆˆ On â†’ Ord y ) ;;
	step 5 : wff = ordtri3or () |- ( ( Ord x âˆ§ Ord y ) â†’ ( x âˆˆ y âˆ¨ x = y âˆ¨ y âˆˆ x ) ) ;;
	step 6 : wff = epel () |- ( x ğ›œ y â†” x âˆˆ y ) ;;
	step 7 : wff = biid () |- ( x = y â†” x = y ) ;;
	step 8 : wff = epel () |- ( y ğ›œ x â†” y âˆˆ x ) ;;
	step 9 : wff = 3orbi123i (step 6, step 7, step 8) |- ( ( x ğ›œ y âˆ¨ x = y âˆ¨ y ğ›œ x ) â†” ( x âˆˆ y âˆ¨ x = y âˆ¨ y âˆˆ x ) ) ;;
	step 10 : wff = sylibr (step 5, step 9) |- ( ( Ord x âˆ§ Ord y ) â†’ ( x ğ›œ y âˆ¨ x = y âˆ¨ y ğ›œ x ) ) ;;
	step 11 : wff = syl2an (step 3, step 4, step 10) |- ( ( x âˆˆ On âˆ§ y âˆˆ On ) â†’ ( x ğ›œ y âˆ¨ x = y âˆ¨ y ğ›œ x ) ) ;;
	step 12 : wff = rgen2a (step 11) |- âˆ€ x âˆˆ On âˆ€ y âˆˆ On ( x ğ›œ y âˆ¨ x = y âˆ¨ y ğ›œ x ) ;;
	step 13 : wff = dfwe2 () |- ( ğ›œ We On â†” ( ğ›œ Fr On âˆ§ âˆ€ x âˆˆ On âˆ€ y âˆˆ On ( x ğ›œ y âˆ¨ x = y âˆ¨ y ğ›œ x ) ) ) ;;
	step 14 : wff = mpbir2an (step 2, step 12, step 13) |- ğ›œ We On ;;
	step 15 : wff = df-ord () |- ( Ord On â†” ( Tr On âˆ§ ğ›œ We On ) ) ;;
	step 16 : wff = mpbir2an (step 1, step 14, step 15) |- Ord On ;;
	qed prop 1 = step 16 ;;
}

/*The epsilon relation well-orders the class of ordinal numbers.
     Proposition 4.8(g) of [Mendelson] p. 244.  (Contributed by NM,
     1-Nov-2003.) */

theorem epweon ()  {
	prop 1 : wff = |- ğ›œ We On ;;
}

proof of epweon {
	step 1 : wff = ordon () |- Ord On ;;
	step 2 : wff = ordwe () |- ( Ord On â†’ ğ›œ We On ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ğ›œ We On ;;
	qed prop 1 = step 3 ;;
}

/*No set contains all ordinal numbers.  Proposition 7.13 of [TakeutiZaring]
     p. 38, but without using the Axiom of Regularity.  This is also known as
     the Burali-Forti paradox (remark in [Enderton] p. 194).  In 1897, Cesare
     Burali-Forti noticed that since the "set" of all ordinal numbers is an
     ordinal class ( ~ ordon ), it must be both an element of the set of all
     ordinal numbers yet greater than every such element.  ZF set theory
     resolves this paradox by not allowing the class of all ordinal numbers to
     be a set (so instead it is a proper class).  Here we prove the denial of
     its existence.  (Contributed by NM, 18-May-1994.) */

theorem onprc ()  {
	prop 1 : wff = |- Â¬ On âˆˆ _V ;;
}

proof of onprc {
	step 1 : wff = ordon () |- Ord On ;;
	step 2 : wff = ordirr () |- ( Ord On â†’ Â¬ On âˆˆ On ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- Â¬ On âˆˆ On ;;
	step 4 : wff = ordon () |- Ord On ;;
	step 5 : wff = elong () |- ( On âˆˆ _V â†’ ( On âˆˆ On â†” Ord On ) ) ;;
	step 6 : wff = mpbiri (step 4, step 5) |- ( On âˆˆ _V â†’ On âˆˆ On ) ;;
	step 7 : wff = mto (step 3, step 6) |- Â¬ On âˆˆ _V ;;
	qed prop 1 = step 7 ;;
}

/*The union of a class of ordinal numbers is ordinal.  Proposition 7.19 of
       [TakeutiZaring] p. 40.  (Contributed by NM, 30-May-1994.)  (Proof
       shortened by Andrew Salmon, 12-Aug-2011.) */

theorem ssorduni (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
}

proof of ssorduni {
	var x : set, y : set;;
	step 1 : wff = eluni2 () |- ( x âˆˆ â‹ƒ A â†” âˆƒ y âˆˆ A x âˆˆ y ) ;;
	step 2 : wff = ssel () |- ( A âŠ† On â†’ ( y âˆˆ A â†’ y âˆˆ On ) ) ;;
	step 3 : wff = onelss () |- ( y âˆˆ On â†’ ( x âˆˆ y â†’ x âŠ† y ) ) ;;
	step 4 : wff = syl6 (step 2, step 3) |- ( A âŠ† On â†’ ( y âˆˆ A â†’ ( x âˆˆ y â†’ x âŠ† y ) ) ) ;;
	step 5 : wff = anc2r () |- ( ( y âˆˆ A â†’ ( x âˆˆ y â†’ x âŠ† y ) ) â†’ ( y âˆˆ A â†’ ( x âˆˆ y â†’ ( x âŠ† y âˆ§ y âˆˆ A ) ) ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A âŠ† On â†’ ( y âˆˆ A â†’ ( x âˆˆ y â†’ ( x âŠ† y âˆ§ y âˆˆ A ) ) ) ) ;;
	step 7 : wff = ssuni () |- ( ( x âŠ† y âˆ§ y âˆˆ A ) â†’ x âŠ† â‹ƒ A ) ;;
	step 8 : wff = syl8 (step 6, step 7) |- ( A âŠ† On â†’ ( y âˆˆ A â†’ ( x âˆˆ y â†’ x âŠ† â‹ƒ A ) ) ) ;;
	step 9 : wff = rexlimdv (step 8) |- ( A âŠ† On â†’ ( âˆƒ y âˆˆ A x âˆˆ y â†’ x âŠ† â‹ƒ A ) ) ;;
	step 10 : wff = syl5bi (step 1, step 9) |- ( A âŠ† On â†’ ( x âˆˆ â‹ƒ A â†’ x âŠ† â‹ƒ A ) ) ;;
	step 11 : wff = ralrimiv (step 10) |- ( A âŠ† On â†’ âˆ€ x âˆˆ â‹ƒ A x âŠ† â‹ƒ A ) ;;
	step 12 : wff = dftr3 () |- ( Tr â‹ƒ A â†” âˆ€ x âˆˆ â‹ƒ A x âŠ† â‹ƒ A ) ;;
	step 13 : wff = sylibr (step 11, step 12) |- ( A âŠ† On â†’ Tr â‹ƒ A ) ;;
	step 14 : wff = eluni2 () |- ( x âˆˆ â‹ƒ A â†” âˆƒ y âˆˆ A x âˆˆ y ) ;;
	step 15 : wff = ssel () |- ( A âŠ† On â†’ ( y âˆˆ A â†’ y âˆˆ On ) ) ;;
	step 16 : wff = onelon () |- ( ( y âˆˆ On âˆ§ x âˆˆ y ) â†’ x âˆˆ On ) ;;
	step 17 : wff = ex (step 16) |- ( y âˆˆ On â†’ ( x âˆˆ y â†’ x âˆˆ On ) ) ;;
	step 18 : wff = syl6 (step 15, step 17) |- ( A âŠ† On â†’ ( y âˆˆ A â†’ ( x âˆˆ y â†’ x âˆˆ On ) ) ) ;;
	step 19 : wff = rexlimdv (step 18) |- ( A âŠ† On â†’ ( âˆƒ y âˆˆ A x âˆˆ y â†’ x âˆˆ On ) ) ;;
	step 20 : wff = syl5bi (step 14, step 19) |- ( A âŠ† On â†’ ( x âˆˆ â‹ƒ A â†’ x âˆˆ On ) ) ;;
	step 21 : wff = ssrdv (step 20) |- ( A âŠ† On â†’ â‹ƒ A âŠ† On ) ;;
	step 22 : wff = ordon () |- Ord On ;;
	step 23 : wff = trssord () |- ( ( Tr â‹ƒ A âˆ§ â‹ƒ A âŠ† On âˆ§ Ord On ) â†’ Ord â‹ƒ A ) ;;
	step 24 : wff = 3exp (step 23) |- ( Tr â‹ƒ A â†’ ( â‹ƒ A âŠ† On â†’ ( Ord On â†’ Ord â‹ƒ A ) ) ) ;;
	step 25 : wff = mpii (step 22, step 24) |- ( Tr â‹ƒ A â†’ ( â‹ƒ A âŠ† On â†’ Ord â‹ƒ A ) ) ;;
	step 26 : wff = sylc (step 13, step 21, step 25) |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
	qed prop 1 = step 26 ;;
}

/*The union of a set of ordinal numbers is an ordinal number.  Theorem 9 of
     [Suppes] p. 132.  (Contributed by NM, 1-Nov-2003.) */

theorem ssonuni (A : class, V : class)  {
	prop 1 : wff = |- ( A âˆˆ V â†’ ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ) ;;
}

proof of ssonuni {
	step 1 : wff = ssorduni () |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
	step 2 : wff = uniexg () |- ( A âˆˆ V â†’ â‹ƒ A âˆˆ _V ) ;;
	step 3 : wff = elong () |- ( â‹ƒ A âˆˆ _V â†’ ( â‹ƒ A âˆˆ On â†” Ord â‹ƒ A ) ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( A âˆˆ V â†’ ( â‹ƒ A âˆˆ On â†” Ord â‹ƒ A ) ) ;;
	step 5 : wff = syl5ibr (step 1, step 4) |- ( A âˆˆ V â†’ ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ) ;;
	qed prop 1 = step 5 ;;
}

/*The union of a set of ordinal numbers is an ordinal number.  Corollary
       7N(d) of [Enderton] p. 193.  (Contributed by NM, 20-Sep-2003.) */

theorem ssonunii (A : class)  {
	hyp 1 : wff = |- A âˆˆ _V ;;
	-----------------------
	prop 1 : wff = |- ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ;;
}

proof of ssonunii {
	step 1 : wff = ssonuni () |- ( A âˆˆ _V â†’ ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ;;
	qed prop 1 = step 2 ;;
}

/*A way to express the ordinal property of a class in terms of the class of
     ordinal numbers.  Corollary 7.14 of [TakeutiZaring] p. 38 and its
     converse.  (Contributed by NM, 1-Jun-2003.) */

theorem ordeleqon (A : class)  {
	prop 1 : wff = |- ( Ord A â†” ( A âˆˆ On âˆ¨ A = On ) ) ;;
}

proof of ordeleqon {
	step 1 : wff = onprc () |- Â¬ On âˆˆ _V ;;
	step 2 : wff = elex () |- ( On âˆˆ A â†’ On âˆˆ _V ) ;;
	step 3 : wff = mto (step 1, step 2) |- Â¬ On âˆˆ A ;;
	step 4 : wff = ordon () |- Ord On ;;
	step 5 : wff = ordtri3or () |- ( ( Ord A âˆ§ Ord On ) â†’ ( A âˆˆ On âˆ¨ A = On âˆ¨ On âˆˆ A ) ) ;;
	step 6 : wff = mpan2 (step 4, step 5) |- ( Ord A â†’ ( A âˆˆ On âˆ¨ A = On âˆ¨ On âˆˆ A ) ) ;;
	step 7 : wff = df-3or () |- ( ( A âˆˆ On âˆ¨ A = On âˆ¨ On âˆˆ A ) â†” ( ( A âˆˆ On âˆ¨ A = On ) âˆ¨ On âˆˆ A ) ) ;;
	step 8 : wff = sylib (step 6, step 7) |- ( Ord A â†’ ( ( A âˆˆ On âˆ¨ A = On ) âˆ¨ On âˆˆ A ) ) ;;
	step 9 : wff = ord (step 8) |- ( Ord A â†’ ( Â¬ ( A âˆˆ On âˆ¨ A = On ) â†’ On âˆˆ A ) ) ;;
	step 10 : wff = mt3i (step 3, step 9) |- ( Ord A â†’ ( A âˆˆ On âˆ¨ A = On ) ) ;;
	step 11 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 12 : wff = ordon () |- Ord On ;;
	step 13 : wff = ordeq () |- ( A = On â†’ ( Ord A â†” Ord On ) ) ;;
	step 14 : wff = mpbiri (step 12, step 13) |- ( A = On â†’ Ord A ) ;;
	step 15 : wff = jaoi (step 11, step 14) |- ( ( A âˆˆ On âˆ¨ A = On ) â†’ Ord A ) ;;
	step 16 : wff = impbii (step 10, step 15) |- ( Ord A â†” ( A âˆˆ On âˆ¨ A = On ) ) ;;
	qed prop 1 = step 16 ;;
}

/*Any ordinal class is a subclass of the class of ordinal numbers.
     Corollary 7.15 of [TakeutiZaring] p. 38.  (Contributed by NM,
     18-May-1994.)  (Proof shortened by Andrew Salmon, 12-Aug-2011.) */

theorem ordsson (A : class)  {
	prop 1 : wff = |- ( Ord A â†’ A âŠ† On ) ;;
}

proof of ordsson {
	step 1 : wff = ordon () |- Ord On ;;
	step 2 : wff = ordeleqon () |- ( Ord A â†” ( A âˆˆ On âˆ¨ A = On ) ) ;;
	step 3 : wff = biimpi (step 2) |- ( Ord A â†’ ( A âˆˆ On âˆ¨ A = On ) ) ;;
	step 4 : wff = adantr (step 3) |- ( ( Ord A âˆ§ Ord On ) â†’ ( A âˆˆ On âˆ¨ A = On ) ) ;;
	step 5 : wff = ordsseleq () |- ( ( Ord A âˆ§ Ord On ) â†’ ( A âŠ† On â†” ( A âˆˆ On âˆ¨ A = On ) ) ) ;;
	step 6 : wff = mpbird (step 4, step 5) |- ( ( Ord A âˆ§ Ord On ) â†’ A âŠ† On ) ;;
	step 7 : wff = mpan2 (step 1, step 6) |- ( Ord A â†’ A âŠ† On ) ;;
	qed prop 1 = step 7 ;;
}

/*An ordinal number is a subset of the class of ordinal numbers.
     (Contributed by NM, 5-Jun-1994.) */

theorem onss (A : class)  {
	prop 1 : wff = |- ( A âˆˆ On â†’ A âŠ† On ) ;;
}

proof of onss {
	step 1 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 2 : wff = ordsson () |- ( Ord A â†’ A âŠ† On ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A âˆˆ On â†’ A âŠ† On ) ;;
	qed prop 1 = step 3 ;;
}

/*Two ways of saying a class of ordinals is unbounded.  (Contributed by
     Mario Carneiro, 8-Jun-2013.) */

theorem ssonprc (A : class)  {
	prop 1 : wff = |- ( A âŠ† On â†’ ( A âˆ‰ _V â†” â‹ƒ A = On ) ) ;;
}

proof of ssonprc {
	step 1 : wff = df-nel () |- ( A âˆ‰ _V â†” Â¬ A âˆˆ _V ) ;;
	step 2 : wff = ssorduni () |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
	step 3 : wff = ordeleqon () |- ( Ord â‹ƒ A â†” ( â‹ƒ A âˆˆ On âˆ¨ â‹ƒ A = On ) ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( A âŠ† On â†’ ( â‹ƒ A âˆˆ On âˆ¨ â‹ƒ A = On ) ) ;;
	step 5 : wff = orcomd (step 4) |- ( A âŠ† On â†’ ( â‹ƒ A = On âˆ¨ â‹ƒ A âˆˆ On ) ) ;;
	step 6 : wff = ord (step 5) |- ( A âŠ† On â†’ ( Â¬ â‹ƒ A = On â†’ â‹ƒ A âˆˆ On ) ) ;;
	step 7 : wff = elex () |- ( â‹ƒ A âˆˆ On â†’ â‹ƒ A âˆˆ _V ) ;;
	step 8 : wff = uniexb () |- ( A âˆˆ _V â†” â‹ƒ A âˆˆ _V ) ;;
	step 9 : wff = sylibr (step 7, step 8) |- ( â‹ƒ A âˆˆ On â†’ A âˆˆ _V ) ;;
	step 10 : wff = syl6 (step 6, step 9) |- ( A âŠ† On â†’ ( Â¬ â‹ƒ A = On â†’ A âˆˆ _V ) ) ;;
	step 11 : wff = con1d (step 10) |- ( A âŠ† On â†’ ( Â¬ A âˆˆ _V â†’ â‹ƒ A = On ) ) ;;
	step 12 : wff = onprc () |- Â¬ On âˆˆ _V ;;
	step 13 : wff = uniexg () |- ( A âˆˆ _V â†’ â‹ƒ A âˆˆ _V ) ;;
	step 14 : wff = eleq1 () |- ( â‹ƒ A = On â†’ ( â‹ƒ A âˆˆ _V â†” On âˆˆ _V ) ) ;;
	step 15 : wff = syl5ib (step 13, step 14) |- ( â‹ƒ A = On â†’ ( A âˆˆ _V â†’ On âˆˆ _V ) ) ;;
	step 16 : wff = mtoi (step 12, step 15) |- ( â‹ƒ A = On â†’ Â¬ A âˆˆ _V ) ;;
	step 17 : wff = impbid1 (step 11, step 16) |- ( A âŠ† On â†’ ( Â¬ A âˆˆ _V â†” â‹ƒ A = On ) ) ;;
	step 18 : wff = syl5bb (step 1, step 17) |- ( A âŠ† On â†’ ( A âˆ‰ _V â†” â‹ƒ A = On ) ) ;;
	qed prop 1 = step 18 ;;
}

/*The union of an ordinal number is an ordinal number.  (Contributed by NM,
     29-Sep-2006.) */

theorem onuni (A : class)  {
	prop 1 : wff = |- ( A âˆˆ On â†’ â‹ƒ A âˆˆ On ) ;;
}

proof of onuni {
	step 1 : wff = onss () |- ( A âˆˆ On â†’ A âŠ† On ) ;;
	step 2 : wff = ssonuni () |- ( A âˆˆ On â†’ ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ) ;;
	step 3 : wff = mpd (step 1, step 2) |- ( A âˆˆ On â†’ â‹ƒ A âˆˆ On ) ;;
	qed prop 1 = step 3 ;;
}

/*The union of an ordinal class is ordinal.  (Contributed by NM,
     12-Sep-2003.) */

theorem orduni (A : class)  {
	prop 1 : wff = |- ( Ord A â†’ Ord â‹ƒ A ) ;;
}

proof of orduni {
	step 1 : wff = ordsson () |- ( Ord A â†’ A âŠ† On ) ;;
	step 2 : wff = ssorduni () |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( Ord A â†’ Ord â‹ƒ A ) ;;
	qed prop 1 = step 3 ;;
}

/*The intersection (infimum) of a non-empty class of ordinal numbers
       belongs to the class.  Compare Exercise 4 of [TakeutiZaring] p. 45.
       (Contributed by NM, 31-Jan-1997.) */

theorem onint (A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ A ) ;;
}

proof of onint {
	var x : set, y : set, z : set;;
	step 1 : wff = ordon () |- Ord On ;;
	step 2 : wff = tz7.5 () |- ( ( Ord On âˆ§ A âŠ† On âˆ§ A â‰  âˆ… ) â†’ âˆƒ x âˆˆ A ( A âˆ© x ) = âˆ… ) ;;
	step 3 : wff = mp3an1 (step 1, step 2) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ âˆƒ x âˆˆ A ( A âˆ© x ) = âˆ… ) ;;
	step 4 : wff = ssel () |- ( A âŠ† On â†’ ( x âˆˆ A â†’ x âˆˆ On ) ) ;;
	step 5 : wff = imdistani (step 4) |- ( ( A âŠ† On âˆ§ x âˆˆ A ) â†’ ( A âŠ† On âˆ§ x âˆˆ On ) ) ;;
	step 6 : wff = ssel () |- ( A âŠ† On â†’ ( z âˆˆ A â†’ z âˆˆ On ) ) ;;
	step 7 : wff = ontri1 () |- ( ( x âˆˆ On âˆ§ z âˆˆ On ) â†’ ( x âŠ† z â†” Â¬ z âˆˆ x ) ) ;;
	step 8 : wff = ssel () |- ( x âŠ† z â†’ ( y âˆˆ x â†’ y âˆˆ z ) ) ;;
	step 9 : wff = syl6bir (step 7, step 8) |- ( ( x âˆˆ On âˆ§ z âˆˆ On ) â†’ ( Â¬ z âˆˆ x â†’ ( y âˆˆ x â†’ y âˆˆ z ) ) ) ;;
	step 10 : wff = ex (step 9) |- ( x âˆˆ On â†’ ( z âˆˆ On â†’ ( Â¬ z âˆˆ x â†’ ( y âˆˆ x â†’ y âˆˆ z ) ) ) ) ;;
	step 11 : wff = sylan9 (step 6, step 10) |- ( ( A âŠ† On âˆ§ x âˆˆ On ) â†’ ( z âˆˆ A â†’ ( Â¬ z âˆˆ x â†’ ( y âˆˆ x â†’ y âˆˆ z ) ) ) ) ;;
	step 12 : wff = com4r (step 11) |- ( y âˆˆ x â†’ ( ( A âŠ† On âˆ§ x âˆˆ On ) â†’ ( z âˆˆ A â†’ ( Â¬ z âˆˆ x â†’ y âˆˆ z ) ) ) ) ;;
	step 13 : wff = imp31 (step 12) |- ( ( ( y âˆˆ x âˆ§ ( A âŠ† On âˆ§ x âˆˆ On ) ) âˆ§ z âˆˆ A ) â†’ ( Â¬ z âˆˆ x â†’ y âˆˆ z ) ) ;;
	step 14 : wff = ralimdva (step 13) |- ( ( y âˆˆ x âˆ§ ( A âŠ† On âˆ§ x âˆˆ On ) ) â†’ ( âˆ€ z âˆˆ A Â¬ z âˆˆ x â†’ âˆ€ z âˆˆ A y âˆˆ z ) ) ;;
	step 15 : wff = disj () |- ( ( A âˆ© x ) = âˆ… â†” âˆ€ z âˆˆ A Â¬ z âˆˆ x ) ;;
	step 16 : wff = vex () |- y âˆˆ _V ;;
	step 17 : wff = elint2 (step 16) |- ( y âˆˆ â‹‚ A â†” âˆ€ z âˆˆ A y âˆˆ z ) ;;
	step 18 : wff = 3imtr4g (step 14, step 15, step 17) |- ( ( y âˆˆ x âˆ§ ( A âŠ† On âˆ§ x âˆˆ On ) ) â†’ ( ( A âˆ© x ) = âˆ… â†’ y âˆˆ â‹‚ A ) ) ;;
	step 19 : wff = sylan2 (step 5, step 18) |- ( ( y âˆˆ x âˆ§ ( A âŠ† On âˆ§ x âˆˆ A ) ) â†’ ( ( A âˆ© x ) = âˆ… â†’ y âˆˆ â‹‚ A ) ) ;;
	step 20 : wff = exp32 (step 19) |- ( y âˆˆ x â†’ ( A âŠ† On â†’ ( x âˆˆ A â†’ ( ( A âˆ© x ) = âˆ… â†’ y âˆˆ â‹‚ A ) ) ) ) ;;
	step 21 : wff = com4l (step 20) |- ( A âŠ† On â†’ ( x âˆˆ A â†’ ( ( A âˆ© x ) = âˆ… â†’ ( y âˆˆ x â†’ y âˆˆ â‹‚ A ) ) ) ) ;;
	step 22 : wff = imp32 (step 21) |- ( ( A âŠ† On âˆ§ ( x âˆˆ A âˆ§ ( A âˆ© x ) = âˆ… ) ) â†’ ( y âˆˆ x â†’ y âˆˆ â‹‚ A ) ) ;;
	step 23 : wff = ssrdv (step 22) |- ( ( A âŠ† On âˆ§ ( x âˆˆ A âˆ§ ( A âˆ© x ) = âˆ… ) ) â†’ x âŠ† â‹‚ A ) ;;
	step 24 : wff = intss1 () |- ( x âˆˆ A â†’ â‹‚ A âŠ† x ) ;;
	step 25 : wff = ad2antrl (step 24) |- ( ( A âŠ† On âˆ§ ( x âˆˆ A âˆ§ ( A âˆ© x ) = âˆ… ) ) â†’ â‹‚ A âŠ† x ) ;;
	step 26 : wff = eqssd (step 23, step 25) |- ( ( A âŠ† On âˆ§ ( x âˆˆ A âˆ§ ( A âˆ© x ) = âˆ… ) ) â†’ x = â‹‚ A ) ;;
	step 27 : wff = eleq1d (step 26) |- ( ( A âŠ† On âˆ§ ( x âˆˆ A âˆ§ ( A âˆ© x ) = âˆ… ) ) â†’ ( x âˆˆ A â†” â‹‚ A âˆˆ A ) ) ;;
	step 28 : wff = biimpd (step 27) |- ( ( A âŠ† On âˆ§ ( x âˆˆ A âˆ§ ( A âˆ© x ) = âˆ… ) ) â†’ ( x âˆˆ A â†’ â‹‚ A âˆˆ A ) ) ;;
	step 29 : wff = exp32 (step 28) |- ( A âŠ† On â†’ ( x âˆˆ A â†’ ( ( A âˆ© x ) = âˆ… â†’ ( x âˆˆ A â†’ â‹‚ A âˆˆ A ) ) ) ) ;;
	step 30 : wff = com34 (step 29) |- ( A âŠ† On â†’ ( x âˆˆ A â†’ ( x âˆˆ A â†’ ( ( A âˆ© x ) = âˆ… â†’ â‹‚ A âˆˆ A ) ) ) ) ;;
	step 31 : wff = pm2.43d (step 30) |- ( A âŠ† On â†’ ( x âˆˆ A â†’ ( ( A âˆ© x ) = âˆ… â†’ â‹‚ A âˆˆ A ) ) ) ;;
	step 32 : wff = rexlimdv (step 31) |- ( A âŠ† On â†’ ( âˆƒ x âˆˆ A ( A âˆ© x ) = âˆ… â†’ â‹‚ A âˆˆ A ) ) ;;
	step 33 : wff = syl5 (step 3, step 32) |- ( A âŠ† On â†’ ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ A ) ) ;;
	step 34 : wff = anabsi5 (step 33) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ A ) ;;
	qed prop 1 = step 34 ;;
}

/*The intersection of a class of ordinal numbers is zero iff the class
     contains zero.  (Contributed by NM, 24-Apr-2004.) */

theorem onint0 (A : class)  {
	prop 1 : wff = |- ( A âŠ† On â†’ ( â‹‚ A = âˆ… â†” âˆ… âˆˆ A ) ) ;;
}

proof of onint0 {
	step 1 : wff = 0ex () |- âˆ… âˆˆ _V ;;
	step 2 : wff = eleq1 () |- ( â‹‚ A = âˆ… â†’ ( â‹‚ A âˆˆ _V â†” âˆ… âˆˆ _V ) ) ;;
	step 3 : wff = mpbiri (step 1, step 2) |- ( â‹‚ A = âˆ… â†’ â‹‚ A âˆˆ _V ) ;;
	step 4 : wff = intex () |- ( A â‰  âˆ… â†” â‹‚ A âˆˆ _V ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( â‹‚ A = âˆ… â†’ A â‰  âˆ… ) ;;
	step 6 : wff = onint () |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ A ) ;;
	step 7 : wff = sylan2 (step 5, step 6) |- ( ( A âŠ† On âˆ§ â‹‚ A = âˆ… ) â†’ â‹‚ A âˆˆ A ) ;;
	step 8 : wff = eleq1 () |- ( â‹‚ A = âˆ… â†’ ( â‹‚ A âˆˆ A â†” âˆ… âˆˆ A ) ) ;;
	step 9 : wff = adantl (step 8) |- ( ( A âŠ† On âˆ§ â‹‚ A = âˆ… ) â†’ ( â‹‚ A âˆˆ A â†” âˆ… âˆˆ A ) ) ;;
	step 10 : wff = mpbid (step 7, step 9) |- ( ( A âŠ† On âˆ§ â‹‚ A = âˆ… ) â†’ âˆ… âˆˆ A ) ;;
	step 11 : wff = ex (step 10) |- ( A âŠ† On â†’ ( â‹‚ A = âˆ… â†’ âˆ… âˆˆ A ) ) ;;
	step 12 : wff = int0el () |- ( âˆ… âˆˆ A â†’ â‹‚ A = âˆ… ) ;;
	step 13 : wff = impbid1 (step 11, step 12) |- ( A âŠ† On â†’ ( â‹‚ A = âˆ… â†” âˆ… âˆˆ A ) ) ;;
	qed prop 1 = step 13 ;;
}

/*A non-empty class of ordinal numbers has the smallest member.  Exercise
       9 of [TakeutiZaring] p. 40.  (Contributed by NM, 3-Oct-2003.) */

theorem onssmin (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ âˆƒ x âˆˆ A âˆ€ y âˆˆ A x âŠ† y ) ;;
}

proof of onssmin {
	step 1 : wff = onint () |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ A ) ;;
	step 2 : wff = intss1 () |- ( y âˆˆ A â†’ â‹‚ A âŠ† y ) ;;
	step 3 : wff = rgen (step 2) |- âˆ€ y âˆˆ A â‹‚ A âŠ† y ;;
	step 4 : wff = sseq1 () |- ( x = â‹‚ A â†’ ( x âŠ† y â†” â‹‚ A âŠ† y ) ) ;;
	step 5 : wff = ralbidv (step 4) |- ( x = â‹‚ A â†’ ( âˆ€ y âˆˆ A x âŠ† y â†” âˆ€ y âˆˆ A â‹‚ A âŠ† y ) ) ;;
	step 6 : wff = rspcev (step 5) |- ( ( â‹‚ A âˆˆ A âˆ§ âˆ€ y âˆˆ A â‹‚ A âŠ† y ) â†’ âˆƒ x âˆˆ A âˆ€ y âˆˆ A x âŠ† y ) ;;
	step 7 : wff = sylancl (step 1, step 3, step 6) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ âˆƒ x âˆˆ A âˆ€ y âˆˆ A x âŠ† y ) ;;
	qed prop 1 = step 7 ;;
}

/*If a property is true for some ordinal number, it is true for a minimal
       ordinal number.  This version uses explicit substitution.  Theorem
       Schema 62 of [Suppes] p. 228.  (Contributed by NM, 29-Sep-2003.) */

theorem onminesb (ph : wff, x : set) disjointed(x) {
	prop 1 : wff = |- ( âˆƒ x âˆˆ On ph â†’ [. â‹‚ { x âˆˆ On | ph } / x ]. ph ) ;;
}

proof of onminesb {
	step 1 : wff = rabn0 () |- ( { x âˆˆ On | ph } â‰  âˆ… â†” âˆƒ x âˆˆ On ph ) ;;
	step 2 : wff = ssrab2 () |- { x âˆˆ On | ph } âŠ† On ;;
	step 3 : wff = onint () |- ( ( { x âˆˆ On | ph } âŠ† On âˆ§ { x âˆˆ On | ph } â‰  âˆ… ) â†’ â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( { x âˆˆ On | ph } â‰  âˆ… â†’ â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } ) ;;
	step 5 : wff = sylbir (step 1, step 4) |- ( âˆƒ x âˆˆ On ph â†’ â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } ) ;;
	step 6 : wff = nfcv () |- F/_ x On ;;
	step 7 : wff = elrabsf (step 6) |- ( â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } â†” ( â‹‚ { x âˆˆ On | ph } âˆˆ On âˆ§ [. â‹‚ { x âˆˆ On | ph } / x ]. ph ) ) ;;
	step 8 : wff = simprbi (step 7) |- ( â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } â†’ [. â‹‚ { x âˆˆ On | ph } / x ]. ph ) ;;
	step 9 : wff = syl (step 5, step 8) |- ( âˆƒ x âˆˆ On ph â†’ [. â‹‚ { x âˆˆ On | ph } / x ]. ph ) ;;
	qed prop 1 = step 9 ;;
}

/*If a property is true for some ordinal number, it is true for a minimal
       ordinal number.  This version uses implicit substitution.  Theorem
       Schema 62 of [Suppes] p. 228.  (Contributed by NM, 3-Oct-2003.) */

theorem onminsb (ph : wff, ps : wff, x : set) disjointed(x, ph) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = â‹‚ { x âˆˆ On | ph } â†’ ( ph â†” ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( âˆƒ x âˆˆ On ph â†’ ps ) ;;
}

proof of onminsb {
	step 1 : wff = rabn0 () |- ( { x âˆˆ On | ph } â‰  âˆ… â†” âˆƒ x âˆˆ On ph ) ;;
	step 2 : wff = ssrab2 () |- { x âˆˆ On | ph } âŠ† On ;;
	step 3 : wff = onint () |- ( ( { x âˆˆ On | ph } âŠ† On âˆ§ { x âˆˆ On | ph } â‰  âˆ… ) â†’ â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( { x âˆˆ On | ph } â‰  âˆ… â†’ â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } ) ;;
	step 5 : wff = sylbir (step 1, step 4) |- ( âˆƒ x âˆˆ On ph â†’ â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } ) ;;
	step 6 : wff = nfrab1 () |- F/_ x { x âˆˆ On | ph } ;;
	step 7 : wff = nfint (step 6) |- F/_ x â‹‚ { x âˆˆ On | ph } ;;
	step 8 : wff = nfcv () |- F/_ x On ;;
	step 9 : wff = elrabf (step 7, step 8, hyp 1, hyp 2) |- ( â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } â†” ( â‹‚ { x âˆˆ On | ph } âˆˆ On âˆ§ ps ) ) ;;
	step 10 : wff = simprbi (step 9) |- ( â‹‚ { x âˆˆ On | ph } âˆˆ { x âˆˆ On | ph } â†’ ps ) ;;
	step 11 : wff = syl (step 5, step 10) |- ( âˆƒ x âˆˆ On ph â†’ ps ) ;;
	qed prop 1 = step 11 ;;
}

/*The intersection of a non-empty collection of ordinal numbers is an
     ordinal number.  Compare Exercise 6 of [TakeutiZaring] p. 44.
     (Contributed by NM, 29-Jan-1997.) */

theorem oninton (A : class)  {
	prop 1 : wff = |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ On ) ;;
}

proof of oninton {
	step 1 : wff = onint () |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ A ) ;;
	step 2 : wff = ex (step 1) |- ( A âŠ† On â†’ ( A â‰  âˆ… â†’ â‹‚ A âˆˆ A ) ) ;;
	step 3 : wff = ssel () |- ( A âŠ† On â†’ ( â‹‚ A âˆˆ A â†’ â‹‚ A âˆˆ On ) ) ;;
	step 4 : wff = syld (step 2, step 3) |- ( A âŠ† On â†’ ( A â‰  âˆ… â†’ â‹‚ A âˆˆ On ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ On ) ;;
	qed prop 1 = step 5 ;;
}

/*The intersection of a class of ordinal numbers exists iff it is an ordinal
     number.  (Contributed by NM, 6-Nov-2003.) */

theorem onintrab (ph : wff, x : set)  {
	prop 1 : wff = |- ( â‹‚ { x âˆˆ On | ph } âˆˆ _V â†” â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
}

proof of onintrab {
	step 1 : wff = intex () |- ( { x âˆˆ On | ph } â‰  âˆ… â†” â‹‚ { x âˆˆ On | ph } âˆˆ _V ) ;;
	step 2 : wff = ssrab2 () |- { x âˆˆ On | ph } âŠ† On ;;
	step 3 : wff = oninton () |- ( ( { x âˆˆ On | ph } âŠ† On âˆ§ { x âˆˆ On | ph } â‰  âˆ… ) â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( { x âˆˆ On | ph } â‰  âˆ… â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 5 : wff = sylbir (step 1, step 4) |- ( â‹‚ { x âˆˆ On | ph } âˆˆ _V â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 6 : wff = elex () |- ( â‹‚ { x âˆˆ On | ph } âˆˆ On â†’ â‹‚ { x âˆˆ On | ph } âˆˆ _V ) ;;
	step 7 : wff = impbii (step 5, step 6) |- ( â‹‚ { x âˆˆ On | ph } âˆˆ _V â†” â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	qed prop 1 = step 7 ;;
}

/*An existence condition equivalent to an intersection's being an ordinal
     number.  (Contributed by NM, 6-Nov-2003.) */

theorem onintrab2 (ph : wff, x : set)  {
	prop 1 : wff = |- ( âˆƒ x âˆˆ On ph â†” â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
}

proof of onintrab2 {
	step 1 : wff = intexrab () |- ( âˆƒ x âˆˆ On ph â†” â‹‚ { x âˆˆ On | ph } âˆˆ _V ) ;;
	step 2 : wff = onintrab () |- ( â‹‚ { x âˆˆ On | ph } âˆˆ _V â†” â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( âˆƒ x âˆˆ On ph â†” â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	qed prop 1 = step 3 ;;
}

/*No member of a set of ordinal numbers belongs to its minimum.
     (Contributed by NM, 2-Feb-1997.) */

theorem onnmin (A : class, B : class)  {
	prop 1 : wff = |- ( ( A âŠ† On âˆ§ B âˆˆ A ) â†’ Â¬ B âˆˆ â‹‚ A ) ;;
}

proof of onnmin {
	step 1 : wff = intss1 () |- ( B âˆˆ A â†’ â‹‚ A âŠ† B ) ;;
	step 2 : wff = adantl (step 1) |- ( ( A âŠ† On âˆ§ B âˆˆ A ) â†’ â‹‚ A âŠ† B ) ;;
	step 3 : wff = ne0i () |- ( B âˆˆ A â†’ A â‰  âˆ… ) ;;
	step 4 : wff = oninton () |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ On ) ;;
	step 5 : wff = sylan2 (step 3, step 4) |- ( ( A âŠ† On âˆ§ B âˆˆ A ) â†’ â‹‚ A âˆˆ On ) ;;
	step 6 : wff = ssel2 () |- ( ( A âŠ† On âˆ§ B âˆˆ A ) â†’ B âˆˆ On ) ;;
	step 7 : wff = ontri1 () |- ( ( â‹‚ A âˆˆ On âˆ§ B âˆˆ On ) â†’ ( â‹‚ A âŠ† B â†” Â¬ B âˆˆ â‹‚ A ) ) ;;
	step 8 : wff = syl2anc (step 5, step 6, step 7) |- ( ( A âŠ† On âˆ§ B âˆˆ A ) â†’ ( â‹‚ A âŠ† B â†” Â¬ B âˆˆ â‹‚ A ) ) ;;
	step 9 : wff = mpbid (step 2, step 8) |- ( ( A âŠ† On âˆ§ B âˆˆ A ) â†’ Â¬ B âˆˆ â‹‚ A ) ;;
	qed prop 1 = step 9 ;;
}

/*An ordinal number smaller than the minimum of a set of ordinal numbers
       does not have the property determining that set. ` ps ` is the wff
       resulting from the substitution of ` A ` for ` x ` in wff ` ph ` .
       (Contributed by NM, 9-Nov-2003.) */

theorem onnminsb (ph : wff, ps : wff, x : set, A : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- ( x = A â†’ ( ph â†” ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A âˆˆ On â†’ ( A âˆˆ â‹‚ { x âˆˆ On | ph } â†’ Â¬ ps ) ) ;;
}

proof of onnminsb {
	step 1 : wff = elrab (hyp 1) |- ( A âˆˆ { x âˆˆ On | ph } â†” ( A âˆˆ On âˆ§ ps ) ) ;;
	step 2 : wff = ssrab2 () |- { x âˆˆ On | ph } âŠ† On ;;
	step 3 : wff = onnmin () |- ( ( { x âˆˆ On | ph } âŠ† On âˆ§ A âˆˆ { x âˆˆ On | ph } ) â†’ Â¬ A âˆˆ â‹‚ { x âˆˆ On | ph } ) ;;
	step 4 : wff = mpan (step 2, step 3) |- ( A âˆˆ { x âˆˆ On | ph } â†’ Â¬ A âˆˆ â‹‚ { x âˆˆ On | ph } ) ;;
	step 5 : wff = sylbir (step 1, step 4) |- ( ( A âˆˆ On âˆ§ ps ) â†’ Â¬ A âˆˆ â‹‚ { x âˆˆ On | ph } ) ;;
	step 6 : wff = ex (step 5) |- ( A âˆˆ On â†’ ( ps â†’ Â¬ A âˆˆ â‹‚ { x âˆˆ On | ph } ) ) ;;
	step 7 : wff = con2d (step 6) |- ( A âˆˆ On â†’ ( A âˆˆ â‹‚ { x âˆˆ On | ph } â†’ Â¬ ps ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A way to show that an ordinal number equals the minimum of a non-empty
       collection of ordinal numbers: it must be in the collection, and it must
       not be larger than any member of the collection.  (Contributed by NM,
       14-Nov-2003.) */

theorem oneqmin (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ ( A = â‹‚ B â†” ( A âˆˆ B âˆ§ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) ) ) ;;
}

proof of oneqmin {
	step 1 : wff = onint () |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ â‹‚ B âˆˆ B ) ;;
	step 2 : wff = eleq1 () |- ( A = â‹‚ B â†’ ( A âˆˆ B â†” â‹‚ B âˆˆ B ) ) ;;
	step 3 : wff = syl5ibrcom (step 1, step 2) |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ ( A = â‹‚ B â†’ A âˆˆ B ) ) ;;
	step 4 : wff = eleq2 () |- ( A = â‹‚ B â†’ ( x âˆˆ A â†” x âˆˆ â‹‚ B ) ) ;;
	step 5 : wff = biimpd (step 4) |- ( A = â‹‚ B â†’ ( x âˆˆ A â†’ x âˆˆ â‹‚ B ) ) ;;
	step 6 : wff = onnmin () |- ( ( B âŠ† On âˆ§ x âˆˆ B ) â†’ Â¬ x âˆˆ â‹‚ B ) ;;
	step 7 : wff = ex (step 6) |- ( B âŠ† On â†’ ( x âˆˆ B â†’ Â¬ x âˆˆ â‹‚ B ) ) ;;
	step 8 : wff = con2d (step 7) |- ( B âŠ† On â†’ ( x âˆˆ â‹‚ B â†’ Â¬ x âˆˆ B ) ) ;;
	step 9 : wff = syl9r (step 5, step 8) |- ( B âŠ† On â†’ ( A = â‹‚ B â†’ ( x âˆˆ A â†’ Â¬ x âˆˆ B ) ) ) ;;
	step 10 : wff = ralrimdv (step 9) |- ( B âŠ† On â†’ ( A = â‹‚ B â†’ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) ) ;;
	step 11 : wff = adantr (step 10) |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ ( A = â‹‚ B â†’ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) ) ;;
	step 12 : wff = jcad (step 3, step 11) |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ ( A = â‹‚ B â†’ ( A âˆˆ B âˆ§ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) ) ) ;;
	step 13 : wff = oneqmini () |- ( B âŠ† On â†’ ( ( A âˆˆ B âˆ§ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) â†’ A = â‹‚ B ) ) ;;
	step 14 : wff = adantr (step 13) |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ ( ( A âˆˆ B âˆ§ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) â†’ A = â‹‚ B ) ) ;;
	step 15 : wff = impbid (step 12, step 14) |- ( ( B âŠ† On âˆ§ B â‰  âˆ… ) â†’ ( A = â‹‚ B â†” ( A âˆˆ B âˆ§ âˆ€ x âˆˆ A Â¬ x âˆˆ B ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Problem 2.5(ii) of [BellMachover] p. 471.  (Contributed by NM,
       20-Sep-2003.) */

theorem bm2.5ii (x : set, y : set, A : class) disjointed(x y A) {
	hyp 1 : wff = |- A âˆˆ _V ;;
	-----------------------
	prop 1 : wff = |- ( A âŠ† On â†’ â‹ƒ A = â‹‚ { x âˆˆ On | âˆ€ y âˆˆ A y âŠ† x } ) ;;
}

proof of bm2.5ii {
	step 1 : wff = ssonunii (hyp 1) |- ( A âŠ† On â†’ â‹ƒ A âˆˆ On ) ;;
	step 2 : wff = unissb () |- ( â‹ƒ A âŠ† x â†” âˆ€ y âˆˆ A y âŠ† x ) ;;
	step 3 : wff = a1i (step 2) |- ( x âˆˆ On â†’ ( â‹ƒ A âŠ† x â†” âˆ€ y âˆˆ A y âŠ† x ) ) ;;
	step 4 : wff = rabbiia (step 3) |- { x âˆˆ On | â‹ƒ A âŠ† x } = { x âˆˆ On | âˆ€ y âˆˆ A y âŠ† x } ;;
	step 5 : wff = inteqi (step 4) |- â‹‚ { x âˆˆ On | â‹ƒ A âŠ† x } = â‹‚ { x âˆˆ On | âˆ€ y âˆˆ A y âŠ† x } ;;
	step 6 : wff = intmin () |- ( â‹ƒ A âˆˆ On â†’ â‹‚ { x âˆˆ On | â‹ƒ A âŠ† x } = â‹ƒ A ) ;;
	step 7 : wff = syl5reqr (step 5, step 6) |- ( â‹ƒ A âˆˆ On â†’ â‹ƒ A = â‹‚ { x âˆˆ On | âˆ€ y âˆˆ A y âŠ† x } ) ;;
	step 8 : wff = syl (step 1, step 7) |- ( A âŠ† On â†’ â‹ƒ A = â‹‚ { x âˆˆ On | âˆ€ y âˆˆ A y âŠ† x } ) ;;
	qed prop 1 = step 8 ;;
}

/*If a wff is true for an ordinal number, there is the smallest ordinal
       number for which it is true.  (Contributed by NM, 2-Feb-1997.)  (Proof
       shortened by Mario Carneiro, 20-Nov-2016.) */

theorem onminex (ph : wff, ps : wff, x : set, y : set) disjointed(x y z, y z ph, x z ps) {
	hyp 1 : wff = |- ( x = y â†’ ( ph â†” ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( âˆƒ x âˆˆ On ph â†’ âˆƒ x âˆˆ On ( ph âˆ§ âˆ€ y âˆˆ x Â¬ ps ) ) ;;
}

proof of onminex {
	var z : set;;
	step 1 : wff = ssrab2 () |- { x âˆˆ On | ph } âŠ† On ;;
	step 2 : wff = rabn0 () |- ( { x âˆˆ On | ph } â‰  âˆ… â†” âˆƒ x âˆˆ On ph ) ;;
	step 3 : wff = biimpri (step 2) |- ( âˆƒ x âˆˆ On ph â†’ { x âˆˆ On | ph } â‰  âˆ… ) ;;
	step 4 : wff = oninton () |- ( ( { x âˆˆ On | ph } âŠ† On âˆ§ { x âˆˆ On | ph } â‰  âˆ… ) â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 5 : wff = sylancr (step 1, step 3, step 4) |- ( âˆƒ x âˆˆ On ph â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 6 : wff = onminesb () |- ( âˆƒ x âˆˆ On ph â†’ [. â‹‚ { x âˆˆ On | ph } / x ]. ph ) ;;
	step 7 : wff = ssrab2 () |- { x âˆˆ On | ph } âŠ† On ;;
	step 8 : wff = rabn0 () |- ( { x âˆˆ On | ph } â‰  âˆ… â†” âˆƒ x âˆˆ On ph ) ;;
	step 9 : wff = biimpri (step 8) |- ( âˆƒ x âˆˆ On ph â†’ { x âˆˆ On | ph } â‰  âˆ… ) ;;
	step 10 : wff = oninton () |- ( ( { x âˆˆ On | ph } âŠ† On âˆ§ { x âˆˆ On | ph } â‰  âˆ… ) â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 11 : wff = sylancr (step 7, step 9, step 10) |- ( âˆƒ x âˆˆ On ph â†’ â‹‚ { x âˆˆ On | ph } âˆˆ On ) ;;
	step 12 : wff = onss () |- ( â‹‚ { x âˆˆ On | ph } âˆˆ On â†’ â‹‚ { x âˆˆ On | ph } âŠ† On ) ;;
	step 13 : wff = syl (step 11, step 12) |- ( âˆƒ x âˆˆ On ph â†’ â‹‚ { x âˆˆ On | ph } âŠ† On ) ;;
	step 14 : wff = sseld (step 13) |- ( âˆƒ x âˆˆ On ph â†’ ( y âˆˆ â‹‚ { x âˆˆ On | ph } â†’ y âˆˆ On ) ) ;;
	step 15 : wff = onnminsb (hyp 1) |- ( y âˆˆ On â†’ ( y âˆˆ â‹‚ { x âˆˆ On | ph } â†’ Â¬ ps ) ) ;;
	step 16 : wff = syli (step 14, step 15) |- ( âˆƒ x âˆˆ On ph â†’ ( y âˆˆ â‹‚ { x âˆˆ On | ph } â†’ Â¬ ps ) ) ;;
	step 17 : wff = ralrimiv (step 16) |- ( âˆƒ x âˆˆ On ph â†’ âˆ€ y âˆˆ â‹‚ { x âˆˆ On | ph } Â¬ ps ) ;;
	step 18 : wff = dfsbcq2 () |- ( z = â‹‚ { x âˆˆ On | ph } â†’ ( [ z / x ] ph â†” [. â‹‚ { x âˆˆ On | ph } / x ]. ph ) ) ;;
	step 19 : wff = raleq () |- ( z = â‹‚ { x âˆˆ On | ph } â†’ ( âˆ€ y âˆˆ z Â¬ ps â†” âˆ€ y âˆˆ â‹‚ { x âˆˆ On | ph } Â¬ ps ) ) ;;
	step 20 : wff = anbi12d (step 18, step 19) |- ( z = â‹‚ { x âˆˆ On | ph } â†’ ( ( [ z / x ] ph âˆ§ âˆ€ y âˆˆ z Â¬ ps ) â†” ( [. â‹‚ { x âˆˆ On | ph } / x ]. ph âˆ§ âˆ€ y âˆˆ â‹‚ { x âˆˆ On | ph } Â¬ ps ) ) ) ;;
	step 21 : wff = rspcev (step 20) |- ( ( â‹‚ { x âˆˆ On | ph } âˆˆ On âˆ§ ( [. â‹‚ { x âˆˆ On | ph } / x ]. ph âˆ§ âˆ€ y âˆˆ â‹‚ { x âˆˆ On | ph } Â¬ ps ) ) â†’ âˆƒ z âˆˆ On ( [ z / x ] ph âˆ§ âˆ€ y âˆˆ z Â¬ ps ) ) ;;
	step 22 : wff = syl12anc (step 5, step 6, step 17, step 21) |- ( âˆƒ x âˆˆ On ph â†’ âˆƒ z âˆˆ On ( [ z / x ] ph âˆ§ âˆ€ y âˆˆ z Â¬ ps ) ) ;;
	step 23 : wff = nfv () |- F/ z ( ph âˆ§ âˆ€ y âˆˆ x Â¬ ps ) ;;
	step 24 : wff = nfs1v () |- F/ x [ z / x ] ph ;;
	step 25 : wff = nfv () |- F/ x âˆ€ y âˆˆ z Â¬ ps ;;
	step 26 : wff = nfan (step 24, step 25) |- F/ x ( [ z / x ] ph âˆ§ âˆ€ y âˆˆ z Â¬ ps ) ;;
	step 27 : wff = sbequ12 () |- ( x = z â†’ ( ph â†” [ z / x ] ph ) ) ;;
	step 28 : wff = raleq () |- ( x = z â†’ ( âˆ€ y âˆˆ x Â¬ ps â†” âˆ€ y âˆˆ z Â¬ ps ) ) ;;
	step 29 : wff = anbi12d (step 27, step 28) |- ( x = z â†’ ( ( ph âˆ§ âˆ€ y âˆˆ x Â¬ ps ) â†” ( [ z / x ] ph âˆ§ âˆ€ y âˆˆ z Â¬ ps ) ) ) ;;
	step 30 : wff = cbvrex (step 23, step 26, step 29) |- ( âˆƒ x âˆˆ On ( ph âˆ§ âˆ€ y âˆˆ x Â¬ ps ) â†” âˆƒ z âˆˆ On ( [ z / x ] ph âˆ§ âˆ€ y âˆˆ z Â¬ ps ) ) ;;
	step 31 : wff = sylibr (step 22, step 30) |- ( âˆƒ x âˆˆ On ph â†’ âˆƒ x âˆˆ On ( ph âˆ§ âˆ€ y âˆˆ x Â¬ ps ) ) ;;
	qed prop 1 = step 31 ;;
}

/*The class of all ordinal numbers is its own successor.  (Contributed by
     NM, 12-Sep-2003.) */

theorem sucon ()  {
	prop 1 : wff = |- suc On = On ;;
}

proof of sucon {
	step 1 : wff = onprc () |- Â¬ On âˆˆ _V ;;
	step 2 : wff = sucprc () |- ( Â¬ On âˆˆ _V â†’ suc On = On ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- suc On = On ;;
	qed prop 1 = step 3 ;;
}

/*A successor exists iff its class argument exists.  (Contributed by NM,
     22-Jun-1998.) */

theorem sucexb (A : class)  {
	prop 1 : wff = |- ( A âˆˆ _V â†” suc A âˆˆ _V ) ;;
}

proof of sucexb {
	step 1 : wff = unexb () |- ( ( A âˆˆ _V âˆ§ { A } âˆˆ _V ) â†” ( A âˆª { A } ) âˆˆ _V ) ;;
	step 2 : wff = snex () |- { A } âˆˆ _V ;;
	step 3 : wff = biantru (step 2) |- ( A âˆˆ _V â†” ( A âˆˆ _V âˆ§ { A } âˆˆ _V ) ) ;;
	step 4 : wff = df-suc () |- suc A = ( A âˆª { A } ) ;;
	step 5 : wff = eleq1i (step 4) |- ( suc A âˆˆ _V â†” ( A âˆª { A } ) âˆˆ _V ) ;;
	step 6 : wff = 3bitr4i (step 1, step 3, step 5) |- ( A âˆˆ _V â†” suc A âˆˆ _V ) ;;
	qed prop 1 = step 6 ;;
}

/*The successor of a set is a set (generalization).  (Contributed by NM,
     5-Jun-1994.) */

theorem sucexg (A : class, V : class)  {
	prop 1 : wff = |- ( A âˆˆ V â†’ suc A âˆˆ _V ) ;;
}

proof of sucexg {
	step 1 : wff = elex () |- ( A âˆˆ V â†’ A âˆˆ _V ) ;;
	step 2 : wff = sucexb () |- ( A âˆˆ _V â†” suc A âˆˆ _V ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( A âˆˆ V â†’ suc A âˆˆ _V ) ;;
	qed prop 1 = step 3 ;;
}

/*The successor of a set is a set.  (Contributed by NM, 30-Aug-1993.) */

theorem sucex (A : class)  {
	hyp 1 : wff = |- A âˆˆ _V ;;
	-----------------------
	prop 1 : wff = |- suc A âˆˆ _V ;;
}

proof of sucex {
	step 1 : wff = sucexg () |- ( A âˆˆ _V â†’ suc A âˆˆ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- suc A âˆˆ _V ;;
	qed prop 1 = step 2 ;;
}

/*The minimum of a class of ordinal numbers is less than the minimum of
       that class with its minimum removed.  (Contributed by NM,
       20-Nov-2003.) */

theorem onmindif2 (A : class) disjointed(x A) {
	prop 1 : wff = |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ â‹‚ ( A âˆ– { â‹‚ A } ) ) ;;
}

proof of onmindif2 {
	var x : set;;
	step 1 : wff = eldifsn () |- ( x âˆˆ ( A âˆ– { â‹‚ A } ) â†” ( x âˆˆ A âˆ§ x â‰  â‹‚ A ) ) ;;
	step 2 : wff = onnmin () |- ( ( A âŠ† On âˆ§ x âˆˆ A ) â†’ Â¬ x âˆˆ â‹‚ A ) ;;
	step 3 : wff = adantlr (step 2) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ Â¬ x âˆˆ â‹‚ A ) ;;
	step 4 : wff = oninton () |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ On ) ;;
	step 5 : wff = adantr (step 4) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ â‹‚ A âˆˆ On ) ;;
	step 6 : wff = ssel2 () |- ( ( A âŠ† On âˆ§ x âˆˆ A ) â†’ x âˆˆ On ) ;;
	step 7 : wff = adantlr (step 6) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ x âˆˆ On ) ;;
	step 8 : wff = ontri1 () |- ( ( â‹‚ A âˆˆ On âˆ§ x âˆˆ On ) â†’ ( â‹‚ A âŠ† x â†” Â¬ x âˆˆ â‹‚ A ) ) ;;
	step 9 : wff = onsseleq () |- ( ( â‹‚ A âˆˆ On âˆ§ x âˆˆ On ) â†’ ( â‹‚ A âŠ† x â†” ( â‹‚ A âˆˆ x âˆ¨ â‹‚ A = x ) ) ) ;;
	step 10 : wff = bitr3d (step 8, step 9) |- ( ( â‹‚ A âˆˆ On âˆ§ x âˆˆ On ) â†’ ( Â¬ x âˆˆ â‹‚ A â†” ( â‹‚ A âˆˆ x âˆ¨ â‹‚ A = x ) ) ) ;;
	step 11 : wff = syl2anc (step 5, step 7, step 10) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ ( Â¬ x âˆˆ â‹‚ A â†” ( â‹‚ A âˆˆ x âˆ¨ â‹‚ A = x ) ) ) ;;
	step 12 : wff = mpbid (step 3, step 11) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ ( â‹‚ A âˆˆ x âˆ¨ â‹‚ A = x ) ) ;;
	step 13 : wff = ord (step 12) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ ( Â¬ â‹‚ A âˆˆ x â†’ â‹‚ A = x ) ) ;;
	step 14 : wff = eqcom () |- ( â‹‚ A = x â†” x = â‹‚ A ) ;;
	step 15 : wff = syl6ib (step 13, step 14) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ ( Â¬ â‹‚ A âˆˆ x â†’ x = â‹‚ A ) ) ;;
	step 16 : wff = necon1ad (step 15) |- ( ( ( A âŠ† On âˆ§ A â‰  âˆ… ) âˆ§ x âˆˆ A ) â†’ ( x â‰  â‹‚ A â†’ â‹‚ A âˆˆ x ) ) ;;
	step 17 : wff = expimpd (step 16) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ ( ( x âˆˆ A âˆ§ x â‰  â‹‚ A ) â†’ â‹‚ A âˆˆ x ) ) ;;
	step 18 : wff = syl5bi (step 1, step 17) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ ( x âˆˆ ( A âˆ– { â‹‚ A } ) â†’ â‹‚ A âˆˆ x ) ) ;;
	step 19 : wff = ralrimiv (step 18) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ âˆ€ x âˆˆ ( A âˆ– { â‹‚ A } ) â‹‚ A âˆˆ x ) ;;
	step 20 : wff = intex () |- ( A â‰  âˆ… â†” â‹‚ A âˆˆ _V ) ;;
	step 21 : wff = elintg () |- ( â‹‚ A âˆˆ _V â†’ ( â‹‚ A âˆˆ â‹‚ ( A âˆ– { â‹‚ A } ) â†” âˆ€ x âˆˆ ( A âˆ– { â‹‚ A } ) â‹‚ A âˆˆ x ) ) ;;
	step 22 : wff = sylbi (step 20, step 21) |- ( A â‰  âˆ… â†’ ( â‹‚ A âˆˆ â‹‚ ( A âˆ– { â‹‚ A } ) â†” âˆ€ x âˆˆ ( A âˆ– { â‹‚ A } ) â‹‚ A âˆˆ x ) ) ;;
	step 23 : wff = adantl (step 22) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ ( â‹‚ A âˆˆ â‹‚ ( A âˆ– { â‹‚ A } ) â†” âˆ€ x âˆˆ ( A âˆ– { â‹‚ A } ) â‹‚ A âˆˆ x ) ) ;;
	step 24 : wff = mpbird (step 19, step 23) |- ( ( A âŠ† On âˆ§ A â‰  âˆ… ) â†’ â‹‚ A âˆˆ â‹‚ ( A âˆ– { â‹‚ A } ) ) ;;
	qed prop 1 = step 24 ;;
}

/*The successor of an ordinal number is an ordinal number.  Proposition
       7.24 of [TakeutiZaring] p. 41.  (Contributed by NM, 6-Jun-1994.) */

theorem suceloni (A : class) disjointed(x A) {
	prop 1 : wff = |- ( A âˆˆ On â†’ suc A âˆˆ On ) ;;
}

proof of suceloni {
	var x : set;;
	step 1 : wff = onelss () |- ( A âˆˆ On â†’ ( x âˆˆ A â†’ x âŠ† A ) ) ;;
	step 2 : wff = elsn () |- ( x âˆˆ { A } â†” x = A ) ;;
	step 3 : wff = eqimss () |- ( x = A â†’ x âŠ† A ) ;;
	step 4 : wff = sylbi (step 2, step 3) |- ( x âˆˆ { A } â†’ x âŠ† A ) ;;
	step 5 : wff = a1i (step 4) |- ( A âˆˆ On â†’ ( x âˆˆ { A } â†’ x âŠ† A ) ) ;;
	step 6 : wff = orim12d (step 1, step 5) |- ( A âˆˆ On â†’ ( ( x âˆˆ A âˆ¨ x âˆˆ { A } ) â†’ ( x âŠ† A âˆ¨ x âŠ† A ) ) ) ;;
	step 7 : wff = df-suc () |- suc A = ( A âˆª { A } ) ;;
	step 8 : wff = eleq2i (step 7) |- ( x âˆˆ suc A â†” x âˆˆ ( A âˆª { A } ) ) ;;
	step 9 : wff = elun () |- ( x âˆˆ ( A âˆª { A } ) â†” ( x âˆˆ A âˆ¨ x âˆˆ { A } ) ) ;;
	step 10 : wff = bitr2i (step 8, step 9) |- ( ( x âˆˆ A âˆ¨ x âˆˆ { A } ) â†” x âˆˆ suc A ) ;;
	step 11 : wff = oridm () |- ( ( x âŠ† A âˆ¨ x âŠ† A ) â†” x âŠ† A ) ;;
	step 12 : wff = 3imtr3g (step 6, step 10, step 11) |- ( A âˆˆ On â†’ ( x âˆˆ suc A â†’ x âŠ† A ) ) ;;
	step 13 : wff = sssucid () |- A âŠ† suc A ;;
	step 14 : wff = sstr2 () |- ( x âŠ† A â†’ ( A âŠ† suc A â†’ x âŠ† suc A ) ) ;;
	step 15 : wff = syl6mpi (step 12, step 13, step 14) |- ( A âˆˆ On â†’ ( x âˆˆ suc A â†’ x âŠ† suc A ) ) ;;
	step 16 : wff = ralrimiv (step 15) |- ( A âˆˆ On â†’ âˆ€ x âˆˆ suc A x âŠ† suc A ) ;;
	step 17 : wff = dftr3 () |- ( Tr suc A â†” âˆ€ x âˆˆ suc A x âŠ† suc A ) ;;
	step 18 : wff = sylibr (step 16, step 17) |- ( A âˆˆ On â†’ Tr suc A ) ;;
	step 19 : wff = df-suc () |- suc A = ( A âˆª { A } ) ;;
	step 20 : wff = onss () |- ( A âˆˆ On â†’ A âŠ† On ) ;;
	step 21 : wff = snssi () |- ( A âˆˆ On â†’ { A } âŠ† On ) ;;
	step 22 : wff = unssd (step 20, step 21) |- ( A âˆˆ On â†’ ( A âˆª { A } ) âŠ† On ) ;;
	step 23 : wff = syl5eqss (step 19, step 22) |- ( A âˆˆ On â†’ suc A âŠ† On ) ;;
	step 24 : wff = ordon () |- Ord On ;;
	step 25 : wff = trssord () |- ( ( Tr suc A âˆ§ suc A âŠ† On âˆ§ Ord On ) â†’ Ord suc A ) ;;
	step 26 : wff = 3exp (step 25) |- ( Tr suc A â†’ ( suc A âŠ† On â†’ ( Ord On â†’ Ord suc A ) ) ) ;;
	step 27 : wff = mpii (step 24, step 26) |- ( Tr suc A â†’ ( suc A âŠ† On â†’ Ord suc A ) ) ;;
	step 28 : wff = sylc (step 18, step 23, step 27) |- ( A âˆˆ On â†’ Ord suc A ) ;;
	step 29 : wff = sucexg () |- ( A âˆˆ On â†’ suc A âˆˆ _V ) ;;
	step 30 : wff = elong () |- ( suc A âˆˆ _V â†’ ( suc A âˆˆ On â†” Ord suc A ) ) ;;
	step 31 : wff = syl (step 29, step 30) |- ( A âˆˆ On â†’ ( suc A âˆˆ On â†” Ord suc A ) ) ;;
	step 32 : wff = mpbird (step 28, step 31) |- ( A âˆˆ On â†’ suc A âˆˆ On ) ;;
	qed prop 1 = step 32 ;;
}

/*The successor of an ordinal class is ordinal.  (Contributed by NM,
     3-Apr-1995.) */

theorem ordsuc (A : class)  {
	prop 1 : wff = |- ( Ord A â†” Ord suc A ) ;;
}

proof of ordsuc {
	step 1 : wff = elong () |- ( A âˆˆ _V â†’ ( A âˆˆ On â†” Ord A ) ) ;;
	step 2 : wff = suceloni () |- ( A âˆˆ On â†’ suc A âˆˆ On ) ;;
	step 3 : wff = eloni () |- ( suc A âˆˆ On â†’ Ord suc A ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( A âˆˆ On â†’ Ord suc A ) ;;
	step 5 : wff = syl6bir (step 1, step 4) |- ( A âˆˆ _V â†’ ( Ord A â†’ Ord suc A ) ) ;;
	step 6 : wff = sucidg () |- ( A âˆˆ _V â†’ A âˆˆ suc A ) ;;
	step 7 : wff = ordelord () |- ( ( Ord suc A âˆ§ A âˆˆ suc A ) â†’ Ord A ) ;;
	step 8 : wff = ex (step 7) |- ( Ord suc A â†’ ( A âˆˆ suc A â†’ Ord A ) ) ;;
	step 9 : wff = syl5com (step 6, step 8) |- ( A âˆˆ _V â†’ ( Ord suc A â†’ Ord A ) ) ;;
	step 10 : wff = impbid (step 5, step 9) |- ( A âˆˆ _V â†’ ( Ord A â†” Ord suc A ) ) ;;
	step 11 : wff = sucprc () |- ( Â¬ A âˆˆ _V â†’ suc A = A ) ;;
	step 12 : wff = eqcomd (step 11) |- ( Â¬ A âˆˆ _V â†’ A = suc A ) ;;
	step 13 : wff = ordeq () |- ( A = suc A â†’ ( Ord A â†” Ord suc A ) ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( Â¬ A âˆˆ _V â†’ ( Ord A â†” Ord suc A ) ) ;;
	step 15 : wff = pm2.61i (step 10, step 14) |- ( Ord A â†” Ord suc A ) ;;
	qed prop 1 = step 15 ;;
}

/*The collection of ordinals in the power class of an ordinal is its
       successor.  (Contributed by NM, 30-Jan-2005.) */

theorem ordpwsuc (A : class) disjointed(x A) {
	prop 1 : wff = |- ( Ord A â†’ ( Pow A âˆ© On ) = suc A ) ;;
}

proof of ordpwsuc {
	var x : set;;
	step 1 : wff = elin () |- ( x âˆˆ ( Pow A âˆ© On ) â†” ( x âˆˆ Pow A âˆ§ x âˆˆ On ) ) ;;
	step 2 : wff = vex () |- x âˆˆ _V ;;
	step 3 : wff = elpw (step 2) |- ( x âˆˆ Pow A â†” x âŠ† A ) ;;
	step 4 : wff = anbi2ci (step 3) |- ( ( x âˆˆ Pow A âˆ§ x âˆˆ On ) â†” ( x âˆˆ On âˆ§ x âŠ† A ) ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( x âˆˆ ( Pow A âˆ© On ) â†” ( x âˆˆ On âˆ§ x âŠ† A ) ) ;;
	step 6 : wff = ordsssuc () |- ( ( x âˆˆ On âˆ§ Ord A ) â†’ ( x âŠ† A â†” x âˆˆ suc A ) ) ;;
	step 7 : wff = expcom (step 6) |- ( Ord A â†’ ( x âˆˆ On â†’ ( x âŠ† A â†” x âˆˆ suc A ) ) ) ;;
	step 8 : wff = pm5.32d (step 7) |- ( Ord A â†’ ( ( x âˆˆ On âˆ§ x âŠ† A ) â†” ( x âˆˆ On âˆ§ x âˆˆ suc A ) ) ) ;;
	step 9 : wff = simpr () |- ( ( x âˆˆ On âˆ§ x âˆˆ suc A ) â†’ x âˆˆ suc A ) ;;
	step 10 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 11 : wff = ordelon () |- ( ( Ord suc A âˆ§ x âˆˆ suc A ) â†’ x âˆˆ On ) ;;
	step 12 : wff = ex (step 11) |- ( Ord suc A â†’ ( x âˆˆ suc A â†’ x âˆˆ On ) ) ;;
	step 13 : wff = sylbi (step 10, step 12) |- ( Ord A â†’ ( x âˆˆ suc A â†’ x âˆˆ On ) ) ;;
	step 14 : wff = ancrd (step 13) |- ( Ord A â†’ ( x âˆˆ suc A â†’ ( x âˆˆ On âˆ§ x âˆˆ suc A ) ) ) ;;
	step 15 : wff = impbid2 (step 9, step 14) |- ( Ord A â†’ ( ( x âˆˆ On âˆ§ x âˆˆ suc A ) â†” x âˆˆ suc A ) ) ;;
	step 16 : wff = bitrd (step 8, step 15) |- ( Ord A â†’ ( ( x âˆˆ On âˆ§ x âŠ† A ) â†” x âˆˆ suc A ) ) ;;
	step 17 : wff = syl5bb (step 5, step 16) |- ( Ord A â†’ ( x âˆˆ ( Pow A âˆ© On ) â†” x âˆˆ suc A ) ) ;;
	step 18 : wff = eqrdv (step 17) |- ( Ord A â†’ ( Pow A âˆ© On ) = suc A ) ;;
	qed prop 1 = step 18 ;;
}

/*The collection of ordinal numbers in the power set of an ordinal number
       is its successor.  (Contributed by NM, 19-Oct-2004.) */

theorem onpwsuc (A : class) disjointed(A) {
	prop 1 : wff = |- ( A âˆˆ On â†’ ( Pow A âˆ© On ) = suc A ) ;;
}

proof of onpwsuc {
	step 1 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 2 : wff = ordpwsuc () |- ( Ord A â†’ ( Pow A âˆ© On ) = suc A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A âˆˆ On â†’ ( Pow A âˆ© On ) = suc A ) ;;
	qed prop 1 = step 3 ;;
}

/*The successor of an ordinal number is an ordinal number.  (Contributed by
     NM, 9-Sep-2003.) */

theorem sucelon (A : class)  {
	prop 1 : wff = |- ( A âˆˆ On â†” suc A âˆˆ On ) ;;
}

proof of sucelon {
	step 1 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 2 : wff = sucexb () |- ( A âˆˆ _V â†” suc A âˆˆ _V ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( Ord A âˆ§ A âˆˆ _V ) â†” ( Ord suc A âˆ§ suc A âˆˆ _V ) ) ;;
	step 4 : wff = elon2 () |- ( A âˆˆ On â†” ( Ord A âˆ§ A âˆˆ _V ) ) ;;
	step 5 : wff = elon2 () |- ( suc A âˆˆ On â†” ( Ord suc A âˆ§ suc A âˆˆ _V ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( A âˆˆ On â†” suc A âˆˆ On ) ;;
	qed prop 1 = step 6 ;;
}

/*The successor of an element of an ordinal class is a subset of it.
     (Contributed by NM, 21-Jun-1998.) */

theorem ordsucss (A : class, B : class)  {
	prop 1 : wff = |- ( Ord B â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
}

proof of ordsucss {
	step 1 : wff = ordelord () |- ( ( Ord B âˆ§ A âˆˆ B ) â†’ Ord A ) ;;
	step 2 : wff = ordnbtwn () |- ( Ord A â†’ Â¬ ( A âˆˆ B âˆ§ B âˆˆ suc A ) ) ;;
	step 3 : wff = imnan () |- ( ( A âˆˆ B â†’ Â¬ B âˆˆ suc A ) â†” Â¬ ( A âˆˆ B âˆ§ B âˆˆ suc A ) ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( Ord A â†’ ( A âˆˆ B â†’ Â¬ B âˆˆ suc A ) ) ;;
	step 5 : wff = adantr (step 4) |- ( ( Ord A âˆ§ Ord B ) â†’ ( A âˆˆ B â†’ Â¬ B âˆˆ suc A ) ) ;;
	step 6 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 7 : wff = ordtri1 () |- ( ( Ord suc A âˆ§ Ord B ) â†’ ( suc A âŠ† B â†” Â¬ B âˆˆ suc A ) ) ;;
	step 8 : wff = sylanb (step 6, step 7) |- ( ( Ord A âˆ§ Ord B ) â†’ ( suc A âŠ† B â†” Â¬ B âˆˆ suc A ) ) ;;
	step 9 : wff = sylibrd (step 5, step 8) |- ( ( Ord A âˆ§ Ord B ) â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	step 10 : wff = sylan (step 1, step 9) |- ( ( ( Ord B âˆ§ A âˆˆ B ) âˆ§ Ord B ) â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	step 11 : wff = exp31 (step 10) |- ( Ord B â†’ ( A âˆˆ B â†’ ( Ord B â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ) ) ;;
	step 12 : wff = pm2.43b (step 11) |- ( A âˆˆ B â†’ ( Ord B â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ) ;;
	step 13 : wff = pm2.43b (step 12) |- ( Ord B â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	qed prop 1 = step 13 ;;
}

/*An ordinal number is a proper subset of its successor.  (Contributed by
     Stefan O'Rear, 18-Nov-2014.) */

theorem onpsssuc (A : class)  {
	prop 1 : wff = |- ( A âˆˆ On â†’ A âŠ‚ suc A ) ;;
}

proof of onpsssuc {
	step 1 : wff = sucidg () |- ( A âˆˆ On â†’ A âˆˆ suc A ) ;;
	step 2 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 3 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 4 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 5 : wff = sylib (step 3, step 4) |- ( A âˆˆ On â†’ Ord suc A ) ;;
	step 6 : wff = ordelpss () |- ( ( Ord A âˆ§ Ord suc A ) â†’ ( A âˆˆ suc A â†” A âŠ‚ suc A ) ) ;;
	step 7 : wff = syl2anc (step 2, step 5, step 6) |- ( A âˆˆ On â†’ ( A âˆˆ suc A â†” A âŠ‚ suc A ) ) ;;
	step 8 : wff = mpbid (step 1, step 7) |- ( A âˆˆ On â†’ A âŠ‚ suc A ) ;;
	qed prop 1 = step 8 ;;
}

/*A set belongs to an ordinal iff its successor is a subset of the ordinal.
     Exercise 8 of [TakeutiZaring] p. 42 and its converse.  (Contributed by NM,
     29-Nov-2003.) */

theorem ordelsuc (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A âˆˆ C âˆ§ Ord B ) â†’ ( A âˆˆ B â†” suc A âŠ† B ) ) ;;
}

proof of ordelsuc {
	step 1 : wff = ordsucss () |- ( Ord B â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	step 2 : wff = adantl (step 1) |- ( ( A âˆˆ C âˆ§ Ord B ) â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	step 3 : wff = sucssel () |- ( A âˆˆ C â†’ ( suc A âŠ† B â†’ A âˆˆ B ) ) ;;
	step 4 : wff = adantr (step 3) |- ( ( A âˆˆ C âˆ§ Ord B ) â†’ ( suc A âŠ† B â†’ A âˆˆ B ) ) ;;
	step 5 : wff = impbid (step 2, step 4) |- ( ( A âˆˆ C âˆ§ Ord B ) â†’ ( A âˆˆ B â†” suc A âŠ† B ) ) ;;
	qed prop 1 = step 5 ;;
}

/*The successor of an ordinal number is the smallest larger ordinal
       number.  (Contributed by NM, 28-Nov-2003.) */

theorem onsucmin (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( A âˆˆ On â†’ suc A = â‹‚ { x âˆˆ On | A âˆˆ x } ) ;;
}

proof of onsucmin {
	step 1 : wff = eloni () |- ( x âˆˆ On â†’ Ord x ) ;;
	step 2 : wff = ordelsuc () |- ( ( A âˆˆ On âˆ§ Ord x ) â†’ ( A âˆˆ x â†” suc A âŠ† x ) ) ;;
	step 3 : wff = sylan2 (step 1, step 2) |- ( ( A âˆˆ On âˆ§ x âˆˆ On ) â†’ ( A âˆˆ x â†” suc A âŠ† x ) ) ;;
	step 4 : wff = rabbidva (step 3) |- ( A âˆˆ On â†’ { x âˆˆ On | A âˆˆ x } = { x âˆˆ On | suc A âŠ† x } ) ;;
	step 5 : wff = inteqd (step 4) |- ( A âˆˆ On â†’ â‹‚ { x âˆˆ On | A âˆˆ x } = â‹‚ { x âˆˆ On | suc A âŠ† x } ) ;;
	step 6 : wff = sucelon () |- ( A âˆˆ On â†” suc A âˆˆ On ) ;;
	step 7 : wff = intmin () |- ( suc A âˆˆ On â†’ â‹‚ { x âˆˆ On | suc A âŠ† x } = suc A ) ;;
	step 8 : wff = sylbi (step 6, step 7) |- ( A âˆˆ On â†’ â‹‚ { x âˆˆ On | suc A âŠ† x } = suc A ) ;;
	step 9 : wff = eqtr2d (step 5, step 8) |- ( A âˆˆ On â†’ suc A = â‹‚ { x âˆˆ On | A âˆˆ x } ) ;;
	qed prop 1 = step 9 ;;
}

/*Membership is inherited by successors.  Generalization of Exercise 9 of
     [TakeutiZaring] p. 42.  (Contributed by NM, 22-Jun-1998.)  (Proof
     shortened by Andrew Salmon, 12-Aug-2011.) */

theorem ordsucelsuc (A : class, B : class)  {
	prop 1 : wff = |- ( Ord B â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ;;
}

proof of ordsucelsuc {
	step 1 : wff = simpl () |- ( ( Ord B âˆ§ A âˆˆ B ) â†’ Ord B ) ;;
	step 2 : wff = ordelord () |- ( ( Ord B âˆ§ A âˆˆ B ) â†’ Ord A ) ;;
	step 3 : wff = jca (step 1, step 2) |- ( ( Ord B âˆ§ A âˆˆ B ) â†’ ( Ord B âˆ§ Ord A ) ) ;;
	step 4 : wff = simpl () |- ( ( Ord B âˆ§ suc A âˆˆ suc B ) â†’ Ord B ) ;;
	step 5 : wff = ordsuc () |- ( Ord B â†” Ord suc B ) ;;
	step 6 : wff = ordelord () |- ( ( Ord suc B âˆ§ suc A âˆˆ suc B ) â†’ Ord suc A ) ;;
	step 7 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( Ord suc B âˆ§ suc A âˆˆ suc B ) â†’ Ord A ) ;;
	step 9 : wff = sylanb (step 5, step 8) |- ( ( Ord B âˆ§ suc A âˆˆ suc B ) â†’ Ord A ) ;;
	step 10 : wff = jca (step 4, step 9) |- ( ( Ord B âˆ§ suc A âˆˆ suc B ) â†’ ( Ord B âˆ§ Ord A ) ) ;;
	step 11 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 12 : wff = ordsseleq () |- ( ( Ord suc A âˆ§ Ord B ) â†’ ( suc A âŠ† B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 13 : wff = sylanb (step 11, step 12) |- ( ( Ord A âˆ§ Ord B ) â†’ ( suc A âŠ† B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 14 : wff = ancoms (step 13) |- ( ( Ord B âˆ§ Ord A ) â†’ ( suc A âŠ† B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 15 : wff = adantl (step 14) |- ( ( A âˆˆ _V âˆ§ ( Ord B âˆ§ Ord A ) ) â†’ ( suc A âŠ† B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 16 : wff = ordsucss () |- ( Ord B â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	step 17 : wff = ad2antrl (step 16) |- ( ( A âˆˆ _V âˆ§ ( Ord B âˆ§ Ord A ) ) â†’ ( A âˆˆ B â†’ suc A âŠ† B ) ) ;;
	step 18 : wff = sucssel () |- ( A âˆˆ _V â†’ ( suc A âŠ† B â†’ A âˆˆ B ) ) ;;
	step 19 : wff = adantr (step 18) |- ( ( A âˆˆ _V âˆ§ ( Ord B âˆ§ Ord A ) ) â†’ ( suc A âŠ† B â†’ A âˆˆ B ) ) ;;
	step 20 : wff = impbid (step 17, step 19) |- ( ( A âˆˆ _V âˆ§ ( Ord B âˆ§ Ord A ) ) â†’ ( A âˆˆ B â†” suc A âŠ† B ) ) ;;
	step 21 : wff = sucexb () |- ( A âˆˆ _V â†” suc A âˆˆ _V ) ;;
	step 22 : wff = elsucg () |- ( suc A âˆˆ _V â†’ ( suc A âˆˆ suc B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 23 : wff = sylbi (step 21, step 22) |- ( A âˆˆ _V â†’ ( suc A âˆˆ suc B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 24 : wff = adantr (step 23) |- ( ( A âˆˆ _V âˆ§ ( Ord B âˆ§ Ord A ) ) â†’ ( suc A âˆˆ suc B â†” ( suc A âˆˆ B âˆ¨ suc A = B ) ) ) ;;
	step 25 : wff = 3bitr4d (step 15, step 20, step 24) |- ( ( A âˆˆ _V âˆ§ ( Ord B âˆ§ Ord A ) ) â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ;;
	step 26 : wff = ex (step 25) |- ( A âˆˆ _V â†’ ( ( Ord B âˆ§ Ord A ) â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ) ;;
	step 27 : wff = elex () |- ( A âˆˆ B â†’ A âˆˆ _V ) ;;
	step 28 : wff = elex () |- ( suc A âˆˆ suc B â†’ suc A âˆˆ _V ) ;;
	step 29 : wff = sucexb () |- ( A âˆˆ _V â†” suc A âˆˆ _V ) ;;
	step 30 : wff = sylibr (step 28, step 29) |- ( suc A âˆˆ suc B â†’ A âˆˆ _V ) ;;
	step 31 : wff = pm5.21ni (step 27, step 30) |- ( Â¬ A âˆˆ _V â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ;;
	step 32 : wff = a1d (step 31) |- ( Â¬ A âˆˆ _V â†’ ( ( Ord B âˆ§ Ord A ) â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ) ;;
	step 33 : wff = pm2.61i (step 26, step 32) |- ( ( Ord B âˆ§ Ord A ) â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ;;
	step 34 : wff = pm5.21nd (step 3, step 10, step 33) |- ( Ord B â†’ ( A âˆˆ B â†” suc A âˆˆ suc B ) ) ;;
	qed prop 1 = step 34 ;;
}

/*The subclass relationship between two ordinal classes is inherited by
     their successors.  (Contributed by NM, 4-Oct-2003.) */

theorem ordsucsssuc (A : class, B : class)  {
	prop 1 : wff = |- ( ( Ord A âˆ§ Ord B ) â†’ ( A âŠ† B â†” suc A âŠ† suc B ) ) ;;
}

proof of ordsucsssuc {
	step 1 : wff = ordsucelsuc () |- ( Ord A â†’ ( B âˆˆ A â†” suc B âˆˆ suc A ) ) ;;
	step 2 : wff = notbid (step 1) |- ( Ord A â†’ ( Â¬ B âˆˆ A â†” Â¬ suc B âˆˆ suc A ) ) ;;
	step 3 : wff = adantr (step 2) |- ( ( Ord A âˆ§ Ord B ) â†’ ( Â¬ B âˆˆ A â†” Â¬ suc B âˆˆ suc A ) ) ;;
	step 4 : wff = ordtri1 () |- ( ( Ord A âˆ§ Ord B ) â†’ ( A âŠ† B â†” Â¬ B âˆˆ A ) ) ;;
	step 5 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 6 : wff = ordsuc () |- ( Ord B â†” Ord suc B ) ;;
	step 7 : wff = ordtri1 () |- ( ( Ord suc A âˆ§ Ord suc B ) â†’ ( suc A âŠ† suc B â†” Â¬ suc B âˆˆ suc A ) ) ;;
	step 8 : wff = syl2anb (step 5, step 6, step 7) |- ( ( Ord A âˆ§ Ord B ) â†’ ( suc A âŠ† suc B â†” Â¬ suc B âˆˆ suc A ) ) ;;
	step 9 : wff = 3bitr4d (step 3, step 4, step 8) |- ( ( Ord A âˆ§ Ord B ) â†’ ( A âŠ† B â†” suc A âŠ† suc B ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Given an element ` A ` of the union of an ordinal ` B ` , ` suc A ` is an
     element of ` B ` itself.  (Contributed by Scott Fenton, 28-Mar-2012.)
     (Proof shortened by Mario Carneiro, 29-May-2015.) */

theorem ordsucuniel (A : class, B : class)  {
	prop 1 : wff = |- ( Ord B â†’ ( A âˆˆ â‹ƒ B â†” suc A âˆˆ B ) ) ;;
}

proof of ordsucuniel {
	step 1 : wff = orduni () |- ( Ord B â†’ Ord â‹ƒ B ) ;;
	step 2 : wff = ordelord () |- ( ( Ord â‹ƒ B âˆ§ A âˆˆ â‹ƒ B ) â†’ Ord A ) ;;
	step 3 : wff = ex (step 2) |- ( Ord â‹ƒ B â†’ ( A âˆˆ â‹ƒ B â†’ Ord A ) ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( Ord B â†’ ( A âˆˆ â‹ƒ B â†’ Ord A ) ) ;;
	step 5 : wff = ordelord () |- ( ( Ord B âˆ§ suc A âˆˆ B ) â†’ Ord suc A ) ;;
	step 6 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 7 : wff = sylibr (step 5, step 6) |- ( ( Ord B âˆ§ suc A âˆˆ B ) â†’ Ord A ) ;;
	step 8 : wff = ex (step 7) |- ( Ord B â†’ ( suc A âˆˆ B â†’ Ord A ) ) ;;
	step 9 : wff = ordsson () |- ( Ord B â†’ B âŠ† On ) ;;
	step 10 : wff = ordunisssuc () |- ( ( B âŠ† On âˆ§ Ord A ) â†’ ( â‹ƒ B âŠ† A â†” B âŠ† suc A ) ) ;;
	step 11 : wff = sylan (step 9, step 10) |- ( ( Ord B âˆ§ Ord A ) â†’ ( â‹ƒ B âŠ† A â†” B âŠ† suc A ) ) ;;
	step 12 : wff = orduni () |- ( Ord B â†’ Ord â‹ƒ B ) ;;
	step 13 : wff = ordtri1 () |- ( ( Ord â‹ƒ B âˆ§ Ord A ) â†’ ( â‹ƒ B âŠ† A â†” Â¬ A âˆˆ â‹ƒ B ) ) ;;
	step 14 : wff = sylan (step 12, step 13) |- ( ( Ord B âˆ§ Ord A ) â†’ ( â‹ƒ B âŠ† A â†” Â¬ A âˆˆ â‹ƒ B ) ) ;;
	step 15 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 16 : wff = ordtri1 () |- ( ( Ord B âˆ§ Ord suc A ) â†’ ( B âŠ† suc A â†” Â¬ suc A âˆˆ B ) ) ;;
	step 17 : wff = sylan2b (step 15, step 16) |- ( ( Ord B âˆ§ Ord A ) â†’ ( B âŠ† suc A â†” Â¬ suc A âˆˆ B ) ) ;;
	step 18 : wff = 3bitr3d (step 11, step 14, step 17) |- ( ( Ord B âˆ§ Ord A ) â†’ ( Â¬ A âˆˆ â‹ƒ B â†” Â¬ suc A âˆˆ B ) ) ;;
	step 19 : wff = con4bid (step 18) |- ( ( Ord B âˆ§ Ord A ) â†’ ( A âˆˆ â‹ƒ B â†” suc A âˆˆ B ) ) ;;
	step 20 : wff = ex (step 19) |- ( Ord B â†’ ( Ord A â†’ ( A âˆˆ â‹ƒ B â†” suc A âˆˆ B ) ) ) ;;
	step 21 : wff = pm5.21ndd (step 4, step 8, step 20) |- ( Ord B â†’ ( A âˆˆ â‹ƒ B â†” suc A âˆˆ B ) ) ;;
	qed prop 1 = step 21 ;;
}

/*The successor of the maximum (i.e. union) of two ordinals is the maximum
       of their successors.  (Contributed by NM, 28-Nov-2003.) */

theorem ordsucun (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( Ord A âˆ§ Ord B ) â†’ suc ( A âˆª B ) = ( suc A âˆª suc B ) ) ;;
}

proof of ordsucun {
	var x : set;;
	step 1 : wff = ordun () |- ( ( Ord A âˆ§ Ord B ) â†’ Ord ( A âˆª B ) ) ;;
	step 2 : wff = ordsuc () |- ( Ord ( A âˆª B ) â†” Ord suc ( A âˆª B ) ) ;;
	step 3 : wff = ordelon () |- ( ( Ord suc ( A âˆª B ) âˆ§ x âˆˆ suc ( A âˆª B ) ) â†’ x âˆˆ On ) ;;
	step 4 : wff = ex (step 3) |- ( Ord suc ( A âˆª B ) â†’ ( x âˆˆ suc ( A âˆª B ) â†’ x âˆˆ On ) ) ;;
	step 5 : wff = sylbi (step 2, step 4) |- ( Ord ( A âˆª B ) â†’ ( x âˆˆ suc ( A âˆª B ) â†’ x âˆˆ On ) ) ;;
	step 6 : wff = syl (step 1, step 5) |- ( ( Ord A âˆ§ Ord B ) â†’ ( x âˆˆ suc ( A âˆª B ) â†’ x âˆˆ On ) ) ;;
	step 7 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 8 : wff = ordsuc () |- ( Ord B â†” Ord suc B ) ;;
	step 9 : wff = ordun () |- ( ( Ord suc A âˆ§ Ord suc B ) â†’ Ord ( suc A âˆª suc B ) ) ;;
	step 10 : wff = ordelon () |- ( ( Ord ( suc A âˆª suc B ) âˆ§ x âˆˆ ( suc A âˆª suc B ) ) â†’ x âˆˆ On ) ;;
	step 11 : wff = ex (step 10) |- ( Ord ( suc A âˆª suc B ) â†’ ( x âˆˆ ( suc A âˆª suc B ) â†’ x âˆˆ On ) ) ;;
	step 12 : wff = syl (step 9, step 11) |- ( ( Ord suc A âˆ§ Ord suc B ) â†’ ( x âˆˆ ( suc A âˆª suc B ) â†’ x âˆˆ On ) ) ;;
	step 13 : wff = syl2anb (step 7, step 8, step 12) |- ( ( Ord A âˆ§ Ord B ) â†’ ( x âˆˆ ( suc A âˆª suc B ) â†’ x âˆˆ On ) ) ;;
	step 14 : wff = ordssun () |- ( ( Ord A âˆ§ Ord B ) â†’ ( x âŠ† ( A âˆª B ) â†” ( x âŠ† A âˆ¨ x âŠ† B ) ) ) ;;
	step 15 : wff = adantl (step 14) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( x âŠ† ( A âˆª B ) â†” ( x âŠ† A âˆ¨ x âŠ† B ) ) ) ;;
	step 16 : wff = ordun () |- ( ( Ord A âˆ§ Ord B ) â†’ Ord ( A âˆª B ) ) ;;
	step 17 : wff = ordsssuc () |- ( ( x âˆˆ On âˆ§ Ord ( A âˆª B ) ) â†’ ( x âŠ† ( A âˆª B ) â†” x âˆˆ suc ( A âˆª B ) ) ) ;;
	step 18 : wff = sylan2 (step 16, step 17) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( x âŠ† ( A âˆª B ) â†” x âˆˆ suc ( A âˆª B ) ) ) ;;
	step 19 : wff = ordsssuc () |- ( ( x âˆˆ On âˆ§ Ord A ) â†’ ( x âŠ† A â†” x âˆˆ suc A ) ) ;;
	step 20 : wff = adantrr (step 19) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( x âŠ† A â†” x âˆˆ suc A ) ) ;;
	step 21 : wff = ordsssuc () |- ( ( x âˆˆ On âˆ§ Ord B ) â†’ ( x âŠ† B â†” x âˆˆ suc B ) ) ;;
	step 22 : wff = adantrl (step 21) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( x âŠ† B â†” x âˆˆ suc B ) ) ;;
	step 23 : wff = orbi12d (step 20, step 22) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( ( x âŠ† A âˆ¨ x âŠ† B ) â†” ( x âˆˆ suc A âˆ¨ x âˆˆ suc B ) ) ) ;;
	step 24 : wff = 3bitr3d (step 15, step 18, step 23) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( x âˆˆ suc ( A âˆª B ) â†” ( x âˆˆ suc A âˆ¨ x âˆˆ suc B ) ) ) ;;
	step 25 : wff = elun () |- ( x âˆˆ ( suc A âˆª suc B ) â†” ( x âˆˆ suc A âˆ¨ x âˆˆ suc B ) ) ;;
	step 26 : wff = syl6bbr (step 24, step 25) |- ( ( x âˆˆ On âˆ§ ( Ord A âˆ§ Ord B ) ) â†’ ( x âˆˆ suc ( A âˆª B ) â†” x âˆˆ ( suc A âˆª suc B ) ) ) ;;
	step 27 : wff = expcom (step 26) |- ( ( Ord A âˆ§ Ord B ) â†’ ( x âˆˆ On â†’ ( x âˆˆ suc ( A âˆª B ) â†” x âˆˆ ( suc A âˆª suc B ) ) ) ) ;;
	step 28 : wff = pm5.21ndd (step 6, step 13, step 27) |- ( ( Ord A âˆ§ Ord B ) â†’ ( x âˆˆ suc ( A âˆª B ) â†” x âˆˆ ( suc A âˆª suc B ) ) ) ;;
	step 29 : wff = eqrdv (step 28) |- ( ( Ord A âˆ§ Ord B ) â†’ suc ( A âˆª B ) = ( suc A âˆª suc B ) ) ;;
	qed prop 1 = step 29 ;;
}

/*The maximum of two ordinals is equal to one of them.  (Contributed by
     Mario Carneiro, 25-Jun-2015.) */

theorem ordunpr (B : class, C : class)  {
	prop 1 : wff = |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( B âˆª C ) âˆˆ { B , C } ) ;;
}

proof of ordunpr {
	step 1 : wff = eloni () |- ( B âˆˆ On â†’ Ord B ) ;;
	step 2 : wff = eloni () |- ( C âˆˆ On â†’ Ord C ) ;;
	step 3 : wff = ordtri2or2 () |- ( ( Ord B âˆ§ Ord C ) â†’ ( B âŠ† C âˆ¨ C âŠ† B ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( B âŠ† C âˆ¨ C âŠ† B ) ) ;;
	step 5 : wff = orcomd (step 4) |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( C âŠ† B âˆ¨ B âŠ† C ) ) ;;
	step 6 : wff = ssequn2 () |- ( C âŠ† B â†” ( B âˆª C ) = B ) ;;
	step 7 : wff = ssequn1 () |- ( B âŠ† C â†” ( B âˆª C ) = C ) ;;
	step 8 : wff = orbi12i (step 6, step 7) |- ( ( C âŠ† B âˆ¨ B âŠ† C ) â†” ( ( B âˆª C ) = B âˆ¨ ( B âˆª C ) = C ) ) ;;
	step 9 : wff = sylib (step 5, step 8) |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( ( B âˆª C ) = B âˆ¨ ( B âˆª C ) = C ) ) ;;
	step 10 : wff = unexg () |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( B âˆª C ) âˆˆ _V ) ;;
	step 11 : wff = elprg () |- ( ( B âˆª C ) âˆˆ _V â†’ ( ( B âˆª C ) âˆˆ { B , C } â†” ( ( B âˆª C ) = B âˆ¨ ( B âˆª C ) = C ) ) ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( ( B âˆª C ) âˆˆ { B , C } â†” ( ( B âˆª C ) = B âˆ¨ ( B âˆª C ) = C ) ) ) ;;
	step 13 : wff = mpbird (step 9, step 12) |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( B âˆª C ) âˆˆ { B , C } ) ;;
	qed prop 1 = step 13 ;;
}

/*The maximum of two ordinals belongs to a third if each of them do.
     (Contributed by NM, 18-Sep-2006.)  (Revised by Mario Carneiro,
     25-Jun-2015.) */

theorem ordunel (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( Ord A âˆ§ B âˆˆ A âˆ§ C âˆˆ A ) â†’ ( B âˆª C ) âˆˆ A ) ;;
}

proof of ordunel {
	step 1 : wff = prssi () |- ( ( B âˆˆ A âˆ§ C âˆˆ A ) â†’ { B , C } âŠ† A ) ;;
	step 2 : wff = 3adant1 (step 1) |- ( ( Ord A âˆ§ B âˆˆ A âˆ§ C âˆˆ A ) â†’ { B , C } âŠ† A ) ;;
	step 3 : wff = ordelon () |- ( ( Ord A âˆ§ B âˆˆ A ) â†’ B âˆˆ On ) ;;
	step 4 : wff = 3adant3 (step 3) |- ( ( Ord A âˆ§ B âˆˆ A âˆ§ C âˆˆ A ) â†’ B âˆˆ On ) ;;
	step 5 : wff = ordelon () |- ( ( Ord A âˆ§ C âˆˆ A ) â†’ C âˆˆ On ) ;;
	step 6 : wff = 3adant2 (step 5) |- ( ( Ord A âˆ§ B âˆˆ A âˆ§ C âˆˆ A ) â†’ C âˆˆ On ) ;;
	step 7 : wff = ordunpr () |- ( ( B âˆˆ On âˆ§ C âˆˆ On ) â†’ ( B âˆª C ) âˆˆ { B , C } ) ;;
	step 8 : wff = syl2anc (step 4, step 6, step 7) |- ( ( Ord A âˆ§ B âˆˆ A âˆ§ C âˆˆ A ) â†’ ( B âˆª C ) âˆˆ { B , C } ) ;;
	step 9 : wff = sseldd (step 2, step 8) |- ( ( Ord A âˆ§ B âˆˆ A âˆ§ C âˆˆ A ) â†’ ( B âˆª C ) âˆˆ A ) ;;
	qed prop 1 = step 9 ;;
}

/*A class of ordinal numbers is a subclass of the successor of its union.
     Similar to Proposition 7.26 of [TakeutiZaring] p. 41.  (Contributed by NM,
     19-Sep-2003.) */

theorem onsucuni (A : class)  {
	prop 1 : wff = |- ( A âŠ† On â†’ A âŠ† suc â‹ƒ A ) ;;
}

proof of onsucuni {
	step 1 : wff = ssorduni () |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
	step 2 : wff = ssid () |- â‹ƒ A âŠ† â‹ƒ A ;;
	step 3 : wff = ordunisssuc () |- ( ( A âŠ† On âˆ§ Ord â‹ƒ A ) â†’ ( â‹ƒ A âŠ† â‹ƒ A â†” A âŠ† suc â‹ƒ A ) ) ;;
	step 4 : wff = mpbii (step 2, step 3) |- ( ( A âŠ† On âˆ§ Ord â‹ƒ A ) â†’ A âŠ† suc â‹ƒ A ) ;;
	step 5 : wff = mpdan (step 1, step 4) |- ( A âŠ† On â†’ A âŠ† suc â‹ƒ A ) ;;
	qed prop 1 = step 5 ;;
}

/*An ordinal class is a subclass of the successor of its union.
     (Contributed by NM, 12-Sep-2003.) */

theorem ordsucuni (A : class)  {
	prop 1 : wff = |- ( Ord A â†’ A âŠ† suc â‹ƒ A ) ;;
}

proof of ordsucuni {
	step 1 : wff = ordsson () |- ( Ord A â†’ A âŠ† On ) ;;
	step 2 : wff = onsucuni () |- ( A âŠ† On â†’ A âŠ† suc â‹ƒ A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( Ord A â†’ A âŠ† suc â‹ƒ A ) ;;
	qed prop 1 = step 3 ;;
}

/*An ordinal class is either its union or the successor of its union.  If we
     adopt the view that zero is a limit ordinal, this means every ordinal
     class is either a limit or a successor.  (Contributed by NM,
     13-Sep-2003.) */

theorem orduniorsuc (A : class)  {
	prop 1 : wff = |- ( Ord A â†’ ( A = â‹ƒ A âˆ¨ A = suc â‹ƒ A ) ) ;;
}

proof of orduniorsuc {
	step 1 : wff = orduniss () |- ( Ord A â†’ â‹ƒ A âŠ† A ) ;;
	step 2 : wff = orduni () |- ( Ord A â†’ Ord â‹ƒ A ) ;;
	step 3 : wff = ordelssne () |- ( ( Ord â‹ƒ A âˆ§ Ord A ) â†’ ( â‹ƒ A âˆˆ A â†” ( â‹ƒ A âŠ† A âˆ§ â‹ƒ A â‰  A ) ) ) ;;
	step 4 : wff = mpancom (step 2, step 3) |- ( Ord A â†’ ( â‹ƒ A âˆˆ A â†” ( â‹ƒ A âŠ† A âˆ§ â‹ƒ A â‰  A ) ) ) ;;
	step 5 : wff = biimprd (step 4) |- ( Ord A â†’ ( ( â‹ƒ A âŠ† A âˆ§ â‹ƒ A â‰  A ) â†’ â‹ƒ A âˆˆ A ) ) ;;
	step 6 : wff = mpand (step 1, step 5) |- ( Ord A â†’ ( â‹ƒ A â‰  A â†’ â‹ƒ A âˆˆ A ) ) ;;
	step 7 : wff = ordsucss () |- ( Ord A â†’ ( â‹ƒ A âˆˆ A â†’ suc â‹ƒ A âŠ† A ) ) ;;
	step 8 : wff = syld (step 6, step 7) |- ( Ord A â†’ ( â‹ƒ A â‰  A â†’ suc â‹ƒ A âŠ† A ) ) ;;
	step 9 : wff = ordsucuni () |- ( Ord A â†’ A âŠ† suc â‹ƒ A ) ;;
	step 10 : wff = jctild (step 8, step 9) |- ( Ord A â†’ ( â‹ƒ A â‰  A â†’ ( A âŠ† suc â‹ƒ A âˆ§ suc â‹ƒ A âŠ† A ) ) ) ;;
	step 11 : wff = df-ne () |- ( A â‰  â‹ƒ A â†” Â¬ A = â‹ƒ A ) ;;
	step 12 : wff = necom () |- ( A â‰  â‹ƒ A â†” â‹ƒ A â‰  A ) ;;
	step 13 : wff = bitr3i (step 11, step 12) |- ( Â¬ A = â‹ƒ A â†” â‹ƒ A â‰  A ) ;;
	step 14 : wff = eqss () |- ( A = suc â‹ƒ A â†” ( A âŠ† suc â‹ƒ A âˆ§ suc â‹ƒ A âŠ† A ) ) ;;
	step 15 : wff = 3imtr4g (step 10, step 13, step 14) |- ( Ord A â†’ ( Â¬ A = â‹ƒ A â†’ A = suc â‹ƒ A ) ) ;;
	step 16 : wff = orrd (step 15) |- ( Ord A â†’ ( A = â‹ƒ A âˆ¨ A = suc â‹ƒ A ) ) ;;
	qed prop 1 = step 16 ;;
}

/*The class of all ordinal numbers is its own union.  Exercise 11 of
       [TakeutiZaring] p. 40.  (Contributed by NM, 12-Nov-2003.) */

theorem unon () disjointed(x y) {
	prop 1 : wff = |- â‹ƒ On = On ;;
}

proof of unon {
	var x : set, y : set;;
	step 1 : wff = eluni2 () |- ( x âˆˆ â‹ƒ On â†” âˆƒ y âˆˆ On x âˆˆ y ) ;;
	step 2 : wff = onelon () |- ( ( y âˆˆ On âˆ§ x âˆˆ y ) â†’ x âˆˆ On ) ;;
	step 3 : wff = rexlimiva (step 2) |- ( âˆƒ y âˆˆ On x âˆˆ y â†’ x âˆˆ On ) ;;
	step 4 : wff = sylbi (step 1, step 3) |- ( x âˆˆ â‹ƒ On â†’ x âˆˆ On ) ;;
	step 5 : wff = vex () |- x âˆˆ _V ;;
	step 6 : wff = sucid (step 5) |- x âˆˆ suc x ;;
	step 7 : wff = suceloni () |- ( x âˆˆ On â†’ suc x âˆˆ On ) ;;
	step 8 : wff = elunii () |- ( ( x âˆˆ suc x âˆ§ suc x âˆˆ On ) â†’ x âˆˆ â‹ƒ On ) ;;
	step 9 : wff = sylancr (step 6, step 7, step 8) |- ( x âˆˆ On â†’ x âˆˆ â‹ƒ On ) ;;
	step 10 : wff = impbii (step 4, step 9) |- ( x âˆˆ â‹ƒ On â†” x âˆˆ On ) ;;
	step 11 : wff = eqriv (step 10) |- â‹ƒ On = On ;;
	qed prop 1 = step 11 ;;
}

/*An ordinal class is equal to the union of its successor.  (Contributed
       by NM, 10-Dec-2004.)  (Proof shortened by Andrew Salmon,
       27-Aug-2011.) */

theorem ordunisuc (A : class) disjointed(x A) {
	prop 1 : wff = |- ( Ord A â†’ â‹ƒ suc A = A ) ;;
}

proof of ordunisuc {
	var x : set;;
	step 1 : wff = ordeleqon () |- ( Ord A â†” ( A âˆˆ On âˆ¨ A = On ) ) ;;
	step 2 : wff = suceq () |- ( x = A â†’ suc x = suc A ) ;;
	step 3 : wff = unieqd (step 2) |- ( x = A â†’ â‹ƒ suc x = â‹ƒ suc A ) ;;
	step 4 : wff = id () |- ( x = A â†’ x = A ) ;;
	step 5 : wff = eqeq12d (step 3, step 4) |- ( x = A â†’ ( â‹ƒ suc x = x â†” â‹ƒ suc A = A ) ) ;;
	step 6 : wff = eloni () |- ( x âˆˆ On â†’ Ord x ) ;;
	step 7 : wff = ordtr () |- ( Ord x â†’ Tr x ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( x âˆˆ On â†’ Tr x ) ;;
	step 9 : wff = vex () |- x âˆˆ _V ;;
	step 10 : wff = unisuc (step 9) |- ( Tr x â†” â‹ƒ suc x = x ) ;;
	step 11 : wff = sylib (step 8, step 10) |- ( x âˆˆ On â†’ â‹ƒ suc x = x ) ;;
	step 12 : wff = vtoclga (step 5, step 11) |- ( A âˆˆ On â†’ â‹ƒ suc A = A ) ;;
	step 13 : wff = sucon () |- suc On = On ;;
	step 14 : wff = unieqi (step 13) |- â‹ƒ suc On = â‹ƒ On ;;
	step 15 : wff = unon () |- â‹ƒ On = On ;;
	step 16 : wff = eqtri (step 14, step 15) |- â‹ƒ suc On = On ;;
	step 17 : wff = suceq () |- ( A = On â†’ suc A = suc On ) ;;
	step 18 : wff = unieqd (step 17) |- ( A = On â†’ â‹ƒ suc A = â‹ƒ suc On ) ;;
	step 19 : wff = id () |- ( A = On â†’ A = On ) ;;
	step 20 : wff = 3eqtr4a (step 16, step 18, step 19) |- ( A = On â†’ â‹ƒ suc A = A ) ;;
	step 21 : wff = jaoi (step 12, step 20) |- ( ( A âˆˆ On âˆ¨ A = On ) â†’ â‹ƒ suc A = A ) ;;
	step 22 : wff = sylbi (step 1, step 21) |- ( Ord A â†’ â‹ƒ suc A = A ) ;;
	qed prop 1 = step 22 ;;
}

/*The union of the ordinal subsets of an ordinal number is that number.
       (Contributed by NM, 30-Jan-2005.) */

theorem orduniss2 (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Ord A â†’ â‹ƒ { x âˆˆ On | x âŠ† A } = A ) ;;
}

proof of orduniss2 {
	step 1 : wff = df-rab () |- { x âˆˆ On | x âŠ† A } = { x | ( x âˆˆ On âˆ§ x âŠ† A ) } ;;
	step 2 : wff = incom () |- ( { x | x âˆˆ On } âˆ© { x | x âŠ† A } ) = ( { x | x âŠ† A } âˆ© { x | x âˆˆ On } ) ;;
	step 3 : wff = inab () |- ( { x | x âˆˆ On } âˆ© { x | x âŠ† A } ) = { x | ( x âˆˆ On âˆ§ x âŠ† A ) } ;;
	step 4 : wff = df-pw () |- Pow A = { x | x âŠ† A } ;;
	step 5 : wff = eqcomi (step 4) |- { x | x âŠ† A } = Pow A ;;
	step 6 : wff = abid2 () |- { x | x âˆˆ On } = On ;;
	step 7 : wff = ineq12i (step 5, step 6) |- ( { x | x âŠ† A } âˆ© { x | x âˆˆ On } ) = ( Pow A âˆ© On ) ;;
	step 8 : wff = 3eqtr3i (step 2, step 3, step 7) |- { x | ( x âˆˆ On âˆ§ x âŠ† A ) } = ( Pow A âˆ© On ) ;;
	step 9 : wff = eqtri (step 1, step 8) |- { x âˆˆ On | x âŠ† A } = ( Pow A âˆ© On ) ;;
	step 10 : wff = ordpwsuc () |- ( Ord A â†’ ( Pow A âˆ© On ) = suc A ) ;;
	step 11 : wff = syl5eq (step 9, step 10) |- ( Ord A â†’ { x âˆˆ On | x âŠ† A } = suc A ) ;;
	step 12 : wff = unieqd (step 11) |- ( Ord A â†’ â‹ƒ { x âˆˆ On | x âŠ† A } = â‹ƒ suc A ) ;;
	step 13 : wff = ordunisuc () |- ( Ord A â†’ â‹ƒ suc A = A ) ;;
	step 14 : wff = eqtrd (step 12, step 13) |- ( Ord A â†’ â‹ƒ { x âˆˆ On | x âŠ† A } = A ) ;;
	qed prop 1 = step 14 ;;
}

/*A successor ordinal is the successor of its union.  (Contributed by NM,
     10-Dec-2004.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem onsucuni2 (A : class, B : class)  {
	prop 1 : wff = |- ( ( A âˆˆ On âˆ§ A = suc B ) â†’ suc â‹ƒ A = A ) ;;
}

proof of onsucuni2 {
	step 1 : wff = eleq1 () |- ( A = suc B â†’ ( A âˆˆ On â†” suc B âˆˆ On ) ) ;;
	step 2 : wff = biimpac (step 1) |- ( ( A âˆˆ On âˆ§ A = suc B ) â†’ suc B âˆˆ On ) ;;
	step 3 : wff = eloni () |- ( suc B âˆˆ On â†’ Ord suc B ) ;;
	step 4 : wff = ordsuc () |- ( Ord B â†” Ord suc B ) ;;
	step 5 : wff = ordunisuc () |- ( Ord B â†’ â‹ƒ suc B = B ) ;;
	step 6 : wff = sylbir (step 4, step 5) |- ( Ord suc B â†’ â‹ƒ suc B = B ) ;;
	step 7 : wff = suceq () |- ( â‹ƒ suc B = B â†’ suc â‹ƒ suc B = suc B ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( Ord suc B â†’ suc â‹ƒ suc B = suc B ) ;;
	step 9 : wff = ordunisuc () |- ( Ord suc B â†’ â‹ƒ suc suc B = suc B ) ;;
	step 10 : wff = eqtr4d (step 8, step 9) |- ( Ord suc B â†’ suc â‹ƒ suc B = â‹ƒ suc suc B ) ;;
	step 11 : wff = 3syl (step 2, step 3, step 10) |- ( ( A âˆˆ On âˆ§ A = suc B ) â†’ suc â‹ƒ suc B = â‹ƒ suc suc B ) ;;
	step 12 : wff = unieq () |- ( A = suc B â†’ â‹ƒ A = â‹ƒ suc B ) ;;
	step 13 : wff = suceq () |- ( â‹ƒ A = â‹ƒ suc B â†’ suc â‹ƒ A = suc â‹ƒ suc B ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( A = suc B â†’ suc â‹ƒ A = suc â‹ƒ suc B ) ;;
	step 15 : wff = suceq () |- ( A = suc B â†’ suc A = suc suc B ) ;;
	step 16 : wff = unieqd (step 15) |- ( A = suc B â†’ â‹ƒ suc A = â‹ƒ suc suc B ) ;;
	step 17 : wff = eqeq12d (step 14, step 16) |- ( A = suc B â†’ ( suc â‹ƒ A = â‹ƒ suc A â†” suc â‹ƒ suc B = â‹ƒ suc suc B ) ) ;;
	step 18 : wff = syl5ibr (step 11, step 17) |- ( A = suc B â†’ ( ( A âˆˆ On âˆ§ A = suc B ) â†’ suc â‹ƒ A = â‹ƒ suc A ) ) ;;
	step 19 : wff = anabsi7 (step 18) |- ( ( A âˆˆ On âˆ§ A = suc B ) â†’ suc â‹ƒ A = â‹ƒ suc A ) ;;
	step 20 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 21 : wff = ordunisuc () |- ( Ord A â†’ â‹ƒ suc A = A ) ;;
	step 22 : wff = syl (step 20, step 21) |- ( A âˆˆ On â†’ â‹ƒ suc A = A ) ;;
	step 23 : wff = adantr (step 22) |- ( ( A âˆˆ On âˆ§ A = suc B ) â†’ â‹ƒ suc A = A ) ;;
	step 24 : wff = eqtrd (step 19, step 23) |- ( ( A âˆˆ On âˆ§ A = suc B ) â†’ suc â‹ƒ A = A ) ;;
	qed prop 1 = step 24 ;;
}

/*The successor of an ordinal class contains the empty set.  (Contributed by
     NM, 4-Apr-1995.) */

theorem 0elsuc (A : class)  {
	prop 1 : wff = |- ( Ord A â†’ âˆ… âˆˆ suc A ) ;;
}

proof of 0elsuc {
	step 1 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 2 : wff = nsuceq0 () |- suc A â‰  âˆ… ;;
	step 3 : wff = ord0eln0 () |- ( Ord suc A â†’ ( âˆ… âˆˆ suc A â†” suc A â‰  âˆ… ) ) ;;
	step 4 : wff = mpbiri (step 2, step 3) |- ( Ord suc A â†’ âˆ… âˆˆ suc A ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( Ord A â†’ âˆ… âˆˆ suc A ) ;;
	qed prop 1 = step 5 ;;
}

/*The class of ordinal numbers is a limit ordinal.  (Contributed by NM,
     24-Mar-1995.) */

theorem limon ()  {
	prop 1 : wff = |- Lim On ;;
}

proof of limon {
	step 1 : wff = ordon () |- Ord On ;;
	step 2 : wff = onn0 () |- On â‰  âˆ… ;;
	step 3 : wff = unon () |- â‹ƒ On = On ;;
	step 4 : wff = eqcomi (step 3) |- On = â‹ƒ On ;;
	step 5 : wff = df-lim () |- ( Lim On â†” ( Ord On âˆ§ On â‰  âˆ… âˆ§ On = â‹ƒ On ) ) ;;
	step 6 : wff = mpbir3an (step 1, step 2, step 4, step 5) |- Lim On ;;
	qed prop 1 = step 6 ;;
}

/*An ordinal number is a subset of ` On ` .  (Contributed by NM,
       11-Aug-1994.) */

theorem onssi (A : class)  {
	hyp 1 : wff = |- A âˆˆ On ;;
	-----------------------
	prop 1 : wff = |- A âŠ† On ;;
}

proof of onssi {
	step 1 : wff = onss () |- ( A âˆˆ On â†’ A âŠ† On ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- A âŠ† On ;;
	qed prop 1 = step 2 ;;
}

/*The successor of an ordinal number is an ordinal number.  Corollary
       7N(c) of [Enderton] p. 193.  (Contributed by NM, 12-Jun-1994.) */

theorem onsuci (A : class)  {
	hyp 1 : wff = |- A âˆˆ On ;;
	-----------------------
	prop 1 : wff = |- suc A âˆˆ On ;;
}

proof of onsuci {
	step 1 : wff = suceloni () |- ( A âˆˆ On â†’ suc A âˆˆ On ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- suc A âˆˆ On ;;
	qed prop 1 = step 2 ;;
}

/*An ordinal number is either its own union (if zero or a limit ordinal)
       or the successor of its union.  (Contributed by NM, 13-Jun-1994.) */

theorem onuniorsuci (A : class)  {
	hyp 1 : wff = |- A âˆˆ On ;;
	-----------------------
	prop 1 : wff = |- ( A = â‹ƒ A âˆ¨ A = suc â‹ƒ A ) ;;
}

proof of onuniorsuci {
	step 1 : wff = onordi (hyp 1) |- Ord A ;;
	step 2 : wff = orduniorsuc () |- ( Ord A â†’ ( A = â‹ƒ A âˆ¨ A = suc â‹ƒ A ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( A = â‹ƒ A âˆ¨ A = suc â‹ƒ A ) ;;
	qed prop 1 = step 3 ;;
}

/*A limit ordinal is not a successor ordinal.  (Contributed by NM,
         18-Feb-2004.) */

theorem onuninsuci (x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- A âˆˆ On ;;
	-----------------------
	prop 1 : wff = |- ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ;;
}

proof of onuninsuci {
	step 1 : wff = onirri (hyp 1) |- Â¬ A âˆˆ A ;;
	step 2 : wff = id () |- ( A = â‹ƒ A â†’ A = â‹ƒ A ) ;;
	step 3 : wff = df-suc () |- suc x = ( x âˆª { x } ) ;;
	step 4 : wff = eqeq2i (step 3) |- ( A = suc x â†” A = ( x âˆª { x } ) ) ;;
	step 5 : wff = unieq () |- ( A = ( x âˆª { x } ) â†’ â‹ƒ A = â‹ƒ ( x âˆª { x } ) ) ;;
	step 6 : wff = sylbi (step 4, step 5) |- ( A = suc x â†’ â‹ƒ A = â‹ƒ ( x âˆª { x } ) ) ;;
	step 7 : wff = uniun () |- â‹ƒ ( x âˆª { x } ) = ( â‹ƒ x âˆª â‹ƒ { x } ) ;;
	step 8 : wff = vex () |- x âˆˆ _V ;;
	step 9 : wff = unisn (step 8) |- â‹ƒ { x } = x ;;
	step 10 : wff = uneq2i (step 9) |- ( â‹ƒ x âˆª â‹ƒ { x } ) = ( â‹ƒ x âˆª x ) ;;
	step 11 : wff = eqtri (step 7, step 10) |- â‹ƒ ( x âˆª { x } ) = ( â‹ƒ x âˆª x ) ;;
	step 12 : wff = syl6eq (step 6, step 11) |- ( A = suc x â†’ â‹ƒ A = ( â‹ƒ x âˆª x ) ) ;;
	step 13 : wff = tron () |- Tr On ;;
	step 14 : wff = eleq1 () |- ( A = suc x â†’ ( A âˆˆ On â†” suc x âˆˆ On ) ) ;;
	step 15 : wff = mpbii (hyp 1, step 14) |- ( A = suc x â†’ suc x âˆˆ On ) ;;
	step 16 : wff = trsuc () |- ( ( Tr On âˆ§ suc x âˆˆ On ) â†’ x âˆˆ On ) ;;
	step 17 : wff = sylancr (step 13, step 15, step 16) |- ( A = suc x â†’ x âˆˆ On ) ;;
	step 18 : wff = eloni () |- ( x âˆˆ On â†’ Ord x ) ;;
	step 19 : wff = ordtr () |- ( Ord x â†’ Tr x ) ;;
	step 20 : wff = syl (step 18, step 19) |- ( x âˆˆ On â†’ Tr x ) ;;
	step 21 : wff = df-tr () |- ( Tr x â†” â‹ƒ x âŠ† x ) ;;
	step 22 : wff = sylib (step 20, step 21) |- ( x âˆˆ On â†’ â‹ƒ x âŠ† x ) ;;
	step 23 : wff = syl (step 17, step 22) |- ( A = suc x â†’ â‹ƒ x âŠ† x ) ;;
	step 24 : wff = ssequn1 () |- ( â‹ƒ x âŠ† x â†” ( â‹ƒ x âˆª x ) = x ) ;;
	step 25 : wff = sylib (step 23, step 24) |- ( A = suc x â†’ ( â‹ƒ x âˆª x ) = x ) ;;
	step 26 : wff = eqtrd (step 12, step 25) |- ( A = suc x â†’ â‹ƒ A = x ) ;;
	step 27 : wff = sylan9eqr (step 2, step 26) |- ( ( A = suc x âˆ§ A = â‹ƒ A ) â†’ A = x ) ;;
	step 28 : wff = vex () |- x âˆˆ _V ;;
	step 29 : wff = sucid (step 28) |- x âˆˆ suc x ;;
	step 30 : wff = eleq2 () |- ( A = suc x â†’ ( x âˆˆ A â†” x âˆˆ suc x ) ) ;;
	step 31 : wff = mpbiri (step 29, step 30) |- ( A = suc x â†’ x âˆˆ A ) ;;
	step 32 : wff = adantr (step 31) |- ( ( A = suc x âˆ§ A = â‹ƒ A ) â†’ x âˆˆ A ) ;;
	step 33 : wff = eqeltrd (step 27, step 32) |- ( ( A = suc x âˆ§ A = â‹ƒ A ) â†’ A âˆˆ A ) ;;
	step 34 : wff = mto (step 1, step 33) |- Â¬ ( A = suc x âˆ§ A = â‹ƒ A ) ;;
	step 35 : wff = imnani (step 34) |- ( A = suc x â†’ Â¬ A = â‹ƒ A ) ;;
	step 36 : wff = rexlimivw (step 35) |- ( âˆƒ x âˆˆ On A = suc x â†’ Â¬ A = â‹ƒ A ) ;;
	step 37 : wff = onuni () |- ( A âˆˆ On â†’ â‹ƒ A âˆˆ On ) ;;
	step 38 : wff = ax-mp (hyp 1, step 37) |- â‹ƒ A âˆˆ On ;;
	step 39 : wff = onuniorsuci (hyp 1) |- ( A = â‹ƒ A âˆ¨ A = suc â‹ƒ A ) ;;
	step 40 : wff = ori (step 39) |- ( Â¬ A = â‹ƒ A â†’ A = suc â‹ƒ A ) ;;
	step 41 : wff = suceq () |- ( x = â‹ƒ A â†’ suc x = suc â‹ƒ A ) ;;
	step 42 : wff = eqeq2d (step 41) |- ( x = â‹ƒ A â†’ ( A = suc x â†” A = suc â‹ƒ A ) ) ;;
	step 43 : wff = rspcev (step 42) |- ( ( â‹ƒ A âˆˆ On âˆ§ A = suc â‹ƒ A ) â†’ âˆƒ x âˆˆ On A = suc x ) ;;
	step 44 : wff = sylancr (step 38, step 40, step 43) |- ( Â¬ A = â‹ƒ A â†’ âˆƒ x âˆˆ On A = suc x ) ;;
	step 45 : wff = impbii (step 36, step 44) |- ( âˆƒ x âˆˆ On A = suc x â†” Â¬ A = â‹ƒ A ) ;;
	step 46 : wff = con2bii (step 45) |- ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ;;
	qed prop 1 = step 46 ;;
}

/*A set belongs to an ordinal number iff its successor is a subset of
         the ordinal number.  Exercise 8 of [TakeutiZaring] p. 42 and its
         converse.  (Contributed by NM, 16-Sep-1995.) */

theorem onsucssi (A : class, B : class)  {
	hyp 1 : wff = |- A âˆˆ On ;;
	hyp 2 : wff = |- B âˆˆ On ;;
	-----------------------
	prop 1 : wff = |- ( A âˆˆ B â†” suc A âŠ† B ) ;;
}

proof of onsucssi {
	step 1 : wff = onordi (hyp 2) |- Ord B ;;
	step 2 : wff = ordelsuc () |- ( ( A âˆˆ On âˆ§ Ord B ) â†’ ( A âˆˆ B â†” suc A âŠ† B ) ) ;;
	step 3 : wff = mp2an (hyp 1, step 1, step 2) |- ( A âˆˆ B â†” suc A âŠ† B ) ;;
	qed prop 1 = step 3 ;;
}

/*A successor is not a limit ordinal.  (Contributed by NM, 25-Mar-1995.)
     (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem nlimsucg (A : class, V : class)  {
	prop 1 : wff = |- ( A âˆˆ V â†’ Â¬ Lim suc A ) ;;
}

proof of nlimsucg {
	step 1 : wff = limord () |- ( Lim suc A â†’ Ord suc A ) ;;
	step 2 : wff = ordsuc () |- ( Ord A â†” Ord suc A ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( Lim suc A â†’ Ord A ) ;;
	step 4 : wff = limuni () |- ( Lim suc A â†’ suc A = â‹ƒ suc A ) ;;
	step 5 : wff = ordunisuc () |- ( Ord A â†’ â‹ƒ suc A = A ) ;;
	step 6 : wff = eqeq2d (step 5) |- ( Ord A â†’ ( suc A = â‹ƒ suc A â†” suc A = A ) ) ;;
	step 7 : wff = ordirr () |- ( Ord A â†’ Â¬ A âˆˆ A ) ;;
	step 8 : wff = eleq2 () |- ( suc A = A â†’ ( A âˆˆ suc A â†” A âˆˆ A ) ) ;;
	step 9 : wff = notbid (step 8) |- ( suc A = A â†’ ( Â¬ A âˆˆ suc A â†” Â¬ A âˆˆ A ) ) ;;
	step 10 : wff = syl5ibrcom (step 7, step 9) |- ( Ord A â†’ ( suc A = A â†’ Â¬ A âˆˆ suc A ) ) ;;
	step 11 : wff = sucidg () |- ( A âˆˆ V â†’ A âˆˆ suc A ) ;;
	step 12 : wff = con3i (step 11) |- ( Â¬ A âˆˆ suc A â†’ Â¬ A âˆˆ V ) ;;
	step 13 : wff = syl6 (step 10, step 12) |- ( Ord A â†’ ( suc A = A â†’ Â¬ A âˆˆ V ) ) ;;
	step 14 : wff = sylbid (step 6, step 13) |- ( Ord A â†’ ( suc A = â‹ƒ suc A â†’ Â¬ A âˆˆ V ) ) ;;
	step 15 : wff = sylc (step 3, step 4, step 14) |- ( Lim suc A â†’ Â¬ A âˆˆ V ) ;;
	step 16 : wff = con2i (step 15) |- ( A âˆˆ V â†’ Â¬ Lim suc A ) ;;
	qed prop 1 = step 16 ;;
}

/*An ordinal equal to its union is not a successor.  (Contributed by NM,
       18-Feb-2004.) */

theorem orduninsuc (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Ord A â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
}

proof of orduninsuc {
	step 1 : wff = ordeleqon () |- ( Ord A â†” ( A âˆˆ On âˆ¨ A = On ) ) ;;
	step 2 : wff = id () |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ A = if ( A âˆˆ On , A , âˆ… ) ) ;;
	step 3 : wff = unieq () |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ â‹ƒ A = â‹ƒ if ( A âˆˆ On , A , âˆ… ) ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ ( A = â‹ƒ A â†” if ( A âˆˆ On , A , âˆ… ) = â‹ƒ if ( A âˆˆ On , A , âˆ… ) ) ) ;;
	step 5 : wff = eqeq1 () |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ ( A = suc x â†” if ( A âˆˆ On , A , âˆ… ) = suc x ) ) ;;
	step 6 : wff = rexbidv (step 5) |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ ( âˆƒ x âˆˆ On A = suc x â†” âˆƒ x âˆˆ On if ( A âˆˆ On , A , âˆ… ) = suc x ) ) ;;
	step 7 : wff = notbid (step 6) |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ ( Â¬ âˆƒ x âˆˆ On A = suc x â†” Â¬ âˆƒ x âˆˆ On if ( A âˆˆ On , A , âˆ… ) = suc x ) ) ;;
	step 8 : wff = bibi12d (step 4, step 7) |- ( A = if ( A âˆˆ On , A , âˆ… ) â†’ ( ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) â†” ( if ( A âˆˆ On , A , âˆ… ) = â‹ƒ if ( A âˆˆ On , A , âˆ… ) â†” Â¬ âˆƒ x âˆˆ On if ( A âˆˆ On , A , âˆ… ) = suc x ) ) ) ;;
	step 9 : wff = 0elon () |- âˆ… âˆˆ On ;;
	step 10 : wff = elimel (step 9) |- if ( A âˆˆ On , A , âˆ… ) âˆˆ On ;;
	step 11 : wff = onuninsuci (step 10) |- ( if ( A âˆˆ On , A , âˆ… ) = â‹ƒ if ( A âˆˆ On , A , âˆ… ) â†” Â¬ âˆƒ x âˆˆ On if ( A âˆˆ On , A , âˆ… ) = suc x ) ;;
	step 12 : wff = dedth (step 8, step 11) |- ( A âˆˆ On â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 13 : wff = unon () |- â‹ƒ On = On ;;
	step 14 : wff = eqcomi (step 13) |- On = â‹ƒ On ;;
	step 15 : wff = onprc () |- Â¬ On âˆˆ _V ;;
	step 16 : wff = vex () |- x âˆˆ _V ;;
	step 17 : wff = sucex (step 16) |- suc x âˆˆ _V ;;
	step 18 : wff = eleq1 () |- ( On = suc x â†’ ( On âˆˆ _V â†” suc x âˆˆ _V ) ) ;;
	step 19 : wff = mpbiri (step 17, step 18) |- ( On = suc x â†’ On âˆˆ _V ) ;;
	step 20 : wff = mto (step 15, step 19) |- Â¬ On = suc x ;;
	step 21 : wff = a1i (step 20) |- ( x âˆˆ On â†’ Â¬ On = suc x ) ;;
	step 22 : wff = nrex (step 21) |- Â¬ âˆƒ x âˆˆ On On = suc x ;;
	step 23 : wff = 2th (step 14, step 22) |- ( On = â‹ƒ On â†” Â¬ âˆƒ x âˆˆ On On = suc x ) ;;
	step 24 : wff = id () |- ( A = On â†’ A = On ) ;;
	step 25 : wff = unieq () |- ( A = On â†’ â‹ƒ A = â‹ƒ On ) ;;
	step 26 : wff = eqeq12d (step 24, step 25) |- ( A = On â†’ ( A = â‹ƒ A â†” On = â‹ƒ On ) ) ;;
	step 27 : wff = eqeq1 () |- ( A = On â†’ ( A = suc x â†” On = suc x ) ) ;;
	step 28 : wff = rexbidv (step 27) |- ( A = On â†’ ( âˆƒ x âˆˆ On A = suc x â†” âˆƒ x âˆˆ On On = suc x ) ) ;;
	step 29 : wff = notbid (step 28) |- ( A = On â†’ ( Â¬ âˆƒ x âˆˆ On A = suc x â†” Â¬ âˆƒ x âˆˆ On On = suc x ) ) ;;
	step 30 : wff = bibi12d (step 26, step 29) |- ( A = On â†’ ( ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) â†” ( On = â‹ƒ On â†” Â¬ âˆƒ x âˆˆ On On = suc x ) ) ) ;;
	step 31 : wff = mpbiri (step 23, step 30) |- ( A = On â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 32 : wff = jaoi (step 12, step 31) |- ( ( A âˆˆ On âˆ¨ A = On ) â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 33 : wff = sylbi (step 1, step 32) |- ( Ord A â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	qed prop 1 = step 33 ;;
}

/*An ordinal equal to its union contains the successor of each of its
       members.  (Contributed by NM, 1-Feb-2005.) */

theorem ordunisuc2 (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Ord A â†’ ( A = â‹ƒ A â†” âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
}

proof of ordunisuc2 {
	step 1 : wff = orduninsuc () |- ( Ord A â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 2 : wff = ralnex () |- ( âˆ€ x âˆˆ On Â¬ A = suc x â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ;;
	step 3 : wff = suceloni () |- ( x âˆˆ On â†’ suc x âˆˆ On ) ;;
	step 4 : wff = eloni () |- ( suc x âˆˆ On â†’ Ord suc x ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( x âˆˆ On â†’ Ord suc x ) ;;
	step 6 : wff = ordtri3 () |- ( ( Ord A âˆ§ Ord suc x ) â†’ ( A = suc x â†” Â¬ ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) ) ) ;;
	step 7 : wff = sylan2 (step 5, step 6) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( A = suc x â†” Â¬ ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) ) ) ;;
	step 8 : wff = con2bid (step 7) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) â†” Â¬ A = suc x ) ) ;;
	step 9 : wff = onnbtwn () |- ( x âˆˆ On â†’ Â¬ ( x âˆˆ A âˆ§ A âˆˆ suc x ) ) ;;
	step 10 : wff = imnan () |- ( ( x âˆˆ A â†’ Â¬ A âˆˆ suc x ) â†” Â¬ ( x âˆˆ A âˆ§ A âˆˆ suc x ) ) ;;
	step 11 : wff = sylibr (step 9, step 10) |- ( x âˆˆ On â†’ ( x âˆˆ A â†’ Â¬ A âˆˆ suc x ) ) ;;
	step 12 : wff = con2d (step 11) |- ( x âˆˆ On â†’ ( A âˆˆ suc x â†’ Â¬ x âˆˆ A ) ) ;;
	step 13 : wff = pm2.21 () |- ( Â¬ x âˆˆ A â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ;;
	step 14 : wff = syl6 (step 12, step 13) |- ( x âˆˆ On â†’ ( A âˆˆ suc x â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 15 : wff = adantl (step 14) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( A âˆˆ suc x â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 16 : wff = ax-1 () |- ( suc x âˆˆ A â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ;;
	step 17 : wff = a1i (step 16) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( suc x âˆˆ A â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 18 : wff = jaod (step 15, step 17) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 19 : wff = eloni () |- ( x âˆˆ On â†’ Ord x ) ;;
	step 20 : wff = ordtri2or () |- ( ( Ord x âˆ§ Ord A ) â†’ ( x âˆˆ A âˆ¨ A âŠ† x ) ) ;;
	step 21 : wff = sylan (step 19, step 20) |- ( ( x âˆˆ On âˆ§ Ord A ) â†’ ( x âˆˆ A âˆ¨ A âŠ† x ) ) ;;
	step 22 : wff = ancoms (step 21) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( x âˆˆ A âˆ¨ A âŠ† x ) ) ;;
	step 23 : wff = orcomd (step 22) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( A âŠ† x âˆ¨ x âˆˆ A ) ) ;;
	step 24 : wff = adantr (step 23) |- ( ( ( Ord A âˆ§ x âˆˆ On ) âˆ§ ( x âˆˆ A â†’ suc x âˆˆ A ) ) â†’ ( A âŠ† x âˆ¨ x âˆˆ A ) ) ;;
	step 25 : wff = ordsssuc2 () |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( A âŠ† x â†” A âˆˆ suc x ) ) ;;
	step 26 : wff = biimpd (step 25) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( A âŠ† x â†’ A âˆˆ suc x ) ) ;;
	step 27 : wff = adantr (step 26) |- ( ( ( Ord A âˆ§ x âˆˆ On ) âˆ§ ( x âˆˆ A â†’ suc x âˆˆ A ) ) â†’ ( A âŠ† x â†’ A âˆˆ suc x ) ) ;;
	step 28 : wff = simpr () |- ( ( ( Ord A âˆ§ x âˆˆ On ) âˆ§ ( x âˆˆ A â†’ suc x âˆˆ A ) ) â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ;;
	step 29 : wff = orim12d (step 27, step 28) |- ( ( ( Ord A âˆ§ x âˆˆ On ) âˆ§ ( x âˆˆ A â†’ suc x âˆˆ A ) ) â†’ ( ( A âŠ† x âˆ¨ x âˆˆ A ) â†’ ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) ) ) ;;
	step 30 : wff = mpd (step 24, step 29) |- ( ( ( Ord A âˆ§ x âˆˆ On ) âˆ§ ( x âˆˆ A â†’ suc x âˆˆ A ) ) â†’ ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) ) ;;
	step 31 : wff = ex (step 30) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( ( x âˆˆ A â†’ suc x âˆˆ A ) â†’ ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) ) ) ;;
	step 32 : wff = impbid (step 18, step 31) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( ( A âˆˆ suc x âˆ¨ suc x âˆˆ A ) â†” ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 33 : wff = bitr3d (step 8, step 32) |- ( ( Ord A âˆ§ x âˆˆ On ) â†’ ( Â¬ A = suc x â†” ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 34 : wff = pm5.74da (step 33) |- ( Ord A â†’ ( ( x âˆˆ On â†’ Â¬ A = suc x ) â†” ( x âˆˆ On â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ) ;;
	step 35 : wff = impexp () |- ( ( ( x âˆˆ On âˆ§ x âˆˆ A ) â†’ suc x âˆˆ A ) â†” ( x âˆˆ On â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 36 : wff = simpr () |- ( ( x âˆˆ On âˆ§ x âˆˆ A ) â†’ x âˆˆ A ) ;;
	step 37 : wff = ordelon () |- ( ( Ord A âˆ§ x âˆˆ A ) â†’ x âˆˆ On ) ;;
	step 38 : wff = ex (step 37) |- ( Ord A â†’ ( x âˆˆ A â†’ x âˆˆ On ) ) ;;
	step 39 : wff = ancrd (step 38) |- ( Ord A â†’ ( x âˆˆ A â†’ ( x âˆˆ On âˆ§ x âˆˆ A ) ) ) ;;
	step 40 : wff = impbid2 (step 36, step 39) |- ( Ord A â†’ ( ( x âˆˆ On âˆ§ x âˆˆ A ) â†” x âˆˆ A ) ) ;;
	step 41 : wff = imbi1d (step 40) |- ( Ord A â†’ ( ( ( x âˆˆ On âˆ§ x âˆˆ A ) â†’ suc x âˆˆ A ) â†” ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 42 : wff = syl5bbr (step 35, step 41) |- ( Ord A â†’ ( ( x âˆˆ On â†’ ( x âˆˆ A â†’ suc x âˆˆ A ) ) â†” ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 43 : wff = bitrd (step 34, step 42) |- ( Ord A â†’ ( ( x âˆˆ On â†’ Â¬ A = suc x ) â†” ( x âˆˆ A â†’ suc x âˆˆ A ) ) ) ;;
	step 44 : wff = ralbidv2 (step 43) |- ( Ord A â†’ ( âˆ€ x âˆˆ On Â¬ A = suc x â†” âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	step 45 : wff = syl5bbr (step 2, step 44) |- ( Ord A â†’ ( Â¬ âˆƒ x âˆˆ On A = suc x â†” âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	step 46 : wff = bitrd (step 1, step 45) |- ( Ord A â†’ ( A = â‹ƒ A â†” âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	qed prop 1 = step 46 ;;
}

/*An ordinal is zero, a successor ordinal, or a limit ordinal.
       (Contributed by NM, 1-Oct-2003.) */

theorem ordzsl (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Ord A â†” ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) ;;
}

proof of ordzsl {
	step 1 : wff = orduninsuc () |- ( Ord A â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 2 : wff = biimprd (step 1) |- ( Ord A â†’ ( Â¬ âˆƒ x âˆˆ On A = suc x â†’ A = â‹ƒ A ) ) ;;
	step 3 : wff = unizlim () |- ( Ord A â†’ ( A = â‹ƒ A â†” ( A = âˆ… âˆ¨ Lim A ) ) ) ;;
	step 4 : wff = sylibd (step 2, step 3) |- ( Ord A â†’ ( Â¬ âˆƒ x âˆˆ On A = suc x â†’ ( A = âˆ… âˆ¨ Lim A ) ) ) ;;
	step 5 : wff = orrd (step 4) |- ( Ord A â†’ ( âˆƒ x âˆˆ On A = suc x âˆ¨ ( A = âˆ… âˆ¨ Lim A ) ) ) ;;
	step 6 : wff = 3orass () |- ( ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) â†” ( A = âˆ… âˆ¨ ( âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) ) ;;
	step 7 : wff = or12 () |- ( ( A = âˆ… âˆ¨ ( âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) â†” ( âˆƒ x âˆˆ On A = suc x âˆ¨ ( A = âˆ… âˆ¨ Lim A ) ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) â†” ( âˆƒ x âˆˆ On A = suc x âˆ¨ ( A = âˆ… âˆ¨ Lim A ) ) ) ;;
	step 9 : wff = sylibr (step 5, step 8) |- ( Ord A â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) ;;
	step 10 : wff = ord0 () |- Ord âˆ… ;;
	step 11 : wff = ordeq () |- ( A = âˆ… â†’ ( Ord A â†” Ord âˆ… ) ) ;;
	step 12 : wff = mpbiri (step 10, step 11) |- ( A = âˆ… â†’ Ord A ) ;;
	step 13 : wff = suceloni () |- ( x âˆˆ On â†’ suc x âˆˆ On ) ;;
	step 14 : wff = eleq1 () |- ( A = suc x â†’ ( A âˆˆ On â†” suc x âˆˆ On ) ) ;;
	step 15 : wff = syl5ibr (step 13, step 14) |- ( A = suc x â†’ ( x âˆˆ On â†’ A âˆˆ On ) ) ;;
	step 16 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 17 : wff = syl6com (step 15, step 16) |- ( x âˆˆ On â†’ ( A = suc x â†’ Ord A ) ) ;;
	step 18 : wff = rexlimiv (step 17) |- ( âˆƒ x âˆˆ On A = suc x â†’ Ord A ) ;;
	step 19 : wff = limord () |- ( Lim A â†’ Ord A ) ;;
	step 20 : wff = 3jaoi (step 12, step 18, step 19) |- ( ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) â†’ Ord A ) ;;
	step 21 : wff = impbii (step 9, step 20) |- ( Ord A â†” ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) ;;
	qed prop 1 = step 21 ;;
}

/*An ordinal number is zero, a successor ordinal, or a limit ordinal
       number.  (Contributed by NM, 1-Oct-2003.)  (Proof shortened by Andrew
       Salmon, 27-Aug-2011.) */

theorem onzsl (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( A âˆˆ On â†” ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
}

proof of onzsl {
	step 1 : wff = elex () |- ( A âˆˆ On â†’ A âˆˆ _V ) ;;
	step 2 : wff = eloni () |- ( A âˆˆ On â†’ Ord A ) ;;
	step 3 : wff = ordzsl () |- ( Ord A â†” ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) ;;
	step 4 : wff = 3mix1 () |- ( A = âˆ… â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( A âˆˆ _V âˆ§ A = âˆ… ) â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 6 : wff = 3mix2 () |- ( âˆƒ x âˆˆ On A = suc x â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 7 : wff = adantl (step 6) |- ( ( A âˆˆ _V âˆ§ âˆƒ x âˆˆ On A = suc x ) â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 8 : wff = 3mix3 () |- ( ( A âˆˆ _V âˆ§ Lim A ) â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 9 : wff = 3jaodan (step 5, step 7, step 8) |- ( ( A âˆˆ _V âˆ§ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ Lim A ) ) â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 10 : wff = sylan2b (step 3, step 9) |- ( ( A âˆˆ _V âˆ§ Ord A ) â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 11 : wff = syl2anc (step 1, step 2, step 10) |- ( A âˆˆ On â†’ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	step 12 : wff = 0elon () |- âˆ… âˆˆ On ;;
	step 13 : wff = eleq1 () |- ( A = âˆ… â†’ ( A âˆˆ On â†” âˆ… âˆˆ On ) ) ;;
	step 14 : wff = mpbiri (step 12, step 13) |- ( A = âˆ… â†’ A âˆˆ On ) ;;
	step 15 : wff = suceloni () |- ( x âˆˆ On â†’ suc x âˆˆ On ) ;;
	step 16 : wff = eleq1 () |- ( A = suc x â†’ ( A âˆˆ On â†” suc x âˆˆ On ) ) ;;
	step 17 : wff = syl5ibrcom (step 15, step 16) |- ( x âˆˆ On â†’ ( A = suc x â†’ A âˆˆ On ) ) ;;
	step 18 : wff = rexlimiv (step 17) |- ( âˆƒ x âˆˆ On A = suc x â†’ A âˆˆ On ) ;;
	step 19 : wff = limelon () |- ( ( A âˆˆ _V âˆ§ Lim A ) â†’ A âˆˆ On ) ;;
	step 20 : wff = 3jaoi (step 14, step 18, step 19) |- ( ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) â†’ A âˆˆ On ) ;;
	step 21 : wff = impbii (step 11, step 20) |- ( A âˆˆ On â†” ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x âˆ¨ ( A âˆˆ _V âˆ§ Lim A ) ) ) ;;
	qed prop 1 = step 21 ;;
}

/*An alternate definition of a limit ordinal, which is any ordinal that is
       neither zero nor a successor.  (Contributed by NM, 1-Nov-2004.)  (Proof
       shortened by Andrew Salmon, 27-Aug-2011.) */

theorem dflim3 (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Lim A â†” ( Ord A âˆ§ Â¬ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x ) ) ) ;;
}

proof of dflim3 {
	step 1 : wff = df-lim () |- ( Lim A â†” ( Ord A âˆ§ A â‰  âˆ… âˆ§ A = â‹ƒ A ) ) ;;
	step 2 : wff = 3anass () |- ( ( Ord A âˆ§ A â‰  âˆ… âˆ§ A = â‹ƒ A ) â†” ( Ord A âˆ§ ( A â‰  âˆ… âˆ§ A = â‹ƒ A ) ) ) ;;
	step 3 : wff = df-ne () |- ( A â‰  âˆ… â†” Â¬ A = âˆ… ) ;;
	step 4 : wff = a1i (step 3) |- ( Ord A â†’ ( A â‰  âˆ… â†” Â¬ A = âˆ… ) ) ;;
	step 5 : wff = orduninsuc () |- ( Ord A â†’ ( A = â‹ƒ A â†” Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 6 : wff = anbi12d (step 4, step 5) |- ( Ord A â†’ ( ( A â‰  âˆ… âˆ§ A = â‹ƒ A ) â†” ( Â¬ A = âˆ… âˆ§ Â¬ âˆƒ x âˆˆ On A = suc x ) ) ) ;;
	step 7 : wff = ioran () |- ( Â¬ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x ) â†” ( Â¬ A = âˆ… âˆ§ Â¬ âˆƒ x âˆˆ On A = suc x ) ) ;;
	step 8 : wff = syl6bbr (step 6, step 7) |- ( Ord A â†’ ( ( A â‰  âˆ… âˆ§ A = â‹ƒ A ) â†” Â¬ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x ) ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( Ord A âˆ§ ( A â‰  âˆ… âˆ§ A = â‹ƒ A ) ) â†” ( Ord A âˆ§ Â¬ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x ) ) ) ;;
	step 10 : wff = 3bitri (step 1, step 2, step 9) |- ( Lim A â†” ( Ord A âˆ§ Â¬ ( A = âˆ… âˆ¨ âˆƒ x âˆˆ On A = suc x ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*An alternate definition of a limit ordinal.  (Contributed by NM,
       1-Feb-2005.) */

theorem dflim4 (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( Lim A â†” ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
}

proof of dflim4 {
	step 1 : wff = dflim2 () |- ( Lim A â†” ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ A = â‹ƒ A ) ) ;;
	step 2 : wff = ordunisuc2 () |- ( Ord A â†’ ( A = â‹ƒ A â†” âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	step 3 : wff = anbi2d (step 2) |- ( Ord A â†’ ( ( âˆ… âˆˆ A âˆ§ A = â‹ƒ A ) â†” ( âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ) ;;
	step 4 : wff = pm5.32i (step 3) |- ( ( Ord A âˆ§ ( âˆ… âˆˆ A âˆ§ A = â‹ƒ A ) ) â†” ( Ord A âˆ§ ( âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ) ;;
	step 5 : wff = 3anass () |- ( ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ A = â‹ƒ A ) â†” ( Ord A âˆ§ ( âˆ… âˆˆ A âˆ§ A = â‹ƒ A ) ) ) ;;
	step 6 : wff = 3anass () |- ( ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) â†” ( Ord A âˆ§ ( âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ) ;;
	step 7 : wff = 3bitr4i (step 4, step 5, step 6) |- ( ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ A = â‹ƒ A ) â†” ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	step 8 : wff = bitri (step 1, step 7) |- ( Lim A â†” ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	qed prop 1 = step 8 ;;
}

/*The successor of a member of a limit ordinal is also a member.
       (Contributed by NM, 3-Sep-2003.) */

theorem limsuc (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( Lim A â†’ ( B âˆˆ A â†” suc B âˆˆ A ) ) ;;
}

proof of limsuc {
	var x : set;;
	step 1 : wff = dflim4 () |- ( Lim A â†” ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) ) ;;
	step 2 : wff = suceq () |- ( x = B â†’ suc x = suc B ) ;;
	step 3 : wff = eleq1d (step 2) |- ( x = B â†’ ( suc x âˆˆ A â†” suc B âˆˆ A ) ) ;;
	step 4 : wff = rspccv (step 3) |- ( âˆ€ x âˆˆ A suc x âˆˆ A â†’ ( B âˆˆ A â†’ suc B âˆˆ A ) ) ;;
	step 5 : wff = 3ad2ant3 (step 4) |- ( ( Ord A âˆ§ âˆ… âˆˆ A âˆ§ âˆ€ x âˆˆ A suc x âˆˆ A ) â†’ ( B âˆˆ A â†’ suc B âˆˆ A ) ) ;;
	step 6 : wff = sylbi (step 1, step 5) |- ( Lim A â†’ ( B âˆˆ A â†’ suc B âˆˆ A ) ) ;;
	step 7 : wff = limord () |- ( Lim A â†’ Ord A ) ;;
	step 8 : wff = ordtr () |- ( Ord A â†’ Tr A ) ;;
	step 9 : wff = trsuc () |- ( ( Tr A âˆ§ suc B âˆˆ A ) â†’ B âˆˆ A ) ;;
	step 10 : wff = ex (step 9) |- ( Tr A â†’ ( suc B âˆˆ A â†’ B âˆˆ A ) ) ;;
	step 11 : wff = 3syl (step 7, step 8, step 10) |- ( Lim A â†’ ( suc B âˆˆ A â†’ B âˆˆ A ) ) ;;
	step 12 : wff = impbid (step 6, step 11) |- ( Lim A â†’ ( B âˆˆ A â†” suc B âˆˆ A ) ) ;;
	qed prop 1 = step 12 ;;
}

/*A class includes a limit ordinal iff the successor of the class includes
       it.  (Contributed by NM, 30-Oct-2003.) */

theorem limsssuc (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( Lim A â†’ ( A âŠ† B â†” A âŠ† suc B ) ) ;;
}

proof of limsssuc {
	var x : set;;
	step 1 : wff = sssucid () |- B âŠ† suc B ;;
	step 2 : wff = sstr2 () |- ( A âŠ† B â†’ ( B âŠ† suc B â†’ A âŠ† suc B ) ) ;;
	step 3 : wff = mpi (step 1, step 2) |- ( A âŠ† B â†’ A âŠ† suc B ) ;;
	step 4 : wff = eleq1 () |- ( x = B â†’ ( x âˆˆ A â†” B âˆˆ A ) ) ;;
	step 5 : wff = biimpcd (step 4) |- ( x âˆˆ A â†’ ( x = B â†’ B âˆˆ A ) ) ;;
	step 6 : wff = limsuc () |- ( Lim A â†’ ( B âˆˆ A â†” suc B âˆˆ A ) ) ;;
	step 7 : wff = biimpa (step 6) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ suc B âˆˆ A ) ;;
	step 8 : wff = limord () |- ( Lim A â†’ Ord A ) ;;
	step 9 : wff = adantr (step 8) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ Ord A ) ;;
	step 10 : wff = limord () |- ( Lim A â†’ Ord A ) ;;
	step 11 : wff = ordelord () |- ( ( Ord A âˆ§ B âˆˆ A ) â†’ Ord B ) ;;
	step 12 : wff = sylan (step 10, step 11) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ Ord B ) ;;
	step 13 : wff = ordsuc () |- ( Ord B â†” Ord suc B ) ;;
	step 14 : wff = sylib (step 12, step 13) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ Ord suc B ) ;;
	step 15 : wff = ordtri1 () |- ( ( Ord A âˆ§ Ord suc B ) â†’ ( A âŠ† suc B â†” Â¬ suc B âˆˆ A ) ) ;;
	step 16 : wff = syl2anc (step 9, step 14, step 15) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ ( A âŠ† suc B â†” Â¬ suc B âˆˆ A ) ) ;;
	step 17 : wff = con2bid (step 16) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ ( suc B âˆˆ A â†” Â¬ A âŠ† suc B ) ) ;;
	step 18 : wff = mpbid (step 7, step 17) |- ( ( Lim A âˆ§ B âˆˆ A ) â†’ Â¬ A âŠ† suc B ) ;;
	step 19 : wff = ex (step 18) |- ( Lim A â†’ ( B âˆˆ A â†’ Â¬ A âŠ† suc B ) ) ;;
	step 20 : wff = sylan9r (step 5, step 19) |- ( ( Lim A âˆ§ x âˆˆ A ) â†’ ( x = B â†’ Â¬ A âŠ† suc B ) ) ;;
	step 21 : wff = con2d (step 20) |- ( ( Lim A âˆ§ x âˆˆ A ) â†’ ( A âŠ† suc B â†’ Â¬ x = B ) ) ;;
	step 22 : wff = ex (step 21) |- ( Lim A â†’ ( x âˆˆ A â†’ ( A âŠ† suc B â†’ Â¬ x = B ) ) ) ;;
	step 23 : wff = com23 (step 22) |- ( Lim A â†’ ( A âŠ† suc B â†’ ( x âˆˆ A â†’ Â¬ x = B ) ) ) ;;
	step 24 : wff = imp31 (step 23) |- ( ( ( Lim A âˆ§ A âŠ† suc B ) âˆ§ x âˆˆ A ) â†’ Â¬ x = B ) ;;
	step 25 : wff = ssel2 () |- ( ( A âŠ† suc B âˆ§ x âˆˆ A ) â†’ x âˆˆ suc B ) ;;
	step 26 : wff = vex () |- x âˆˆ _V ;;
	step 27 : wff = elsuc (step 26) |- ( x âˆˆ suc B â†” ( x âˆˆ B âˆ¨ x = B ) ) ;;
	step 28 : wff = sylib (step 25, step 27) |- ( ( A âŠ† suc B âˆ§ x âˆˆ A ) â†’ ( x âˆˆ B âˆ¨ x = B ) ) ;;
	step 29 : wff = ord (step 28) |- ( ( A âŠ† suc B âˆ§ x âˆˆ A ) â†’ ( Â¬ x âˆˆ B â†’ x = B ) ) ;;
	step 30 : wff = con1d (step 29) |- ( ( A âŠ† suc B âˆ§ x âˆˆ A ) â†’ ( Â¬ x = B â†’ x âˆˆ B ) ) ;;
	step 31 : wff = adantll (step 30) |- ( ( ( Lim A âˆ§ A âŠ† suc B ) âˆ§ x âˆˆ A ) â†’ ( Â¬ x = B â†’ x âˆˆ B ) ) ;;
	step 32 : wff = mpd (step 24, step 31) |- ( ( ( Lim A âˆ§ A âŠ† suc B ) âˆ§ x âˆˆ A ) â†’ x âˆˆ B ) ;;
	step 33 : wff = ex (step 32) |- ( ( Lim A âˆ§ A âŠ† suc B ) â†’ ( x âˆˆ A â†’ x âˆˆ B ) ) ;;
	step 34 : wff = ssrdv (step 33) |- ( ( Lim A âˆ§ A âŠ† suc B ) â†’ A âŠ† B ) ;;
	step 35 : wff = ex (step 34) |- ( Lim A â†’ ( A âŠ† suc B â†’ A âŠ† B ) ) ;;
	step 36 : wff = impbid2 (step 3, step 35) |- ( Lim A â†’ ( A âŠ† B â†” A âŠ† suc B ) ) ;;
	qed prop 1 = step 36 ;;
}

/*Two ways to express the class of non-limit ordinal numbers.  Part of
       Definition 7.27 of [TakeutiZaring] p. 42, who use the symbol K_I for
       this class.  (Contributed by NM, 1-Nov-2004.) */

theorem nlimon (x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- { x âˆˆ On | ( x = âˆ… âˆ¨ âˆƒ y âˆˆ On x = suc y ) } = { x âˆˆ On | Â¬ Lim x } ;;
}

proof of nlimon {
	step 1 : wff = eloni () |- ( x âˆˆ On â†’ Ord x ) ;;
	step 2 : wff = dflim3 () |- ( Lim x â†” ( Ord x âˆ§ Â¬ ( x = âˆ… âˆ¨ âˆƒ y âˆˆ On x = suc y ) ) ) ;;
	step 3 : wff = baib (step 2) |- ( Ord x â†’ ( Lim x â†” Â¬ ( x = âˆ… âˆ¨ âˆƒ y âˆˆ On x = suc y ) ) ) ;;
	step 4 : wff = con2bid (step 3) |- ( Ord x â†’ ( ( x = âˆ… âˆ¨ âˆƒ y âˆˆ On x = suc y ) â†” Â¬ Lim x ) ) ;;
	step 5 : wff = syl (step 1, step 4) |- ( x âˆˆ On â†’ ( ( x = âˆ… âˆ¨ âˆƒ y âˆˆ On x = suc y ) â†” Â¬ Lim x ) ) ;;
	step 6 : wff = rabbiia (step 5) |- { x âˆˆ On | ( x = âˆ… âˆ¨ âˆƒ y âˆˆ On x = suc y ) } = { x âˆˆ On | Â¬ Lim x } ;;
	qed prop 1 = step 6 ;;
}

/*The union of a nonempty class of limit ordinals is a limit ordinal.
       (Contributed by NM, 1-Feb-2005.) */

theorem limuni3 (x : set, A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( ( A â‰  âˆ… âˆ§ âˆ€ x âˆˆ A Lim x ) â†’ Lim â‹ƒ A ) ;;
}

proof of limuni3 {
	var y : set, z : set;;
	step 1 : wff = limeq () |- ( x = z â†’ ( Lim x â†” Lim z ) ) ;;
	step 2 : wff = rspcv (step 1) |- ( z âˆˆ A â†’ ( âˆ€ x âˆˆ A Lim x â†’ Lim z ) ) ;;
	step 3 : wff = vex () |- z âˆˆ _V ;;
	step 4 : wff = limelon () |- ( ( z âˆˆ _V âˆ§ Lim z ) â†’ z âˆˆ On ) ;;
	step 5 : wff = mpan (step 3, step 4) |- ( Lim z â†’ z âˆˆ On ) ;;
	step 6 : wff = syl6com (step 2, step 5) |- ( âˆ€ x âˆˆ A Lim x â†’ ( z âˆˆ A â†’ z âˆˆ On ) ) ;;
	step 7 : wff = ssrdv (step 6) |- ( âˆ€ x âˆˆ A Lim x â†’ A âŠ† On ) ;;
	step 8 : wff = ssorduni () |- ( A âŠ† On â†’ Ord â‹ƒ A ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( âˆ€ x âˆˆ A Lim x â†’ Ord â‹ƒ A ) ;;
	step 10 : wff = adantl (step 9) |- ( ( A â‰  âˆ… âˆ§ âˆ€ x âˆˆ A Lim x ) â†’ Ord â‹ƒ A ) ;;
	step 11 : wff = n0 () |- ( A â‰  âˆ… â†” âˆƒ z z âˆˆ A ) ;;
	step 12 : wff = limeq () |- ( x = z â†’ ( Lim x â†” Lim z ) ) ;;
	step 13 : wff = rspcv (step 12) |- ( z âˆˆ A â†’ ( âˆ€ x âˆˆ A Lim x â†’ Lim z ) ) ;;
	step 14 : wff = 0ellim () |- ( Lim z â†’ âˆ… âˆˆ z ) ;;
	step 15 : wff = elunii () |- ( ( âˆ… âˆˆ z âˆ§ z âˆˆ A ) â†’ âˆ… âˆˆ â‹ƒ A ) ;;
	step 16 : wff = expcom (step 15) |- ( z âˆˆ A â†’ ( âˆ… âˆˆ z â†’ âˆ… âˆˆ â‹ƒ A ) ) ;;
	step 17 : wff = syl5 (step 14, step 16) |- ( z âˆˆ A â†’ ( Lim z â†’ âˆ… âˆˆ â‹ƒ A ) ) ;;
	step 18 : wff = syld (step 13, step 17) |- ( z âˆˆ A â†’ ( âˆ€ x âˆˆ A Lim x â†’ âˆ… âˆˆ â‹ƒ A ) ) ;;
	step 19 : wff = exlimiv (step 18) |- ( âˆƒ z z âˆˆ A â†’ ( âˆ€ x âˆˆ A Lim x â†’ âˆ… âˆˆ â‹ƒ A ) ) ;;
	step 20 : wff = sylbi (step 11, step 19) |- ( A â‰  âˆ… â†’ ( âˆ€ x âˆˆ A Lim x â†’ âˆ… âˆˆ â‹ƒ A ) ) ;;
	step 21 : wff = imp (step 20) |- ( ( A â‰  âˆ… âˆ§ âˆ€ x âˆˆ A Lim x ) â†’ âˆ… âˆˆ â‹ƒ A ) ;;
	step 22 : wff = eluni2 () |- ( y âˆˆ â‹ƒ A â†” âˆƒ z âˆˆ A y âˆˆ z ) ;;
	step 23 : wff = limeq () |- ( x = z â†’ ( Lim x â†” Lim z ) ) ;;
	step 24 : wff = rspccv (step 23) |- ( âˆ€ x âˆˆ A Lim x â†’ ( z âˆˆ A â†’ Lim z ) ) ;;
	step 25 : wff = limsuc () |- ( Lim z â†’ ( y âˆˆ z â†” suc y âˆˆ z ) ) ;;
	step 26 : wff = anbi1d (step 25) |- ( Lim z â†’ ( ( y âˆˆ z âˆ§ z âˆˆ A ) â†” ( suc y âˆˆ z âˆ§ z âˆˆ A ) ) ) ;;
	step 27 : wff = elunii () |- ( ( suc y âˆˆ z âˆ§ z âˆˆ A ) â†’ suc y âˆˆ â‹ƒ A ) ;;
	step 28 : wff = syl6bi (step 26, step 27) |- ( Lim z â†’ ( ( y âˆˆ z âˆ§ z âˆˆ A ) â†’ suc y âˆˆ â‹ƒ A ) ) ;;
	step 29 : wff = exp3a (step 28) |- ( Lim z â†’ ( y âˆˆ z â†’ ( z âˆˆ A â†’ suc y âˆˆ â‹ƒ A ) ) ) ;;
	step 30 : wff = com3r (step 29) |- ( z âˆˆ A â†’ ( Lim z â†’ ( y âˆˆ z â†’ suc y âˆˆ â‹ƒ A ) ) ) ;;
	step 31 : wff = sylcom (step 24, step 30) |- ( âˆ€ x âˆˆ A Lim x â†’ ( z âˆˆ A â†’ ( y âˆˆ z â†’ suc y âˆˆ â‹ƒ A ) ) ) ;;
	step 32 : wff = rexlimdv (step 31) |- ( âˆ€ x âˆˆ A Lim x â†’ ( âˆƒ z âˆˆ A y âˆˆ z â†’ suc y âˆˆ â‹ƒ A ) ) ;;
	step 33 : wff = syl5bi (step 22, step 32) |- ( âˆ€ x âˆˆ A Lim x â†’ ( y âˆˆ â‹ƒ A â†’ suc y âˆˆ â‹ƒ A ) ) ;;
	step 34 : wff = ralrimiv (step 33) |- ( âˆ€ x âˆˆ A Lim x â†’ âˆ€ y âˆˆ â‹ƒ A suc y âˆˆ â‹ƒ A ) ;;
	step 35 : wff = adantl (step 34) |- ( ( A â‰  âˆ… âˆ§ âˆ€ x âˆˆ A Lim x ) â†’ âˆ€ y âˆˆ â‹ƒ A suc y âˆˆ â‹ƒ A ) ;;
	step 36 : wff = dflim4 () |- ( Lim â‹ƒ A â†” ( Ord â‹ƒ A âˆ§ âˆ… âˆˆ â‹ƒ A âˆ§ âˆ€ y âˆˆ â‹ƒ A suc y âˆˆ â‹ƒ A ) ) ;;
	step 37 : wff = syl3anbrc (step 10, step 21, step 35, step 36) |- ( ( A â‰  âˆ… âˆ§ âˆ€ x âˆˆ A Lim x ) â†’ Lim â‹ƒ A ) ;;
	qed prop 1 = step 37 ;;
}


