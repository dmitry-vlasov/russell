import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Function_operation.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        First and second members of an ordered pair

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

constant {
	symbol 1st ;;
}

/* First member of an ordered pair */

constant {
	symbol 2nd ;;
}

/* Second member of an ordered pair */

/* Extend the definition of a class to include the first member an ordered
     pair function. */

rule c1st () {
	term : class = # 1st ;;
}

/* Extend the definition of a class to include the second member an ordered
     pair function. */

rule c2nd () {
	term : class = # 2nd ;;
}

/* Define a function that extracts the first member, or abscissa, of an
     ordered pair.  Theorem ~ op1st proves that it does this.  For example,
     ` ( 1st `` <. 3 , 4 >. ) = 3 ` .  Equivalent to Definition 5.13 (i) of
     [Monk1] p. 52 (compare ~ op1sta and ~ op1stb ).  The notation is the same
     as Monk's.  (Contributed by NM, 9-Oct-2004.) */

definition df-1st (x : set)  {
	defiendum : class = # 1st ;;
	definiens : class = # ( x ∈ _V ↦ ⋃ dom { x } ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Define a function that extracts the second member, or ordinate, of an
     ordered pair.  Theorem ~ op2nd proves that it does this.  For example,
     ` ( 2nd `` <. 3 , 4 >. ) = 4 ` .  Equivalent to Definition 5.13 (ii) of
     [Monk1] p. 52 (compare ~ op2nda and ~ op2ndb ).  The notation is the same
     as Monk's.  (Contributed by NM, 9-Oct-2004.) */

definition df-2nd (x : set)  {
	defiendum : class = # 2nd ;;
	definiens : class = # ( x ∈ _V ↦ ⋃ ran { x } ) ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* The value of the function that extracts the first member of an ordered
       pair.  (Contributed by NM, 9-Oct-2004.)  (Revised by Mario Carneiro,
       8-Sep-2013.) */

theorem 1stval (A : class) disjointed(x A) {
	prop 1 : wff = |- ( 1st ` A ) = ⋃ dom { A } ;;
}

proof of 1stval {
	var x : set;;
	step 1 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 2 : wff = dmeqd (step 1) |- ( x = A → dom { x } = dom { A } ) ;;
	step 3 : wff = unieqd (step 2) |- ( x = A → ⋃ dom { x } = ⋃ dom { A } ) ;;
	step 4 : wff = df-1st () |- 1st = ( x ∈ _V ↦ ⋃ dom { x } ) ;;
	step 5 : wff = snex () |- { A } ∈ _V ;;
	step 6 : wff = dmex (step 5) |- dom { A } ∈ _V ;;
	step 7 : wff = uniex (step 6) |- ⋃ dom { A } ∈ _V ;;
	step 8 : wff = fvmpt (step 3, step 4, step 7) |- ( A ∈ _V → ( 1st ` A ) = ⋃ dom { A } ) ;;
	step 9 : wff = fvprc () |- ( ¬ A ∈ _V → ( 1st ` A ) = ∅ ) ;;
	step 10 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 11 : wff = biimpi (step 10) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 12 : wff = dmeqd (step 11) |- ( ¬ A ∈ _V → dom { A } = dom ∅ ) ;;
	step 13 : wff = dm0 () |- dom ∅ = ∅ ;;
	step 14 : wff = syl6eq (step 12, step 13) |- ( ¬ A ∈ _V → dom { A } = ∅ ) ;;
	step 15 : wff = unieqd (step 14) |- ( ¬ A ∈ _V → ⋃ dom { A } = ⋃ ∅ ) ;;
	step 16 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 17 : wff = syl6eq (step 15, step 16) |- ( ¬ A ∈ _V → ⋃ dom { A } = ∅ ) ;;
	step 18 : wff = eqtr4d (step 9, step 17) |- ( ¬ A ∈ _V → ( 1st ` A ) = ⋃ dom { A } ) ;;
	step 19 : wff = pm2.61i (step 8, step 18) |- ( 1st ` A ) = ⋃ dom { A } ;;
	qed prop 1 = step 19 ;;
}

/* The value of the function that extracts the second member of an ordered
       pair.  (Contributed by NM, 9-Oct-2004.)  (Revised by Mario Carneiro,
       8-Sep-2013.) */

theorem 2ndval (A : class) disjointed(x A) {
	prop 1 : wff = |- ( 2nd ` A ) = ⋃ ran { A } ;;
}

proof of 2ndval {
	var x : set;;
	step 1 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 2 : wff = rneqd (step 1) |- ( x = A → ran { x } = ran { A } ) ;;
	step 3 : wff = unieqd (step 2) |- ( x = A → ⋃ ran { x } = ⋃ ran { A } ) ;;
	step 4 : wff = df-2nd () |- 2nd = ( x ∈ _V ↦ ⋃ ran { x } ) ;;
	step 5 : wff = snex () |- { A } ∈ _V ;;
	step 6 : wff = rnex (step 5) |- ran { A } ∈ _V ;;
	step 7 : wff = uniex (step 6) |- ⋃ ran { A } ∈ _V ;;
	step 8 : wff = fvmpt (step 3, step 4, step 7) |- ( A ∈ _V → ( 2nd ` A ) = ⋃ ran { A } ) ;;
	step 9 : wff = fvprc () |- ( ¬ A ∈ _V → ( 2nd ` A ) = ∅ ) ;;
	step 10 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 11 : wff = biimpi (step 10) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 12 : wff = rneqd (step 11) |- ( ¬ A ∈ _V → ran { A } = ran ∅ ) ;;
	step 13 : wff = rn0 () |- ran ∅ = ∅ ;;
	step 14 : wff = syl6eq (step 12, step 13) |- ( ¬ A ∈ _V → ran { A } = ∅ ) ;;
	step 15 : wff = unieqd (step 14) |- ( ¬ A ∈ _V → ⋃ ran { A } = ⋃ ∅ ) ;;
	step 16 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 17 : wff = syl6eq (step 15, step 16) |- ( ¬ A ∈ _V → ⋃ ran { A } = ∅ ) ;;
	step 18 : wff = eqtr4d (step 9, step 17) |- ( ¬ A ∈ _V → ( 2nd ` A ) = ⋃ ran { A } ) ;;
	step 19 : wff = pm2.61i (step 8, step 18) |- ( 2nd ` A ) = ⋃ ran { A } ;;
	qed prop 1 = step 19 ;;
}

/* The value of the first-member function at the empty set.  (Contributed by
     NM, 23-Apr-2007.) */

theorem 1st0 ()  {
	prop 1 : wff = |- ( 1st ` ∅ ) = ∅ ;;
}

proof of 1st0 {
	step 1 : wff = 1stval () |- ( 1st ` ∅ ) = ⋃ dom { ∅ } ;;
	step 2 : wff = dmsn0 () |- dom { ∅ } = ∅ ;;
	step 3 : wff = unieqi (step 2) |- ⋃ dom { ∅ } = ⋃ ∅ ;;
	step 4 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 5 : wff = 3eqtri (step 1, step 3, step 4) |- ( 1st ` ∅ ) = ∅ ;;
	qed prop 1 = step 5 ;;
}

/* The value of the second-member function at the empty set.  (Contributed by
     NM, 23-Apr-2007.) */

theorem 2nd0 ()  {
	prop 1 : wff = |- ( 2nd ` ∅ ) = ∅ ;;
}

proof of 2nd0 {
	step 1 : wff = 2ndval () |- ( 2nd ` ∅ ) = ⋃ ran { ∅ } ;;
	step 2 : wff = dmsn0 () |- dom { ∅ } = ∅ ;;
	step 3 : wff = dm0rn0 () |- ( dom { ∅ } = ∅ ↔ ran { ∅ } = ∅ ) ;;
	step 4 : wff = mpbi (step 2, step 3) |- ran { ∅ } = ∅ ;;
	step 5 : wff = unieqi (step 4) |- ⋃ ran { ∅ } = ⋃ ∅ ;;
	step 6 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 7 : wff = 3eqtri (step 1, step 5, step 6) |- ( 2nd ` ∅ ) = ∅ ;;
	qed prop 1 = step 7 ;;
}

/* Extract the first member of an ordered pair.  (Contributed by NM,
       5-Oct-2004.) */

theorem op1st (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 1st ` 〈 A , B 〉 ) = A ;;
}

proof of op1st {
	step 1 : wff = 1stval () |- ( 1st ` 〈 A , B 〉 ) = ⋃ dom { 〈 A , B 〉 } ;;
	step 2 : wff = op1sta (hyp 1, hyp 2) |- ⋃ dom { 〈 A , B 〉 } = A ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( 1st ` 〈 A , B 〉 ) = A ;;
	qed prop 1 = step 3 ;;
}

/* Extract the second member of an ordered pair.  (Contributed by NM,
       5-Oct-2004.) */

theorem op2nd (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( 2nd ` 〈 A , B 〉 ) = B ;;
}

proof of op2nd {
	step 1 : wff = 2ndval () |- ( 2nd ` 〈 A , B 〉 ) = ⋃ ran { 〈 A , B 〉 } ;;
	step 2 : wff = op2nda (hyp 1, hyp 2) |- ⋃ ran { 〈 A , B 〉 } = B ;;
	step 3 : wff = eqtri (step 1, step 2) |- ( 2nd ` 〈 A , B 〉 ) = B ;;
	qed prop 1 = step 3 ;;
}

/* Extract the first member of an ordered pair.  (Contributed by Mario
       Carneiro, 31-Aug-2015.) */

theorem op1std (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( C = 〈 A , B 〉 → ( 1st ` C ) = A ) ;;
}

proof of op1std {
	step 1 : wff = fveq2 () |- ( C = 〈 A , B 〉 → ( 1st ` C ) = ( 1st ` 〈 A , B 〉 ) ) ;;
	step 2 : wff = op1st (hyp 1, hyp 2) |- ( 1st ` 〈 A , B 〉 ) = A ;;
	step 3 : wff = syl6eq (step 1, step 2) |- ( C = 〈 A , B 〉 → ( 1st ` C ) = A ) ;;
	qed prop 1 = step 3 ;;
}

/* Extract the second member of an ordered pair.  (Contributed by Mario
       Carneiro, 31-Aug-2015.) */

theorem op2ndd (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( C = 〈 A , B 〉 → ( 2nd ` C ) = B ) ;;
}

proof of op2ndd {
	step 1 : wff = fveq2 () |- ( C = 〈 A , B 〉 → ( 2nd ` C ) = ( 2nd ` 〈 A , B 〉 ) ) ;;
	step 2 : wff = op2nd (hyp 1, hyp 2) |- ( 2nd ` 〈 A , B 〉 ) = B ;;
	step 3 : wff = syl6eq (step 1, step 2) |- ( C = 〈 A , B 〉 → ( 2nd ` C ) = B ) ;;
	qed prop 1 = step 3 ;;
}

/* Extract the first member of an ordered pair.  (Contributed by NM,
       19-Jul-2005.) */

theorem op1stg (A : class, B : class, V : class, W : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( 1st ` 〈 A , B 〉 ) = A ) ;;
}

proof of op1stg {
	var x : set, y : set;;
	step 1 : wff = opeq1 () |- ( x = A → 〈 x , y 〉 = 〈 A , y 〉 ) ;;
	step 2 : wff = fveq2d (step 1) |- ( x = A → ( 1st ` 〈 x , y 〉 ) = ( 1st ` 〈 A , y 〉 ) ) ;;
	step 3 : wff = id () |- ( x = A → x = A ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( x = A → ( ( 1st ` 〈 x , y 〉 ) = x ↔ ( 1st ` 〈 A , y 〉 ) = A ) ) ;;
	step 5 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 6 : wff = fveq2d (step 5) |- ( y = B → ( 1st ` 〈 A , y 〉 ) = ( 1st ` 〈 A , B 〉 ) ) ;;
	step 7 : wff = eqeq1d (step 6) |- ( y = B → ( ( 1st ` 〈 A , y 〉 ) = A ↔ ( 1st ` 〈 A , B 〉 ) = A ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = op1st (step 8, step 9) |- ( 1st ` 〈 x , y 〉 ) = x ;;
	step 11 : wff = vtocl2g (step 4, step 7, step 10) |- ( ( A ∈ V ∧ B ∈ W ) → ( 1st ` 〈 A , B 〉 ) = A ) ;;
	qed prop 1 = step 11 ;;
}

/* Extract the second member of an ordered pair.  (Contributed by NM,
       19-Jul-2005.) */

theorem op2ndg (A : class, B : class, V : class, W : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( 2nd ` 〈 A , B 〉 ) = B ) ;;
}

proof of op2ndg {
	var x : set, y : set;;
	step 1 : wff = opeq1 () |- ( x = A → 〈 x , y 〉 = 〈 A , y 〉 ) ;;
	step 2 : wff = fveq2d (step 1) |- ( x = A → ( 2nd ` 〈 x , y 〉 ) = ( 2nd ` 〈 A , y 〉 ) ) ;;
	step 3 : wff = eqeq1d (step 2) |- ( x = A → ( ( 2nd ` 〈 x , y 〉 ) = y ↔ ( 2nd ` 〈 A , y 〉 ) = y ) ) ;;
	step 4 : wff = opeq2 () |- ( y = B → 〈 A , y 〉 = 〈 A , B 〉 ) ;;
	step 5 : wff = fveq2d (step 4) |- ( y = B → ( 2nd ` 〈 A , y 〉 ) = ( 2nd ` 〈 A , B 〉 ) ) ;;
	step 6 : wff = id () |- ( y = B → y = B ) ;;
	step 7 : wff = eqeq12d (step 5, step 6) |- ( y = B → ( ( 2nd ` 〈 A , y 〉 ) = y ↔ ( 2nd ` 〈 A , B 〉 ) = B ) ) ;;
	step 8 : wff = vex () |- x ∈ _V ;;
	step 9 : wff = vex () |- y ∈ _V ;;
	step 10 : wff = op2nd (step 8, step 9) |- ( 2nd ` 〈 x , y 〉 ) = y ;;
	step 11 : wff = vtocl2g (step 3, step 7, step 10) |- ( ( A ∈ V ∧ B ∈ W ) → ( 2nd ` 〈 A , B 〉 ) = B ) ;;
	qed prop 1 = step 11 ;;
}

/* Extract the first member of an ordered triple.  (Due to infrequent
       usage, it isn't worthwhile at this point to define special extractors
       for triples, so we reuse the ordered pair extractors for ~ ot1stg ,
       ~ ot2ndg , ~ ot3rdg .)  (Contributed by NM, 3-Apr-2015.)  (Revised by
       Mario Carneiro, 2-May-2015.) */

theorem ot1stg (A : class, B : class, C : class, V : class, W : class, X : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 1st ` ( 1st ` 〈 A , B , C 〉 ) ) = A ) ;;
}

proof of ot1stg {
	step 1 : wff = df-ot () |- 〈 A , B , C 〉 = 〈 〈 A , B 〉 , C 〉 ;;
	step 2 : wff = fveq2i (step 1) |- ( 1st ` 〈 A , B , C 〉 ) = ( 1st ` 〈 〈 A , B 〉 , C 〉 ) ;;
	step 3 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 4 : wff = op1stg () |- ( ( 〈 A , B 〉 ∈ _V ∧ C ∈ X ) → ( 1st ` 〈 〈 A , B 〉 , C 〉 ) = 〈 A , B 〉 ) ;;
	step 5 : wff = mpan (step 3, step 4) |- ( C ∈ X → ( 1st ` 〈 〈 A , B 〉 , C 〉 ) = 〈 A , B 〉 ) ;;
	step 6 : wff = syl5eq (step 2, step 5) |- ( C ∈ X → ( 1st ` 〈 A , B , C 〉 ) = 〈 A , B 〉 ) ;;
	step 7 : wff = fveq2d (step 6) |- ( C ∈ X → ( 1st ` ( 1st ` 〈 A , B , C 〉 ) ) = ( 1st ` 〈 A , B 〉 ) ) ;;
	step 8 : wff = op1stg () |- ( ( A ∈ V ∧ B ∈ W ) → ( 1st ` 〈 A , B 〉 ) = A ) ;;
	step 9 : wff = sylan9eqr (step 7, step 8) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ C ∈ X ) → ( 1st ` ( 1st ` 〈 A , B , C 〉 ) ) = A ) ;;
	step 10 : wff = 3impa (step 9) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 1st ` ( 1st ` 〈 A , B , C 〉 ) ) = A ) ;;
	qed prop 1 = step 10 ;;
}

/* Extract the second member of an ordered triple.  (See ~ ot1stg
       comment.)  (Contributed by NM, 3-Apr-2015.)  (Revised by Mario Carneiro,
       2-May-2015.) */

theorem ot2ndg (A : class, B : class, C : class, V : class, W : class, X : class)  {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 2nd ` ( 1st ` 〈 A , B , C 〉 ) ) = B ) ;;
}

proof of ot2ndg {
	step 1 : wff = df-ot () |- 〈 A , B , C 〉 = 〈 〈 A , B 〉 , C 〉 ;;
	step 2 : wff = fveq2i (step 1) |- ( 1st ` 〈 A , B , C 〉 ) = ( 1st ` 〈 〈 A , B 〉 , C 〉 ) ;;
	step 3 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 4 : wff = op1stg () |- ( ( 〈 A , B 〉 ∈ _V ∧ C ∈ X ) → ( 1st ` 〈 〈 A , B 〉 , C 〉 ) = 〈 A , B 〉 ) ;;
	step 5 : wff = mpan (step 3, step 4) |- ( C ∈ X → ( 1st ` 〈 〈 A , B 〉 , C 〉 ) = 〈 A , B 〉 ) ;;
	step 6 : wff = syl5eq (step 2, step 5) |- ( C ∈ X → ( 1st ` 〈 A , B , C 〉 ) = 〈 A , B 〉 ) ;;
	step 7 : wff = fveq2d (step 6) |- ( C ∈ X → ( 2nd ` ( 1st ` 〈 A , B , C 〉 ) ) = ( 2nd ` 〈 A , B 〉 ) ) ;;
	step 8 : wff = op2ndg () |- ( ( A ∈ V ∧ B ∈ W ) → ( 2nd ` 〈 A , B 〉 ) = B ) ;;
	step 9 : wff = sylan9eqr (step 7, step 8) |- ( ( ( A ∈ V ∧ B ∈ W ) ∧ C ∈ X ) → ( 2nd ` ( 1st ` 〈 A , B , C 〉 ) ) = B ) ;;
	step 10 : wff = 3impa (step 9) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( 2nd ` ( 1st ` 〈 A , B , C 〉 ) ) = B ) ;;
	qed prop 1 = step 10 ;;
}

/* Extract the third member of an ordered triple.  (See ~ ot1stg comment.)
       (Contributed by NM, 3-Apr-2015.) */

theorem ot3rdg (A : class, B : class, C : class, V : class)  {
	prop 1 : wff = |- ( C ∈ V → ( 2nd ` 〈 A , B , C 〉 ) = C ) ;;
}

proof of ot3rdg {
	step 1 : wff = df-ot () |- 〈 A , B , C 〉 = 〈 〈 A , B 〉 , C 〉 ;;
	step 2 : wff = fveq2i (step 1) |- ( 2nd ` 〈 A , B , C 〉 ) = ( 2nd ` 〈 〈 A , B 〉 , C 〉 ) ;;
	step 3 : wff = opex () |- 〈 A , B 〉 ∈ _V ;;
	step 4 : wff = op2ndg () |- ( ( 〈 A , B 〉 ∈ _V ∧ C ∈ V ) → ( 2nd ` 〈 〈 A , B 〉 , C 〉 ) = C ) ;;
	step 5 : wff = mpan (step 3, step 4) |- ( C ∈ V → ( 2nd ` 〈 〈 A , B 〉 , C 〉 ) = C ) ;;
	step 6 : wff = syl5eq (step 2, step 5) |- ( C ∈ V → ( 2nd ` 〈 A , B , C 〉 ) = C ) ;;
	qed prop 1 = step 6 ;;
}

/* Alternate value of the function that extracts the first member of an
       ordered pair.  Definition 5.13 (i) of [Monk1] p. 52.  (Contributed by
       NM, 18-Aug-2006.) */

theorem 1stval2 (A : class) disjointed(x y A, x y) {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) → ( 1st ` A ) = ⋂ ⋂ A ) ;;
}

proof of 1stval2 {
	var x : set, y : set;;
	step 1 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = op1st (step 2, step 3) |- ( 1st ` 〈 x , y 〉 ) = x ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = op1stb (step 5, step 6) |- ⋂ ⋂ 〈 x , y 〉 = x ;;
	step 8 : wff = eqtr4i (step 4, step 7) |- ( 1st ` 〈 x , y 〉 ) = ⋂ ⋂ 〈 x , y 〉 ;;
	step 9 : wff = fveq2 () |- ( A = 〈 x , y 〉 → ( 1st ` A ) = ( 1st ` 〈 x , y 〉 ) ) ;;
	step 10 : wff = inteq () |- ( A = 〈 x , y 〉 → ⋂ A = ⋂ 〈 x , y 〉 ) ;;
	step 11 : wff = inteqd (step 10) |- ( A = 〈 x , y 〉 → ⋂ ⋂ A = ⋂ ⋂ 〈 x , y 〉 ) ;;
	step 12 : wff = 3eqtr4a (step 8, step 9, step 11) |- ( A = 〈 x , y 〉 → ( 1st ` A ) = ⋂ ⋂ A ) ;;
	step 13 : wff = exlimivv (step 12) |- ( ∃ x ∃ y A = 〈 x , y 〉 → ( 1st ` A ) = ⋂ ⋂ A ) ;;
	step 14 : wff = sylbi (step 1, step 13) |- ( A ∈ ( _V × _V ) → ( 1st ` A ) = ⋂ ⋂ A ) ;;
	qed prop 1 = step 14 ;;
}

/* Alternate value of the function that extracts the second member of an
       ordered pair.  Definition 5.13 (ii) of [Monk1] p. 52.  (Contributed by
       NM, 18-Aug-2006.) */

theorem 2ndval2 (A : class) disjointed(x y A, x y) {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) → ( 2nd ` A ) = ⋂ ⋂ ⋂ ⁻¹ { A } ) ;;
}

proof of 2ndval2 {
	var x : set, y : set;;
	step 1 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = op2nd (step 2, step 3) |- ( 2nd ` 〈 x , y 〉 ) = y ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = op2ndb (step 5, step 6) |- ⋂ ⋂ ⋂ ⁻¹ { 〈 x , y 〉 } = y ;;
	step 8 : wff = eqtr4i (step 4, step 7) |- ( 2nd ` 〈 x , y 〉 ) = ⋂ ⋂ ⋂ ⁻¹ { 〈 x , y 〉 } ;;
	step 9 : wff = fveq2 () |- ( A = 〈 x , y 〉 → ( 2nd ` A ) = ( 2nd ` 〈 x , y 〉 ) ) ;;
	step 10 : wff = sneq () |- ( A = 〈 x , y 〉 → { A } = { 〈 x , y 〉 } ) ;;
	step 11 : wff = cnveqd (step 10) |- ( A = 〈 x , y 〉 → ⁻¹ { A } = ⁻¹ { 〈 x , y 〉 } ) ;;
	step 12 : wff = inteqd (step 11) |- ( A = 〈 x , y 〉 → ⋂ ⁻¹ { A } = ⋂ ⁻¹ { 〈 x , y 〉 } ) ;;
	step 13 : wff = inteqd (step 12) |- ( A = 〈 x , y 〉 → ⋂ ⋂ ⁻¹ { A } = ⋂ ⋂ ⁻¹ { 〈 x , y 〉 } ) ;;
	step 14 : wff = inteqd (step 13) |- ( A = 〈 x , y 〉 → ⋂ ⋂ ⋂ ⁻¹ { A } = ⋂ ⋂ ⋂ ⁻¹ { 〈 x , y 〉 } ) ;;
	step 15 : wff = 3eqtr4a (step 8, step 9, step 14) |- ( A = 〈 x , y 〉 → ( 2nd ` A ) = ⋂ ⋂ ⋂ ⁻¹ { A } ) ;;
	step 16 : wff = exlimivv (step 15) |- ( ∃ x ∃ y A = 〈 x , y 〉 → ( 2nd ` A ) = ⋂ ⋂ ⋂ ⁻¹ { A } ) ;;
	step 17 : wff = sylbi (step 1, step 16) |- ( A ∈ ( _V × _V ) → ( 2nd ` A ) = ⋂ ⋂ ⋂ ⁻¹ { A } ) ;;
	qed prop 1 = step 17 ;;
}

/* The ` 1st ` function maps the universe onto the universe.  (Contributed
       by NM, 14-Oct-2004.)  (Revised by Mario Carneiro, 8-Sep-2013.) */

theorem fo1st () disjointed(x y, x y, x y) {
	prop 1 : wff = |- 1st : _V ↠ _V ;;
}

proof of fo1st {
	var x : set, y : set;;
	step 1 : wff = snex () |- { x } ∈ _V ;;
	step 2 : wff = dmex (step 1) |- dom { x } ∈ _V ;;
	step 3 : wff = uniex (step 2) |- ⋃ dom { x } ∈ _V ;;
	step 4 : wff = df-1st () |- 1st = ( x ∈ _V ↦ ⋃ dom { x } ) ;;
	step 5 : wff = fnmpti (step 3, step 4) |- 1st Fn _V ;;
	step 6 : wff = df-1st () |- 1st = ( x ∈ _V ↦ ⋃ dom { x } ) ;;
	step 7 : wff = rnmpt (step 6) |- ran 1st = { y | ∃ x ∈ _V y = ⋃ dom { x } } ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opex () |- 〈 y , y 〉 ∈ _V ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = op1sta (step 10, step 11) |- ⋃ dom { 〈 y , y 〉 } = y ;;
	step 13 : wff = eqcomi (step 12) |- y = ⋃ dom { 〈 y , y 〉 } ;;
	step 14 : wff = sneq () |- ( x = 〈 y , y 〉 → { x } = { 〈 y , y 〉 } ) ;;
	step 15 : wff = dmeqd (step 14) |- ( x = 〈 y , y 〉 → dom { x } = dom { 〈 y , y 〉 } ) ;;
	step 16 : wff = unieqd (step 15) |- ( x = 〈 y , y 〉 → ⋃ dom { x } = ⋃ dom { 〈 y , y 〉 } ) ;;
	step 17 : wff = eqeq2d (step 16) |- ( x = 〈 y , y 〉 → ( y = ⋃ dom { x } ↔ y = ⋃ dom { 〈 y , y 〉 } ) ) ;;
	step 18 : wff = rspcev (step 17) |- ( ( 〈 y , y 〉 ∈ _V ∧ y = ⋃ dom { 〈 y , y 〉 } ) → ∃ x ∈ _V y = ⋃ dom { x } ) ;;
	step 19 : wff = mp2an (step 9, step 13, step 18) |- ∃ x ∈ _V y = ⋃ dom { x } ;;
	step 20 : wff = 2th (step 8, step 19) |- ( y ∈ _V ↔ ∃ x ∈ _V y = ⋃ dom { x } ) ;;
	step 21 : wff = abbi2i (step 20) |- _V = { y | ∃ x ∈ _V y = ⋃ dom { x } } ;;
	step 22 : wff = eqtr4i (step 7, step 21) |- ran 1st = _V ;;
	step 23 : wff = df-fo () |- ( 1st : _V ↠ _V ↔ ( 1st Fn _V ∧ ran 1st = _V ) ) ;;
	step 24 : wff = mpbir2an (step 5, step 22, step 23) |- 1st : _V ↠ _V ;;
	qed prop 1 = step 24 ;;
}

/* The ` 2nd ` function maps the universe onto the universe.  (Contributed
       by NM, 14-Oct-2004.)  (Revised by Mario Carneiro, 8-Sep-2013.) */

theorem fo2nd () disjointed(x y, x y, x y, x y, x y, x y) {
	prop 1 : wff = |- 2nd : _V ↠ _V ;;
}

proof of fo2nd {
	var x : set, y : set;;
	step 1 : wff = snex () |- { x } ∈ _V ;;
	step 2 : wff = rnex (step 1) |- ran { x } ∈ _V ;;
	step 3 : wff = uniex (step 2) |- ⋃ ran { x } ∈ _V ;;
	step 4 : wff = df-2nd () |- 2nd = ( x ∈ _V ↦ ⋃ ran { x } ) ;;
	step 5 : wff = fnmpti (step 3, step 4) |- 2nd Fn _V ;;
	step 6 : wff = df-2nd () |- 2nd = ( x ∈ _V ↦ ⋃ ran { x } ) ;;
	step 7 : wff = rnmpt (step 6) |- ran 2nd = { y | ∃ x ∈ _V y = ⋃ ran { x } } ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = opex () |- 〈 y , y 〉 ∈ _V ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = op2nda (step 10, step 11) |- ⋃ ran { 〈 y , y 〉 } = y ;;
	step 13 : wff = eqcomi (step 12) |- y = ⋃ ran { 〈 y , y 〉 } ;;
	step 14 : wff = sneq () |- ( x = 〈 y , y 〉 → { x } = { 〈 y , y 〉 } ) ;;
	step 15 : wff = rneqd (step 14) |- ( x = 〈 y , y 〉 → ran { x } = ran { 〈 y , y 〉 } ) ;;
	step 16 : wff = unieqd (step 15) |- ( x = 〈 y , y 〉 → ⋃ ran { x } = ⋃ ran { 〈 y , y 〉 } ) ;;
	step 17 : wff = eqeq2d (step 16) |- ( x = 〈 y , y 〉 → ( y = ⋃ ran { x } ↔ y = ⋃ ran { 〈 y , y 〉 } ) ) ;;
	step 18 : wff = rspcev (step 17) |- ( ( 〈 y , y 〉 ∈ _V ∧ y = ⋃ ran { 〈 y , y 〉 } ) → ∃ x ∈ _V y = ⋃ ran { x } ) ;;
	step 19 : wff = mp2an (step 9, step 13, step 18) |- ∃ x ∈ _V y = ⋃ ran { x } ;;
	step 20 : wff = 2th (step 8, step 19) |- ( y ∈ _V ↔ ∃ x ∈ _V y = ⋃ ran { x } ) ;;
	step 21 : wff = abbi2i (step 20) |- _V = { y | ∃ x ∈ _V y = ⋃ ran { x } } ;;
	step 22 : wff = eqtr4i (step 7, step 21) |- ran 2nd = _V ;;
	step 23 : wff = df-fo () |- ( 2nd : _V ↠ _V ↔ ( 2nd Fn _V ∧ ran 2nd = _V ) ) ;;
	step 24 : wff = mpbir2an (step 5, step 22, step 23) |- 2nd : _V ↠ _V ;;
	qed prop 1 = step 24 ;;
}

/* Mapping of a restriction of the ` 1st ` (first member of an ordered
       pair) function.  (Contributed by NM, 11-Oct-2004.)  (Revised by Mario
       Carneiro, 8-Sep-2013.) */

theorem f1stres (A : class, B : class) disjointed(x y z A, x y z B, x y z, x y z A, x y z B, x y z) {
	prop 1 : wff = |- ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ;;
}

proof of f1stres {
	var x : set, y : set, z : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = vex () |- z ∈ _V ;;
	step 3 : wff = op1sta (step 1, step 2) |- ⋃ dom { 〈 y , z 〉 } = y ;;
	step 4 : wff = eleq1i (step 3) |- ( ⋃ dom { 〈 y , z 〉 } ∈ A ↔ y ∈ A ) ;;
	step 5 : wff = biimpri (step 4) |- ( y ∈ A → ⋃ dom { 〈 y , z 〉 } ∈ A ) ;;
	step 6 : wff = adantr (step 5) |- ( ( y ∈ A ∧ z ∈ B ) → ⋃ dom { 〈 y , z 〉 } ∈ A ) ;;
	step 7 : wff = rgen2 (step 6) |- ∀ y ∈ A ∀ z ∈ B ⋃ dom { 〈 y , z 〉 } ∈ A ;;
	step 8 : wff = sneq () |- ( x = 〈 y , z 〉 → { x } = { 〈 y , z 〉 } ) ;;
	step 9 : wff = dmeqd (step 8) |- ( x = 〈 y , z 〉 → dom { x } = dom { 〈 y , z 〉 } ) ;;
	step 10 : wff = unieqd (step 9) |- ( x = 〈 y , z 〉 → ⋃ dom { x } = ⋃ dom { 〈 y , z 〉 } ) ;;
	step 11 : wff = eleq1d (step 10) |- ( x = 〈 y , z 〉 → ( ⋃ dom { x } ∈ A ↔ ⋃ dom { 〈 y , z 〉 } ∈ A ) ) ;;
	step 12 : wff = ralxp (step 11) |- ( ∀ x ∈ ( A × B ) ⋃ dom { x } ∈ A ↔ ∀ y ∈ A ∀ z ∈ B ⋃ dom { 〈 y , z 〉 } ∈ A ) ;;
	step 13 : wff = mpbir (step 7, step 12) |- ∀ x ∈ ( A × B ) ⋃ dom { x } ∈ A ;;
	step 14 : wff = df-1st () |- 1st = ( x ∈ _V ↦ ⋃ dom { x } ) ;;
	step 15 : wff = reseq1i (step 14) |- ( 1st ↾ ( A × B ) ) = ( ( x ∈ _V ↦ ⋃ dom { x } ) ↾ ( A × B ) ) ;;
	step 16 : wff = ssv () |- ( A × B ) ⊆ _V ;;
	step 17 : wff = resmpt () |- ( ( A × B ) ⊆ _V → ( ( x ∈ _V ↦ ⋃ dom { x } ) ↾ ( A × B ) ) = ( x ∈ ( A × B ) ↦ ⋃ dom { x } ) ) ;;
	step 18 : wff = ax-mp (step 16, step 17) |- ( ( x ∈ _V ↦ ⋃ dom { x } ) ↾ ( A × B ) ) = ( x ∈ ( A × B ) ↦ ⋃ dom { x } ) ;;
	step 19 : wff = eqtri (step 15, step 18) |- ( 1st ↾ ( A × B ) ) = ( x ∈ ( A × B ) ↦ ⋃ dom { x } ) ;;
	step 20 : wff = fmpt (step 19) |- ( ∀ x ∈ ( A × B ) ⋃ dom { x } ∈ A ↔ ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ) ;;
	step 21 : wff = mpbi (step 13, step 20) |- ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ;;
	qed prop 1 = step 21 ;;
}

/* Mapping of a restriction of the ` 2nd ` (second member of an ordered
       pair) function.  (Contributed by NM, 7-Aug-2006.)  (Revised by Mario
       Carneiro, 8-Sep-2013.) */

theorem f2ndres (A : class, B : class) disjointed(x y z A, x y z B, x y z, x y z A, x y z B, x y z) {
	prop 1 : wff = |- ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ;;
}

proof of f2ndres {
	var x : set, y : set, z : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = vex () |- z ∈ _V ;;
	step 3 : wff = op2nda (step 1, step 2) |- ⋃ ran { 〈 y , z 〉 } = z ;;
	step 4 : wff = eleq1i (step 3) |- ( ⋃ ran { 〈 y , z 〉 } ∈ B ↔ z ∈ B ) ;;
	step 5 : wff = biimpri (step 4) |- ( z ∈ B → ⋃ ran { 〈 y , z 〉 } ∈ B ) ;;
	step 6 : wff = adantl (step 5) |- ( ( y ∈ A ∧ z ∈ B ) → ⋃ ran { 〈 y , z 〉 } ∈ B ) ;;
	step 7 : wff = rgen2 (step 6) |- ∀ y ∈ A ∀ z ∈ B ⋃ ran { 〈 y , z 〉 } ∈ B ;;
	step 8 : wff = sneq () |- ( x = 〈 y , z 〉 → { x } = { 〈 y , z 〉 } ) ;;
	step 9 : wff = rneqd (step 8) |- ( x = 〈 y , z 〉 → ran { x } = ran { 〈 y , z 〉 } ) ;;
	step 10 : wff = unieqd (step 9) |- ( x = 〈 y , z 〉 → ⋃ ran { x } = ⋃ ran { 〈 y , z 〉 } ) ;;
	step 11 : wff = eleq1d (step 10) |- ( x = 〈 y , z 〉 → ( ⋃ ran { x } ∈ B ↔ ⋃ ran { 〈 y , z 〉 } ∈ B ) ) ;;
	step 12 : wff = ralxp (step 11) |- ( ∀ x ∈ ( A × B ) ⋃ ran { x } ∈ B ↔ ∀ y ∈ A ∀ z ∈ B ⋃ ran { 〈 y , z 〉 } ∈ B ) ;;
	step 13 : wff = mpbir (step 7, step 12) |- ∀ x ∈ ( A × B ) ⋃ ran { x } ∈ B ;;
	step 14 : wff = df-2nd () |- 2nd = ( x ∈ _V ↦ ⋃ ran { x } ) ;;
	step 15 : wff = reseq1i (step 14) |- ( 2nd ↾ ( A × B ) ) = ( ( x ∈ _V ↦ ⋃ ran { x } ) ↾ ( A × B ) ) ;;
	step 16 : wff = ssv () |- ( A × B ) ⊆ _V ;;
	step 17 : wff = resmpt () |- ( ( A × B ) ⊆ _V → ( ( x ∈ _V ↦ ⋃ ran { x } ) ↾ ( A × B ) ) = ( x ∈ ( A × B ) ↦ ⋃ ran { x } ) ) ;;
	step 18 : wff = ax-mp (step 16, step 17) |- ( ( x ∈ _V ↦ ⋃ ran { x } ) ↾ ( A × B ) ) = ( x ∈ ( A × B ) ↦ ⋃ ran { x } ) ;;
	step 19 : wff = eqtri (step 15, step 18) |- ( 2nd ↾ ( A × B ) ) = ( x ∈ ( A × B ) ↦ ⋃ ran { x } ) ;;
	step 20 : wff = fmpt (step 19) |- ( ∀ x ∈ ( A × B ) ⋃ ran { x } ∈ B ↔ ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ) ;;
	step 21 : wff = mpbi (step 13, step 20) |- ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ;;
	qed prop 1 = step 21 ;;
}

/* Onto mapping of a restriction of the ` 1st ` (first member of an ordered
       pair) function.  (Contributed by NM, 14-Dec-2008.) */

theorem fo1stres (A : class, B : class) disjointed(x y A, x y B, x y, x y A, x y B, x y) {
	prop 1 : wff = |- ( B ≠ ∅ → ( 1st ↾ ( A × B ) ) : ( A × B ) ↠ A ) ;;
}

proof of fo1stres {
	var x : set, y : set;;
	step 1 : wff = n0 () |- ( B ≠ ∅ ↔ ∃ y y ∈ B ) ;;
	step 2 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 3 : wff = fvres () |- ( 〈 x , y 〉 ∈ ( A × B ) → ( ( 1st ↾ ( A × B ) ) ` 〈 x , y 〉 ) = ( 1st ` 〈 x , y 〉 ) ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = op1st (step 4, step 5) |- ( 1st ` 〈 x , y 〉 ) = x ;;
	step 7 : wff = syl6req (step 3, step 6) |- ( 〈 x , y 〉 ∈ ( A × B ) → x = ( ( 1st ↾ ( A × B ) ) ` 〈 x , y 〉 ) ) ;;
	step 8 : wff = f1stres () |- ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ;;
	step 9 : wff = ffn () |- ( ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A → ( 1st ↾ ( A × B ) ) Fn ( A × B ) ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- ( 1st ↾ ( A × B ) ) Fn ( A × B ) ;;
	step 11 : wff = fnfvelrn () |- ( ( ( 1st ↾ ( A × B ) ) Fn ( A × B ) ∧ 〈 x , y 〉 ∈ ( A × B ) ) → ( ( 1st ↾ ( A × B ) ) ` 〈 x , y 〉 ) ∈ ran ( 1st ↾ ( A × B ) ) ) ;;
	step 12 : wff = mpan (step 10, step 11) |- ( 〈 x , y 〉 ∈ ( A × B ) → ( ( 1st ↾ ( A × B ) ) ` 〈 x , y 〉 ) ∈ ran ( 1st ↾ ( A × B ) ) ) ;;
	step 13 : wff = eqeltrd (step 7, step 12) |- ( 〈 x , y 〉 ∈ ( A × B ) → x ∈ ran ( 1st ↾ ( A × B ) ) ) ;;
	step 14 : wff = sylbir (step 2, step 13) |- ( ( x ∈ A ∧ y ∈ B ) → x ∈ ran ( 1st ↾ ( A × B ) ) ) ;;
	step 15 : wff = expcom (step 14) |- ( y ∈ B → ( x ∈ A → x ∈ ran ( 1st ↾ ( A × B ) ) ) ) ;;
	step 16 : wff = exlimiv (step 15) |- ( ∃ y y ∈ B → ( x ∈ A → x ∈ ran ( 1st ↾ ( A × B ) ) ) ) ;;
	step 17 : wff = sylbi (step 1, step 16) |- ( B ≠ ∅ → ( x ∈ A → x ∈ ran ( 1st ↾ ( A × B ) ) ) ) ;;
	step 18 : wff = ssrdv (step 17) |- ( B ≠ ∅ → A ⊆ ran ( 1st ↾ ( A × B ) ) ) ;;
	step 19 : wff = f1stres () |- ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ;;
	step 20 : wff = frn () |- ( ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A → ran ( 1st ↾ ( A × B ) ) ⊆ A ) ;;
	step 21 : wff = ax-mp (step 19, step 20) |- ran ( 1st ↾ ( A × B ) ) ⊆ A ;;
	step 22 : wff = jctil (step 18, step 21) |- ( B ≠ ∅ → ( ran ( 1st ↾ ( A × B ) ) ⊆ A ∧ A ⊆ ran ( 1st ↾ ( A × B ) ) ) ) ;;
	step 23 : wff = eqss () |- ( ran ( 1st ↾ ( A × B ) ) = A ↔ ( ran ( 1st ↾ ( A × B ) ) ⊆ A ∧ A ⊆ ran ( 1st ↾ ( A × B ) ) ) ) ;;
	step 24 : wff = sylibr (step 22, step 23) |- ( B ≠ ∅ → ran ( 1st ↾ ( A × B ) ) = A ) ;;
	step 25 : wff = f1stres () |- ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ;;
	step 26 : wff = jctil (step 24, step 25) |- ( B ≠ ∅ → ( ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ∧ ran ( 1st ↾ ( A × B ) ) = A ) ) ;;
	step 27 : wff = dffo2 () |- ( ( 1st ↾ ( A × B ) ) : ( A × B ) ↠ A ↔ ( ( 1st ↾ ( A × B ) ) : ( A × B ) ⟶ A ∧ ran ( 1st ↾ ( A × B ) ) = A ) ) ;;
	step 28 : wff = sylibr (step 26, step 27) |- ( B ≠ ∅ → ( 1st ↾ ( A × B ) ) : ( A × B ) ↠ A ) ;;
	qed prop 1 = step 28 ;;
}

/* Onto mapping of a restriction of the ` 2nd ` (second member of an
       ordered pair) function.  (Contributed by NM, 14-Dec-2008.) */

theorem fo2ndres (A : class, B : class) disjointed(x y A, x y B, x y, x y A, x y B, x y) {
	prop 1 : wff = |- ( A ≠ ∅ → ( 2nd ↾ ( A × B ) ) : ( A × B ) ↠ B ) ;;
}

proof of fo2ndres {
	var x : set, y : set;;
	step 1 : wff = n0 () |- ( A ≠ ∅ ↔ ∃ x x ∈ A ) ;;
	step 2 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 3 : wff = fvres () |- ( 〈 x , y 〉 ∈ ( A × B ) → ( ( 2nd ↾ ( A × B ) ) ` 〈 x , y 〉 ) = ( 2nd ` 〈 x , y 〉 ) ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = op2nd (step 4, step 5) |- ( 2nd ` 〈 x , y 〉 ) = y ;;
	step 7 : wff = syl6req (step 3, step 6) |- ( 〈 x , y 〉 ∈ ( A × B ) → y = ( ( 2nd ↾ ( A × B ) ) ` 〈 x , y 〉 ) ) ;;
	step 8 : wff = f2ndres () |- ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ;;
	step 9 : wff = ffn () |- ( ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B → ( 2nd ↾ ( A × B ) ) Fn ( A × B ) ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- ( 2nd ↾ ( A × B ) ) Fn ( A × B ) ;;
	step 11 : wff = fnfvelrn () |- ( ( ( 2nd ↾ ( A × B ) ) Fn ( A × B ) ∧ 〈 x , y 〉 ∈ ( A × B ) ) → ( ( 2nd ↾ ( A × B ) ) ` 〈 x , y 〉 ) ∈ ran ( 2nd ↾ ( A × B ) ) ) ;;
	step 12 : wff = mpan (step 10, step 11) |- ( 〈 x , y 〉 ∈ ( A × B ) → ( ( 2nd ↾ ( A × B ) ) ` 〈 x , y 〉 ) ∈ ran ( 2nd ↾ ( A × B ) ) ) ;;
	step 13 : wff = eqeltrd (step 7, step 12) |- ( 〈 x , y 〉 ∈ ( A × B ) → y ∈ ran ( 2nd ↾ ( A × B ) ) ) ;;
	step 14 : wff = sylbir (step 2, step 13) |- ( ( x ∈ A ∧ y ∈ B ) → y ∈ ran ( 2nd ↾ ( A × B ) ) ) ;;
	step 15 : wff = ex (step 14) |- ( x ∈ A → ( y ∈ B → y ∈ ran ( 2nd ↾ ( A × B ) ) ) ) ;;
	step 16 : wff = exlimiv (step 15) |- ( ∃ x x ∈ A → ( y ∈ B → y ∈ ran ( 2nd ↾ ( A × B ) ) ) ) ;;
	step 17 : wff = sylbi (step 1, step 16) |- ( A ≠ ∅ → ( y ∈ B → y ∈ ran ( 2nd ↾ ( A × B ) ) ) ) ;;
	step 18 : wff = ssrdv (step 17) |- ( A ≠ ∅ → B ⊆ ran ( 2nd ↾ ( A × B ) ) ) ;;
	step 19 : wff = f2ndres () |- ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ;;
	step 20 : wff = frn () |- ( ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B → ran ( 2nd ↾ ( A × B ) ) ⊆ B ) ;;
	step 21 : wff = ax-mp (step 19, step 20) |- ran ( 2nd ↾ ( A × B ) ) ⊆ B ;;
	step 22 : wff = jctil (step 18, step 21) |- ( A ≠ ∅ → ( ran ( 2nd ↾ ( A × B ) ) ⊆ B ∧ B ⊆ ran ( 2nd ↾ ( A × B ) ) ) ) ;;
	step 23 : wff = eqss () |- ( ran ( 2nd ↾ ( A × B ) ) = B ↔ ( ran ( 2nd ↾ ( A × B ) ) ⊆ B ∧ B ⊆ ran ( 2nd ↾ ( A × B ) ) ) ) ;;
	step 24 : wff = sylibr (step 22, step 23) |- ( A ≠ ∅ → ran ( 2nd ↾ ( A × B ) ) = B ) ;;
	step 25 : wff = f2ndres () |- ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ;;
	step 26 : wff = jctil (step 24, step 25) |- ( A ≠ ∅ → ( ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ∧ ran ( 2nd ↾ ( A × B ) ) = B ) ) ;;
	step 27 : wff = dffo2 () |- ( ( 2nd ↾ ( A × B ) ) : ( A × B ) ↠ B ↔ ( ( 2nd ↾ ( A × B ) ) : ( A × B ) ⟶ B ∧ ran ( 2nd ↾ ( A × B ) ) = B ) ) ;;
	step 28 : wff = sylibr (step 26, step 27) |- ( A ≠ ∅ → ( 2nd ↾ ( A × B ) ) : ( A × B ) ↠ B ) ;;
	qed prop 1 = step 28 ;;
}

/* Value of an alternate definition of the ` 1st ` function.  (Contributed
       by NM, 14-Oct-2004.)  (Revised by Mario Carneiro, 30-Dec-2014.) */

theorem 1st2val (x : set, y : set, z : set, A : class) disjointed(x y z w v, v w A) {
	prop 1 : wff = |- ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( 1st ` A ) ;;
}

proof of 1st2val {
	var w : set, v : set;;
	step 1 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ w ∃ v A = 〈 w , v 〉 ) ;;
	step 2 : wff = fveq2 () |- ( A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` 〈 w , v 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( w { 〈 〈 x , y 〉 , z 〉 | z = x } v ) = ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` 〈 w , v 〉 ) ;;
	step 4 : wff = vex () |- w ∈ _V ;;
	step 5 : wff = vex () |- v ∈ _V ;;
	step 6 : wff = simpl () |- ( ( x = w ∧ y = v ) → x = w ) ;;
	step 7 : wff = mpt2v () |- ( x ∈ _V , y ∈ _V ↦ x ) = { 〈 〈 x , y 〉 , z 〉 | z = x } ;;
	step 8 : wff = eqcomi (step 7) |- { 〈 〈 x , y 〉 , z 〉 | z = x } = ( x ∈ _V , y ∈ _V ↦ x ) ;;
	step 9 : wff = vex () |- w ∈ _V ;;
	step 10 : wff = ovmpt2a (step 6, step 8, step 9) |- ( ( w ∈ _V ∧ v ∈ _V ) → ( w { 〈 〈 x , y 〉 , z 〉 | z = x } v ) = w ) ;;
	step 11 : wff = mp2an (step 4, step 5, step 10) |- ( w { 〈 〈 x , y 〉 , z 〉 | z = x } v ) = w ;;
	step 12 : wff = eqtr3i (step 3, step 11) |- ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` 〈 w , v 〉 ) = w ;;
	step 13 : wff = syl6eq (step 2, step 12) |- ( A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = w ) ;;
	step 14 : wff = vex () |- w ∈ _V ;;
	step 15 : wff = vex () |- v ∈ _V ;;
	step 16 : wff = op1std (step 14, step 15) |- ( A = 〈 w , v 〉 → ( 1st ` A ) = w ) ;;
	step 17 : wff = eqtr4d (step 13, step 16) |- ( A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( 1st ` A ) ) ;;
	step 18 : wff = exlimivv (step 17) |- ( ∃ w ∃ v A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( 1st ` A ) ) ;;
	step 19 : wff = sylbi (step 1, step 18) |- ( A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( 1st ` A ) ) ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = pm3.2i (step 20, step 21) |- ( x ∈ _V ∧ y ∈ _V ) ;;
	step 23 : wff = a9ev () |- ∃ z z = x ;;
	step 24 : wff = 2th (step 22, step 23) |- ( ( x ∈ _V ∧ y ∈ _V ) ↔ ∃ z z = x ) ;;
	step 25 : wff = opabbii (step 24) |- { 〈 x , y 〉 | ( x ∈ _V ∧ y ∈ _V ) } = { 〈 x , y 〉 | ∃ z z = x } ;;
	step 26 : wff = df-xp () |- ( _V × _V ) = { 〈 x , y 〉 | ( x ∈ _V ∧ y ∈ _V ) } ;;
	step 27 : wff = dmoprab () |- dom { 〈 〈 x , y 〉 , z 〉 | z = x } = { 〈 x , y 〉 | ∃ z z = x } ;;
	step 28 : wff = 3eqtr4ri (step 25, step 26, step 27) |- dom { 〈 〈 x , y 〉 , z 〉 | z = x } = ( _V × _V ) ;;
	step 29 : wff = eleq2i (step 28) |- ( A ∈ dom { 〈 〈 x , y 〉 , z 〉 | z = x } ↔ A ∈ ( _V × _V ) ) ;;
	step 30 : wff = ndmfv () |- ( ¬ A ∈ dom { 〈 〈 x , y 〉 , z 〉 | z = x } → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ∅ ) ;;
	step 31 : wff = sylnbir (step 29, step 30) |- ( ¬ A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ∅ ) ;;
	step 32 : wff = dmsnn0 () |- ( A ∈ ( _V × _V ) ↔ dom { A } ≠ ∅ ) ;;
	step 33 : wff = biimpri (step 32) |- ( dom { A } ≠ ∅ → A ∈ ( _V × _V ) ) ;;
	step 34 : wff = necon1bi (step 33) |- ( ¬ A ∈ ( _V × _V ) → dom { A } = ∅ ) ;;
	step 35 : wff = unieqd (step 34) |- ( ¬ A ∈ ( _V × _V ) → ⋃ dom { A } = ⋃ ∅ ) ;;
	step 36 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 37 : wff = syl6eq (step 35, step 36) |- ( ¬ A ∈ ( _V × _V ) → ⋃ dom { A } = ∅ ) ;;
	step 38 : wff = eqtr4d (step 31, step 37) |- ( ¬ A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ⋃ dom { A } ) ;;
	step 39 : wff = 1stval () |- ( 1st ` A ) = ⋃ dom { A } ;;
	step 40 : wff = syl6eqr (step 38, step 39) |- ( ¬ A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( 1st ` A ) ) ;;
	step 41 : wff = pm2.61i (step 19, step 40) |- ( { 〈 〈 x , y 〉 , z 〉 | z = x } ` A ) = ( 1st ` A ) ;;
	qed prop 1 = step 41 ;;
}

/* Value of an alternate definition of the ` 2nd ` function.  (Contributed
       by NM, 10-Aug-2006.)  (Revised by Mario Carneiro, 30-Dec-2014.) */

theorem 2nd2val (x : set, y : set, z : set, A : class) disjointed(x y z w v, v w A) {
	prop 1 : wff = |- ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( 2nd ` A ) ;;
}

proof of 2nd2val {
	var w : set, v : set;;
	step 1 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ w ∃ v A = 〈 w , v 〉 ) ;;
	step 2 : wff = fveq2 () |- ( A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` 〈 w , v 〉 ) ) ;;
	step 3 : wff = df-ov () |- ( w { 〈 〈 x , y 〉 , z 〉 | z = y } v ) = ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` 〈 w , v 〉 ) ;;
	step 4 : wff = vex () |- w ∈ _V ;;
	step 5 : wff = vex () |- v ∈ _V ;;
	step 6 : wff = simpr () |- ( ( x = w ∧ y = v ) → y = v ) ;;
	step 7 : wff = mpt2v () |- ( x ∈ _V , y ∈ _V ↦ y ) = { 〈 〈 x , y 〉 , z 〉 | z = y } ;;
	step 8 : wff = eqcomi (step 7) |- { 〈 〈 x , y 〉 , z 〉 | z = y } = ( x ∈ _V , y ∈ _V ↦ y ) ;;
	step 9 : wff = vex () |- v ∈ _V ;;
	step 10 : wff = ovmpt2a (step 6, step 8, step 9) |- ( ( w ∈ _V ∧ v ∈ _V ) → ( w { 〈 〈 x , y 〉 , z 〉 | z = y } v ) = v ) ;;
	step 11 : wff = mp2an (step 4, step 5, step 10) |- ( w { 〈 〈 x , y 〉 , z 〉 | z = y } v ) = v ;;
	step 12 : wff = eqtr3i (step 3, step 11) |- ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` 〈 w , v 〉 ) = v ;;
	step 13 : wff = syl6eq (step 2, step 12) |- ( A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = v ) ;;
	step 14 : wff = vex () |- w ∈ _V ;;
	step 15 : wff = vex () |- v ∈ _V ;;
	step 16 : wff = op2ndd (step 14, step 15) |- ( A = 〈 w , v 〉 → ( 2nd ` A ) = v ) ;;
	step 17 : wff = eqtr4d (step 13, step 16) |- ( A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( 2nd ` A ) ) ;;
	step 18 : wff = exlimivv (step 17) |- ( ∃ w ∃ v A = 〈 w , v 〉 → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( 2nd ` A ) ) ;;
	step 19 : wff = sylbi (step 1, step 18) |- ( A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( 2nd ` A ) ) ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = pm3.2i (step 20, step 21) |- ( x ∈ _V ∧ y ∈ _V ) ;;
	step 23 : wff = a9ev () |- ∃ z z = y ;;
	step 24 : wff = 2th (step 22, step 23) |- ( ( x ∈ _V ∧ y ∈ _V ) ↔ ∃ z z = y ) ;;
	step 25 : wff = opabbii (step 24) |- { 〈 x , y 〉 | ( x ∈ _V ∧ y ∈ _V ) } = { 〈 x , y 〉 | ∃ z z = y } ;;
	step 26 : wff = df-xp () |- ( _V × _V ) = { 〈 x , y 〉 | ( x ∈ _V ∧ y ∈ _V ) } ;;
	step 27 : wff = dmoprab () |- dom { 〈 〈 x , y 〉 , z 〉 | z = y } = { 〈 x , y 〉 | ∃ z z = y } ;;
	step 28 : wff = 3eqtr4ri (step 25, step 26, step 27) |- dom { 〈 〈 x , y 〉 , z 〉 | z = y } = ( _V × _V ) ;;
	step 29 : wff = eleq2i (step 28) |- ( A ∈ dom { 〈 〈 x , y 〉 , z 〉 | z = y } ↔ A ∈ ( _V × _V ) ) ;;
	step 30 : wff = ndmfv () |- ( ¬ A ∈ dom { 〈 〈 x , y 〉 , z 〉 | z = y } → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ∅ ) ;;
	step 31 : wff = sylnbir (step 29, step 30) |- ( ¬ A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ∅ ) ;;
	step 32 : wff = rnsnn0 () |- ( A ∈ ( _V × _V ) ↔ ran { A } ≠ ∅ ) ;;
	step 33 : wff = biimpri (step 32) |- ( ran { A } ≠ ∅ → A ∈ ( _V × _V ) ) ;;
	step 34 : wff = necon1bi (step 33) |- ( ¬ A ∈ ( _V × _V ) → ran { A } = ∅ ) ;;
	step 35 : wff = unieqd (step 34) |- ( ¬ A ∈ ( _V × _V ) → ⋃ ran { A } = ⋃ ∅ ) ;;
	step 36 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 37 : wff = syl6eq (step 35, step 36) |- ( ¬ A ∈ ( _V × _V ) → ⋃ ran { A } = ∅ ) ;;
	step 38 : wff = eqtr4d (step 31, step 37) |- ( ¬ A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ⋃ ran { A } ) ;;
	step 39 : wff = 2ndval () |- ( 2nd ` A ) = ⋃ ran { A } ;;
	step 40 : wff = syl6eqr (step 38, step 39) |- ( ¬ A ∈ ( _V × _V ) → ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( 2nd ` A ) ) ;;
	step 41 : wff = pm2.61i (step 19, step 40) |- ( { 〈 〈 x , y 〉 , z 〉 | z = y } ` A ) = ( 2nd ` A ) ;;
	qed prop 1 = step 41 ;;
}

/* Composition of the first member function with another function.
     (Contributed by NM, 12-Oct-2007.) */

theorem 1stcof (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ ( B × C ) → ( 1st ∘ F ) : A ⟶ B ) ;;
}

proof of 1stcof {
	step 1 : wff = fo1st () |- 1st : _V ↠ _V ;;
	step 2 : wff = fofn () |- ( 1st : _V ↠ _V → 1st Fn _V ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- 1st Fn _V ;;
	step 4 : wff = ffn () |- ( F : A ⟶ ( B × C ) → F Fn A ) ;;
	step 5 : wff = dffn2 () |- ( F Fn A ↔ F : A ⟶ _V ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( F : A ⟶ ( B × C ) → F : A ⟶ _V ) ;;
	step 7 : wff = fnfco () |- ( ( 1st Fn _V ∧ F : A ⟶ _V ) → ( 1st ∘ F ) Fn A ) ;;
	step 8 : wff = sylancr (step 3, step 6, step 7) |- ( F : A ⟶ ( B × C ) → ( 1st ∘ F ) Fn A ) ;;
	step 9 : wff = rnco () |- ran ( 1st ∘ F ) = ran ( 1st ↾ ran F ) ;;
	step 10 : wff = frn () |- ( F : A ⟶ ( B × C ) → ran F ⊆ ( B × C ) ) ;;
	step 11 : wff = ssres2 () |- ( ran F ⊆ ( B × C ) → ( 1st ↾ ran F ) ⊆ ( 1st ↾ ( B × C ) ) ) ;;
	step 12 : wff = rnss () |- ( ( 1st ↾ ran F ) ⊆ ( 1st ↾ ( B × C ) ) → ran ( 1st ↾ ran F ) ⊆ ran ( 1st ↾ ( B × C ) ) ) ;;
	step 13 : wff = 3syl (step 10, step 11, step 12) |- ( F : A ⟶ ( B × C ) → ran ( 1st ↾ ran F ) ⊆ ran ( 1st ↾ ( B × C ) ) ) ;;
	step 14 : wff = f1stres () |- ( 1st ↾ ( B × C ) ) : ( B × C ) ⟶ B ;;
	step 15 : wff = frn () |- ( ( 1st ↾ ( B × C ) ) : ( B × C ) ⟶ B → ran ( 1st ↾ ( B × C ) ) ⊆ B ) ;;
	step 16 : wff = ax-mp (step 14, step 15) |- ran ( 1st ↾ ( B × C ) ) ⊆ B ;;
	step 17 : wff = syl6ss (step 13, step 16) |- ( F : A ⟶ ( B × C ) → ran ( 1st ↾ ran F ) ⊆ B ) ;;
	step 18 : wff = syl5eqss (step 9, step 17) |- ( F : A ⟶ ( B × C ) → ran ( 1st ∘ F ) ⊆ B ) ;;
	step 19 : wff = df-f () |- ( ( 1st ∘ F ) : A ⟶ B ↔ ( ( 1st ∘ F ) Fn A ∧ ran ( 1st ∘ F ) ⊆ B ) ) ;;
	step 20 : wff = sylanbrc (step 8, step 18, step 19) |- ( F : A ⟶ ( B × C ) → ( 1st ∘ F ) : A ⟶ B ) ;;
	qed prop 1 = step 20 ;;
}

/* Composition of the first member function with another function.
     (Contributed by FL, 15-Oct-2012.) */

theorem 2ndcof (A : class, B : class, C : class, F : class)  {
	prop 1 : wff = |- ( F : A ⟶ ( B × C ) → ( 2nd ∘ F ) : A ⟶ C ) ;;
}

proof of 2ndcof {
	step 1 : wff = fo2nd () |- 2nd : _V ↠ _V ;;
	step 2 : wff = fofn () |- ( 2nd : _V ↠ _V → 2nd Fn _V ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- 2nd Fn _V ;;
	step 4 : wff = ffn () |- ( F : A ⟶ ( B × C ) → F Fn A ) ;;
	step 5 : wff = dffn2 () |- ( F Fn A ↔ F : A ⟶ _V ) ;;
	step 6 : wff = sylib (step 4, step 5) |- ( F : A ⟶ ( B × C ) → F : A ⟶ _V ) ;;
	step 7 : wff = fnfco () |- ( ( 2nd Fn _V ∧ F : A ⟶ _V ) → ( 2nd ∘ F ) Fn A ) ;;
	step 8 : wff = sylancr (step 3, step 6, step 7) |- ( F : A ⟶ ( B × C ) → ( 2nd ∘ F ) Fn A ) ;;
	step 9 : wff = rnco () |- ran ( 2nd ∘ F ) = ran ( 2nd ↾ ran F ) ;;
	step 10 : wff = frn () |- ( F : A ⟶ ( B × C ) → ran F ⊆ ( B × C ) ) ;;
	step 11 : wff = ssres2 () |- ( ran F ⊆ ( B × C ) → ( 2nd ↾ ran F ) ⊆ ( 2nd ↾ ( B × C ) ) ) ;;
	step 12 : wff = rnss () |- ( ( 2nd ↾ ran F ) ⊆ ( 2nd ↾ ( B × C ) ) → ran ( 2nd ↾ ran F ) ⊆ ran ( 2nd ↾ ( B × C ) ) ) ;;
	step 13 : wff = 3syl (step 10, step 11, step 12) |- ( F : A ⟶ ( B × C ) → ran ( 2nd ↾ ran F ) ⊆ ran ( 2nd ↾ ( B × C ) ) ) ;;
	step 14 : wff = f2ndres () |- ( 2nd ↾ ( B × C ) ) : ( B × C ) ⟶ C ;;
	step 15 : wff = frn () |- ( ( 2nd ↾ ( B × C ) ) : ( B × C ) ⟶ C → ran ( 2nd ↾ ( B × C ) ) ⊆ C ) ;;
	step 16 : wff = ax-mp (step 14, step 15) |- ran ( 2nd ↾ ( B × C ) ) ⊆ C ;;
	step 17 : wff = syl6ss (step 13, step 16) |- ( F : A ⟶ ( B × C ) → ran ( 2nd ↾ ran F ) ⊆ C ) ;;
	step 18 : wff = syl5eqss (step 9, step 17) |- ( F : A ⟶ ( B × C ) → ran ( 2nd ∘ F ) ⊆ C ) ;;
	step 19 : wff = df-f () |- ( ( 2nd ∘ F ) : A ⟶ C ↔ ( ( 2nd ∘ F ) Fn A ∧ ran ( 2nd ∘ F ) ⊆ C ) ) ;;
	step 20 : wff = sylanbrc (step 8, step 18, step 19) |- ( F : A ⟶ ( B × C ) → ( 2nd ∘ F ) : A ⟶ C ) ;;
	qed prop 1 = step 20 ;;
}

/* Location of the first element of a Cartesian product.  (Contributed by
       Jeff Madsen, 2-Sep-2009.) */

theorem xp1st (A : class, B : class, C : class) disjointed(A b c, B b c, C b c) {
	prop 1 : wff = |- ( A ∈ ( B × C ) → ( 1st ` A ) ∈ B ) ;;
}

proof of xp1st {
	var b : set, c : set;;
	step 1 : wff = elxp () |- ( A ∈ ( B × C ) ↔ ∃ b ∃ c ( A = 〈 b , c 〉 ∧ ( b ∈ B ∧ c ∈ C ) ) ) ;;
	step 2 : wff = vex () |- b ∈ _V ;;
	step 3 : wff = vex () |- c ∈ _V ;;
	step 4 : wff = op1std (step 2, step 3) |- ( A = 〈 b , c 〉 → ( 1st ` A ) = b ) ;;
	step 5 : wff = eleq1d (step 4) |- ( A = 〈 b , c 〉 → ( ( 1st ` A ) ∈ B ↔ b ∈ B ) ) ;;
	step 6 : wff = biimpar (step 5) |- ( ( A = 〈 b , c 〉 ∧ b ∈ B ) → ( 1st ` A ) ∈ B ) ;;
	step 7 : wff = adantrr (step 6) |- ( ( A = 〈 b , c 〉 ∧ ( b ∈ B ∧ c ∈ C ) ) → ( 1st ` A ) ∈ B ) ;;
	step 8 : wff = exlimivv (step 7) |- ( ∃ b ∃ c ( A = 〈 b , c 〉 ∧ ( b ∈ B ∧ c ∈ C ) ) → ( 1st ` A ) ∈ B ) ;;
	step 9 : wff = sylbi (step 1, step 8) |- ( A ∈ ( B × C ) → ( 1st ` A ) ∈ B ) ;;
	qed prop 1 = step 9 ;;
}

/* Location of the second element of a Cartesian product.  (Contributed by
       Jeff Madsen, 2-Sep-2009.) */

theorem xp2nd (A : class, B : class, C : class) disjointed(A b c, B b c, C b c) {
	prop 1 : wff = |- ( A ∈ ( B × C ) → ( 2nd ` A ) ∈ C ) ;;
}

proof of xp2nd {
	var b : set, c : set;;
	step 1 : wff = elxp () |- ( A ∈ ( B × C ) ↔ ∃ b ∃ c ( A = 〈 b , c 〉 ∧ ( b ∈ B ∧ c ∈ C ) ) ) ;;
	step 2 : wff = vex () |- b ∈ _V ;;
	step 3 : wff = vex () |- c ∈ _V ;;
	step 4 : wff = op2ndd (step 2, step 3) |- ( A = 〈 b , c 〉 → ( 2nd ` A ) = c ) ;;
	step 5 : wff = eleq1d (step 4) |- ( A = 〈 b , c 〉 → ( ( 2nd ` A ) ∈ C ↔ c ∈ C ) ) ;;
	step 6 : wff = biimpar (step 5) |- ( ( A = 〈 b , c 〉 ∧ c ∈ C ) → ( 2nd ` A ) ∈ C ) ;;
	step 7 : wff = adantrl (step 6) |- ( ( A = 〈 b , c 〉 ∧ ( b ∈ B ∧ c ∈ C ) ) → ( 2nd ` A ) ∈ C ) ;;
	step 8 : wff = exlimivv (step 7) |- ( ∃ b ∃ c ( A = 〈 b , c 〉 ∧ ( b ∈ B ∧ c ∈ C ) ) → ( 2nd ` A ) ∈ C ) ;;
	step 9 : wff = sylbi (step 1, step 8) |- ( A ∈ ( B × C ) → ( 2nd ` A ) ∈ C ) ;;
	qed prop 1 = step 9 ;;
}

/* Membership in a cross product.  This version requires no quantifiers or
     dummy variables.  See also ~ elxp4 .  (Contributed by NM, 9-Oct-2004.) */

theorem elxp6 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
}

proof of elxp6 {
	step 1 : wff = elxp4 () |- ( A ∈ ( B × C ) ↔ ( A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ∧ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 2 : wff = 1stval () |- ( 1st ` A ) = ⋃ dom { A } ;;
	step 3 : wff = 2ndval () |- ( 2nd ` A ) = ⋃ ran { A } ;;
	step 4 : wff = opeq12i (step 2, step 3) |- 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ;;
	step 5 : wff = eqeq2i (step 4) |- ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ↔ A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ) ;;
	step 6 : wff = 1stval () |- ( 1st ` A ) = ⋃ dom { A } ;;
	step 7 : wff = eleq1i (step 6) |- ( ( 1st ` A ) ∈ B ↔ ⋃ dom { A } ∈ B ) ;;
	step 8 : wff = 2ndval () |- ( 2nd ` A ) = ⋃ ran { A } ;;
	step 9 : wff = eleq1i (step 8) |- ( ( 2nd ` A ) ∈ C ↔ ⋃ ran { A } ∈ C ) ;;
	step 10 : wff = anbi12i (step 7, step 9) |- ( ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ↔ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ;;
	step 11 : wff = anbi12i (step 5, step 10) |- ( ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ↔ ( A = 〈 ⋃ dom { A } , ⋃ ran { A } 〉 ∧ ( ⋃ dom { A } ∈ B ∧ ⋃ ran { A } ∈ C ) ) ) ;;
	step 12 : wff = bitr4i (step 1, step 11) |- ( A ∈ ( B × C ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Membership in a cross product.  This version requires no quantifiers or
     dummy variables.  See also ~ elxp4 .  (Contributed by NM, 19-Aug-2006.) */

theorem elxp7 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∈ ( B × C ) ↔ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
}

proof of elxp7 {
	step 1 : wff = elxp6 () |- ( A ∈ ( B × C ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	step 2 : wff = fvex () |- ( 1st ` A ) ∈ _V ;;
	step 3 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 4 : wff = pm3.2i (step 2, step 3) |- ( ( 1st ` A ) ∈ _V ∧ ( 2nd ` A ) ∈ _V ) ;;
	step 5 : wff = elxp6 () |- ( A ∈ ( _V × _V ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ _V ∧ ( 2nd ` A ) ∈ _V ) ) ) ;;
	step 6 : wff = mpbiran2 (step 4, step 5) |- ( A ∈ ( _V × _V ) ↔ A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 7 : wff = anbi1i (step 6) |- ( ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	step 8 : wff = bitr4i (step 1, step 7) |- ( A ∈ ( B × C ) ↔ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Difference of Cartesian products, expressed in terms of a union of
       Cartesian products of differences.  (Contributed by Jeff Madsen,
       2-Sep-2009.)  (Revised by Mario Carneiro, 26-Jun-2014.) */

theorem difxp (A : class, B : class, C : class, D : class) disjointed(A x y, B x y, C x y, D x y) {
	prop 1 : wff = |- ( ( C × D ) ∖ ( A × B ) ) = ( ( ( C ∖ A ) × D ) ∪ ( C × ( D ∖ B ) ) ) ;;
}

proof of difxp {
	var x : set, y : set;;
	step 1 : wff = difss () |- ( ( C × D ) ∖ ( A × B ) ) ⊆ ( C × D ) ;;
	step 2 : wff = relxp () |- Rel ( C × D ) ;;
	step 3 : wff = relss () |- ( ( ( C × D ) ∖ ( A × B ) ) ⊆ ( C × D ) → ( Rel ( C × D ) → Rel ( ( C × D ) ∖ ( A × B ) ) ) ) ;;
	step 4 : wff = mp2 (step 1, step 2, step 3) |- Rel ( ( C × D ) ∖ ( A × B ) ) ;;
	step 5 : wff = relxp () |- Rel ( ( C ∖ A ) × D ) ;;
	step 6 : wff = relxp () |- Rel ( C × ( D ∖ B ) ) ;;
	step 7 : wff = relun () |- ( Rel ( ( ( C ∖ A ) × D ) ∪ ( C × ( D ∖ B ) ) ) ↔ ( Rel ( ( C ∖ A ) × D ) ∧ Rel ( C × ( D ∖ B ) ) ) ) ;;
	step 8 : wff = mpbir2an (step 5, step 6, step 7) |- Rel ( ( ( C ∖ A ) × D ) ∪ ( C × ( D ∖ B ) ) ) ;;
	step 9 : wff = ianor () |- ( ¬ ( x ∈ A ∧ y ∈ B ) ↔ ( ¬ x ∈ A ∨ ¬ y ∈ B ) ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ ( x ∈ A ∧ y ∈ B ) ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ( ¬ x ∈ A ∨ ¬ y ∈ B ) ) ) ;;
	step 11 : wff = andi () |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ( ¬ x ∈ A ∨ ¬ y ∈ B ) ) ↔ ( ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ x ∈ A ) ∨ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ y ∈ B ) ) ) ;;
	step 12 : wff = bitri (step 10, step 11) |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ ( x ∈ A ∧ y ∈ B ) ) ↔ ( ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ x ∈ A ) ∨ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ y ∈ B ) ) ) ;;
	step 13 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( C × D ) ↔ ( x ∈ C ∧ y ∈ D ) ) ;;
	step 14 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 15 : wff = notbii (step 14) |- ( ¬ 〈 x , y 〉 ∈ ( A × B ) ↔ ¬ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 16 : wff = anbi12i (step 13, step 15) |- ( ( 〈 x , y 〉 ∈ ( C × D ) ∧ ¬ 〈 x , y 〉 ∈ ( A × B ) ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 17 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( ( C ∖ A ) × D ) ↔ ( x ∈ ( C ∖ A ) ∧ y ∈ D ) ) ;;
	step 18 : wff = eldif () |- ( x ∈ ( C ∖ A ) ↔ ( x ∈ C ∧ ¬ x ∈ A ) ) ;;
	step 19 : wff = anbi1i (step 18) |- ( ( x ∈ ( C ∖ A ) ∧ y ∈ D ) ↔ ( ( x ∈ C ∧ ¬ x ∈ A ) ∧ y ∈ D ) ) ;;
	step 20 : wff = an32 () |- ( ( ( x ∈ C ∧ ¬ x ∈ A ) ∧ y ∈ D ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ x ∈ A ) ) ;;
	step 21 : wff = bitri (step 19, step 20) |- ( ( x ∈ ( C ∖ A ) ∧ y ∈ D ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ x ∈ A ) ) ;;
	step 22 : wff = bitri (step 17, step 21) |- ( 〈 x , y 〉 ∈ ( ( C ∖ A ) × D ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ x ∈ A ) ) ;;
	step 23 : wff = eldif () |- ( y ∈ ( D ∖ B ) ↔ ( y ∈ D ∧ ¬ y ∈ B ) ) ;;
	step 24 : wff = anbi2i (step 23) |- ( ( x ∈ C ∧ y ∈ ( D ∖ B ) ) ↔ ( x ∈ C ∧ ( y ∈ D ∧ ¬ y ∈ B ) ) ) ;;
	step 25 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( C × ( D ∖ B ) ) ↔ ( x ∈ C ∧ y ∈ ( D ∖ B ) ) ) ;;
	step 26 : wff = anass () |- ( ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ y ∈ B ) ↔ ( x ∈ C ∧ ( y ∈ D ∧ ¬ y ∈ B ) ) ) ;;
	step 27 : wff = 3bitr4i (step 24, step 25, step 26) |- ( 〈 x , y 〉 ∈ ( C × ( D ∖ B ) ) ↔ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ y ∈ B ) ) ;;
	step 28 : wff = orbi12i (step 22, step 27) |- ( ( 〈 x , y 〉 ∈ ( ( C ∖ A ) × D ) ∨ 〈 x , y 〉 ∈ ( C × ( D ∖ B ) ) ) ↔ ( ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ x ∈ A ) ∨ ( ( x ∈ C ∧ y ∈ D ) ∧ ¬ y ∈ B ) ) ) ;;
	step 29 : wff = 3bitr4i (step 12, step 16, step 28) |- ( ( 〈 x , y 〉 ∈ ( C × D ) ∧ ¬ 〈 x , y 〉 ∈ ( A × B ) ) ↔ ( 〈 x , y 〉 ∈ ( ( C ∖ A ) × D ) ∨ 〈 x , y 〉 ∈ ( C × ( D ∖ B ) ) ) ) ;;
	step 30 : wff = eldif () |- ( 〈 x , y 〉 ∈ ( ( C × D ) ∖ ( A × B ) ) ↔ ( 〈 x , y 〉 ∈ ( C × D ) ∧ ¬ 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 31 : wff = elun () |- ( 〈 x , y 〉 ∈ ( ( ( C ∖ A ) × D ) ∪ ( C × ( D ∖ B ) ) ) ↔ ( 〈 x , y 〉 ∈ ( ( C ∖ A ) × D ) ∨ 〈 x , y 〉 ∈ ( C × ( D ∖ B ) ) ) ) ;;
	step 32 : wff = 3bitr4i (step 29, step 30, step 31) |- ( 〈 x , y 〉 ∈ ( ( C × D ) ∖ ( A × B ) ) ↔ 〈 x , y 〉 ∈ ( ( ( C ∖ A ) × D ) ∪ ( C × ( D ∖ B ) ) ) ) ;;
	step 33 : wff = eqrelriiv (step 4, step 8, step 32) |- ( ( C × D ) ∖ ( A × B ) ) = ( ( ( C ∖ A ) × D ) ∪ ( C × ( D ∖ B ) ) ) ;;
	qed prop 1 = step 33 ;;
}

/* Difference law for cross product.  (Contributed by Scott Fenton,
     18-Feb-2013.)  (Revised by Mario Carneiro, 26-Jun-2014.) */

theorem difxp1 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∖ B ) × C ) = ( ( A × C ) ∖ ( B × C ) ) ;;
}

proof of difxp1 {
	step 1 : wff = difxp () |- ( ( A × C ) ∖ ( B × C ) ) = ( ( ( A ∖ B ) × C ) ∪ ( A × ( C ∖ C ) ) ) ;;
	step 2 : wff = difid () |- ( C ∖ C ) = ∅ ;;
	step 3 : wff = xpeq2i (step 2) |- ( A × ( C ∖ C ) ) = ( A × ∅ ) ;;
	step 4 : wff = xp0 () |- ( A × ∅ ) = ∅ ;;
	step 5 : wff = eqtri (step 3, step 4) |- ( A × ( C ∖ C ) ) = ∅ ;;
	step 6 : wff = uneq2i (step 5) |- ( ( ( A ∖ B ) × C ) ∪ ( A × ( C ∖ C ) ) ) = ( ( ( A ∖ B ) × C ) ∪ ∅ ) ;;
	step 7 : wff = un0 () |- ( ( ( A ∖ B ) × C ) ∪ ∅ ) = ( ( A ∖ B ) × C ) ;;
	step 8 : wff = 3eqtrri (step 1, step 6, step 7) |- ( ( A ∖ B ) × C ) = ( ( A × C ) ∖ ( B × C ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Difference law for cross product.  (Contributed by Scott Fenton,
     18-Feb-2013.)  (Revised by Mario Carneiro, 26-Jun-2014.) */

theorem difxp2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A × ( B ∖ C ) ) = ( ( A × B ) ∖ ( A × C ) ) ;;
}

proof of difxp2 {
	step 1 : wff = difxp () |- ( ( A × B ) ∖ ( A × C ) ) = ( ( ( A ∖ A ) × B ) ∪ ( A × ( B ∖ C ) ) ) ;;
	step 2 : wff = difid () |- ( A ∖ A ) = ∅ ;;
	step 3 : wff = xpeq1i (step 2) |- ( ( A ∖ A ) × B ) = ( ∅ × B ) ;;
	step 4 : wff = xp0r () |- ( ∅ × B ) = ∅ ;;
	step 5 : wff = eqtri (step 3, step 4) |- ( ( A ∖ A ) × B ) = ∅ ;;
	step 6 : wff = uneq1i (step 5) |- ( ( ( A ∖ A ) × B ) ∪ ( A × ( B ∖ C ) ) ) = ( ∅ ∪ ( A × ( B ∖ C ) ) ) ;;
	step 7 : wff = uncom () |- ( ∅ ∪ ( A × ( B ∖ C ) ) ) = ( ( A × ( B ∖ C ) ) ∪ ∅ ) ;;
	step 8 : wff = un0 () |- ( ( A × ( B ∖ C ) ) ∪ ∅ ) = ( A × ( B ∖ C ) ) ;;
	step 9 : wff = eqtri (step 7, step 8) |- ( ∅ ∪ ( A × ( B ∖ C ) ) ) = ( A × ( B ∖ C ) ) ;;
	step 10 : wff = 3eqtrri (step 1, step 6, step 9) |- ( A × ( B ∖ C ) ) = ( ( A × B ) ∖ ( A × C ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Equality with an ordered pair.  (Contributed by NM, 15-Dec-2008.)
     (Revised by Mario Carneiro, 23-Feb-2014.) */

theorem eqopi (A : class, B : class, C : class, V : class, W : class)  {
	prop 1 : wff = |- ( ( A ∈ ( V × W ) ∧ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) → A = 〈 B , C 〉 ) ;;
}

proof of eqopi {
	step 1 : wff = xpss () |- ( V × W ) ⊆ ( _V × _V ) ;;
	step 2 : wff = sseli (step 1) |- ( A ∈ ( V × W ) → A ∈ ( _V × _V ) ) ;;
	step 3 : wff = elxp6 () |- ( A ∈ ( _V × _V ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ _V ∧ ( 2nd ` A ) ∈ _V ) ) ) ;;
	step 4 : wff = simplbi (step 3) |- ( A ∈ ( _V × _V ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 5 : wff = opeq12 () |- ( ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) → 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 = 〈 B , C 〉 ) ;;
	step 6 : wff = sylan9eq (step 4, step 5) |- ( ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) → A = 〈 B , C 〉 ) ;;
	step 7 : wff = sylan (step 2, step 6) |- ( ( A ∈ ( V × W ) ∧ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) → A = 〈 B , C 〉 ) ;;
	qed prop 1 = step 7 ;;
}

/* Representation of cross product based on ordered pair component
       functions.  (Contributed by NM, 16-Sep-2006.) */

theorem xp2 (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A × B ) = { x ∈ ( _V × _V ) | ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ B ) } ;;
}

proof of xp2 {
	step 1 : wff = elxp7 () |- ( x ∈ ( A × B ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ B ) ) ) ;;
	step 2 : wff = abbi2i (step 1) |- ( A × B ) = { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ B ) ) } ;;
	step 3 : wff = df-rab () |- { x ∈ ( _V × _V ) | ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ B ) } = { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ B ) ) } ;;
	step 4 : wff = eqtr4i (step 2, step 3) |- ( A × B ) = { x ∈ ( _V × _V ) | ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ B ) } ;;
	qed prop 1 = step 4 ;;
}

/* The membership relation for a cross product is inherited by union.
       (Contributed by NM, 16-Sep-2006.) */

theorem unielxp (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( A ∈ ( B × C ) → ⋃ A ∈ ⋃ ( B × C ) ) ;;
}

proof of unielxp {
	var x : set;;
	step 1 : wff = elxp7 () |- ( A ∈ ( B × C ) ↔ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	step 2 : wff = elvvuni () |- ( A ∈ ( _V × _V ) → ⋃ A ∈ A ) ;;
	step 3 : wff = adantr (step 2) |- ( ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) → ⋃ A ∈ A ) ;;
	step 4 : wff = simprl () |- ( ( ⋃ A ∈ A ∧ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) → A ∈ ( _V × _V ) ) ;;
	step 5 : wff = eleq2 () |- ( x = A → ( ⋃ A ∈ x ↔ ⋃ A ∈ A ) ) ;;
	step 6 : wff = eleq1 () |- ( x = A → ( x ∈ ( _V × _V ) ↔ A ∈ ( _V × _V ) ) ) ;;
	step 7 : wff = fveq2 () |- ( x = A → ( 1st ` x ) = ( 1st ` A ) ) ;;
	step 8 : wff = eleq1d (step 7) |- ( x = A → ( ( 1st ` x ) ∈ B ↔ ( 1st ` A ) ∈ B ) ) ;;
	step 9 : wff = fveq2 () |- ( x = A → ( 2nd ` x ) = ( 2nd ` A ) ) ;;
	step 10 : wff = eleq1d (step 9) |- ( x = A → ( ( 2nd ` x ) ∈ C ↔ ( 2nd ` A ) ∈ C ) ) ;;
	step 11 : wff = anbi12d (step 8, step 10) |- ( x = A → ( ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ↔ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	step 12 : wff = anbi12d (step 6, step 11) |- ( x = A → ( ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) ↔ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ) ;;
	step 13 : wff = anbi12d (step 5, step 12) |- ( x = A → ( ( ⋃ A ∈ x ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) ) ↔ ( ⋃ A ∈ A ∧ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ) ) ;;
	step 14 : wff = spcegv (step 13) |- ( A ∈ ( _V × _V ) → ( ( ⋃ A ∈ A ∧ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) → ∃ x ( ⋃ A ∈ x ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) ) ) ) ;;
	step 15 : wff = mpcom (step 4, step 14) |- ( ( ⋃ A ∈ A ∧ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) → ∃ x ( ⋃ A ∈ x ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) ) ) ;;
	step 16 : wff = eluniab () |- ( ⋃ A ∈ ⋃ { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) } ↔ ∃ x ( ⋃ A ∈ x ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) ) ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ( ⋃ A ∈ A ∧ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) → ⋃ A ∈ ⋃ { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) } ) ;;
	step 18 : wff = xp2 () |- ( B × C ) = { x ∈ ( _V × _V ) | ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) } ;;
	step 19 : wff = df-rab () |- { x ∈ ( _V × _V ) | ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) } = { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) } ;;
	step 20 : wff = eqtri (step 18, step 19) |- ( B × C ) = { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) } ;;
	step 21 : wff = unieqi (step 20) |- ⋃ ( B × C ) = ⋃ { x | ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ B ∧ ( 2nd ` x ) ∈ C ) ) } ;;
	step 22 : wff = syl6eleqr (step 17, step 21) |- ( ( ⋃ A ∈ A ∧ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) → ⋃ A ∈ ⋃ ( B × C ) ) ;;
	step 23 : wff = mpancom (step 3, step 22) |- ( ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) → ⋃ A ∈ ⋃ ( B × C ) ) ;;
	step 24 : wff = sylbi (step 1, step 23) |- ( A ∈ ( B × C ) → ⋃ A ∈ ⋃ ( B × C ) ) ;;
	qed prop 1 = step 24 ;;
}

/* Reconstruction of a member of a cross product in terms of its ordered pair
     components.  (Contributed by NM, 20-Oct-2013.) */

theorem 1st2nd2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∈ ( B × C ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
}

proof of 1st2nd2 {
	step 1 : wff = elxp6 () |- ( A ∈ ( B × C ) ↔ ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∧ ( ( 1st ` A ) ∈ B ∧ ( 2nd ` A ) ∈ C ) ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( A ∈ ( B × C ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	qed prop 1 = step 2 ;;
}

/* Reconstruction of an ordered pair in terms of its components.
     (Contributed by NM, 25-Feb-2014.) */

theorem 1st2ndb (A : class)  {
	prop 1 : wff = |- ( A ∈ ( _V × _V ) ↔ A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
}

proof of 1st2ndb {
	step 1 : wff = 1st2nd2 () |- ( A ∈ ( _V × _V ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 2 : wff = id () |- ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 3 : wff = fvex () |- ( 1st ` A ) ∈ _V ;;
	step 4 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 5 : wff = opelvv (step 3, step 4) |- 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ ( _V × _V ) ;;
	step 6 : wff = syl6eqel (step 2, step 5) |- ( A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 → A ∈ ( _V × _V ) ) ;;
	step 7 : wff = impbii (step 1, step 6) |- ( A ∈ ( _V × _V ) ↔ A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	qed prop 1 = step 7 ;;
}

/* An ordered pair theorem for members of cross products.  (Contributed by
     NM, 20-Jun-2007.) */

theorem xpopth (A : class, B : class, C : class, D : class, R : class, S : class)  {
	prop 1 : wff = |- ( ( A ∈ ( C × D ) ∧ B ∈ ( R × S ) ) → ( ( ( 1st ` A ) = ( 1st ` B ) ∧ ( 2nd ` A ) = ( 2nd ` B ) ) ↔ A = B ) ) ;;
}

proof of xpopth {
	step 1 : wff = 1st2nd2 () |- ( A ∈ ( C × D ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 2 : wff = 1st2nd2 () |- ( B ∈ ( R × S ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 3 : wff = eqeqan12d (step 1, step 2) |- ( ( A ∈ ( C × D ) ∧ B ∈ ( R × S ) ) → ( A = B ↔ 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ) ;;
	step 4 : wff = fvex () |- ( 1st ` A ) ∈ _V ;;
	step 5 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 6 : wff = opth (step 4, step 5) |- ( 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ↔ ( ( 1st ` A ) = ( 1st ` B ) ∧ ( 2nd ` A ) = ( 2nd ` B ) ) ) ;;
	step 7 : wff = syl6rbb (step 3, step 6) |- ( ( A ∈ ( C × D ) ∧ B ∈ ( R × S ) ) → ( ( ( 1st ` A ) = ( 1st ` B ) ∧ ( 2nd ` A ) = ( 2nd ` B ) ) ↔ A = B ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Two ways to express equality with an ordered pair.  (Contributed by NM,
     3-Sep-2007.)  (Proof shortened by Mario Carneiro, 26-Apr-2015.) */

theorem eqop (A : class, B : class, C : class, V : class, W : class)  {
	prop 1 : wff = |- ( A ∈ ( V × W ) → ( A = 〈 B , C 〉 ↔ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) ) ;;
}

proof of eqop {
	step 1 : wff = 1st2nd2 () |- ( A ∈ ( V × W ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( A ∈ ( V × W ) → ( A = 〈 B , C 〉 ↔ 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 = 〈 B , C 〉 ) ) ;;
	step 3 : wff = fvex () |- ( 1st ` A ) ∈ _V ;;
	step 4 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 5 : wff = opth (step 3, step 4) |- ( 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 = 〈 B , C 〉 ↔ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) ;;
	step 6 : wff = syl6bb (step 2, step 5) |- ( A ∈ ( V × W ) → ( A = 〈 B , C 〉 ↔ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Two ways to express equality with an ordered pair.  (Contributed by NM,
       25-Feb-2014.) */

theorem eqop2 (A : class, B : class, C : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A = 〈 B , C 〉 ↔ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) ) ;;
}

proof of eqop2 {
	step 1 : wff = opelvv (hyp 1, hyp 2) |- 〈 B , C 〉 ∈ ( _V × _V ) ;;
	step 2 : wff = eleq1 () |- ( A = 〈 B , C 〉 → ( A ∈ ( _V × _V ) ↔ 〈 B , C 〉 ∈ ( _V × _V ) ) ) ;;
	step 3 : wff = mpbiri (step 1, step 2) |- ( A = 〈 B , C 〉 → A ∈ ( _V × _V ) ) ;;
	step 4 : wff = eqop () |- ( A ∈ ( _V × _V ) → ( A = 〈 B , C 〉 ↔ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) ) ;;
	step 5 : wff = biadan2 (step 3, step 4) |- ( A = 〈 B , C 〉 ↔ ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = C ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Two ways of expressing that an element is the first member of an ordered
       pair.  (Contributed by NM, 22-Sep-2013.)  (Revised by Mario Carneiro,
       23-Feb-2014.) */

theorem op1steq (x : set, A : class, B : class, V : class, W : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∈ ( V × W ) → ( ( 1st ` A ) = B ↔ ∃ x A = 〈 B , x 〉 ) ) ;;
}

proof of op1steq {
	step 1 : wff = xpss () |- ( V × W ) ⊆ ( _V × _V ) ;;
	step 2 : wff = sseli (step 1) |- ( A ∈ ( V × W ) → A ∈ ( _V × _V ) ) ;;
	step 3 : wff = eqid () |- ( 2nd ` A ) = ( 2nd ` A ) ;;
	step 4 : wff = eqopi () |- ( ( A ∈ ( _V × _V ) ∧ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = ( 2nd ` A ) ) ) → A = 〈 B , ( 2nd ` A ) 〉 ) ;;
	step 5 : wff = mpanr2 (step 3, step 4) |- ( ( A ∈ ( _V × _V ) ∧ ( 1st ` A ) = B ) → A = 〈 B , ( 2nd ` A ) 〉 ) ;;
	step 6 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 7 : wff = opeq2 () |- ( x = ( 2nd ` A ) → 〈 B , x 〉 = 〈 B , ( 2nd ` A ) 〉 ) ;;
	step 8 : wff = eqeq2d (step 7) |- ( x = ( 2nd ` A ) → ( A = 〈 B , x 〉 ↔ A = 〈 B , ( 2nd ` A ) 〉 ) ) ;;
	step 9 : wff = spcev (step 6, step 8) |- ( A = 〈 B , ( 2nd ` A ) 〉 → ∃ x A = 〈 B , x 〉 ) ;;
	step 10 : wff = syl (step 5, step 9) |- ( ( A ∈ ( _V × _V ) ∧ ( 1st ` A ) = B ) → ∃ x A = 〈 B , x 〉 ) ;;
	step 11 : wff = ex (step 10) |- ( A ∈ ( _V × _V ) → ( ( 1st ` A ) = B → ∃ x A = 〈 B , x 〉 ) ) ;;
	step 12 : wff = eqop () |- ( A ∈ ( _V × _V ) → ( A = 〈 B , x 〉 ↔ ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = x ) ) ) ;;
	step 13 : wff = simpl () |- ( ( ( 1st ` A ) = B ∧ ( 2nd ` A ) = x ) → ( 1st ` A ) = B ) ;;
	step 14 : wff = syl6bi (step 12, step 13) |- ( A ∈ ( _V × _V ) → ( A = 〈 B , x 〉 → ( 1st ` A ) = B ) ) ;;
	step 15 : wff = exlimdv (step 14) |- ( A ∈ ( _V × _V ) → ( ∃ x A = 〈 B , x 〉 → ( 1st ` A ) = B ) ) ;;
	step 16 : wff = impbid (step 11, step 15) |- ( A ∈ ( _V × _V ) → ( ( 1st ` A ) = B ↔ ∃ x A = 〈 B , x 〉 ) ) ;;
	step 17 : wff = syl (step 2, step 16) |- ( A ∈ ( V × W ) → ( ( 1st ` A ) = B ↔ ∃ x A = 〈 B , x 〉 ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Swap the members of an ordered pair.  (Contributed by NM, 31-Dec-2014.) */

theorem 2nd1st (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∈ ( B × C ) → ⋃ ⁻¹ { A } = 〈 ( 2nd ` A ) , ( 1st ` A ) 〉 ) ;;
}

proof of 2nd1st {
	step 1 : wff = 1st2nd2 () |- ( A ∈ ( B × C ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 2 : wff = sneqd (step 1) |- ( A ∈ ( B × C ) → { A } = { 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 } ) ;;
	step 3 : wff = cnveqd (step 2) |- ( A ∈ ( B × C ) → ⁻¹ { A } = ⁻¹ { 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 } ) ;;
	step 4 : wff = unieqd (step 3) |- ( A ∈ ( B × C ) → ⋃ ⁻¹ { A } = ⋃ ⁻¹ { 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 } ) ;;
	step 5 : wff = opswap () |- ⋃ ⁻¹ { 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 } = 〈 ( 2nd ` A ) , ( 1st ` A ) 〉 ;;
	step 6 : wff = syl6eq (step 4, step 5) |- ( A ∈ ( B × C ) → ⋃ ⁻¹ { A } = 〈 ( 2nd ` A ) , ( 1st ` A ) 〉 ) ;;
	qed prop 1 = step 6 ;;
}

/* Reconstruction of a member of a relation in terms of its ordered pair
     components.  (Contributed by NM, 29-Aug-2006.) */

theorem 1st2nd (A : class, B : class)  {
	prop 1 : wff = |- ( ( Rel B ∧ A ∈ B ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
}

proof of 1st2nd {
	step 1 : wff = df-rel () |- ( Rel B ↔ B ⊆ ( _V × _V ) ) ;;
	step 2 : wff = ssel2 () |- ( ( B ⊆ ( _V × _V ) ∧ A ∈ B ) → A ∈ ( _V × _V ) ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( Rel B ∧ A ∈ B ) → A ∈ ( _V × _V ) ) ;;
	step 4 : wff = 1st2nd2 () |- ( A ∈ ( _V × _V ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ( Rel B ∧ A ∈ B ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	qed prop 1 = step 5 ;;
}

/* The first ordered pair component of a member of a relation belongs to the
     domain of the relation.  (Contributed by NM, 17-Sep-2006.) */

theorem 1stdm (A : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A ∈ R ) → ( 1st ` A ) ∈ dom R ) ;;
}

proof of 1stdm {
	step 1 : wff = df-rel () |- ( Rel R ↔ R ⊆ ( _V × _V ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( Rel R → R ⊆ ( _V × _V ) ) ;;
	step 3 : wff = sselda (step 2) |- ( ( Rel R ∧ A ∈ R ) → A ∈ ( _V × _V ) ) ;;
	step 4 : wff = 1stval2 () |- ( A ∈ ( _V × _V ) → ( 1st ` A ) = ⋂ ⋂ A ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ( Rel R ∧ A ∈ R ) → ( 1st ` A ) = ⋂ ⋂ A ) ;;
	step 6 : wff = elreldm () |- ( ( Rel R ∧ A ∈ R ) → ⋂ ⋂ A ∈ dom R ) ;;
	step 7 : wff = eqeltrd (step 5, step 6) |- ( ( Rel R ∧ A ∈ R ) → ( 1st ` A ) ∈ dom R ) ;;
	qed prop 1 = step 7 ;;
}

/* The second ordered pair component of a member of a relation belongs to the
     range of the relation.  (Contributed by NM, 17-Sep-2006.) */

theorem 2ndrn (A : class, R : class)  {
	prop 1 : wff = |- ( ( Rel R ∧ A ∈ R ) → ( 2nd ` A ) ∈ ran R ) ;;
}

proof of 2ndrn {
	step 1 : wff = 1st2nd () |- ( ( Rel R ∧ A ∈ R ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 2 : wff = simpr () |- ( ( Rel R ∧ A ∈ R ) → A ∈ R ) ;;
	step 3 : wff = eqeltrrd (step 1, step 2) |- ( ( Rel R ∧ A ∈ R ) → 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ R ) ;;
	step 4 : wff = fvex () |- ( 1st ` A ) ∈ _V ;;
	step 5 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 6 : wff = opelrn (step 4, step 5) |- ( 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ R → ( 2nd ` A ) ∈ ran R ) ;;
	step 7 : wff = syl (step 3, step 6) |- ( ( Rel R ∧ A ∈ R ) → ( 2nd ` A ) ∈ ran R ) ;;
	qed prop 1 = step 7 ;;
}

/* Express an element of a relation as a relationship between first and
     second components.  (Contributed by Mario Carneiro, 22-Jun-2016.) */

theorem 1st2ndbr (A : class, B : class)  {
	prop 1 : wff = |- ( ( Rel B ∧ A ∈ B ) → ( 1st ` A ) B ( 2nd ` A ) ) ;;
}

proof of 1st2ndbr {
	step 1 : wff = 1st2nd () |- ( ( Rel B ∧ A ∈ B ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 2 : wff = simpr () |- ( ( Rel B ∧ A ∈ B ) → A ∈ B ) ;;
	step 3 : wff = eqeltrrd (step 1, step 2) |- ( ( Rel B ∧ A ∈ B ) → 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ B ) ;;
	step 4 : wff = df-br () |- ( ( 1st ` A ) B ( 2nd ` A ) ↔ 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ B ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ( Rel B ∧ A ∈ B ) → ( 1st ` A ) B ( 2nd ` A ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Two ways of expressing membership in the domain of a relation.
       (Contributed by NM, 22-Sep-2013.) */

theorem releldm2 (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( Rel A → ( B ∈ dom A ↔ ∃ x ∈ A ( 1st ` x ) = B ) ) ;;
}

proof of releldm2 {
	var y : set;;
	step 1 : wff = elex () |- ( B ∈ dom A → B ∈ _V ) ;;
	step 2 : wff = anim2i (step 1) |- ( ( Rel A ∧ B ∈ dom A ) → ( Rel A ∧ B ∈ _V ) ) ;;
	step 3 : wff = id () |- ( ( 1st ` x ) = B → ( 1st ` x ) = B ) ;;
	step 4 : wff = fvex () |- ( 1st ` x ) ∈ _V ;;
	step 5 : wff = syl6eqelr (step 3, step 4) |- ( ( 1st ` x ) = B → B ∈ _V ) ;;
	step 6 : wff = rexlimivw (step 5) |- ( ∃ x ∈ A ( 1st ` x ) = B → B ∈ _V ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( Rel A ∧ ∃ x ∈ A ( 1st ` x ) = B ) → ( Rel A ∧ B ∈ _V ) ) ;;
	step 8 : wff = eldm2g () |- ( B ∈ _V → ( B ∈ dom A ↔ ∃ y 〈 B , y 〉 ∈ A ) ) ;;
	step 9 : wff = adantl (step 8) |- ( ( Rel A ∧ B ∈ _V ) → ( B ∈ dom A ↔ ∃ y 〈 B , y 〉 ∈ A ) ) ;;
	step 10 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 11 : wff = ssel () |- ( A ⊆ ( _V × _V ) → ( x ∈ A → x ∈ ( _V × _V ) ) ) ;;
	step 12 : wff = sylbi (step 10, step 11) |- ( Rel A → ( x ∈ A → x ∈ ( _V × _V ) ) ) ;;
	step 13 : wff = imp (step 12) |- ( ( Rel A ∧ x ∈ A ) → x ∈ ( _V × _V ) ) ;;
	step 14 : wff = op1steq () |- ( x ∈ ( _V × _V ) → ( ( 1st ` x ) = B ↔ ∃ y x = 〈 B , y 〉 ) ) ;;
	step 15 : wff = syl (step 13, step 14) |- ( ( Rel A ∧ x ∈ A ) → ( ( 1st ` x ) = B ↔ ∃ y x = 〈 B , y 〉 ) ) ;;
	step 16 : wff = rexbidva (step 15) |- ( Rel A → ( ∃ x ∈ A ( 1st ` x ) = B ↔ ∃ x ∈ A ∃ y x = 〈 B , y 〉 ) ) ;;
	step 17 : wff = adantr (step 16) |- ( ( Rel A ∧ B ∈ _V ) → ( ∃ x ∈ A ( 1st ` x ) = B ↔ ∃ x ∈ A ∃ y x = 〈 B , y 〉 ) ) ;;
	step 18 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ y x = 〈 B , y 〉 ↔ ∃ y ∃ x ∈ A x = 〈 B , y 〉 ) ;;
	step 19 : wff = risset () |- ( 〈 B , y 〉 ∈ A ↔ ∃ x ∈ A x = 〈 B , y 〉 ) ;;
	step 20 : wff = exbii (step 19) |- ( ∃ y 〈 B , y 〉 ∈ A ↔ ∃ y ∃ x ∈ A x = 〈 B , y 〉 ) ;;
	step 21 : wff = bitr4i (step 18, step 20) |- ( ∃ x ∈ A ∃ y x = 〈 B , y 〉 ↔ ∃ y 〈 B , y 〉 ∈ A ) ;;
	step 22 : wff = syl6bb (step 17, step 21) |- ( ( Rel A ∧ B ∈ _V ) → ( ∃ x ∈ A ( 1st ` x ) = B ↔ ∃ y 〈 B , y 〉 ∈ A ) ) ;;
	step 23 : wff = bitr4d (step 9, step 22) |- ( ( Rel A ∧ B ∈ _V ) → ( B ∈ dom A ↔ ∃ x ∈ A ( 1st ` x ) = B ) ) ;;
	step 24 : wff = pm5.21nd (step 2, step 7, step 23) |- ( Rel A → ( B ∈ dom A ↔ ∃ x ∈ A ( 1st ` x ) = B ) ) ;;
	qed prop 1 = step 24 ;;
}

/* An expression for the domain of a relation.  (Contributed by NM,
       22-Sep-2013.) */

theorem reldm (x : set, A : class) disjointed(x y z A) {
	prop 1 : wff = |- ( Rel A → dom A = ran ( x ∈ A ↦ ( 1st ` x ) ) ) ;;
}

proof of reldm {
	var y : set, z : set;;
	step 1 : wff = releldm2 () |- ( Rel A → ( y ∈ dom A ↔ ∃ z ∈ A ( 1st ` z ) = y ) ) ;;
	step 2 : wff = fvex () |- ( 1st ` x ) ∈ _V ;;
	step 3 : wff = eqid () |- ( x ∈ A ↦ ( 1st ` x ) ) = ( x ∈ A ↦ ( 1st ` x ) ) ;;
	step 4 : wff = fnmpti (step 2, step 3) |- ( x ∈ A ↦ ( 1st ` x ) ) Fn A ;;
	step 5 : wff = fvelrnb () |- ( ( x ∈ A ↦ ( 1st ` x ) ) Fn A → ( y ∈ ran ( x ∈ A ↦ ( 1st ` x ) ) ↔ ∃ z ∈ A ( ( x ∈ A ↦ ( 1st ` x ) ) ` z ) = y ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( y ∈ ran ( x ∈ A ↦ ( 1st ` x ) ) ↔ ∃ z ∈ A ( ( x ∈ A ↦ ( 1st ` x ) ) ` z ) = y ) ;;
	step 7 : wff = fveq2 () |- ( x = z → ( 1st ` x ) = ( 1st ` z ) ) ;;
	step 8 : wff = eqid () |- ( x ∈ A ↦ ( 1st ` x ) ) = ( x ∈ A ↦ ( 1st ` x ) ) ;;
	step 9 : wff = fvex () |- ( 1st ` z ) ∈ _V ;;
	step 10 : wff = fvmpt (step 7, step 8, step 9) |- ( z ∈ A → ( ( x ∈ A ↦ ( 1st ` x ) ) ` z ) = ( 1st ` z ) ) ;;
	step 11 : wff = eqeq1d (step 10) |- ( z ∈ A → ( ( ( x ∈ A ↦ ( 1st ` x ) ) ` z ) = y ↔ ( 1st ` z ) = y ) ) ;;
	step 12 : wff = rexbiia (step 11) |- ( ∃ z ∈ A ( ( x ∈ A ↦ ( 1st ` x ) ) ` z ) = y ↔ ∃ z ∈ A ( 1st ` z ) = y ) ;;
	step 13 : wff = a1i (step 12) |- ( Rel A → ( ∃ z ∈ A ( ( x ∈ A ↦ ( 1st ` x ) ) ` z ) = y ↔ ∃ z ∈ A ( 1st ` z ) = y ) ) ;;
	step 14 : wff = syl5rbb (step 6, step 13) |- ( Rel A → ( ∃ z ∈ A ( 1st ` z ) = y ↔ y ∈ ran ( x ∈ A ↦ ( 1st ` x ) ) ) ) ;;
	step 15 : wff = bitrd (step 1, step 14) |- ( Rel A → ( y ∈ dom A ↔ y ∈ ran ( x ∈ A ↦ ( 1st ` x ) ) ) ) ;;
	step 16 : wff = eqrdv (step 15) |- ( Rel A → dom A = ran ( x ∈ A ↦ ( 1st ` x ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Equality theorem for substitution of a class for an ordered pair (analog
     of ~ sbceq1a that avoids the existential quantifiers of ~ copsexg ).
     (Contributed by NM, 19-Aug-2006.)  (Revised by Mario Carneiro,
     31-Aug-2015.) */

theorem sbcopeq1a (ph : wff, x : set, y : set, A : class)  {
	prop 1 : wff = |- ( A = 〈 x , y 〉 → ( [. ( 1st ` A ) / x ]. [. ( 2nd ` A ) / y ]. ph ↔ ph ) ) ;;
}

proof of sbcopeq1a {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = op2ndd (step 1, step 2) |- ( A = 〈 x , y 〉 → ( 2nd ` A ) = y ) ;;
	step 4 : wff = eqcomd (step 3) |- ( A = 〈 x , y 〉 → y = ( 2nd ` A ) ) ;;
	step 5 : wff = sbceq1a () |- ( y = ( 2nd ` A ) → ( ph ↔ [. ( 2nd ` A ) / y ]. ph ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A = 〈 x , y 〉 → ( ph ↔ [. ( 2nd ` A ) / y ]. ph ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = op1std (step 7, step 8) |- ( A = 〈 x , y 〉 → ( 1st ` A ) = x ) ;;
	step 10 : wff = eqcomd (step 9) |- ( A = 〈 x , y 〉 → x = ( 1st ` A ) ) ;;
	step 11 : wff = sbceq1a () |- ( x = ( 1st ` A ) → ( [. ( 2nd ` A ) / y ]. ph ↔ [. ( 1st ` A ) / x ]. [. ( 2nd ` A ) / y ]. ph ) ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( A = 〈 x , y 〉 → ( [. ( 2nd ` A ) / y ]. ph ↔ [. ( 1st ` A ) / x ]. [. ( 2nd ` A ) / y ]. ph ) ) ;;
	step 13 : wff = bitr2d (step 6, step 12) |- ( A = 〈 x , y 〉 → ( [. ( 1st ` A ) / x ]. [. ( 2nd ` A ) / y ]. ph ↔ ph ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Equality theorem for substitution of a class ` A ` for an ordered pair
     ` <. x , y >. ` in ` B ` (analog of ~ csbeq1a ).  (Contributed by NM,
     19-Aug-2006.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem csbopeq1a (x : set, y : set, A : class, B : class)  {
	prop 1 : wff = |- ( A = 〈 x , y 〉 → [_ ( 1st ` A ) / x ]_ [_ ( 2nd ` A ) / y ]_ B = B ) ;;
}

proof of csbopeq1a {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = op2ndd (step 1, step 2) |- ( A = 〈 x , y 〉 → ( 2nd ` A ) = y ) ;;
	step 4 : wff = eqcomd (step 3) |- ( A = 〈 x , y 〉 → y = ( 2nd ` A ) ) ;;
	step 5 : wff = csbeq1a () |- ( y = ( 2nd ` A ) → B = [_ ( 2nd ` A ) / y ]_ B ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A = 〈 x , y 〉 → B = [_ ( 2nd ` A ) / y ]_ B ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = vex () |- y ∈ _V ;;
	step 9 : wff = op1std (step 7, step 8) |- ( A = 〈 x , y 〉 → ( 1st ` A ) = x ) ;;
	step 10 : wff = eqcomd (step 9) |- ( A = 〈 x , y 〉 → x = ( 1st ` A ) ) ;;
	step 11 : wff = csbeq1a () |- ( x = ( 1st ` A ) → [_ ( 2nd ` A ) / y ]_ B = [_ ( 1st ` A ) / x ]_ [_ ( 2nd ` A ) / y ]_ B ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( A = 〈 x , y 〉 → [_ ( 2nd ` A ) / y ]_ B = [_ ( 1st ` A ) / x ]_ [_ ( 2nd ` A ) / y ]_ B ) ;;
	step 13 : wff = eqtr2d (step 6, step 12) |- ( A = 〈 x , y 〉 → [_ ( 1st ` A ) / x ]_ [_ ( 2nd ` A ) / y ]_ B = B ) ;;
	qed prop 1 = step 13 ;;
}

/* A way to define an ordered-pair class abstraction without using
       existential quantifiers.  (Contributed by NM, 18-Aug-2006.)  (Revised by
       Mario Carneiro, 31-Aug-2015.) */

theorem dfopab2 (ph : wff, x : set, y : set, z : set) disjointed(z ph, x y z) {
	prop 1 : wff = |- { 〈 x , y 〉 | ph } = { z ∈ ( _V × _V ) | [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph } ;;
}

proof of dfopab2 {
	step 1 : wff = nfsbc1v () |- F/ x [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ;;
	step 2 : wff = 19.41 (step 1) |- ( ∃ x ( ∃ y z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ↔ ( ∃ x ∃ y z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ) ;;
	step 3 : wff = sbcopeq1a () |- ( z = 〈 x , y 〉 → ( [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ↔ ph ) ) ;;
	step 4 : wff = pm5.32i (step 3) |- ( ( z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ↔ ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ( z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ↔ ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 6 : wff = nfcv () |- F/_ y ( 1st ` z ) ;;
	step 7 : wff = nfsbc1v () |- F/ y [. ( 2nd ` z ) / y ]. ph ;;
	step 8 : wff = nfsbc (step 6, step 7) |- F/ y [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ;;
	step 9 : wff = 19.41 (step 8) |- ( ∃ y ( z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ↔ ( ∃ y z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ) ;;
	step 10 : wff = bitr3i (step 5, step 9) |- ( ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ( ∃ y z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ) ;;
	step 11 : wff = exbii (step 10) |- ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ( ∃ y z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ) ;;
	step 12 : wff = elvv () |- ( z ∈ ( _V × _V ) ↔ ∃ x ∃ y z = 〈 x , y 〉 ) ;;
	step 13 : wff = anbi1i (step 12) |- ( ( z ∈ ( _V × _V ) ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ↔ ( ∃ x ∃ y z = 〈 x , y 〉 ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ) ;;
	step 14 : wff = 3bitr4i (step 2, step 11, step 13) |- ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ( z ∈ ( _V × _V ) ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) ) ;;
	step 15 : wff = abbii (step 14) |- { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } = { z | ( z ∈ ( _V × _V ) ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) } ;;
	step 16 : wff = df-opab () |- { 〈 x , y 〉 | ph } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ;;
	step 17 : wff = df-rab () |- { z ∈ ( _V × _V ) | [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph } = { z | ( z ∈ ( _V × _V ) ∧ [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph ) } ;;
	step 18 : wff = 3eqtr4i (step 15, step 16, step 17) |- { 〈 x , y 〉 | ph } = { z ∈ ( _V × _V ) | [. ( 1st ` z ) / x ]. [. ( 2nd ` z ) / y ]. ph } ;;
	qed prop 1 = step 18 ;;
}

/* A way to define an operation class abstraction without using existential
       quantifiers.  (Contributed by NM, 18-Aug-2006.)  (Revised by Mario
       Carneiro, 31-Aug-2015.) */

theorem dfoprab3s (ph : wff, x : set, y : set, z : set, w : set) disjointed(w ph, x y z w) {
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) } ;;
}

proof of dfoprab3s {
	step 1 : wff = dfoprab2 () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } ;;
	step 2 : wff = nfsbc1v () |- F/ x [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ;;
	step 3 : wff = 19.41 (step 2) |- ( ∃ x ( ∃ y w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ↔ ( ∃ x ∃ y w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ) ;;
	step 4 : wff = sbcopeq1a () |- ( w = 〈 x , y 〉 → ( [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ↔ ph ) ) ;;
	step 5 : wff = pm5.32i (step 4) |- ( ( w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ↔ ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ( w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ↔ ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 7 : wff = nfcv () |- F/_ y ( 1st ` w ) ;;
	step 8 : wff = nfsbc1v () |- F/ y [. ( 2nd ` w ) / y ]. ph ;;
	step 9 : wff = nfsbc (step 7, step 8) |- F/ y [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ;;
	step 10 : wff = 19.41 (step 9) |- ( ∃ y ( w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ↔ ( ∃ y w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ) ;;
	step 11 : wff = bitr3i (step 6, step 10) |- ( ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ( ∃ y w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ( ∃ y w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ) ;;
	step 13 : wff = elvv () |- ( w ∈ ( _V × _V ) ↔ ∃ x ∃ y w = 〈 x , y 〉 ) ;;
	step 14 : wff = anbi1i (step 13) |- ( ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ↔ ( ∃ x ∃ y w = 〈 x , y 〉 ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ) ;;
	step 15 : wff = 3bitr4i (step 3, step 12, step 14) |- ( ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) ) ;;
	step 16 : wff = opabbii (step 15) |- { 〈 w , z 〉 | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) } = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) } ;;
	step 17 : wff = eqtri (step 1, step 16) |- { 〈 〈 x , y 〉 , z 〉 | ph } = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ph ) } ;;
	qed prop 1 = step 17 ;;
}

/* Operation class abstraction expressed without existential quantifiers.
       (Contributed by NM, 16-Dec-2008.) */

theorem dfoprab3 (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(x y ph, w ps, x y z w) {
	hyp 1 : wff = |- ( w = 〈 x , y 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ps } ;;
}

proof of dfoprab3 {
	step 1 : wff = dfoprab3s () |- { 〈 〈 x , y 〉 , z 〉 | ps } = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ps ) } ;;
	step 2 : wff = fvex () |- ( 1st ` w ) ∈ _V ;;
	step 3 : wff = fvex () |- ( 2nd ` w ) ∈ _V ;;
	step 4 : wff = eqcom () |- ( x = ( 1st ` w ) ↔ ( 1st ` w ) = x ) ;;
	step 5 : wff = eqcom () |- ( y = ( 2nd ` w ) ↔ ( 2nd ` w ) = y ) ;;
	step 6 : wff = anbi12i (step 4, step 5) |- ( ( x = ( 1st ` w ) ∧ y = ( 2nd ` w ) ) ↔ ( ( 1st ` w ) = x ∧ ( 2nd ` w ) = y ) ) ;;
	step 7 : wff = eqopi () |- ( ( w ∈ ( _V × _V ) ∧ ( ( 1st ` w ) = x ∧ ( 2nd ` w ) = y ) ) → w = 〈 x , y 〉 ) ;;
	step 8 : wff = sylan2b (step 6, step 7) |- ( ( w ∈ ( _V × _V ) ∧ ( x = ( 1st ` w ) ∧ y = ( 2nd ` w ) ) ) → w = 〈 x , y 〉 ) ;;
	step 9 : wff = syl (step 8, hyp 1) |- ( ( w ∈ ( _V × _V ) ∧ ( x = ( 1st ` w ) ∧ y = ( 2nd ` w ) ) ) → ( ph ↔ ps ) ) ;;
	step 10 : wff = bicomd (step 9) |- ( ( w ∈ ( _V × _V ) ∧ ( x = ( 1st ` w ) ∧ y = ( 2nd ` w ) ) ) → ( ps ↔ ph ) ) ;;
	step 11 : wff = ex (step 10) |- ( w ∈ ( _V × _V ) → ( ( x = ( 1st ` w ) ∧ y = ( 2nd ` w ) ) → ( ps ↔ ph ) ) ) ;;
	step 12 : wff = sbc2iedv (step 2, step 3, step 11) |- ( w ∈ ( _V × _V ) → ( [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ps ↔ ph ) ) ;;
	step 13 : wff = pm5.32i (step 12) |- ( ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ps ) ↔ ( w ∈ ( _V × _V ) ∧ ph ) ) ;;
	step 14 : wff = opabbii (step 13) |- { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ [. ( 1st ` w ) / x ]. [. ( 2nd ` w ) / y ]. ps ) } = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ ph ) } ;;
	step 15 : wff = eqtr2i (step 1, step 14) |- { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ps } ;;
	qed prop 1 = step 15 ;;
}

/* Operation class abstraction expressed without existential quantifiers.
       (Contributed by NM, 3-Sep-2007.)  (Revised by Mario Carneiro,
       31-Aug-2015.) */

theorem dfoprab4 (ph : wff, ps : wff, x : set, y : set, z : set, w : set, A : class, B : class) disjointed(w x y A, w x y B, x y ph, w ps, w x y z) {
	hyp 1 : wff = |- ( w = 〈 x , y 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ;;
}

proof of dfoprab4 {
	step 1 : wff = xpss () |- ( A × B ) ⊆ ( _V × _V ) ;;
	step 2 : wff = sseli (step 1) |- ( w ∈ ( A × B ) → w ∈ ( _V × _V ) ) ;;
	step 3 : wff = adantr (step 2) |- ( ( w ∈ ( A × B ) ∧ ph ) → w ∈ ( _V × _V ) ) ;;
	step 4 : wff = pm4.71ri (step 3) |- ( ( w ∈ ( A × B ) ∧ ph ) ↔ ( w ∈ ( _V × _V ) ∧ ( w ∈ ( A × B ) ∧ ph ) ) ) ;;
	step 5 : wff = opabbii (step 4) |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ph ) } = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ ( w ∈ ( A × B ) ∧ ph ) ) } ;;
	step 6 : wff = eleq1 () |- ( w = 〈 x , y 〉 → ( w ∈ ( A × B ) ↔ 〈 x , y 〉 ∈ ( A × B ) ) ) ;;
	step 7 : wff = opelxp () |- ( 〈 x , y 〉 ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ;;
	step 8 : wff = syl6bb (step 6, step 7) |- ( w = 〈 x , y 〉 → ( w ∈ ( A × B ) ↔ ( x ∈ A ∧ y ∈ B ) ) ) ;;
	step 9 : wff = anbi12d (step 8, hyp 1) |- ( w = 〈 x , y 〉 → ( ( w ∈ ( A × B ) ∧ ph ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ) ) ;;
	step 10 : wff = dfoprab3 (step 9) |- { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ ( w ∈ ( A × B ) ∧ ph ) ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ;;
	step 11 : wff = eqtri (step 5, step 10) |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ;;
	qed prop 1 = step 11 ;;
}

/* Operation class abstraction expressed without existential quantifiers.
       (Unnecessary distinct variable restrictions were removed by David
       Abernethy, 19-Jun-2012.)  (Contributed by NM, 20-Dec-2008.)  (Revised by
       Mario Carneiro, 31-Aug-2015.) */

theorem dfoprab4f (ph : wff, ps : wff, x : set, y : set, z : set, w : set, A : class, B : class) disjointed(t u w x y z, t u w x y A, t u w x y B, t u w ps, t u ph) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ y ph ;;
	hyp 3 : wff = |- ( w = 〈 x , y 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ;;
}

proof of dfoprab4f {
	var u : set, t : set;;
	step 1 : wff = nfv () |- F/ x w = 〈 t , u 〉 ;;
	step 2 : wff = nfs1v () |- F/ x [ t / x ] [ u / y ] ps ;;
	step 3 : wff = nfbi (hyp 1, step 2) |- F/ x ( ph ↔ [ t / x ] [ u / y ] ps ) ;;
	step 4 : wff = nfim (step 1, step 3) |- F/ x ( w = 〈 t , u 〉 → ( ph ↔ [ t / x ] [ u / y ] ps ) ) ;;
	step 5 : wff = opeq1 () |- ( x = t → 〈 x , u 〉 = 〈 t , u 〉 ) ;;
	step 6 : wff = eqeq2d (step 5) |- ( x = t → ( w = 〈 x , u 〉 ↔ w = 〈 t , u 〉 ) ) ;;
	step 7 : wff = sbequ12 () |- ( x = t → ( [ u / y ] ps ↔ [ t / x ] [ u / y ] ps ) ) ;;
	step 8 : wff = bibi2d (step 7) |- ( x = t → ( ( ph ↔ [ u / y ] ps ) ↔ ( ph ↔ [ t / x ] [ u / y ] ps ) ) ) ;;
	step 9 : wff = imbi12d (step 6, step 8) |- ( x = t → ( ( w = 〈 x , u 〉 → ( ph ↔ [ u / y ] ps ) ) ↔ ( w = 〈 t , u 〉 → ( ph ↔ [ t / x ] [ u / y ] ps ) ) ) ) ;;
	step 10 : wff = nfv () |- F/ y w = 〈 x , u 〉 ;;
	step 11 : wff = nfs1v () |- F/ y [ u / y ] ps ;;
	step 12 : wff = nfbi (hyp 2, step 11) |- F/ y ( ph ↔ [ u / y ] ps ) ;;
	step 13 : wff = nfim (step 10, step 12) |- F/ y ( w = 〈 x , u 〉 → ( ph ↔ [ u / y ] ps ) ) ;;
	step 14 : wff = opeq2 () |- ( y = u → 〈 x , y 〉 = 〈 x , u 〉 ) ;;
	step 15 : wff = eqeq2d (step 14) |- ( y = u → ( w = 〈 x , y 〉 ↔ w = 〈 x , u 〉 ) ) ;;
	step 16 : wff = sbequ12 () |- ( y = u → ( ps ↔ [ u / y ] ps ) ) ;;
	step 17 : wff = bibi2d (step 16) |- ( y = u → ( ( ph ↔ ps ) ↔ ( ph ↔ [ u / y ] ps ) ) ) ;;
	step 18 : wff = imbi12d (step 15, step 17) |- ( y = u → ( ( w = 〈 x , y 〉 → ( ph ↔ ps ) ) ↔ ( w = 〈 x , u 〉 → ( ph ↔ [ u / y ] ps ) ) ) ) ;;
	step 19 : wff = chvar (step 13, step 18, hyp 3) |- ( w = 〈 x , u 〉 → ( ph ↔ [ u / y ] ps ) ) ;;
	step 20 : wff = chvar (step 4, step 9, step 19) |- ( w = 〈 t , u 〉 → ( ph ↔ [ t / x ] [ u / y ] ps ) ) ;;
	step 21 : wff = dfoprab4 (step 20) |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ph ) } = { 〈 〈 t , u 〉 , z 〉 | ( ( t ∈ A ∧ u ∈ B ) ∧ [ t / x ] [ u / y ] ps ) } ;;
	step 22 : wff = nfv () |- F/ t ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ;;
	step 23 : wff = nfv () |- F/ u ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ;;
	step 24 : wff = nfv () |- F/ x ( t ∈ A ∧ u ∈ B ) ;;
	step 25 : wff = nfs1v () |- F/ x [ t / x ] [ u / y ] ps ;;
	step 26 : wff = nfan (step 24, step 25) |- F/ x ( ( t ∈ A ∧ u ∈ B ) ∧ [ t / x ] [ u / y ] ps ) ;;
	step 27 : wff = nfv () |- F/ y ( t ∈ A ∧ u ∈ B ) ;;
	step 28 : wff = nfs1v () |- F/ y [ u / y ] ps ;;
	step 29 : wff = nfsb (step 28) |- F/ y [ t / x ] [ u / y ] ps ;;
	step 30 : wff = nfan (step 27, step 29) |- F/ y ( ( t ∈ A ∧ u ∈ B ) ∧ [ t / x ] [ u / y ] ps ) ;;
	step 31 : wff = eleq1 () |- ( x = t → ( x ∈ A ↔ t ∈ A ) ) ;;
	step 32 : wff = eleq1 () |- ( y = u → ( y ∈ B ↔ u ∈ B ) ) ;;
	step 33 : wff = bi2anan9 (step 31, step 32) |- ( ( x = t ∧ y = u ) → ( ( x ∈ A ∧ y ∈ B ) ↔ ( t ∈ A ∧ u ∈ B ) ) ) ;;
	step 34 : wff = sbequ12 () |- ( y = u → ( ps ↔ [ u / y ] ps ) ) ;;
	step 35 : wff = sbequ12 () |- ( x = t → ( [ u / y ] ps ↔ [ t / x ] [ u / y ] ps ) ) ;;
	step 36 : wff = sylan9bbr (step 34, step 35) |- ( ( x = t ∧ y = u ) → ( ps ↔ [ t / x ] [ u / y ] ps ) ) ;;
	step 37 : wff = anbi12d (step 33, step 36) |- ( ( x = t ∧ y = u ) → ( ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) ↔ ( ( t ∈ A ∧ u ∈ B ) ∧ [ t / x ] [ u / y ] ps ) ) ) ;;
	step 38 : wff = cbvoprab12 (step 22, step 23, step 26, step 30, step 37) |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } = { 〈 〈 t , u 〉 , z 〉 | ( ( t ∈ A ∧ u ∈ B ) ∧ [ t / x ] [ u / y ] ps ) } ;;
	step 39 : wff = eqtr4i (step 21, step 38) |- { 〈 w , z 〉 | ( w ∈ ( A × B ) ∧ ph ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ ps ) } ;;
	qed prop 1 = step 39 ;;
}

/* Define the cross product of three classes.  Compare ~ df-xp .
       (Contributed by FL, 6-Nov-2013.)  (Proof shortened by Mario Carneiro,
       3-Nov-2015.) */

theorem dfxp3 (x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x y z u A, x y z u B, x y z u C) {
	prop 1 : wff = |- ( ( A × B ) × C ) = { 〈 〈 x , y 〉 , z 〉 | ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) } ;;
}

proof of dfxp3 {
	var u : set;;
	step 1 : wff = biidd () |- ( u = 〈 x , y 〉 → ( z ∈ C ↔ z ∈ C ) ) ;;
	step 2 : wff = dfoprab4 (step 1) |- { 〈 u , z 〉 | ( u ∈ ( A × B ) ∧ z ∈ C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z ∈ C ) } ;;
	step 3 : wff = df-xp () |- ( ( A × B ) × C ) = { 〈 u , z 〉 | ( u ∈ ( A × B ) ∧ z ∈ C ) } ;;
	step 4 : wff = df-3an () |- ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) ↔ ( ( x ∈ A ∧ y ∈ B ) ∧ z ∈ C ) ) ;;
	step 5 : wff = oprabbii (step 4) |- { 〈 〈 x , y 〉 , z 〉 | ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) } = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z ∈ C ) } ;;
	step 6 : wff = 3eqtr4i (step 2, step 3, step 5) |- ( ( A × B ) × C ) = { 〈 〈 x , y 〉 , z 〉 | ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) } ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution inference for ordered pairs.  Compare
       ~ copsex2ga .  (Contributed by NM, 12-Mar-2014.) */

theorem copsex2gb (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, x y ph) {
	hyp 1 : wff = |- ( A = 〈 x , y 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ↔ ( A ∈ ( _V × _V ) ∧ ph ) ) ;;
}

proof of copsex2gb {
	step 1 : wff = elvv () |- ( A ∈ ( _V × _V ) ↔ ∃ x ∃ y A = 〈 x , y 〉 ) ;;
	step 2 : wff = anbi1i (step 1) |- ( ( A ∈ ( _V × _V ) ∧ ph ) ↔ ( ∃ x ∃ y A = 〈 x , y 〉 ∧ ph ) ) ;;
	step 3 : wff = 19.41vv () |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) ↔ ( ∃ x ∃ y A = 〈 x , y 〉 ∧ ph ) ) ;;
	step 4 : wff = pm5.32i (hyp 1) |- ( ( A = 〈 x , y 〉 ∧ ph ) ↔ ( A = 〈 x , y 〉 ∧ ps ) ) ;;
	step 5 : wff = 2exbii (step 4) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ) ;;
	step 6 : wff = 3bitr2ri (step 2, step 3, step 5) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ↔ ( A ∈ ( _V × _V ) ∧ ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution inference for ordered pairs.  Compare
       ~ copsex2g .  (Contributed by NM, 26-Feb-2014.)  (Proof shortened by
       Mario Carneiro, 31-Aug-2015.) */

theorem copsex2ga (ph : wff, ps : wff, x : set, y : set, A : class, V : class, W : class) disjointed(x y A, x y ph) {
	hyp 1 : wff = |- ( A = 〈 x , y 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ( V × W ) → ( ph ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ) ) ;;
}

proof of copsex2ga {
	step 1 : wff = xpss () |- ( V × W ) ⊆ ( _V × _V ) ;;
	step 2 : wff = sseli (step 1) |- ( A ∈ ( V × W ) → A ∈ ( _V × _V ) ) ;;
	step 3 : wff = copsex2gb (hyp 1) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ↔ ( A ∈ ( _V × _V ) ∧ ph ) ) ;;
	step 4 : wff = baibr (step 3) |- ( A ∈ ( _V × _V ) → ( ph ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( A ∈ ( V × W ) → ( ph ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Membership in an ordered pair class builder.  (Contributed by NM,
       25-Feb-2014.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem elopaba (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, x y ph) {
	hyp 1 : wff = |- ( A = 〈 x , y 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { 〈 x , y 〉 | ps } ↔ ( A ∈ ( _V × _V ) ∧ ph ) ) ;;
}

proof of elopaba {
	step 1 : wff = elopab () |- ( A ∈ { 〈 x , y 〉 | ps } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ) ;;
	step 2 : wff = copsex2gb (hyp 1) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ps ) ↔ ( A ∈ ( _V × _V ) ∧ ph ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A ∈ { 〈 x , y 〉 | ps } ↔ ( A ∈ ( _V × _V ) ∧ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Transfer ordered-pair existence from/to single variable existence.
       (Contributed by NM, 26-Feb-2014.)  (Proof shortened by Mario Carneiro,
       31-Aug-2015.) */

theorem exopxfr (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(y z ph, x ps, x y z) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ ( _V × _V ) ph ↔ ∃ y ∃ z ps ) ;;
}

proof of exopxfr {
	step 1 : wff = rexxp (hyp 1) |- ( ∃ x ∈ ( _V × _V ) ph ↔ ∃ y ∈ _V ∃ z ∈ _V ps ) ;;
	step 2 : wff = rexv () |- ( ∃ y ∈ _V ∃ z ∈ _V ps ↔ ∃ y ∃ z ∈ _V ps ) ;;
	step 3 : wff = rexv () |- ( ∃ z ∈ _V ps ↔ ∃ z ps ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ∃ z ∈ _V ps ↔ ∃ y ∃ z ps ) ;;
	step 5 : wff = 3bitri (step 1, step 2, step 4) |- ( ∃ x ∈ ( _V × _V ) ph ↔ ∃ y ∃ z ps ) ;;
	qed prop 1 = step 5 ;;
}

/* Transfer ordered-pair existence from/to single variable existence.
       (Contributed by NM, 26-Feb-2014.) */

theorem exopxfr2 (ph : wff, ps : wff, x : set, y : set, z : set, A : class) disjointed(x y z A, y z ph, x ps) {
	hyp 1 : wff = |- ( x = 〈 y , z 〉 → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( Rel A → ( ∃ x ∈ A ph ↔ ∃ y ∃ z ( 〈 y , z 〉 ∈ A ∧ ps ) ) ) ;;
}

proof of exopxfr2 {
	step 1 : wff = df-rel () |- ( Rel A ↔ A ⊆ ( _V × _V ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( Rel A → A ⊆ ( _V × _V ) ) ;;
	step 3 : wff = sseld (step 2) |- ( Rel A → ( x ∈ A → x ∈ ( _V × _V ) ) ) ;;
	step 4 : wff = adantrd (step 3) |- ( Rel A → ( ( x ∈ A ∧ ph ) → x ∈ ( _V × _V ) ) ) ;;
	step 5 : wff = pm4.71rd (step 4) |- ( Rel A → ( ( x ∈ A ∧ ph ) ↔ ( x ∈ ( _V × _V ) ∧ ( x ∈ A ∧ ph ) ) ) ) ;;
	step 6 : wff = rexbidv2 (step 5) |- ( Rel A → ( ∃ x ∈ A ph ↔ ∃ x ∈ ( _V × _V ) ( x ∈ A ∧ ph ) ) ) ;;
	step 7 : wff = eleq1 () |- ( x = 〈 y , z 〉 → ( x ∈ A ↔ 〈 y , z 〉 ∈ A ) ) ;;
	step 8 : wff = anbi12d (step 7, hyp 1) |- ( x = 〈 y , z 〉 → ( ( x ∈ A ∧ ph ) ↔ ( 〈 y , z 〉 ∈ A ∧ ps ) ) ) ;;
	step 9 : wff = exopxfr (step 8) |- ( ∃ x ∈ ( _V × _V ) ( x ∈ A ∧ ph ) ↔ ∃ y ∃ z ( 〈 y , z 〉 ∈ A ∧ ps ) ) ;;
	step 10 : wff = syl6bb (step 6, step 9) |- ( Rel A → ( ∃ x ∈ A ph ↔ ∃ y ∃ z ( 〈 y , z 〉 ∈ A ∧ ps ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/* A consequence of membership in an ordered-pair class abstraction, using
       ordered pair extractors.  (Contributed by NM, 29-Aug-2006.) */

theorem elopabi (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(x y A, x y ch) {
	hyp 1 : wff = |- ( x = ( 1st ` A ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = ( 2nd ` A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { 〈 x , y 〉 | ph } → ch ) ;;
}

proof of elopabi {
	step 1 : wff = relopab () |- Rel { 〈 x , y 〉 | ph } ;;
	step 2 : wff = 1st2nd () |- ( ( Rel { 〈 x , y 〉 | ph } ∧ A ∈ { 〈 x , y 〉 | ph } ) → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( A ∈ { 〈 x , y 〉 | ph } → A = 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ) ;;
	step 4 : wff = id () |- ( A ∈ { 〈 x , y 〉 | ph } → A ∈ { 〈 x , y 〉 | ph } ) ;;
	step 5 : wff = eqeltrrd (step 3, step 4) |- ( A ∈ { 〈 x , y 〉 | ph } → 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 6 : wff = fvex () |- ( 1st ` A ) ∈ _V ;;
	step 7 : wff = fvex () |- ( 2nd ` A ) ∈ _V ;;
	step 8 : wff = opelopab (step 6, step 7, hyp 1, hyp 2) |- ( 〈 ( 1st ` A ) , ( 2nd ` A ) 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ;;
	step 9 : wff = sylib (step 5, step 8) |- ( A ∈ { 〈 x , y 〉 | ph } → ch ) ;;
	qed prop 1 = step 9 ;;
}

/* A consequence of membership in an operation class abstraction, using
       ordered pair extractors.  (Contributed by NM, 6-Nov-2006.)  (Revised by
       David Abernethy, 19-Jun-2012.) */

theorem eloprabi (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class) disjointed(w x y z A, w ph, x y z th) {
	hyp 1 : wff = |- ( x = ( 1st ` ( 1st ` A ) ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = ( 2nd ` ( 1st ` A ) ) → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( z = ( 2nd ` A ) → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → th ) ;;
}

proof of eloprabi {
	var w : set;;
	step 1 : wff = eqeq1 () |- ( w = A → ( w = 〈 〈 x , y 〉 , z 〉 ↔ A = 〈 〈 x , y 〉 , z 〉 ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( w = A → ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ) ;;
	step 3 : wff = 3exbidv (step 2) |- ( w = A → ( ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ) ;;
	step 4 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ph } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ph ) } ;;
	step 5 : wff = elab2g (step 3, step 4) |- ( A ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → ( A ∈ { 〈 〈 x , y 〉 , z 〉 | ph } ↔ ∃ x ∃ y ∃ z ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ) ;;
	step 6 : wff = ibi (step 5) |- ( A ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → ∃ x ∃ y ∃ z ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) ) ;;
	step 7 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 8 : wff = vex () |- z ∈ _V ;;
	step 9 : wff = op1std (step 7, step 8) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( 1st ` A ) = 〈 x , y 〉 ) ;;
	step 10 : wff = fveq2d (step 9) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( 1st ` ( 1st ` A ) ) = ( 1st ` 〈 x , y 〉 ) ) ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = op1st (step 11, step 12) |- ( 1st ` 〈 x , y 〉 ) = x ;;
	step 14 : wff = syl6req (step 10, step 13) |- ( A = 〈 〈 x , y 〉 , z 〉 → x = ( 1st ` ( 1st ` A ) ) ) ;;
	step 15 : wff = syl (step 14, hyp 1) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( ph ↔ ps ) ) ;;
	step 16 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 17 : wff = vex () |- z ∈ _V ;;
	step 18 : wff = op1std (step 16, step 17) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( 1st ` A ) = 〈 x , y 〉 ) ;;
	step 19 : wff = fveq2d (step 18) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( 2nd ` ( 1st ` A ) ) = ( 2nd ` 〈 x , y 〉 ) ) ;;
	step 20 : wff = vex () |- x ∈ _V ;;
	step 21 : wff = vex () |- y ∈ _V ;;
	step 22 : wff = op2nd (step 20, step 21) |- ( 2nd ` 〈 x , y 〉 ) = y ;;
	step 23 : wff = syl6req (step 19, step 22) |- ( A = 〈 〈 x , y 〉 , z 〉 → y = ( 2nd ` ( 1st ` A ) ) ) ;;
	step 24 : wff = syl (step 23, hyp 2) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( ps ↔ ch ) ) ;;
	step 25 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 26 : wff = vex () |- z ∈ _V ;;
	step 27 : wff = op2ndd (step 25, step 26) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( 2nd ` A ) = z ) ;;
	step 28 : wff = eqcomd (step 27) |- ( A = 〈 〈 x , y 〉 , z 〉 → z = ( 2nd ` A ) ) ;;
	step 29 : wff = syl (step 28, hyp 3) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( ch ↔ th ) ) ;;
	step 30 : wff = 3bitrd (step 15, step 24, step 29) |- ( A = 〈 〈 x , y 〉 , z 〉 → ( ph ↔ th ) ) ;;
	step 31 : wff = biimpa (step 30) |- ( ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → th ) ;;
	step 32 : wff = exlimiv (step 31) |- ( ∃ z ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → th ) ;;
	step 33 : wff = exlimiv (step 32) |- ( ∃ y ∃ z ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → th ) ;;
	step 34 : wff = exlimiv (step 33) |- ( ∃ x ∃ y ∃ z ( A = 〈 〈 x , y 〉 , z 〉 ∧ ph ) → th ) ;;
	step 35 : wff = syl (step 6, step 34) |- ( A ∈ { 〈 〈 x , y 〉 , z 〉 | ph } → th ) ;;
	qed prop 1 = step 35 ;;
}

/* Express a two-argument function as a one-argument function, or
       vice-versa.  (Contributed by Mario Carneiro, 24-Dec-2016.) */

theorem mpt2mptsx (x : set, y : set, z : set, A : class, B : class, C : class) disjointed(u v x y z A, u v y z B, u v z C) {
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
}

proof of mpt2mptsx {
	var v : set, u : set;;
	step 1 : wff = vex () |- u ∈ _V ;;
	step 2 : wff = vex () |- v ∈ _V ;;
	step 3 : wff = op1std (step 1, step 2) |- ( z = 〈 u , v 〉 → ( 1st ` z ) = u ) ;;
	step 4 : wff = csbeq1d (step 3) |- ( z = 〈 u , v 〉 → [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C = [_ u / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 5 : wff = vex () |- u ∈ _V ;;
	step 6 : wff = vex () |- v ∈ _V ;;
	step 7 : wff = op2ndd (step 5, step 6) |- ( z = 〈 u , v 〉 → ( 2nd ` z ) = v ) ;;
	step 8 : wff = csbeq1d (step 7) |- ( z = 〈 u , v 〉 → [_ ( 2nd ` z ) / y ]_ C = [_ v / y ]_ C ) ;;
	step 9 : wff = csbeq2dv (step 8) |- ( z = 〈 u , v 〉 → [_ u / x ]_ [_ ( 2nd ` z ) / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 10 : wff = eqtrd (step 4, step 9) |- ( z = 〈 u , v 〉 → [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 11 : wff = mpt2mptx (step 10) |- ( z ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) = ( u ∈ A , v ∈ [_ u / x ]_ B ↦ [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 12 : wff = nfcv () |- F/_ u ( { x } × B ) ;;
	step 13 : wff = nfcv () |- F/_ x { u } ;;
	step 14 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ B ;;
	step 15 : wff = nfxp (step 13, step 14) |- F/_ x ( { u } × [_ u / x ]_ B ) ;;
	step 16 : wff = sneq () |- ( x = u → { x } = { u } ) ;;
	step 17 : wff = csbeq1a () |- ( x = u → B = [_ u / x ]_ B ) ;;
	step 18 : wff = xpeq12d (step 16, step 17) |- ( x = u → ( { x } × B ) = ( { u } × [_ u / x ]_ B ) ) ;;
	step 19 : wff = cbviun (step 12, step 15, step 18) |- ⋃_ x ∈ A ( { x } × B ) = ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ;;
	step 20 : wff = mpteq1 () |- ( ⋃_ x ∈ A ( { x } × B ) = ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) → ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) = ( z ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ) ;;
	step 21 : wff = ax-mp (step 19, step 20) |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) = ( z ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 22 : wff = nfcv () |- F/_ u B ;;
	step 23 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ B ;;
	step 24 : wff = nfcv () |- F/_ u C ;;
	step 25 : wff = nfcv () |- F/_ v C ;;
	step 26 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ [_ v / y ]_ C ;;
	step 27 : wff = nfcv () |- F/_ y u ;;
	step 28 : wff = nfcsb1v () |- F/_ y [_ v / y ]_ C ;;
	step 29 : wff = nfcsb (step 27, step 28) |- F/_ y [_ u / x ]_ [_ v / y ]_ C ;;
	step 30 : wff = csbeq1a () |- ( x = u → B = [_ u / x ]_ B ) ;;
	step 31 : wff = csbeq1a () |- ( y = v → C = [_ v / y ]_ C ) ;;
	step 32 : wff = csbeq1a () |- ( x = u → [_ v / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 33 : wff = sylan9eqr (step 31, step 32) |- ( ( x = u ∧ y = v ) → C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 34 : wff = cbvmpt2x (step 22, step 23, step 24, step 25, step 26, step 29, step 30, step 33) |- ( x ∈ A , y ∈ B ↦ C ) = ( u ∈ A , v ∈ [_ u / x ]_ B ↦ [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 35 : wff = 3eqtr4ri (step 11, step 21, step 34) |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	qed prop 1 = step 35 ;;
}

/* Express a two-argument function as a one-argument function, or
       vice-versa.  (Contributed by Mario Carneiro, 24-Sep-2015.) */

theorem mpt2mpts (x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x y z A, y z B, z C, x B) {
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ ( A × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
}

proof of mpt2mpts {
	step 1 : wff = mpt2mptsx () |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 2 : wff = iunxpconst () |- ⋃_ x ∈ A ( { x } × B ) = ( A × B ) ;;
	step 3 : wff = mpteq1 () |- ( ⋃_ x ∈ A ( { x } × B ) = ( A × B ) → ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) = ( z ∈ ( A × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) = ( z ∈ ( A × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 5 : wff = eqtri (step 1, step 4) |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ ( A × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	qed prop 1 = step 5 ;;
}

/* The domain of a mapping is a subset of its base class.  (Contributed by
       Mario Carneiro, 9-Feb-2015.) */

theorem dmmpt2ssx (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(t u v x y A, t u v y B, t u v C, v x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- dom F ⊆ ⋃_ x ∈ A ( { x } × B ) ;;
}

proof of dmmpt2ssx {
	var v : set, u : set, t : set;;
	step 1 : wff = nfcv () |- F/_ u B ;;
	step 2 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ B ;;
	step 3 : wff = nfcv () |- F/_ u C ;;
	step 4 : wff = nfcv () |- F/_ v C ;;
	step 5 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ [_ v / y ]_ C ;;
	step 6 : wff = nfcv () |- F/_ y u ;;
	step 7 : wff = nfcsb1v () |- F/_ y [_ v / y ]_ C ;;
	step 8 : wff = nfcsb (step 6, step 7) |- F/_ y [_ u / x ]_ [_ v / y ]_ C ;;
	step 9 : wff = csbeq1a () |- ( x = u → B = [_ u / x ]_ B ) ;;
	step 10 : wff = csbeq1a () |- ( y = v → C = [_ v / y ]_ C ) ;;
	step 11 : wff = csbeq1a () |- ( x = u → [_ v / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 12 : wff = sylan9eqr (step 10, step 11) |- ( ( x = u ∧ y = v ) → C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 13 : wff = cbvmpt2x (step 1, step 2, step 3, step 4, step 5, step 8, step 9, step 12) |- ( x ∈ A , y ∈ B ↦ C ) = ( u ∈ A , v ∈ [_ u / x ]_ B ↦ [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 14 : wff = vex () |- u ∈ _V ;;
	step 15 : wff = vex () |- v ∈ _V ;;
	step 16 : wff = op1std (step 14, step 15) |- ( t = 〈 u , v 〉 → ( 1st ` t ) = u ) ;;
	step 17 : wff = csbeq1d (step 16) |- ( t = 〈 u , v 〉 → [_ ( 1st ` t ) / x ]_ [_ ( 2nd ` t ) / y ]_ C = [_ u / x ]_ [_ ( 2nd ` t ) / y ]_ C ) ;;
	step 18 : wff = vex () |- u ∈ _V ;;
	step 19 : wff = vex () |- v ∈ _V ;;
	step 20 : wff = op2ndd (step 18, step 19) |- ( t = 〈 u , v 〉 → ( 2nd ` t ) = v ) ;;
	step 21 : wff = csbeq1d (step 20) |- ( t = 〈 u , v 〉 → [_ ( 2nd ` t ) / y ]_ C = [_ v / y ]_ C ) ;;
	step 22 : wff = csbeq2dv (step 21) |- ( t = 〈 u , v 〉 → [_ u / x ]_ [_ ( 2nd ` t ) / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 23 : wff = eqtrd (step 17, step 22) |- ( t = 〈 u , v 〉 → [_ ( 1st ` t ) / x ]_ [_ ( 2nd ` t ) / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 24 : wff = mpt2mptx (step 23) |- ( t ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ↦ [_ ( 1st ` t ) / x ]_ [_ ( 2nd ` t ) / y ]_ C ) = ( u ∈ A , v ∈ [_ u / x ]_ B ↦ [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 25 : wff = 3eqtr4i (step 13, hyp 1, step 24) |- F = ( t ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ↦ [_ ( 1st ` t ) / x ]_ [_ ( 2nd ` t ) / y ]_ C ) ;;
	step 26 : wff = dmmptss (step 25) |- dom F ⊆ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ;;
	step 27 : wff = nfcv () |- F/_ u ( { x } × B ) ;;
	step 28 : wff = nfcv () |- F/_ x { u } ;;
	step 29 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ B ;;
	step 30 : wff = nfxp (step 28, step 29) |- F/_ x ( { u } × [_ u / x ]_ B ) ;;
	step 31 : wff = sneq () |- ( x = u → { x } = { u } ) ;;
	step 32 : wff = csbeq1a () |- ( x = u → B = [_ u / x ]_ B ) ;;
	step 33 : wff = xpeq12d (step 31, step 32) |- ( x = u → ( { x } × B ) = ( { u } × [_ u / x ]_ B ) ) ;;
	step 34 : wff = cbviun (step 27, step 30, step 33) |- ⋃_ x ∈ A ( { x } × B ) = ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ;;
	step 35 : wff = sseqtr4i (step 26, step 34) |- dom F ⊆ ⋃_ x ∈ A ( { x } × B ) ;;
	qed prop 1 = step 35 ;;
}

/* Functionality, domain and codomain of a class given by the "maps to"
       notation, where ` B ( x ) ` is not constant but depends on ` x ` .
       (Contributed by NM, 29-Dec-2014.) */

theorem fmpt2x (x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(v w x y z A, v w y z B, v w z C, v w x y z D) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ∈ D ↔ F : ⋃_ x ∈ A ( { x } × B ) ⟶ D ) ;;
}

proof of fmpt2x {
	var z : set, w : set, v : set;;
	step 1 : wff = vex () |- z ∈ _V ;;
	step 2 : wff = vex () |- w ∈ _V ;;
	step 3 : wff = op1std (step 1, step 2) |- ( v = 〈 z , w 〉 → ( 1st ` v ) = z ) ;;
	step 4 : wff = csbeq1d (step 3) |- ( v = 〈 z , w 〉 → [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C = [_ z / x ]_ [_ ( 2nd ` v ) / y ]_ C ) ;;
	step 5 : wff = vex () |- z ∈ _V ;;
	step 6 : wff = vex () |- w ∈ _V ;;
	step 7 : wff = op2ndd (step 5, step 6) |- ( v = 〈 z , w 〉 → ( 2nd ` v ) = w ) ;;
	step 8 : wff = csbeq1d (step 7) |- ( v = 〈 z , w 〉 → [_ ( 2nd ` v ) / y ]_ C = [_ w / y ]_ C ) ;;
	step 9 : wff = csbeq2dv (step 8) |- ( v = 〈 z , w 〉 → [_ z / x ]_ [_ ( 2nd ` v ) / y ]_ C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 10 : wff = eqtrd (step 4, step 9) |- ( v = 〈 z , w 〉 → [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 11 : wff = eleq1d (step 10) |- ( v = 〈 z , w 〉 → ( [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C ∈ D ↔ [_ z / x ]_ [_ w / y ]_ C ∈ D ) ) ;;
	step 12 : wff = raliunxp (step 11) |- ( ∀ v ∈ ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C ∈ D ↔ ∀ z ∈ A ∀ w ∈ [_ z / x ]_ B [_ z / x ]_ [_ w / y ]_ C ∈ D ) ;;
	step 13 : wff = nfv () |- F/ z ( ( x ∈ A ∧ y ∈ B ) ∧ v = C ) ;;
	step 14 : wff = nfv () |- F/ w ( ( x ∈ A ∧ y ∈ B ) ∧ v = C ) ;;
	step 15 : wff = nfv () |- F/ x z ∈ A ;;
	step 16 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ B ;;
	step 17 : wff = nfel2 (step 16) |- F/ x w ∈ [_ z / x ]_ B ;;
	step 18 : wff = nfan (step 15, step 17) |- F/ x ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ;;
	step 19 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ [_ w / y ]_ C ;;
	step 20 : wff = nfeq2 (step 19) |- F/ x v = [_ z / x ]_ [_ w / y ]_ C ;;
	step 21 : wff = nfan (step 18, step 20) |- F/ x ( ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ∧ v = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 22 : wff = nfv () |- F/ y ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ;;
	step 23 : wff = nfcv () |- F/_ y z ;;
	step 24 : wff = nfcsb1v () |- F/_ y [_ w / y ]_ C ;;
	step 25 : wff = nfcsb (step 23, step 24) |- F/_ y [_ z / x ]_ [_ w / y ]_ C ;;
	step 26 : wff = nfeq2 (step 25) |- F/ y v = [_ z / x ]_ [_ w / y ]_ C ;;
	step 27 : wff = nfan (step 22, step 26) |- F/ y ( ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ∧ v = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 28 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 29 : wff = adantr (step 28) |- ( ( x = z ∧ y = w ) → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 30 : wff = eleq1 () |- ( y = w → ( y ∈ B ↔ w ∈ B ) ) ;;
	step 31 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 32 : wff = eleq2d (step 31) |- ( x = z → ( w ∈ B ↔ w ∈ [_ z / x ]_ B ) ) ;;
	step 33 : wff = sylan9bbr (step 30, step 32) |- ( ( x = z ∧ y = w ) → ( y ∈ B ↔ w ∈ [_ z / x ]_ B ) ) ;;
	step 34 : wff = anbi12d (step 29, step 33) |- ( ( x = z ∧ y = w ) → ( ( x ∈ A ∧ y ∈ B ) ↔ ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ) ) ;;
	step 35 : wff = csbeq1a () |- ( y = w → C = [_ w / y ]_ C ) ;;
	step 36 : wff = csbeq1a () |- ( x = z → [_ w / y ]_ C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 37 : wff = sylan9eqr (step 35, step 36) |- ( ( x = z ∧ y = w ) → C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 38 : wff = eqeq2d (step 37) |- ( ( x = z ∧ y = w ) → ( v = C ↔ v = [_ z / x ]_ [_ w / y ]_ C ) ) ;;
	step 39 : wff = anbi12d (step 34, step 38) |- ( ( x = z ∧ y = w ) → ( ( ( x ∈ A ∧ y ∈ B ) ∧ v = C ) ↔ ( ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ∧ v = [_ z / x ]_ [_ w / y ]_ C ) ) ) ;;
	step 40 : wff = cbvoprab12 (step 13, step 14, step 21, step 27, step 39) |- { 〈 〈 x , y 〉 , v 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ v = C ) } = { 〈 〈 z , w 〉 , v 〉 | ( ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ∧ v = [_ z / x ]_ [_ w / y ]_ C ) } ;;
	step 41 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , v 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ v = C ) } ;;
	step 42 : wff = df-mpt2 () |- ( z ∈ A , w ∈ [_ z / x ]_ B ↦ [_ z / x ]_ [_ w / y ]_ C ) = { 〈 〈 z , w 〉 , v 〉 | ( ( z ∈ A ∧ w ∈ [_ z / x ]_ B ) ∧ v = [_ z / x ]_ [_ w / y ]_ C ) } ;;
	step 43 : wff = 3eqtr4i (step 40, step 41, step 42) |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ A , w ∈ [_ z / x ]_ B ↦ [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 44 : wff = vex () |- z ∈ _V ;;
	step 45 : wff = vex () |- w ∈ _V ;;
	step 46 : wff = op1std (step 44, step 45) |- ( v = 〈 z , w 〉 → ( 1st ` v ) = z ) ;;
	step 47 : wff = csbeq1d (step 46) |- ( v = 〈 z , w 〉 → [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C = [_ z / x ]_ [_ ( 2nd ` v ) / y ]_ C ) ;;
	step 48 : wff = vex () |- z ∈ _V ;;
	step 49 : wff = vex () |- w ∈ _V ;;
	step 50 : wff = op2ndd (step 48, step 49) |- ( v = 〈 z , w 〉 → ( 2nd ` v ) = w ) ;;
	step 51 : wff = csbeq1d (step 50) |- ( v = 〈 z , w 〉 → [_ ( 2nd ` v ) / y ]_ C = [_ w / y ]_ C ) ;;
	step 52 : wff = csbeq2dv (step 51) |- ( v = 〈 z , w 〉 → [_ z / x ]_ [_ ( 2nd ` v ) / y ]_ C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 53 : wff = eqtrd (step 47, step 52) |- ( v = 〈 z , w 〉 → [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 54 : wff = mpt2mptx (step 53) |- ( v ∈ ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) ↦ [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C ) = ( z ∈ A , w ∈ [_ z / x ]_ B ↦ [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 55 : wff = 3eqtr4i (step 43, hyp 1, step 54) |- F = ( v ∈ ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) ↦ [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C ) ;;
	step 56 : wff = fmpt (step 55) |- ( ∀ v ∈ ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) [_ ( 1st ` v ) / x ]_ [_ ( 2nd ` v ) / y ]_ C ∈ D ↔ F : ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) ⟶ D ) ;;
	step 57 : wff = bitr3i (step 12, step 56) |- ( ∀ z ∈ A ∀ w ∈ [_ z / x ]_ B [_ z / x ]_ [_ w / y ]_ C ∈ D ↔ F : ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) ⟶ D ) ;;
	step 58 : wff = nfv () |- F/ z ∀ y ∈ B C ∈ D ;;
	step 59 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ B ;;
	step 60 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ [_ w / y ]_ C ;;
	step 61 : wff = nfel1 (step 60) |- F/ x [_ z / x ]_ [_ w / y ]_ C ∈ D ;;
	step 62 : wff = nfral (step 59, step 61) |- F/ x ∀ w ∈ [_ z / x ]_ B [_ z / x ]_ [_ w / y ]_ C ∈ D ;;
	step 63 : wff = nfv () |- F/ w C ∈ D ;;
	step 64 : wff = nfcsb1v () |- F/_ y [_ w / y ]_ C ;;
	step 65 : wff = nfel1 (step 64) |- F/ y [_ w / y ]_ C ∈ D ;;
	step 66 : wff = csbeq1a () |- ( y = w → C = [_ w / y ]_ C ) ;;
	step 67 : wff = eleq1d (step 66) |- ( y = w → ( C ∈ D ↔ [_ w / y ]_ C ∈ D ) ) ;;
	step 68 : wff = cbvral (step 63, step 65, step 67) |- ( ∀ y ∈ B C ∈ D ↔ ∀ w ∈ B [_ w / y ]_ C ∈ D ) ;;
	step 69 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 70 : wff = csbeq1a () |- ( x = z → [_ w / y ]_ C = [_ z / x ]_ [_ w / y ]_ C ) ;;
	step 71 : wff = eleq1d (step 70) |- ( x = z → ( [_ w / y ]_ C ∈ D ↔ [_ z / x ]_ [_ w / y ]_ C ∈ D ) ) ;;
	step 72 : wff = raleqbidv (step 69, step 71) |- ( x = z → ( ∀ w ∈ B [_ w / y ]_ C ∈ D ↔ ∀ w ∈ [_ z / x ]_ B [_ z / x ]_ [_ w / y ]_ C ∈ D ) ) ;;
	step 73 : wff = syl5bb (step 68, step 72) |- ( x = z → ( ∀ y ∈ B C ∈ D ↔ ∀ w ∈ [_ z / x ]_ B [_ z / x ]_ [_ w / y ]_ C ∈ D ) ) ;;
	step 74 : wff = cbvral (step 58, step 62, step 73) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ D ↔ ∀ z ∈ A ∀ w ∈ [_ z / x ]_ B [_ z / x ]_ [_ w / y ]_ C ∈ D ) ;;
	step 75 : wff = nfcv () |- F/_ z ( { x } × B ) ;;
	step 76 : wff = nfcv () |- F/_ x { z } ;;
	step 77 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ B ;;
	step 78 : wff = nfxp (step 76, step 77) |- F/_ x ( { z } × [_ z / x ]_ B ) ;;
	step 79 : wff = sneq () |- ( x = z → { x } = { z } ) ;;
	step 80 : wff = csbeq1a () |- ( x = z → B = [_ z / x ]_ B ) ;;
	step 81 : wff = xpeq12d (step 79, step 80) |- ( x = z → ( { x } × B ) = ( { z } × [_ z / x ]_ B ) ) ;;
	step 82 : wff = cbviun (step 75, step 78, step 81) |- ⋃_ x ∈ A ( { x } × B ) = ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) ;;
	step 83 : wff = feq2i (step 82) |- ( F : ⋃_ x ∈ A ( { x } × B ) ⟶ D ↔ F : ⋃_ z ∈ A ( { z } × [_ z / x ]_ B ) ⟶ D ) ;;
	step 84 : wff = 3bitr4i (step 57, step 74, step 83) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ D ↔ F : ⋃_ x ∈ A ( { x } × B ) ⟶ D ) ;;
	qed prop 1 = step 84 ;;
}

/* Functionality, domain and range of a class given by the "maps to"
       notation.  (Contributed by FL, 17-May-2010.) */

theorem fmpt2 (x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(A x y, B x y, D x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ∈ D ↔ F : ( A × B ) ⟶ D ) ;;
}

proof of fmpt2 {
	step 1 : wff = fmpt2x (hyp 1) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ D ↔ F : ⋃_ x ∈ A ( { x } × B ) ⟶ D ) ;;
	step 2 : wff = iunxpconst () |- ⋃_ x ∈ A ( { x } × B ) = ( A × B ) ;;
	step 3 : wff = feq2i (step 2) |- ( F : ⋃_ x ∈ A ( { x } × B ) ⟶ D ↔ F : ( A × B ) ⟶ D ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ D ↔ F : ( A × B ) ⟶ D ) ;;
	qed prop 1 = step 4 ;;
}

/* Functionality and domain of a class given by the "maps to" notation.
       (Contributed by FL, 17-May-2010.) */

theorem fnmpt2 (x : set, y : set, A : class, B : class, C : class, F : class, V : class) disjointed(A x y, B x y, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → F Fn ( A × B ) ) ;;
}

proof of fnmpt2 {
	step 1 : wff = elex () |- ( C ∈ V → C ∈ _V ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ y ∈ B C ∈ V → ∀ y ∈ B C ∈ _V ) ;;
	step 3 : wff = ralimi (step 2) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → ∀ x ∈ A ∀ y ∈ B C ∈ _V ) ;;
	step 4 : wff = fmpt2 (hyp 1) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ _V ↔ F : ( A × B ) ⟶ _V ) ;;
	step 5 : wff = dffn2 () |- ( F Fn ( A × B ) ↔ F : ( A × B ) ⟶ _V ) ;;
	step 6 : wff = bitr4i (step 4, step 5) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ _V ↔ F Fn ( A × B ) ) ;;
	step 7 : wff = sylib (step 3, step 6) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ V → F Fn ( A × B ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Functionality and domain of a class given by the "maps to" notation.
       (Contributed by FL, 17-May-2010.) */

theorem fnmpt2i (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(A x y, B x y, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- F Fn ( A × B ) ;;
}

proof of fnmpt2i {
	step 1 : wff = rgen2w (hyp 2) |- ∀ x ∈ A ∀ y ∈ B C ∈ _V ;;
	step 2 : wff = fnmpt2 (hyp 1) |- ( ∀ x ∈ A ∀ y ∈ B C ∈ _V → F Fn ( A × B ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- F Fn ( A × B ) ;;
	qed prop 1 = step 3 ;;
}

/* Domain of a class given by the "maps to" notation.  (Contributed by FL,
       17-May-2010.) */

theorem dmmpt2 (x : set, y : set, A : class, B : class, C : class, F : class) disjointed(A x y, B x y, x y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- dom F = ( A × B ) ;;
}

proof of dmmpt2 {
	step 1 : wff = fnmpt2i (hyp 1, hyp 2) |- F Fn ( A × B ) ;;
	step 2 : wff = fndm () |- ( F Fn ( A × B ) → dom F = ( A × B ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- dom F = ( A × B ) ;;
	qed prop 1 = step 3 ;;
}

/* Existence of an operation class abstraction (version for dependent
       domains).  (Contributed by Mario Carneiro, 30-Dec-2016.) */

theorem mpt2exxg (x : set, y : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(A x y, B y) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ ∀ x ∈ A B ∈ S ) → F ∈ _V ) ;;
}

proof of mpt2exxg {
	step 1 : wff = mpt2fun (hyp 1) |- Fun F ;;
	step 2 : wff = dmmpt2ssx (hyp 1) |- dom F ⊆ ⋃_ x ∈ A ( { x } × B ) ;;
	step 3 : wff = snex () |- { x } ∈ _V ;;
	step 4 : wff = xpexg () |- ( ( { x } ∈ _V ∧ B ∈ S ) → ( { x } × B ) ∈ _V ) ;;
	step 5 : wff = mpan (step 3, step 4) |- ( B ∈ S → ( { x } × B ) ∈ _V ) ;;
	step 6 : wff = ralimi (step 5) |- ( ∀ x ∈ A B ∈ S → ∀ x ∈ A ( { x } × B ) ∈ _V ) ;;
	step 7 : wff = iunexg () |- ( ( A ∈ R ∧ ∀ x ∈ A ( { x } × B ) ∈ _V ) → ⋃_ x ∈ A ( { x } × B ) ∈ _V ) ;;
	step 8 : wff = sylan2 (step 6, step 7) |- ( ( A ∈ R ∧ ∀ x ∈ A B ∈ S ) → ⋃_ x ∈ A ( { x } × B ) ∈ _V ) ;;
	step 9 : wff = ssexg () |- ( ( dom F ⊆ ⋃_ x ∈ A ( { x } × B ) ∧ ⋃_ x ∈ A ( { x } × B ) ∈ _V ) → dom F ∈ _V ) ;;
	step 10 : wff = sylancr (step 2, step 8, step 9) |- ( ( A ∈ R ∧ ∀ x ∈ A B ∈ S ) → dom F ∈ _V ) ;;
	step 11 : wff = funex () |- ( ( Fun F ∧ dom F ∈ _V ) → F ∈ _V ) ;;
	step 12 : wff = sylancr (step 1, step 10, step 11) |- ( ( A ∈ R ∧ ∀ x ∈ A B ∈ S ) → F ∈ _V ) ;;
	qed prop 1 = step 12 ;;
}

/* Existence of an operation class abstraction (special case).
       (Contributed by FL, 17-May-2010.)  (Revised by Mario Carneiro,
       1-Sep-2015.) */

theorem mpt2exg (x : set, y : set, A : class, B : class, C : class, R : class, S : class, F : class) disjointed(A x y, B y, x B) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ S ) → F ∈ _V ) ;;
}

proof of mpt2exg {
	step 1 : wff = elex () |- ( B ∈ S → B ∈ _V ) ;;
	step 2 : wff = elex () |- ( B ∈ _V → B ∈ _V ) ;;
	step 3 : wff = ralrimivw (step 2) |- ( B ∈ _V → ∀ x ∈ A B ∈ _V ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( B ∈ S → ∀ x ∈ A B ∈ _V ) ;;
	step 5 : wff = mpt2exxg (hyp 1) |- ( ( A ∈ R ∧ ∀ x ∈ A B ∈ _V ) → F ∈ _V ) ;;
	step 6 : wff = sylan2 (step 4, step 5) |- ( ( A ∈ R ∧ B ∈ S ) → F ∈ _V ) ;;
	qed prop 1 = step 6 ;;
}

/* If the domain of a function given by maps-to notation is a set, the
       function is a set.  (Contributed by NM, 12-Sep-2011.) */

theorem mpt2exga (x : set, y : set, A : class, B : class, C : class, V : class, W : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( x ∈ A , y ∈ B ↦ C ) ∈ _V ) ;;
}

proof of mpt2exga {
	step 1 : wff = eqid () |- ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ C ) ;;
	step 2 : wff = mpt2exg (step 1) |- ( ( A ∈ V ∧ B ∈ W ) → ( x ∈ A , y ∈ B ↦ C ) ∈ _V ) ;;
	qed prop 1 = step 2 ;;
}

/* If the domain of a function given by maps-to notation is a set, the
       function is a set.  (Contributed by Mario Carneiro, 20-Dec-2013.) */

theorem mpt2ex (x : set, y : set, A : class, B : class, C : class) disjointed(x y A, y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) ∈ _V ;;
}

proof of mpt2ex {
	step 1 : wff = rgenw (hyp 2) |- ∀ x ∈ A B ∈ _V ;;
	step 2 : wff = eqid () |- ( x ∈ A , y ∈ B ↦ C ) = ( x ∈ A , y ∈ B ↦ C ) ;;
	step 3 : wff = mpt2exxg (step 2) |- ( ( A ∈ _V ∧ ∀ x ∈ A B ∈ _V ) → ( x ∈ A , y ∈ B ↦ C ) ∈ _V ) ;;
	step 4 : wff = mp2an (hyp 1, step 1, step 3) |- ( x ∈ A , y ∈ B ↦ C ) ∈ _V ;;
	qed prop 1 = step 4 ;;
}

/* A mapping operation with empty domain.  (Contributed by Stefan O'Rear,
       29-Jan-2015.)  (Revised by Mario Carneiro, 15-May-2015.) */

theorem mpt20 (x : set, y : set, B : class, C : class) disjointed(w x z, w y z, w z B, w z C) {
	prop 1 : wff = |- ( x ∈ ∅ , y ∈ B ↦ C ) = ∅ ;;
}

proof of mpt20 {
	var z : set, w : set;;
	step 1 : wff = df-mpt2 () |- ( x ∈ ∅ , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = df-oprab () |- { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) } = { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) } ;;
	step 3 : wff = noel () |- ¬ x ∈ ∅ ;;
	step 4 : wff = simprll () |- ( ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) → x ∈ ∅ ) ;;
	step 5 : wff = mto (step 3, step 4) |- ¬ ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) ;;
	step 6 : wff = nex (step 5) |- ¬ ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) ;;
	step 7 : wff = nex (step 6) |- ¬ ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) ;;
	step 8 : wff = nex (step 7) |- ¬ ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) ;;
	step 9 : wff = abf (step 8) |- { w | ∃ x ∃ y ∃ z ( w = 〈 〈 x , y 〉 , z 〉 ∧ ( ( x ∈ ∅ ∧ y ∈ B ) ∧ z = C ) ) } = ∅ ;;
	step 10 : wff = 3eqtri (step 1, step 2, step 9) |- ( x ∈ ∅ , y ∈ B ↦ C ) = ∅ ;;
	qed prop 1 = step 10 ;;
}

/* If all the values of the mapping are subsets of a class ` X ` , then so
       is any evaluation of the mapping.  (Contributed by Mario Carneiro,
       24-Dec-2016.) */

theorem ovmptss (x : set, y : set, A : class, B : class, C : class, E : class, F : class, G : class, X : class) disjointed(u v x y z A, u v y z B, u v z C, u v x y z X) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B C ⊆ X → ( E F G ) ⊆ X ) ;;
}

proof of ovmptss {
	var z : set, v : set, u : set;;
	step 1 : wff = mpt2mptsx () |- ( x ∈ A , y ∈ B ↦ C ) = ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- F = ( z ∈ ⋃_ x ∈ A ( { x } × B ) ↦ [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 3 : wff = fvmptss (step 2) |- ( ∀ z ∈ ⋃_ x ∈ A ( { x } × B ) [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ⊆ X → ( F ` 〈 E , G 〉 ) ⊆ X ) ;;
	step 4 : wff = vex () |- u ∈ _V ;;
	step 5 : wff = vex () |- v ∈ _V ;;
	step 6 : wff = op1std (step 4, step 5) |- ( z = 〈 u , v 〉 → ( 1st ` z ) = u ) ;;
	step 7 : wff = csbeq1d (step 6) |- ( z = 〈 u , v 〉 → [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C = [_ u / x ]_ [_ ( 2nd ` z ) / y ]_ C ) ;;
	step 8 : wff = vex () |- u ∈ _V ;;
	step 9 : wff = vex () |- v ∈ _V ;;
	step 10 : wff = op2ndd (step 8, step 9) |- ( z = 〈 u , v 〉 → ( 2nd ` z ) = v ) ;;
	step 11 : wff = csbeq1d (step 10) |- ( z = 〈 u , v 〉 → [_ ( 2nd ` z ) / y ]_ C = [_ v / y ]_ C ) ;;
	step 12 : wff = csbeq2dv (step 11) |- ( z = 〈 u , v 〉 → [_ u / x ]_ [_ ( 2nd ` z ) / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 13 : wff = eqtrd (step 7, step 12) |- ( z = 〈 u , v 〉 → [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 14 : wff = sseq1d (step 13) |- ( z = 〈 u , v 〉 → ( [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ⊆ X ↔ [_ u / x ]_ [_ v / y ]_ C ⊆ X ) ) ;;
	step 15 : wff = raliunxp (step 14) |- ( ∀ z ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ⊆ X ↔ ∀ u ∈ A ∀ v ∈ [_ u / x ]_ B [_ u / x ]_ [_ v / y ]_ C ⊆ X ) ;;
	step 16 : wff = nfcv () |- F/_ u ( { x } × B ) ;;
	step 17 : wff = nfcv () |- F/_ x { u } ;;
	step 18 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ B ;;
	step 19 : wff = nfxp (step 17, step 18) |- F/_ x ( { u } × [_ u / x ]_ B ) ;;
	step 20 : wff = sneq () |- ( x = u → { x } = { u } ) ;;
	step 21 : wff = csbeq1a () |- ( x = u → B = [_ u / x ]_ B ) ;;
	step 22 : wff = xpeq12d (step 20, step 21) |- ( x = u → ( { x } × B ) = ( { u } × [_ u / x ]_ B ) ) ;;
	step 23 : wff = cbviun (step 16, step 19, step 22) |- ⋃_ x ∈ A ( { x } × B ) = ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) ;;
	step 24 : wff = raleqi (step 23) |- ( ∀ z ∈ ⋃_ x ∈ A ( { x } × B ) [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ⊆ X ↔ ∀ z ∈ ⋃_ u ∈ A ( { u } × [_ u / x ]_ B ) [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ⊆ X ) ;;
	step 25 : wff = nfv () |- F/ u ∀ y ∈ B C ⊆ X ;;
	step 26 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ B ;;
	step 27 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ [_ v / y ]_ C ;;
	step 28 : wff = nfcv () |- F/_ x X ;;
	step 29 : wff = nfss (step 27, step 28) |- F/ x [_ u / x ]_ [_ v / y ]_ C ⊆ X ;;
	step 30 : wff = nfral (step 26, step 29) |- F/ x ∀ v ∈ [_ u / x ]_ B [_ u / x ]_ [_ v / y ]_ C ⊆ X ;;
	step 31 : wff = nfv () |- F/ v C ⊆ X ;;
	step 32 : wff = nfcsb1v () |- F/_ y [_ v / y ]_ C ;;
	step 33 : wff = nfcv () |- F/_ y X ;;
	step 34 : wff = nfss (step 32, step 33) |- F/ y [_ v / y ]_ C ⊆ X ;;
	step 35 : wff = csbeq1a () |- ( y = v → C = [_ v / y ]_ C ) ;;
	step 36 : wff = sseq1d (step 35) |- ( y = v → ( C ⊆ X ↔ [_ v / y ]_ C ⊆ X ) ) ;;
	step 37 : wff = cbvral (step 31, step 34, step 36) |- ( ∀ y ∈ B C ⊆ X ↔ ∀ v ∈ B [_ v / y ]_ C ⊆ X ) ;;
	step 38 : wff = csbeq1a () |- ( x = u → B = [_ u / x ]_ B ) ;;
	step 39 : wff = csbeq1a () |- ( x = u → [_ v / y ]_ C = [_ u / x ]_ [_ v / y ]_ C ) ;;
	step 40 : wff = sseq1d (step 39) |- ( x = u → ( [_ v / y ]_ C ⊆ X ↔ [_ u / x ]_ [_ v / y ]_ C ⊆ X ) ) ;;
	step 41 : wff = raleqbidv (step 38, step 40) |- ( x = u → ( ∀ v ∈ B [_ v / y ]_ C ⊆ X ↔ ∀ v ∈ [_ u / x ]_ B [_ u / x ]_ [_ v / y ]_ C ⊆ X ) ) ;;
	step 42 : wff = syl5bb (step 37, step 41) |- ( x = u → ( ∀ y ∈ B C ⊆ X ↔ ∀ v ∈ [_ u / x ]_ B [_ u / x ]_ [_ v / y ]_ C ⊆ X ) ) ;;
	step 43 : wff = cbvral (step 25, step 30, step 42) |- ( ∀ x ∈ A ∀ y ∈ B C ⊆ X ↔ ∀ u ∈ A ∀ v ∈ [_ u / x ]_ B [_ u / x ]_ [_ v / y ]_ C ⊆ X ) ;;
	step 44 : wff = 3bitr4ri (step 15, step 24, step 43) |- ( ∀ x ∈ A ∀ y ∈ B C ⊆ X ↔ ∀ z ∈ ⋃_ x ∈ A ( { x } × B ) [_ ( 1st ` z ) / x ]_ [_ ( 2nd ` z ) / y ]_ C ⊆ X ) ;;
	step 45 : wff = df-ov () |- ( E F G ) = ( F ` 〈 E , G 〉 ) ;;
	step 46 : wff = sseq1i (step 45) |- ( ( E F G ) ⊆ X ↔ ( F ` 〈 E , G 〉 ) ⊆ X ) ;;
	step 47 : wff = 3imtr4i (step 3, step 44, step 46) |- ( ∀ x ∈ A ∀ y ∈ B C ⊆ X → ( E F G ) ⊆ X ) ;;
	qed prop 1 = step 47 ;;
}

/* Any function to sets of ordered pairs produces a relation on function
       value unconditionally.  (Contributed by Mario Carneiro, 9-Feb-2015.) */

theorem relmpt2opab (ph : wff, x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class, F : class) disjointed(w x y z, y B, x y A) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ { 〈 z , w 〉 | ph } ) ;;
	-----------------------
	prop 1 : wff = |- Rel ( C F D ) ;;
}

proof of relmpt2opab {
	step 1 : wff = relopab () |- Rel { 〈 z , w 〉 | ph } ;;
	step 2 : wff = df-rel () |- ( Rel { 〈 z , w 〉 | ph } ↔ { 〈 z , w 〉 | ph } ⊆ ( _V × _V ) ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- { 〈 z , w 〉 | ph } ⊆ ( _V × _V ) ;;
	step 4 : wff = rgenw (step 3) |- ∀ y ∈ B { 〈 z , w 〉 | ph } ⊆ ( _V × _V ) ;;
	step 5 : wff = rgenw (step 4) |- ∀ x ∈ A ∀ y ∈ B { 〈 z , w 〉 | ph } ⊆ ( _V × _V ) ;;
	step 6 : wff = ovmptss (hyp 1) |- ( ∀ x ∈ A ∀ y ∈ B { 〈 z , w 〉 | ph } ⊆ ( _V × _V ) → ( C F D ) ⊆ ( _V × _V ) ) ;;
	step 7 : wff = ax-mp (step 5, step 6) |- ( C F D ) ⊆ ( _V × _V ) ;;
	step 8 : wff = df-rel () |- ( Rel ( C F D ) ↔ ( C F D ) ⊆ ( _V × _V ) ) ;;
	step 9 : wff = mpbir (step 7, step 8) |- Rel ( C F D ) ;;
	qed prop 1 = step 9 ;;
}

/* Composition of two functions.  Variation of ~ fmptco when the second
       function has two arguments.  (Contributed by Mario Carneiro,
       8-Feb-2015.) */

theorem fmpt2co (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, T : class, F : class, G : class) disjointed(u v w x y B, u w x y z C, x y ph, u v w x y S, u v w x y A, u v w z R, z T) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → R ∈ C ) ;;
	hyp 2 : wff = |- ( ph → F = ( x ∈ A , y ∈ B ↦ R ) ) ;;
	hyp 3 : wff = |- ( ph → G = ( z ∈ C ↦ S ) ) ;;
	hyp 4 : wff = |- ( z = R → S = T ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( G ∘ F ) = ( x ∈ A , y ∈ B ↦ T ) ) ;;
}

proof of fmpt2co {
	var w : set, v : set, u : set;;
	step 1 : wff = ralrimivva (hyp 1) |- ( ph → ∀ x ∈ A ∀ y ∈ B R ∈ C ) ;;
	step 2 : wff = eqid () |- ( x ∈ A , y ∈ B ↦ R ) = ( x ∈ A , y ∈ B ↦ R ) ;;
	step 3 : wff = fmpt2 (step 2) |- ( ∀ x ∈ A ∀ y ∈ B R ∈ C ↔ ( x ∈ A , y ∈ B ↦ R ) : ( A × B ) ⟶ C ) ;;
	step 4 : wff = sylib (step 1, step 3) |- ( ph → ( x ∈ A , y ∈ B ↦ R ) : ( A × B ) ⟶ C ) ;;
	step 5 : wff = nfcv () |- F/_ u R ;;
	step 6 : wff = nfcv () |- F/_ v R ;;
	step 7 : wff = nfcv () |- F/_ x v ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ R ;;
	step 9 : wff = nfcsb (step 7, step 8) |- F/_ x [_ v / y ]_ [_ u / x ]_ R ;;
	step 10 : wff = nfcsb1v () |- F/_ y [_ v / y ]_ [_ u / x ]_ R ;;
	step 11 : wff = csbeq1a () |- ( x = u → R = [_ u / x ]_ R ) ;;
	step 12 : wff = csbeq1a () |- ( y = v → [_ u / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 13 : wff = sylan9eq (step 11, step 12) |- ( ( x = u ∧ y = v ) → R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 14 : wff = cbvmpt2 (step 5, step 6, step 9, step 10, step 13) |- ( x ∈ A , y ∈ B ↦ R ) = ( u ∈ A , v ∈ B ↦ [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 15 : wff = vex () |- u ∈ _V ;;
	step 16 : wff = vex () |- v ∈ _V ;;
	step 17 : wff = op2ndd (step 15, step 16) |- ( w = 〈 u , v 〉 → ( 2nd ` w ) = v ) ;;
	step 18 : wff = csbeq1d (step 17) |- ( w = 〈 u , v 〉 → [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ ( 1st ` w ) / x ]_ R ) ;;
	step 19 : wff = vex () |- u ∈ _V ;;
	step 20 : wff = vex () |- v ∈ _V ;;
	step 21 : wff = op1std (step 19, step 20) |- ( w = 〈 u , v 〉 → ( 1st ` w ) = u ) ;;
	step 22 : wff = csbeq1d (step 21) |- ( w = 〈 u , v 〉 → [_ ( 1st ` w ) / x ]_ R = [_ u / x ]_ R ) ;;
	step 23 : wff = csbeq2dv (step 22) |- ( w = 〈 u , v 〉 → [_ v / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 24 : wff = eqtrd (step 18, step 23) |- ( w = 〈 u , v 〉 → [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 25 : wff = mpt2mpt (step 24) |- ( w ∈ ( A × B ) ↦ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ) = ( u ∈ A , v ∈ B ↦ [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 26 : wff = eqtr4i (step 14, step 25) |- ( x ∈ A , y ∈ B ↦ R ) = ( w ∈ ( A × B ) ↦ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ) ;;
	step 27 : wff = fmpt (step 26) |- ( ∀ w ∈ ( A × B ) [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ∈ C ↔ ( x ∈ A , y ∈ B ↦ R ) : ( A × B ) ⟶ C ) ;;
	step 28 : wff = sylibr (step 4, step 27) |- ( ph → ∀ w ∈ ( A × B ) [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ∈ C ) ;;
	step 29 : wff = nfcv () |- F/_ u R ;;
	step 30 : wff = nfcv () |- F/_ v R ;;
	step 31 : wff = nfcv () |- F/_ x v ;;
	step 32 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ R ;;
	step 33 : wff = nfcsb (step 31, step 32) |- F/_ x [_ v / y ]_ [_ u / x ]_ R ;;
	step 34 : wff = nfcsb1v () |- F/_ y [_ v / y ]_ [_ u / x ]_ R ;;
	step 35 : wff = csbeq1a () |- ( x = u → R = [_ u / x ]_ R ) ;;
	step 36 : wff = csbeq1a () |- ( y = v → [_ u / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 37 : wff = sylan9eq (step 35, step 36) |- ( ( x = u ∧ y = v ) → R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 38 : wff = cbvmpt2 (step 29, step 30, step 33, step 34, step 37) |- ( x ∈ A , y ∈ B ↦ R ) = ( u ∈ A , v ∈ B ↦ [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 39 : wff = vex () |- u ∈ _V ;;
	step 40 : wff = vex () |- v ∈ _V ;;
	step 41 : wff = op2ndd (step 39, step 40) |- ( w = 〈 u , v 〉 → ( 2nd ` w ) = v ) ;;
	step 42 : wff = csbeq1d (step 41) |- ( w = 〈 u , v 〉 → [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ ( 1st ` w ) / x ]_ R ) ;;
	step 43 : wff = vex () |- u ∈ _V ;;
	step 44 : wff = vex () |- v ∈ _V ;;
	step 45 : wff = op1std (step 43, step 44) |- ( w = 〈 u , v 〉 → ( 1st ` w ) = u ) ;;
	step 46 : wff = csbeq1d (step 45) |- ( w = 〈 u , v 〉 → [_ ( 1st ` w ) / x ]_ R = [_ u / x ]_ R ) ;;
	step 47 : wff = csbeq2dv (step 46) |- ( w = 〈 u , v 〉 → [_ v / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 48 : wff = eqtrd (step 42, step 47) |- ( w = 〈 u , v 〉 → [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 49 : wff = mpt2mpt (step 48) |- ( w ∈ ( A × B ) ↦ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ) = ( u ∈ A , v ∈ B ↦ [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 50 : wff = eqtr4i (step 38, step 49) |- ( x ∈ A , y ∈ B ↦ R ) = ( w ∈ ( A × B ) ↦ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ) ;;
	step 51 : wff = syl6eq (hyp 2, step 50) |- ( ph → F = ( w ∈ ( A × B ) ↦ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R ) ) ;;
	step 52 : wff = fmptcos (step 28, step 51, hyp 3) |- ( ph → ( G ∘ F ) = ( w ∈ ( A × B ) ↦ [_ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R / z ]_ S ) ) ;;
	step 53 : wff = vex () |- u ∈ _V ;;
	step 54 : wff = vex () |- v ∈ _V ;;
	step 55 : wff = op2ndd (step 53, step 54) |- ( w = 〈 u , v 〉 → ( 2nd ` w ) = v ) ;;
	step 56 : wff = csbeq1d (step 55) |- ( w = 〈 u , v 〉 → [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ ( 1st ` w ) / x ]_ R ) ;;
	step 57 : wff = vex () |- u ∈ _V ;;
	step 58 : wff = vex () |- v ∈ _V ;;
	step 59 : wff = op1std (step 57, step 58) |- ( w = 〈 u , v 〉 → ( 1st ` w ) = u ) ;;
	step 60 : wff = csbeq1d (step 59) |- ( w = 〈 u , v 〉 → [_ ( 1st ` w ) / x ]_ R = [_ u / x ]_ R ) ;;
	step 61 : wff = csbeq2dv (step 60) |- ( w = 〈 u , v 〉 → [_ v / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 62 : wff = eqtrd (step 56, step 61) |- ( w = 〈 u , v 〉 → [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 63 : wff = csbeq1d (step 62) |- ( w = 〈 u , v 〉 → [_ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R / z ]_ S = [_ [_ v / y ]_ [_ u / x ]_ R / z ]_ S ) ;;
	step 64 : wff = mpt2mpt (step 63) |- ( w ∈ ( A × B ) ↦ [_ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R / z ]_ S ) = ( u ∈ A , v ∈ B ↦ [_ [_ v / y ]_ [_ u / x ]_ R / z ]_ S ) ;;
	step 65 : wff = nfcv () |- F/_ u [_ R / z ]_ S ;;
	step 66 : wff = nfcv () |- F/_ v [_ R / z ]_ S ;;
	step 67 : wff = nfcv () |- F/_ x v ;;
	step 68 : wff = nfcsb1v () |- F/_ x [_ u / x ]_ R ;;
	step 69 : wff = nfcsb (step 67, step 68) |- F/_ x [_ v / y ]_ [_ u / x ]_ R ;;
	step 70 : wff = nfcv () |- F/_ x S ;;
	step 71 : wff = nfcsb (step 69, step 70) |- F/_ x [_ [_ v / y ]_ [_ u / x ]_ R / z ]_ S ;;
	step 72 : wff = nfcsb1v () |- F/_ y [_ v / y ]_ [_ u / x ]_ R ;;
	step 73 : wff = nfcv () |- F/_ y S ;;
	step 74 : wff = nfcsb (step 72, step 73) |- F/_ y [_ [_ v / y ]_ [_ u / x ]_ R / z ]_ S ;;
	step 75 : wff = csbeq1a () |- ( x = u → R = [_ u / x ]_ R ) ;;
	step 76 : wff = csbeq1a () |- ( y = v → [_ u / x ]_ R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 77 : wff = sylan9eq (step 75, step 76) |- ( ( x = u ∧ y = v ) → R = [_ v / y ]_ [_ u / x ]_ R ) ;;
	step 78 : wff = csbeq1d (step 77) |- ( ( x = u ∧ y = v ) → [_ R / z ]_ S = [_ [_ v / y ]_ [_ u / x ]_ R / z ]_ S ) ;;
	step 79 : wff = cbvmpt2 (step 65, step 66, step 71, step 74, step 78) |- ( x ∈ A , y ∈ B ↦ [_ R / z ]_ S ) = ( u ∈ A , v ∈ B ↦ [_ [_ v / y ]_ [_ u / x ]_ R / z ]_ S ) ;;
	step 80 : wff = eqtr4i (step 64, step 79) |- ( w ∈ ( A × B ) ↦ [_ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R / z ]_ S ) = ( x ∈ A , y ∈ B ↦ [_ R / z ]_ S ) ;;
	step 81 : wff = 3impb (hyp 1) |- ( ( ph ∧ x ∈ A ∧ y ∈ B ) → R ∈ C ) ;;
	step 82 : wff = nfcvd () |- ( R ∈ C → F/_ z T ) ;;
	step 83 : wff = csbiegf (step 82, hyp 4) |- ( R ∈ C → [_ R / z ]_ S = T ) ;;
	step 84 : wff = syl (step 81, step 83) |- ( ( ph ∧ x ∈ A ∧ y ∈ B ) → [_ R / z ]_ S = T ) ;;
	step 85 : wff = mpt2eq3dva (step 84) |- ( ph → ( x ∈ A , y ∈ B ↦ [_ R / z ]_ S ) = ( x ∈ A , y ∈ B ↦ T ) ) ;;
	step 86 : wff = syl5eq (step 80, step 85) |- ( ph → ( w ∈ ( A × B ) ↦ [_ [_ ( 2nd ` w ) / y ]_ [_ ( 1st ` w ) / x ]_ R / z ]_ S ) = ( x ∈ A , y ∈ B ↦ T ) ) ;;
	step 87 : wff = eqtrd (step 52, step 86) |- ( ph → ( G ∘ F ) = ( x ∈ A , y ∈ B ↦ T ) ) ;;
	qed prop 1 = step 87 ;;
}

/* Composition of a function with an operator abstraction.  (Contributed by
       Jeff Madsen, 2-Sep-2009.)  (Proof shortened by Mario Carneiro,
       26-Sep-2015.) */

theorem oprabco (x : set, y : set, A : class, B : class, C : class, D : class, F : class, G : class, H : class) disjointed(x y z A, x y z B, x y z D, x y z H, z C) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → C ∈ D ) ;;
	hyp 2 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	hyp 3 : wff = |- G = ( x ∈ A , y ∈ B ↦ ( H ` C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( H Fn D → G = ( H ∘ F ) ) ;;
}

proof of oprabco {
	var z : set;;
	step 1 : wff = adantl (hyp 1) |- ( ( H Fn D ∧ ( x ∈ A ∧ y ∈ B ) ) → C ∈ D ) ;;
	step 2 : wff = a1i (hyp 2) |- ( H Fn D → F = ( x ∈ A , y ∈ B ↦ C ) ) ;;
	step 3 : wff = dffn5 () |- ( H Fn D ↔ H = ( z ∈ D ↦ ( H ` z ) ) ) ;;
	step 4 : wff = biimpi (step 3) |- ( H Fn D → H = ( z ∈ D ↦ ( H ` z ) ) ) ;;
	step 5 : wff = fveq2 () |- ( z = C → ( H ` z ) = ( H ` C ) ) ;;
	step 6 : wff = fmpt2co (step 1, step 2, step 4, step 5) |- ( H Fn D → ( H ∘ F ) = ( x ∈ A , y ∈ B ↦ ( H ` C ) ) ) ;;
	step 7 : wff = syl6reqr (step 6, hyp 3) |- ( H Fn D → G = ( H ∘ F ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Composition of operator abstractions.  (Contributed by Jeff Madsen,
       2-Sep-2009.)  (Revised by David Abernethy, 23-Apr-2013.) */

theorem oprab2co (x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class, M : class) disjointed(x y A, x y B, x y M, x y R, x y S) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → C ∈ R ) ;;
	hyp 2 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → D ∈ S ) ;;
	hyp 3 : wff = |- F = ( x ∈ A , y ∈ B ↦ 〈 C , D 〉 ) ;;
	hyp 4 : wff = |- G = ( x ∈ A , y ∈ B ↦ ( C M D ) ) ;;
	-----------------------
	prop 1 : wff = |- ( M Fn ( R × S ) → G = ( M ∘ F ) ) ;;
}

proof of oprab2co {
	step 1 : wff = opelxpi () |- ( ( C ∈ R ∧ D ∈ S ) → 〈 C , D 〉 ∈ ( R × S ) ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ( x ∈ A ∧ y ∈ B ) → 〈 C , D 〉 ∈ ( R × S ) ) ;;
	step 3 : wff = df-ov () |- ( C M D ) = ( M ` 〈 C , D 〉 ) ;;
	step 4 : wff = a1i (step 3) |- ( ( x ∈ A ∧ y ∈ B ) → ( C M D ) = ( M ` 〈 C , D 〉 ) ) ;;
	step 5 : wff = mpt2eq3ia (step 4) |- ( x ∈ A , y ∈ B ↦ ( C M D ) ) = ( x ∈ A , y ∈ B ↦ ( M ` 〈 C , D 〉 ) ) ;;
	step 6 : wff = eqtri (hyp 4, step 5) |- G = ( x ∈ A , y ∈ B ↦ ( M ` 〈 C , D 〉 ) ) ;;
	step 7 : wff = oprabco (step 2, hyp 3, step 6) |- ( M Fn ( R × S ) → G = ( M ∘ F ) ) ;;
	qed prop 1 = step 7 ;;
}

/* An alternate possible definition of the ` 1st ` function.  (Contributed
       by NM, 14-Oct-2004.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem df1st2 (x : set, y : set, z : set) disjointed(w x y z) {
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | z = x } = ( 1st ↾ ( _V × _V ) ) ;;
}

proof of df1st2 {
	var w : set;;
	step 1 : wff = fo1st () |- 1st : _V ↠ _V ;;
	step 2 : wff = fofn () |- ( 1st : _V ↠ _V → 1st Fn _V ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- 1st Fn _V ;;
	step 4 : wff = dffn5 () |- ( 1st Fn _V ↔ 1st = ( w ∈ _V ↦ ( 1st ` w ) ) ) ;;
	step 5 : wff = mpbi (step 3, step 4) |- 1st = ( w ∈ _V ↦ ( 1st ` w ) ) ;;
	step 6 : wff = mptv () |- ( w ∈ _V ↦ ( 1st ` w ) ) = { 〈 w , z 〉 | z = ( 1st ` w ) } ;;
	step 7 : wff = eqtri (step 5, step 6) |- 1st = { 〈 w , z 〉 | z = ( 1st ` w ) } ;;
	step 8 : wff = reseq1i (step 7) |- ( 1st ↾ ( _V × _V ) ) = ( { 〈 w , z 〉 | z = ( 1st ` w ) } ↾ ( _V × _V ) ) ;;
	step 9 : wff = resopab () |- ( { 〈 w , z 〉 | z = ( 1st ` w ) } ↾ ( _V × _V ) ) = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ z = ( 1st ` w ) ) } ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = op1std (step 10, step 11) |- ( w = 〈 x , y 〉 → ( 1st ` w ) = x ) ;;
	step 13 : wff = eqeq2d (step 12) |- ( w = 〈 x , y 〉 → ( z = ( 1st ` w ) ↔ z = x ) ) ;;
	step 14 : wff = dfoprab3 (step 13) |- { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ z = ( 1st ` w ) ) } = { 〈 〈 x , y 〉 , z 〉 | z = x } ;;
	step 15 : wff = 3eqtrri (step 8, step 9, step 14) |- { 〈 〈 x , y 〉 , z 〉 | z = x } = ( 1st ↾ ( _V × _V ) ) ;;
	qed prop 1 = step 15 ;;
}

/* An alternate possible definition of the ` 2nd ` function.  (Contributed
       by NM, 10-Aug-2006.)  (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem df2nd2 (x : set, y : set, z : set) disjointed(w x y z) {
	prop 1 : wff = |- { 〈 〈 x , y 〉 , z 〉 | z = y } = ( 2nd ↾ ( _V × _V ) ) ;;
}

proof of df2nd2 {
	var w : set;;
	step 1 : wff = fo2nd () |- 2nd : _V ↠ _V ;;
	step 2 : wff = fofn () |- ( 2nd : _V ↠ _V → 2nd Fn _V ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- 2nd Fn _V ;;
	step 4 : wff = dffn5 () |- ( 2nd Fn _V ↔ 2nd = ( w ∈ _V ↦ ( 2nd ` w ) ) ) ;;
	step 5 : wff = mpbi (step 3, step 4) |- 2nd = ( w ∈ _V ↦ ( 2nd ` w ) ) ;;
	step 6 : wff = mptv () |- ( w ∈ _V ↦ ( 2nd ` w ) ) = { 〈 w , z 〉 | z = ( 2nd ` w ) } ;;
	step 7 : wff = eqtri (step 5, step 6) |- 2nd = { 〈 w , z 〉 | z = ( 2nd ` w ) } ;;
	step 8 : wff = reseq1i (step 7) |- ( 2nd ↾ ( _V × _V ) ) = ( { 〈 w , z 〉 | z = ( 2nd ` w ) } ↾ ( _V × _V ) ) ;;
	step 9 : wff = resopab () |- ( { 〈 w , z 〉 | z = ( 2nd ` w ) } ↾ ( _V × _V ) ) = { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ z = ( 2nd ` w ) ) } ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = vex () |- y ∈ _V ;;
	step 12 : wff = op2ndd (step 10, step 11) |- ( w = 〈 x , y 〉 → ( 2nd ` w ) = y ) ;;
	step 13 : wff = eqeq2d (step 12) |- ( w = 〈 x , y 〉 → ( z = ( 2nd ` w ) ↔ z = y ) ) ;;
	step 14 : wff = dfoprab3 (step 13) |- { 〈 w , z 〉 | ( w ∈ ( _V × _V ) ∧ z = ( 2nd ` w ) ) } = { 〈 〈 x , y 〉 , z 〉 | z = y } ;;
	step 15 : wff = 3eqtrri (step 8, step 9, step 14) |- { 〈 〈 x , y 〉 , z 〉 | z = y } = ( 2nd ↾ ( _V × _V ) ) ;;
	qed prop 1 = step 15 ;;
}

/* The mapping of a restriction of the ` 1st ` function to a constant
       function.  (Contributed by NM, 14-Dec-2008.) */

theorem 1stconst (A : class, B : class, V : class) disjointed(x y A, x y B, x y V) {
	prop 1 : wff = |- ( B ∈ V → ( 1st ↾ ( A × { B } ) ) : ( A × { B } ) ⤖ A ) ;;
}

proof of 1stconst {
	var x : set, y : set;;
	step 1 : wff = snnzg () |- ( B ∈ V → { B } ≠ ∅ ) ;;
	step 2 : wff = fo1stres () |- ( { B } ≠ ∅ → ( 1st ↾ ( A × { B } ) ) : ( A × { B } ) ↠ A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( B ∈ V → ( 1st ↾ ( A × { B } ) ) : ( A × { B } ) ↠ A ) ;;
	step 4 : wff = moeq () |- ∃* x x = 〈 y , B 〉 ;;
	step 5 : wff = moani (step 4) |- ∃* x ( y ∈ A ∧ x = 〈 y , B 〉 ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = brres (step 6) |- ( x ( 1st ↾ ( A × { B } ) ) y ↔ ( x 1st y ∧ x ∈ ( A × { B } ) ) ) ;;
	step 8 : wff = fo1st () |- 1st : _V ↠ _V ;;
	step 9 : wff = fofn () |- ( 1st : _V ↠ _V → 1st Fn _V ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- 1st Fn _V ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = fnbrfvb () |- ( ( 1st Fn _V ∧ x ∈ _V ) → ( ( 1st ` x ) = y ↔ x 1st y ) ) ;;
	step 13 : wff = mp2an (step 10, step 11, step 12) |- ( ( 1st ` x ) = y ↔ x 1st y ) ;;
	step 14 : wff = anbi1i (step 13) |- ( ( ( 1st ` x ) = y ∧ x ∈ ( A × { B } ) ) ↔ ( x 1st y ∧ x ∈ ( A × { B } ) ) ) ;;
	step 15 : wff = elxp7 () |- ( x ∈ ( A × { B } ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ { B } ) ) ) ;;
	step 16 : wff = eleq1 () |- ( ( 1st ` x ) = y → ( ( 1st ` x ) ∈ A ↔ y ∈ A ) ) ;;
	step 17 : wff = biimpa (step 16) |- ( ( ( 1st ` x ) = y ∧ ( 1st ` x ) ∈ A ) → y ∈ A ) ;;
	step 18 : wff = adantrr (step 17) |- ( ( ( 1st ` x ) = y ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ { B } ) ) → y ∈ A ) ;;
	step 19 : wff = adantrl (step 18) |- ( ( ( 1st ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ { B } ) ) ) → y ∈ A ) ;;
	step 20 : wff = elsni () |- ( ( 2nd ` x ) ∈ { B } → ( 2nd ` x ) = B ) ;;
	step 21 : wff = eqopi () |- ( ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) = y ∧ ( 2nd ` x ) = B ) ) → x = 〈 y , B 〉 ) ;;
	step 22 : wff = an12s (step 21) |- ( ( ( 1st ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( 2nd ` x ) = B ) ) → x = 〈 y , B 〉 ) ;;
	step 23 : wff = sylanr2 (step 20, step 22) |- ( ( ( 1st ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( 2nd ` x ) ∈ { B } ) ) → x = 〈 y , B 〉 ) ;;
	step 24 : wff = adantrrl (step 23) |- ( ( ( 1st ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ { B } ) ) ) → x = 〈 y , B 〉 ) ;;
	step 25 : wff = jca (step 19, step 24) |- ( ( ( 1st ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ A ∧ ( 2nd ` x ) ∈ { B } ) ) ) → ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ;;
	step 26 : wff = sylan2b (step 15, step 25) |- ( ( ( 1st ` x ) = y ∧ x ∈ ( A × { B } ) ) → ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ;;
	step 27 : wff = adantl (step 26) |- ( ( B ∈ V ∧ ( ( 1st ` x ) = y ∧ x ∈ ( A × { B } ) ) ) → ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ;;
	step 28 : wff = simprr () |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → x = 〈 y , B 〉 ) ;;
	step 29 : wff = fveq2d (step 28) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → ( 1st ` x ) = ( 1st ` 〈 y , B 〉 ) ) ;;
	step 30 : wff = simprl () |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → y ∈ A ) ;;
	step 31 : wff = simpl () |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → B ∈ V ) ;;
	step 32 : wff = op1stg () |- ( ( y ∈ A ∧ B ∈ V ) → ( 1st ` 〈 y , B 〉 ) = y ) ;;
	step 33 : wff = syl2anc (step 30, step 31, step 32) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → ( 1st ` 〈 y , B 〉 ) = y ) ;;
	step 34 : wff = eqtrd (step 29, step 33) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → ( 1st ` x ) = y ) ;;
	step 35 : wff = simprr () |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → x = 〈 y , B 〉 ) ;;
	step 36 : wff = simprl () |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → y ∈ A ) ;;
	step 37 : wff = snidg () |- ( B ∈ V → B ∈ { B } ) ;;
	step 38 : wff = adantr (step 37) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → B ∈ { B } ) ;;
	step 39 : wff = opelxpi () |- ( ( y ∈ A ∧ B ∈ { B } ) → 〈 y , B 〉 ∈ ( A × { B } ) ) ;;
	step 40 : wff = syl2anc (step 36, step 38, step 39) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → 〈 y , B 〉 ∈ ( A × { B } ) ) ;;
	step 41 : wff = eqeltrd (step 35, step 40) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → x ∈ ( A × { B } ) ) ;;
	step 42 : wff = jca (step 34, step 41) |- ( ( B ∈ V ∧ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) → ( ( 1st ` x ) = y ∧ x ∈ ( A × { B } ) ) ) ;;
	step 43 : wff = impbida (step 27, step 42) |- ( B ∈ V → ( ( ( 1st ` x ) = y ∧ x ∈ ( A × { B } ) ) ↔ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ) ;;
	step 44 : wff = syl5bbr (step 14, step 43) |- ( B ∈ V → ( ( x 1st y ∧ x ∈ ( A × { B } ) ) ↔ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ) ;;
	step 45 : wff = syl5bb (step 7, step 44) |- ( B ∈ V → ( x ( 1st ↾ ( A × { B } ) ) y ↔ ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ) ;;
	step 46 : wff = mobidv (step 45) |- ( B ∈ V → ( ∃* x x ( 1st ↾ ( A × { B } ) ) y ↔ ∃* x ( y ∈ A ∧ x = 〈 y , B 〉 ) ) ) ;;
	step 47 : wff = mpbiri (step 5, step 46) |- ( B ∈ V → ∃* x x ( 1st ↾ ( A × { B } ) ) y ) ;;
	step 48 : wff = alrimiv (step 47) |- ( B ∈ V → ∀ y ∃* x x ( 1st ↾ ( A × { B } ) ) y ) ;;
	step 49 : wff = funcnv2 () |- ( Fun ⁻¹ ( 1st ↾ ( A × { B } ) ) ↔ ∀ y ∃* x x ( 1st ↾ ( A × { B } ) ) y ) ;;
	step 50 : wff = sylibr (step 48, step 49) |- ( B ∈ V → Fun ⁻¹ ( 1st ↾ ( A × { B } ) ) ) ;;
	step 51 : wff = dff1o3 () |- ( ( 1st ↾ ( A × { B } ) ) : ( A × { B } ) ⤖ A ↔ ( ( 1st ↾ ( A × { B } ) ) : ( A × { B } ) ↠ A ∧ Fun ⁻¹ ( 1st ↾ ( A × { B } ) ) ) ) ;;
	step 52 : wff = sylanbrc (step 3, step 50, step 51) |- ( B ∈ V → ( 1st ↾ ( A × { B } ) ) : ( A × { B } ) ⤖ A ) ;;
	qed prop 1 = step 52 ;;
}

/* The mapping of a restriction of the ` 2nd ` function to a converse
       constant function.  (Contributed by NM, 27-Mar-2008.) */

theorem 2ndconst (A : class, B : class, V : class) disjointed(x y A, x y B, x y V) {
	prop 1 : wff = |- ( A ∈ V → ( 2nd ↾ ( { A } × B ) ) : ( { A } × B ) ⤖ B ) ;;
}

proof of 2ndconst {
	var x : set, y : set;;
	step 1 : wff = snnzg () |- ( A ∈ V → { A } ≠ ∅ ) ;;
	step 2 : wff = fo2ndres () |- ( { A } ≠ ∅ → ( 2nd ↾ ( { A } × B ) ) : ( { A } × B ) ↠ B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ∈ V → ( 2nd ↾ ( { A } × B ) ) : ( { A } × B ) ↠ B ) ;;
	step 4 : wff = moeq () |- ∃* x x = 〈 A , y 〉 ;;
	step 5 : wff = moani (step 4) |- ∃* x ( y ∈ B ∧ x = 〈 A , y 〉 ) ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = brres (step 6) |- ( x ( 2nd ↾ ( { A } × B ) ) y ↔ ( x 2nd y ∧ x ∈ ( { A } × B ) ) ) ;;
	step 8 : wff = fo2nd () |- 2nd : _V ↠ _V ;;
	step 9 : wff = fofn () |- ( 2nd : _V ↠ _V → 2nd Fn _V ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- 2nd Fn _V ;;
	step 11 : wff = vex () |- x ∈ _V ;;
	step 12 : wff = fnbrfvb () |- ( ( 2nd Fn _V ∧ x ∈ _V ) → ( ( 2nd ` x ) = y ↔ x 2nd y ) ) ;;
	step 13 : wff = mp2an (step 10, step 11, step 12) |- ( ( 2nd ` x ) = y ↔ x 2nd y ) ;;
	step 14 : wff = anbi1i (step 13) |- ( ( ( 2nd ` x ) = y ∧ x ∈ ( { A } × B ) ) ↔ ( x 2nd y ∧ x ∈ ( { A } × B ) ) ) ;;
	step 15 : wff = elxp7 () |- ( x ∈ ( { A } × B ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ { A } ∧ ( 2nd ` x ) ∈ B ) ) ) ;;
	step 16 : wff = eleq1 () |- ( ( 2nd ` x ) = y → ( ( 2nd ` x ) ∈ B ↔ y ∈ B ) ) ;;
	step 17 : wff = biimpa (step 16) |- ( ( ( 2nd ` x ) = y ∧ ( 2nd ` x ) ∈ B ) → y ∈ B ) ;;
	step 18 : wff = adantrl (step 17) |- ( ( ( 2nd ` x ) = y ∧ ( ( 1st ` x ) ∈ { A } ∧ ( 2nd ` x ) ∈ B ) ) → y ∈ B ) ;;
	step 19 : wff = adantrl (step 18) |- ( ( ( 2nd ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ { A } ∧ ( 2nd ` x ) ∈ B ) ) ) → y ∈ B ) ;;
	step 20 : wff = elsni () |- ( ( 1st ` x ) ∈ { A } → ( 1st ` x ) = A ) ;;
	step 21 : wff = eqopi () |- ( ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) = A ∧ ( 2nd ` x ) = y ) ) → x = 〈 A , y 〉 ) ;;
	step 22 : wff = ancom2s (step 21) |- ( ( x ∈ ( _V × _V ) ∧ ( ( 2nd ` x ) = y ∧ ( 1st ` x ) = A ) ) → x = 〈 A , y 〉 ) ;;
	step 23 : wff = an12s (step 22) |- ( ( ( 2nd ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( 1st ` x ) = A ) ) → x = 〈 A , y 〉 ) ;;
	step 24 : wff = sylanr2 (step 20, step 23) |- ( ( ( 2nd ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( 1st ` x ) ∈ { A } ) ) → x = 〈 A , y 〉 ) ;;
	step 25 : wff = adantrrr (step 24) |- ( ( ( 2nd ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ { A } ∧ ( 2nd ` x ) ∈ B ) ) ) → x = 〈 A , y 〉 ) ;;
	step 26 : wff = jca (step 19, step 25) |- ( ( ( 2nd ` x ) = y ∧ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ { A } ∧ ( 2nd ` x ) ∈ B ) ) ) → ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ;;
	step 27 : wff = sylan2b (step 15, step 26) |- ( ( ( 2nd ` x ) = y ∧ x ∈ ( { A } × B ) ) → ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ;;
	step 28 : wff = adantl (step 27) |- ( ( A ∈ V ∧ ( ( 2nd ` x ) = y ∧ x ∈ ( { A } × B ) ) ) → ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ;;
	step 29 : wff = fveq2 () |- ( x = 〈 A , y 〉 → ( 2nd ` x ) = ( 2nd ` 〈 A , y 〉 ) ) ;;
	step 30 : wff = vex () |- y ∈ _V ;;
	step 31 : wff = op2ndg () |- ( ( A ∈ V ∧ y ∈ _V ) → ( 2nd ` 〈 A , y 〉 ) = y ) ;;
	step 32 : wff = mpan2 (step 30, step 31) |- ( A ∈ V → ( 2nd ` 〈 A , y 〉 ) = y ) ;;
	step 33 : wff = sylan9eqr (step 29, step 32) |- ( ( A ∈ V ∧ x = 〈 A , y 〉 ) → ( 2nd ` x ) = y ) ;;
	step 34 : wff = adantrl (step 33) |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → ( 2nd ` x ) = y ) ;;
	step 35 : wff = simprr () |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → x = 〈 A , y 〉 ) ;;
	step 36 : wff = snidg () |- ( A ∈ V → A ∈ { A } ) ;;
	step 37 : wff = adantr (step 36) |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → A ∈ { A } ) ;;
	step 38 : wff = simprl () |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → y ∈ B ) ;;
	step 39 : wff = opelxpi () |- ( ( A ∈ { A } ∧ y ∈ B ) → 〈 A , y 〉 ∈ ( { A } × B ) ) ;;
	step 40 : wff = syl2anc (step 37, step 38, step 39) |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → 〈 A , y 〉 ∈ ( { A } × B ) ) ;;
	step 41 : wff = eqeltrd (step 35, step 40) |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → x ∈ ( { A } × B ) ) ;;
	step 42 : wff = jca (step 34, step 41) |- ( ( A ∈ V ∧ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) → ( ( 2nd ` x ) = y ∧ x ∈ ( { A } × B ) ) ) ;;
	step 43 : wff = impbida (step 28, step 42) |- ( A ∈ V → ( ( ( 2nd ` x ) = y ∧ x ∈ ( { A } × B ) ) ↔ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ) ;;
	step 44 : wff = syl5bbr (step 14, step 43) |- ( A ∈ V → ( ( x 2nd y ∧ x ∈ ( { A } × B ) ) ↔ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ) ;;
	step 45 : wff = syl5bb (step 7, step 44) |- ( A ∈ V → ( x ( 2nd ↾ ( { A } × B ) ) y ↔ ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ) ;;
	step 46 : wff = mobidv (step 45) |- ( A ∈ V → ( ∃* x x ( 2nd ↾ ( { A } × B ) ) y ↔ ∃* x ( y ∈ B ∧ x = 〈 A , y 〉 ) ) ) ;;
	step 47 : wff = mpbiri (step 5, step 46) |- ( A ∈ V → ∃* x x ( 2nd ↾ ( { A } × B ) ) y ) ;;
	step 48 : wff = alrimiv (step 47) |- ( A ∈ V → ∀ y ∃* x x ( 2nd ↾ ( { A } × B ) ) y ) ;;
	step 49 : wff = funcnv2 () |- ( Fun ⁻¹ ( 2nd ↾ ( { A } × B ) ) ↔ ∀ y ∃* x x ( 2nd ↾ ( { A } × B ) ) y ) ;;
	step 50 : wff = sylibr (step 48, step 49) |- ( A ∈ V → Fun ⁻¹ ( 2nd ↾ ( { A } × B ) ) ) ;;
	step 51 : wff = dff1o3 () |- ( ( 2nd ↾ ( { A } × B ) ) : ( { A } × B ) ⤖ B ↔ ( ( 2nd ↾ ( { A } × B ) ) : ( { A } × B ) ↠ B ∧ Fun ⁻¹ ( 2nd ↾ ( { A } × B ) ) ) ) ;;
	step 52 : wff = sylanbrc (step 3, step 50, step 51) |- ( A ∈ V → ( 2nd ↾ ( { A } × B ) ) : ( { A } × B ) ⤖ B ) ;;
	qed prop 1 = step 52 ;;
}

/* Alternate definition for the "maps to" notation ~ df-mpt2 (although it
       requires that ` C ` be a set).  (Contributed by NM, 19-Dec-2008.)
       (Revised by Mario Carneiro, 31-Aug-2015.) */

theorem dfmpt2 (x : set, y : set, A : class, B : class, C : class) disjointed(w x y A, w x y B, w C) {
	hyp 1 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A , y ∈ B ↦ C ) = ⋃_ x ∈ A ⋃_ y ∈ B { 〈 〈 x , y 〉 , C 〉 } ;;
}

proof of dfmpt2 {
	var w : set;;
	step 1 : wff = mpt2mpts () |- ( x ∈ A , y ∈ B ↦ C ) = ( w ∈ ( A × B ) ↦ [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C ) ;;
	step 2 : wff = fvex () |- ( 1st ` w ) ∈ _V ;;
	step 3 : wff = fvex () |- ( 2nd ` w ) ∈ _V ;;
	step 4 : wff = csbex (step 3, hyp 1) |- [_ ( 2nd ` w ) / y ]_ C ∈ _V ;;
	step 5 : wff = csbex (step 2, step 4) |- [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C ∈ _V ;;
	step 6 : wff = dfmpt (step 5) |- ( w ∈ ( A × B ) ↦ [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C ) = ⋃_ w ∈ ( A × B ) { 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 } ;;
	step 7 : wff = nfcv () |- F/_ x w ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C ;;
	step 9 : wff = nfop (step 7, step 8) |- F/_ x 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 ;;
	step 10 : wff = nfsn (step 9) |- F/_ x { 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 } ;;
	step 11 : wff = nfcv () |- F/_ y w ;;
	step 12 : wff = nfcv () |- F/_ y ( 1st ` w ) ;;
	step 13 : wff = nfcsb1v () |- F/_ y [_ ( 2nd ` w ) / y ]_ C ;;
	step 14 : wff = nfcsb (step 12, step 13) |- F/_ y [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C ;;
	step 15 : wff = nfop (step 11, step 14) |- F/_ y 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 ;;
	step 16 : wff = nfsn (step 15) |- F/_ y { 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 } ;;
	step 17 : wff = nfcv () |- F/_ w { 〈 〈 x , y 〉 , C 〉 } ;;
	step 18 : wff = id () |- ( w = 〈 x , y 〉 → w = 〈 x , y 〉 ) ;;
	step 19 : wff = csbopeq1a () |- ( w = 〈 x , y 〉 → [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C = C ) ;;
	step 20 : wff = opeq12d (step 18, step 19) |- ( w = 〈 x , y 〉 → 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 = 〈 〈 x , y 〉 , C 〉 ) ;;
	step 21 : wff = sneqd (step 20) |- ( w = 〈 x , y 〉 → { 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 } = { 〈 〈 x , y 〉 , C 〉 } ) ;;
	step 22 : wff = iunxpf (step 10, step 16, step 17, step 21) |- ⋃_ w ∈ ( A × B ) { 〈 w , [_ ( 1st ` w ) / x ]_ [_ ( 2nd ` w ) / y ]_ C 〉 } = ⋃_ x ∈ A ⋃_ y ∈ B { 〈 〈 x , y 〉 , C 〉 } ;;
	step 23 : wff = 3eqtri (step 1, step 6, step 22) |- ( x ∈ A , y ∈ B ↦ C ) = ⋃_ x ∈ A ⋃_ y ∈ B { 〈 〈 x , y 〉 , C 〉 } ;;
	qed prop 1 = step 23 ;;
}

/* Composition with ` ``' ( 2nd |`` ( { C } X. _V ) ) ` turns any binary
       operation ` F ` with a constant first operand into a function ` G ` of
       the second operand only.  This transformation is called "currying."
       (Contributed by NM, 28-Mar-2008.)  (Revised by Mario Carneiro,
       26-Dec-2014.) */

theorem curry1 (x : set, A : class, B : class, C : class, F : class, G : class) disjointed(x A, x B, x C, x F, x G) {
	hyp 1 : wff = |- G = ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → G = ( x ∈ B ↦ ( C F x ) ) ) ;;
}

proof of curry1 {
	step 1 : wff = fnfun () |- ( F Fn ( A × B ) → Fun F ) ;;
	step 2 : wff = 2ndconst () |- ( C ∈ A → ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ) ;;
	step 3 : wff = dff1o3 () |- ( ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ↔ ( ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ↠ _V ∧ Fun ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ) ;;
	step 4 : wff = simprbi (step 3) |- ( ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V → Fun ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( C ∈ A → Fun ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ;;
	step 6 : wff = funco () |- ( ( Fun F ∧ Fun ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) → Fun ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ) ;;
	step 7 : wff = syl2an (step 1, step 5, step 6) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → Fun ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ) ;;
	step 8 : wff = dmco () |- dom ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) = ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " dom F ) ;;
	step 9 : wff = fndm () |- ( F Fn ( A × B ) → dom F = ( A × B ) ) ;;
	step 10 : wff = adantr (step 9) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → dom F = ( A × B ) ) ;;
	step 11 : wff = imaeq2d (step 10) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " dom F ) = ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) ) ;;
	step 12 : wff = imacnvcnv () |- ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) = ( ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) ;;
	step 13 : wff = df-ima () |- ( ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) = ran ( ( 2nd ↾ ( { C } × _V ) ) ↾ ( A × B ) ) ;;
	step 14 : wff = resres () |- ( ( 2nd ↾ ( { C } × _V ) ) ↾ ( A × B ) ) = ( 2nd ↾ ( ( { C } × _V ) ∩ ( A × B ) ) ) ;;
	step 15 : wff = rneqi (step 14) |- ran ( ( 2nd ↾ ( { C } × _V ) ) ↾ ( A × B ) ) = ran ( 2nd ↾ ( ( { C } × _V ) ∩ ( A × B ) ) ) ;;
	step 16 : wff = 3eqtri (step 12, step 13, step 15) |- ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) = ran ( 2nd ↾ ( ( { C } × _V ) ∩ ( A × B ) ) ) ;;
	step 17 : wff = inxp () |- ( ( { C } × _V ) ∩ ( A × B ) ) = ( ( { C } ∩ A ) × ( _V ∩ B ) ) ;;
	step 18 : wff = incom () |- ( _V ∩ B ) = ( B ∩ _V ) ;;
	step 19 : wff = inv1 () |- ( B ∩ _V ) = B ;;
	step 20 : wff = eqtri (step 18, step 19) |- ( _V ∩ B ) = B ;;
	step 21 : wff = xpeq2i (step 20) |- ( ( { C } ∩ A ) × ( _V ∩ B ) ) = ( ( { C } ∩ A ) × B ) ;;
	step 22 : wff = eqtri (step 17, step 21) |- ( ( { C } × _V ) ∩ ( A × B ) ) = ( ( { C } ∩ A ) × B ) ;;
	step 23 : wff = snssi () |- ( C ∈ A → { C } ⊆ A ) ;;
	step 24 : wff = df-ss () |- ( { C } ⊆ A ↔ ( { C } ∩ A ) = { C } ) ;;
	step 25 : wff = sylib (step 23, step 24) |- ( C ∈ A → ( { C } ∩ A ) = { C } ) ;;
	step 26 : wff = xpeq1d (step 25) |- ( C ∈ A → ( ( { C } ∩ A ) × B ) = ( { C } × B ) ) ;;
	step 27 : wff = syl5eq (step 22, step 26) |- ( C ∈ A → ( ( { C } × _V ) ∩ ( A × B ) ) = ( { C } × B ) ) ;;
	step 28 : wff = reseq2d (step 27) |- ( C ∈ A → ( 2nd ↾ ( ( { C } × _V ) ∩ ( A × B ) ) ) = ( 2nd ↾ ( { C } × B ) ) ) ;;
	step 29 : wff = rneqd (step 28) |- ( C ∈ A → ran ( 2nd ↾ ( ( { C } × _V ) ∩ ( A × B ) ) ) = ran ( 2nd ↾ ( { C } × B ) ) ) ;;
	step 30 : wff = 2ndconst () |- ( C ∈ A → ( 2nd ↾ ( { C } × B ) ) : ( { C } × B ) ⤖ B ) ;;
	step 31 : wff = f1ofo () |- ( ( 2nd ↾ ( { C } × B ) ) : ( { C } × B ) ⤖ B → ( 2nd ↾ ( { C } × B ) ) : ( { C } × B ) ↠ B ) ;;
	step 32 : wff = forn () |- ( ( 2nd ↾ ( { C } × B ) ) : ( { C } × B ) ↠ B → ran ( 2nd ↾ ( { C } × B ) ) = B ) ;;
	step 33 : wff = 3syl (step 30, step 31, step 32) |- ( C ∈ A → ran ( 2nd ↾ ( { C } × B ) ) = B ) ;;
	step 34 : wff = eqtrd (step 29, step 33) |- ( C ∈ A → ran ( 2nd ↾ ( ( { C } × _V ) ∩ ( A × B ) ) ) = B ) ;;
	step 35 : wff = syl5eq (step 16, step 34) |- ( C ∈ A → ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) = B ) ;;
	step 36 : wff = adantl (step 35) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " ( A × B ) ) = B ) ;;
	step 37 : wff = eqtrd (step 11, step 36) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( ⁻¹ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) " dom F ) = B ) ;;
	step 38 : wff = syl5eq (step 8, step 37) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → dom ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) = B ) ;;
	step 39 : wff = fneq1i (hyp 1) |- ( G Fn B ↔ ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) Fn B ) ;;
	step 40 : wff = df-fn () |- ( ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) Fn B ↔ ( Fun ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ∧ dom ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) = B ) ) ;;
	step 41 : wff = bitri (step 39, step 40) |- ( G Fn B ↔ ( Fun ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ∧ dom ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) = B ) ) ;;
	step 42 : wff = sylanbrc (step 7, step 38, step 41) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → G Fn B ) ;;
	step 43 : wff = dffn5 () |- ( G Fn B ↔ G = ( x ∈ B ↦ ( G ` x ) ) ) ;;
	step 44 : wff = sylib (step 42, step 43) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → G = ( x ∈ B ↦ ( G ` x ) ) ) ;;
	step 45 : wff = fveq1i (hyp 1) |- ( G ` x ) = ( ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ` x ) ;;
	step 46 : wff = 2ndconst () |- ( C ∈ A → ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ) ;;
	step 47 : wff = dff1o4 () |- ( ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ↔ ( ( 2nd ↾ ( { C } × _V ) ) Fn ( { C } × _V ) ∧ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) Fn _V ) ) ;;
	step 48 : wff = sylib (step 46, step 47) |- ( C ∈ A → ( ( 2nd ↾ ( { C } × _V ) ) Fn ( { C } × _V ) ∧ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) Fn _V ) ) ;;
	step 49 : wff = simprd (step 48) |- ( C ∈ A → ⁻¹ ( 2nd ↾ ( { C } × _V ) ) Fn _V ) ;;
	step 50 : wff = vex () |- x ∈ _V ;;
	step 51 : wff = fvco2 () |- ( ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) Fn _V ∧ x ∈ _V ) → ( ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ` x ) = ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) ) ;;
	step 52 : wff = mpan2 (step 50, step 51) |- ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) Fn _V → ( ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ` x ) = ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) ) ;;
	step 53 : wff = syl (step 49, step 52) |- ( C ∈ A → ( ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ` x ) = ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) ) ;;
	step 54 : wff = ad2antlr (step 53) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ x ∈ B ) → ( ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ` x ) = ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) ) ;;
	step 55 : wff = syl5eq (step 45, step 54) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ x ∈ B ) → ( G ` x ) = ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) ) ;;
	step 56 : wff = 2ndconst () |- ( C ∈ A → ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ) ;;
	step 57 : wff = adantr (step 56) |- ( ( C ∈ A ∧ x ∈ B ) → ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ) ;;
	step 58 : wff = snidg () |- ( C ∈ A → C ∈ { C } ) ;;
	step 59 : wff = vex () |- x ∈ _V ;;
	step 60 : wff = jctir (step 58, step 59) |- ( C ∈ A → ( C ∈ { C } ∧ x ∈ _V ) ) ;;
	step 61 : wff = opelxp () |- ( 〈 C , x 〉 ∈ ( { C } × _V ) ↔ ( C ∈ { C } ∧ x ∈ _V ) ) ;;
	step 62 : wff = sylibr (step 60, step 61) |- ( C ∈ A → 〈 C , x 〉 ∈ ( { C } × _V ) ) ;;
	step 63 : wff = adantr (step 62) |- ( ( C ∈ A ∧ x ∈ B ) → 〈 C , x 〉 ∈ ( { C } × _V ) ) ;;
	step 64 : wff = jca (step 57, step 63) |- ( ( C ∈ A ∧ x ∈ B ) → ( ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ∧ 〈 C , x 〉 ∈ ( { C } × _V ) ) ) ;;
	step 65 : wff = snidg () |- ( C ∈ A → C ∈ { C } ) ;;
	step 66 : wff = vex () |- x ∈ _V ;;
	step 67 : wff = jctir (step 65, step 66) |- ( C ∈ A → ( C ∈ { C } ∧ x ∈ _V ) ) ;;
	step 68 : wff = opelxp () |- ( 〈 C , x 〉 ∈ ( { C } × _V ) ↔ ( C ∈ { C } ∧ x ∈ _V ) ) ;;
	step 69 : wff = sylibr (step 67, step 68) |- ( C ∈ A → 〈 C , x 〉 ∈ ( { C } × _V ) ) ;;
	step 70 : wff = fvres () |- ( 〈 C , x 〉 ∈ ( { C } × _V ) → ( ( 2nd ↾ ( { C } × _V ) ) ` 〈 C , x 〉 ) = ( 2nd ` 〈 C , x 〉 ) ) ;;
	step 71 : wff = syl (step 69, step 70) |- ( C ∈ A → ( ( 2nd ↾ ( { C } × _V ) ) ` 〈 C , x 〉 ) = ( 2nd ` 〈 C , x 〉 ) ) ;;
	step 72 : wff = vex () |- x ∈ _V ;;
	step 73 : wff = op2ndg () |- ( ( C ∈ A ∧ x ∈ _V ) → ( 2nd ` 〈 C , x 〉 ) = x ) ;;
	step 74 : wff = mpan2 (step 72, step 73) |- ( C ∈ A → ( 2nd ` 〈 C , x 〉 ) = x ) ;;
	step 75 : wff = eqtrd (step 71, step 74) |- ( C ∈ A → ( ( 2nd ↾ ( { C } × _V ) ) ` 〈 C , x 〉 ) = x ) ;;
	step 76 : wff = adantr (step 75) |- ( ( C ∈ A ∧ x ∈ B ) → ( ( 2nd ↾ ( { C } × _V ) ) ` 〈 C , x 〉 ) = x ) ;;
	step 77 : wff = f1ocnvfv () |- ( ( ( 2nd ↾ ( { C } × _V ) ) : ( { C } × _V ) ⤖ _V ∧ 〈 C , x 〉 ∈ ( { C } × _V ) ) → ( ( ( 2nd ↾ ( { C } × _V ) ) ` 〈 C , x 〉 ) = x → ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) = 〈 C , x 〉 ) ) ;;
	step 78 : wff = sylc (step 64, step 76, step 77) |- ( ( C ∈ A ∧ x ∈ B ) → ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) = 〈 C , x 〉 ) ;;
	step 79 : wff = fveq2d (step 78) |- ( ( C ∈ A ∧ x ∈ B ) → ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) = ( F ` 〈 C , x 〉 ) ) ;;
	step 80 : wff = adantll (step 79) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ x ∈ B ) → ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) = ( F ` 〈 C , x 〉 ) ) ;;
	step 81 : wff = df-ov () |- ( C F x ) = ( F ` 〈 C , x 〉 ) ;;
	step 82 : wff = syl6eqr (step 80, step 81) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ x ∈ B ) → ( F ` ( ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ` x ) ) = ( C F x ) ) ;;
	step 83 : wff = eqtrd (step 55, step 82) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ x ∈ B ) → ( G ` x ) = ( C F x ) ) ;;
	step 84 : wff = mpteq2dva (step 83) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( x ∈ B ↦ ( G ` x ) ) = ( x ∈ B ↦ ( C F x ) ) ) ;;
	step 85 : wff = eqtrd (step 44, step 84) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → G = ( x ∈ B ↦ ( C F x ) ) ) ;;
	qed prop 1 = step 85 ;;
}

/* The value of a curried function with a constant first argument.
       (Contributed by NM, 28-Mar-2008.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem curry1val (A : class, B : class, C : class, D : class, F : class, G : class) disjointed(x A, x B, x C, x D, x F, x G) {
	hyp 1 : wff = |- G = ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( G ` D ) = ( C F D ) ) ;;
}

proof of curry1val {
	var x : set;;
	step 1 : wff = curry1 (hyp 1) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → G = ( x ∈ B ↦ ( C F x ) ) ) ;;
	step 2 : wff = fveq1d (step 1) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( G ` D ) = ( ( x ∈ B ↦ ( C F x ) ) ` D ) ) ;;
	step 3 : wff = eqid () |- ( x ∈ B ↦ ( C F x ) ) = ( x ∈ B ↦ ( C F x ) ) ;;
	step 4 : wff = dmmptss (step 3) |- dom ( x ∈ B ↦ ( C F x ) ) ⊆ B ;;
	step 5 : wff = sseli (step 4) |- ( D ∈ dom ( x ∈ B ↦ ( C F x ) ) → D ∈ B ) ;;
	step 6 : wff = con3i (step 5) |- ( ¬ D ∈ B → ¬ D ∈ dom ( x ∈ B ↦ ( C F x ) ) ) ;;
	step 7 : wff = ndmfv () |- ( ¬ D ∈ dom ( x ∈ B ↦ ( C F x ) ) → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ∅ ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ¬ D ∈ B → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ∅ ) ;;
	step 9 : wff = adantl (step 8) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ ¬ D ∈ B ) → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ∅ ) ;;
	step 10 : wff = fndm () |- ( F Fn ( A × B ) → dom F = ( A × B ) ) ;;
	step 11 : wff = adantr (step 10) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → dom F = ( A × B ) ) ;;
	step 12 : wff = simpr () |- ( ( C ∈ A ∧ D ∈ B ) → D ∈ B ) ;;
	step 13 : wff = con3i (step 12) |- ( ¬ D ∈ B → ¬ ( C ∈ A ∧ D ∈ B ) ) ;;
	step 14 : wff = ndmovg () |- ( ( dom F = ( A × B ) ∧ ¬ ( C ∈ A ∧ D ∈ B ) ) → ( C F D ) = ∅ ) ;;
	step 15 : wff = syl2an (step 11, step 13, step 14) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ ¬ D ∈ B ) → ( C F D ) = ∅ ) ;;
	step 16 : wff = eqtr4d (step 9, step 15) |- ( ( ( F Fn ( A × B ) ∧ C ∈ A ) ∧ ¬ D ∈ B ) → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ( C F D ) ) ;;
	step 17 : wff = ex (step 16) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( ¬ D ∈ B → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ( C F D ) ) ) ;;
	step 18 : wff = oveq2 () |- ( x = D → ( C F x ) = ( C F D ) ) ;;
	step 19 : wff = eqid () |- ( x ∈ B ↦ ( C F x ) ) = ( x ∈ B ↦ ( C F x ) ) ;;
	step 20 : wff = ovex () |- ( C F D ) ∈ _V ;;
	step 21 : wff = fvmpt (step 18, step 19, step 20) |- ( D ∈ B → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ( C F D ) ) ;;
	step 22 : wff = pm2.61d2 (step 17, step 21) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( ( x ∈ B ↦ ( C F x ) ) ` D ) = ( C F D ) ) ;;
	step 23 : wff = eqtrd (step 2, step 22) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → ( G ` D ) = ( C F D ) ) ;;
	qed prop 1 = step 23 ;;
}

/* Functionality of a curried function with a constant first argument.
       (Contributed by NM, 29-Mar-2008.) */

theorem curry1f (A : class, B : class, C : class, D : class, F : class, G : class) disjointed(x A, x B, x C, x D, x F, x G) {
	hyp 1 : wff = |- G = ( F ∘ ⁻¹ ( 2nd ↾ ( { C } × _V ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ) → G : B ⟶ D ) ;;
}

proof of curry1f {
	var x : set;;
	step 1 : wff = fovrn () |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ∧ x ∈ B ) → ( C F x ) ∈ D ) ;;
	step 2 : wff = 3expa (step 1) |- ( ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ) ∧ x ∈ B ) → ( C F x ) ∈ D ) ;;
	step 3 : wff = eqid () |- ( x ∈ B ↦ ( C F x ) ) = ( x ∈ B ↦ ( C F x ) ) ;;
	step 4 : wff = fmptd (step 2, step 3) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ) → ( x ∈ B ↦ ( C F x ) ) : B ⟶ D ) ;;
	step 5 : wff = ffn () |- ( F : ( A × B ) ⟶ D → F Fn ( A × B ) ) ;;
	step 6 : wff = curry1 (hyp 1) |- ( ( F Fn ( A × B ) ∧ C ∈ A ) → G = ( x ∈ B ↦ ( C F x ) ) ) ;;
	step 7 : wff = sylan (step 5, step 6) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ) → G = ( x ∈ B ↦ ( C F x ) ) ) ;;
	step 8 : wff = feq1d (step 7) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ) → ( G : B ⟶ D ↔ ( x ∈ B ↦ ( C F x ) ) : B ⟶ D ) ) ;;
	step 9 : wff = mpbird (step 4, step 8) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ A ) → G : B ⟶ D ) ;;
	qed prop 1 = step 9 ;;
}

/* Composition with ` ``' ( 1st |`` ( _V X. { C } ) ) ` turns any binary
       operation ` F ` with a constant second operand into a function ` G ` of
       the first operand only.  This transformation is called "currying."  (If
       this becomes frequently used, we can introduce a new notation for the
       hypothesis.)  (Contributed by NM, 16-Dec-2008.) */

theorem curry2 (x : set, A : class, B : class, C : class, F : class, G : class) disjointed(x A, x B, x C, x F, x G) {
	hyp 1 : wff = |- G = ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → G = ( x ∈ A ↦ ( x F C ) ) ) ;;
}

proof of curry2 {
	step 1 : wff = fnfun () |- ( F Fn ( A × B ) → Fun F ) ;;
	step 2 : wff = 1stconst () |- ( C ∈ B → ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ) ;;
	step 3 : wff = dff1o3 () |- ( ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ↔ ( ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ↠ _V ∧ Fun ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ) ;;
	step 4 : wff = simprbi (step 3) |- ( ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V → Fun ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( C ∈ B → Fun ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ;;
	step 6 : wff = funco () |- ( ( Fun F ∧ Fun ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) → Fun ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ) ;;
	step 7 : wff = syl2an (step 1, step 5, step 6) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → Fun ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ) ;;
	step 8 : wff = dmco () |- dom ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) = ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " dom F ) ;;
	step 9 : wff = fndm () |- ( F Fn ( A × B ) → dom F = ( A × B ) ) ;;
	step 10 : wff = adantr (step 9) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → dom F = ( A × B ) ) ;;
	step 11 : wff = imaeq2d (step 10) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " dom F ) = ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) ) ;;
	step 12 : wff = imacnvcnv () |- ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) = ( ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) ;;
	step 13 : wff = df-ima () |- ( ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) = ran ( ( 1st ↾ ( _V × { C } ) ) ↾ ( A × B ) ) ;;
	step 14 : wff = resres () |- ( ( 1st ↾ ( _V × { C } ) ) ↾ ( A × B ) ) = ( 1st ↾ ( ( _V × { C } ) ∩ ( A × B ) ) ) ;;
	step 15 : wff = rneqi (step 14) |- ran ( ( 1st ↾ ( _V × { C } ) ) ↾ ( A × B ) ) = ran ( 1st ↾ ( ( _V × { C } ) ∩ ( A × B ) ) ) ;;
	step 16 : wff = 3eqtri (step 12, step 13, step 15) |- ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) = ran ( 1st ↾ ( ( _V × { C } ) ∩ ( A × B ) ) ) ;;
	step 17 : wff = inxp () |- ( ( _V × { C } ) ∩ ( A × B ) ) = ( ( _V ∩ A ) × ( { C } ∩ B ) ) ;;
	step 18 : wff = incom () |- ( _V ∩ A ) = ( A ∩ _V ) ;;
	step 19 : wff = inv1 () |- ( A ∩ _V ) = A ;;
	step 20 : wff = eqtri (step 18, step 19) |- ( _V ∩ A ) = A ;;
	step 21 : wff = xpeq1i (step 20) |- ( ( _V ∩ A ) × ( { C } ∩ B ) ) = ( A × ( { C } ∩ B ) ) ;;
	step 22 : wff = eqtri (step 17, step 21) |- ( ( _V × { C } ) ∩ ( A × B ) ) = ( A × ( { C } ∩ B ) ) ;;
	step 23 : wff = snssi () |- ( C ∈ B → { C } ⊆ B ) ;;
	step 24 : wff = df-ss () |- ( { C } ⊆ B ↔ ( { C } ∩ B ) = { C } ) ;;
	step 25 : wff = sylib (step 23, step 24) |- ( C ∈ B → ( { C } ∩ B ) = { C } ) ;;
	step 26 : wff = xpeq2d (step 25) |- ( C ∈ B → ( A × ( { C } ∩ B ) ) = ( A × { C } ) ) ;;
	step 27 : wff = syl5eq (step 22, step 26) |- ( C ∈ B → ( ( _V × { C } ) ∩ ( A × B ) ) = ( A × { C } ) ) ;;
	step 28 : wff = reseq2d (step 27) |- ( C ∈ B → ( 1st ↾ ( ( _V × { C } ) ∩ ( A × B ) ) ) = ( 1st ↾ ( A × { C } ) ) ) ;;
	step 29 : wff = rneqd (step 28) |- ( C ∈ B → ran ( 1st ↾ ( ( _V × { C } ) ∩ ( A × B ) ) ) = ran ( 1st ↾ ( A × { C } ) ) ) ;;
	step 30 : wff = 1stconst () |- ( C ∈ B → ( 1st ↾ ( A × { C } ) ) : ( A × { C } ) ⤖ A ) ;;
	step 31 : wff = f1ofo () |- ( ( 1st ↾ ( A × { C } ) ) : ( A × { C } ) ⤖ A → ( 1st ↾ ( A × { C } ) ) : ( A × { C } ) ↠ A ) ;;
	step 32 : wff = forn () |- ( ( 1st ↾ ( A × { C } ) ) : ( A × { C } ) ↠ A → ran ( 1st ↾ ( A × { C } ) ) = A ) ;;
	step 33 : wff = 3syl (step 30, step 31, step 32) |- ( C ∈ B → ran ( 1st ↾ ( A × { C } ) ) = A ) ;;
	step 34 : wff = eqtrd (step 29, step 33) |- ( C ∈ B → ran ( 1st ↾ ( ( _V × { C } ) ∩ ( A × B ) ) ) = A ) ;;
	step 35 : wff = syl5eq (step 16, step 34) |- ( C ∈ B → ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) = A ) ;;
	step 36 : wff = adantl (step 35) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " ( A × B ) ) = A ) ;;
	step 37 : wff = eqtrd (step 11, step 36) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( ⁻¹ ⁻¹ ( 1st ↾ ( _V × { C } ) ) " dom F ) = A ) ;;
	step 38 : wff = syl5eq (step 8, step 37) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → dom ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) = A ) ;;
	step 39 : wff = fneq1i (hyp 1) |- ( G Fn A ↔ ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) Fn A ) ;;
	step 40 : wff = df-fn () |- ( ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) Fn A ↔ ( Fun ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ∧ dom ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) = A ) ) ;;
	step 41 : wff = bitri (step 39, step 40) |- ( G Fn A ↔ ( Fun ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ∧ dom ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) = A ) ) ;;
	step 42 : wff = sylanbrc (step 7, step 38, step 41) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → G Fn A ) ;;
	step 43 : wff = dffn5 () |- ( G Fn A ↔ G = ( x ∈ A ↦ ( G ` x ) ) ) ;;
	step 44 : wff = sylib (step 42, step 43) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → G = ( x ∈ A ↦ ( G ` x ) ) ) ;;
	step 45 : wff = fveq1i (hyp 1) |- ( G ` x ) = ( ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ` x ) ;;
	step 46 : wff = 1stconst () |- ( C ∈ B → ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ) ;;
	step 47 : wff = dff1o4 () |- ( ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ↔ ( ( 1st ↾ ( _V × { C } ) ) Fn ( _V × { C } ) ∧ ⁻¹ ( 1st ↾ ( _V × { C } ) ) Fn _V ) ) ;;
	step 48 : wff = sylib (step 46, step 47) |- ( C ∈ B → ( ( 1st ↾ ( _V × { C } ) ) Fn ( _V × { C } ) ∧ ⁻¹ ( 1st ↾ ( _V × { C } ) ) Fn _V ) ) ;;
	step 49 : wff = simprd (step 48) |- ( C ∈ B → ⁻¹ ( 1st ↾ ( _V × { C } ) ) Fn _V ) ;;
	step 50 : wff = vex () |- x ∈ _V ;;
	step 51 : wff = fvco2 () |- ( ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) Fn _V ∧ x ∈ _V ) → ( ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ` x ) = ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) ) ;;
	step 52 : wff = sylancl (step 49, step 50, step 51) |- ( C ∈ B → ( ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ` x ) = ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) ) ;;
	step 53 : wff = ad2antlr (step 52) |- ( ( ( F Fn ( A × B ) ∧ C ∈ B ) ∧ x ∈ A ) → ( ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ` x ) = ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) ) ;;
	step 54 : wff = syl5eq (step 45, step 53) |- ( ( ( F Fn ( A × B ) ∧ C ∈ B ) ∧ x ∈ A ) → ( G ` x ) = ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) ) ;;
	step 55 : wff = 1stconst () |- ( C ∈ B → ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ) ;;
	step 56 : wff = adantr (step 55) |- ( ( C ∈ B ∧ x ∈ A ) → ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ) ;;
	step 57 : wff = vex () |- x ∈ _V ;;
	step 58 : wff = a1i (step 57) |- ( ( C ∈ B ∧ x ∈ A ) → x ∈ _V ) ;;
	step 59 : wff = snidg () |- ( C ∈ B → C ∈ { C } ) ;;
	step 60 : wff = adantr (step 59) |- ( ( C ∈ B ∧ x ∈ A ) → C ∈ { C } ) ;;
	step 61 : wff = opelxp () |- ( 〈 x , C 〉 ∈ ( _V × { C } ) ↔ ( x ∈ _V ∧ C ∈ { C } ) ) ;;
	step 62 : wff = sylanbrc (step 58, step 60, step 61) |- ( ( C ∈ B ∧ x ∈ A ) → 〈 x , C 〉 ∈ ( _V × { C } ) ) ;;
	step 63 : wff = jca (step 56, step 62) |- ( ( C ∈ B ∧ x ∈ A ) → ( ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ∧ 〈 x , C 〉 ∈ ( _V × { C } ) ) ) ;;
	step 64 : wff = vex () |- x ∈ _V ;;
	step 65 : wff = a1i (step 64) |- ( C ∈ B → x ∈ _V ) ;;
	step 66 : wff = snidg () |- ( C ∈ B → C ∈ { C } ) ;;
	step 67 : wff = opelxp () |- ( 〈 x , C 〉 ∈ ( _V × { C } ) ↔ ( x ∈ _V ∧ C ∈ { C } ) ) ;;
	step 68 : wff = sylanbrc (step 65, step 66, step 67) |- ( C ∈ B → 〈 x , C 〉 ∈ ( _V × { C } ) ) ;;
	step 69 : wff = fvres () |- ( 〈 x , C 〉 ∈ ( _V × { C } ) → ( ( 1st ↾ ( _V × { C } ) ) ` 〈 x , C 〉 ) = ( 1st ` 〈 x , C 〉 ) ) ;;
	step 70 : wff = syl (step 68, step 69) |- ( C ∈ B → ( ( 1st ↾ ( _V × { C } ) ) ` 〈 x , C 〉 ) = ( 1st ` 〈 x , C 〉 ) ) ;;
	step 71 : wff = adantr (step 70) |- ( ( C ∈ B ∧ x ∈ A ) → ( ( 1st ↾ ( _V × { C } ) ) ` 〈 x , C 〉 ) = ( 1st ` 〈 x , C 〉 ) ) ;;
	step 72 : wff = op1stg () |- ( ( x ∈ A ∧ C ∈ B ) → ( 1st ` 〈 x , C 〉 ) = x ) ;;
	step 73 : wff = ancoms (step 72) |- ( ( C ∈ B ∧ x ∈ A ) → ( 1st ` 〈 x , C 〉 ) = x ) ;;
	step 74 : wff = eqtrd (step 71, step 73) |- ( ( C ∈ B ∧ x ∈ A ) → ( ( 1st ↾ ( _V × { C } ) ) ` 〈 x , C 〉 ) = x ) ;;
	step 75 : wff = f1ocnvfv () |- ( ( ( 1st ↾ ( _V × { C } ) ) : ( _V × { C } ) ⤖ _V ∧ 〈 x , C 〉 ∈ ( _V × { C } ) ) → ( ( ( 1st ↾ ( _V × { C } ) ) ` 〈 x , C 〉 ) = x → ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) = 〈 x , C 〉 ) ) ;;
	step 76 : wff = sylc (step 63, step 74, step 75) |- ( ( C ∈ B ∧ x ∈ A ) → ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) = 〈 x , C 〉 ) ;;
	step 77 : wff = fveq2d (step 76) |- ( ( C ∈ B ∧ x ∈ A ) → ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) = ( F ` 〈 x , C 〉 ) ) ;;
	step 78 : wff = adantll (step 77) |- ( ( ( F Fn ( A × B ) ∧ C ∈ B ) ∧ x ∈ A ) → ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) = ( F ` 〈 x , C 〉 ) ) ;;
	step 79 : wff = df-ov () |- ( x F C ) = ( F ` 〈 x , C 〉 ) ;;
	step 80 : wff = syl6eqr (step 78, step 79) |- ( ( ( F Fn ( A × B ) ∧ C ∈ B ) ∧ x ∈ A ) → ( F ` ( ⁻¹ ( 1st ↾ ( _V × { C } ) ) ` x ) ) = ( x F C ) ) ;;
	step 81 : wff = eqtrd (step 54, step 80) |- ( ( ( F Fn ( A × B ) ∧ C ∈ B ) ∧ x ∈ A ) → ( G ` x ) = ( x F C ) ) ;;
	step 82 : wff = mpteq2dva (step 81) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( x ∈ A ↦ ( G ` x ) ) = ( x ∈ A ↦ ( x F C ) ) ) ;;
	step 83 : wff = eqtrd (step 44, step 82) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → G = ( x ∈ A ↦ ( x F C ) ) ) ;;
	qed prop 1 = step 83 ;;
}

/* Functionality of a curried function with a constant second argument.
       (Contributed by NM, 16-Dec-2008.) */

theorem curry2f (A : class, B : class, C : class, D : class, F : class, G : class) disjointed(x A, x B, x C, x D, x F, x G) {
	hyp 1 : wff = |- G = ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ) → G : A ⟶ D ) ;;
}

proof of curry2f {
	var x : set;;
	step 1 : wff = fovrn () |- ( ( F : ( A × B ) ⟶ D ∧ x ∈ A ∧ C ∈ B ) → ( x F C ) ∈ D ) ;;
	step 2 : wff = 3com23 (step 1) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ∧ x ∈ A ) → ( x F C ) ∈ D ) ;;
	step 3 : wff = 3expa (step 2) |- ( ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ) ∧ x ∈ A ) → ( x F C ) ∈ D ) ;;
	step 4 : wff = eqid () |- ( x ∈ A ↦ ( x F C ) ) = ( x ∈ A ↦ ( x F C ) ) ;;
	step 5 : wff = fmptd (step 3, step 4) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ) → ( x ∈ A ↦ ( x F C ) ) : A ⟶ D ) ;;
	step 6 : wff = ffn () |- ( F : ( A × B ) ⟶ D → F Fn ( A × B ) ) ;;
	step 7 : wff = curry2 (hyp 1) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → G = ( x ∈ A ↦ ( x F C ) ) ) ;;
	step 8 : wff = sylan (step 6, step 7) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ) → G = ( x ∈ A ↦ ( x F C ) ) ) ;;
	step 9 : wff = feq1d (step 8) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ) → ( G : A ⟶ D ↔ ( x ∈ A ↦ ( x F C ) ) : A ⟶ D ) ) ;;
	step 10 : wff = mpbird (step 5, step 9) |- ( ( F : ( A × B ) ⟶ D ∧ C ∈ B ) → G : A ⟶ D ) ;;
	qed prop 1 = step 10 ;;
}

/* The value of a curried function with a constant second argument.
       (Contributed by NM, 16-Dec-2008.) */

theorem curry2val (A : class, B : class, C : class, D : class, F : class, G : class) disjointed(x A, x B, x C, x D, x F, x G) {
	hyp 1 : wff = |- G = ( F ∘ ⁻¹ ( 1st ↾ ( _V × { C } ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( G ` D ) = ( D F C ) ) ;;
}

proof of curry2val {
	var x : set;;
	step 1 : wff = curry2 (hyp 1) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → G = ( x ∈ A ↦ ( x F C ) ) ) ;;
	step 2 : wff = fveq1d (step 1) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( G ` D ) = ( ( x ∈ A ↦ ( x F C ) ) ` D ) ) ;;
	step 3 : wff = eqid () |- ( x ∈ A ↦ ( x F C ) ) = ( x ∈ A ↦ ( x F C ) ) ;;
	step 4 : wff = dmmptss (step 3) |- dom ( x ∈ A ↦ ( x F C ) ) ⊆ A ;;
	step 5 : wff = sseli (step 4) |- ( D ∈ dom ( x ∈ A ↦ ( x F C ) ) → D ∈ A ) ;;
	step 6 : wff = con3i (step 5) |- ( ¬ D ∈ A → ¬ D ∈ dom ( x ∈ A ↦ ( x F C ) ) ) ;;
	step 7 : wff = ndmfv () |- ( ¬ D ∈ dom ( x ∈ A ↦ ( x F C ) ) → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ∅ ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ¬ D ∈ A → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ∅ ) ;;
	step 9 : wff = adantl (step 8) |- ( ( F Fn ( A × B ) ∧ ¬ D ∈ A ) → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ∅ ) ;;
	step 10 : wff = fndm () |- ( F Fn ( A × B ) → dom F = ( A × B ) ) ;;
	step 11 : wff = simpl () |- ( ( D ∈ A ∧ C ∈ B ) → D ∈ A ) ;;
	step 12 : wff = con3i (step 11) |- ( ¬ D ∈ A → ¬ ( D ∈ A ∧ C ∈ B ) ) ;;
	step 13 : wff = ndmovg () |- ( ( dom F = ( A × B ) ∧ ¬ ( D ∈ A ∧ C ∈ B ) ) → ( D F C ) = ∅ ) ;;
	step 14 : wff = syl2an (step 10, step 12, step 13) |- ( ( F Fn ( A × B ) ∧ ¬ D ∈ A ) → ( D F C ) = ∅ ) ;;
	step 15 : wff = eqtr4d (step 9, step 14) |- ( ( F Fn ( A × B ) ∧ ¬ D ∈ A ) → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ( D F C ) ) ;;
	step 16 : wff = ex (step 15) |- ( F Fn ( A × B ) → ( ¬ D ∈ A → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ( D F C ) ) ) ;;
	step 17 : wff = adantr (step 16) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( ¬ D ∈ A → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ( D F C ) ) ) ;;
	step 18 : wff = oveq1 () |- ( x = D → ( x F C ) = ( D F C ) ) ;;
	step 19 : wff = eqid () |- ( x ∈ A ↦ ( x F C ) ) = ( x ∈ A ↦ ( x F C ) ) ;;
	step 20 : wff = ovex () |- ( D F C ) ∈ _V ;;
	step 21 : wff = fvmpt (step 18, step 19, step 20) |- ( D ∈ A → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ( D F C ) ) ;;
	step 22 : wff = pm2.61d2 (step 17, step 21) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( ( x ∈ A ↦ ( x F C ) ) ` D ) = ( D F C ) ) ;;
	step 23 : wff = eqtrd (step 2, step 22) |- ( ( F Fn ( A × B ) ∧ C ∈ B ) → ( G ` D ) = ( D F C ) ) ;;
	qed prop 1 = step 23 ;;
}

/* Lemma for ~ cnvf1o .  (Contributed by Mario Carneiro, 27-Apr-2014.) */

theorem cnvf1olem (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ( C ∈ ⁻¹ A ∧ B = ⋃ ⁻¹ { C } ) ) ;;
}

proof of cnvf1olem {
	step 1 : wff = simprr () |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C = ⋃ ⁻¹ { B } ) ;;
	step 2 : wff = 1st2nd () |- ( ( Rel A ∧ B ∈ A ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 3 : wff = adantrr (step 2) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 4 : wff = sneqd (step 3) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → { B } = { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 5 : wff = cnveqd (step 4) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ⁻¹ { B } = ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 6 : wff = unieqd (step 5) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ⋃ ⁻¹ { B } = ⋃ ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 7 : wff = eqtrd (step 1, step 6) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C = ⋃ ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 8 : wff = opswap () |- ⋃ ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } = 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 ;;
	step 9 : wff = syl6eq (step 7, step 8) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C = 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 ) ;;
	step 10 : wff = 1st2nd () |- ( ( Rel A ∧ B ∈ A ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 11 : wff = adantrr (step 10) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 12 : wff = simprl () |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → B ∈ A ) ;;
	step 13 : wff = eqeltrrd (step 11, step 12) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ∈ A ) ;;
	step 14 : wff = fvex () |- ( 2nd ` B ) ∈ _V ;;
	step 15 : wff = fvex () |- ( 1st ` B ) ∈ _V ;;
	step 16 : wff = opelcnv (step 14, step 15) |- ( 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 ∈ ⁻¹ A ↔ 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ∈ A ) ;;
	step 17 : wff = sylibr (step 13, step 16) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 ∈ ⁻¹ A ) ;;
	step 18 : wff = eqeltrd (step 9, step 17) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C ∈ ⁻¹ A ) ;;
	step 19 : wff = opswap () |- ⋃ ⁻¹ { 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 } = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ;;
	step 20 : wff = eqcomi (step 19) |- 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 = ⋃ ⁻¹ { 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 } ;;
	step 21 : wff = 1st2nd () |- ( ( Rel A ∧ B ∈ A ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 22 : wff = adantrr (step 21) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 23 : wff = simprr () |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C = ⋃ ⁻¹ { B } ) ;;
	step 24 : wff = 1st2nd () |- ( ( Rel A ∧ B ∈ A ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 25 : wff = adantrr (step 24) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → B = 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 ) ;;
	step 26 : wff = sneqd (step 25) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → { B } = { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 27 : wff = cnveqd (step 26) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ⁻¹ { B } = ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 28 : wff = unieqd (step 27) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ⋃ ⁻¹ { B } = ⋃ ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 29 : wff = eqtrd (step 23, step 28) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C = ⋃ ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } ) ;;
	step 30 : wff = opswap () |- ⋃ ⁻¹ { 〈 ( 1st ` B ) , ( 2nd ` B ) 〉 } = 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 ;;
	step 31 : wff = syl6eq (step 29, step 30) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → C = 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 ) ;;
	step 32 : wff = sneqd (step 31) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → { C } = { 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 } ) ;;
	step 33 : wff = cnveqd (step 32) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ⁻¹ { C } = ⁻¹ { 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 } ) ;;
	step 34 : wff = unieqd (step 33) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ⋃ ⁻¹ { C } = ⋃ ⁻¹ { 〈 ( 2nd ` B ) , ( 1st ` B ) 〉 } ) ;;
	step 35 : wff = 3eqtr4a (step 20, step 22, step 34) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → B = ⋃ ⁻¹ { C } ) ;;
	step 36 : wff = jca (step 18, step 35) |- ( ( Rel A ∧ ( B ∈ A ∧ C = ⋃ ⁻¹ { B } ) ) → ( C ∈ ⁻¹ A ∧ B = ⋃ ⁻¹ { C } ) ) ;;
	qed prop 1 = step 36 ;;
}

/* Describe a function that maps the elements of a set to its converse
       bijectively.  (Contributed by Mario Carneiro, 27-Apr-2014.) */

theorem cnvf1o (x : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Rel A → ( x ∈ A ↦ ⋃ ⁻¹ { x } ) : A ⤖ ⁻¹ A ) ;;
}

proof of cnvf1o {
	var y : set;;
	step 1 : wff = eqid () |- ( x ∈ A ↦ ⋃ ⁻¹ { x } ) = ( x ∈ A ↦ ⋃ ⁻¹ { x } ) ;;
	step 2 : wff = snex () |- { x } ∈ _V ;;
	step 3 : wff = cnvex (step 2) |- ⁻¹ { x } ∈ _V ;;
	step 4 : wff = uniex (step 3) |- ⋃ ⁻¹ { x } ∈ _V ;;
	step 5 : wff = a1i (step 4) |- ( ( Rel A ∧ x ∈ A ) → ⋃ ⁻¹ { x } ∈ _V ) ;;
	step 6 : wff = snex () |- { y } ∈ _V ;;
	step 7 : wff = cnvex (step 6) |- ⁻¹ { y } ∈ _V ;;
	step 8 : wff = uniex (step 7) |- ⋃ ⁻¹ { y } ∈ _V ;;
	step 9 : wff = a1i (step 8) |- ( ( Rel A ∧ y ∈ ⁻¹ A ) → ⋃ ⁻¹ { y } ∈ _V ) ;;
	step 10 : wff = cnvf1olem () |- ( ( Rel A ∧ ( x ∈ A ∧ y = ⋃ ⁻¹ { x } ) ) → ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) ;;
	step 11 : wff = relcnv () |- Rel ⁻¹ A ;;
	step 12 : wff = simpr () |- ( ( Rel A ∧ ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) → ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) ;;
	step 13 : wff = cnvf1olem () |- ( ( Rel ⁻¹ A ∧ ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) → ( x ∈ ⁻¹ ⁻¹ A ∧ y = ⋃ ⁻¹ { x } ) ) ;;
	step 14 : wff = sylancr (step 11, step 12, step 13) |- ( ( Rel A ∧ ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) → ( x ∈ ⁻¹ ⁻¹ A ∧ y = ⋃ ⁻¹ { x } ) ) ;;
	step 15 : wff = dfrel2 () |- ( Rel A ↔ ⁻¹ ⁻¹ A = A ) ;;
	step 16 : wff = eleq2 () |- ( ⁻¹ ⁻¹ A = A → ( x ∈ ⁻¹ ⁻¹ A ↔ x ∈ A ) ) ;;
	step 17 : wff = sylbi (step 15, step 16) |- ( Rel A → ( x ∈ ⁻¹ ⁻¹ A ↔ x ∈ A ) ) ;;
	step 18 : wff = anbi1d (step 17) |- ( Rel A → ( ( x ∈ ⁻¹ ⁻¹ A ∧ y = ⋃ ⁻¹ { x } ) ↔ ( x ∈ A ∧ y = ⋃ ⁻¹ { x } ) ) ) ;;
	step 19 : wff = adantr (step 18) |- ( ( Rel A ∧ ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) → ( ( x ∈ ⁻¹ ⁻¹ A ∧ y = ⋃ ⁻¹ { x } ) ↔ ( x ∈ A ∧ y = ⋃ ⁻¹ { x } ) ) ) ;;
	step 20 : wff = mpbid (step 14, step 19) |- ( ( Rel A ∧ ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) → ( x ∈ A ∧ y = ⋃ ⁻¹ { x } ) ) ;;
	step 21 : wff = impbida (step 10, step 20) |- ( Rel A → ( ( x ∈ A ∧ y = ⋃ ⁻¹ { x } ) ↔ ( y ∈ ⁻¹ A ∧ x = ⋃ ⁻¹ { y } ) ) ) ;;
	step 22 : wff = f1od (step 1, step 5, step 9, step 21) |- ( Rel A → ( x ∈ A ↦ ⋃ ⁻¹ { x } ) : A ⤖ ⁻¹ A ) ;;
	qed prop 1 = step 22 ;;
}

/* Lemma for ~ fpar .  (Contributed by NM, 22-Dec-2008.)  (Revised by Mario
       Carneiro, 28-Apr-2015.) */

theorem fparlem1 (x : set) disjointed(x y, x y, x y) {
	prop 1 : wff = |- ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) = ( { x } × _V ) ;;
}

proof of fparlem1 {
	var y : set;;
	step 1 : wff = fvres () |- ( y ∈ ( _V × _V ) → ( ( 1st ↾ ( _V × _V ) ) ` y ) = ( 1st ` y ) ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( y ∈ ( _V × _V ) → ( ( ( 1st ↾ ( _V × _V ) ) ` y ) = x ↔ ( 1st ` y ) = x ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = elsnc2 (step 3) |- ( ( 1st ` y ) ∈ { x } ↔ ( 1st ` y ) = x ) ;;
	step 5 : wff = fvex () |- ( 2nd ` y ) ∈ _V ;;
	step 6 : wff = biantru (step 5) |- ( ( 1st ` y ) ∈ { x } ↔ ( ( 1st ` y ) ∈ { x } ∧ ( 2nd ` y ) ∈ _V ) ) ;;
	step 7 : wff = bitr3i (step 4, step 6) |- ( ( 1st ` y ) = x ↔ ( ( 1st ` y ) ∈ { x } ∧ ( 2nd ` y ) ∈ _V ) ) ;;
	step 8 : wff = syl6bb (step 2, step 7) |- ( y ∈ ( _V × _V ) → ( ( ( 1st ↾ ( _V × _V ) ) ` y ) = x ↔ ( ( 1st ` y ) ∈ { x } ∧ ( 2nd ` y ) ∈ _V ) ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( y ∈ ( _V × _V ) ∧ ( ( 1st ↾ ( _V × _V ) ) ` y ) = x ) ↔ ( y ∈ ( _V × _V ) ∧ ( ( 1st ` y ) ∈ { x } ∧ ( 2nd ` y ) ∈ _V ) ) ) ;;
	step 10 : wff = f1stres () |- ( 1st ↾ ( _V × _V ) ) : ( _V × _V ) ⟶ _V ;;
	step 11 : wff = ffn () |- ( ( 1st ↾ ( _V × _V ) ) : ( _V × _V ) ⟶ _V → ( 1st ↾ ( _V × _V ) ) Fn ( _V × _V ) ) ;;
	step 12 : wff = fniniseg () |- ( ( 1st ↾ ( _V × _V ) ) Fn ( _V × _V ) → ( y ∈ ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ↔ ( y ∈ ( _V × _V ) ∧ ( ( 1st ↾ ( _V × _V ) ) ` y ) = x ) ) ) ;;
	step 13 : wff = mp2b (step 10, step 11, step 12) |- ( y ∈ ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ↔ ( y ∈ ( _V × _V ) ∧ ( ( 1st ↾ ( _V × _V ) ) ` y ) = x ) ) ;;
	step 14 : wff = elxp7 () |- ( y ∈ ( { x } × _V ) ↔ ( y ∈ ( _V × _V ) ∧ ( ( 1st ` y ) ∈ { x } ∧ ( 2nd ` y ) ∈ _V ) ) ) ;;
	step 15 : wff = 3bitr4i (step 9, step 13, step 14) |- ( y ∈ ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ↔ y ∈ ( { x } × _V ) ) ;;
	step 16 : wff = eqriv (step 15) |- ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) = ( { x } × _V ) ;;
	qed prop 1 = step 16 ;;
}

/* Lemma for ~ fpar .  (Contributed by NM, 22-Dec-2008.)  (Revised by Mario
       Carneiro, 28-Apr-2015.) */

theorem fparlem2 (y : set) disjointed(x y, x y, x y) {
	prop 1 : wff = |- ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) = ( _V × { y } ) ;;
}

proof of fparlem2 {
	var x : set;;
	step 1 : wff = fvres () |- ( x ∈ ( _V × _V ) → ( ( 2nd ↾ ( _V × _V ) ) ` x ) = ( 2nd ` x ) ) ;;
	step 2 : wff = eqeq1d (step 1) |- ( x ∈ ( _V × _V ) → ( ( ( 2nd ↾ ( _V × _V ) ) ` x ) = y ↔ ( 2nd ` x ) = y ) ) ;;
	step 3 : wff = vex () |- y ∈ _V ;;
	step 4 : wff = elsnc2 (step 3) |- ( ( 2nd ` x ) ∈ { y } ↔ ( 2nd ` x ) = y ) ;;
	step 5 : wff = fvex () |- ( 1st ` x ) ∈ _V ;;
	step 6 : wff = biantrur (step 5) |- ( ( 2nd ` x ) ∈ { y } ↔ ( ( 1st ` x ) ∈ _V ∧ ( 2nd ` x ) ∈ { y } ) ) ;;
	step 7 : wff = bitr3i (step 4, step 6) |- ( ( 2nd ` x ) = y ↔ ( ( 1st ` x ) ∈ _V ∧ ( 2nd ` x ) ∈ { y } ) ) ;;
	step 8 : wff = syl6bb (step 2, step 7) |- ( x ∈ ( _V × _V ) → ( ( ( 2nd ↾ ( _V × _V ) ) ` x ) = y ↔ ( ( 1st ` x ) ∈ _V ∧ ( 2nd ` x ) ∈ { y } ) ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( x ∈ ( _V × _V ) ∧ ( ( 2nd ↾ ( _V × _V ) ) ` x ) = y ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ _V ∧ ( 2nd ` x ) ∈ { y } ) ) ) ;;
	step 10 : wff = f2ndres () |- ( 2nd ↾ ( _V × _V ) ) : ( _V × _V ) ⟶ _V ;;
	step 11 : wff = ffn () |- ( ( 2nd ↾ ( _V × _V ) ) : ( _V × _V ) ⟶ _V → ( 2nd ↾ ( _V × _V ) ) Fn ( _V × _V ) ) ;;
	step 12 : wff = fniniseg () |- ( ( 2nd ↾ ( _V × _V ) ) Fn ( _V × _V ) → ( x ∈ ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 2nd ↾ ( _V × _V ) ) ` x ) = y ) ) ) ;;
	step 13 : wff = mp2b (step 10, step 11, step 12) |- ( x ∈ ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 2nd ↾ ( _V × _V ) ) ` x ) = y ) ) ;;
	step 14 : wff = elxp7 () |- ( x ∈ ( _V × { y } ) ↔ ( x ∈ ( _V × _V ) ∧ ( ( 1st ` x ) ∈ _V ∧ ( 2nd ` x ) ∈ { y } ) ) ) ;;
	step 15 : wff = 3bitr4i (step 9, step 13, step 14) |- ( x ∈ ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ↔ x ∈ ( _V × { y } ) ) ;;
	step 16 : wff = eqriv (step 15) |- ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) = ( _V × { y } ) ;;
	qed prop 1 = step 16 ;;
}

/* Lemma for ~ fpar .  (Contributed by NM, 22-Dec-2008.)  (Revised by Mario
       Carneiro, 28-Apr-2015.) */

theorem fparlem3 (x : set, A : class, F : class) disjointed(x A, x y F, x y, x y) {
	prop 1 : wff = |- ( F Fn A → ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( F ∘ ( 1st ↾ ( _V × _V ) ) ) ) = ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ) ;;
}

proof of fparlem3 {
	var y : set;;
	step 1 : wff = coiun () |- ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ⋃_ x ∈ A ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) = ⋃_ x ∈ A ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ;;
	step 2 : wff = inss1 () |- ( dom F ∩ ran ( 1st ↾ ( _V × _V ) ) ) ⊆ dom F ;;
	step 3 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 4 : wff = syl5sseq (step 2, step 3) |- ( F Fn A → ( dom F ∩ ran ( 1st ↾ ( _V × _V ) ) ) ⊆ A ) ;;
	step 5 : wff = dfco2a () |- ( ( dom F ∩ ran ( 1st ↾ ( _V × _V ) ) ) ⊆ A → ( F ∘ ( 1st ↾ ( _V × _V ) ) ) = ⋃_ x ∈ A ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( F Fn A → ( F ∘ ( 1st ↾ ( _V × _V ) ) ) = ⋃_ x ∈ A ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ;;
	step 7 : wff = coeq2d (step 6) |- ( F Fn A → ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( F ∘ ( 1st ↾ ( _V × _V ) ) ) ) = ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ⋃_ x ∈ A ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ) ;;
	step 8 : wff = inss1 () |- ( dom ( { ( F ` x ) } × ( { x } × _V ) ) ∩ ran ( 1st ↾ ( _V × _V ) ) ) ⊆ dom ( { ( F ` x ) } × ( { x } × _V ) ) ;;
	step 9 : wff = dmxpss () |- dom ( { ( F ` x ) } × ( { x } × _V ) ) ⊆ { ( F ` x ) } ;;
	step 10 : wff = sstri (step 8, step 9) |- ( dom ( { ( F ` x ) } × ( { x } × _V ) ) ∩ ran ( 1st ↾ ( _V × _V ) ) ) ⊆ { ( F ` x ) } ;;
	step 11 : wff = dfco2a () |- ( ( dom ( { ( F ` x ) } × ( { x } × _V ) ) ∩ ran ( 1st ↾ ( _V × _V ) ) ) ⊆ { ( F ` x ) } → ( ( { ( F ` x ) } × ( { x } × _V ) ) ∘ ( 1st ↾ ( _V × _V ) ) ) = ⋃_ y ∈ { ( F ` x ) } ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { y } ) × ( ( { ( F ` x ) } × ( { x } × _V ) ) " { y } ) ) ) ;;
	step 12 : wff = ax-mp (step 10, step 11) |- ( ( { ( F ` x ) } × ( { x } × _V ) ) ∘ ( 1st ↾ ( _V × _V ) ) ) = ⋃_ y ∈ { ( F ` x ) } ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { y } ) × ( ( { ( F ` x ) } × ( { x } × _V ) ) " { y } ) ) ;;
	step 13 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 14 : wff = fparlem1 () |- ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { y } ) = ( { y } × _V ) ;;
	step 15 : wff = sneq () |- ( y = ( F ` x ) → { y } = { ( F ` x ) } ) ;;
	step 16 : wff = xpeq1d (step 15) |- ( y = ( F ` x ) → ( { y } × _V ) = ( { ( F ` x ) } × _V ) ) ;;
	step 17 : wff = syl5eq (step 14, step 16) |- ( y = ( F ` x ) → ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { y } ) = ( { ( F ` x ) } × _V ) ) ;;
	step 18 : wff = sneq () |- ( y = ( F ` x ) → { y } = { ( F ` x ) } ) ;;
	step 19 : wff = imaeq2d (step 18) |- ( y = ( F ` x ) → ( ( { ( F ` x ) } × ( { x } × _V ) ) " { y } ) = ( ( { ( F ` x ) } × ( { x } × _V ) ) " { ( F ` x ) } ) ) ;;
	step 20 : wff = df-ima () |- ( ( { ( F ` x ) } × ( { x } × _V ) ) " { ( F ` x ) } ) = ran ( ( { ( F ` x ) } × ( { x } × _V ) ) ↾ { ( F ` x ) } ) ;;
	step 21 : wff = ssid () |- { ( F ` x ) } ⊆ { ( F ` x ) } ;;
	step 22 : wff = xpssres () |- ( { ( F ` x ) } ⊆ { ( F ` x ) } → ( ( { ( F ` x ) } × ( { x } × _V ) ) ↾ { ( F ` x ) } ) = ( { ( F ` x ) } × ( { x } × _V ) ) ) ;;
	step 23 : wff = ax-mp (step 21, step 22) |- ( ( { ( F ` x ) } × ( { x } × _V ) ) ↾ { ( F ` x ) } ) = ( { ( F ` x ) } × ( { x } × _V ) ) ;;
	step 24 : wff = rneqi (step 23) |- ran ( ( { ( F ` x ) } × ( { x } × _V ) ) ↾ { ( F ` x ) } ) = ran ( { ( F ` x ) } × ( { x } × _V ) ) ;;
	step 25 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 26 : wff = snnz (step 25) |- { ( F ` x ) } ≠ ∅ ;;
	step 27 : wff = rnxp () |- ( { ( F ` x ) } ≠ ∅ → ran ( { ( F ` x ) } × ( { x } × _V ) ) = ( { x } × _V ) ) ;;
	step 28 : wff = ax-mp (step 26, step 27) |- ran ( { ( F ` x ) } × ( { x } × _V ) ) = ( { x } × _V ) ;;
	step 29 : wff = eqtri (step 24, step 28) |- ran ( ( { ( F ` x ) } × ( { x } × _V ) ) ↾ { ( F ` x ) } ) = ( { x } × _V ) ;;
	step 30 : wff = eqtri (step 20, step 29) |- ( ( { ( F ` x ) } × ( { x } × _V ) ) " { ( F ` x ) } ) = ( { x } × _V ) ;;
	step 31 : wff = syl6eq (step 19, step 30) |- ( y = ( F ` x ) → ( ( { ( F ` x ) } × ( { x } × _V ) ) " { y } ) = ( { x } × _V ) ) ;;
	step 32 : wff = xpeq12d (step 17, step 31) |- ( y = ( F ` x ) → ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { y } ) × ( ( { ( F ` x ) } × ( { x } × _V ) ) " { y } ) ) = ( ( { ( F ` x ) } × _V ) × ( { x } × _V ) ) ) ;;
	step 33 : wff = iunxsn (step 13, step 32) |- ⋃_ y ∈ { ( F ` x ) } ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { y } ) × ( ( { ( F ` x ) } × ( { x } × _V ) ) " { y } ) ) = ( ( { ( F ` x ) } × _V ) × ( { x } × _V ) ) ;;
	step 34 : wff = eqtri (step 12, step 33) |- ( ( { ( F ` x ) } × ( { x } × _V ) ) ∘ ( 1st ↾ ( _V × _V ) ) ) = ( ( { ( F ` x ) } × _V ) × ( { x } × _V ) ) ;;
	step 35 : wff = cnveqi (step 34) |- ⁻¹ ( ( { ( F ` x ) } × ( { x } × _V ) ) ∘ ( 1st ↾ ( _V × _V ) ) ) = ⁻¹ ( ( { ( F ` x ) } × _V ) × ( { x } × _V ) ) ;;
	step 36 : wff = cnvco () |- ⁻¹ ( ( { ( F ` x ) } × ( { x } × _V ) ) ∘ ( 1st ↾ ( _V × _V ) ) ) = ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ⁻¹ ( { ( F ` x ) } × ( { x } × _V ) ) ) ;;
	step 37 : wff = cnvxp () |- ⁻¹ ( ( { ( F ` x ) } × _V ) × ( { x } × _V ) ) = ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ;;
	step 38 : wff = 3eqtr3i (step 35, step 36, step 37) |- ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ⁻¹ ( { ( F ` x ) } × ( { x } × _V ) ) ) = ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ;;
	step 39 : wff = fparlem1 () |- ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) = ( { x } × _V ) ;;
	step 40 : wff = xpeq2i (step 39) |- ( { ( F ` x ) } × ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ) = ( { ( F ` x ) } × ( { x } × _V ) ) ;;
	step 41 : wff = fnsnfv () |- ( ( F Fn A ∧ x ∈ A ) → { ( F ` x ) } = ( F " { x } ) ) ;;
	step 42 : wff = xpeq1d (step 41) |- ( ( F Fn A ∧ x ∈ A ) → ( { ( F ` x ) } × ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ) = ( ( F " { x } ) × ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ) ) ;;
	step 43 : wff = syl5eqr (step 40, step 42) |- ( ( F Fn A ∧ x ∈ A ) → ( { ( F ` x ) } × ( { x } × _V ) ) = ( ( F " { x } ) × ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ) ) ;;
	step 44 : wff = cnveqd (step 43) |- ( ( F Fn A ∧ x ∈ A ) → ⁻¹ ( { ( F ` x ) } × ( { x } × _V ) ) = ⁻¹ ( ( F " { x } ) × ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ) ) ;;
	step 45 : wff = cnvxp () |- ⁻¹ ( ( F " { x } ) × ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) ) = ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ;;
	step 46 : wff = syl6eq (step 44, step 45) |- ( ( F Fn A ∧ x ∈ A ) → ⁻¹ ( { ( F ` x ) } × ( { x } × _V ) ) = ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ;;
	step 47 : wff = coeq2d (step 46) |- ( ( F Fn A ∧ x ∈ A ) → ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ⁻¹ ( { ( F ` x ) } × ( { x } × _V ) ) ) = ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ) ;;
	step 48 : wff = syl5eqr (step 38, step 47) |- ( ( F Fn A ∧ x ∈ A ) → ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) = ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ) ;;
	step 49 : wff = iuneq2dv (step 48) |- ( F Fn A → ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) = ⋃_ x ∈ A ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) " { x } ) × ( F " { x } ) ) ) ) ;;
	step 50 : wff = 3eqtr4a (step 1, step 7, step 49) |- ( F Fn A → ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( F ∘ ( 1st ↾ ( _V × _V ) ) ) ) = ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ) ;;
	qed prop 1 = step 50 ;;
}

/* Lemma for ~ fpar .  (Contributed by NM, 22-Dec-2008.)  (Revised by Mario
       Carneiro, 28-Apr-2015.) */

theorem fparlem4 (y : set, B : class, G : class) disjointed(y B, x y, x y G, x y) {
	prop 1 : wff = |- ( G Fn B → ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) ) = ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) ;;
}

proof of fparlem4 {
	var x : set;;
	step 1 : wff = coiun () |- ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ⋃_ y ∈ B ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) = ⋃_ y ∈ B ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ;;
	step 2 : wff = inss1 () |- ( dom G ∩ ran ( 2nd ↾ ( _V × _V ) ) ) ⊆ dom G ;;
	step 3 : wff = fndm () |- ( G Fn B → dom G = B ) ;;
	step 4 : wff = syl5sseq (step 2, step 3) |- ( G Fn B → ( dom G ∩ ran ( 2nd ↾ ( _V × _V ) ) ) ⊆ B ) ;;
	step 5 : wff = dfco2a () |- ( ( dom G ∩ ran ( 2nd ↾ ( _V × _V ) ) ) ⊆ B → ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) = ⋃_ y ∈ B ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( G Fn B → ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) = ⋃_ y ∈ B ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ;;
	step 7 : wff = coeq2d (step 6) |- ( G Fn B → ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) ) = ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ⋃_ y ∈ B ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ) ;;
	step 8 : wff = inss1 () |- ( dom ( { ( G ` y ) } × ( _V × { y } ) ) ∩ ran ( 2nd ↾ ( _V × _V ) ) ) ⊆ dom ( { ( G ` y ) } × ( _V × { y } ) ) ;;
	step 9 : wff = dmxpss () |- dom ( { ( G ` y ) } × ( _V × { y } ) ) ⊆ { ( G ` y ) } ;;
	step 10 : wff = sstri (step 8, step 9) |- ( dom ( { ( G ` y ) } × ( _V × { y } ) ) ∩ ran ( 2nd ↾ ( _V × _V ) ) ) ⊆ { ( G ` y ) } ;;
	step 11 : wff = dfco2a () |- ( ( dom ( { ( G ` y ) } × ( _V × { y } ) ) ∩ ran ( 2nd ↾ ( _V × _V ) ) ) ⊆ { ( G ` y ) } → ( ( { ( G ` y ) } × ( _V × { y } ) ) ∘ ( 2nd ↾ ( _V × _V ) ) ) = ⋃_ x ∈ { ( G ` y ) } ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { x } ) × ( ( { ( G ` y ) } × ( _V × { y } ) ) " { x } ) ) ) ;;
	step 12 : wff = ax-mp (step 10, step 11) |- ( ( { ( G ` y ) } × ( _V × { y } ) ) ∘ ( 2nd ↾ ( _V × _V ) ) ) = ⋃_ x ∈ { ( G ` y ) } ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { x } ) × ( ( { ( G ` y ) } × ( _V × { y } ) ) " { x } ) ) ;;
	step 13 : wff = fvex () |- ( G ` y ) ∈ _V ;;
	step 14 : wff = fparlem2 () |- ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { x } ) = ( _V × { x } ) ;;
	step 15 : wff = sneq () |- ( x = ( G ` y ) → { x } = { ( G ` y ) } ) ;;
	step 16 : wff = xpeq2d (step 15) |- ( x = ( G ` y ) → ( _V × { x } ) = ( _V × { ( G ` y ) } ) ) ;;
	step 17 : wff = syl5eq (step 14, step 16) |- ( x = ( G ` y ) → ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { x } ) = ( _V × { ( G ` y ) } ) ) ;;
	step 18 : wff = sneq () |- ( x = ( G ` y ) → { x } = { ( G ` y ) } ) ;;
	step 19 : wff = imaeq2d (step 18) |- ( x = ( G ` y ) → ( ( { ( G ` y ) } × ( _V × { y } ) ) " { x } ) = ( ( { ( G ` y ) } × ( _V × { y } ) ) " { ( G ` y ) } ) ) ;;
	step 20 : wff = df-ima () |- ( ( { ( G ` y ) } × ( _V × { y } ) ) " { ( G ` y ) } ) = ran ( ( { ( G ` y ) } × ( _V × { y } ) ) ↾ { ( G ` y ) } ) ;;
	step 21 : wff = ssid () |- { ( G ` y ) } ⊆ { ( G ` y ) } ;;
	step 22 : wff = xpssres () |- ( { ( G ` y ) } ⊆ { ( G ` y ) } → ( ( { ( G ` y ) } × ( _V × { y } ) ) ↾ { ( G ` y ) } ) = ( { ( G ` y ) } × ( _V × { y } ) ) ) ;;
	step 23 : wff = ax-mp (step 21, step 22) |- ( ( { ( G ` y ) } × ( _V × { y } ) ) ↾ { ( G ` y ) } ) = ( { ( G ` y ) } × ( _V × { y } ) ) ;;
	step 24 : wff = rneqi (step 23) |- ran ( ( { ( G ` y ) } × ( _V × { y } ) ) ↾ { ( G ` y ) } ) = ran ( { ( G ` y ) } × ( _V × { y } ) ) ;;
	step 25 : wff = fvex () |- ( G ` y ) ∈ _V ;;
	step 26 : wff = snnz (step 25) |- { ( G ` y ) } ≠ ∅ ;;
	step 27 : wff = rnxp () |- ( { ( G ` y ) } ≠ ∅ → ran ( { ( G ` y ) } × ( _V × { y } ) ) = ( _V × { y } ) ) ;;
	step 28 : wff = ax-mp (step 26, step 27) |- ran ( { ( G ` y ) } × ( _V × { y } ) ) = ( _V × { y } ) ;;
	step 29 : wff = eqtri (step 24, step 28) |- ran ( ( { ( G ` y ) } × ( _V × { y } ) ) ↾ { ( G ` y ) } ) = ( _V × { y } ) ;;
	step 30 : wff = eqtri (step 20, step 29) |- ( ( { ( G ` y ) } × ( _V × { y } ) ) " { ( G ` y ) } ) = ( _V × { y } ) ;;
	step 31 : wff = syl6eq (step 19, step 30) |- ( x = ( G ` y ) → ( ( { ( G ` y ) } × ( _V × { y } ) ) " { x } ) = ( _V × { y } ) ) ;;
	step 32 : wff = xpeq12d (step 17, step 31) |- ( x = ( G ` y ) → ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { x } ) × ( ( { ( G ` y ) } × ( _V × { y } ) ) " { x } ) ) = ( ( _V × { ( G ` y ) } ) × ( _V × { y } ) ) ) ;;
	step 33 : wff = iunxsn (step 13, step 32) |- ⋃_ x ∈ { ( G ` y ) } ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { x } ) × ( ( { ( G ` y ) } × ( _V × { y } ) ) " { x } ) ) = ( ( _V × { ( G ` y ) } ) × ( _V × { y } ) ) ;;
	step 34 : wff = eqtri (step 12, step 33) |- ( ( { ( G ` y ) } × ( _V × { y } ) ) ∘ ( 2nd ↾ ( _V × _V ) ) ) = ( ( _V × { ( G ` y ) } ) × ( _V × { y } ) ) ;;
	step 35 : wff = cnveqi (step 34) |- ⁻¹ ( ( { ( G ` y ) } × ( _V × { y } ) ) ∘ ( 2nd ↾ ( _V × _V ) ) ) = ⁻¹ ( ( _V × { ( G ` y ) } ) × ( _V × { y } ) ) ;;
	step 36 : wff = cnvco () |- ⁻¹ ( ( { ( G ` y ) } × ( _V × { y } ) ) ∘ ( 2nd ↾ ( _V × _V ) ) ) = ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ⁻¹ ( { ( G ` y ) } × ( _V × { y } ) ) ) ;;
	step 37 : wff = cnvxp () |- ⁻¹ ( ( _V × { ( G ` y ) } ) × ( _V × { y } ) ) = ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ;;
	step 38 : wff = 3eqtr3i (step 35, step 36, step 37) |- ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ⁻¹ ( { ( G ` y ) } × ( _V × { y } ) ) ) = ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ;;
	step 39 : wff = fparlem2 () |- ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) = ( _V × { y } ) ;;
	step 40 : wff = xpeq2i (step 39) |- ( { ( G ` y ) } × ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ) = ( { ( G ` y ) } × ( _V × { y } ) ) ;;
	step 41 : wff = fnsnfv () |- ( ( G Fn B ∧ y ∈ B ) → { ( G ` y ) } = ( G " { y } ) ) ;;
	step 42 : wff = xpeq1d (step 41) |- ( ( G Fn B ∧ y ∈ B ) → ( { ( G ` y ) } × ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ) = ( ( G " { y } ) × ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ) ) ;;
	step 43 : wff = syl5eqr (step 40, step 42) |- ( ( G Fn B ∧ y ∈ B ) → ( { ( G ` y ) } × ( _V × { y } ) ) = ( ( G " { y } ) × ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ) ) ;;
	step 44 : wff = cnveqd (step 43) |- ( ( G Fn B ∧ y ∈ B ) → ⁻¹ ( { ( G ` y ) } × ( _V × { y } ) ) = ⁻¹ ( ( G " { y } ) × ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ) ) ;;
	step 45 : wff = cnvxp () |- ⁻¹ ( ( G " { y } ) × ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) ) = ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ;;
	step 46 : wff = syl6eq (step 44, step 45) |- ( ( G Fn B ∧ y ∈ B ) → ⁻¹ ( { ( G ` y ) } × ( _V × { y } ) ) = ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ;;
	step 47 : wff = coeq2d (step 46) |- ( ( G Fn B ∧ y ∈ B ) → ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ⁻¹ ( { ( G ` y ) } × ( _V × { y } ) ) ) = ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ) ;;
	step 48 : wff = syl5eqr (step 38, step 47) |- ( ( G Fn B ∧ y ∈ B ) → ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) = ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ) ;;
	step 49 : wff = iuneq2dv (step 48) |- ( G Fn B → ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) = ⋃_ y ∈ B ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) " { y } ) × ( G " { y } ) ) ) ) ;;
	step 50 : wff = 3eqtr4a (step 1, step 7, step 49) |- ( G Fn B → ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) ) = ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) ;;
	qed prop 1 = step 50 ;;
}

/* Merge two functions in parallel.  Use as the second argument of a
       composition with a (2-place) operation to build compound operations such
       as ` z = ( ( sqr `` x ) + ( abs `` y ) ) ` .  (Contributed by NM,
       17-Sep-2007.)  (Proof shortened by Mario Carneiro, 28-Apr-2015.) */

theorem fpar (x : set, y : set, A : class, B : class, F : class, G : class, H : class) disjointed(x y A, x y B, x y F, x y G) {
	hyp 1 : wff = |- H = ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( F ∘ ( 1st ↾ ( _V × _V ) ) ) ) ∩ ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( F Fn A ∧ G Fn B ) → H = ( x ∈ A , y ∈ B ↦ 〈 ( F ` x ) , ( G ` y ) 〉 ) ) ;;
}

proof of fpar {
	step 1 : wff = fparlem3 () |- ( F Fn A → ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( F ∘ ( 1st ↾ ( _V × _V ) ) ) ) = ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ) ;;
	step 2 : wff = fparlem4 () |- ( G Fn B → ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) ) = ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) ;;
	step 3 : wff = ineqan12d (step 1, step 2) |- ( ( F Fn A ∧ G Fn B ) → ( ( ⁻¹ ( 1st ↾ ( _V × _V ) ) ∘ ( F ∘ ( 1st ↾ ( _V × _V ) ) ) ) ∩ ( ⁻¹ ( 2nd ↾ ( _V × _V ) ) ∘ ( G ∘ ( 2nd ↾ ( _V × _V ) ) ) ) ) = ( ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) ) ;;
	step 4 : wff = opex () |- 〈 ( F ` x ) , ( G ` y ) 〉 ∈ _V ;;
	step 5 : wff = dfmpt2 (step 4) |- ( x ∈ A , y ∈ B ↦ 〈 ( F ` x ) , ( G ` y ) 〉 ) = ⋃_ x ∈ A ⋃_ y ∈ B { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ;;
	step 6 : wff = inxp () |- ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = ( ( ( { x } × _V ) ∩ ( _V × { y } ) ) × ( ( { ( F ` x ) } × _V ) ∩ ( _V × { ( G ` y ) } ) ) ) ;;
	step 7 : wff = inxp () |- ( ( { x } × _V ) ∩ ( _V × { y } ) ) = ( ( { x } ∩ _V ) × ( _V ∩ { y } ) ) ;;
	step 8 : wff = inv1 () |- ( { x } ∩ _V ) = { x } ;;
	step 9 : wff = incom () |- ( _V ∩ { y } ) = ( { y } ∩ _V ) ;;
	step 10 : wff = inv1 () |- ( { y } ∩ _V ) = { y } ;;
	step 11 : wff = eqtri (step 9, step 10) |- ( _V ∩ { y } ) = { y } ;;
	step 12 : wff = xpeq12i (step 8, step 11) |- ( ( { x } ∩ _V ) × ( _V ∩ { y } ) ) = ( { x } × { y } ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = xpsn (step 13, step 14) |- ( { x } × { y } ) = { 〈 x , y 〉 } ;;
	step 16 : wff = 3eqtri (step 7, step 12, step 15) |- ( ( { x } × _V ) ∩ ( _V × { y } ) ) = { 〈 x , y 〉 } ;;
	step 17 : wff = inxp () |- ( ( { ( F ` x ) } × _V ) ∩ ( _V × { ( G ` y ) } ) ) = ( ( { ( F ` x ) } ∩ _V ) × ( _V ∩ { ( G ` y ) } ) ) ;;
	step 18 : wff = inv1 () |- ( { ( F ` x ) } ∩ _V ) = { ( F ` x ) } ;;
	step 19 : wff = incom () |- ( _V ∩ { ( G ` y ) } ) = ( { ( G ` y ) } ∩ _V ) ;;
	step 20 : wff = inv1 () |- ( { ( G ` y ) } ∩ _V ) = { ( G ` y ) } ;;
	step 21 : wff = eqtri (step 19, step 20) |- ( _V ∩ { ( G ` y ) } ) = { ( G ` y ) } ;;
	step 22 : wff = xpeq12i (step 18, step 21) |- ( ( { ( F ` x ) } ∩ _V ) × ( _V ∩ { ( G ` y ) } ) ) = ( { ( F ` x ) } × { ( G ` y ) } ) ;;
	step 23 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 24 : wff = fvex () |- ( G ` y ) ∈ _V ;;
	step 25 : wff = xpsn (step 23, step 24) |- ( { ( F ` x ) } × { ( G ` y ) } ) = { 〈 ( F ` x ) , ( G ` y ) 〉 } ;;
	step 26 : wff = 3eqtri (step 17, step 22, step 25) |- ( ( { ( F ` x ) } × _V ) ∩ ( _V × { ( G ` y ) } ) ) = { 〈 ( F ` x ) , ( G ` y ) 〉 } ;;
	step 27 : wff = xpeq12i (step 16, step 26) |- ( ( ( { x } × _V ) ∩ ( _V × { y } ) ) × ( ( { ( F ` x ) } × _V ) ∩ ( _V × { ( G ` y ) } ) ) ) = ( { 〈 x , y 〉 } × { 〈 ( F ` x ) , ( G ` y ) 〉 } ) ;;
	step 28 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 29 : wff = opex () |- 〈 ( F ` x ) , ( G ` y ) 〉 ∈ _V ;;
	step 30 : wff = xpsn (step 28, step 29) |- ( { 〈 x , y 〉 } × { 〈 ( F ` x ) , ( G ` y ) 〉 } ) = { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ;;
	step 31 : wff = 3eqtri (step 6, step 27, step 30) |- ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ;;
	step 32 : wff = a1i (step 31) |- ( y ∈ B → ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ) ;;
	step 33 : wff = iuneq2i (step 32) |- ⋃_ y ∈ B ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = ⋃_ y ∈ B { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ;;
	step 34 : wff = a1i (step 33) |- ( x ∈ A → ⋃_ y ∈ B ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = ⋃_ y ∈ B { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ) ;;
	step 35 : wff = iuneq2i (step 34) |- ⋃_ x ∈ A ⋃_ y ∈ B ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = ⋃_ x ∈ A ⋃_ y ∈ B { 〈 〈 x , y 〉 , 〈 ( F ` x ) , ( G ` y ) 〉 〉 } ;;
	step 36 : wff = 2iunin () |- ⋃_ x ∈ A ⋃_ y ∈ B ( ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) = ( ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) ;;
	step 37 : wff = 3eqtr2i (step 5, step 35, step 36) |- ( x ∈ A , y ∈ B ↦ 〈 ( F ` x ) , ( G ` y ) 〉 ) = ( ⋃_ x ∈ A ( ( { x } × _V ) × ( { ( F ` x ) } × _V ) ) ∩ ⋃_ y ∈ B ( ( _V × { y } ) × ( _V × { ( G ` y ) } ) ) ) ;;
	step 38 : wff = 3eqtr4g (step 3, hyp 1, step 37) |- ( ( F Fn A ∧ G Fn B ) → H = ( x ∈ A , y ∈ B ↦ 〈 ( F ` x ) , ( G ` y ) 〉 ) ) ;;
	qed prop 1 = step 38 ;;
}

/* A function that can be used to feed a common value to both operands of
       an operation.  Use as the second argument of a composition with the
       function of ~ fpar in order to build compound functions such as
       ` y = ( ( sqr `` x ) + ( abs `` x ) ) ` .  (Contributed by NM,
       17-Sep-2007.) */

theorem fsplit (x : set) disjointed(x y z) {
	prop 1 : wff = |- ⁻¹ ( 1st ↾ _I ) = ( x ∈ _V ↦ 〈 x , x 〉 ) ;;
}

proof of fsplit {
	var y : set, z : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = brcnv (step 1, step 2) |- ( x ⁻¹ ( 1st ↾ _I ) y ↔ y ( 1st ↾ _I ) x ) ;;
	step 4 : wff = vex () |- x ∈ _V ;;
	step 5 : wff = brres (step 4) |- ( y ( 1st ↾ _I ) x ↔ ( y 1st x ∧ y ∈ _I ) ) ;;
	step 6 : wff = 19.42v () |- ( ∃ z ( ( 1st ` y ) = x ∧ y = 〈 z , z 〉 ) ↔ ( ( 1st ` y ) = x ∧ ∃ z y = 〈 z , z 〉 ) ) ;;
	step 7 : wff = vex () |- z ∈ _V ;;
	step 8 : wff = vex () |- z ∈ _V ;;
	step 9 : wff = op1std (step 7, step 8) |- ( y = 〈 z , z 〉 → ( 1st ` y ) = z ) ;;
	step 10 : wff = eqeq1d (step 9) |- ( y = 〈 z , z 〉 → ( ( 1st ` y ) = x ↔ z = x ) ) ;;
	step 11 : wff = pm5.32ri (step 10) |- ( ( ( 1st ` y ) = x ∧ y = 〈 z , z 〉 ) ↔ ( z = x ∧ y = 〈 z , z 〉 ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ z ( ( 1st ` y ) = x ∧ y = 〈 z , z 〉 ) ↔ ∃ z ( z = x ∧ y = 〈 z , z 〉 ) ) ;;
	step 13 : wff = fo1st () |- 1st : _V ↠ _V ;;
	step 14 : wff = fofn () |- ( 1st : _V ↠ _V → 1st Fn _V ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- 1st Fn _V ;;
	step 16 : wff = vex () |- y ∈ _V ;;
	step 17 : wff = fnbrfvb () |- ( ( 1st Fn _V ∧ y ∈ _V ) → ( ( 1st ` y ) = x ↔ y 1st x ) ) ;;
	step 18 : wff = mp2an (step 15, step 16, step 17) |- ( ( 1st ` y ) = x ↔ y 1st x ) ;;
	step 19 : wff = dfid2 () |- _I = { 〈 z , z 〉 | z = z } ;;
	step 20 : wff = eleq2i (step 19) |- ( y ∈ _I ↔ y ∈ { 〈 z , z 〉 | z = z } ) ;;
	step 21 : wff = nfe1 () |- F/ z ∃ z ( y = 〈 z , z 〉 ∧ z = z ) ;;
	step 22 : wff = 19.9 (step 21) |- ( ∃ z ∃ z ( y = 〈 z , z 〉 ∧ z = z ) ↔ ∃ z ( y = 〈 z , z 〉 ∧ z = z ) ) ;;
	step 23 : wff = elopab () |- ( y ∈ { 〈 z , z 〉 | z = z } ↔ ∃ z ∃ z ( y = 〈 z , z 〉 ∧ z = z ) ) ;;
	step 24 : wff = equid () |- z = z ;;
	step 25 : wff = biantru (step 24) |- ( y = 〈 z , z 〉 ↔ ( y = 〈 z , z 〉 ∧ z = z ) ) ;;
	step 26 : wff = exbii (step 25) |- ( ∃ z y = 〈 z , z 〉 ↔ ∃ z ( y = 〈 z , z 〉 ∧ z = z ) ) ;;
	step 27 : wff = 3bitr4i (step 22, step 23, step 26) |- ( y ∈ { 〈 z , z 〉 | z = z } ↔ ∃ z y = 〈 z , z 〉 ) ;;
	step 28 : wff = bitr2i (step 20, step 27) |- ( ∃ z y = 〈 z , z 〉 ↔ y ∈ _I ) ;;
	step 29 : wff = anbi12i (step 18, step 28) |- ( ( ( 1st ` y ) = x ∧ ∃ z y = 〈 z , z 〉 ) ↔ ( y 1st x ∧ y ∈ _I ) ) ;;
	step 30 : wff = 3bitr3ri (step 6, step 12, step 29) |- ( ( y 1st x ∧ y ∈ _I ) ↔ ∃ z ( z = x ∧ y = 〈 z , z 〉 ) ) ;;
	step 31 : wff = vex () |- x ∈ _V ;;
	step 32 : wff = id () |- ( z = x → z = x ) ;;
	step 33 : wff = id () |- ( z = x → z = x ) ;;
	step 34 : wff = opeq12d (step 32, step 33) |- ( z = x → 〈 z , z 〉 = 〈 x , x 〉 ) ;;
	step 35 : wff = eqeq2d (step 34) |- ( z = x → ( y = 〈 z , z 〉 ↔ y = 〈 x , x 〉 ) ) ;;
	step 36 : wff = ceqsexv (step 31, step 35) |- ( ∃ z ( z = x ∧ y = 〈 z , z 〉 ) ↔ y = 〈 x , x 〉 ) ;;
	step 37 : wff = bitri (step 30, step 36) |- ( ( y 1st x ∧ y ∈ _I ) ↔ y = 〈 x , x 〉 ) ;;
	step 38 : wff = bitri (step 5, step 37) |- ( y ( 1st ↾ _I ) x ↔ y = 〈 x , x 〉 ) ;;
	step 39 : wff = bitri (step 3, step 38) |- ( x ⁻¹ ( 1st ↾ _I ) y ↔ y = 〈 x , x 〉 ) ;;
	step 40 : wff = opabbii (step 39) |- { 〈 x , y 〉 | x ⁻¹ ( 1st ↾ _I ) y } = { 〈 x , y 〉 | y = 〈 x , x 〉 } ;;
	step 41 : wff = relcnv () |- Rel ⁻¹ ( 1st ↾ _I ) ;;
	step 42 : wff = dfrel4v () |- ( Rel ⁻¹ ( 1st ↾ _I ) ↔ ⁻¹ ( 1st ↾ _I ) = { 〈 x , y 〉 | x ⁻¹ ( 1st ↾ _I ) y } ) ;;
	step 43 : wff = mpbi (step 41, step 42) |- ⁻¹ ( 1st ↾ _I ) = { 〈 x , y 〉 | x ⁻¹ ( 1st ↾ _I ) y } ;;
	step 44 : wff = mptv () |- ( x ∈ _V ↦ 〈 x , x 〉 ) = { 〈 x , y 〉 | y = 〈 x , x 〉 } ;;
	step 45 : wff = 3eqtr4i (step 40, step 43, step 44) |- ⁻¹ ( 1st ↾ _I ) = ( x ∈ _V ↦ 〈 x , x 〉 ) ;;
	qed prop 1 = step 45 ;;
}

/* Lemma for ~ algrf and related theorems.  (Contributed by Mario Carneiro,
       28-May-2014.)  (Revised by Mario Carneiro, 30-Apr-2015.) */

theorem algrflem (B : class, C : class, F : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( B ( F ∘ 1st ) C ) = ( F ` B ) ;;
}

proof of algrflem {
	step 1 : wff = df-ov () |- ( B ( F ∘ 1st ) C ) = ( ( F ∘ 1st ) ` 〈 B , C 〉 ) ;;
	step 2 : wff = fo1st () |- 1st : _V ↠ _V ;;
	step 3 : wff = fof () |- ( 1st : _V ↠ _V → 1st : _V ⟶ _V ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- 1st : _V ⟶ _V ;;
	step 5 : wff = opex () |- 〈 B , C 〉 ∈ _V ;;
	step 6 : wff = fvco3 () |- ( ( 1st : _V ⟶ _V ∧ 〈 B , C 〉 ∈ _V ) → ( ( F ∘ 1st ) ` 〈 B , C 〉 ) = ( F ` ( 1st ` 〈 B , C 〉 ) ) ) ;;
	step 7 : wff = mp2an (step 4, step 5, step 6) |- ( ( F ∘ 1st ) ` 〈 B , C 〉 ) = ( F ` ( 1st ` 〈 B , C 〉 ) ) ;;
	step 8 : wff = op1st (hyp 1, hyp 2) |- ( 1st ` 〈 B , C 〉 ) = B ;;
	step 9 : wff = fveq2i (step 8) |- ( F ` ( 1st ` 〈 B , C 〉 ) ) = ( F ` B ) ;;
	step 10 : wff = 3eqtri (step 1, step 7, step 9) |- ( B ( F ∘ 1st ) C ) = ( F ` B ) ;;
	qed prop 1 = step 10 ;;
}

/* A lexicographical ordering of two well-founded classes.  (Contributed by
       Scott Fenton, 17-Mar-2011.)  (Revised by Mario Carneiro, 7-Mar-2013.)
       (Proof shortened by Wolf Lammen, 4-Oct-2014.) */

theorem frxp (x : set, y : set, A : class, B : class, R : class, S : class, T : class) disjointed(A a b c s v w x y z, B a b d s v w x y z, R a b c s v w x y, S a b d s t u v w x y, T a b s w z) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( R Fr A ∧ S Fr B ) → T Fr ( A × B ) ) ;;
}

proof of frxp {
	var z : set, w : set, v : set, u : set, t : set, s : set, a : set, b : set, c : set, d : set;;
	step 1 : wff = ssn0 () |- ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( A × B ) ≠ ∅ ) ;;
	step 2 : wff = xpnz () |- ( ( A ≠ ∅ ∧ B ≠ ∅ ) ↔ ( A × B ) ≠ ∅ ) ;;
	step 3 : wff = biimpri (step 2) |- ( ( A × B ) ≠ ∅ → ( A ≠ ∅ ∧ B ≠ ∅ ) ) ;;
	step 4 : wff = simprd (step 3) |- ( ( A × B ) ≠ ∅ → B ≠ ∅ ) ;;
	step 5 : wff = syl (step 1, step 4) |- ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → B ≠ ∅ ) ;;
	step 6 : wff = dmxp () |- ( B ≠ ∅ → dom ( A × B ) = A ) ;;
	step 7 : wff = dmss () |- ( s ⊆ ( A × B ) → dom s ⊆ dom ( A × B ) ) ;;
	step 8 : wff = sseq2 () |- ( dom ( A × B ) = A → ( dom s ⊆ dom ( A × B ) ↔ dom s ⊆ A ) ) ;;
	step 9 : wff = syl5ib (step 7, step 8) |- ( dom ( A × B ) = A → ( s ⊆ ( A × B ) → dom s ⊆ A ) ) ;;
	step 10 : wff = syl (step 6, step 9) |- ( B ≠ ∅ → ( s ⊆ ( A × B ) → dom s ⊆ A ) ) ;;
	step 11 : wff = impcom (step 10) |- ( ( s ⊆ ( A × B ) ∧ B ≠ ∅ ) → dom s ⊆ A ) ;;
	step 12 : wff = syldan (step 5, step 11) |- ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → dom s ⊆ A ) ;;
	step 13 : wff = relxp () |- Rel ( A × B ) ;;
	step 14 : wff = relss () |- ( s ⊆ ( A × B ) → ( Rel ( A × B ) → Rel s ) ) ;;
	step 15 : wff = mpi (step 13, step 14) |- ( s ⊆ ( A × B ) → Rel s ) ;;
	step 16 : wff = reldm0 () |- ( Rel s → ( s = ∅ ↔ dom s = ∅ ) ) ;;
	step 17 : wff = syl (step 15, step 16) |- ( s ⊆ ( A × B ) → ( s = ∅ ↔ dom s = ∅ ) ) ;;
	step 18 : wff = necon3bid (step 17) |- ( s ⊆ ( A × B ) → ( s ≠ ∅ ↔ dom s ≠ ∅ ) ) ;;
	step 19 : wff = biimpa (step 18) |- ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → dom s ≠ ∅ ) ;;
	step 20 : wff = jca (step 12, step 19) |- ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( dom s ⊆ A ∧ dom s ≠ ∅ ) ) ;;
	step 21 : wff = df-fr () |- ( R Fr A ↔ ∀ v ( ( v ⊆ A ∧ v ≠ ∅ ) → ∃ a ∈ v ∀ c ∈ v ¬ c R a ) ) ;;
	step 22 : wff = vex () |- s ∈ _V ;;
	step 23 : wff = dmex (step 22) |- dom s ∈ _V ;;
	step 24 : wff = sseq1 () |- ( v = dom s → ( v ⊆ A ↔ dom s ⊆ A ) ) ;;
	step 25 : wff = neeq1 () |- ( v = dom s → ( v ≠ ∅ ↔ dom s ≠ ∅ ) ) ;;
	step 26 : wff = anbi12d (step 24, step 25) |- ( v = dom s → ( ( v ⊆ A ∧ v ≠ ∅ ) ↔ ( dom s ⊆ A ∧ dom s ≠ ∅ ) ) ) ;;
	step 27 : wff = raleq () |- ( v = dom s → ( ∀ c ∈ v ¬ c R a ↔ ∀ c ∈ dom s ¬ c R a ) ) ;;
	step 28 : wff = rexeqbi1dv (step 27) |- ( v = dom s → ( ∃ a ∈ v ∀ c ∈ v ¬ c R a ↔ ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a ) ) ;;
	step 29 : wff = imbi12d (step 26, step 28) |- ( v = dom s → ( ( ( v ⊆ A ∧ v ≠ ∅ ) → ∃ a ∈ v ∀ c ∈ v ¬ c R a ) ↔ ( ( dom s ⊆ A ∧ dom s ≠ ∅ ) → ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a ) ) ) ;;
	step 30 : wff = spcv (step 23, step 29) |- ( ∀ v ( ( v ⊆ A ∧ v ≠ ∅ ) → ∃ a ∈ v ∀ c ∈ v ¬ c R a ) → ( ( dom s ⊆ A ∧ dom s ≠ ∅ ) → ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a ) ) ;;
	step 31 : wff = sylbi (step 21, step 30) |- ( R Fr A → ( ( dom s ⊆ A ∧ dom s ≠ ∅ ) → ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a ) ) ;;
	step 32 : wff = syl5 (step 20, step 31) |- ( R Fr A → ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a ) ) ;;
	step 33 : wff = adantr (step 32) |- ( ( R Fr A ∧ S Fr B ) → ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a ) ) ;;
	step 34 : wff = imassrn () |- ( s " { a } ) ⊆ ran s ;;
	step 35 : wff = xpeq0 () |- ( ( A × B ) = ∅ ↔ ( A = ∅ ∨ B = ∅ ) ) ;;
	step 36 : wff = biimpri (step 35) |- ( ( A = ∅ ∨ B = ∅ ) → ( A × B ) = ∅ ) ;;
	step 37 : wff = orcs (step 36) |- ( A = ∅ → ( A × B ) = ∅ ) ;;
	step 38 : wff = sseq2 () |- ( ( A × B ) = ∅ → ( s ⊆ ( A × B ) ↔ s ⊆ ∅ ) ) ;;
	step 39 : wff = ss0 () |- ( s ⊆ ∅ → s = ∅ ) ;;
	step 40 : wff = syl6bi (step 38, step 39) |- ( ( A × B ) = ∅ → ( s ⊆ ( A × B ) → s = ∅ ) ) ;;
	step 41 : wff = syl (step 37, step 40) |- ( A = ∅ → ( s ⊆ ( A × B ) → s = ∅ ) ) ;;
	step 42 : wff = rneq () |- ( s = ∅ → ran s = ran ∅ ) ;;
	step 43 : wff = rn0 () |- ran ∅ = ∅ ;;
	step 44 : wff = 0ss () |- ∅ ⊆ B ;;
	step 45 : wff = eqsstri (step 43, step 44) |- ran ∅ ⊆ B ;;
	step 46 : wff = a1i (step 45) |- ( s = ∅ → ran ∅ ⊆ B ) ;;
	step 47 : wff = eqsstrd (step 42, step 46) |- ( s = ∅ → ran s ⊆ B ) ;;
	step 48 : wff = syl6 (step 41, step 47) |- ( A = ∅ → ( s ⊆ ( A × B ) → ran s ⊆ B ) ) ;;
	step 49 : wff = rnxp () |- ( A ≠ ∅ → ran ( A × B ) = B ) ;;
	step 50 : wff = rnss () |- ( s ⊆ ( A × B ) → ran s ⊆ ran ( A × B ) ) ;;
	step 51 : wff = sseq2 () |- ( ran ( A × B ) = B → ( ran s ⊆ ran ( A × B ) ↔ ran s ⊆ B ) ) ;;
	step 52 : wff = syl5ib (step 50, step 51) |- ( ran ( A × B ) = B → ( s ⊆ ( A × B ) → ran s ⊆ B ) ) ;;
	step 53 : wff = syl (step 49, step 52) |- ( A ≠ ∅ → ( s ⊆ ( A × B ) → ran s ⊆ B ) ) ;;
	step 54 : wff = pm2.61ine (step 48, step 53) |- ( s ⊆ ( A × B ) → ran s ⊆ B ) ;;
	step 55 : wff = syl5ss (step 34, step 54) |- ( s ⊆ ( A × B ) → ( s " { a } ) ⊆ B ) ;;
	step 56 : wff = vex () |- a ∈ _V ;;
	step 57 : wff = eldm (step 56) |- ( a ∈ dom s ↔ ∃ b a s b ) ;;
	step 58 : wff = vex () |- a ∈ _V ;;
	step 59 : wff = vex () |- b ∈ _V ;;
	step 60 : wff = elimasn (step 58, step 59) |- ( b ∈ ( s " { a } ) ↔ 〈 a , b 〉 ∈ s ) ;;
	step 61 : wff = df-br () |- ( a s b ↔ 〈 a , b 〉 ∈ s ) ;;
	step 62 : wff = bitr4i (step 60, step 61) |- ( b ∈ ( s " { a } ) ↔ a s b ) ;;
	step 63 : wff = ne0i () |- ( b ∈ ( s " { a } ) → ( s " { a } ) ≠ ∅ ) ;;
	step 64 : wff = sylbir (step 62, step 63) |- ( a s b → ( s " { a } ) ≠ ∅ ) ;;
	step 65 : wff = exlimiv (step 64) |- ( ∃ b a s b → ( s " { a } ) ≠ ∅ ) ;;
	step 66 : wff = sylbi (step 57, step 65) |- ( a ∈ dom s → ( s " { a } ) ≠ ∅ ) ;;
	step 67 : wff = df-fr () |- ( S Fr B ↔ ∀ v ( ( v ⊆ B ∧ v ≠ ∅ ) → ∃ b ∈ v ∀ d ∈ v ¬ d S b ) ) ;;
	step 68 : wff = vex () |- s ∈ _V ;;
	step 69 : wff = imaexg () |- ( s ∈ _V → ( s " { a } ) ∈ _V ) ;;
	step 70 : wff = ax-mp (step 68, step 69) |- ( s " { a } ) ∈ _V ;;
	step 71 : wff = sseq1 () |- ( v = ( s " { a } ) → ( v ⊆ B ↔ ( s " { a } ) ⊆ B ) ) ;;
	step 72 : wff = neeq1 () |- ( v = ( s " { a } ) → ( v ≠ ∅ ↔ ( s " { a } ) ≠ ∅ ) ) ;;
	step 73 : wff = anbi12d (step 71, step 72) |- ( v = ( s " { a } ) → ( ( v ⊆ B ∧ v ≠ ∅ ) ↔ ( ( s " { a } ) ⊆ B ∧ ( s " { a } ) ≠ ∅ ) ) ) ;;
	step 74 : wff = raleq () |- ( v = ( s " { a } ) → ( ∀ d ∈ v ¬ d S b ↔ ∀ d ∈ ( s " { a } ) ¬ d S b ) ) ;;
	step 75 : wff = rexeqbi1dv (step 74) |- ( v = ( s " { a } ) → ( ∃ b ∈ v ∀ d ∈ v ¬ d S b ↔ ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b ) ) ;;
	step 76 : wff = imbi12d (step 73, step 75) |- ( v = ( s " { a } ) → ( ( ( v ⊆ B ∧ v ≠ ∅ ) → ∃ b ∈ v ∀ d ∈ v ¬ d S b ) ↔ ( ( ( s " { a } ) ⊆ B ∧ ( s " { a } ) ≠ ∅ ) → ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b ) ) ) ;;
	step 77 : wff = spcv (step 70, step 76) |- ( ∀ v ( ( v ⊆ B ∧ v ≠ ∅ ) → ∃ b ∈ v ∀ d ∈ v ¬ d S b ) → ( ( ( s " { a } ) ⊆ B ∧ ( s " { a } ) ≠ ∅ ) → ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b ) ) ;;
	step 78 : wff = sylbi (step 67, step 77) |- ( S Fr B → ( ( ( s " { a } ) ⊆ B ∧ ( s " { a } ) ≠ ∅ ) → ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b ) ) ;;
	step 79 : wff = syl2ani (step 55, step 66, step 78) |- ( S Fr B → ( ( s ⊆ ( A × B ) ∧ a ∈ dom s ) → ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b ) ) ;;
	step 80 : wff = relxp () |- Rel ( A × B ) ;;
	step 81 : wff = relss () |- ( s ⊆ ( A × B ) → ( Rel ( A × B ) → Rel s ) ) ;;
	step 82 : wff = mpi (step 80, step 81) |- ( s ⊆ ( A × B ) → Rel s ) ;;
	step 83 : wff = 1stdm () |- ( ( Rel s ∧ w ∈ s ) → ( 1st ` w ) ∈ dom s ) ;;
	step 84 : wff = breq1 () |- ( c = ( 1st ` w ) → ( c R a ↔ ( 1st ` w ) R a ) ) ;;
	step 85 : wff = notbid (step 84) |- ( c = ( 1st ` w ) → ( ¬ c R a ↔ ¬ ( 1st ` w ) R a ) ) ;;
	step 86 : wff = rspccv (step 85) |- ( ∀ c ∈ dom s ¬ c R a → ( ( 1st ` w ) ∈ dom s → ¬ ( 1st ` w ) R a ) ) ;;
	step 87 : wff = syl5 (step 83, step 86) |- ( ∀ c ∈ dom s ¬ c R a → ( ( Rel s ∧ w ∈ s ) → ¬ ( 1st ` w ) R a ) ) ;;
	step 88 : wff = exp3a (step 87) |- ( ∀ c ∈ dom s ¬ c R a → ( Rel s → ( w ∈ s → ¬ ( 1st ` w ) R a ) ) ) ;;
	step 89 : wff = impcom (step 88) |- ( ( Rel s ∧ ∀ c ∈ dom s ¬ c R a ) → ( w ∈ s → ¬ ( 1st ` w ) R a ) ) ;;
	step 90 : wff = adantr (step 89) |- ( ( ( Rel s ∧ ∀ c ∈ dom s ¬ c R a ) ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ¬ ( 1st ` w ) R a ) ) ;;
	step 91 : wff = elrel () |- ( ( Rel s ∧ w ∈ s ) → ∃ t ∃ u w = 〈 t , u 〉 ) ;;
	step 92 : wff = ex (step 91) |- ( Rel s → ( w ∈ s → ∃ t ∃ u w = 〈 t , u 〉 ) ) ;;
	step 93 : wff = adantr (step 92) |- ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ∃ t ∃ u w = 〈 t , u 〉 ) ) ;;
	step 94 : wff = vex () |- a ∈ _V ;;
	step 95 : wff = vex () |- u ∈ _V ;;
	step 96 : wff = elimasn (step 94, step 95) |- ( u ∈ ( s " { a } ) ↔ 〈 a , u 〉 ∈ s ) ;;
	step 97 : wff = breq1 () |- ( d = u → ( d S b ↔ u S b ) ) ;;
	step 98 : wff = notbid (step 97) |- ( d = u → ( ¬ d S b ↔ ¬ u S b ) ) ;;
	step 99 : wff = rspccv (step 98) |- ( ∀ d ∈ ( s " { a } ) ¬ d S b → ( u ∈ ( s " { a } ) → ¬ u S b ) ) ;;
	step 100 : wff = syl5bir (step 96, step 99) |- ( ∀ d ∈ ( s " { a } ) ¬ d S b → ( 〈 a , u 〉 ∈ s → ¬ u S b ) ) ;;
	step 101 : wff = adantl (step 100) |- ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( 〈 a , u 〉 ∈ s → ¬ u S b ) ) ;;
	step 102 : wff = opeq1 () |- ( t = a → 〈 t , u 〉 = 〈 a , u 〉 ) ;;
	step 103 : wff = eleq1d (step 102) |- ( t = a → ( 〈 t , u 〉 ∈ s ↔ 〈 a , u 〉 ∈ s ) ) ;;
	step 104 : wff = imbi1d (step 103) |- ( t = a → ( ( 〈 t , u 〉 ∈ s → ¬ u S b ) ↔ ( 〈 a , u 〉 ∈ s → ¬ u S b ) ) ) ;;
	step 105 : wff = syl5ibr (step 101, step 104) |- ( t = a → ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( 〈 t , u 〉 ∈ s → ¬ u S b ) ) ) ;;
	step 106 : wff = com3l (step 105) |- ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( 〈 t , u 〉 ∈ s → ( t = a → ¬ u S b ) ) ) ;;
	step 107 : wff = eleq1 () |- ( w = 〈 t , u 〉 → ( w ∈ s ↔ 〈 t , u 〉 ∈ s ) ) ;;
	step 108 : wff = vex () |- t ∈ _V ;;
	step 109 : wff = vex () |- u ∈ _V ;;
	step 110 : wff = op1std (step 108, step 109) |- ( w = 〈 t , u 〉 → ( 1st ` w ) = t ) ;;
	step 111 : wff = eqeq1d (step 110) |- ( w = 〈 t , u 〉 → ( ( 1st ` w ) = a ↔ t = a ) ) ;;
	step 112 : wff = vex () |- t ∈ _V ;;
	step 113 : wff = vex () |- u ∈ _V ;;
	step 114 : wff = op2ndd (step 112, step 113) |- ( w = 〈 t , u 〉 → ( 2nd ` w ) = u ) ;;
	step 115 : wff = breq1d (step 114) |- ( w = 〈 t , u 〉 → ( ( 2nd ` w ) S b ↔ u S b ) ) ;;
	step 116 : wff = notbid (step 115) |- ( w = 〈 t , u 〉 → ( ¬ ( 2nd ` w ) S b ↔ ¬ u S b ) ) ;;
	step 117 : wff = imbi12d (step 111, step 116) |- ( w = 〈 t , u 〉 → ( ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ↔ ( t = a → ¬ u S b ) ) ) ;;
	step 118 : wff = imbi12d (step 107, step 117) |- ( w = 〈 t , u 〉 → ( ( w ∈ s → ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ↔ ( 〈 t , u 〉 ∈ s → ( t = a → ¬ u S b ) ) ) ) ;;
	step 119 : wff = syl5ibr (step 106, step 118) |- ( w = 〈 t , u 〉 → ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 120 : wff = exlimivv (step 119) |- ( ∃ t ∃ u w = 〈 t , u 〉 → ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 121 : wff = com3l (step 120) |- ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ( ∃ t ∃ u w = 〈 t , u 〉 → ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 122 : wff = mpdd (step 93, step 121) |- ( ( Rel s ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ;;
	step 123 : wff = adantlr (step 122) |- ( ( ( Rel s ∧ ∀ c ∈ dom s ¬ c R a ) ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ;;
	step 124 : wff = jcad (step 90, step 123) |- ( ( ( Rel s ∧ ∀ c ∈ dom s ¬ c R a ) ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ( w ∈ s → ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 125 : wff = ralrimiv (step 124) |- ( ( ( Rel s ∧ ∀ c ∈ dom s ¬ c R a ) ∧ ∀ d ∈ ( s " { a } ) ¬ d S b ) → ∀ w ∈ s ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ;;
	step 126 : wff = ex (step 125) |- ( ( Rel s ∧ ∀ c ∈ dom s ¬ c R a ) → ( ∀ d ∈ ( s " { a } ) ¬ d S b → ∀ w ∈ s ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 127 : wff = sylan (step 82, step 126) |- ( ( s ⊆ ( A × B ) ∧ ∀ c ∈ dom s ¬ c R a ) → ( ∀ d ∈ ( s " { a } ) ¬ d S b → ∀ w ∈ s ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 128 : wff = olc () |- ( ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) → ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 129 : wff = ralimi (step 128) |- ( ∀ w ∈ s ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) → ∀ w ∈ s ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 130 : wff = syl6 (step 127, step 129) |- ( ( s ⊆ ( A × B ) ∧ ∀ c ∈ dom s ¬ c R a ) → ( ∀ d ∈ ( s " { a } ) ¬ d S b → ∀ w ∈ s ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ) ;;
	step 131 : wff = ianor () |- ( ¬ ( ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∧ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ↔ ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ¬ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ) ;;
	step 132 : wff = vex () |- w ∈ _V ;;
	step 133 : wff = opex () |- 〈 a , b 〉 ∈ _V ;;
	step 134 : wff = eleq1 () |- ( x = w → ( x ∈ ( A × B ) ↔ w ∈ ( A × B ) ) ) ;;
	step 135 : wff = anbi1d (step 134) |- ( x = w → ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ↔ ( w ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ) ) ;;
	step 136 : wff = fveq2 () |- ( x = w → ( 1st ` x ) = ( 1st ` w ) ) ;;
	step 137 : wff = breq1d (step 136) |- ( x = w → ( ( 1st ` x ) R ( 1st ` y ) ↔ ( 1st ` w ) R ( 1st ` y ) ) ) ;;
	step 138 : wff = fveq2 () |- ( x = w → ( 1st ` x ) = ( 1st ` w ) ) ;;
	step 139 : wff = eqeq1d (step 138) |- ( x = w → ( ( 1st ` x ) = ( 1st ` y ) ↔ ( 1st ` w ) = ( 1st ` y ) ) ) ;;
	step 140 : wff = fveq2 () |- ( x = w → ( 2nd ` x ) = ( 2nd ` w ) ) ;;
	step 141 : wff = breq1d (step 140) |- ( x = w → ( ( 2nd ` x ) S ( 2nd ` y ) ↔ ( 2nd ` w ) S ( 2nd ` y ) ) ) ;;
	step 142 : wff = anbi12d (step 139, step 141) |- ( x = w → ( ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ↔ ( ( 1st ` w ) = ( 1st ` y ) ∧ ( 2nd ` w ) S ( 2nd ` y ) ) ) ) ;;
	step 143 : wff = orbi12d (step 137, step 142) |- ( x = w → ( ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ↔ ( ( 1st ` w ) R ( 1st ` y ) ∨ ( ( 1st ` w ) = ( 1st ` y ) ∧ ( 2nd ` w ) S ( 2nd ` y ) ) ) ) ) ;;
	step 144 : wff = anbi12d (step 135, step 143) |- ( x = w → ( ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) ↔ ( ( w ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` w ) R ( 1st ` y ) ∨ ( ( 1st ` w ) = ( 1st ` y ) ∧ ( 2nd ` w ) S ( 2nd ` y ) ) ) ) ) ) ;;
	step 145 : wff = eleq1 () |- ( y = 〈 a , b 〉 → ( y ∈ ( A × B ) ↔ 〈 a , b 〉 ∈ ( A × B ) ) ) ;;
	step 146 : wff = anbi2d (step 145) |- ( y = 〈 a , b 〉 → ( ( w ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ↔ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ) ) ;;
	step 147 : wff = vex () |- a ∈ _V ;;
	step 148 : wff = vex () |- b ∈ _V ;;
	step 149 : wff = op1std (step 147, step 148) |- ( y = 〈 a , b 〉 → ( 1st ` y ) = a ) ;;
	step 150 : wff = breq2d (step 149) |- ( y = 〈 a , b 〉 → ( ( 1st ` w ) R ( 1st ` y ) ↔ ( 1st ` w ) R a ) ) ;;
	step 151 : wff = vex () |- a ∈ _V ;;
	step 152 : wff = vex () |- b ∈ _V ;;
	step 153 : wff = op1std (step 151, step 152) |- ( y = 〈 a , b 〉 → ( 1st ` y ) = a ) ;;
	step 154 : wff = eqeq2d (step 153) |- ( y = 〈 a , b 〉 → ( ( 1st ` w ) = ( 1st ` y ) ↔ ( 1st ` w ) = a ) ) ;;
	step 155 : wff = vex () |- a ∈ _V ;;
	step 156 : wff = vex () |- b ∈ _V ;;
	step 157 : wff = op2ndd (step 155, step 156) |- ( y = 〈 a , b 〉 → ( 2nd ` y ) = b ) ;;
	step 158 : wff = breq2d (step 157) |- ( y = 〈 a , b 〉 → ( ( 2nd ` w ) S ( 2nd ` y ) ↔ ( 2nd ` w ) S b ) ) ;;
	step 159 : wff = anbi12d (step 154, step 158) |- ( y = 〈 a , b 〉 → ( ( ( 1st ` w ) = ( 1st ` y ) ∧ ( 2nd ` w ) S ( 2nd ` y ) ) ↔ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ;;
	step 160 : wff = orbi12d (step 150, step 159) |- ( y = 〈 a , b 〉 → ( ( ( 1st ` w ) R ( 1st ` y ) ∨ ( ( 1st ` w ) = ( 1st ` y ) ∧ ( 2nd ` w ) S ( 2nd ` y ) ) ) ↔ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ) ;;
	step 161 : wff = anbi12d (step 146, step 160) |- ( y = 〈 a , b 〉 → ( ( ( w ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` w ) R ( 1st ` y ) ∨ ( ( 1st ` w ) = ( 1st ` y ) ∧ ( 2nd ` w ) S ( 2nd ` y ) ) ) ) ↔ ( ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∧ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ) ) ;;
	step 162 : wff = brab (step 132, step 133, step 144, step 161, hyp 1) |- ( w T 〈 a , b 〉 ↔ ( ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∧ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ) ;;
	step 163 : wff = xchnxbir (step 131, step 162) |- ( ¬ w T 〈 a , b 〉 ↔ ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ¬ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ) ;;
	step 164 : wff = ioran () |- ( ¬ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ↔ ( ¬ ( 1st ` w ) R a ∧ ¬ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ;;
	step 165 : wff = ianor () |- ( ¬ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ↔ ( ¬ ( 1st ` w ) = a ∨ ¬ ( 2nd ` w ) S b ) ) ;;
	step 166 : wff = pm4.62 () |- ( ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ↔ ( ¬ ( 1st ` w ) = a ∨ ¬ ( 2nd ` w ) S b ) ) ;;
	step 167 : wff = bitr4i (step 165, step 166) |- ( ¬ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ↔ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ;;
	step 168 : wff = anbi2i (step 167) |- ( ( ¬ ( 1st ` w ) R a ∧ ¬ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ↔ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ;;
	step 169 : wff = bitri (step 164, step 168) |- ( ¬ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ↔ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ;;
	step 170 : wff = orbi2i (step 169) |- ( ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ¬ ( ( 1st ` w ) R a ∨ ( ( 1st ` w ) = a ∧ ( 2nd ` w ) S b ) ) ) ↔ ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 171 : wff = bitri (step 163, step 170) |- ( ¬ w T 〈 a , b 〉 ↔ ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 172 : wff = ralbii (step 171) |- ( ∀ w ∈ s ¬ w T 〈 a , b 〉 ↔ ∀ w ∈ s ( ¬ ( w ∈ ( A × B ) ∧ 〈 a , b 〉 ∈ ( A × B ) ) ∨ ( ¬ ( 1st ` w ) R a ∧ ( ( 1st ` w ) = a → ¬ ( 2nd ` w ) S b ) ) ) ) ;;
	step 173 : wff = syl6ibr (step 130, step 172) |- ( ( s ⊆ ( A × B ) ∧ ∀ c ∈ dom s ¬ c R a ) → ( ∀ d ∈ ( s " { a } ) ¬ d S b → ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 174 : wff = reximdv (step 173) |- ( ( s ⊆ ( A × B ) ∧ ∀ c ∈ dom s ¬ c R a ) → ( ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 175 : wff = ex (step 174) |- ( s ⊆ ( A × B ) → ( ∀ c ∈ dom s ¬ c R a → ( ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ) ;;
	step 176 : wff = com23 (step 175) |- ( s ⊆ ( A × B ) → ( ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b → ( ∀ c ∈ dom s ¬ c R a → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ) ;;
	step 177 : wff = adantr (step 176) |- ( ( s ⊆ ( A × B ) ∧ a ∈ dom s ) → ( ∃ b ∈ ( s " { a } ) ∀ d ∈ ( s " { a } ) ¬ d S b → ( ∀ c ∈ dom s ¬ c R a → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ) ;;
	step 178 : wff = sylcom (step 79, step 177) |- ( S Fr B → ( ( s ⊆ ( A × B ) ∧ a ∈ dom s ) → ( ∀ c ∈ dom s ¬ c R a → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ) ;;
	step 179 : wff = impl (step 178) |- ( ( ( S Fr B ∧ s ⊆ ( A × B ) ) ∧ a ∈ dom s ) → ( ∀ c ∈ dom s ¬ c R a → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 180 : wff = expimpd (step 179) |- ( ( S Fr B ∧ s ⊆ ( A × B ) ) → ( ( a ∈ dom s ∧ ∀ c ∈ dom s ¬ c R a ) → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 181 : wff = 3adant3 (step 180) |- ( ( S Fr B ∧ s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( ( a ∈ dom s ∧ ∀ c ∈ dom s ¬ c R a ) → ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 182 : wff = resss () |- ( s ↾ { a } ) ⊆ s ;;
	step 183 : wff = df-rex () |- ( ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 ↔ ∃ b ( b ∈ ( s " { a } ) ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 184 : wff = vex () |- a ∈ _V ;;
	step 185 : wff = vex () |- b ∈ _V ;;
	step 186 : wff = elimasn (step 184, step 185) |- ( b ∈ ( s " { a } ) ↔ 〈 a , b 〉 ∈ s ) ;;
	step 187 : wff = eqid () |- 〈 a , b 〉 = 〈 a , b 〉 ;;
	step 188 : wff = opex () |- 〈 a , b 〉 ∈ _V ;;
	step 189 : wff = eqeq1 () |- ( z = 〈 a , b 〉 → ( z = 〈 a , b 〉 ↔ 〈 a , b 〉 = 〈 a , b 〉 ) ) ;;
	step 190 : wff = breq2 () |- ( z = 〈 a , b 〉 → ( w T z ↔ w T 〈 a , b 〉 ) ) ;;
	step 191 : wff = notbid (step 190) |- ( z = 〈 a , b 〉 → ( ¬ w T z ↔ ¬ w T 〈 a , b 〉 ) ) ;;
	step 192 : wff = ralbidv (step 191) |- ( z = 〈 a , b 〉 → ( ∀ w ∈ s ¬ w T z ↔ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ;;
	step 193 : wff = anbi2d (step 192) |- ( z = 〈 a , b 〉 → ( ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ↔ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ) ;;
	step 194 : wff = anbi12d (step 189, step 193) |- ( z = 〈 a , b 〉 → ( ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ↔ ( 〈 a , b 〉 = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) ) ) ;;
	step 195 : wff = spcev (step 188, step 194) |- ( ( 〈 a , b 〉 = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) ) → ∃ z ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 196 : wff = mpan (step 187, step 195) |- ( ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) → ∃ z ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 197 : wff = sylanb (step 186, step 196) |- ( ( b ∈ ( s " { a } ) ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) → ∃ z ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 198 : wff = eximi (step 197) |- ( ∃ b ( b ∈ ( s " { a } ) ∧ ∀ w ∈ s ¬ w T 〈 a , b 〉 ) → ∃ b ∃ z ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 199 : wff = sylbi (step 183, step 198) |- ( ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 → ∃ b ∃ z ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 200 : wff = excom () |- ( ∃ b ∃ z ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ↔ ∃ z ∃ b ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 201 : wff = sylib (step 199, step 200) |- ( ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 → ∃ z ∃ b ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 202 : wff = df-rex () |- ( ∃ z ∈ ( s ↾ { a } ) ∀ w ∈ s ¬ w T z ↔ ∃ z ( z ∈ ( s ↾ { a } ) ∧ ∀ w ∈ s ¬ w T z ) ) ;;
	step 203 : wff = vex () |- a ∈ _V ;;
	step 204 : wff = elsnres (step 203) |- ( z ∈ ( s ↾ { a } ) ↔ ∃ b ( z = 〈 a , b 〉 ∧ 〈 a , b 〉 ∈ s ) ) ;;
	step 205 : wff = anbi1i (step 204) |- ( ( z ∈ ( s ↾ { a } ) ∧ ∀ w ∈ s ¬ w T z ) ↔ ( ∃ b ( z = 〈 a , b 〉 ∧ 〈 a , b 〉 ∈ s ) ∧ ∀ w ∈ s ¬ w T z ) ) ;;
	step 206 : wff = 19.41v () |- ( ∃ b ( ( z = 〈 a , b 〉 ∧ 〈 a , b 〉 ∈ s ) ∧ ∀ w ∈ s ¬ w T z ) ↔ ( ∃ b ( z = 〈 a , b 〉 ∧ 〈 a , b 〉 ∈ s ) ∧ ∀ w ∈ s ¬ w T z ) ) ;;
	step 207 : wff = anass () |- ( ( ( z = 〈 a , b 〉 ∧ 〈 a , b 〉 ∈ s ) ∧ ∀ w ∈ s ¬ w T z ) ↔ ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 208 : wff = exbii (step 207) |- ( ∃ b ( ( z = 〈 a , b 〉 ∧ 〈 a , b 〉 ∈ s ) ∧ ∀ w ∈ s ¬ w T z ) ↔ ∃ b ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 209 : wff = 3bitr2i (step 205, step 206, step 208) |- ( ( z ∈ ( s ↾ { a } ) ∧ ∀ w ∈ s ¬ w T z ) ↔ ∃ b ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 210 : wff = exbii (step 209) |- ( ∃ z ( z ∈ ( s ↾ { a } ) ∧ ∀ w ∈ s ¬ w T z ) ↔ ∃ z ∃ b ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 211 : wff = bitri (step 202, step 210) |- ( ∃ z ∈ ( s ↾ { a } ) ∀ w ∈ s ¬ w T z ↔ ∃ z ∃ b ( z = 〈 a , b 〉 ∧ ( 〈 a , b 〉 ∈ s ∧ ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 212 : wff = sylibr (step 201, step 211) |- ( ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 → ∃ z ∈ ( s ↾ { a } ) ∀ w ∈ s ¬ w T z ) ;;
	step 213 : wff = ssrexv () |- ( ( s ↾ { a } ) ⊆ s → ( ∃ z ∈ ( s ↾ { a } ) ∀ w ∈ s ¬ w T z → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ;;
	step 214 : wff = mpsyl (step 182, step 212, step 213) |- ( ∃ b ∈ ( s " { a } ) ∀ w ∈ s ¬ w T 〈 a , b 〉 → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ;;
	step 215 : wff = syl6 (step 181, step 214) |- ( ( S Fr B ∧ s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( ( a ∈ dom s ∧ ∀ c ∈ dom s ¬ c R a ) → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ;;
	step 216 : wff = exp3a (step 215) |- ( ( S Fr B ∧ s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( a ∈ dom s → ( ∀ c ∈ dom s ¬ c R a → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 217 : wff = rexlimdv (step 216) |- ( ( S Fr B ∧ s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ;;
	step 218 : wff = 3expib (step 217) |- ( S Fr B → ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 219 : wff = adantl (step 218) |- ( ( R Fr A ∧ S Fr B ) → ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ( ∃ a ∈ dom s ∀ c ∈ dom s ¬ c R a → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ) ;;
	step 220 : wff = mpdd (step 33, step 219) |- ( ( R Fr A ∧ S Fr B ) → ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ;;
	step 221 : wff = alrimiv (step 220) |- ( ( R Fr A ∧ S Fr B ) → ∀ s ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ;;
	step 222 : wff = df-fr () |- ( T Fr ( A × B ) ↔ ∀ s ( ( s ⊆ ( A × B ) ∧ s ≠ ∅ ) → ∃ z ∈ s ∀ w ∈ s ¬ w T z ) ) ;;
	step 223 : wff = sylibr (step 221, step 222) |- ( ( R Fr A ∧ S Fr B ) → T Fr ( A × B ) ) ;;
	qed prop 1 = step 223 ;;
}

/* Lemma for lexicographical ordering theorems.  (Contributed by Scott
       Fenton, 16-Mar-2011.) */

theorem xporderlem (x : set, y : set, A : class, B : class, R : class, S : class, T : class, a : set, b : set, c : set, d : set) disjointed(A x y, B x y, R x y, S x y, a x y, b x y, c x y, d x y) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( 〈 a , b 〉 T 〈 c , d 〉 ↔ ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
}

proof of xporderlem {
	step 1 : wff = df-br () |- ( 〈 a , b 〉 T 〈 c , d 〉 ↔ 〈 〈 a , b 〉 , 〈 c , d 〉 〉 ∈ T ) ;;
	step 2 : wff = eleq2i (hyp 1) |- ( 〈 〈 a , b 〉 , 〈 c , d 〉 〉 ∈ T ↔ 〈 〈 a , b 〉 , 〈 c , d 〉 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( 〈 a , b 〉 T 〈 c , d 〉 ↔ 〈 〈 a , b 〉 , 〈 c , d 〉 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ) ;;
	step 4 : wff = opex () |- 〈 a , b 〉 ∈ _V ;;
	step 5 : wff = opex () |- 〈 c , d 〉 ∈ _V ;;
	step 6 : wff = eleq1 () |- ( x = 〈 a , b 〉 → ( x ∈ ( A × B ) ↔ 〈 a , b 〉 ∈ ( A × B ) ) ) ;;
	step 7 : wff = opelxp () |- ( 〈 a , b 〉 ∈ ( A × B ) ↔ ( a ∈ A ∧ b ∈ B ) ) ;;
	step 8 : wff = syl6bb (step 6, step 7) |- ( x = 〈 a , b 〉 → ( x ∈ ( A × B ) ↔ ( a ∈ A ∧ b ∈ B ) ) ) ;;
	step 9 : wff = anbi1d (step 8) |- ( x = 〈 a , b 〉 → ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ↔ ( ( a ∈ A ∧ b ∈ B ) ∧ y ∈ ( A × B ) ) ) ) ;;
	step 10 : wff = vex () |- a ∈ _V ;;
	step 11 : wff = vex () |- b ∈ _V ;;
	step 12 : wff = op1std (step 10, step 11) |- ( x = 〈 a , b 〉 → ( 1st ` x ) = a ) ;;
	step 13 : wff = breq1d (step 12) |- ( x = 〈 a , b 〉 → ( ( 1st ` x ) R ( 1st ` y ) ↔ a R ( 1st ` y ) ) ) ;;
	step 14 : wff = vex () |- a ∈ _V ;;
	step 15 : wff = vex () |- b ∈ _V ;;
	step 16 : wff = op1std (step 14, step 15) |- ( x = 〈 a , b 〉 → ( 1st ` x ) = a ) ;;
	step 17 : wff = eqeq1d (step 16) |- ( x = 〈 a , b 〉 → ( ( 1st ` x ) = ( 1st ` y ) ↔ a = ( 1st ` y ) ) ) ;;
	step 18 : wff = vex () |- a ∈ _V ;;
	step 19 : wff = vex () |- b ∈ _V ;;
	step 20 : wff = op2ndd (step 18, step 19) |- ( x = 〈 a , b 〉 → ( 2nd ` x ) = b ) ;;
	step 21 : wff = breq1d (step 20) |- ( x = 〈 a , b 〉 → ( ( 2nd ` x ) S ( 2nd ` y ) ↔ b S ( 2nd ` y ) ) ) ;;
	step 22 : wff = anbi12d (step 17, step 21) |- ( x = 〈 a , b 〉 → ( ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ↔ ( a = ( 1st ` y ) ∧ b S ( 2nd ` y ) ) ) ) ;;
	step 23 : wff = orbi12d (step 13, step 22) |- ( x = 〈 a , b 〉 → ( ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ↔ ( a R ( 1st ` y ) ∨ ( a = ( 1st ` y ) ∧ b S ( 2nd ` y ) ) ) ) ) ;;
	step 24 : wff = anbi12d (step 9, step 23) |- ( x = 〈 a , b 〉 → ( ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) ↔ ( ( ( a ∈ A ∧ b ∈ B ) ∧ y ∈ ( A × B ) ) ∧ ( a R ( 1st ` y ) ∨ ( a = ( 1st ` y ) ∧ b S ( 2nd ` y ) ) ) ) ) ) ;;
	step 25 : wff = eleq1 () |- ( y = 〈 c , d 〉 → ( y ∈ ( A × B ) ↔ 〈 c , d 〉 ∈ ( A × B ) ) ) ;;
	step 26 : wff = opelxp () |- ( 〈 c , d 〉 ∈ ( A × B ) ↔ ( c ∈ A ∧ d ∈ B ) ) ;;
	step 27 : wff = syl6bb (step 25, step 26) |- ( y = 〈 c , d 〉 → ( y ∈ ( A × B ) ↔ ( c ∈ A ∧ d ∈ B ) ) ) ;;
	step 28 : wff = anbi2d (step 27) |- ( y = 〈 c , d 〉 → ( ( ( a ∈ A ∧ b ∈ B ) ∧ y ∈ ( A × B ) ) ↔ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) ) ) ;;
	step 29 : wff = vex () |- c ∈ _V ;;
	step 30 : wff = vex () |- d ∈ _V ;;
	step 31 : wff = op1std (step 29, step 30) |- ( y = 〈 c , d 〉 → ( 1st ` y ) = c ) ;;
	step 32 : wff = breq2d (step 31) |- ( y = 〈 c , d 〉 → ( a R ( 1st ` y ) ↔ a R c ) ) ;;
	step 33 : wff = vex () |- c ∈ _V ;;
	step 34 : wff = vex () |- d ∈ _V ;;
	step 35 : wff = op1std (step 33, step 34) |- ( y = 〈 c , d 〉 → ( 1st ` y ) = c ) ;;
	step 36 : wff = eqeq2d (step 35) |- ( y = 〈 c , d 〉 → ( a = ( 1st ` y ) ↔ a = c ) ) ;;
	step 37 : wff = vex () |- c ∈ _V ;;
	step 38 : wff = vex () |- d ∈ _V ;;
	step 39 : wff = op2ndd (step 37, step 38) |- ( y = 〈 c , d 〉 → ( 2nd ` y ) = d ) ;;
	step 40 : wff = breq2d (step 39) |- ( y = 〈 c , d 〉 → ( b S ( 2nd ` y ) ↔ b S d ) ) ;;
	step 41 : wff = anbi12d (step 36, step 40) |- ( y = 〈 c , d 〉 → ( ( a = ( 1st ` y ) ∧ b S ( 2nd ` y ) ) ↔ ( a = c ∧ b S d ) ) ) ;;
	step 42 : wff = orbi12d (step 32, step 41) |- ( y = 〈 c , d 〉 → ( ( a R ( 1st ` y ) ∨ ( a = ( 1st ` y ) ∧ b S ( 2nd ` y ) ) ) ↔ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
	step 43 : wff = anbi12d (step 28, step 42) |- ( y = 〈 c , d 〉 → ( ( ( ( a ∈ A ∧ b ∈ B ) ∧ y ∈ ( A × B ) ) ∧ ( a R ( 1st ` y ) ∨ ( a = ( 1st ` y ) ∧ b S ( 2nd ` y ) ) ) ) ↔ ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ) ;;
	step 44 : wff = opelopab (step 4, step 5, step 24, step 43) |- ( 〈 〈 a , b 〉 , 〈 c , d 〉 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ↔ ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
	step 45 : wff = an4 () |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) ↔ ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ) ;;
	step 46 : wff = anbi1i (step 45) |- ( ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ↔ ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
	step 47 : wff = 3bitri (step 3, step 44, step 46) |- ( 〈 a , b 〉 T 〈 c , d 〉 ↔ ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
	qed prop 1 = step 47 ;;
}

/* A lexicographical ordering of two posets.  (Contributed by Scott Fenton,
       16-Mar-2011.)  (Revised by Mario Carneiro, 7-Mar-2013.) */

theorem poxp (x : set, y : set, A : class, B : class, R : class, S : class, T : class) disjointed(A a b c d e f t u v x y, B a b c d e f t u v x y, R a b c d e f t u v x y, S a b c d e f t u v x y, T a b c d e f t u v) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( R Po A ∧ S Po B ) → T Po ( A × B ) ) ;;
}

proof of poxp {
	var v : set, u : set, t : set, e : set, f : set, a : set, b : set, c : set, d : set;;
	step 1 : wff = elxp () |- ( t ∈ ( A × B ) ↔ ∃ a ∃ b ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ) ;;
	step 2 : wff = elxp () |- ( u ∈ ( A × B ) ↔ ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ) ;;
	step 3 : wff = elxp () |- ( v ∈ ( A × B ) ↔ ∃ e ∃ f ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) ) ;;
	step 4 : wff = 3an6 () |- ( ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ∧ ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ∧ ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) ) ↔ ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) ) ;;
	step 5 : wff = poirr () |- ( ( R Po A ∧ a ∈ A ) → ¬ a R a ) ;;
	step 6 : wff = ex (step 5) |- ( R Po A → ( a ∈ A → ¬ a R a ) ) ;;
	step 7 : wff = poirr () |- ( ( S Po B ∧ b ∈ B ) → ¬ b S b ) ;;
	step 8 : wff = intnand (step 7) |- ( ( S Po B ∧ b ∈ B ) → ¬ ( a = a ∧ b S b ) ) ;;
	step 9 : wff = ex (step 8) |- ( S Po B → ( b ∈ B → ¬ ( a = a ∧ b S b ) ) ) ;;
	step 10 : wff = im2anan9 (step 6, step 9) |- ( ( R Po A ∧ S Po B ) → ( ( a ∈ A ∧ b ∈ B ) → ( ¬ a R a ∧ ¬ ( a = a ∧ b S b ) ) ) ) ;;
	step 11 : wff = ioran () |- ( ¬ ( a R a ∨ ( a = a ∧ b S b ) ) ↔ ( ¬ a R a ∧ ¬ ( a = a ∧ b S b ) ) ) ;;
	step 12 : wff = syl6ibr (step 10, step 11) |- ( ( R Po A ∧ S Po B ) → ( ( a ∈ A ∧ b ∈ B ) → ¬ ( a R a ∨ ( a = a ∧ b S b ) ) ) ) ;;
	step 13 : wff = imp (step 12) |- ( ( ( R Po A ∧ S Po B ) ∧ ( a ∈ A ∧ b ∈ B ) ) → ¬ ( a R a ∨ ( a = a ∧ b S b ) ) ) ;;
	step 14 : wff = intnand (step 13) |- ( ( ( R Po A ∧ S Po B ) ∧ ( a ∈ A ∧ b ∈ B ) ) → ¬ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ) ;;
	step 15 : wff = 3ad2antr1 (step 14) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ¬ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ) ;;
	step 16 : wff = an4 () |- ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) ↔ ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ) ∧ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) ) ;;
	step 17 : wff = 3an6 () |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ↔ ( ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ) ;;
	step 18 : wff = potr () |- ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) → ( ( a R c ∧ c R e ) → a R e ) ) ;;
	step 19 : wff = 3impia (step 18) |- ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ∧ ( a R c ∧ c R e ) ) → a R e ) ;;
	step 20 : wff = orcd (step 19) |- ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ∧ ( a R c ∧ c R e ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ;;
	step 21 : wff = 3expia (step 20) |- ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) → ( ( a R c ∧ c R e ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 22 : wff = expdimp (step 21) |- ( ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) ∧ a R c ) → ( c R e → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 23 : wff = breq2 () |- ( c = e → ( a R c ↔ a R e ) ) ;;
	step 24 : wff = biimpa (step 23) |- ( ( c = e ∧ a R c ) → a R e ) ;;
	step 25 : wff = orcd (step 24) |- ( ( c = e ∧ a R c ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ;;
	step 26 : wff = expcom (step 25) |- ( a R c → ( c = e → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 27 : wff = adantrd (step 26) |- ( a R c → ( ( c = e ∧ d S f ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 28 : wff = adantl (step 27) |- ( ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) ∧ a R c ) → ( ( c = e ∧ d S f ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 29 : wff = jaod (step 22, step 28) |- ( ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) ∧ a R c ) → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 30 : wff = ex (step 29) |- ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) → ( a R c → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 31 : wff = potr () |- ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) → ( ( b S d ∧ d S f ) → b S f ) ) ;;
	step 32 : wff = expdimp (step 31) |- ( ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ∧ b S d ) → ( d S f → b S f ) ) ;;
	step 33 : wff = anim2d (step 32) |- ( ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ∧ b S d ) → ( ( c = e ∧ d S f ) → ( c = e ∧ b S f ) ) ) ;;
	step 34 : wff = orim2d (step 33) |- ( ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ∧ b S d ) → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( c R e ∨ ( c = e ∧ b S f ) ) ) ) ;;
	step 35 : wff = breq1 () |- ( a = c → ( a R e ↔ c R e ) ) ;;
	step 36 : wff = equequ1 () |- ( a = c → ( a = e ↔ c = e ) ) ;;
	step 37 : wff = anbi1d (step 36) |- ( a = c → ( ( a = e ∧ b S f ) ↔ ( c = e ∧ b S f ) ) ) ;;
	step 38 : wff = orbi12d (step 35, step 37) |- ( a = c → ( ( a R e ∨ ( a = e ∧ b S f ) ) ↔ ( c R e ∨ ( c = e ∧ b S f ) ) ) ) ;;
	step 39 : wff = imbi2d (step 38) |- ( a = c → ( ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ↔ ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( c R e ∨ ( c = e ∧ b S f ) ) ) ) ) ;;
	step 40 : wff = syl5ibr (step 34, step 39) |- ( a = c → ( ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ∧ b S d ) → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 41 : wff = exp3a (step 40) |- ( a = c → ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) → ( b S d → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ) ;;
	step 42 : wff = com12 (step 41) |- ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) → ( a = c → ( b S d → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ) ;;
	step 43 : wff = imp3a (step 42) |- ( ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) → ( ( a = c ∧ b S d ) → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 44 : wff = jaao (step 30, step 43) |- ( ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) ∧ ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ) → ( ( a R c ∨ ( a = c ∧ b S d ) ) → ( ( c R e ∨ ( c = e ∧ d S f ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 45 : wff = imp3a (step 44) |- ( ( ( R Po A ∧ ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ) ∧ ( S Po B ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ) → ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 46 : wff = an4s (step 45) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ c ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ∧ f ∈ B ) ) ) → ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 47 : wff = sylan2b (step 17, step 46) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) → ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 48 : wff = an4 () |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ↔ ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ) ;;
	step 49 : wff = biimpi (step 48) |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ) ;;
	step 50 : wff = 3adant2 (step 49) |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ) ;;
	step 51 : wff = adantl (step 50) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ) ;;
	step 52 : wff = jctild (step 47, step 51) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 53 : wff = adantld (step 52) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ) ∧ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 54 : wff = syl5bi (step 16, step 53) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 55 : wff = jca (step 15, step 54) |- ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ¬ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ∧ ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ) ;;
	step 56 : wff = breq12 () |- ( ( t = 〈 a , b 〉 ∧ t = 〈 a , b 〉 ) → ( t T t ↔ 〈 a , b 〉 T 〈 a , b 〉 ) ) ;;
	step 57 : wff = anidms (step 56) |- ( t = 〈 a , b 〉 → ( t T t ↔ 〈 a , b 〉 T 〈 a , b 〉 ) ) ;;
	step 58 : wff = notbid (step 57) |- ( t = 〈 a , b 〉 → ( ¬ t T t ↔ ¬ 〈 a , b 〉 T 〈 a , b 〉 ) ) ;;
	step 59 : wff = 3ad2ant1 (step 58) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ¬ t T t ↔ ¬ 〈 a , b 〉 T 〈 a , b 〉 ) ) ;;
	step 60 : wff = breq12 () |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( t T u ↔ 〈 a , b 〉 T 〈 c , d 〉 ) ) ;;
	step 61 : wff = 3adant3 (step 60) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( t T u ↔ 〈 a , b 〉 T 〈 c , d 〉 ) ) ;;
	step 62 : wff = breq12 () |- ( ( u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( u T v ↔ 〈 c , d 〉 T 〈 e , f 〉 ) ) ;;
	step 63 : wff = 3adant1 (step 62) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( u T v ↔ 〈 c , d 〉 T 〈 e , f 〉 ) ) ;;
	step 64 : wff = anbi12d (step 61, step 63) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ( t T u ∧ u T v ) ↔ ( 〈 a , b 〉 T 〈 c , d 〉 ∧ 〈 c , d 〉 T 〈 e , f 〉 ) ) ) ;;
	step 65 : wff = breq12 () |- ( ( t = 〈 a , b 〉 ∧ v = 〈 e , f 〉 ) → ( t T v ↔ 〈 a , b 〉 T 〈 e , f 〉 ) ) ;;
	step 66 : wff = 3adant2 (step 65) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( t T v ↔ 〈 a , b 〉 T 〈 e , f 〉 ) ) ;;
	step 67 : wff = imbi12d (step 64, step 66) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ( ( t T u ∧ u T v ) → t T v ) ↔ ( ( 〈 a , b 〉 T 〈 c , d 〉 ∧ 〈 c , d 〉 T 〈 e , f 〉 ) → 〈 a , b 〉 T 〈 e , f 〉 ) ) ) ;;
	step 68 : wff = anbi12d (step 59, step 67) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ↔ ( ¬ 〈 a , b 〉 T 〈 a , b 〉 ∧ ( ( 〈 a , b 〉 T 〈 c , d 〉 ∧ 〈 c , d 〉 T 〈 e , f 〉 ) → 〈 a , b 〉 T 〈 e , f 〉 ) ) ) ) ;;
	step 69 : wff = xporderlem (hyp 1) |- ( 〈 a , b 〉 T 〈 a , b 〉 ↔ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ) ;;
	step 70 : wff = notbii (step 69) |- ( ¬ 〈 a , b 〉 T 〈 a , b 〉 ↔ ¬ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ) ;;
	step 71 : wff = xporderlem (hyp 1) |- ( 〈 a , b 〉 T 〈 c , d 〉 ↔ ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
	step 72 : wff = xporderlem (hyp 1) |- ( 〈 c , d 〉 T 〈 e , f 〉 ↔ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) ;;
	step 73 : wff = anbi12i (step 71, step 72) |- ( ( 〈 a , b 〉 T 〈 c , d 〉 ∧ 〈 c , d 〉 T 〈 e , f 〉 ) ↔ ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) ) ;;
	step 74 : wff = xporderlem (hyp 1) |- ( 〈 a , b 〉 T 〈 e , f 〉 ↔ ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ;;
	step 75 : wff = imbi12i (step 73, step 74) |- ( ( ( 〈 a , b 〉 T 〈 c , d 〉 ∧ 〈 c , d 〉 T 〈 e , f 〉 ) → 〈 a , b 〉 T 〈 e , f 〉 ) ↔ ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ;;
	step 76 : wff = anbi12i (step 70, step 75) |- ( ( ¬ 〈 a , b 〉 T 〈 a , b 〉 ∧ ( ( 〈 a , b 〉 T 〈 c , d 〉 ∧ 〈 c , d 〉 T 〈 e , f 〉 ) → 〈 a , b 〉 T 〈 e , f 〉 ) ) ↔ ( ¬ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ∧ ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ) ;;
	step 77 : wff = syl6bb (step 68, step 76) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ↔ ( ¬ ( ( ( a ∈ A ∧ a ∈ A ) ∧ ( b ∈ B ∧ b ∈ B ) ) ∧ ( a R a ∨ ( a = a ∧ b S b ) ) ) ∧ ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∧ ( ( ( c ∈ A ∧ e ∈ A ) ∧ ( d ∈ B ∧ f ∈ B ) ) ∧ ( c R e ∨ ( c = e ∧ d S f ) ) ) ) → ( ( ( a ∈ A ∧ e ∈ A ) ∧ ( b ∈ B ∧ f ∈ B ) ) ∧ ( a R e ∨ ( a = e ∧ b S f ) ) ) ) ) ) ) ;;
	step 78 : wff = syl5ibr (step 55, step 77) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ( ( R Po A ∧ S Po B ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ;;
	step 79 : wff = exp3acom23 (step 78) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) → ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ;;
	step 80 : wff = imp (step 79) |- ( ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ∧ v = 〈 e , f 〉 ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ;;
	step 81 : wff = sylbi (step 4, step 80) |- ( ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ∧ ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ∧ ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ;;
	step 82 : wff = 3exp (step 81) |- ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 83 : wff = com3l (step 82) |- ( ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 84 : wff = exlimivv (step 83) |- ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 85 : wff = com3l (step 84) |- ( ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 86 : wff = exlimivv (step 85) |- ( ∃ e ∃ f ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 87 : wff = com3l (step 86) |- ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ∃ e ∃ f ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 88 : wff = exlimivv (step 87) |- ( ∃ a ∃ b ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ∃ e ∃ f ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ) ;;
	step 89 : wff = 3imp (step 88) |- ( ( ∃ a ∃ b ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ∧ ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ∧ ∃ e ∃ f ( v = 〈 e , f 〉 ∧ ( e ∈ A ∧ f ∈ B ) ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ;;
	step 90 : wff = syl3anb (step 1, step 2, step 3, step 89) |- ( ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ∧ v ∈ ( A × B ) ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ;;
	step 91 : wff = 3expia (step 90) |- ( ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ) → ( v ∈ ( A × B ) → ( ( R Po A ∧ S Po B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ;;
	step 92 : wff = com3r (step 91) |- ( ( R Po A ∧ S Po B ) → ( ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ) → ( v ∈ ( A × B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ) ;;
	step 93 : wff = imp (step 92) |- ( ( ( R Po A ∧ S Po B ) ∧ ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ) ) → ( v ∈ ( A × B ) → ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ) ;;
	step 94 : wff = ralrimiv (step 93) |- ( ( ( R Po A ∧ S Po B ) ∧ ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ) ) → ∀ v ∈ ( A × B ) ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ;;
	step 95 : wff = ralrimivva (step 94) |- ( ( R Po A ∧ S Po B ) → ∀ t ∈ ( A × B ) ∀ u ∈ ( A × B ) ∀ v ∈ ( A × B ) ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ;;
	step 96 : wff = df-po () |- ( T Po ( A × B ) ↔ ∀ t ∈ ( A × B ) ∀ u ∈ ( A × B ) ∀ v ∈ ( A × B ) ( ¬ t T t ∧ ( ( t T u ∧ u T v ) → t T v ) ) ) ;;
	step 97 : wff = sylibr (step 95, step 96) |- ( ( R Po A ∧ S Po B ) → T Po ( A × B ) ) ;;
	qed prop 1 = step 97 ;;
}

/* A lexicographical ordering of two strictly ordered classes.
       (Contributed by Scott Fenton, 17-Mar-2011.)  (Revised by Mario Carneiro,
       7-Mar-2013.) */

theorem soxp (x : set, y : set, A : class, B : class, R : class, S : class, T : class) disjointed(A a b c d t u x y, B a b c d t u x y, R a b c d t u x y, S a b c d t u x y, T a b c d t u) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( R Or A ∧ S Or B ) → T Or ( A × B ) ) ;;
}

proof of soxp {
	var u : set, t : set, a : set, b : set, c : set, d : set;;
	step 1 : wff = sopo () |- ( R Or A → R Po A ) ;;
	step 2 : wff = sopo () |- ( S Or B → S Po B ) ;;
	step 3 : wff = poxp (hyp 1) |- ( ( R Po A ∧ S Po B ) → T Po ( A × B ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( R Or A ∧ S Or B ) → T Po ( A × B ) ) ;;
	step 5 : wff = elxp () |- ( t ∈ ( A × B ) ↔ ∃ a ∃ b ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ) ;;
	step 6 : wff = elxp () |- ( u ∈ ( A × B ) ↔ ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ) ;;
	step 7 : wff = ioran () |- ( ¬ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) ↔ ( ¬ ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ¬ ( a = c ∧ b = d ) ) ) ;;
	step 8 : wff = ioran () |- ( ¬ ( a R c ∨ ( a = c ∧ b S d ) ) ↔ ( ¬ a R c ∧ ¬ ( a = c ∧ b S d ) ) ) ;;
	step 9 : wff = ianor () |- ( ¬ ( a = c ∧ b S d ) ↔ ( ¬ a = c ∨ ¬ b S d ) ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( ¬ a R c ∧ ¬ ( a = c ∧ b S d ) ) ↔ ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) ) ;;
	step 11 : wff = bitri (step 8, step 10) |- ( ¬ ( a R c ∨ ( a = c ∧ b S d ) ) ↔ ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) ) ;;
	step 12 : wff = ianor () |- ( ¬ ( a = c ∧ b = d ) ↔ ( ¬ a = c ∨ ¬ b = d ) ) ;;
	step 13 : wff = anbi12i (step 11, step 12) |- ( ( ¬ ( a R c ∨ ( a = c ∧ b S d ) ) ∧ ¬ ( a = c ∧ b = d ) ) ↔ ( ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) ∧ ( ¬ a = c ∨ ¬ b = d ) ) ) ;;
	step 14 : wff = bitri (step 7, step 13) |- ( ¬ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) ↔ ( ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) ∧ ( ¬ a = c ∨ ¬ b = d ) ) ) ;;
	step 15 : wff = solin () |- ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) → ( a R c ∨ a = c ∨ c R a ) ) ;;
	step 16 : wff = 3orass () |- ( ( a R c ∨ a = c ∨ c R a ) ↔ ( a R c ∨ ( a = c ∨ c R a ) ) ) ;;
	step 17 : wff = df-or () |- ( ( a R c ∨ ( a = c ∨ c R a ) ) ↔ ( ¬ a R c → ( a = c ∨ c R a ) ) ) ;;
	step 18 : wff = bitri (step 16, step 17) |- ( ( a R c ∨ a = c ∨ c R a ) ↔ ( ¬ a R c → ( a = c ∨ c R a ) ) ) ;;
	step 19 : wff = sylib (step 15, step 18) |- ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) → ( ¬ a R c → ( a = c ∨ c R a ) ) ) ;;
	step 20 : wff = solin () |- ( ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) → ( b S d ∨ b = d ∨ d S b ) ) ;;
	step 21 : wff = 3orass () |- ( ( b S d ∨ b = d ∨ d S b ) ↔ ( b S d ∨ ( b = d ∨ d S b ) ) ) ;;
	step 22 : wff = df-or () |- ( ( b S d ∨ ( b = d ∨ d S b ) ) ↔ ( ¬ b S d → ( b = d ∨ d S b ) ) ) ;;
	step 23 : wff = bitri (step 21, step 22) |- ( ( b S d ∨ b = d ∨ d S b ) ↔ ( ¬ b S d → ( b = d ∨ d S b ) ) ) ;;
	step 24 : wff = sylib (step 20, step 23) |- ( ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) → ( ¬ b S d → ( b = d ∨ d S b ) ) ) ;;
	step 25 : wff = orim2d (step 24) |- ( ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) → ( ( ¬ a = c ∨ ¬ b S d ) → ( ¬ a = c ∨ ( b = d ∨ d S b ) ) ) ) ;;
	step 26 : wff = im2anan9 (step 19, step 25) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) → ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ ( b = d ∨ d S b ) ) ) ) ) ;;
	step 27 : wff = pm2.53 () |- ( ( a = c ∨ c R a ) → ( ¬ a = c → c R a ) ) ;;
	step 28 : wff = orc () |- ( c R a → ( c R a ∨ ( c = a ∧ d S b ) ) ) ;;
	step 29 : wff = syl6 (step 27, step 28) |- ( ( a = c ∨ c R a ) → ( ¬ a = c → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 30 : wff = adantr (step 29) |- ( ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ ( b = d ∨ d S b ) ) ) → ( ¬ a = c → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 31 : wff = orel1 () |- ( ¬ b = d → ( ( b = d ∨ d S b ) → d S b ) ) ;;
	step 32 : wff = orim2d (step 31) |- ( ¬ b = d → ( ( ¬ a = c ∨ ( b = d ∨ d S b ) ) → ( ¬ a = c ∨ d S b ) ) ) ;;
	step 33 : wff = anim2d (step 32) |- ( ¬ b = d → ( ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ ( b = d ∨ d S b ) ) ) → ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ d S b ) ) ) ) ;;
	step 34 : wff = imor () |- ( ( a = c → d S b ) ↔ ( ¬ a = c ∨ d S b ) ) ;;
	step 35 : wff = biimpri (step 34) |- ( ( ¬ a = c ∨ d S b ) → ( a = c → d S b ) ) ;;
	step 36 : wff = com12 (step 35) |- ( a = c → ( ( ¬ a = c ∨ d S b ) → d S b ) ) ;;
	step 37 : wff = equcomi () |- ( a = c → c = a ) ;;
	step 38 : wff = anim1i (step 37) |- ( ( a = c ∧ d S b ) → ( c = a ∧ d S b ) ) ;;
	step 39 : wff = olcd (step 38) |- ( ( a = c ∧ d S b ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ;;
	step 40 : wff = ex (step 39) |- ( a = c → ( d S b → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 41 : wff = syld (step 36, step 40) |- ( a = c → ( ( ¬ a = c ∨ d S b ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 42 : wff = orc () |- ( c R a → ( c R a ∨ ( c = a ∧ d S b ) ) ) ;;
	step 43 : wff = a1d (step 42) |- ( c R a → ( ( ¬ a = c ∨ d S b ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 44 : wff = jaoi (step 41, step 43) |- ( ( a = c ∨ c R a ) → ( ( ¬ a = c ∨ d S b ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 45 : wff = imp (step 44) |- ( ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ d S b ) ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ;;
	step 46 : wff = syl6com (step 33, step 45) |- ( ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ ( b = d ∨ d S b ) ) ) → ( ¬ b = d → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 47 : wff = jaod (step 30, step 46) |- ( ( ( a = c ∨ c R a ) ∧ ( ¬ a = c ∨ ( b = d ∨ d S b ) ) ) → ( ( ¬ a = c ∨ ¬ b = d ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 48 : wff = syl6 (step 26, step 47) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) → ( ( ¬ a = c ∨ ¬ b = d ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ;;
	step 49 : wff = imp3a (step 48) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( ( ¬ a R c ∧ ( ¬ a = c ∨ ¬ b S d ) ) ∧ ( ¬ a = c ∨ ¬ b = d ) ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 50 : wff = syl5bi (step 14, step 49) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ¬ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 51 : wff = df-3or () |- ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ∨ ( c R a ∨ ( c = a ∧ d S b ) ) ) ↔ ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) ∨ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 52 : wff = df-or () |- ( ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) ∨ ( c R a ∨ ( c = a ∧ d S b ) ) ) ↔ ( ¬ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 53 : wff = bitri (step 51, step 52) |- ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ∨ ( c R a ∨ ( c = a ∧ d S b ) ) ) ↔ ( ¬ ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ) → ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 54 : wff = sylibr (step 50, step 53) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ∨ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 55 : wff = pm3.2 () |- ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) → ( ( a R c ∨ ( a = c ∧ b S d ) ) → ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ) ;;
	step 56 : wff = ad2ant2l (step 55) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( a R c ∨ ( a = c ∧ b S d ) ) → ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ) ;;
	step 57 : wff = idd () |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( a = c ∧ b = d ) → ( a = c ∧ b = d ) ) ) ;;
	step 58 : wff = simpr () |- ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) → ( a ∈ A ∧ c ∈ A ) ) ;;
	step 59 : wff = ancomd (step 58) |- ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) → ( c ∈ A ∧ a ∈ A ) ) ;;
	step 60 : wff = simpr () |- ( ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) → ( b ∈ B ∧ d ∈ B ) ) ;;
	step 61 : wff = ancomd (step 60) |- ( ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) → ( d ∈ B ∧ b ∈ B ) ) ;;
	step 62 : wff = pm3.2 () |- ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) → ( ( c R a ∨ ( c = a ∧ d S b ) ) → ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ;;
	step 63 : wff = syl2an (step 59, step 61, step 62) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( c R a ∨ ( c = a ∧ d S b ) ) → ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ;;
	step 64 : wff = 3orim123d (step 56, step 57, step 63) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( ( a R c ∨ ( a = c ∧ b S d ) ) ∨ ( a = c ∧ b = d ) ∨ ( c R a ∨ ( c = a ∧ d S b ) ) ) → ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ) ;;
	step 65 : wff = mpd (step 54, step 64) |- ( ( ( R Or A ∧ ( a ∈ A ∧ c ∈ A ) ) ∧ ( S Or B ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ;;
	step 66 : wff = an4s (step 65) |- ( ( ( R Or A ∧ S Or B ) ∧ ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ) → ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ;;
	step 67 : wff = expcom (step 66) |- ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ) ;;
	step 68 : wff = an4s (step 67) |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ) ;;
	step 69 : wff = breq12 () |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( t T u ↔ 〈 a , b 〉 T 〈 c , d 〉 ) ) ;;
	step 70 : wff = eqeq12 () |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( t = u ↔ 〈 a , b 〉 = 〈 c , d 〉 ) ) ;;
	step 71 : wff = breq12 () |- ( ( u = 〈 c , d 〉 ∧ t = 〈 a , b 〉 ) → ( u T t ↔ 〈 c , d 〉 T 〈 a , b 〉 ) ) ;;
	step 72 : wff = ancoms (step 71) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( u T t ↔ 〈 c , d 〉 T 〈 a , b 〉 ) ) ;;
	step 73 : wff = 3orbi123d (step 69, step 70, step 72) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( ( t T u ∨ t = u ∨ u T t ) ↔ ( 〈 a , b 〉 T 〈 c , d 〉 ∨ 〈 a , b 〉 = 〈 c , d 〉 ∨ 〈 c , d 〉 T 〈 a , b 〉 ) ) ) ;;
	step 74 : wff = xporderlem (hyp 1) |- ( 〈 a , b 〉 T 〈 c , d 〉 ↔ ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ) ;;
	step 75 : wff = vex () |- a ∈ _V ;;
	step 76 : wff = vex () |- b ∈ _V ;;
	step 77 : wff = opth (step 75, step 76) |- ( 〈 a , b 〉 = 〈 c , d 〉 ↔ ( a = c ∧ b = d ) ) ;;
	step 78 : wff = xporderlem (hyp 1) |- ( 〈 c , d 〉 T 〈 a , b 〉 ↔ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ;;
	step 79 : wff = 3orbi123i (step 74, step 77, step 78) |- ( ( 〈 a , b 〉 T 〈 c , d 〉 ∨ 〈 a , b 〉 = 〈 c , d 〉 ∨ 〈 c , d 〉 T 〈 a , b 〉 ) ↔ ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ;;
	step 80 : wff = syl6bb (step 73, step 79) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( ( t T u ∨ t = u ∨ u T t ) ↔ ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) ) ) ;;
	step 81 : wff = biimprcd (step 80) |- ( ( ( ( ( a ∈ A ∧ c ∈ A ) ∧ ( b ∈ B ∧ d ∈ B ) ) ∧ ( a R c ∨ ( a = c ∧ b S d ) ) ) ∨ ( a = c ∧ b = d ) ∨ ( ( ( c ∈ A ∧ a ∈ A ) ∧ ( d ∈ B ∧ b ∈ B ) ) ∧ ( c R a ∨ ( c = a ∧ d S b ) ) ) ) → ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 82 : wff = syl6 (step 68, step 81) |- ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( t T u ∨ t = u ∨ u T t ) ) ) ) ;;
	step 83 : wff = com3r (step 82) |- ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) → ( ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ) ;;
	step 84 : wff = imp (step 83) |- ( ( ( t = 〈 a , b 〉 ∧ u = 〈 c , d 〉 ) ∧ ( ( a ∈ A ∧ b ∈ B ) ∧ ( c ∈ A ∧ d ∈ B ) ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 85 : wff = an4s (step 84) |- ( ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ∧ ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 86 : wff = expcom (step 85) |- ( ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ) ;;
	step 87 : wff = exlimivv (step 86) |- ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ) ;;
	step 88 : wff = com12 (step 87) |- ( ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ) ;;
	step 89 : wff = exlimivv (step 88) |- ( ∃ a ∃ b ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) → ( ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ) ;;
	step 90 : wff = imp (step 89) |- ( ( ∃ a ∃ b ( t = 〈 a , b 〉 ∧ ( a ∈ A ∧ b ∈ B ) ) ∧ ∃ c ∃ d ( u = 〈 c , d 〉 ∧ ( c ∈ A ∧ d ∈ B ) ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 91 : wff = syl2anb (step 5, step 6, step 90) |- ( ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ) → ( ( R Or A ∧ S Or B ) → ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 92 : wff = com12 (step 91) |- ( ( R Or A ∧ S Or B ) → ( ( t ∈ ( A × B ) ∧ u ∈ ( A × B ) ) → ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 93 : wff = ralrimivv (step 92) |- ( ( R Or A ∧ S Or B ) → ∀ t ∈ ( A × B ) ∀ u ∈ ( A × B ) ( t T u ∨ t = u ∨ u T t ) ) ;;
	step 94 : wff = df-so () |- ( T Or ( A × B ) ↔ ( T Po ( A × B ) ∧ ∀ t ∈ ( A × B ) ∀ u ∈ ( A × B ) ( t T u ∨ t = u ∨ u T t ) ) ) ;;
	step 95 : wff = sylanbrc (step 4, step 93, step 94) |- ( ( R Or A ∧ S Or B ) → T Or ( A × B ) ) ;;
	qed prop 1 = step 95 ;;
}

/* A lexicographical ordering of two well-ordered classes.  (Contributed by
       Scott Fenton, 17-Mar-2011.)  (Revised by Mario Carneiro, 7-Mar-2013.) */

theorem wexp (x : set, y : set, A : class, B : class, R : class, S : class, T : class) disjointed(A x y, B x y, R x y, S x y) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ ( A × B ) ∧ y ∈ ( A × B ) ) ∧ ( ( 1st ` x ) R ( 1st ` y ) ∨ ( ( 1st ` x ) = ( 1st ` y ) ∧ ( 2nd ` x ) S ( 2nd ` y ) ) ) ) } ;;
	-----------------------
	prop 1 : wff = |- ( ( R We A ∧ S We B ) → T We ( A × B ) ) ;;
}

proof of wexp {
	step 1 : wff = wefr () |- ( R We A → R Fr A ) ;;
	step 2 : wff = wefr () |- ( S We B → S Fr B ) ;;
	step 3 : wff = frxp (hyp 1) |- ( ( R Fr A ∧ S Fr B ) → T Fr ( A × B ) ) ;;
	step 4 : wff = syl2an (step 1, step 2, step 3) |- ( ( R We A ∧ S We B ) → T Fr ( A × B ) ) ;;
	step 5 : wff = weso () |- ( R We A → R Or A ) ;;
	step 6 : wff = weso () |- ( S We B → S Or B ) ;;
	step 7 : wff = soxp (hyp 1) |- ( ( R Or A ∧ S Or B ) → T Or ( A × B ) ) ;;
	step 8 : wff = syl2an (step 5, step 6, step 7) |- ( ( R We A ∧ S We B ) → T Or ( A × B ) ) ;;
	step 9 : wff = df-we () |- ( T We ( A × B ) ↔ ( T Fr ( A × B ) ∧ T Or ( A × B ) ) ) ;;
	step 10 : wff = sylanbrc (step 4, step 8, step 9) |- ( ( R We A ∧ S We B ) → T We ( A × B ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Lemma for ~ fnwe .  (Contributed by Mario Carneiro, 10-Mar-2013.)
         (Revised by Mario Carneiro, 18-Nov-2014.) */

theorem fnwelem (ph : wff, x : set, y : set, z : set, w : set, v : set, u : set, A : class, B : class, Q : class, R : class, S : class, T : class, F : class, G : class) disjointed(u v w x y z A, u v w x y z B, w x y G, w x z ph, u v w x y z F, w x y Q, u v w x y R, u v w x y S, w T) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) } ;;
	hyp 2 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 3 : wff = |- ( ph → R We B ) ;;
	hyp 4 : wff = |- ( ph → S We A ) ;;
	hyp 5 : wff = |- ( ph → ( F " w ) ∈ _V ) ;;
	hyp 6 : wff = |- Q = { 〈 u , v 〉 | ( ( u ∈ ( B × A ) ∧ v ∈ ( B × A ) ) ∧ ( ( 1st ` u ) R ( 1st ` v ) ∨ ( ( 1st ` u ) = ( 1st ` v ) ∧ ( 2nd ` u ) S ( 2nd ` v ) ) ) ) } ;;
	hyp 7 : wff = |- G = ( z ∈ A ↦ 〈 ( F ` z ) , z 〉 ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → T We A ) ;;
}

proof of fnwelem {
	step 1 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 2 : wff = simpr () |- ( ( F : A ⟶ B ∧ z ∈ A ) → z ∈ A ) ;;
	step 3 : wff = opelxp () |- ( 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ↔ ( ( F ` z ) ∈ B ∧ z ∈ A ) ) ;;
	step 4 : wff = sylanbrc (step 1, step 2, step 3) |- ( ( F : A ⟶ B ∧ z ∈ A ) → 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ) ;;
	step 5 : wff = fmptd (step 4, hyp 7) |- ( F : A ⟶ B → G : A ⟶ ( B × A ) ) ;;
	step 6 : wff = frn () |- ( G : A ⟶ ( B × A ) → ran G ⊆ ( B × A ) ) ;;
	step 7 : wff = 3syl (hyp 2, step 5, step 6) |- ( ph → ran G ⊆ ( B × A ) ) ;;
	step 8 : wff = wexp (hyp 6) |- ( ( R We B ∧ S We A ) → Q We ( B × A ) ) ;;
	step 9 : wff = syl2anc (hyp 3, hyp 4, step 8) |- ( ph → Q We ( B × A ) ) ;;
	step 10 : wff = wess () |- ( ran G ⊆ ( B × A ) → ( Q We ( B × A ) → Q We ran G ) ) ;;
	step 11 : wff = sylc (step 7, step 9, step 10) |- ( ph → Q We ran G ) ;;
	step 12 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 13 : wff = simpr () |- ( ( F : A ⟶ B ∧ z ∈ A ) → z ∈ A ) ;;
	step 14 : wff = opelxp () |- ( 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ↔ ( ( F ` z ) ∈ B ∧ z ∈ A ) ) ;;
	step 15 : wff = sylanbrc (step 12, step 13, step 14) |- ( ( F : A ⟶ B ∧ z ∈ A ) → 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ) ;;
	step 16 : wff = fmptd (step 15, hyp 7) |- ( F : A ⟶ B → G : A ⟶ ( B × A ) ) ;;
	step 17 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 18 : wff = id () |- ( z = x → z = x ) ;;
	step 19 : wff = opeq12d (step 17, step 18) |- ( z = x → 〈 ( F ` z ) , z 〉 = 〈 ( F ` x ) , x 〉 ) ;;
	step 20 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 21 : wff = fvmpt (step 19, hyp 7, step 20) |- ( x ∈ A → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 22 : wff = fveq2 () |- ( z = y → ( F ` z ) = ( F ` y ) ) ;;
	step 23 : wff = id () |- ( z = y → z = y ) ;;
	step 24 : wff = opeq12d (step 22, step 23) |- ( z = y → 〈 ( F ` z ) , z 〉 = 〈 ( F ` y ) , y 〉 ) ;;
	step 25 : wff = opex () |- 〈 ( F ` y ) , y 〉 ∈ _V ;;
	step 26 : wff = fvmpt (step 24, hyp 7, step 25) |- ( y ∈ A → ( G ` y ) = 〈 ( F ` y ) , y 〉 ) ;;
	step 27 : wff = eqeqan12d (step 21, step 26) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) ↔ 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ) ) ;;
	step 28 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 29 : wff = vex () |- x ∈ _V ;;
	step 30 : wff = opth (step 28, step 29) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ↔ ( ( F ` x ) = ( F ` y ) ∧ x = y ) ) ;;
	step 31 : wff = simprbi (step 30) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 → x = y ) ;;
	step 32 : wff = syl6bi (step 27, step 31) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 33 : wff = rgen2a (step 32) |- ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ;;
	step 34 : wff = a1i (step 33) |- ( F : A ⟶ B → ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 35 : wff = dff13 () |- ( G : A ↣ ( B × A ) ↔ ( G : A ⟶ ( B × A ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ) ;;
	step 36 : wff = sylanbrc (step 16, step 34, step 35) |- ( F : A ⟶ B → G : A ↣ ( B × A ) ) ;;
	step 37 : wff = syl (hyp 2, step 36) |- ( ph → G : A ↣ ( B × A ) ) ;;
	step 38 : wff = f1f1orn () |- ( G : A ↣ ( B × A ) → G : A ⤖ ran G ) ;;
	step 39 : wff = f1ocnv () |- ( G : A ⤖ ran G → ⁻¹ G : ran G ⤖ A ) ;;
	step 40 : wff = 3syl (step 37, step 38, step 39) |- ( ph → ⁻¹ G : ran G ⤖ A ) ;;
	step 41 : wff = eqid () |- { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } ;;
	step 42 : wff = f1oiso2 (step 41) |- ( ⁻¹ G : ran G ⤖ A → ⁻¹ G Isom Q , { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } ( ran G , A ) ) ;;
	step 43 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 44 : wff = simpr () |- ( ( F : A ⟶ B ∧ z ∈ A ) → z ∈ A ) ;;
	step 45 : wff = opelxp () |- ( 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ↔ ( ( F ` z ) ∈ B ∧ z ∈ A ) ) ;;
	step 46 : wff = sylanbrc (step 43, step 44, step 45) |- ( ( F : A ⟶ B ∧ z ∈ A ) → 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ) ;;
	step 47 : wff = fmptd (step 46, hyp 7) |- ( F : A ⟶ B → G : A ⟶ ( B × A ) ) ;;
	step 48 : wff = frel () |- ( G : A ⟶ ( B × A ) → Rel G ) ;;
	step 49 : wff = dfrel2 () |- ( Rel G ↔ ⁻¹ ⁻¹ G = G ) ;;
	step 50 : wff = sylib (step 48, step 49) |- ( G : A ⟶ ( B × A ) → ⁻¹ ⁻¹ G = G ) ;;
	step 51 : wff = fveq1d (step 50) |- ( G : A ⟶ ( B × A ) → ( ⁻¹ ⁻¹ G ` x ) = ( G ` x ) ) ;;
	step 52 : wff = frel () |- ( G : A ⟶ ( B × A ) → Rel G ) ;;
	step 53 : wff = dfrel2 () |- ( Rel G ↔ ⁻¹ ⁻¹ G = G ) ;;
	step 54 : wff = sylib (step 52, step 53) |- ( G : A ⟶ ( B × A ) → ⁻¹ ⁻¹ G = G ) ;;
	step 55 : wff = fveq1d (step 54) |- ( G : A ⟶ ( B × A ) → ( ⁻¹ ⁻¹ G ` y ) = ( G ` y ) ) ;;
	step 56 : wff = breq12d (step 51, step 55) |- ( G : A ⟶ ( B × A ) → ( ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ↔ ( G ` x ) Q ( G ` y ) ) ) ;;
	step 57 : wff = syl (step 47, step 56) |- ( F : A ⟶ B → ( ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ↔ ( G ` x ) Q ( G ` y ) ) ) ;;
	step 58 : wff = adantr (step 57) |- ( ( F : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ↔ ( G ` x ) Q ( G ` y ) ) ) ;;
	step 59 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 60 : wff = id () |- ( z = x → z = x ) ;;
	step 61 : wff = opeq12d (step 59, step 60) |- ( z = x → 〈 ( F ` z ) , z 〉 = 〈 ( F ` x ) , x 〉 ) ;;
	step 62 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 63 : wff = fvmpt (step 61, hyp 7, step 62) |- ( x ∈ A → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 64 : wff = fveq2 () |- ( z = y → ( F ` z ) = ( F ` y ) ) ;;
	step 65 : wff = id () |- ( z = y → z = y ) ;;
	step 66 : wff = opeq12d (step 64, step 65) |- ( z = y → 〈 ( F ` z ) , z 〉 = 〈 ( F ` y ) , y 〉 ) ;;
	step 67 : wff = opex () |- 〈 ( F ` y ) , y 〉 ∈ _V ;;
	step 68 : wff = fvmpt (step 66, hyp 7, step 67) |- ( y ∈ A → ( G ` y ) = 〈 ( F ` y ) , y 〉 ) ;;
	step 69 : wff = breqan12d (step 63, step 68) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) Q ( G ` y ) ↔ 〈 ( F ` x ) , x 〉 Q 〈 ( F ` y ) , y 〉 ) ) ;;
	step 70 : wff = adantl (step 69) |- ( ( F : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( G ` x ) Q ( G ` y ) ↔ 〈 ( F ` x ) , x 〉 Q 〈 ( F ` y ) , y 〉 ) ) ;;
	step 71 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( F ` x ) ∈ B ) ;;
	step 72 : wff = simpr () |- ( ( F : A ⟶ B ∧ x ∈ A ) → x ∈ A ) ;;
	step 73 : wff = jca (step 71, step 72) |- ( ( F : A ⟶ B ∧ x ∈ A ) → ( ( F ` x ) ∈ B ∧ x ∈ A ) ) ;;
	step 74 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ y ∈ A ) → ( F ` y ) ∈ B ) ;;
	step 75 : wff = simpr () |- ( ( F : A ⟶ B ∧ y ∈ A ) → y ∈ A ) ;;
	step 76 : wff = jca (step 74, step 75) |- ( ( F : A ⟶ B ∧ y ∈ A ) → ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ;;
	step 77 : wff = anim12dan (step 73, step 76) |- ( ( F : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ) ;;
	step 78 : wff = biantrurd (step 77) |- ( ( F : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ↔ ( ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ) ) ;;
	step 79 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 80 : wff = opex () |- 〈 ( F ` y ) , y 〉 ∈ _V ;;
	step 81 : wff = eleq1 () |- ( u = 〈 ( F ` x ) , x 〉 → ( u ∈ ( B × A ) ↔ 〈 ( F ` x ) , x 〉 ∈ ( B × A ) ) ) ;;
	step 82 : wff = opelxp () |- ( 〈 ( F ` x ) , x 〉 ∈ ( B × A ) ↔ ( ( F ` x ) ∈ B ∧ x ∈ A ) ) ;;
	step 83 : wff = syl6bb (step 81, step 82) |- ( u = 〈 ( F ` x ) , x 〉 → ( u ∈ ( B × A ) ↔ ( ( F ` x ) ∈ B ∧ x ∈ A ) ) ) ;;
	step 84 : wff = anbi1d (step 83) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( u ∈ ( B × A ) ∧ v ∈ ( B × A ) ) ↔ ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ v ∈ ( B × A ) ) ) ) ;;
	step 85 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 86 : wff = vex () |- x ∈ _V ;;
	step 87 : wff = op1std (step 85, step 86) |- ( u = 〈 ( F ` x ) , x 〉 → ( 1st ` u ) = ( F ` x ) ) ;;
	step 88 : wff = breq1d (step 87) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( 1st ` u ) R ( 1st ` v ) ↔ ( F ` x ) R ( 1st ` v ) ) ) ;;
	step 89 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 90 : wff = vex () |- x ∈ _V ;;
	step 91 : wff = op1std (step 89, step 90) |- ( u = 〈 ( F ` x ) , x 〉 → ( 1st ` u ) = ( F ` x ) ) ;;
	step 92 : wff = eqeq1d (step 91) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( 1st ` u ) = ( 1st ` v ) ↔ ( F ` x ) = ( 1st ` v ) ) ) ;;
	step 93 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 94 : wff = vex () |- x ∈ _V ;;
	step 95 : wff = op2ndd (step 93, step 94) |- ( u = 〈 ( F ` x ) , x 〉 → ( 2nd ` u ) = x ) ;;
	step 96 : wff = breq1d (step 95) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( 2nd ` u ) S ( 2nd ` v ) ↔ x S ( 2nd ` v ) ) ) ;;
	step 97 : wff = anbi12d (step 92, step 96) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( ( 1st ` u ) = ( 1st ` v ) ∧ ( 2nd ` u ) S ( 2nd ` v ) ) ↔ ( ( F ` x ) = ( 1st ` v ) ∧ x S ( 2nd ` v ) ) ) ) ;;
	step 98 : wff = orbi12d (step 88, step 97) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( ( 1st ` u ) R ( 1st ` v ) ∨ ( ( 1st ` u ) = ( 1st ` v ) ∧ ( 2nd ` u ) S ( 2nd ` v ) ) ) ↔ ( ( F ` x ) R ( 1st ` v ) ∨ ( ( F ` x ) = ( 1st ` v ) ∧ x S ( 2nd ` v ) ) ) ) ) ;;
	step 99 : wff = anbi12d (step 84, step 98) |- ( u = 〈 ( F ` x ) , x 〉 → ( ( ( u ∈ ( B × A ) ∧ v ∈ ( B × A ) ) ∧ ( ( 1st ` u ) R ( 1st ` v ) ∨ ( ( 1st ` u ) = ( 1st ` v ) ∧ ( 2nd ` u ) S ( 2nd ` v ) ) ) ) ↔ ( ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ v ∈ ( B × A ) ) ∧ ( ( F ` x ) R ( 1st ` v ) ∨ ( ( F ` x ) = ( 1st ` v ) ∧ x S ( 2nd ` v ) ) ) ) ) ) ;;
	step 100 : wff = eleq1 () |- ( v = 〈 ( F ` y ) , y 〉 → ( v ∈ ( B × A ) ↔ 〈 ( F ` y ) , y 〉 ∈ ( B × A ) ) ) ;;
	step 101 : wff = opelxp () |- ( 〈 ( F ` y ) , y 〉 ∈ ( B × A ) ↔ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ;;
	step 102 : wff = syl6bb (step 100, step 101) |- ( v = 〈 ( F ` y ) , y 〉 → ( v ∈ ( B × A ) ↔ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ) ;;
	step 103 : wff = anbi2d (step 102) |- ( v = 〈 ( F ` y ) , y 〉 → ( ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ v ∈ ( B × A ) ) ↔ ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ) ) ;;
	step 104 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 105 : wff = vex () |- y ∈ _V ;;
	step 106 : wff = op1std (step 104, step 105) |- ( v = 〈 ( F ` y ) , y 〉 → ( 1st ` v ) = ( F ` y ) ) ;;
	step 107 : wff = breq2d (step 106) |- ( v = 〈 ( F ` y ) , y 〉 → ( ( F ` x ) R ( 1st ` v ) ↔ ( F ` x ) R ( F ` y ) ) ) ;;
	step 108 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 109 : wff = vex () |- y ∈ _V ;;
	step 110 : wff = op1std (step 108, step 109) |- ( v = 〈 ( F ` y ) , y 〉 → ( 1st ` v ) = ( F ` y ) ) ;;
	step 111 : wff = eqeq2d (step 110) |- ( v = 〈 ( F ` y ) , y 〉 → ( ( F ` x ) = ( 1st ` v ) ↔ ( F ` x ) = ( F ` y ) ) ) ;;
	step 112 : wff = fvex () |- ( F ` y ) ∈ _V ;;
	step 113 : wff = vex () |- y ∈ _V ;;
	step 114 : wff = op2ndd (step 112, step 113) |- ( v = 〈 ( F ` y ) , y 〉 → ( 2nd ` v ) = y ) ;;
	step 115 : wff = breq2d (step 114) |- ( v = 〈 ( F ` y ) , y 〉 → ( x S ( 2nd ` v ) ↔ x S y ) ) ;;
	step 116 : wff = anbi12d (step 111, step 115) |- ( v = 〈 ( F ` y ) , y 〉 → ( ( ( F ` x ) = ( 1st ` v ) ∧ x S ( 2nd ` v ) ) ↔ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ;;
	step 117 : wff = orbi12d (step 107, step 116) |- ( v = 〈 ( F ` y ) , y 〉 → ( ( ( F ` x ) R ( 1st ` v ) ∨ ( ( F ` x ) = ( 1st ` v ) ∧ x S ( 2nd ` v ) ) ) ↔ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ) ;;
	step 118 : wff = anbi12d (step 103, step 117) |- ( v = 〈 ( F ` y ) , y 〉 → ( ( ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ v ∈ ( B × A ) ) ∧ ( ( F ` x ) R ( 1st ` v ) ∨ ( ( F ` x ) = ( 1st ` v ) ∧ x S ( 2nd ` v ) ) ) ) ↔ ( ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ) ) ;;
	step 119 : wff = brab (step 79, step 80, step 99, step 118, hyp 6) |- ( 〈 ( F ` x ) , x 〉 Q 〈 ( F ` y ) , y 〉 ↔ ( ( ( ( F ` x ) ∈ B ∧ x ∈ A ) ∧ ( ( F ` y ) ∈ B ∧ y ∈ A ) ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ) ;;
	step 120 : wff = syl6rbbr (step 78, step 119) |- ( ( F : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( 〈 ( F ` x ) , x 〉 Q 〈 ( F ` y ) , y 〉 ↔ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ) ;;
	step 121 : wff = 3bitrrd (step 58, step 70, step 120) |- ( ( F : A ⟶ B ∧ ( x ∈ A ∧ y ∈ A ) ) → ( ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ↔ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) ) ;;
	step 122 : wff = pm5.32da (step 121) |- ( F : A ⟶ B → ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) ) ) ;;
	step 123 : wff = opabbidv (step 122) |- ( F : A ⟶ B → { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) } = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } ) ;;
	step 124 : wff = syl5eq (hyp 1, step 123) |- ( F : A ⟶ B → T = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } ) ;;
	step 125 : wff = isoeq3 () |- ( T = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } → ( ⁻¹ G Isom Q , T ( ran G , A ) ↔ ⁻¹ G Isom Q , { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } ( ran G , A ) ) ) ;;
	step 126 : wff = syl (step 124, step 125) |- ( F : A ⟶ B → ( ⁻¹ G Isom Q , T ( ran G , A ) ↔ ⁻¹ G Isom Q , { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ⁻¹ ⁻¹ G ` x ) Q ( ⁻¹ ⁻¹ G ` y ) ) } ( ran G , A ) ) ) ;;
	step 127 : wff = syl5ibr (step 42, step 126) |- ( F : A ⟶ B → ( ⁻¹ G : ran G ⤖ A → ⁻¹ G Isom Q , T ( ran G , A ) ) ) ;;
	step 128 : wff = sylc (hyp 2, step 40, step 127) |- ( ph → ⁻¹ G Isom Q , T ( ran G , A ) ) ;;
	step 129 : wff = isocnv () |- ( ⁻¹ G Isom Q , T ( ran G , A ) → ⁻¹ ⁻¹ G Isom T , Q ( A , ran G ) ) ;;
	step 130 : wff = syl (step 128, step 129) |- ( ph → ⁻¹ ⁻¹ G Isom T , Q ( A , ran G ) ) ;;
	step 131 : wff = imacnvcnv () |- ( ⁻¹ ⁻¹ G " w ) = ( G " w ) ;;
	step 132 : wff = imadmres () |- ( G " dom ( G ↾ w ) ) = ( G " w ) ;;
	step 133 : wff = dmres () |- dom ( G ↾ w ) = ( w ∩ dom G ) ;;
	step 134 : wff = elin2 (step 133) |- ( x ∈ dom ( G ↾ w ) ↔ ( x ∈ w ∧ x ∈ dom G ) ) ;;
	step 135 : wff = simprr () |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ dom G ) ;;
	step 136 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 137 : wff = simpr () |- ( ( F : A ⟶ B ∧ z ∈ A ) → z ∈ A ) ;;
	step 138 : wff = opelxp () |- ( 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ↔ ( ( F ` z ) ∈ B ∧ z ∈ A ) ) ;;
	step 139 : wff = sylanbrc (step 136, step 137, step 138) |- ( ( F : A ⟶ B ∧ z ∈ A ) → 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ) ;;
	step 140 : wff = fmptd (step 139, hyp 7) |- ( F : A ⟶ B → G : A ⟶ ( B × A ) ) ;;
	step 141 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 142 : wff = id () |- ( z = x → z = x ) ;;
	step 143 : wff = opeq12d (step 141, step 142) |- ( z = x → 〈 ( F ` z ) , z 〉 = 〈 ( F ` x ) , x 〉 ) ;;
	step 144 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 145 : wff = fvmpt (step 143, hyp 7, step 144) |- ( x ∈ A → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 146 : wff = fveq2 () |- ( z = y → ( F ` z ) = ( F ` y ) ) ;;
	step 147 : wff = id () |- ( z = y → z = y ) ;;
	step 148 : wff = opeq12d (step 146, step 147) |- ( z = y → 〈 ( F ` z ) , z 〉 = 〈 ( F ` y ) , y 〉 ) ;;
	step 149 : wff = opex () |- 〈 ( F ` y ) , y 〉 ∈ _V ;;
	step 150 : wff = fvmpt (step 148, hyp 7, step 149) |- ( y ∈ A → ( G ` y ) = 〈 ( F ` y ) , y 〉 ) ;;
	step 151 : wff = eqeqan12d (step 145, step 150) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) ↔ 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ) ) ;;
	step 152 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 153 : wff = vex () |- x ∈ _V ;;
	step 154 : wff = opth (step 152, step 153) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ↔ ( ( F ` x ) = ( F ` y ) ∧ x = y ) ) ;;
	step 155 : wff = simprbi (step 154) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 → x = y ) ;;
	step 156 : wff = syl6bi (step 151, step 155) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 157 : wff = rgen2a (step 156) |- ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ;;
	step 158 : wff = a1i (step 157) |- ( F : A ⟶ B → ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 159 : wff = dff13 () |- ( G : A ↣ ( B × A ) ↔ ( G : A ⟶ ( B × A ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ) ;;
	step 160 : wff = sylanbrc (step 140, step 158, step 159) |- ( F : A ⟶ B → G : A ↣ ( B × A ) ) ;;
	step 161 : wff = f1dm () |- ( G : A ↣ ( B × A ) → dom G = A ) ;;
	step 162 : wff = 3syl (hyp 2, step 160, step 161) |- ( ph → dom G = A ) ;;
	step 163 : wff = adantr (step 162) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → dom G = A ) ;;
	step 164 : wff = eleqtrd (step 135, step 163) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ A ) ;;
	step 165 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 166 : wff = id () |- ( z = x → z = x ) ;;
	step 167 : wff = opeq12d (step 165, step 166) |- ( z = x → 〈 ( F ` z ) , z 〉 = 〈 ( F ` x ) , x 〉 ) ;;
	step 168 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 169 : wff = fvmpt (step 167, hyp 7, step 168) |- ( x ∈ A → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 170 : wff = syl (step 164, step 169) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 171 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 172 : wff = syl (hyp 2, step 171) |- ( ph → F Fn A ) ;;
	step 173 : wff = adantr (step 172) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → F Fn A ) ;;
	step 174 : wff = dmres () |- dom ( F ↾ w ) = ( w ∩ dom F ) ;;
	step 175 : wff = inss2 () |- ( w ∩ dom F ) ⊆ dom F ;;
	step 176 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 177 : wff = syl (hyp 2, step 176) |- ( ph → F Fn A ) ;;
	step 178 : wff = adantr (step 177) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → F Fn A ) ;;
	step 179 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 180 : wff = syl (step 178, step 179) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → dom F = A ) ;;
	step 181 : wff = syl5sseq (step 175, step 180) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → ( w ∩ dom F ) ⊆ A ) ;;
	step 182 : wff = syl5eqss (step 174, step 181) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → dom ( F ↾ w ) ⊆ A ) ;;
	step 183 : wff = simprl () |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ w ) ;;
	step 184 : wff = simprr () |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ dom G ) ;;
	step 185 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 186 : wff = simpr () |- ( ( F : A ⟶ B ∧ z ∈ A ) → z ∈ A ) ;;
	step 187 : wff = opelxp () |- ( 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ↔ ( ( F ` z ) ∈ B ∧ z ∈ A ) ) ;;
	step 188 : wff = sylanbrc (step 185, step 186, step 187) |- ( ( F : A ⟶ B ∧ z ∈ A ) → 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ) ;;
	step 189 : wff = fmptd (step 188, hyp 7) |- ( F : A ⟶ B → G : A ⟶ ( B × A ) ) ;;
	step 190 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 191 : wff = id () |- ( z = x → z = x ) ;;
	step 192 : wff = opeq12d (step 190, step 191) |- ( z = x → 〈 ( F ` z ) , z 〉 = 〈 ( F ` x ) , x 〉 ) ;;
	step 193 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 194 : wff = fvmpt (step 192, hyp 7, step 193) |- ( x ∈ A → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 195 : wff = fveq2 () |- ( z = y → ( F ` z ) = ( F ` y ) ) ;;
	step 196 : wff = id () |- ( z = y → z = y ) ;;
	step 197 : wff = opeq12d (step 195, step 196) |- ( z = y → 〈 ( F ` z ) , z 〉 = 〈 ( F ` y ) , y 〉 ) ;;
	step 198 : wff = opex () |- 〈 ( F ` y ) , y 〉 ∈ _V ;;
	step 199 : wff = fvmpt (step 197, hyp 7, step 198) |- ( y ∈ A → ( G ` y ) = 〈 ( F ` y ) , y 〉 ) ;;
	step 200 : wff = eqeqan12d (step 194, step 199) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) ↔ 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ) ) ;;
	step 201 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 202 : wff = vex () |- x ∈ _V ;;
	step 203 : wff = opth (step 201, step 202) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ↔ ( ( F ` x ) = ( F ` y ) ∧ x = y ) ) ;;
	step 204 : wff = simprbi (step 203) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 → x = y ) ;;
	step 205 : wff = syl6bi (step 200, step 204) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 206 : wff = rgen2a (step 205) |- ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ;;
	step 207 : wff = a1i (step 206) |- ( F : A ⟶ B → ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 208 : wff = dff13 () |- ( G : A ↣ ( B × A ) ↔ ( G : A ⟶ ( B × A ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ) ;;
	step 209 : wff = sylanbrc (step 189, step 207, step 208) |- ( F : A ⟶ B → G : A ↣ ( B × A ) ) ;;
	step 210 : wff = f1dm () |- ( G : A ↣ ( B × A ) → dom G = A ) ;;
	step 211 : wff = 3syl (hyp 2, step 209, step 210) |- ( ph → dom G = A ) ;;
	step 212 : wff = adantr (step 211) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → dom G = A ) ;;
	step 213 : wff = eleqtrd (step 184, step 212) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ A ) ;;
	step 214 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 215 : wff = syl (hyp 2, step 214) |- ( ph → F Fn A ) ;;
	step 216 : wff = adantr (step 215) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → F Fn A ) ;;
	step 217 : wff = fndm () |- ( F Fn A → dom F = A ) ;;
	step 218 : wff = syl (step 216, step 217) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → dom F = A ) ;;
	step 219 : wff = eleqtrrd (step 213, step 218) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ dom F ) ;;
	step 220 : wff = dmres () |- dom ( F ↾ w ) = ( w ∩ dom F ) ;;
	step 221 : wff = elin2 (step 220) |- ( x ∈ dom ( F ↾ w ) ↔ ( x ∈ w ∧ x ∈ dom F ) ) ;;
	step 222 : wff = sylanbrc (step 183, step 219, step 221) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ dom ( F ↾ w ) ) ;;
	step 223 : wff = fnfvima () |- ( ( F Fn A ∧ dom ( F ↾ w ) ⊆ A ∧ x ∈ dom ( F ↾ w ) ) → ( F ` x ) ∈ ( F " dom ( F ↾ w ) ) ) ;;
	step 224 : wff = syl3anc (step 173, step 182, step 222, step 223) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → ( F ` x ) ∈ ( F " dom ( F ↾ w ) ) ) ;;
	step 225 : wff = imadmres () |- ( F " dom ( F ↾ w ) ) = ( F " w ) ;;
	step 226 : wff = syl6eleq (step 224, step 225) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → ( F ` x ) ∈ ( F " w ) ) ;;
	step 227 : wff = simprl () |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → x ∈ w ) ;;
	step 228 : wff = opelxpi () |- ( ( ( F ` x ) ∈ ( F " w ) ∧ x ∈ w ) → 〈 ( F ` x ) , x 〉 ∈ ( ( F " w ) × w ) ) ;;
	step 229 : wff = syl2anc (step 226, step 227, step 228) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → 〈 ( F ` x ) , x 〉 ∈ ( ( F " w ) × w ) ) ;;
	step 230 : wff = eqeltrd (step 170, step 229) |- ( ( ph ∧ ( x ∈ w ∧ x ∈ dom G ) ) → ( G ` x ) ∈ ( ( F " w ) × w ) ) ;;
	step 231 : wff = sylan2b (step 134, step 230) |- ( ( ph ∧ x ∈ dom ( G ↾ w ) ) → ( G ` x ) ∈ ( ( F " w ) × w ) ) ;;
	step 232 : wff = ralrimiva (step 231) |- ( ph → ∀ x ∈ dom ( G ↾ w ) ( G ` x ) ∈ ( ( F " w ) × w ) ) ;;
	step 233 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 234 : wff = simpr () |- ( ( F : A ⟶ B ∧ z ∈ A ) → z ∈ A ) ;;
	step 235 : wff = opelxp () |- ( 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ↔ ( ( F ` z ) ∈ B ∧ z ∈ A ) ) ;;
	step 236 : wff = sylanbrc (step 233, step 234, step 235) |- ( ( F : A ⟶ B ∧ z ∈ A ) → 〈 ( F ` z ) , z 〉 ∈ ( B × A ) ) ;;
	step 237 : wff = fmptd (step 236, hyp 7) |- ( F : A ⟶ B → G : A ⟶ ( B × A ) ) ;;
	step 238 : wff = fveq2 () |- ( z = x → ( F ` z ) = ( F ` x ) ) ;;
	step 239 : wff = id () |- ( z = x → z = x ) ;;
	step 240 : wff = opeq12d (step 238, step 239) |- ( z = x → 〈 ( F ` z ) , z 〉 = 〈 ( F ` x ) , x 〉 ) ;;
	step 241 : wff = opex () |- 〈 ( F ` x ) , x 〉 ∈ _V ;;
	step 242 : wff = fvmpt (step 240, hyp 7, step 241) |- ( x ∈ A → ( G ` x ) = 〈 ( F ` x ) , x 〉 ) ;;
	step 243 : wff = fveq2 () |- ( z = y → ( F ` z ) = ( F ` y ) ) ;;
	step 244 : wff = id () |- ( z = y → z = y ) ;;
	step 245 : wff = opeq12d (step 243, step 244) |- ( z = y → 〈 ( F ` z ) , z 〉 = 〈 ( F ` y ) , y 〉 ) ;;
	step 246 : wff = opex () |- 〈 ( F ` y ) , y 〉 ∈ _V ;;
	step 247 : wff = fvmpt (step 245, hyp 7, step 246) |- ( y ∈ A → ( G ` y ) = 〈 ( F ` y ) , y 〉 ) ;;
	step 248 : wff = eqeqan12d (step 242, step 247) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) ↔ 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ) ) ;;
	step 249 : wff = fvex () |- ( F ` x ) ∈ _V ;;
	step 250 : wff = vex () |- x ∈ _V ;;
	step 251 : wff = opth (step 249, step 250) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 ↔ ( ( F ` x ) = ( F ` y ) ∧ x = y ) ) ;;
	step 252 : wff = simprbi (step 251) |- ( 〈 ( F ` x ) , x 〉 = 〈 ( F ` y ) , y 〉 → x = y ) ;;
	step 253 : wff = syl6bi (step 248, step 252) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 254 : wff = rgen2a (step 253) |- ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ;;
	step 255 : wff = a1i (step 254) |- ( F : A ⟶ B → ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ;;
	step 256 : wff = dff13 () |- ( G : A ↣ ( B × A ) ↔ ( G : A ⟶ ( B × A ) ∧ ∀ x ∈ A ∀ y ∈ A ( ( G ` x ) = ( G ` y ) → x = y ) ) ) ;;
	step 257 : wff = sylanbrc (step 237, step 255, step 256) |- ( F : A ⟶ B → G : A ↣ ( B × A ) ) ;;
	step 258 : wff = f1fun () |- ( G : A ↣ ( B × A ) → Fun G ) ;;
	step 259 : wff = 3syl (hyp 2, step 257, step 258) |- ( ph → Fun G ) ;;
	step 260 : wff = resss () |- ( G ↾ w ) ⊆ G ;;
	step 261 : wff = dmss () |- ( ( G ↾ w ) ⊆ G → dom ( G ↾ w ) ⊆ dom G ) ;;
	step 262 : wff = ax-mp (step 260, step 261) |- dom ( G ↾ w ) ⊆ dom G ;;
	step 263 : wff = funimass4 () |- ( ( Fun G ∧ dom ( G ↾ w ) ⊆ dom G ) → ( ( G " dom ( G ↾ w ) ) ⊆ ( ( F " w ) × w ) ↔ ∀ x ∈ dom ( G ↾ w ) ( G ` x ) ∈ ( ( F " w ) × w ) ) ) ;;
	step 264 : wff = sylancl (step 259, step 262, step 263) |- ( ph → ( ( G " dom ( G ↾ w ) ) ⊆ ( ( F " w ) × w ) ↔ ∀ x ∈ dom ( G ↾ w ) ( G ` x ) ∈ ( ( F " w ) × w ) ) ) ;;
	step 265 : wff = mpbird (step 232, step 264) |- ( ph → ( G " dom ( G ↾ w ) ) ⊆ ( ( F " w ) × w ) ) ;;
	step 266 : wff = syl5eqssr (step 132, step 265) |- ( ph → ( G " w ) ⊆ ( ( F " w ) × w ) ) ;;
	step 267 : wff = vex () |- w ∈ _V ;;
	step 268 : wff = xpexg () |- ( ( ( F " w ) ∈ _V ∧ w ∈ _V ) → ( ( F " w ) × w ) ∈ _V ) ;;
	step 269 : wff = sylancl (hyp 5, step 267, step 268) |- ( ph → ( ( F " w ) × w ) ∈ _V ) ;;
	step 270 : wff = ssexg () |- ( ( ( G " w ) ⊆ ( ( F " w ) × w ) ∧ ( ( F " w ) × w ) ∈ _V ) → ( G " w ) ∈ _V ) ;;
	step 271 : wff = syl2anc (step 266, step 269, step 270) |- ( ph → ( G " w ) ∈ _V ) ;;
	step 272 : wff = syl5eqel (step 131, step 271) |- ( ph → ( ⁻¹ ⁻¹ G " w ) ∈ _V ) ;;
	step 273 : wff = alrimiv (step 272) |- ( ph → ∀ w ( ⁻¹ ⁻¹ G " w ) ∈ _V ) ;;
	step 274 : wff = isowe2 () |- ( ( ⁻¹ ⁻¹ G Isom T , Q ( A , ran G ) ∧ ∀ w ( ⁻¹ ⁻¹ G " w ) ∈ _V ) → ( Q We ran G → T We A ) ) ;;
	step 275 : wff = syl2anc (step 130, step 273, step 274) |- ( ph → ( Q We ran G → T We A ) ) ;;
	step 276 : wff = mpd (step 11, step 275) |- ( ph → T We A ) ;;
	qed prop 1 = step 276 ;;
}

/* A variant on lexicographic order, which sorts first by some function of
       the base set, and then by a "backup" well-ordering when the function
       value is equal on both elements.  (Contributed by Mario Carneiro,
       10-Mar-2013.)  (Revised by Mario Carneiro, 18-Nov-2014.) */

theorem fnwe (ph : wff, x : set, y : set, w : set, A : class, B : class, R : class, S : class, T : class, F : class) disjointed(u v w x y z A, u v w x y z B, w x y, w x z ph, u v w x y z F, w x y, u v w x y R, u v w x y S, w T) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) } ;;
	hyp 2 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 3 : wff = |- ( ph → R We B ) ;;
	hyp 4 : wff = |- ( ph → S We A ) ;;
	hyp 5 : wff = |- ( ph → ( F " w ) ∈ _V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → T We A ) ;;
}

proof of fnwe {
	var z : set, v : set, u : set;;
	step 1 : wff = eqid () |- { 〈 u , v 〉 | ( ( u ∈ ( B × A ) ∧ v ∈ ( B × A ) ) ∧ ( ( 1st ` u ) R ( 1st ` v ) ∨ ( ( 1st ` u ) = ( 1st ` v ) ∧ ( 2nd ` u ) S ( 2nd ` v ) ) ) ) } = { 〈 u , v 〉 | ( ( u ∈ ( B × A ) ∧ v ∈ ( B × A ) ) ∧ ( ( 1st ` u ) R ( 1st ` v ) ∨ ( ( 1st ` u ) = ( 1st ` v ) ∧ ( 2nd ` u ) S ( 2nd ` v ) ) ) ) } ;;
	step 2 : wff = eqid () |- ( z ∈ A ↦ 〈 ( F ` z ) , z 〉 ) = ( z ∈ A ↦ 〈 ( F ` z ) , z 〉 ) ;;
	step 3 : wff = fnwelem (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, step 1, step 2) |- ( ph → T We A ) ;;
	qed prop 1 = step 3 ;;
}

/* Condition for the well-order in ~ fnwe to be set-like.  (Contributed by
       Mario Carneiro, 25-Jun-2015.) */

theorem fnse (ph : wff, x : set, y : set, w : set, A : class, B : class, R : class, S : class, T : class, F : class) disjointed(x y z A, u w B, u w x y F, w z ph, u w x y R, u z, x y S, w z T) {
	hyp 1 : wff = |- T = { 〈 x , y 〉 | ( ( x ∈ A ∧ y ∈ A ) ∧ ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ) } ;;
	hyp 2 : wff = |- ( ph → F : A ⟶ B ) ;;
	hyp 3 : wff = |- ( ph → R Se B ) ;;
	hyp 4 : wff = |- ( ph → ( ⁻¹ F " w ) ∈ _V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → T Se A ) ;;
}

proof of fnse {
	var z : set, u : set;;
	step 1 : wff = inss2 () |- ( A ∩ ( ⁻¹ T " { z } ) ) ⊆ ( ⁻¹ T " { z } ) ;;
	step 2 : wff = vex () |- z ∈ _V ;;
	step 3 : wff = vex () |- w ∈ _V ;;
	step 4 : wff = eliniseg (step 3) |- ( z ∈ _V → ( w ∈ ( ⁻¹ T " { z } ) ↔ w T z ) ) ;;
	step 5 : wff = ax-mp (step 2, step 4) |- ( w ∈ ( ⁻¹ T " { z } ) ↔ w T z ) ;;
	step 6 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 7 : wff = fveq2 () |- ( y = z → ( F ` y ) = ( F ` z ) ) ;;
	step 8 : wff = breqan12d (step 6, step 7) |- ( ( x = w ∧ y = z ) → ( ( F ` x ) R ( F ` y ) ↔ ( F ` w ) R ( F ` z ) ) ) ;;
	step 9 : wff = fveq2 () |- ( x = w → ( F ` x ) = ( F ` w ) ) ;;
	step 10 : wff = fveq2 () |- ( y = z → ( F ` y ) = ( F ` z ) ) ;;
	step 11 : wff = eqeqan12d (step 9, step 10) |- ( ( x = w ∧ y = z ) → ( ( F ` x ) = ( F ` y ) ↔ ( F ` w ) = ( F ` z ) ) ) ;;
	step 12 : wff = breq12 () |- ( ( x = w ∧ y = z ) → ( x S y ↔ w S z ) ) ;;
	step 13 : wff = anbi12d (step 11, step 12) |- ( ( x = w ∧ y = z ) → ( ( ( F ` x ) = ( F ` y ) ∧ x S y ) ↔ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) ) ;;
	step 14 : wff = orbi12d (step 8, step 13) |- ( ( x = w ∧ y = z ) → ( ( ( F ` x ) R ( F ` y ) ∨ ( ( F ` x ) = ( F ` y ) ∧ x S y ) ) ↔ ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) ) ) ;;
	step 15 : wff = brab2ga (step 14, hyp 1) |- ( w T z ↔ ( ( w ∈ A ∧ z ∈ A ) ∧ ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) ) ) ;;
	step 16 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ w ∈ A ) → ( F ` w ) ∈ B ) ;;
	step 17 : wff = sylan (hyp 2, step 16) |- ( ( ph ∧ w ∈ A ) → ( F ` w ) ∈ B ) ;;
	step 18 : wff = adantrr (step 17) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( F ` w ) ∈ B ) ;;
	step 19 : wff = breq1 () |- ( u = ( F ` w ) → ( u R ( F ` z ) ↔ ( F ` w ) R ( F ` z ) ) ) ;;
	step 20 : wff = elrab3 (step 19) |- ( ( F ` w ) ∈ B → ( ( F ` w ) ∈ { u ∈ B | u R ( F ` z ) } ↔ ( F ` w ) R ( F ` z ) ) ) ;;
	step 21 : wff = syl (step 18, step 20) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( F ` w ) ∈ { u ∈ B | u R ( F ` z ) } ↔ ( F ` w ) R ( F ` z ) ) ) ;;
	step 22 : wff = biimprd (step 21) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( F ` w ) R ( F ` z ) → ( F ` w ) ∈ { u ∈ B | u R ( F ` z ) } ) ) ;;
	step 23 : wff = simpl () |- ( ( ( F ` w ) = ( F ` z ) ∧ w S z ) → ( F ` w ) = ( F ` z ) ) ;;
	step 24 : wff = fvex () |- ( F ` w ) ∈ _V ;;
	step 25 : wff = elsnc (step 24) |- ( ( F ` w ) ∈ { ( F ` z ) } ↔ ( F ` w ) = ( F ` z ) ) ;;
	step 26 : wff = sylibr (step 23, step 25) |- ( ( ( F ` w ) = ( F ` z ) ∧ w S z ) → ( F ` w ) ∈ { ( F ` z ) } ) ;;
	step 27 : wff = a1i (step 26) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( ( F ` w ) = ( F ` z ) ∧ w S z ) → ( F ` w ) ∈ { ( F ` z ) } ) ) ;;
	step 28 : wff = orim12d (step 22, step 27) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) → ( ( F ` w ) ∈ { u ∈ B | u R ( F ` z ) } ∨ ( F ` w ) ∈ { ( F ` z ) } ) ) ) ;;
	step 29 : wff = elun () |- ( ( F ` w ) ∈ ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ↔ ( ( F ` w ) ∈ { u ∈ B | u R ( F ` z ) } ∨ ( F ` w ) ∈ { ( F ` z ) } ) ) ;;
	step 30 : wff = syl6ibr (step 28, step 29) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) → ( F ` w ) ∈ ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ;;
	step 31 : wff = simprl () |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → w ∈ A ) ;;
	step 32 : wff = jctild (step 30, step 31) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) → ( w ∈ A ∧ ( F ` w ) ∈ ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 33 : wff = ffn () |- ( F : A ⟶ B → F Fn A ) ;;
	step 34 : wff = syl (hyp 2, step 33) |- ( ph → F Fn A ) ;;
	step 35 : wff = adantr (step 34) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → F Fn A ) ;;
	step 36 : wff = elpreima () |- ( F Fn A → ( w ∈ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ↔ ( w ∈ A ∧ ( F ` w ) ∈ ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 37 : wff = syl (step 35, step 36) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( w ∈ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ↔ ( w ∈ A ∧ ( F ` w ) ∈ ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 38 : wff = sylibrd (step 32, step 37) |- ( ( ph ∧ ( w ∈ A ∧ z ∈ A ) ) → ( ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) → w ∈ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 39 : wff = expimpd (step 38) |- ( ph → ( ( ( w ∈ A ∧ z ∈ A ) ∧ ( ( F ` w ) R ( F ` z ) ∨ ( ( F ` w ) = ( F ` z ) ∧ w S z ) ) ) → w ∈ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 40 : wff = syl5bi (step 15, step 39) |- ( ph → ( w T z → w ∈ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 41 : wff = syl5bi (step 5, step 40) |- ( ph → ( w ∈ ( ⁻¹ T " { z } ) → w ∈ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ) ;;
	step 42 : wff = ssrdv (step 41) |- ( ph → ( ⁻¹ T " { z } ) ⊆ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ;;
	step 43 : wff = syl5ss (step 1, step 42) |- ( ph → ( A ∩ ( ⁻¹ T " { z } ) ) ⊆ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ;;
	step 44 : wff = adantr (step 43) |- ( ( ph ∧ z ∈ A ) → ( A ∩ ( ⁻¹ T " { z } ) ) ⊆ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ;;
	step 45 : wff = ffvelrn () |- ( ( F : A ⟶ B ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 46 : wff = sylan (hyp 2, step 45) |- ( ( ph ∧ z ∈ A ) → ( F ` z ) ∈ B ) ;;
	step 47 : wff = seex () |- ( ( R Se B ∧ ( F ` z ) ∈ B ) → { u ∈ B | u R ( F ` z ) } ∈ _V ) ;;
	step 48 : wff = sylan (hyp 3, step 47) |- ( ( ph ∧ ( F ` z ) ∈ B ) → { u ∈ B | u R ( F ` z ) } ∈ _V ) ;;
	step 49 : wff = syldan (step 46, step 48) |- ( ( ph ∧ z ∈ A ) → { u ∈ B | u R ( F ` z ) } ∈ _V ) ;;
	step 50 : wff = snex () |- { ( F ` z ) } ∈ _V ;;
	step 51 : wff = unexg () |- ( ( { u ∈ B | u R ( F ` z ) } ∈ _V ∧ { ( F ` z ) } ∈ _V ) → ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ∈ _V ) ;;
	step 52 : wff = sylancl (step 49, step 50, step 51) |- ( ( ph ∧ z ∈ A ) → ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ∈ _V ) ;;
	step 53 : wff = imaeq2 () |- ( w = ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) → ( ⁻¹ F " w ) = ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ) ;;
	step 54 : wff = eleq1d (step 53) |- ( w = ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) → ( ( ⁻¹ F " w ) ∈ _V ↔ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∈ _V ) ) ;;
	step 55 : wff = imbi2d (step 54) |- ( w = ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) → ( ( ph → ( ⁻¹ F " w ) ∈ _V ) ↔ ( ph → ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∈ _V ) ) ) ;;
	step 56 : wff = vtoclg (step 55, hyp 4) |- ( ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ∈ _V → ( ph → ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∈ _V ) ) ;;
	step 57 : wff = impcom (step 56) |- ( ( ph ∧ ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ∈ _V ) → ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∈ _V ) ;;
	step 58 : wff = syldan (step 52, step 57) |- ( ( ph ∧ z ∈ A ) → ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∈ _V ) ;;
	step 59 : wff = ssexg () |- ( ( ( A ∩ ( ⁻¹ T " { z } ) ) ⊆ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∧ ( ⁻¹ F " ( { u ∈ B | u R ( F ` z ) } ∪ { ( F ` z ) } ) ) ∈ _V ) → ( A ∩ ( ⁻¹ T " { z } ) ) ∈ _V ) ;;
	step 60 : wff = syl2anc (step 44, step 58, step 59) |- ( ( ph ∧ z ∈ A ) → ( A ∩ ( ⁻¹ T " { z } ) ) ∈ _V ) ;;
	step 61 : wff = ralrimiva (step 60) |- ( ph → ∀ z ∈ A ( A ∩ ( ⁻¹ T " { z } ) ) ∈ _V ) ;;
	step 62 : wff = dfse2 () |- ( T Se A ↔ ∀ z ∈ A ( A ∩ ( ⁻¹ T " { z } ) ) ∈ _V ) ;;
	step 63 : wff = sylibr (step 61, step 62) |- ( ph → T Se A ) ;;
	qed prop 1 = step 63 ;;
}


