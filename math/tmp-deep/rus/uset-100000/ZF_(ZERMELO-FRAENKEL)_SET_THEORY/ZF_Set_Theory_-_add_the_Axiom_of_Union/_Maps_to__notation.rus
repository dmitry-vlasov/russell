import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Union/Operations.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        "Maps to" notation

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*If a two-parameter class is not empty, constrain the implicit pair.
       (Contributed by Stefan O'Rear, 7-Mar-2015.) */

theorem elmpt2cl (x : set, y : set, A : class, B : class, C : class, S : class, T : class, F : class, X : class) disjointed(A x y z, B x y z, C z) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( X ∈ ( S F T ) → ( S ∈ A ∧ T ∈ B ) ) ;;
}

proof of elmpt2cl {
	var z : set;;
	step 1 : wff = df-mpt2 () |- ( x ∈ A , y ∈ B ↦ C ) = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- F = { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 3 : wff = dmeqi (step 2) |- dom F = dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ;;
	step 4 : wff = dmoprabss () |- dom { 〈 〈 x , y 〉 , z 〉 | ( ( x ∈ A ∧ y ∈ B ) ∧ z = C ) } ⊆ ( A × B ) ;;
	step 5 : wff = eqsstri (step 3, step 4) |- dom F ⊆ ( A × B ) ;;
	step 6 : wff = elfvdm () |- ( X ∈ ( F ` 〈 S , T 〉 ) → 〈 S , T 〉 ∈ dom F ) ;;
	step 7 : wff = df-ov () |- ( S F T ) = ( F ` 〈 S , T 〉 ) ;;
	step 8 : wff = eleq2s (step 6, step 7) |- ( X ∈ ( S F T ) → 〈 S , T 〉 ∈ dom F ) ;;
	step 9 : wff = sseldi (step 5, step 8) |- ( X ∈ ( S F T ) → 〈 S , T 〉 ∈ ( A × B ) ) ;;
	step 10 : wff = opelxp () |- ( 〈 S , T 〉 ∈ ( A × B ) ↔ ( S ∈ A ∧ T ∈ B ) ) ;;
	step 11 : wff = sylib (step 9, step 10) |- ( X ∈ ( S F T ) → ( S ∈ A ∧ T ∈ B ) ) ;;
	qed prop 1 = step 11 ;;
}

/*If a two-parameter class is not empty, the first argument is in its
       nominal domain.  (Contributed by FL, 15-Oct-2012.)  (Revised by Stefan
       O'Rear, 7-Mar-2015.) */

theorem elmpt2cl1 (x : set, y : set, A : class, B : class, C : class, S : class, T : class, F : class, X : class) disjointed(A x y, B x y, C) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( X ∈ ( S F T ) → S ∈ A ) ;;
}

proof of elmpt2cl1 {
	step 1 : wff = elmpt2cl (hyp 1) |- ( X ∈ ( S F T ) → ( S ∈ A ∧ T ∈ B ) ) ;;
	step 2 : wff = simpld (step 1) |- ( X ∈ ( S F T ) → S ∈ A ) ;;
	qed prop 1 = step 2 ;;
}

/*If a two-parameter class is not empty, the second argument is in its
       nominal domain.  (Contributed by FL, 15-Oct-2012.)  (Revised by Stefan
       O'Rear, 7-Mar-2015.) */

theorem elmpt2cl2 (x : set, y : set, A : class, B : class, C : class, S : class, T : class, F : class, X : class) disjointed(A x y, B x y, C) {
	hyp 1 : wff = |- F = ( x ∈ A , y ∈ B ↦ C ) ;;
	-----------------------
	prop 1 : wff = |- ( X ∈ ( S F T ) → T ∈ B ) ;;
}

proof of elmpt2cl2 {
	step 1 : wff = elmpt2cl (hyp 1) |- ( X ∈ ( S F T ) → ( S ∈ A ∧ T ∈ B ) ) ;;
	step 2 : wff = simprd (step 1) |- ( X ∈ ( S F T ) → T ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Utility lemma for two-parameter classes.

       _EDITORIAL_: can simplify ~ isghm , ~ islmhm .  (Contributed by Stefan
       O'Rear, 21-Jan-2015.) */

theorem elovmpt2 (A : class, B : class, C : class, D : class, E : class, F : class, X : class, Y : class, a : set, b : set) disjointed(A a b, B a b, E a b, F a b, X a b, Y a b, a b) {
	hyp 1 : wff = |- D = ( a ∈ A , b ∈ B ↦ C ) ;;
	hyp 2 : wff = |- C ∈ _V ;;
	hyp 3 : wff = |- ( ( a = X ∧ b = Y ) → C = E ) ;;
	-----------------------
	prop 1 : wff = |- ( F ∈ ( X D Y ) ↔ ( X ∈ A ∧ Y ∈ B ∧ F ∈ E ) ) ;;
}

proof of elovmpt2 {
	step 1 : wff = elmpt2cl (hyp 1) |- ( F ∈ ( X D Y ) → ( X ∈ A ∧ Y ∈ B ) ) ;;
	step 2 : wff = gen2 (hyp 2) |- ∀ a ∀ b C ∈ _V ;;
	step 3 : wff = eleq1d (hyp 3) |- ( ( a = X ∧ b = Y ) → ( C ∈ _V ↔ E ∈ _V ) ) ;;
	step 4 : wff = spc2gv (step 3) |- ( ( X ∈ A ∧ Y ∈ B ) → ( ∀ a ∀ b C ∈ _V → E ∈ _V ) ) ;;
	step 5 : wff = mpi (step 2, step 4) |- ( ( X ∈ A ∧ Y ∈ B ) → E ∈ _V ) ;;
	step 6 : wff = ovmpt2ga (hyp 3, hyp 1) |- ( ( X ∈ A ∧ Y ∈ B ∧ E ∈ _V ) → ( X D Y ) = E ) ;;
	step 7 : wff = mpd3an3 (step 5, step 6) |- ( ( X ∈ A ∧ Y ∈ B ) → ( X D Y ) = E ) ;;
	step 8 : wff = eleq2d (step 7) |- ( ( X ∈ A ∧ Y ∈ B ) → ( F ∈ ( X D Y ) ↔ F ∈ E ) ) ;;
	step 9 : wff = biadan2 (step 1, step 8) |- ( F ∈ ( X D Y ) ↔ ( ( X ∈ A ∧ Y ∈ B ) ∧ F ∈ E ) ) ;;
	step 10 : wff = df-3an () |- ( ( X ∈ A ∧ Y ∈ B ∧ F ∈ E ) ↔ ( ( X ∈ A ∧ Y ∈ B ) ∧ F ∈ E ) ) ;;
	step 11 : wff = bitr4i (step 9, step 10) |- ( F ∈ ( X D Y ) ↔ ( X ∈ A ∧ Y ∈ B ∧ F ∈ E ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Any function to sets of ordered pairs produces a relation on function
       value unconditionally.  (Contributed by Mario Carneiro, 7-Aug-2014.)
       (Proof shortened by Mario Carneiro, 24-Dec-2016.) */

theorem relmptopab (ph : wff, x : set, y : set, z : set, A : class, B : class, F : class) disjointed(x A, B, F) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ { 〈 y , z 〉 | ph } ) ;;
	-----------------------
	prop 1 : wff = |- Rel ( F ` B ) ;;
}

proof of relmptopab {
	step 1 : wff = fvmptss (hyp 1) |- ( ∀ x ∈ A { 〈 y , z 〉 | ph } ⊆ ( _V × _V ) → ( F ` B ) ⊆ ( _V × _V ) ) ;;
	step 2 : wff = relopab () |- Rel { 〈 y , z 〉 | ph } ;;
	step 3 : wff = df-rel () |- ( Rel { 〈 y , z 〉 | ph } ↔ { 〈 y , z 〉 | ph } ⊆ ( _V × _V ) ) ;;
	step 4 : wff = mpbi (step 2, step 3) |- { 〈 y , z 〉 | ph } ⊆ ( _V × _V ) ;;
	step 5 : wff = a1i (step 4) |- ( x ∈ A → { 〈 y , z 〉 | ph } ⊆ ( _V × _V ) ) ;;
	step 6 : wff = mprg (step 1, step 5) |- ( F ` B ) ⊆ ( _V × _V ) ;;
	step 7 : wff = df-rel () |- ( Rel ( F ` B ) ↔ ( F ` B ) ⊆ ( _V × _V ) ) ;;
	step 8 : wff = mpbir (step 6, step 7) |- Rel ( F ` B ) ;;
	qed prop 1 = step 8 ;;
}

/*Describe an implicit one-to-one onto function.  (Contributed by Mario
         Carneiro, 30-Apr-2015.) */

theorem f1ocnvd (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, F : class, W : class, X : class) disjointed(x y A, x y B, y C, x D, x y ph) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → C ∈ W ) ;;
	hyp 3 : wff = |- ( ( ph ∧ y ∈ B ) → D ∈ X ) ;;
	hyp 4 : wff = |- ( ph → ( ( x ∈ A ∧ y = C ) ↔ ( y ∈ B ∧ x = D ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⤖ B ∧ ⁻¹ F = ( y ∈ B ↦ D ) ) ) ;;
}

proof of f1ocnvd {
	step 1 : wff = ralrimiva (hyp 2) |- ( ph → ∀ x ∈ A C ∈ W ) ;;
	step 2 : wff = fnmpt (hyp 1) |- ( ∀ x ∈ A C ∈ W → F Fn A ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → F Fn A ) ;;
	step 4 : wff = ralrimiva (hyp 3) |- ( ph → ∀ y ∈ B D ∈ X ) ;;
	step 5 : wff = eqid () |- ( y ∈ B ↦ D ) = ( y ∈ B ↦ D ) ;;
	step 6 : wff = fnmpt (step 5) |- ( ∀ y ∈ B D ∈ X → ( y ∈ B ↦ D ) Fn B ) ;;
	step 7 : wff = syl (step 4, step 6) |- ( ph → ( y ∈ B ↦ D ) Fn B ) ;;
	step 8 : wff = opabbidv (hyp 4) |- ( ph → { 〈 y , x 〉 | ( x ∈ A ∧ y = C ) } = { 〈 y , x 〉 | ( y ∈ B ∧ x = D ) } ) ;;
	step 9 : wff = df-mpt () |- ( x ∈ A ↦ C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 10 : wff = eqtri (hyp 1, step 9) |- F = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 11 : wff = cnveqi (step 10) |- ⁻¹ F = ⁻¹ { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 12 : wff = cnvopab () |- ⁻¹ { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } = { 〈 y , x 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 13 : wff = eqtri (step 11, step 12) |- ⁻¹ F = { 〈 y , x 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 14 : wff = df-mpt () |- ( y ∈ B ↦ D ) = { 〈 y , x 〉 | ( y ∈ B ∧ x = D ) } ;;
	step 15 : wff = 3eqtr4g (step 8, step 13, step 14) |- ( ph → ⁻¹ F = ( y ∈ B ↦ D ) ) ;;
	step 16 : wff = fneq1d (step 15) |- ( ph → ( ⁻¹ F Fn B ↔ ( y ∈ B ↦ D ) Fn B ) ) ;;
	step 17 : wff = mpbird (step 7, step 16) |- ( ph → ⁻¹ F Fn B ) ;;
	step 18 : wff = dff1o4 () |- ( F : A ⤖ B ↔ ( F Fn A ∧ ⁻¹ F Fn B ) ) ;;
	step 19 : wff = sylanbrc (step 3, step 17, step 18) |- ( ph → F : A ⤖ B ) ;;
	step 20 : wff = opabbidv (hyp 4) |- ( ph → { 〈 y , x 〉 | ( x ∈ A ∧ y = C ) } = { 〈 y , x 〉 | ( y ∈ B ∧ x = D ) } ) ;;
	step 21 : wff = df-mpt () |- ( x ∈ A ↦ C ) = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 22 : wff = eqtri (hyp 1, step 21) |- F = { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 23 : wff = cnveqi (step 22) |- ⁻¹ F = ⁻¹ { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 24 : wff = cnvopab () |- ⁻¹ { 〈 x , y 〉 | ( x ∈ A ∧ y = C ) } = { 〈 y , x 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 25 : wff = eqtri (step 23, step 24) |- ⁻¹ F = { 〈 y , x 〉 | ( x ∈ A ∧ y = C ) } ;;
	step 26 : wff = df-mpt () |- ( y ∈ B ↦ D ) = { 〈 y , x 〉 | ( y ∈ B ∧ x = D ) } ;;
	step 27 : wff = 3eqtr4g (step 20, step 25, step 26) |- ( ph → ⁻¹ F = ( y ∈ B ↦ D ) ) ;;
	step 28 : wff = jca (step 19, step 27) |- ( ph → ( F : A ⤖ B ∧ ⁻¹ F = ( y ∈ B ↦ D ) ) ) ;;
	qed prop 1 = step 28 ;;
}

/*Describe an implicit one-to-one onto function.  (Contributed by Mario
         Carneiro, 12-May-2014.) */

theorem f1od (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, F : class, W : class, X : class) disjointed(x y A, x y B, y C, x D, x y ph) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → C ∈ W ) ;;
	hyp 3 : wff = |- ( ( ph ∧ y ∈ B ) → D ∈ X ) ;;
	hyp 4 : wff = |- ( ph → ( ( x ∈ A ∧ y = C ) ↔ ( y ∈ B ∧ x = D ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F : A ⤖ B ) ;;
}

proof of f1od {
	step 1 : wff = f1ocnvd (hyp 1, hyp 2, hyp 3, hyp 4) |- ( ph → ( F : A ⤖ B ∧ ⁻¹ F = ( y ∈ B ↦ D ) ) ) ;;
	step 2 : wff = simpld (step 1) |- ( ph → F : A ⤖ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Describe an implicit one-to-one onto function.  (Contributed by Mario
       Carneiro, 30-Apr-2015.) */

theorem f1ocnv2d (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y A, x y B, y C, x D, x y ph) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → C ∈ B ) ;;
	hyp 3 : wff = |- ( ( ph ∧ y ∈ B ) → D ∈ A ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( x = D ↔ y = C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F : A ⤖ B ∧ ⁻¹ F = ( y ∈ B ↦ D ) ) ) ;;
}

proof of f1ocnv2d {
	step 1 : wff = eleq1a () |- ( C ∈ B → ( y = C → y ∈ B ) ) ;;
	step 2 : wff = syl (hyp 2, step 1) |- ( ( ph ∧ x ∈ A ) → ( y = C → y ∈ B ) ) ;;
	step 3 : wff = impr (step 2) |- ( ( ph ∧ ( x ∈ A ∧ y = C ) ) → y ∈ B ) ;;
	step 4 : wff = biimpar (hyp 4) |- ( ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ y = C ) → x = D ) ;;
	step 5 : wff = exp42 (step 4) |- ( ph → ( x ∈ A → ( y ∈ B → ( y = C → x = D ) ) ) ) ;;
	step 6 : wff = com34 (step 5) |- ( ph → ( x ∈ A → ( y = C → ( y ∈ B → x = D ) ) ) ) ;;
	step 7 : wff = imp32 (step 6) |- ( ( ph ∧ ( x ∈ A ∧ y = C ) ) → ( y ∈ B → x = D ) ) ;;
	step 8 : wff = jcai (step 3, step 7) |- ( ( ph ∧ ( x ∈ A ∧ y = C ) ) → ( y ∈ B ∧ x = D ) ) ;;
	step 9 : wff = eleq1a () |- ( D ∈ A → ( x = D → x ∈ A ) ) ;;
	step 10 : wff = syl (hyp 3, step 9) |- ( ( ph ∧ y ∈ B ) → ( x = D → x ∈ A ) ) ;;
	step 11 : wff = impr (step 10) |- ( ( ph ∧ ( y ∈ B ∧ x = D ) ) → x ∈ A ) ;;
	step 12 : wff = biimpa (hyp 4) |- ( ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) ∧ x = D ) → y = C ) ;;
	step 13 : wff = exp42 (step 12) |- ( ph → ( x ∈ A → ( y ∈ B → ( x = D → y = C ) ) ) ) ;;
	step 14 : wff = com23 (step 13) |- ( ph → ( y ∈ B → ( x ∈ A → ( x = D → y = C ) ) ) ) ;;
	step 15 : wff = com34 (step 14) |- ( ph → ( y ∈ B → ( x = D → ( x ∈ A → y = C ) ) ) ) ;;
	step 16 : wff = imp32 (step 15) |- ( ( ph ∧ ( y ∈ B ∧ x = D ) ) → ( x ∈ A → y = C ) ) ;;
	step 17 : wff = jcai (step 11, step 16) |- ( ( ph ∧ ( y ∈ B ∧ x = D ) ) → ( x ∈ A ∧ y = C ) ) ;;
	step 18 : wff = impbida (step 8, step 17) |- ( ph → ( ( x ∈ A ∧ y = C ) ↔ ( y ∈ B ∧ x = D ) ) ) ;;
	step 19 : wff = f1ocnvd (hyp 1, hyp 2, hyp 3, step 18) |- ( ph → ( F : A ⤖ B ∧ ⁻¹ F = ( y ∈ B ↦ D ) ) ) ;;
	qed prop 1 = step 19 ;;
}

/*Describe an implicit one-to-one onto function.  (Contributed by Mario
       Carneiro, 12-May-2014.) */

theorem f1o2d (ph : wff, x : set, y : set, A : class, B : class, C : class, D : class, F : class) disjointed(x y A, x y B, y C, x D, x y ph) {
	hyp 1 : wff = |- F = ( x ∈ A ↦ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → C ∈ B ) ;;
	hyp 3 : wff = |- ( ( ph ∧ y ∈ B ) → D ∈ A ) ;;
	hyp 4 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( x = D ↔ y = C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F : A ⤖ B ) ;;
}

proof of f1o2d {
	step 1 : wff = f1ocnv2d (hyp 1, hyp 2, hyp 3, hyp 4) |- ( ph → ( F : A ⤖ B ∧ ⁻¹ F = ( y ∈ B ↦ D ) ) ) ;;
	step 2 : wff = simpld (step 1) |- ( ph → F : A ⤖ B ) ;;
	qed prop 1 = step 2 ;;
}

/*The cross product of two sets is a set.  Proposition 6.2 of
       [TakeutiZaring] p. 23.  This version is proven using Replacement; see
       ~ xpexg for a version that uses the Power Set axiom instead.
       (Contributed by Mario Carneiro, 20-May-2013.)
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem xpexgALT (A : class, B : class, V : class, W : class) disjointed(A x y, B x y, V y) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( A × B ) ∈ _V ) ;;
}

proof of xpexgALT {
	var x : set, y : set;;
	step 1 : wff = iunid () |- ⋃_ y ∈ B { y } = B ;;
	step 2 : wff = xpeq2i (step 1) |- ( A × ⋃_ y ∈ B { y } ) = ( A × B ) ;;
	step 3 : wff = xpiundi () |- ( A × ⋃_ y ∈ B { y } ) = ⋃_ y ∈ B ( A × { y } ) ;;
	step 4 : wff = eqtr3i (step 2, step 3) |- ( A × B ) = ⋃_ y ∈ B ( A × { y } ) ;;
	step 5 : wff = id () |- ( B ∈ W → B ∈ W ) ;;
	step 6 : wff = fconstmpt () |- ( A × { y } ) = ( x ∈ A ↦ y ) ;;
	step 7 : wff = mptexg () |- ( A ∈ V → ( x ∈ A ↦ y ) ∈ _V ) ;;
	step 8 : wff = syl5eqel (step 6, step 7) |- ( A ∈ V → ( A × { y } ) ∈ _V ) ;;
	step 9 : wff = ralrimivw (step 8) |- ( A ∈ V → ∀ y ∈ B ( A × { y } ) ∈ _V ) ;;
	step 10 : wff = iunexg () |- ( ( B ∈ W ∧ ∀ y ∈ B ( A × { y } ) ∈ _V ) → ⋃_ y ∈ B ( A × { y } ) ∈ _V ) ;;
	step 11 : wff = syl2anr (step 5, step 9, step 10) |- ( ( A ∈ V ∧ B ∈ W ) → ⋃_ y ∈ B ( A × { y } ) ∈ _V ) ;;
	step 12 : wff = syl5eqel (step 4, step 11) |- ( ( A ∈ V ∧ B ∈ W ) → ( A × B ) ∈ _V ) ;;
	qed prop 1 = step 12 ;;
}

/*A one-to-one mapping induces a one-to-one mapping on power sets.  This
       version of ~ f1opw avoids the Axiom of Replacement.  (Contributed by
       Mario Carneiro, 26-Jun-2015.) */

theorem f1opw2 (ph : wff, A : class, B : class, F : class, a : set, b : set) disjointed(a b A, a b B, a b F, a b ph) {
	hyp 1 : wff = |- ( ph → F : A ⤖ B ) ;;
	hyp 2 : wff = |- ( ph → ( ⁻¹ F " a ) ∈ _V ) ;;
	hyp 3 : wff = |- ( ph → ( F " b ) ∈ _V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( b ∈ Pow A ↦ ( F " b ) ) : Pow A ⤖ Pow B ) ;;
}

proof of f1opw2 {
	step 1 : wff = eqid () |- ( b ∈ Pow A ↦ ( F " b ) ) = ( b ∈ Pow A ↦ ( F " b ) ) ;;
	step 2 : wff = imassrn () |- ( F " b ) ⊆ ran F ;;
	step 3 : wff = f1ofo () |- ( F : A ⤖ B → F : A ↠ B ) ;;
	step 4 : wff = syl (hyp 1, step 3) |- ( ph → F : A ↠ B ) ;;
	step 5 : wff = forn () |- ( F : A ↠ B → ran F = B ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ph → ran F = B ) ;;
	step 7 : wff = syl5sseq (step 2, step 6) |- ( ph → ( F " b ) ⊆ B ) ;;
	step 8 : wff = elpwg () |- ( ( F " b ) ∈ _V → ( ( F " b ) ∈ Pow B ↔ ( F " b ) ⊆ B ) ) ;;
	step 9 : wff = syl (hyp 3, step 8) |- ( ph → ( ( F " b ) ∈ Pow B ↔ ( F " b ) ⊆ B ) ) ;;
	step 10 : wff = mpbird (step 7, step 9) |- ( ph → ( F " b ) ∈ Pow B ) ;;
	step 11 : wff = adantr (step 10) |- ( ( ph ∧ b ∈ Pow A ) → ( F " b ) ∈ Pow B ) ;;
	step 12 : wff = imassrn () |- ( ⁻¹ F " a ) ⊆ ran ⁻¹ F ;;
	step 13 : wff = dfdm4 () |- dom F = ran ⁻¹ F ;;
	step 14 : wff = f1odm () |- ( F : A ⤖ B → dom F = A ) ;;
	step 15 : wff = syl (hyp 1, step 14) |- ( ph → dom F = A ) ;;
	step 16 : wff = syl5eqr (step 13, step 15) |- ( ph → ran ⁻¹ F = A ) ;;
	step 17 : wff = syl5sseq (step 12, step 16) |- ( ph → ( ⁻¹ F " a ) ⊆ A ) ;;
	step 18 : wff = elpwg () |- ( ( ⁻¹ F " a ) ∈ _V → ( ( ⁻¹ F " a ) ∈ Pow A ↔ ( ⁻¹ F " a ) ⊆ A ) ) ;;
	step 19 : wff = syl (hyp 2, step 18) |- ( ph → ( ( ⁻¹ F " a ) ∈ Pow A ↔ ( ⁻¹ F " a ) ⊆ A ) ) ;;
	step 20 : wff = mpbird (step 17, step 19) |- ( ph → ( ⁻¹ F " a ) ∈ Pow A ) ;;
	step 21 : wff = adantr (step 20) |- ( ( ph ∧ a ∈ Pow B ) → ( ⁻¹ F " a ) ∈ Pow A ) ;;
	step 22 : wff = f1ofo () |- ( F : A ⤖ B → F : A ↠ B ) ;;
	step 23 : wff = syl (hyp 1, step 22) |- ( ph → F : A ↠ B ) ;;
	step 24 : wff = elpwi () |- ( a ∈ Pow B → a ⊆ B ) ;;
	step 25 : wff = adantl (step 24) |- ( ( b ∈ Pow A ∧ a ∈ Pow B ) → a ⊆ B ) ;;
	step 26 : wff = foimacnv () |- ( ( F : A ↠ B ∧ a ⊆ B ) → ( F " ( ⁻¹ F " a ) ) = a ) ;;
	step 27 : wff = syl2an (step 23, step 25, step 26) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → ( F " ( ⁻¹ F " a ) ) = a ) ;;
	step 28 : wff = eqcomd (step 27) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → a = ( F " ( ⁻¹ F " a ) ) ) ;;
	step 29 : wff = imaeq2 () |- ( b = ( ⁻¹ F " a ) → ( F " b ) = ( F " ( ⁻¹ F " a ) ) ) ;;
	step 30 : wff = eqeq2d (step 29) |- ( b = ( ⁻¹ F " a ) → ( a = ( F " b ) ↔ a = ( F " ( ⁻¹ F " a ) ) ) ) ;;
	step 31 : wff = syl5ibrcom (step 28, step 30) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → ( b = ( ⁻¹ F " a ) → a = ( F " b ) ) ) ;;
	step 32 : wff = f1of1 () |- ( F : A ⤖ B → F : A ↣ B ) ;;
	step 33 : wff = syl (hyp 1, step 32) |- ( ph → F : A ↣ B ) ;;
	step 34 : wff = elpwi () |- ( b ∈ Pow A → b ⊆ A ) ;;
	step 35 : wff = adantr (step 34) |- ( ( b ∈ Pow A ∧ a ∈ Pow B ) → b ⊆ A ) ;;
	step 36 : wff = f1imacnv () |- ( ( F : A ↣ B ∧ b ⊆ A ) → ( ⁻¹ F " ( F " b ) ) = b ) ;;
	step 37 : wff = syl2an (step 33, step 35, step 36) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → ( ⁻¹ F " ( F " b ) ) = b ) ;;
	step 38 : wff = eqcomd (step 37) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → b = ( ⁻¹ F " ( F " b ) ) ) ;;
	step 39 : wff = imaeq2 () |- ( a = ( F " b ) → ( ⁻¹ F " a ) = ( ⁻¹ F " ( F " b ) ) ) ;;
	step 40 : wff = eqeq2d (step 39) |- ( a = ( F " b ) → ( b = ( ⁻¹ F " a ) ↔ b = ( ⁻¹ F " ( F " b ) ) ) ) ;;
	step 41 : wff = syl5ibrcom (step 38, step 40) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → ( a = ( F " b ) → b = ( ⁻¹ F " a ) ) ) ;;
	step 42 : wff = impbid (step 31, step 41) |- ( ( ph ∧ ( b ∈ Pow A ∧ a ∈ Pow B ) ) → ( b = ( ⁻¹ F " a ) ↔ a = ( F " b ) ) ) ;;
	step 43 : wff = f1o2d (step 1, step 11, step 21, step 42) |- ( ph → ( b ∈ Pow A ↦ ( F " b ) ) : Pow A ⤖ Pow B ) ;;
	qed prop 1 = step 43 ;;
}

/*A one-to-one mapping induces a one-to-one mapping on power sets.
       (Contributed by Stefan O'Rear, 18-Nov-2014.)  (Revised by Mario
       Carneiro, 26-Jun-2015.) */

theorem f1opw (A : class, B : class, F : class, b : set) disjointed(a b A, a b B, a b F) {
	prop 1 : wff = |- ( F : A ⤖ B → ( b ∈ Pow A ↦ ( F " b ) ) : Pow A ⤖ Pow B ) ;;
}

proof of f1opw {
	var a : set;;
	step 1 : wff = id () |- ( F : A ⤖ B → F : A ⤖ B ) ;;
	step 2 : wff = dff1o3 () |- ( F : A ⤖ B ↔ ( F : A ↠ B ∧ Fun ⁻¹ F ) ) ;;
	step 3 : wff = simprbi (step 2) |- ( F : A ⤖ B → Fun ⁻¹ F ) ;;
	step 4 : wff = vex () |- a ∈ _V ;;
	step 5 : wff = funimaex (step 4) |- ( Fun ⁻¹ F → ( ⁻¹ F " a ) ∈ _V ) ;;
	step 6 : wff = syl (step 3, step 5) |- ( F : A ⤖ B → ( ⁻¹ F " a ) ∈ _V ) ;;
	step 7 : wff = f1ofun () |- ( F : A ⤖ B → Fun F ) ;;
	step 8 : wff = vex () |- b ∈ _V ;;
	step 9 : wff = funimaex (step 8) |- ( Fun F → ( F " b ) ∈ _V ) ;;
	step 10 : wff = syl (step 7, step 9) |- ( F : A ⤖ B → ( F " b ) ∈ _V ) ;;
	step 11 : wff = f1opw2 (step 1, step 6, step 10) |- ( F : A ⤖ B → ( b ∈ Pow A ↦ ( F " b ) ) : Pow A ⤖ Pow B ) ;;
	qed prop 1 = step 11 ;;
}

/*Show that the support of a function is contained in a set.  (Contributed
       by Mario Carneiro, 19-Dec-2014.)  (Revised by Mario Carneiro,
       22-Mar-2015.) */

theorem suppss2 (ph : wff, A : class, B : class, k : set, W : class, Z : class) disjointed(k A, B, k ph, k W, k Z) {
	hyp 1 : wff = |- ( ( ph ∧ k ∈ ( A ∖ W ) ) → B = Z ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ⁻¹ ( k ∈ A ↦ B ) " ( _V ∖ { Z } ) ) ⊆ W ) ;;
}

proof of suppss2 {
	step 1 : wff = eqid () |- ( k ∈ A ↦ B ) = ( k ∈ A ↦ B ) ;;
	step 2 : wff = mptpreima (step 1) |- ( ⁻¹ ( k ∈ A ↦ B ) " ( _V ∖ { Z } ) ) = { k ∈ A | B ∈ ( _V ∖ { Z } ) } ;;
	step 3 : wff = eldifsni () |- ( B ∈ ( _V ∖ { Z } ) → B ≠ Z ) ;;
	step 4 : wff = eldif () |- ( k ∈ ( A ∖ W ) ↔ ( k ∈ A ∧ ¬ k ∈ W ) ) ;;
	step 5 : wff = sylan2br (step 4, hyp 1) |- ( ( ph ∧ ( k ∈ A ∧ ¬ k ∈ W ) ) → B = Z ) ;;
	step 6 : wff = expr (step 5) |- ( ( ph ∧ k ∈ A ) → ( ¬ k ∈ W → B = Z ) ) ;;
	step 7 : wff = necon1ad (step 6) |- ( ( ph ∧ k ∈ A ) → ( B ≠ Z → k ∈ W ) ) ;;
	step 8 : wff = syl5 (step 3, step 7) |- ( ( ph ∧ k ∈ A ) → ( B ∈ ( _V ∖ { Z } ) → k ∈ W ) ) ;;
	step 9 : wff = 3impia (step 8) |- ( ( ph ∧ k ∈ A ∧ B ∈ ( _V ∖ { Z } ) ) → k ∈ W ) ;;
	step 10 : wff = rabssdv (step 9) |- ( ph → { k ∈ A | B ∈ ( _V ∖ { Z } ) } ⊆ W ) ;;
	step 11 : wff = syl5eqss (step 2, step 10) |- ( ph → ( ⁻¹ ( k ∈ A ↦ B ) " ( _V ∖ { Z } ) ) ⊆ W ) ;;
	qed prop 1 = step 11 ;;
}

/*Formula building theorem for support restriction, on a function which
       preserves zero.  (Contributed by Stefan O'Rear, 9-Mar-2015.) */

theorem suppssfv (ph : wff, x : set, A : class, D : class, F : class, L : class, V : class, Y : class, Z : class) disjointed(ph x, Y x, Z x) {
	hyp 1 : wff = |- ( ph → ( ⁻¹ ( x ∈ D ↦ A ) " ( _V ∖ { Y } ) ) ⊆ L ) ;;
	hyp 2 : wff = |- ( ph → ( F ` Y ) = Z ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ D ) → A ∈ V ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ⁻¹ ( x ∈ D ↦ ( F ` A ) ) " ( _V ∖ { Z } ) ) ⊆ L ) ;;
}

proof of suppssfv {
	step 1 : wff = eldifsni () |- ( ( F ` A ) ∈ ( _V ∖ { Z } ) → ( F ` A ) ≠ Z ) ;;
	step 2 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 3 : wff = syl (hyp 3, step 2) |- ( ( ph ∧ x ∈ D ) → A ∈ _V ) ;;
	step 4 : wff = adantr (step 3) |- ( ( ( ph ∧ x ∈ D ) ∧ ( F ` A ) ≠ Z ) → A ∈ _V ) ;;
	step 5 : wff = fveq2 () |- ( A = Y → ( F ` A ) = ( F ` Y ) ) ;;
	step 6 : wff = eqeq1d (step 5) |- ( A = Y → ( ( F ` A ) = Z ↔ ( F ` Y ) = Z ) ) ;;
	step 7 : wff = syl5ibrcom (hyp 2, step 6) |- ( ph → ( A = Y → ( F ` A ) = Z ) ) ;;
	step 8 : wff = necon3d (step 7) |- ( ph → ( ( F ` A ) ≠ Z → A ≠ Y ) ) ;;
	step 9 : wff = adantr (step 8) |- ( ( ph ∧ x ∈ D ) → ( ( F ` A ) ≠ Z → A ≠ Y ) ) ;;
	step 10 : wff = imp (step 9) |- ( ( ( ph ∧ x ∈ D ) ∧ ( F ` A ) ≠ Z ) → A ≠ Y ) ;;
	step 11 : wff = eldifsn () |- ( A ∈ ( _V ∖ { Y } ) ↔ ( A ∈ _V ∧ A ≠ Y ) ) ;;
	step 12 : wff = sylanbrc (step 4, step 10, step 11) |- ( ( ( ph ∧ x ∈ D ) ∧ ( F ` A ) ≠ Z ) → A ∈ ( _V ∖ { Y } ) ) ;;
	step 13 : wff = ex (step 12) |- ( ( ph ∧ x ∈ D ) → ( ( F ` A ) ≠ Z → A ∈ ( _V ∖ { Y } ) ) ) ;;
	step 14 : wff = syl5 (step 1, step 13) |- ( ( ph ∧ x ∈ D ) → ( ( F ` A ) ∈ ( _V ∖ { Z } ) → A ∈ ( _V ∖ { Y } ) ) ) ;;
	step 15 : wff = ss2rabdv (step 14) |- ( ph → { x ∈ D | ( F ` A ) ∈ ( _V ∖ { Z } ) } ⊆ { x ∈ D | A ∈ ( _V ∖ { Y } ) } ) ;;
	step 16 : wff = eqid () |- ( x ∈ D ↦ ( F ` A ) ) = ( x ∈ D ↦ ( F ` A ) ) ;;
	step 17 : wff = mptpreima (step 16) |- ( ⁻¹ ( x ∈ D ↦ ( F ` A ) ) " ( _V ∖ { Z } ) ) = { x ∈ D | ( F ` A ) ∈ ( _V ∖ { Z } ) } ;;
	step 18 : wff = eqid () |- ( x ∈ D ↦ A ) = ( x ∈ D ↦ A ) ;;
	step 19 : wff = mptpreima (step 18) |- ( ⁻¹ ( x ∈ D ↦ A ) " ( _V ∖ { Y } ) ) = { x ∈ D | A ∈ ( _V ∖ { Y } ) } ;;
	step 20 : wff = 3sstr4g (step 15, step 17, step 19) |- ( ph → ( ⁻¹ ( x ∈ D ↦ ( F ` A ) ) " ( _V ∖ { Z } ) ) ⊆ ( ⁻¹ ( x ∈ D ↦ A ) " ( _V ∖ { Y } ) ) ) ;;
	step 21 : wff = sstrd (step 20, hyp 1) |- ( ph → ( ⁻¹ ( x ∈ D ↦ ( F ` A ) ) " ( _V ∖ { Z } ) ) ⊆ L ) ;;
	qed prop 1 = step 21 ;;
}

/*Formula building theorem for support restrictions: operator with left
       annihilator.  (Contributed by Stefan O'Rear, 9-Mar-2015.) */

theorem suppssov1 (ph : wff, x : set, v : set, A : class, B : class, D : class, R : class, L : class, O : class, V : class, Y : class, Z : class) disjointed(ph v, ph x, B v, O v, R v, Y v, Y x, Z v, Z x) {
	hyp 1 : wff = |- ( ph → ( ⁻¹ ( x ∈ D ↦ A ) " ( _V ∖ { Y } ) ) ⊆ L ) ;;
	hyp 2 : wff = |- ( ( ph ∧ v ∈ R ) → ( Y O v ) = Z ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ D ) → A ∈ V ) ;;
	hyp 4 : wff = |- ( ( ph ∧ x ∈ D ) → B ∈ R ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ⁻¹ ( x ∈ D ↦ ( A O B ) ) " ( _V ∖ { Z } ) ) ⊆ L ) ;;
}

proof of suppssov1 {
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = syl (hyp 3, step 1) |- ( ( ph ∧ x ∈ D ) → A ∈ _V ) ;;
	step 3 : wff = adantr (step 2) |- ( ( ( ph ∧ x ∈ D ) ∧ ( A O B ) ∈ ( _V ∖ { Z } ) ) → A ∈ _V ) ;;
	step 4 : wff = eldifsni () |- ( ( A O B ) ∈ ( _V ∖ { Z } ) → ( A O B ) ≠ Z ) ;;
	step 5 : wff = ralrimiva (hyp 2) |- ( ph → ∀ v ∈ R ( Y O v ) = Z ) ;;
	step 6 : wff = adantr (step 5) |- ( ( ph ∧ x ∈ D ) → ∀ v ∈ R ( Y O v ) = Z ) ;;
	step 7 : wff = oveq2 () |- ( v = B → ( Y O v ) = ( Y O B ) ) ;;
	step 8 : wff = eqeq1d (step 7) |- ( v = B → ( ( Y O v ) = Z ↔ ( Y O B ) = Z ) ) ;;
	step 9 : wff = rspcva (step 8) |- ( ( B ∈ R ∧ ∀ v ∈ R ( Y O v ) = Z ) → ( Y O B ) = Z ) ;;
	step 10 : wff = syl2anc (hyp 4, step 6, step 9) |- ( ( ph ∧ x ∈ D ) → ( Y O B ) = Z ) ;;
	step 11 : wff = oveq1 () |- ( A = Y → ( A O B ) = ( Y O B ) ) ;;
	step 12 : wff = eqeq1d (step 11) |- ( A = Y → ( ( A O B ) = Z ↔ ( Y O B ) = Z ) ) ;;
	step 13 : wff = syl5ibrcom (step 10, step 12) |- ( ( ph ∧ x ∈ D ) → ( A = Y → ( A O B ) = Z ) ) ;;
	step 14 : wff = necon3d (step 13) |- ( ( ph ∧ x ∈ D ) → ( ( A O B ) ≠ Z → A ≠ Y ) ) ;;
	step 15 : wff = syl5 (step 4, step 14) |- ( ( ph ∧ x ∈ D ) → ( ( A O B ) ∈ ( _V ∖ { Z } ) → A ≠ Y ) ) ;;
	step 16 : wff = imp (step 15) |- ( ( ( ph ∧ x ∈ D ) ∧ ( A O B ) ∈ ( _V ∖ { Z } ) ) → A ≠ Y ) ;;
	step 17 : wff = eldifsn () |- ( A ∈ ( _V ∖ { Y } ) ↔ ( A ∈ _V ∧ A ≠ Y ) ) ;;
	step 18 : wff = sylanbrc (step 3, step 16, step 17) |- ( ( ( ph ∧ x ∈ D ) ∧ ( A O B ) ∈ ( _V ∖ { Z } ) ) → A ∈ ( _V ∖ { Y } ) ) ;;
	step 19 : wff = ex (step 18) |- ( ( ph ∧ x ∈ D ) → ( ( A O B ) ∈ ( _V ∖ { Z } ) → A ∈ ( _V ∖ { Y } ) ) ) ;;
	step 20 : wff = ss2rabdv (step 19) |- ( ph → { x ∈ D | ( A O B ) ∈ ( _V ∖ { Z } ) } ⊆ { x ∈ D | A ∈ ( _V ∖ { Y } ) } ) ;;
	step 21 : wff = eqid () |- ( x ∈ D ↦ ( A O B ) ) = ( x ∈ D ↦ ( A O B ) ) ;;
	step 22 : wff = mptpreima (step 21) |- ( ⁻¹ ( x ∈ D ↦ ( A O B ) ) " ( _V ∖ { Z } ) ) = { x ∈ D | ( A O B ) ∈ ( _V ∖ { Z } ) } ;;
	step 23 : wff = eqid () |- ( x ∈ D ↦ A ) = ( x ∈ D ↦ A ) ;;
	step 24 : wff = mptpreima (step 23) |- ( ⁻¹ ( x ∈ D ↦ A ) " ( _V ∖ { Y } ) ) = { x ∈ D | A ∈ ( _V ∖ { Y } ) } ;;
	step 25 : wff = 3sstr4g (step 20, step 22, step 24) |- ( ph → ( ⁻¹ ( x ∈ D ↦ ( A O B ) ) " ( _V ∖ { Z } ) ) ⊆ ( ⁻¹ ( x ∈ D ↦ A ) " ( _V ∖ { Y } ) ) ) ;;
	step 26 : wff = sstrd (step 25, hyp 1) |- ( ph → ( ⁻¹ ( x ∈ D ↦ ( A O B ) ) " ( _V ∖ { Z } ) ) ⊆ L ) ;;
	qed prop 1 = step 26 ;;
}


