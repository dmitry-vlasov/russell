import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Power_Sets/Ordered_pair_theorem.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                Ordered-pair class abstractions (cont.)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*The law of concretion.  Special case of Theorem 9.5 of [Quine] p. 61.
       (Contributed by NM, 14-Apr-1995.)  (Proof shortened by Andrew Salmon,
       25-Jul-2011.) */

theorem opabid (ph : wff, x : set, y : set) disjointed(x z, y z, ph z) {
	prop 1 : wff = |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
}

proof of opabid {
	var z : set;;
	step 1 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 2 : wff = copsexg () |- ( z = 〈 x , y 〉 → ( ph ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 3 : wff = bicomd (step 2) |- ( z = 〈 x , y 〉 → ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ph ) ) ;;
	step 4 : wff = df-opab () |- { 〈 x , y 〉 | ph } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ;;
	step 5 : wff = elab2 (step 1, step 3, step 4) |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
	qed prop 1 = step 5 ;;
}

/*Membership in a class abstraction of pairs.  (Contributed by NM,
       24-Mar-1998.) */

theorem elopab (ph : wff, x : set, y : set, A : class) disjointed(x z A, y z A, z ph) {
	prop 1 : wff = |- ( A ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) ) ;;
}

proof of elopab {
	var z : set;;
	step 1 : wff = elex () |- ( A ∈ { 〈 x , y 〉 | ph } → A ∈ _V ) ;;
	step 2 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 3 : wff = eleq1 () |- ( A = 〈 x , y 〉 → ( A ∈ _V ↔ 〈 x , y 〉 ∈ _V ) ) ;;
	step 4 : wff = mpbiri (step 2, step 3) |- ( A = 〈 x , y 〉 → A ∈ _V ) ;;
	step 5 : wff = adantr (step 4) |- ( ( A = 〈 x , y 〉 ∧ ph ) → A ∈ _V ) ;;
	step 6 : wff = exlimivv (step 5) |- ( ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) → A ∈ _V ) ;;
	step 7 : wff = eqeq1 () |- ( z = A → ( z = 〈 x , y 〉 ↔ A = 〈 x , y 〉 ) ) ;;
	step 8 : wff = anbi1d (step 7) |- ( z = A → ( ( z = 〈 x , y 〉 ∧ ph ) ↔ ( A = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 9 : wff = 2exbidv (step 8) |- ( z = A → ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 10 : wff = df-opab () |- { 〈 x , y 〉 | ph } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ;;
	step 11 : wff = elab2g (step 9, step 10) |- ( A ∈ _V → ( A ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) ) ) ;;
	step 12 : wff = pm5.21nii (step 1, step 6, step 11) |- ( A ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( A = 〈 x , y 〉 ∧ ph ) ) ;;
	qed prop 1 = step 12 ;;
}

/*The law of concretion in terms of substitutions.  (Contributed by NM,
       30-Sep-2002.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.)
       (New usage is discouraged.) */

theorem opelopabsbOLD (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z, x y w, ph) {
	prop 1 : wff = |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] [ z / x ] ph ) ;;
}

proof of opelopabsbOLD {
	step 1 : wff = excom () |- ( ∃ x ∃ y ( 〈 z , w 〉 = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ∃ x ( 〈 z , w 〉 = 〈 x , y 〉 ∧ ph ) ) ;;
	step 2 : wff = vex () |- z ∈ _V ;;
	step 3 : wff = vex () |- w ∈ _V ;;
	step 4 : wff = opth (step 2, step 3) |- ( 〈 z , w 〉 = 〈 x , y 〉 ↔ ( z = x ∧ w = y ) ) ;;
	step 5 : wff = equcom () |- ( z = x ↔ x = z ) ;;
	step 6 : wff = equcom () |- ( w = y ↔ y = w ) ;;
	step 7 : wff = anbi12ci (step 5, step 6) |- ( ( z = x ∧ w = y ) ↔ ( y = w ∧ x = z ) ) ;;
	step 8 : wff = bitri (step 4, step 7) |- ( 〈 z , w 〉 = 〈 x , y 〉 ↔ ( y = w ∧ x = z ) ) ;;
	step 9 : wff = anbi1i (step 8) |- ( ( 〈 z , w 〉 = 〈 x , y 〉 ∧ ph ) ↔ ( ( y = w ∧ x = z ) ∧ ph ) ) ;;
	step 10 : wff = 2exbii (step 9) |- ( ∃ y ∃ x ( 〈 z , w 〉 = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ∃ x ( ( y = w ∧ x = z ) ∧ ph ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( ∃ x ∃ y ( 〈 z , w 〉 = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ∃ x ( ( y = w ∧ x = z ) ∧ ph ) ) ;;
	step 12 : wff = elopab () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( 〈 z , w 〉 = 〈 x , y 〉 ∧ ph ) ) ;;
	step 13 : wff = 2sb5 () |- ( [ w / y ] [ z / x ] ph ↔ ∃ y ∃ x ( ( y = w ∧ x = z ) ∧ ph ) ) ;;
	step 14 : wff = 3bitr4i (step 11, step 12, step 13) |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] [ z / x ] ph ) ;;
	qed prop 1 = step 14 ;;
}

/*The law of concretion in terms of substitutions.  (Contributed by NM,
       17-Mar-2008.)  (New usage is discouraged.) */

theorem brabsbOLD (ph : wff, x : set, y : set, z : set, w : set, R : class) disjointed(x y z, x y w, ph) {
	hyp 1 : wff = |- R = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( z R w ↔ [ w / y ] [ z / x ] ph ) ;;
}

proof of brabsbOLD {
	step 1 : wff = breqi (hyp 1) |- ( z R w ↔ z { 〈 x , y 〉 | ph } w ) ;;
	step 2 : wff = df-br () |- ( z { 〈 x , y 〉 | ph } w ↔ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 3 : wff = opelopabsbOLD () |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] [ z / x ] ph ) ;;
	step 4 : wff = 3bitri (step 1, step 2, step 3) |- ( z R w ↔ [ w / y ] [ z / x ] ph ) ;;
	qed prop 1 = step 4 ;;
}

/*The law of concretion in terms of substitutions.  (Contributed by NM,
       30-Sep-2002.)  (Revised by Mario Carneiro, 18-Nov-2016.) */

theorem opelopabsb (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y z w, w z A, w x B, w z ph) {
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ;;
}

proof of opelopabsb {
	var z : set, w : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = opnzi (step 1, step 2) |- 〈 x , y 〉 ≠ ∅ ;;
	step 4 : wff = simpl () |- ( ( ∅ = 〈 x , y 〉 ∧ ph ) → ∅ = 〈 x , y 〉 ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ( ∅ = 〈 x , y 〉 ∧ ph ) → 〈 x , y 〉 = ∅ ) ;;
	step 6 : wff = necon3ai (step 5) |- ( 〈 x , y 〉 ≠ ∅ → ¬ ( ∅ = 〈 x , y 〉 ∧ ph ) ) ;;
	step 7 : wff = ax-mp (step 3, step 6) |- ¬ ( ∅ = 〈 x , y 〉 ∧ ph ) ;;
	step 8 : wff = nex (step 7) |- ¬ ∃ y ( ∅ = 〈 x , y 〉 ∧ ph ) ;;
	step 9 : wff = nex (step 8) |- ¬ ∃ x ∃ y ( ∅ = 〈 x , y 〉 ∧ ph ) ;;
	step 10 : wff = elopab () |- ( ∅ ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( ∅ = 〈 x , y 〉 ∧ ph ) ) ;;
	step 11 : wff = mtbir (step 9, step 10) |- ¬ ∅ ∈ { 〈 x , y 〉 | ph } ;;
	step 12 : wff = eleq1 () |- ( 〈 A , B 〉 = ∅ → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ∅ ∈ { 〈 x , y 〉 | ph } ) ) ;;
	step 13 : wff = mtbiri (step 11, step 12) |- ( 〈 A , B 〉 = ∅ → ¬ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 14 : wff = necon2ai (step 13) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } → 〈 A , B 〉 ≠ ∅ ) ;;
	step 15 : wff = opnz () |- ( 〈 A , B 〉 ≠ ∅ ↔ ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 16 : wff = sylib (step 14, step 15) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 17 : wff = sbcex () |- ( [. A / x ]. [. B / y ]. ph → A ∈ _V ) ;;
	step 18 : wff = spesbc () |- ( [. A / x ]. [. B / y ]. ph → ∃ x [. B / y ]. ph ) ;;
	step 19 : wff = sbcex () |- ( [. B / y ]. ph → B ∈ _V ) ;;
	step 20 : wff = exlimiv (step 19) |- ( ∃ x [. B / y ]. ph → B ∈ _V ) ;;
	step 21 : wff = syl (step 18, step 20) |- ( [. A / x ]. [. B / y ]. ph → B ∈ _V ) ;;
	step 22 : wff = jca (step 17, step 21) |- ( [. A / x ]. [. B / y ]. ph → ( A ∈ _V ∧ B ∈ _V ) ) ;;
	step 23 : wff = opeq1 () |- ( z = A → 〈 z , w 〉 = 〈 A , w 〉 ) ;;
	step 24 : wff = eleq1d (step 23) |- ( z = A → ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ 〈 A , w 〉 ∈ { 〈 x , y 〉 | ph } ) ) ;;
	step 25 : wff = dfsbcq2 () |- ( z = A → ( [ z / x ] [ w / y ] ph ↔ [. A / x ]. [ w / y ] ph ) ) ;;
	step 26 : wff = bibi12d (step 24, step 25) |- ( z = A → ( ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ z / x ] [ w / y ] ph ) ↔ ( 〈 A , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [ w / y ] ph ) ) ) ;;
	step 27 : wff = opeq2 () |- ( w = B → 〈 A , w 〉 = 〈 A , B 〉 ) ;;
	step 28 : wff = eleq1d (step 27) |- ( w = B → ( 〈 A , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ) ) ;;
	step 29 : wff = dfsbcq2 () |- ( w = B → ( [ w / y ] ph ↔ [. B / y ]. ph ) ) ;;
	step 30 : wff = sbcbidv (step 29) |- ( w = B → ( [. A / x ]. [ w / y ] ph ↔ [. A / x ]. [. B / y ]. ph ) ) ;;
	step 31 : wff = bibi12d (step 28, step 30) |- ( w = B → ( ( 〈 A , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [ w / y ] ph ) ↔ ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ) ) ;;
	step 32 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ph } ;;
	step 33 : wff = nfel2 (step 32) |- F/ x 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ;;
	step 34 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 35 : wff = nfbi (step 33, step 34) |- F/ x ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ z / x ] [ w / y ] ph ) ;;
	step 36 : wff = opeq1 () |- ( x = z → 〈 x , w 〉 = 〈 z , w 〉 ) ;;
	step 37 : wff = eleq1d (step 36) |- ( x = z → ( 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ) ) ;;
	step 38 : wff = sbequ12 () |- ( x = z → ( [ w / y ] ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 39 : wff = bibi12d (step 37, step 38) |- ( x = z → ( ( 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] ph ) ↔ ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ z / x ] [ w / y ] ph ) ) ) ;;
	step 40 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ph } ;;
	step 41 : wff = nfel2 (step 40) |- F/ y 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ;;
	step 42 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 43 : wff = nfbi (step 41, step 42) |- F/ y ( 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] ph ) ;;
	step 44 : wff = opeq2 () |- ( y = w → 〈 x , y 〉 = 〈 x , w 〉 ) ;;
	step 45 : wff = eleq1d (step 44) |- ( y = w → ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ) ) ;;
	step 46 : wff = sbequ12 () |- ( y = w → ( ph ↔ [ w / y ] ph ) ) ;;
	step 47 : wff = bibi12d (step 45, step 46) |- ( y = w → ( ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ↔ ( 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] ph ) ) ) ;;
	step 48 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
	step 49 : wff = chvar (step 43, step 47, step 48) |- ( 〈 x , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ w / y ] ph ) ;;
	step 50 : wff = chvar (step 35, step 39, step 49) |- ( 〈 z , w 〉 ∈ { 〈 x , y 〉 | ph } ↔ [ z / x ] [ w / y ] ph ) ;;
	step 51 : wff = vtocl2g (step 26, step 31, step 50) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ) ;;
	step 52 : wff = pm5.21nii (step 16, step 22, step 51) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ;;
	qed prop 1 = step 52 ;;
}

/*The law of concretion in terms of substitutions.  (Contributed by NM,
       17-Mar-2008.) */

theorem brabsb (ph : wff, x : set, y : set, A : class, B : class, R : class) disjointed(x y, A, x B, ph) {
	hyp 1 : wff = |- R = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A R B ↔ [. A / x ]. [. B / y ]. ph ) ;;
}

proof of brabsb {
	step 1 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 2 : wff = eleq2i (hyp 1) |- ( 〈 A , B 〉 ∈ R ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 3 : wff = opelopabsb () |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ;;
	step 4 : wff = 3bitri (step 1, step 2, step 3) |- ( A R B ↔ [. A / x ]. [. B / y ]. ph ) ;;
	qed prop 1 = step 4 ;;
}

/*Closed theorem form of ~ opelopab .  (Contributed by NM,
       19-Feb-2013.) */

theorem opelopabt (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x y A, x y B, x y ch, ph) {
	prop 1 : wff = |- ( ( ∀ x ∀ y ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ∀ y ( y = B → ( ps ↔ ch ) ) ∧ ( A ∈ V ∧ B ∈ W ) ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ) ;;
}

proof of opelopabt {
	step 1 : wff = elopab () |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ ph ) ) ;;
	step 2 : wff = 19.26-2 () |- ( ∀ x ∀ y ( ( x = A → ( ph ↔ ps ) ) ∧ ( y = B → ( ps ↔ ch ) ) ) ↔ ( ∀ x ∀ y ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ∀ y ( y = B → ( ps ↔ ch ) ) ) ) ;;
	step 3 : wff = prth () |- ( ( ( x = A → ( ph ↔ ps ) ) ∧ ( y = B → ( ps ↔ ch ) ) ) → ( ( x = A ∧ y = B ) → ( ( ph ↔ ps ) ∧ ( ps ↔ ch ) ) ) ) ;;
	step 4 : wff = bitr () |- ( ( ( ph ↔ ps ) ∧ ( ps ↔ ch ) ) → ( ph ↔ ch ) ) ;;
	step 5 : wff = syl6 (step 3, step 4) |- ( ( ( x = A → ( ph ↔ ps ) ) ∧ ( y = B → ( ps ↔ ch ) ) ) → ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ) ;;
	step 6 : wff = 2alimi (step 5) |- ( ∀ x ∀ y ( ( x = A → ( ph ↔ ps ) ) ∧ ( y = B → ( ps ↔ ch ) ) ) → ∀ x ∀ y ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ) ;;
	step 7 : wff = sylbir (step 2, step 6) |- ( ( ∀ x ∀ y ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ∀ y ( y = B → ( ps ↔ ch ) ) ) → ∀ x ∀ y ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ) ;;
	step 8 : wff = copsex2t () |- ( ( ∀ x ∀ y ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ∧ ( A ∈ V ∧ B ∈ W ) ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ ph ) ↔ ch ) ) ;;
	step 9 : wff = sylan (step 7, step 8) |- ( ( ( ∀ x ∀ y ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ∀ y ( y = B → ( ps ↔ ch ) ) ) ∧ ( A ∈ V ∧ B ∈ W ) ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ ph ) ↔ ch ) ) ;;
	step 10 : wff = 3impa (step 9) |- ( ( ∀ x ∀ y ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ∀ y ( y = B → ( ps ↔ ch ) ) ∧ ( A ∈ V ∧ B ∈ W ) ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ ph ) ↔ ch ) ) ;;
	step 11 : wff = syl5bb (step 1, step 10) |- ( ( ∀ x ∀ y ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ∀ y ( y = B → ( ps ↔ ch ) ) ∧ ( A ∈ V ∧ B ∈ W ) ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ) ;;
	qed prop 1 = step 11 ;;
}

/*The law of concretion.  Theorem 9.5 of [Quine] p. 61.  (Contributed by
       Mario Carneiro, 19-Dec-2013.) */

theorem opelopabga (ph : wff, ps : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ) ;;
}

proof of opelopabga {
	step 1 : wff = elopab () |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ ph ) ) ;;
	step 2 : wff = copsex2g (hyp 1) |- ( ( A ∈ V ∧ B ∈ W ) → ( ∃ x ∃ y ( 〈 A , B 〉 = 〈 x , y 〉 ∧ ph ) ↔ ps ) ) ;;
	step 3 : wff = syl5bb (step 1, step 2) |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*The law of concretion for a binary relation.  (Contributed by Mario
         Carneiro, 19-Dec-2013.) */

theorem brabga (ph : wff, ps : wff, x : set, y : set, A : class, B : class, R : class, V : class, W : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- R = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( A R B ↔ ps ) ) ;;
}

proof of brabga {
	step 1 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 2 : wff = eleq2i (hyp 2) |- ( 〈 A , B 〉 ∈ R ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A R B ↔ 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ) ;;
	step 4 : wff = opelopabga (hyp 1) |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ) ;;
	step 5 : wff = syl5bb (step 3, step 4) |- ( ( A ∈ V ∧ B ∈ W ) → ( A R B ↔ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Ordered pair membership in an ordered pair class abstraction.
       (Contributed by Mario Carneiro, 19-Dec-2013.) */

theorem opelopab2a (ph : wff, ps : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x y ps, x y C, x y D) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ps ) ) ;;
}

proof of opelopab2a {
	step 1 : wff = eleq1 () |- ( x = A → ( x ∈ C ↔ A ∈ C ) ) ;;
	step 2 : wff = eleq1 () |- ( y = B → ( y ∈ D ↔ B ∈ D ) ) ;;
	step 3 : wff = bi2anan9 (step 1, step 2) |- ( ( x = A ∧ y = B ) → ( ( x ∈ C ∧ y ∈ D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ) ;;
	step 4 : wff = anbi12d (step 3, hyp 1) |- ( ( x = A ∧ y = B ) → ( ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ ps ) ) ) ;;
	step 5 : wff = opelopabga (step 4) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ( ( A ∈ C ∧ B ∈ D ) ∧ ps ) ) ) ;;
	step 6 : wff = bianabs (step 5) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/*The law of concretion.  Theorem 9.5 of [Quine] p. 61.  (Contributed by
       Mario Carneiro, 19-Dec-2013.) */

theorem opelopaba (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ;;
}

proof of opelopaba {
	step 1 : wff = opelopabga (hyp 3) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/*The law of concretion for a binary relation.  (Contributed by NM,
         19-Dec-2013.) */

theorem braba (ph : wff, ps : wff, x : set, y : set, A : class, B : class, R : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- R = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A R B ↔ ps ) ;;
}

proof of braba {
	step 1 : wff = brabga (hyp 3, hyp 4) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A R B ↔ ps ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A R B ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/*The law of concretion.  Theorem 9.5 of [Quine] p. 61.  (Contributed by
       NM, 28-May-1995.)  (Revised by Mario Carneiro, 19-Dec-2013.) */

theorem opelopabg (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x y A, x y B, x y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ) ;;
}

proof of opelopabg {
	step 1 : wff = sylan9bb (hyp 1, hyp 2) |- ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ;;
	step 2 : wff = opelopabga (step 1) |- ( ( A ∈ V ∧ B ∈ W ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*The law of concretion for a binary relation.  (Contributed by NM,
         16-Aug-1999.)  (Revised by Mario Carneiro, 19-Dec-2013.) */

theorem brabg (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class) disjointed(x y A, x y B, x y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- R = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( A R B ↔ ch ) ) ;;
}

proof of brabg {
	step 1 : wff = sylan9bb (hyp 1, hyp 2) |- ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ;;
	step 2 : wff = brabga (step 1, hyp 3) |- ( ( A ∈ C ∧ B ∈ D ) → ( A R B ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Ordered pair membership in an ordered pair class abstraction.
       (Contributed by NM, 14-Oct-2007.)  (Revised by Mario Carneiro,
       19-Dec-2013.) */

theorem opelopab2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x y C, x y D, x y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ch ) ) ;;
}

proof of opelopab2 {
	step 1 : wff = sylan9bb (hyp 1, hyp 2) |- ( ( x = A ∧ y = B ) → ( ph ↔ ch ) ) ;;
	step 2 : wff = opelopab2a (step 1) |- ( ( A ∈ C ∧ B ∈ D ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ( ( x ∈ C ∧ y ∈ D ) ∧ ph ) } ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*The law of concretion.  Theorem 9.5 of [Quine] p. 61.  (Contributed by
       NM, 16-May-1995.) */

theorem opelopab (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, x y ch) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ;;
}

proof of opelopab {
	step 1 : wff = opelopabg (hyp 3, hyp 4) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/*The law of concretion for a binary relation.  (Contributed by NM,
         16-Aug-1999.) */

theorem brab (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, R : class) disjointed(x y A, x y B, x y ch) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 5 : wff = |- R = { 〈 x , y 〉 | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A R B ↔ ch ) ;;
}

proof of brab {
	step 1 : wff = brabg (hyp 3, hyp 4, hyp 5) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( A R B ↔ ch ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A R B ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/*The law of concretion.  Theorem 9.5 of [Quine] p. 61.  This version of
       ~ opelopab uses bound-variable hypotheses in place of distinct variable
       conditions."  (Contributed by Mario Carneiro, 19-Dec-2013.)  (Proof
       shortened by Mario Carneiro, 18-Nov-2016.) */

theorem opelopabaf (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, ph, ps) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- F/ y ps ;;
	hyp 3 : wff = |- A ∈ _V ;;
	hyp 4 : wff = |- B ∈ _V ;;
	hyp 5 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ;;
}

proof of opelopabaf {
	step 1 : wff = opelopabsb () |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ;;
	step 2 : wff = nfv () |- F/ x B ∈ _V ;;
	step 3 : wff = sbc2iegf (hyp 1, hyp 2, step 2, hyp 5) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( [. A / x ]. [. B / y ]. ph ↔ ps ) ) ;;
	step 4 : wff = mp2an (hyp 3, hyp 4, step 3) |- ( [. A / x ]. [. B / y ]. ph ↔ ps ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ps ) ;;
	qed prop 1 = step 5 ;;
}

/*The law of concretion.  Theorem 9.5 of [Quine] p. 61.  This version of
       ~ opelopab uses bound-variable hypotheses in place of distinct variable
       conditions."  (Contributed by NM, 19-Dec-2008.) */

theorem opelopabf (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, ch, ph) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- F/ y ch ;;
	hyp 3 : wff = |- A ∈ _V ;;
	hyp 4 : wff = |- B ∈ _V ;;
	hyp 5 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 6 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ;;
}

proof of opelopabf {
	step 1 : wff = opelopabsb () |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ [. A / x ]. [. B / y ]. ph ) ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = nfsbc (step 2, hyp 1) |- F/ x [. B / y ]. ps ;;
	step 4 : wff = sbcbidv (hyp 5) |- ( x = A → ( [. B / y ]. ph ↔ [. B / y ]. ps ) ) ;;
	step 5 : wff = sbciegf (step 3, step 4) |- ( A ∈ _V → ( [. A / x ]. [. B / y ]. ph ↔ [. B / y ]. ps ) ) ;;
	step 6 : wff = ax-mp (hyp 3, step 5) |- ( [. A / x ]. [. B / y ]. ph ↔ [. B / y ]. ps ) ;;
	step 7 : wff = sbciegf (hyp 2, hyp 6) |- ( B ∈ _V → ( [. B / y ]. ps ↔ ch ) ) ;;
	step 8 : wff = ax-mp (hyp 4, step 7) |- ( [. B / y ]. ps ↔ ch ) ;;
	step 9 : wff = 3bitri (step 1, step 6, step 8) |- ( 〈 A , B 〉 ∈ { 〈 x , y 〉 | ph } ↔ ch ) ;;
	qed prop 1 = step 9 ;;
}

/*Equivalence of ordered pair abstraction subclass and implication.
       (Contributed by NM, 27-Dec-1996.)  (Revised by Mario Carneiro,
       19-May-2013.) */

theorem ssopab2 (ph : wff, ps : wff, x : set, y : set) disjointed(ph z, ps z, x z, y z) {
	prop 1 : wff = |- ( ∀ x ∀ y ( ph → ps ) → { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ) ;;
}

proof of ssopab2 {
	var z : set;;
	step 1 : wff = nfa1 () |- F/ x ∀ x ∀ y ( ph → ps ) ;;
	step 2 : wff = nfa1 () |- F/ y ∀ y ( ph → ps ) ;;
	step 3 : wff = sp () |- ( ∀ y ( ph → ps ) → ( ph → ps ) ) ;;
	step 4 : wff = anim2d (step 3) |- ( ∀ y ( ph → ps ) → ( ( z = 〈 x , y 〉 ∧ ph ) → ( z = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 5 : wff = eximd (step 2, step 4) |- ( ∀ y ( ph → ps ) → ( ∃ y ( z = 〈 x , y 〉 ∧ ph ) → ∃ y ( z = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 6 : wff = sps (step 5) |- ( ∀ x ∀ y ( ph → ps ) → ( ∃ y ( z = 〈 x , y 〉 ∧ ph ) → ∃ y ( z = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 7 : wff = eximd (step 1, step 6) |- ( ∀ x ∀ y ( ph → ps ) → ( ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) → ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ps ) ) ) ;;
	step 8 : wff = ss2abdv (step 7) |- ( ∀ x ∀ y ( ph → ps ) → { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ⊆ { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ps ) } ) ;;
	step 9 : wff = df-opab () |- { 〈 x , y 〉 | ph } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) } ;;
	step 10 : wff = df-opab () |- { 〈 x , y 〉 | ps } = { z | ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ps ) } ;;
	step 11 : wff = 3sstr4g (step 8, step 9, step 10) |- ( ∀ x ∀ y ( ph → ps ) → { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ) ;;
	qed prop 1 = step 11 ;;
}

/*Equivalence of ordered pair abstraction subclass and implication.
       (Contributed by NM, 27-Dec-1996.)  (Proof shortened by Mario Carneiro,
       18-Nov-2016.) */

theorem ssopab2b (ph : wff, ps : wff, x : set, y : set) disjointed(ph, ps, x, y) {
	prop 1 : wff = |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ↔ ∀ x ∀ y ( ph → ps ) ) ;;
}

proof of ssopab2b {
	step 1 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ph } ;;
	step 2 : wff = nfopab1 () |- F/_ x { 〈 x , y 〉 | ps } ;;
	step 3 : wff = nfss (step 1, step 2) |- F/ x { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ;;
	step 4 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ph } ;;
	step 5 : wff = nfopab2 () |- F/_ y { 〈 x , y 〉 | ps } ;;
	step 6 : wff = nfss (step 4, step 5) |- F/ y { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ;;
	step 7 : wff = ssel () |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } → ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } → 〈 x , y 〉 ∈ { 〈 x , y 〉 | ps } ) ) ;;
	step 8 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ph } ↔ ph ) ;;
	step 9 : wff = opabid () |- ( 〈 x , y 〉 ∈ { 〈 x , y 〉 | ps } ↔ ps ) ;;
	step 10 : wff = 3imtr3g (step 7, step 8, step 9) |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } → ( ph → ps ) ) ;;
	step 11 : wff = alrimi (step 6, step 10) |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } → ∀ y ( ph → ps ) ) ;;
	step 12 : wff = alrimi (step 3, step 11) |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } → ∀ x ∀ y ( ph → ps ) ) ;;
	step 13 : wff = ssopab2 () |- ( ∀ x ∀ y ( ph → ps ) → { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ) ;;
	step 14 : wff = impbii (step 12, step 13) |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ↔ ∀ x ∀ y ( ph → ps ) ) ;;
	qed prop 1 = step 14 ;;
}

/*Inference of ordered pair abstraction subclass from implication.
       (Contributed by NM, 5-Apr-1995.) */

theorem ssopab2i (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ;;
}

proof of ssopab2i {
	step 1 : wff = ssopab2 () |- ( ∀ x ∀ y ( ph → ps ) → { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ) ;;
	step 2 : wff = ax-gen (hyp 1) |- ∀ y ( ph → ps ) ;;
	step 3 : wff = mpg (step 1, step 2) |- { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ;;
	qed prop 1 = step 3 ;;
}

/*Inference of ordered pair abstraction subclass from implication.
       (Contributed by NM, 19-Jan-2014.)  (Revised by Mario Carneiro,
       24-Jun-2014.) */

theorem ssopab2dv (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x ph, y ph) {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { 〈 x , y 〉 | ps } ⊆ { 〈 x , y 〉 | ch } ) ;;
}

proof of ssopab2dv {
	step 1 : wff = alrimivv (hyp 1) |- ( ph → ∀ x ∀ y ( ps → ch ) ) ;;
	step 2 : wff = ssopab2 () |- ( ∀ x ∀ y ( ps → ch ) → { 〈 x , y 〉 | ps } ⊆ { 〈 x , y 〉 | ch } ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → { 〈 x , y 〉 | ps } ⊆ { 〈 x , y 〉 | ch } ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalence of ordered pair abstraction equality and biconditional.
       (Contributed by Mario Carneiro, 4-Jan-2017.) */

theorem eqopab2b (ph : wff, ps : wff, x : set, y : set) disjointed(ph, ps, x, y) {
	prop 1 : wff = |- ( { 〈 x , y 〉 | ph } = { 〈 x , y 〉 | ps } ↔ ∀ x ∀ y ( ph ↔ ps ) ) ;;
}

proof of eqopab2b {
	step 1 : wff = ssopab2b () |- ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ↔ ∀ x ∀ y ( ph → ps ) ) ;;
	step 2 : wff = ssopab2b () |- ( { 〈 x , y 〉 | ps } ⊆ { 〈 x , y 〉 | ph } ↔ ∀ x ∀ y ( ps → ph ) ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ∧ { 〈 x , y 〉 | ps } ⊆ { 〈 x , y 〉 | ph } ) ↔ ( ∀ x ∀ y ( ph → ps ) ∧ ∀ x ∀ y ( ps → ph ) ) ) ;;
	step 4 : wff = eqss () |- ( { 〈 x , y 〉 | ph } = { 〈 x , y 〉 | ps } ↔ ( { 〈 x , y 〉 | ph } ⊆ { 〈 x , y 〉 | ps } ∧ { 〈 x , y 〉 | ps } ⊆ { 〈 x , y 〉 | ph } ) ) ;;
	step 5 : wff = 2albiim () |- ( ∀ x ∀ y ( ph ↔ ps ) ↔ ( ∀ x ∀ y ( ph → ps ) ∧ ∀ x ∀ y ( ps → ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( { 〈 x , y 〉 | ph } = { 〈 x , y 〉 | ps } ↔ ∀ x ∀ y ( ph ↔ ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Non-empty ordered pair class abstraction.  (Contributed by NM,
       10-Oct-2007.) */

theorem opabn0 (ph : wff, x : set, y : set) disjointed(z ph, z x, z y) {
	prop 1 : wff = |- ( { 〈 x , y 〉 | ph } ≠ ∅ ↔ ∃ x ∃ y ph ) ;;
}

proof of opabn0 {
	var z : set;;
	step 1 : wff = n0 () |- ( { 〈 x , y 〉 | ph } ≠ ∅ ↔ ∃ z z ∈ { 〈 x , y 〉 | ph } ) ;;
	step 2 : wff = elopab () |- ( z ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ z z ∈ { 〈 x , y 〉 | ph } ↔ ∃ z ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 4 : wff = exrot3 () |- ( ∃ z ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ∃ z ( z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 5 : wff = opex () |- 〈 x , y 〉 ∈ _V ;;
	step 6 : wff = isseti (step 5) |- ∃ z z = 〈 x , y 〉 ;;
	step 7 : wff = 19.41v () |- ( ∃ z ( z = 〈 x , y 〉 ∧ ph ) ↔ ( ∃ z z = 〈 x , y 〉 ∧ ph ) ) ;;
	step 8 : wff = mpbiran (step 6, step 7) |- ( ∃ z ( z = 〈 x , y 〉 ∧ ph ) ↔ ph ) ;;
	step 9 : wff = 2exbii (step 8) |- ( ∃ x ∃ y ∃ z ( z = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ph ) ;;
	step 10 : wff = bitri (step 4, step 9) |- ( ∃ z ∃ x ∃ y ( z = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ph ) ;;
	step 11 : wff = bitri (step 3, step 10) |- ( ∃ z z ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ph ) ;;
	step 12 : wff = bitri (step 1, step 11) |- ( { 〈 x , y 〉 | ph } ≠ ∅ ↔ ∃ x ∃ y ph ) ;;
	qed prop 1 = step 12 ;;
}

/*Move indexed union inside an ordered-pair abstraction.  (Contributed by
       Stefan O'Rear, 20-Feb-2015.) */

theorem iunopab (ph : wff, x : set, y : set, z : set, A : class) disjointed(ph w, A w x, A y, w y z, x z) {
	prop 1 : wff = |- ⋃_ z ∈ A { 〈 x , y 〉 | ph } = { 〈 x , y 〉 | ∃ z ∈ A ph } ;;
}

proof of iunopab {
	var w : set;;
	step 1 : wff = elopab () |- ( w ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 2 : wff = rexbii (step 1) |- ( ∃ z ∈ A w ∈ { 〈 x , y 〉 | ph } ↔ ∃ z ∈ A ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 3 : wff = rexcom4 () |- ( ∃ z ∈ A ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ z ∈ A ∃ y ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 4 : wff = rexcom4 () |- ( ∃ z ∈ A ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ∃ z ∈ A ( w = 〈 x , y 〉 ∧ ph ) ) ;;
	step 5 : wff = r19.42v () |- ( ∃ z ∈ A ( w = 〈 x , y 〉 ∧ ph ) ↔ ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ∃ z ∈ A ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) ) ;;
	step 7 : wff = bitri (step 4, step 6) |- ( ∃ z ∈ A ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ x ∃ z ∈ A ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) ) ;;
	step 9 : wff = bitri (step 3, step 8) |- ( ∃ z ∈ A ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ph ) ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) ) ;;
	step 10 : wff = bitri (step 2, step 9) |- ( ∃ z ∈ A w ∈ { 〈 x , y 〉 | ph } ↔ ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) ) ;;
	step 11 : wff = abbii (step 10) |- { w | ∃ z ∈ A w ∈ { 〈 x , y 〉 | ph } } = { w | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) } ;;
	step 12 : wff = df-iun () |- ⋃_ z ∈ A { 〈 x , y 〉 | ph } = { w | ∃ z ∈ A w ∈ { 〈 x , y 〉 | ph } } ;;
	step 13 : wff = df-opab () |- { 〈 x , y 〉 | ∃ z ∈ A ph } = { w | ∃ x ∃ y ( w = 〈 x , y 〉 ∧ ∃ z ∈ A ph ) } ;;
	step 14 : wff = 3eqtr4i (step 11, step 12, step 13) |- ⋃_ z ∈ A { 〈 x , y 〉 | ph } = { 〈 x , y 〉 | ∃ z ∈ A ph } ;;
	qed prop 1 = step 14 ;;
}


