import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Power_Sets/Introduce_the_Axiom_of_Power_Sets.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                   Derive the Axiom of Pairing

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* The Axiom of Pairing of Zermelo-Fraenkel set theory.  Axiom 2 of
       [TakeutiZaring] p. 15.  In some textbooks this is stated as a separate
       axiom; here we show it is redundant since it can be derived from the
       other axioms.

       This theorem should not be referenced by any proof other than ~ axpr .
       Instead, use ~ zfpair2 below so that the uses of the Axiom of Pairing
       can be more easily identified.  (Contributed by NM, 18-Oct-1995.)
       (New usage is discouraged.) */

theorem zfpair (x : set, y : set) disjointed(x z w v, y z w v) {
	prop 1 : wff = |- { x , y } ∈ _V ;;
}

proof of zfpair {
	var z : set, w : set, v : set;;
	step 1 : wff = dfpr2 () |- { x , y } = { w | ( w = x ∨ w = y ) } ;;
	step 2 : wff = 19.43 () |- ( ∃ z ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ↔ ( ∃ z ( z = ∅ ∧ w = x ) ∨ ∃ z ( z = { ∅ } ∧ w = y ) ) ) ;;
	step 3 : wff = prlem2 () |- ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ↔ ( ( z = ∅ ∨ z = { ∅ } ) ∧ ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ z ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ↔ ∃ z ( ( z = ∅ ∨ z = { ∅ } ) ∧ ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ) ) ;;
	step 5 : wff = 0ex () |- ∅ ∈ _V ;;
	step 6 : wff = isseti (step 5) |- ∃ z z = ∅ ;;
	step 7 : wff = 19.41v () |- ( ∃ z ( z = ∅ ∧ w = x ) ↔ ( ∃ z z = ∅ ∧ w = x ) ) ;;
	step 8 : wff = mpbiran (step 6, step 7) |- ( ∃ z ( z = ∅ ∧ w = x ) ↔ w = x ) ;;
	step 9 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 10 : wff = isseti (step 9) |- ∃ z z = { ∅ } ;;
	step 11 : wff = 19.41v () |- ( ∃ z ( z = { ∅ } ∧ w = y ) ↔ ( ∃ z z = { ∅ } ∧ w = y ) ) ;;
	step 12 : wff = mpbiran (step 10, step 11) |- ( ∃ z ( z = { ∅ } ∧ w = y ) ↔ w = y ) ;;
	step 13 : wff = orbi12i (step 8, step 12) |- ( ( ∃ z ( z = ∅ ∧ w = x ) ∨ ∃ z ( z = { ∅ } ∧ w = y ) ) ↔ ( w = x ∨ w = y ) ) ;;
	step 14 : wff = 3bitr3ri (step 2, step 4, step 13) |- ( ( w = x ∨ w = y ) ↔ ∃ z ( ( z = ∅ ∨ z = { ∅ } ) ∧ ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ) ) ;;
	step 15 : wff = abbii (step 14) |- { w | ( w = x ∨ w = y ) } = { w | ∃ z ( ( z = ∅ ∨ z = { ∅ } ) ∧ ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ) } ;;
	step 16 : wff = dfpr2 () |- { ∅ , { ∅ } } = { z | ( z = ∅ ∨ z = { ∅ } ) } ;;
	step 17 : wff = pp0ex () |- { ∅ , { ∅ } } ∈ _V ;;
	step 18 : wff = eqeltrri (step 16, step 17) |- { z | ( z = ∅ ∨ z = { ∅ } ) } ∈ _V ;;
	step 19 : wff = equequ2 () |- ( v = x → ( w = v ↔ w = x ) ) ;;
	step 20 : wff = 0inp0 () |- ( z = ∅ → ¬ z = { ∅ } ) ;;
	step 21 : wff = prlem1 (step 19, step 20) |- ( v = x → ( z = ∅ → ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ) ;;
	step 22 : wff = alrimdv (step 21) |- ( v = x → ( z = ∅ → ∀ w ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ) ;;
	step 23 : wff = spimev (step 22) |- ( z = ∅ → ∃ v ∀ w ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ;;
	step 24 : wff = orcom () |- ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ↔ ( ( z = { ∅ } ∧ w = y ) ∨ ( z = ∅ ∧ w = x ) ) ) ;;
	step 25 : wff = equequ2 () |- ( v = y → ( w = v ↔ w = y ) ) ;;
	step 26 : wff = 0inp0 () |- ( z = ∅ → ¬ z = { ∅ } ) ;;
	step 27 : wff = con2i (step 26) |- ( z = { ∅ } → ¬ z = ∅ ) ;;
	step 28 : wff = prlem1 (step 25, step 27) |- ( v = y → ( z = { ∅ } → ( ( ( z = { ∅ } ∧ w = y ) ∨ ( z = ∅ ∧ w = x ) ) → w = v ) ) ) ;;
	step 29 : wff = syl7bi (step 24, step 28) |- ( v = y → ( z = { ∅ } → ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ) ;;
	step 30 : wff = alrimdv (step 29) |- ( v = y → ( z = { ∅ } → ∀ w ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ) ;;
	step 31 : wff = spimev (step 30) |- ( z = { ∅ } → ∃ v ∀ w ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ;;
	step 32 : wff = jaoi (step 23, step 31) |- ( ( z = ∅ ∨ z = { ∅ } ) → ∃ v ∀ w ( ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) → w = v ) ) ;;
	step 33 : wff = zfrep4 (step 18, step 32) |- { w | ∃ z ( ( z = ∅ ∨ z = { ∅ } ) ∧ ( ( z = ∅ ∧ w = x ) ∨ ( z = { ∅ } ∧ w = y ) ) ) } ∈ _V ;;
	step 34 : wff = eqeltri (step 15, step 33) |- { w | ( w = x ∨ w = y ) } ∈ _V ;;
	step 35 : wff = eqeltri (step 1, step 34) |- { x , y } ∈ _V ;;
	qed prop 1 = step 35 ;;
}

/* Unabbreviated version of the Axiom of Pairing of ZF set theory, derived
       as a theorem from the other axioms.

       This theorem should not be referenced by any proof.  Instead, use
       ~ ax-pr below so that the uses of the Axiom of Pairing can be more
       easily identified.  (Contributed by NM, 14-Nov-2006.)
       (New usage is discouraged.) */

theorem axpr (x : set, y : set, z : set, w : set) disjointed(x z w, y z w) {
	prop 1 : wff = |- ∃ z ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ;;
}

proof of axpr {
	step 1 : wff = zfpair () |- { x , y } ∈ _V ;;
	step 2 : wff = isseti (step 1) |- ∃ z z = { x , y } ;;
	step 3 : wff = dfcleq () |- ( z = { x , y } ↔ ∀ w ( w ∈ z ↔ w ∈ { x , y } ) ) ;;
	step 4 : wff = vex () |- w ∈ _V ;;
	step 5 : wff = elpr (step 4) |- ( w ∈ { x , y } ↔ ( w = x ∨ w = y ) ) ;;
	step 6 : wff = bibi2i (step 5) |- ( ( w ∈ z ↔ w ∈ { x , y } ) ↔ ( w ∈ z ↔ ( w = x ∨ w = y ) ) ) ;;
	step 7 : wff = bi2 () |- ( ( w ∈ z ↔ ( w = x ∨ w = y ) ) → ( ( w = x ∨ w = y ) → w ∈ z ) ) ;;
	step 8 : wff = sylbi (step 6, step 7) |- ( ( w ∈ z ↔ w ∈ { x , y } ) → ( ( w = x ∨ w = y ) → w ∈ z ) ) ;;
	step 9 : wff = alimi (step 8) |- ( ∀ w ( w ∈ z ↔ w ∈ { x , y } ) → ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ) ;;
	step 10 : wff = sylbi (step 3, step 9) |- ( z = { x , y } → ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ) ;;
	step 11 : wff = eximi (step 10) |- ( ∃ z z = { x , y } → ∃ z ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ) ;;
	step 12 : wff = ax-mp (step 2, step 11) |- ∃ z ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ;;
	qed prop 1 = step 12 ;;
}

/* The Axiom of Pairing of ZF set theory.  It was derived as theorem ~ axpr
       above and is therefore redundant, but we state it as a separate axiom
       here so that its uses can be identified more easily.  (Contributed by
       NM, 14-Nov-2006.) */

axiom ax-pr (x : set, y : set, z : set, w : set) disjointed(x z w, y z w) {
	prop 1 : wff = |- ∃ z ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ;;
}

/* Derive the abbreviated version of the Axiom of Pairing from ~ ax-pr .
       See ~ zfpair for its derivation from the other axioms.  (Contributed by
       NM, 14-Nov-2006.) */

theorem zfpair2 (x : set, y : set) disjointed(x z w, y z w) {
	prop 1 : wff = |- { x , y } ∈ _V ;;
}

proof of zfpair2 {
	var z : set, w : set;;
	step 1 : wff = ax-pr () |- ∃ z ∀ w ( ( w = x ∨ w = y ) → w ∈ z ) ;;
	step 2 : wff = bm1.3ii (step 1) |- ∃ z ∀ w ( w ∈ z ↔ ( w = x ∨ w = y ) ) ;;
	step 3 : wff = dfcleq () |- ( z = { x , y } ↔ ∀ w ( w ∈ z ↔ w ∈ { x , y } ) ) ;;
	step 4 : wff = vex () |- w ∈ _V ;;
	step 5 : wff = elpr (step 4) |- ( w ∈ { x , y } ↔ ( w = x ∨ w = y ) ) ;;
	step 6 : wff = bibi2i (step 5) |- ( ( w ∈ z ↔ w ∈ { x , y } ) ↔ ( w ∈ z ↔ ( w = x ∨ w = y ) ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ w ( w ∈ z ↔ w ∈ { x , y } ) ↔ ∀ w ( w ∈ z ↔ ( w = x ∨ w = y ) ) ) ;;
	step 8 : wff = bitri (step 3, step 7) |- ( z = { x , y } ↔ ∀ w ( w ∈ z ↔ ( w = x ∨ w = y ) ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ z z = { x , y } ↔ ∃ z ∀ w ( w ∈ z ↔ ( w = x ∨ w = y ) ) ) ;;
	step 10 : wff = mpbir (step 2, step 9) |- ∃ z z = { x , y } ;;
	step 11 : wff = issetri (step 10) |- { x , y } ∈ _V ;;
	qed prop 1 = step 11 ;;
}

/* A singleton is a set.  Theorem 7.13 of [Quine] p. 51, proved using
       Extensionality, Separation, and Pairing.  See also ~ snexALT .
       (Contributed by NM, 7-Aug-1994.)  (Revised by Mario Carneiro,
       19-May-2013.)  (Proof modification is discouraged.) */

theorem snex (A : class) disjointed(x A) {
	prop 1 : wff = |- { A } ∈ _V ;;
}

proof of snex {
	var x : set;;
	step 1 : wff = dfsn2 () |- { A } = { A , A } ;;
	step 2 : wff = preq12 () |- ( ( x = A ∧ x = A ) → { x , x } = { A , A } ) ;;
	step 3 : wff = anidms (step 2) |- ( x = A → { x , x } = { A , A } ) ;;
	step 4 : wff = eleq1d (step 3) |- ( x = A → ( { x , x } ∈ _V ↔ { A , A } ∈ _V ) ) ;;
	step 5 : wff = zfpair2 () |- { x , x } ∈ _V ;;
	step 6 : wff = vtoclg (step 4, step 5) |- ( A ∈ _V → { A , A } ∈ _V ) ;;
	step 7 : wff = syl5eqel (step 1, step 6) |- ( A ∈ _V → { A } ∈ _V ) ;;
	step 8 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 9 : wff = biimpi (step 8) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 10 : wff = 0ex () |- ∅ ∈ _V ;;
	step 11 : wff = syl6eqel (step 9, step 10) |- ( ¬ A ∈ _V → { A } ∈ _V ) ;;
	step 12 : wff = pm2.61i (step 7, step 11) |- { A } ∈ _V ;;
	qed prop 1 = step 12 ;;
}

/* The Axiom of Pairing using class variables.  Theorem 7.13 of [Quine]
       p. 51.  By virtue of its definition, an unordered pair remains a set
       (even though no longer a pair) even when its components are proper
       classes (see ~ prprc ), so we can dispense with hypotheses requiring
       them to be sets.  (Contributed by NM, 5-Aug-1993.) */

theorem prex (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- { A , B } ∈ _V ;;
}

proof of prex {
	var x : set, y : set;;
	step 1 : wff = preq2 () |- ( y = B → { x , y } = { x , B } ) ;;
	step 2 : wff = eleq1d (step 1) |- ( y = B → ( { x , y } ∈ _V ↔ { x , B } ∈ _V ) ) ;;
	step 3 : wff = zfpair2 () |- { x , y } ∈ _V ;;
	step 4 : wff = vtoclg (step 2, step 3) |- ( B ∈ _V → { x , B } ∈ _V ) ;;
	step 5 : wff = preq1 () |- ( x = A → { x , B } = { A , B } ) ;;
	step 6 : wff = eleq1d (step 5) |- ( x = A → ( { x , B } ∈ _V ↔ { A , B } ∈ _V ) ) ;;
	step 7 : wff = syl5ib (step 4, step 6) |- ( x = A → ( B ∈ _V → { A , B } ∈ _V ) ) ;;
	step 8 : wff = vtocleg (step 7) |- ( A ∈ _V → ( B ∈ _V → { A , B } ∈ _V ) ) ;;
	step 9 : wff = prprc1 () |- ( ¬ A ∈ _V → { A , B } = { B } ) ;;
	step 10 : wff = snex () |- { B } ∈ _V ;;
	step 11 : wff = syl6eqel (step 9, step 10) |- ( ¬ A ∈ _V → { A , B } ∈ _V ) ;;
	step 12 : wff = prprc2 () |- ( ¬ B ∈ _V → { A , B } = { A } ) ;;
	step 13 : wff = snex () |- { A } ∈ _V ;;
	step 14 : wff = syl6eqel (step 12, step 13) |- ( ¬ B ∈ _V → { A , B } ∈ _V ) ;;
	step 15 : wff = pm2.61nii (step 8, step 11, step 14) |- { A , B } ∈ _V ;;
	qed prop 1 = step 15 ;;
}

/* Every set is an element of some other set.  This has a shorter proof
       than ~ el but uses more axioms.  (Contributed by NM, 4-Jan-2002.)
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem elALT (x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ∃ y x ∈ y ;;
}

proof of elALT {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = snid (step 1) |- x ∈ { x } ;;
	step 3 : wff = snex () |- { x } ∈ _V ;;
	step 4 : wff = eleq2 () |- ( y = { x } → ( x ∈ y ↔ x ∈ { x } ) ) ;;
	step 5 : wff = spcev (step 3, step 4) |- ( x ∈ { x } → ∃ y x ∈ y ) ;;
	step 6 : wff = ax-mp (step 2, step 5) |- ∃ y x ∈ y ;;
	qed prop 1 = step 6 ;;
}

/* An alternative proof of ~ dtru ("two things exist") using ~ ax-pr
       instead of ~ ax-pow .  (Contributed by Mario Carneiro, 31-Aug-2015.)
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem dtruALT2 (x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ¬ ∀ x x = y ;;
}

proof of dtruALT2 {
	step 1 : wff = 0inp0 () |- ( y = ∅ → ¬ y = { ∅ } ) ;;
	step 2 : wff = snex () |- { ∅ } ∈ _V ;;
	step 3 : wff = eqeq2 () |- ( x = { ∅ } → ( y = x ↔ y = { ∅ } ) ) ;;
	step 4 : wff = notbid (step 3) |- ( x = { ∅ } → ( ¬ y = x ↔ ¬ y = { ∅ } ) ) ;;
	step 5 : wff = spcev (step 2, step 4) |- ( ¬ y = { ∅ } → ∃ x ¬ y = x ) ;;
	step 6 : wff = syl (step 1, step 5) |- ( y = ∅ → ∃ x ¬ y = x ) ;;
	step 7 : wff = 0ex () |- ∅ ∈ _V ;;
	step 8 : wff = eqeq2 () |- ( x = ∅ → ( y = x ↔ y = ∅ ) ) ;;
	step 9 : wff = notbid (step 8) |- ( x = ∅ → ( ¬ y = x ↔ ¬ y = ∅ ) ) ;;
	step 10 : wff = spcev (step 7, step 9) |- ( ¬ y = ∅ → ∃ x ¬ y = x ) ;;
	step 11 : wff = pm2.61i (step 6, step 10) |- ∃ x ¬ y = x ;;
	step 12 : wff = exnal () |- ( ∃ x ¬ y = x ↔ ¬ ∀ x y = x ) ;;
	step 13 : wff = eqcom () |- ( y = x ↔ x = y ) ;;
	step 14 : wff = albii (step 13) |- ( ∀ x y = x ↔ ∀ x x = y ) ;;
	step 15 : wff = xchbinx (step 12, step 14) |- ( ∃ x ¬ y = x ↔ ¬ ∀ x x = y ) ;;
	step 16 : wff = mpbi (step 11, step 15) |- ¬ ∀ x x = y ;;
	qed prop 1 = step 16 ;;
}

/* A singleton of a set belongs to the power class of a class containing
       the set.  (Contributed by Alan Sare, 25-Aug-2011.) */

theorem snelpwi (A : class, B : class)  {
	prop 1 : wff = |- ( A ∈ B → { A } ∈ Pow B ) ;;
}

proof of snelpwi {
	step 1 : wff = snssi () |- ( A ∈ B → { A } ⊆ B ) ;;
	step 2 : wff = snex () |- { A } ∈ _V ;;
	step 3 : wff = elpw (step 2) |- ( { A } ∈ Pow B ↔ { A } ⊆ B ) ;;
	step 4 : wff = sylibr (step 1, step 3) |- ( A ∈ B → { A } ∈ Pow B ) ;;
	qed prop 1 = step 4 ;;
}

/* A singleton of a set belongs to the power class of a class containing
       the set.  (Contributed by NM, 1-Apr-1998.) */

theorem snelpw (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B ↔ { A } ∈ Pow B ) ;;
}

proof of snelpw {
	step 1 : wff = snss (hyp 1) |- ( A ∈ B ↔ { A } ⊆ B ) ;;
	step 2 : wff = snex () |- { A } ∈ _V ;;
	step 3 : wff = elpw (step 2) |- ( { A } ∈ Pow B ↔ { A } ⊆ B ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( A ∈ B ↔ { A } ∈ Pow B ) ;;
	qed prop 1 = step 4 ;;
}

/* A theorem similar to extensionality, requiring the existence of a
       singleton.  Exercise 8 of [TakeutiZaring] p. 16.  (Contributed by NM,
       10-Aug-1993.) */

theorem rext (x : set, y : set, z : set) disjointed(x y z) {
	prop 1 : wff = |- ( ∀ z ( x ∈ z → y ∈ z ) → x = y ) ;;
}

proof of rext {
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = snid (step 1) |- x ∈ { x } ;;
	step 3 : wff = snex () |- { x } ∈ _V ;;
	step 4 : wff = eleq2 () |- ( z = { x } → ( x ∈ z ↔ x ∈ { x } ) ) ;;
	step 5 : wff = eleq2 () |- ( z = { x } → ( y ∈ z ↔ y ∈ { x } ) ) ;;
	step 6 : wff = imbi12d (step 4, step 5) |- ( z = { x } → ( ( x ∈ z → y ∈ z ) ↔ ( x ∈ { x } → y ∈ { x } ) ) ) ;;
	step 7 : wff = spcv (step 3, step 6) |- ( ∀ z ( x ∈ z → y ∈ z ) → ( x ∈ { x } → y ∈ { x } ) ) ;;
	step 8 : wff = mpi (step 2, step 7) |- ( ∀ z ( x ∈ z → y ∈ z ) → y ∈ { x } ) ;;
	step 9 : wff = elsn () |- ( y ∈ { x } ↔ y = x ) ;;
	step 10 : wff = equcomi () |- ( y = x → x = y ) ;;
	step 11 : wff = sylbi (step 9, step 10) |- ( y ∈ { x } → x = y ) ;;
	step 12 : wff = syl (step 8, step 11) |- ( ∀ z ( x ∈ z → y ∈ z ) → x = y ) ;;
	qed prop 1 = step 12 ;;
}

/* Classes are subclasses if and only if their power classes are
       subclasses.  Exercise 18 of [TakeutiZaring] p. 18.  (Contributed by NM,
       13-Oct-1996.) */

theorem sspwb (A : class, B : class) disjointed(A x, B x) {
	prop 1 : wff = |- ( A ⊆ B ↔ Pow A ⊆ Pow B ) ;;
}

proof of sspwb {
	var x : set;;
	step 1 : wff = sstr2 () |- ( x ⊆ A → ( A ⊆ B → x ⊆ B ) ) ;;
	step 2 : wff = com12 (step 1) |- ( A ⊆ B → ( x ⊆ A → x ⊆ B ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = elpw (step 3) |- ( x ∈ Pow A ↔ x ⊆ A ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = elpw (step 5) |- ( x ∈ Pow B ↔ x ⊆ B ) ;;
	step 7 : wff = 3imtr4g (step 2, step 4, step 6) |- ( A ⊆ B → ( x ∈ Pow A → x ∈ Pow B ) ) ;;
	step 8 : wff = ssrdv (step 7) |- ( A ⊆ B → Pow A ⊆ Pow B ) ;;
	step 9 : wff = ssel () |- ( Pow A ⊆ Pow B → ( { x } ∈ Pow A → { x } ∈ Pow B ) ) ;;
	step 10 : wff = snex () |- { x } ∈ _V ;;
	step 11 : wff = elpw (step 10) |- ( { x } ∈ Pow A ↔ { x } ⊆ A ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = snss (step 12) |- ( x ∈ A ↔ { x } ⊆ A ) ;;
	step 14 : wff = bitr4i (step 11, step 13) |- ( { x } ∈ Pow A ↔ x ∈ A ) ;;
	step 15 : wff = snex () |- { x } ∈ _V ;;
	step 16 : wff = elpw (step 15) |- ( { x } ∈ Pow B ↔ { x } ⊆ B ) ;;
	step 17 : wff = vex () |- x ∈ _V ;;
	step 18 : wff = snss (step 17) |- ( x ∈ B ↔ { x } ⊆ B ) ;;
	step 19 : wff = bitr4i (step 16, step 18) |- ( { x } ∈ Pow B ↔ x ∈ B ) ;;
	step 20 : wff = 3imtr3g (step 9, step 14, step 19) |- ( Pow A ⊆ Pow B → ( x ∈ A → x ∈ B ) ) ;;
	step 21 : wff = ssrdv (step 20) |- ( Pow A ⊆ Pow B → A ⊆ B ) ;;
	step 22 : wff = impbii (step 8, step 21) |- ( A ⊆ B ↔ Pow A ⊆ Pow B ) ;;
	qed prop 1 = step 22 ;;
}

/* A class equals the union of its power class.  Exercise 6(a) of
       [Enderton] p. 38.  (Contributed by NM, 14-Oct-1996.)  (Proof shortened
       by Alan Sare, 28-Dec-2008.) */

theorem unipw (A : class) disjointed(A x y) {
	prop 1 : wff = |- ⋃ Pow A = A ;;
}

proof of unipw {
	var x : set, y : set;;
	step 1 : wff = eluni () |- ( x ∈ ⋃ Pow A ↔ ∃ y ( x ∈ y ∧ y ∈ Pow A ) ) ;;
	step 2 : wff = elelpwi () |- ( ( x ∈ y ∧ y ∈ Pow A ) → x ∈ A ) ;;
	step 3 : wff = exlimiv (step 2) |- ( ∃ y ( x ∈ y ∧ y ∈ Pow A ) → x ∈ A ) ;;
	step 4 : wff = sylbi (step 1, step 3) |- ( x ∈ ⋃ Pow A → x ∈ A ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = snid (step 5) |- x ∈ { x } ;;
	step 7 : wff = snelpwi () |- ( x ∈ A → { x } ∈ Pow A ) ;;
	step 8 : wff = elunii () |- ( ( x ∈ { x } ∧ { x } ∈ Pow A ) → x ∈ ⋃ Pow A ) ;;
	step 9 : wff = sylancr (step 6, step 7, step 8) |- ( x ∈ A → x ∈ ⋃ Pow A ) ;;
	step 10 : wff = impbii (step 4, step 9) |- ( x ∈ ⋃ Pow A ↔ x ∈ A ) ;;
	step 11 : wff = eqriv (step 10) |- ⋃ Pow A = A ;;
	qed prop 1 = step 11 ;;
}

/* Membership of a power class.  Exercise 10 of [Enderton] p. 26.
     (Contributed by NM, 13-Jan-2007.) */

theorem pwel (A : class, B : class)  {
	prop 1 : wff = |- ( A ∈ B → Pow A ∈ Pow Pow ⋃ B ) ;;
}

proof of pwel {
	step 1 : wff = elssuni () |- ( A ∈ B → A ⊆ ⋃ B ) ;;
	step 2 : wff = sspwb () |- ( A ⊆ ⋃ B ↔ Pow A ⊆ Pow ⋃ B ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( A ∈ B → Pow A ⊆ Pow ⋃ B ) ;;
	step 4 : wff = pwexg () |- ( A ∈ B → Pow A ∈ _V ) ;;
	step 5 : wff = elpwg () |- ( Pow A ∈ _V → ( Pow A ∈ Pow Pow ⋃ B ↔ Pow A ⊆ Pow ⋃ B ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A ∈ B → ( Pow A ∈ Pow Pow ⋃ B ↔ Pow A ⊆ Pow ⋃ B ) ) ;;
	step 7 : wff = mpbird (step 3, step 6) |- ( A ∈ B → Pow A ∈ Pow Pow ⋃ B ) ;;
	qed prop 1 = step 7 ;;
}

/* A class is transitive iff its power class is transitive.  (Contributed by
     Alan Sare, 25-Aug-2011.)  (Revised by Mario Carneiro, 15-Jun-2014.) */

theorem pwtr (A : class)  {
	prop 1 : wff = |- ( Tr A ↔ Tr Pow A ) ;;
}

proof of pwtr {
	step 1 : wff = unipw () |- ⋃ Pow A = A ;;
	step 2 : wff = sseq1i (step 1) |- ( ⋃ Pow A ⊆ Pow A ↔ A ⊆ Pow A ) ;;
	step 3 : wff = df-tr () |- ( Tr Pow A ↔ ⋃ Pow A ⊆ Pow A ) ;;
	step 4 : wff = dftr4 () |- ( Tr A ↔ A ⊆ Pow A ) ;;
	step 5 : wff = 3bitr4ri (step 2, step 3, step 4) |- ( Tr A ↔ Tr Pow A ) ;;
	qed prop 1 = step 5 ;;
}

/* An extensionality-like principle defining subclass in terms of subsets.
       (Contributed by NM, 30-Jun-2004.) */

theorem ssextss (x : set, A : class, B : class) disjointed(A x, B x) {
	prop 1 : wff = |- ( A ⊆ B ↔ ∀ x ( x ⊆ A → x ⊆ B ) ) ;;
}

proof of ssextss {
	step 1 : wff = sspwb () |- ( A ⊆ B ↔ Pow A ⊆ Pow B ) ;;
	step 2 : wff = dfss2 () |- ( Pow A ⊆ Pow B ↔ ∀ x ( x ∈ Pow A → x ∈ Pow B ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = elpw (step 3) |- ( x ∈ Pow A ↔ x ⊆ A ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = elpw (step 5) |- ( x ∈ Pow B ↔ x ⊆ B ) ;;
	step 7 : wff = imbi12i (step 4, step 6) |- ( ( x ∈ Pow A → x ∈ Pow B ) ↔ ( x ⊆ A → x ⊆ B ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ( x ∈ Pow A → x ∈ Pow B ) ↔ ∀ x ( x ⊆ A → x ⊆ B ) ) ;;
	step 9 : wff = 3bitri (step 1, step 2, step 8) |- ( A ⊆ B ↔ ∀ x ( x ⊆ A → x ⊆ B ) ) ;;
	qed prop 1 = step 9 ;;
}

/* An extensionality-like principle that uses the subset instead of the
       membership relation: two classes are equal iff they have the same
       subsets.  (Contributed by NM, 30-Jun-2004.) */

theorem ssext (x : set, A : class, B : class) disjointed(A x, B x) {
	prop 1 : wff = |- ( A = B ↔ ∀ x ( x ⊆ A ↔ x ⊆ B ) ) ;;
}

proof of ssext {
	step 1 : wff = ssextss () |- ( A ⊆ B ↔ ∀ x ( x ⊆ A → x ⊆ B ) ) ;;
	step 2 : wff = ssextss () |- ( B ⊆ A ↔ ∀ x ( x ⊆ B → x ⊆ A ) ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) ↔ ( ∀ x ( x ⊆ A → x ⊆ B ) ∧ ∀ x ( x ⊆ B → x ⊆ A ) ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = albiim () |- ( ∀ x ( x ⊆ A ↔ x ⊆ B ) ↔ ( ∀ x ( x ⊆ A → x ⊆ B ) ∧ ∀ x ( x ⊆ B → x ⊆ A ) ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( A = B ↔ ∀ x ( x ⊆ A ↔ x ⊆ B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Negation of subclass relationship.  Compare ~ nss .  (Contributed by NM,
       30-Jun-2004.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem nssss (x : set, A : class, B : class) disjointed(A x, B x) {
	prop 1 : wff = |- ( ¬ A ⊆ B ↔ ∃ x ( x ⊆ A ∧ ¬ x ⊆ B ) ) ;;
}

proof of nssss {
	step 1 : wff = exanali () |- ( ∃ x ( x ⊆ A ∧ ¬ x ⊆ B ) ↔ ¬ ∀ x ( x ⊆ A → x ⊆ B ) ) ;;
	step 2 : wff = ssextss () |- ( A ⊆ B ↔ ∀ x ( x ⊆ A → x ⊆ B ) ) ;;
	step 3 : wff = xchbinxr (step 1, step 2) |- ( ∃ x ( x ⊆ A ∧ ¬ x ⊆ B ) ↔ ¬ A ⊆ B ) ;;
	step 4 : wff = bicomi (step 3) |- ( ¬ A ⊆ B ↔ ∃ x ( x ⊆ A ∧ ¬ x ⊆ B ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Classes are equal if and only if their power classes are equal.  Exercise
     19 of [TakeutiZaring] p. 18.  (Contributed by NM, 13-Oct-1996.) */

theorem pweqb (A : class, B : class)  {
	prop 1 : wff = |- ( A = B ↔ Pow A = Pow B ) ;;
}

proof of pweqb {
	step 1 : wff = sspwb () |- ( A ⊆ B ↔ Pow A ⊆ Pow B ) ;;
	step 2 : wff = sspwb () |- ( B ⊆ A ↔ Pow B ⊆ Pow A ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) ↔ ( Pow A ⊆ Pow B ∧ Pow B ⊆ Pow A ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = eqss () |- ( Pow A = Pow B ↔ ( Pow A ⊆ Pow B ∧ Pow B ⊆ Pow A ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( A = B ↔ Pow A = Pow B ) ;;
	qed prop 1 = step 6 ;;
}

/* The intersection of all sets to which a set belongs is the singleton of
       that set.  (Contributed by NM, 5-Jun-2009.) */

theorem intid (x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ { x | A ∈ x } = { A } ;;
}

proof of intid {
	step 1 : wff = snex () |- { A } ∈ _V ;;
	step 2 : wff = eleq2 () |- ( x = { A } → ( A ∈ x ↔ A ∈ { A } ) ) ;;
	step 3 : wff = snid (hyp 1) |- A ∈ { A } ;;
	step 4 : wff = intmin3 (step 2, step 3) |- ( { A } ∈ _V → ⋂ { x | A ∈ x } ⊆ { A } ) ;;
	step 5 : wff = ax-mp (step 1, step 4) |- ⋂ { x | A ∈ x } ⊆ { A } ;;
	step 6 : wff = elintab (hyp 1) |- ( A ∈ ⋂ { x | A ∈ x } ↔ ∀ x ( A ∈ x → A ∈ x ) ) ;;
	step 7 : wff = id () |- ( A ∈ x → A ∈ x ) ;;
	step 8 : wff = mpgbir (step 6, step 7) |- A ∈ ⋂ { x | A ∈ x } ;;
	step 9 : wff = snssi () |- ( A ∈ ⋂ { x | A ∈ x } → { A } ⊆ ⋂ { x | A ∈ x } ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- { A } ⊆ ⋂ { x | A ∈ x } ;;
	step 11 : wff = eqssi (step 5, step 10) |- ⋂ { x | A ∈ x } = { A } ;;
	qed prop 1 = step 11 ;;
}

/* "At most one" existence implies a class abstraction exists.
       (Contributed by NM, 30-Dec-1996.) */

theorem moabex (ph : wff, x : set) disjointed(x y, y ph) {
	prop 1 : wff = |- ( ∃* x ph → { x | ph } ∈ _V ) ;;
}

proof of moabex {
	var y : set;;
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = mo2 (step 1) |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 3 : wff = abss () |- ( { x | ph } ⊆ { y } ↔ ∀ x ( ph → x ∈ { y } ) ) ;;
	step 4 : wff = elsn () |- ( x ∈ { y } ↔ x = y ) ;;
	step 5 : wff = imbi2i (step 4) |- ( ( ph → x ∈ { y } ) ↔ ( ph → x = y ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ x ( ph → x ∈ { y } ) ↔ ∀ x ( ph → x = y ) ) ;;
	step 7 : wff = bitri (step 3, step 6) |- ( { x | ph } ⊆ { y } ↔ ∀ x ( ph → x = y ) ) ;;
	step 8 : wff = snex () |- { y } ∈ _V ;;
	step 9 : wff = ssex (step 8) |- ( { x | ph } ⊆ { y } → { x | ph } ∈ _V ) ;;
	step 10 : wff = sylbir (step 7, step 9) |- ( ∀ x ( ph → x = y ) → { x | ph } ∈ _V ) ;;
	step 11 : wff = exlimiv (step 10) |- ( ∃ y ∀ x ( ph → x = y ) → { x | ph } ∈ _V ) ;;
	step 12 : wff = sylbi (step 2, step 11) |- ( ∃* x ph → { x | ph } ∈ _V ) ;;
	qed prop 1 = step 12 ;;
}

/* Restricted "at most one" existence implies a restricted class abstraction
     exists.  (Contributed by NM, 17-Jun-2017.) */

theorem rmorabex (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃* x ∈ A ph → { x ∈ A | ph } ∈ _V ) ;;
}

proof of rmorabex {
	step 1 : wff = moabex () |- ( ∃* x ( x ∈ A ∧ ph ) → { x | ( x ∈ A ∧ ph ) } ∈ _V ) ;;
	step 2 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 4 : wff = eleq1i (step 3) |- ( { x ∈ A | ph } ∈ _V ↔ { x | ( x ∈ A ∧ ph ) } ∈ _V ) ;;
	step 5 : wff = 3imtr4i (step 1, step 2, step 4) |- ( ∃* x ∈ A ph → { x ∈ A | ph } ∈ _V ) ;;
	qed prop 1 = step 5 ;;
}

/* The abstraction of a wff with existential uniqueness exists.  (Contributed
     by NM, 25-Nov-1994.) */

theorem euabex (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃! x ph → { x | ph } ∈ _V ) ;;
}

proof of euabex {
	step 1 : wff = eumo () |- ( ∃! x ph → ∃* x ph ) ;;
	step 2 : wff = moabex () |- ( ∃* x ph → { x | ph } ∈ _V ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ∃! x ph → { x | ph } ∈ _V ) ;;
	qed prop 1 = step 3 ;;
}

/* A non-empty class (even if proper) has a non-empty subset.  (Contributed
       by NM, 23-Aug-2003.) */

theorem nnullss (x : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ≠ ∅ → ∃ x ( x ⊆ A ∧ x ≠ ∅ ) ) ;;
}

proof of nnullss {
	var y : set;;
	step 1 : wff = n0 () |- ( A ≠ ∅ ↔ ∃ y y ∈ A ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = snss (step 2) |- ( y ∈ A ↔ { y } ⊆ A ) ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = snnz (step 4) |- { y } ≠ ∅ ;;
	step 6 : wff = snex () |- { y } ∈ _V ;;
	step 7 : wff = sseq1 () |- ( x = { y } → ( x ⊆ A ↔ { y } ⊆ A ) ) ;;
	step 8 : wff = neeq1 () |- ( x = { y } → ( x ≠ ∅ ↔ { y } ≠ ∅ ) ) ;;
	step 9 : wff = anbi12d (step 7, step 8) |- ( x = { y } → ( ( x ⊆ A ∧ x ≠ ∅ ) ↔ ( { y } ⊆ A ∧ { y } ≠ ∅ ) ) ) ;;
	step 10 : wff = spcev (step 6, step 9) |- ( ( { y } ⊆ A ∧ { y } ≠ ∅ ) → ∃ x ( x ⊆ A ∧ x ≠ ∅ ) ) ;;
	step 11 : wff = mpan2 (step 5, step 10) |- ( { y } ⊆ A → ∃ x ( x ⊆ A ∧ x ≠ ∅ ) ) ;;
	step 12 : wff = sylbi (step 3, step 11) |- ( y ∈ A → ∃ x ( x ⊆ A ∧ x ≠ ∅ ) ) ;;
	step 13 : wff = exlimiv (step 12) |- ( ∃ y y ∈ A → ∃ x ( x ⊆ A ∧ x ≠ ∅ ) ) ;;
	step 14 : wff = sylbi (step 1, step 13) |- ( A ≠ ∅ → ∃ x ( x ⊆ A ∧ x ≠ ∅ ) ) ;;
	qed prop 1 = step 14 ;;
}

/* Restricted existence in a class (even if proper) implies restricted
       existence in a subset.  (Contributed by NM, 23-Aug-2003.) */

theorem exss (ph : wff, x : set, y : set, A : class) disjointed(x y z A, y z ph) {
	prop 1 : wff = |- ( ∃ x ∈ A ph → ∃ y ( y ⊆ A ∧ ∃ x ∈ y ph ) ) ;;
}

proof of exss {
	var z : set;;
	step 1 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 2 : wff = neeq1i (step 1) |- ( { x ∈ A | ph } ≠ ∅ ↔ { x | ( x ∈ A ∧ ph ) } ≠ ∅ ) ;;
	step 3 : wff = rabn0 () |- ( { x ∈ A | ph } ≠ ∅ ↔ ∃ x ∈ A ph ) ;;
	step 4 : wff = n0 () |- ( { x | ( x ∈ A ∧ ph ) } ≠ ∅ ↔ ∃ z z ∈ { x | ( x ∈ A ∧ ph ) } ) ;;
	step 5 : wff = 3bitr3i (step 2, step 3, step 4) |- ( ∃ x ∈ A ph ↔ ∃ z z ∈ { x | ( x ∈ A ∧ ph ) } ) ;;
	step 6 : wff = vex () |- z ∈ _V ;;
	step 7 : wff = snss (step 6) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } ↔ { z } ⊆ { x | ( x ∈ A ∧ ph ) } ) ;;
	step 8 : wff = ssab2 () |- { x | ( x ∈ A ∧ ph ) } ⊆ A ;;
	step 9 : wff = sstr2 () |- ( { z } ⊆ { x | ( x ∈ A ∧ ph ) } → ( { x | ( x ∈ A ∧ ph ) } ⊆ A → { z } ⊆ A ) ) ;;
	step 10 : wff = mpi (step 8, step 9) |- ( { z } ⊆ { x | ( x ∈ A ∧ ph ) } → { z } ⊆ A ) ;;
	step 11 : wff = sylbi (step 7, step 10) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } → { z } ⊆ A ) ;;
	step 12 : wff = simpr () |- ( ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) → [ z / x ] ph ) ;;
	step 13 : wff = equsb1 () |- [ z / x ] x = z ;;
	step 14 : wff = elsn () |- ( x ∈ { z } ↔ x = z ) ;;
	step 15 : wff = sbbii (step 14) |- ( [ z / x ] x ∈ { z } ↔ [ z / x ] x = z ) ;;
	step 16 : wff = mpbir (step 13, step 15) |- [ z / x ] x ∈ { z } ;;
	step 17 : wff = jctil (step 12, step 16) |- ( ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) → ( [ z / x ] x ∈ { z } ∧ [ z / x ] ph ) ) ;;
	step 18 : wff = df-clab () |- ( z ∈ { x | ( x ∈ A ∧ ph ) } ↔ [ z / x ] ( x ∈ A ∧ ph ) ) ;;
	step 19 : wff = sban () |- ( [ z / x ] ( x ∈ A ∧ ph ) ↔ ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ) ;;
	step 20 : wff = bitri (step 18, step 19) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } ↔ ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ) ;;
	step 21 : wff = df-rab () |- { x ∈ { z } | ph } = { x | ( x ∈ { z } ∧ ph ) } ;;
	step 22 : wff = eleq2i (step 21) |- ( z ∈ { x ∈ { z } | ph } ↔ z ∈ { x | ( x ∈ { z } ∧ ph ) } ) ;;
	step 23 : wff = df-clab () |- ( z ∈ { x | ( x ∈ { z } ∧ ph ) } ↔ [ z / x ] ( x ∈ { z } ∧ ph ) ) ;;
	step 24 : wff = sban () |- ( [ z / x ] ( x ∈ { z } ∧ ph ) ↔ ( [ z / x ] x ∈ { z } ∧ [ z / x ] ph ) ) ;;
	step 25 : wff = bitri (step 23, step 24) |- ( z ∈ { x | ( x ∈ { z } ∧ ph ) } ↔ ( [ z / x ] x ∈ { z } ∧ [ z / x ] ph ) ) ;;
	step 26 : wff = bitri (step 22, step 25) |- ( z ∈ { x ∈ { z } | ph } ↔ ( [ z / x ] x ∈ { z } ∧ [ z / x ] ph ) ) ;;
	step 27 : wff = 3imtr4i (step 17, step 20, step 26) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } → z ∈ { x ∈ { z } | ph } ) ;;
	step 28 : wff = ne0i () |- ( z ∈ { x ∈ { z } | ph } → { x ∈ { z } | ph } ≠ ∅ ) ;;
	step 29 : wff = syl (step 27, step 28) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } → { x ∈ { z } | ph } ≠ ∅ ) ;;
	step 30 : wff = rabn0 () |- ( { x ∈ { z } | ph } ≠ ∅ ↔ ∃ x ∈ { z } ph ) ;;
	step 31 : wff = sylib (step 29, step 30) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } → ∃ x ∈ { z } ph ) ;;
	step 32 : wff = snex () |- { z } ∈ _V ;;
	step 33 : wff = sseq1 () |- ( y = { z } → ( y ⊆ A ↔ { z } ⊆ A ) ) ;;
	step 34 : wff = rexeq () |- ( y = { z } → ( ∃ x ∈ y ph ↔ ∃ x ∈ { z } ph ) ) ;;
	step 35 : wff = anbi12d (step 33, step 34) |- ( y = { z } → ( ( y ⊆ A ∧ ∃ x ∈ y ph ) ↔ ( { z } ⊆ A ∧ ∃ x ∈ { z } ph ) ) ) ;;
	step 36 : wff = spcev (step 32, step 35) |- ( ( { z } ⊆ A ∧ ∃ x ∈ { z } ph ) → ∃ y ( y ⊆ A ∧ ∃ x ∈ y ph ) ) ;;
	step 37 : wff = syl2anc (step 11, step 31, step 36) |- ( z ∈ { x | ( x ∈ A ∧ ph ) } → ∃ y ( y ⊆ A ∧ ∃ x ∈ y ph ) ) ;;
	step 38 : wff = exlimiv (step 37) |- ( ∃ z z ∈ { x | ( x ∈ A ∧ ph ) } → ∃ y ( y ⊆ A ∧ ∃ x ∈ y ph ) ) ;;
	step 39 : wff = sylbi (step 5, step 38) |- ( ∃ x ∈ A ph → ∃ y ( y ⊆ A ∧ ∃ x ∈ y ph ) ) ;;
	qed prop 1 = step 39 ;;
}

/* An ordered pair of classes is a set.  Exercise 7 of [TakeutiZaring]
     p. 16.  (Contributed by NM, 18-Aug-1993.)  (Revised by Mario Carneiro,
     26-Apr-2015.) */

theorem opex (A : class, B : class)  {
	prop 1 : wff = |- 〈 A , B 〉 ∈ _V ;;
}

proof of opex {
	step 1 : wff = dfopif () |- 〈 A , B 〉 = if ( ( A ∈ _V ∧ B ∈ _V ) , { { A } , { A , B } } , ∅ ) ;;
	step 2 : wff = prex () |- { { A } , { A , B } } ∈ _V ;;
	step 3 : wff = 0ex () |- ∅ ∈ _V ;;
	step 4 : wff = ifex (step 2, step 3) |- if ( ( A ∈ _V ∧ B ∈ _V ) , { { A } , { A , B } } , ∅ ) ∈ _V ;;
	step 5 : wff = eqeltri (step 1, step 4) |- 〈 A , B 〉 ∈ _V ;;
	qed prop 1 = step 5 ;;
}

/* An ordered triple of classes is a set.  (Contributed by NM,
     3-Apr-2015.) */

theorem otex (A : class, B : class, C : class)  {
	prop 1 : wff = |- 〈 A , B , C 〉 ∈ _V ;;
}

proof of otex {
	step 1 : wff = df-ot () |- 〈 A , B , C 〉 = 〈 〈 A , B 〉 , C 〉 ;;
	step 2 : wff = opex () |- 〈 〈 A , B 〉 , C 〉 ∈ _V ;;
	step 3 : wff = eqeltri (step 1, step 2) |- 〈 A , B , C 〉 ∈ _V ;;
	qed prop 1 = step 3 ;;
}

/* An ordered pair has two elements.  Exercise 3 of [TakeutiZaring] p. 15.
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       26-Apr-2015.) */

theorem elop (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ 〈 B , C 〉 ↔ ( A = { B } ∨ A = { B , C } ) ) ;;
}

proof of elop {
	step 1 : wff = dfop (hyp 2, hyp 3) |- 〈 B , C 〉 = { { B } , { B , C } } ;;
	step 2 : wff = eleq2i (step 1) |- ( A ∈ 〈 B , C 〉 ↔ A ∈ { { B } , { B , C } } ) ;;
	step 3 : wff = elpr (hyp 1) |- ( A ∈ { { B } , { B , C } } ↔ ( A = { B } ∨ A = { B , C } ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( A ∈ 〈 B , C 〉 ↔ ( A = { B } ∨ A = { B , C } ) ) ;;
	qed prop 1 = step 4 ;;
}

/* One of the two elements in an ordered pair.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem opi1 (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { A } ∈ 〈 A , B 〉 ;;
}

proof of opi1 {
	step 1 : wff = snex () |- { A } ∈ _V ;;
	step 2 : wff = prid1 (step 1) |- { A } ∈ { { A } , { A , B } } ;;
	step 3 : wff = dfop (hyp 1, hyp 2) |- 〈 A , B 〉 = { { A } , { A , B } } ;;
	step 4 : wff = eleqtrri (step 2, step 3) |- { A } ∈ 〈 A , B 〉 ;;
	qed prop 1 = step 4 ;;
}

/* One of the two elements of an ordered pair.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Mario Carneiro, 26-Apr-2015.) */

theorem opi2 (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- { A , B } ∈ 〈 A , B 〉 ;;
}

proof of opi2 {
	step 1 : wff = prex () |- { A , B } ∈ _V ;;
	step 2 : wff = prid2 (step 1) |- { A , B } ∈ { { A } , { A , B } } ;;
	step 3 : wff = dfop (hyp 1, hyp 2) |- 〈 A , B 〉 = { { A } , { A , B } } ;;
	step 4 : wff = eleqtrri (step 2, step 3) |- { A , B } ∈ 〈 A , B 〉 ;;
	qed prop 1 = step 4 ;;
}


