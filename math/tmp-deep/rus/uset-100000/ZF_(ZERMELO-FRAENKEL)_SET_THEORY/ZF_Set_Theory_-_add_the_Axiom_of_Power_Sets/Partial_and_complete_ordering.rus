import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Power_Sets/Epsilon_and_identity_relations.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                  Partial and complete ordering

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*We have not yet defined relations ( ~ df-rel ), but here we introduce a
few related notions we will use to develop ordinals.  The class variable
` R ` is no different from other class variables, but it reminds us that
normally it represents what we will later call a "relation."
*/

/*Declare new constant symbols. */

constant {
	symbol Po ;;
}

/*Partial ordering predicate symbol (read: 'partial ordering'). */

constant {
	symbol Or ;;
}

/*Strict complete ordering predicate symbol (read: 'orders'). */

/*Extend wff notation to include the strict partial ordering predicate.
     Read:  ' ` R ` is a partial order on ` A ` .' */

rule wpo (A : class, R : class) {
	term : wff = # R Po A ;;
}

/*Extend wff notation to include the strict complete ordering predicate.
     Read:  ' ` R ` orders ` A ` .' */

rule wor (A : class, R : class) {
	term : wff = # R Or A ;;
}

/*Define the strict partial order predicate.  Definition of [Enderton]
       p. 168.  The expression ` R Po A ` means ` R ` is a partial order on
       ` A ` .  For example, ` < Po RR ` is true, while ` <_ Po RR ` is false
       ( ~ ex-po ).  (Contributed by NM, 16-Mar-1997.) */

definition df-po (x : set, y : set, z : set, A : class, R : class) disjointed(x y z R, x y z A) {
	defiendum : wff = # R Po A ;;
	definiens : wff = # ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define the strict complete (linear) order predicate.  The expression
       ` R Or A ` is true if relationship ` R ` orders ` A ` .  For example,
       ` < Or RR ` is true ( ~ ltso ).  Equivalent to Definition 6.19(1) of
       [TakeutiZaring] p. 29.  (Contributed by NM, 21-Jan-1996.) */

definition df-so (x : set, y : set, A : class, R : class) disjointed(x y R, x y A) {
	defiendum : wff = # R Or A ;;
	definiens : wff = # ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Subset theorem for the partial ordering predicate.  (Contributed by NM,
       27-Mar-1997.)  (Proof shortened by Mario Carneiro, 18-Nov-2016.) */

theorem poss (A : class, B : class, R : class) disjointed(x y z R, x y z A, x y z B) {
	prop 1 : wff = |- ( A ⊆ B → ( R Po B → R Po A ) ) ;;
}

proof of poss {
	var x : set, y : set, z : set;;
	step 1 : wff = ssralv () |- ( A ⊆ B → ( ∀ x ∈ B ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ x ∈ A ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 2 : wff = ssralv () |- ( A ⊆ B → ( ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ y ∈ A ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 3 : wff = ssralv () |- ( A ⊆ B → ( ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 4 : wff = ralimdv (step 3) |- ( A ⊆ B → ( ∀ y ∈ A ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 5 : wff = syld (step 2, step 4) |- ( A ⊆ B → ( ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 6 : wff = ralimdv (step 5) |- ( A ⊆ B → ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 7 : wff = syld (step 1, step 6) |- ( A ⊆ B → ( ∀ x ∈ B ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) → ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 8 : wff = df-po () |- ( R Po B ↔ ∀ x ∈ B ∀ y ∈ B ∀ z ∈ B ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 9 : wff = df-po () |- ( R Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 10 : wff = 3imtr4g (step 7, step 8, step 9) |- ( A ⊆ B → ( R Po B → R Po A ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Equality theorem for partial ordering predicate.  (Contributed by NM,
       27-Mar-1997.) */

theorem poeq1 (A : class, R : class, S : class) disjointed(x y z R, x y z S, x y z A) {
	prop 1 : wff = |- ( R = S → ( R Po A ↔ S Po A ) ) ;;
}

proof of poeq1 {
	var x : set, y : set, z : set;;
	step 1 : wff = breq () |- ( R = S → ( x R x ↔ x S x ) ) ;;
	step 2 : wff = notbid (step 1) |- ( R = S → ( ¬ x R x ↔ ¬ x S x ) ) ;;
	step 3 : wff = breq () |- ( R = S → ( x R y ↔ x S y ) ) ;;
	step 4 : wff = breq () |- ( R = S → ( y R z ↔ y S z ) ) ;;
	step 5 : wff = anbi12d (step 3, step 4) |- ( R = S → ( ( x R y ∧ y R z ) ↔ ( x S y ∧ y S z ) ) ) ;;
	step 6 : wff = breq () |- ( R = S → ( x R z ↔ x S z ) ) ;;
	step 7 : wff = imbi12d (step 5, step 6) |- ( R = S → ( ( ( x R y ∧ y R z ) → x R z ) ↔ ( ( x S y ∧ y S z ) → x S z ) ) ) ;;
	step 8 : wff = anbi12d (step 2, step 7) |- ( R = S → ( ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ¬ x S x ∧ ( ( x S y ∧ y S z ) → x S z ) ) ) ) ;;
	step 9 : wff = ralbidv (step 8) |- ( R = S → ( ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ z ∈ A ( ¬ x S x ∧ ( ( x S y ∧ y S z ) → x S z ) ) ) ) ;;
	step 10 : wff = 2ralbidv (step 9) |- ( R = S → ( ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x S x ∧ ( ( x S y ∧ y S z ) → x S z ) ) ) ) ;;
	step 11 : wff = df-po () |- ( R Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 12 : wff = df-po () |- ( S Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x S x ∧ ( ( x S y ∧ y S z ) → x S z ) ) ) ;;
	step 13 : wff = 3bitr4g (step 10, step 11, step 12) |- ( R = S → ( R Po A ↔ S Po A ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Equality theorem for partial ordering predicate.  (Contributed by NM,
     27-Mar-1997.) */

theorem poeq2 (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( A = B → ( R Po A ↔ R Po B ) ) ;;
}

proof of poeq2 {
	step 1 : wff = eqimss2 () |- ( A = B → B ⊆ A ) ;;
	step 2 : wff = poss () |- ( B ⊆ A → ( R Po A → R Po B ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A = B → ( R Po A → R Po B ) ) ;;
	step 4 : wff = eqimss () |- ( A = B → A ⊆ B ) ;;
	step 5 : wff = poss () |- ( A ⊆ B → ( R Po B → R Po A ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( A = B → ( R Po B → R Po A ) ) ;;
	step 7 : wff = impbid (step 3, step 6) |- ( A = B → ( R Po A ↔ R Po B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Bound-variable hypothesis builder for partial orders.  (Contributed by
       Stefan O'Rear, 20-Jan-2015.) */

theorem nfpo (x : set, A : class, R : class) disjointed(R a b c, A a b c, x a b c) {
	hyp 1 : wff = |- F/_ x R ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x R Po A ;;
}

proof of nfpo {
	var a : set, b : set, c : set;;
	step 1 : wff = df-po () |- ( R Po A ↔ ∀ a ∈ A ∀ b ∈ A ∀ c ∈ A ( ¬ a R a ∧ ( ( a R b ∧ b R c ) → a R c ) ) ) ;;
	step 2 : wff = nfcv () |- F/_ x a ;;
	step 3 : wff = nfcv () |- F/_ x a ;;
	step 4 : wff = nfbr (step 2, hyp 1, step 3) |- F/ x a R a ;;
	step 5 : wff = nfn (step 4) |- F/ x ¬ a R a ;;
	step 6 : wff = nfcv () |- F/_ x a ;;
	step 7 : wff = nfcv () |- F/_ x b ;;
	step 8 : wff = nfbr (step 6, hyp 1, step 7) |- F/ x a R b ;;
	step 9 : wff = nfcv () |- F/_ x b ;;
	step 10 : wff = nfcv () |- F/_ x c ;;
	step 11 : wff = nfbr (step 9, hyp 1, step 10) |- F/ x b R c ;;
	step 12 : wff = nfan (step 8, step 11) |- F/ x ( a R b ∧ b R c ) ;;
	step 13 : wff = nfcv () |- F/_ x a ;;
	step 14 : wff = nfcv () |- F/_ x c ;;
	step 15 : wff = nfbr (step 13, hyp 1, step 14) |- F/ x a R c ;;
	step 16 : wff = nfim (step 12, step 15) |- F/ x ( ( a R b ∧ b R c ) → a R c ) ;;
	step 17 : wff = nfan (step 5, step 16) |- F/ x ( ¬ a R a ∧ ( ( a R b ∧ b R c ) → a R c ) ) ;;
	step 18 : wff = nfral (hyp 2, step 17) |- F/ x ∀ c ∈ A ( ¬ a R a ∧ ( ( a R b ∧ b R c ) → a R c ) ) ;;
	step 19 : wff = nfral (hyp 2, step 18) |- F/ x ∀ b ∈ A ∀ c ∈ A ( ¬ a R a ∧ ( ( a R b ∧ b R c ) → a R c ) ) ;;
	step 20 : wff = nfral (hyp 2, step 19) |- F/ x ∀ a ∈ A ∀ b ∈ A ∀ c ∈ A ( ¬ a R a ∧ ( ( a R b ∧ b R c ) → a R c ) ) ;;
	step 21 : wff = nfxfr (step 1, step 20) |- F/ x R Po A ;;
	qed prop 1 = step 21 ;;
}

/*Bound-variable hypothesis builder for total orders.  (Contributed by
       Stefan O'Rear, 20-Jan-2015.) */

theorem nfso (x : set, A : class, R : class) disjointed(R a b, A a b, x a b) {
	hyp 1 : wff = |- F/_ x R ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x R Or A ;;
}

proof of nfso {
	var a : set, b : set;;
	step 1 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ a ∈ A ∀ b ∈ A ( a R b ∨ a = b ∨ b R a ) ) ) ;;
	step 2 : wff = nfpo (hyp 1, hyp 2) |- F/ x R Po A ;;
	step 3 : wff = nfcv () |- F/_ x a ;;
	step 4 : wff = nfcv () |- F/_ x b ;;
	step 5 : wff = nfbr (step 3, hyp 1, step 4) |- F/ x a R b ;;
	step 6 : wff = nfv () |- F/ x a = b ;;
	step 7 : wff = nfcv () |- F/_ x b ;;
	step 8 : wff = nfcv () |- F/_ x a ;;
	step 9 : wff = nfbr (step 7, hyp 1, step 8) |- F/ x b R a ;;
	step 10 : wff = nf3or (step 5, step 6, step 9) |- F/ x ( a R b ∨ a = b ∨ b R a ) ;;
	step 11 : wff = nfral (hyp 2, step 10) |- F/ x ∀ b ∈ A ( a R b ∨ a = b ∨ b R a ) ;;
	step 12 : wff = nfral (hyp 2, step 11) |- F/ x ∀ a ∈ A ∀ b ∈ A ( a R b ∨ a = b ∨ b R a ) ;;
	step 13 : wff = nfan (step 2, step 12) |- F/ x ( R Po A ∧ ∀ a ∈ A ∀ b ∈ A ( a R b ∨ a = b ∨ b R a ) ) ;;
	step 14 : wff = nfxfr (step 1, step 13) |- F/ x R Or A ;;
	qed prop 1 = step 14 ;;
}

/*Properties of partial order relation in class notation.  (Contributed by
       NM, 27-Mar-1997.) */

theorem pocl (A : class, B : class, C : class, D : class, R : class) disjointed(x y z R, x y z A, x y z B, x y z C, x y z D) {
	prop 1 : wff = |- ( R Po A → ( ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) → ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ) ;;
}

proof of pocl {
	var x : set, y : set, z : set;;
	step 1 : wff = id () |- ( x = B → x = B ) ;;
	step 2 : wff = id () |- ( x = B → x = B ) ;;
	step 3 : wff = breq12d (step 1, step 2) |- ( x = B → ( x R x ↔ B R B ) ) ;;
	step 4 : wff = notbid (step 3) |- ( x = B → ( ¬ x R x ↔ ¬ B R B ) ) ;;
	step 5 : wff = breq1 () |- ( x = B → ( x R y ↔ B R y ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( x = B → ( ( x R y ∧ y R z ) ↔ ( B R y ∧ y R z ) ) ) ;;
	step 7 : wff = breq1 () |- ( x = B → ( x R z ↔ B R z ) ) ;;
	step 8 : wff = imbi12d (step 6, step 7) |- ( x = B → ( ( ( x R y ∧ y R z ) → x R z ) ↔ ( ( B R y ∧ y R z ) → B R z ) ) ) ;;
	step 9 : wff = anbi12d (step 4, step 8) |- ( x = B → ( ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ( ¬ B R B ∧ ( ( B R y ∧ y R z ) → B R z ) ) ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( x = B → ( ( R Po A → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ↔ ( R Po A → ( ¬ B R B ∧ ( ( B R y ∧ y R z ) → B R z ) ) ) ) ) ;;
	step 11 : wff = breq2 () |- ( y = C → ( B R y ↔ B R C ) ) ;;
	step 12 : wff = breq1 () |- ( y = C → ( y R z ↔ C R z ) ) ;;
	step 13 : wff = anbi12d (step 11, step 12) |- ( y = C → ( ( B R y ∧ y R z ) ↔ ( B R C ∧ C R z ) ) ) ;;
	step 14 : wff = imbi1d (step 13) |- ( y = C → ( ( ( B R y ∧ y R z ) → B R z ) ↔ ( ( B R C ∧ C R z ) → B R z ) ) ) ;;
	step 15 : wff = anbi2d (step 14) |- ( y = C → ( ( ¬ B R B ∧ ( ( B R y ∧ y R z ) → B R z ) ) ↔ ( ¬ B R B ∧ ( ( B R C ∧ C R z ) → B R z ) ) ) ) ;;
	step 16 : wff = imbi2d (step 15) |- ( y = C → ( ( R Po A → ( ¬ B R B ∧ ( ( B R y ∧ y R z ) → B R z ) ) ) ↔ ( R Po A → ( ¬ B R B ∧ ( ( B R C ∧ C R z ) → B R z ) ) ) ) ) ;;
	step 17 : wff = breq2 () |- ( z = D → ( C R z ↔ C R D ) ) ;;
	step 18 : wff = anbi2d (step 17) |- ( z = D → ( ( B R C ∧ C R z ) ↔ ( B R C ∧ C R D ) ) ) ;;
	step 19 : wff = breq2 () |- ( z = D → ( B R z ↔ B R D ) ) ;;
	step 20 : wff = imbi12d (step 18, step 19) |- ( z = D → ( ( ( B R C ∧ C R z ) → B R z ) ↔ ( ( B R C ∧ C R D ) → B R D ) ) ) ;;
	step 21 : wff = anbi2d (step 20) |- ( z = D → ( ( ¬ B R B ∧ ( ( B R C ∧ C R z ) → B R z ) ) ↔ ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ) ;;
	step 22 : wff = imbi2d (step 21) |- ( z = D → ( ( R Po A → ( ¬ B R B ∧ ( ( B R C ∧ C R z ) → B R z ) ) ) ↔ ( R Po A → ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ) ) ;;
	step 23 : wff = df-po () |- ( R Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 24 : wff = r3al () |- ( ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ↔ ∀ x ∀ y ∀ z ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 25 : wff = bitri (step 23, step 24) |- ( R Po A ↔ ∀ x ∀ y ∀ z ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 26 : wff = biimpi (step 25) |- ( R Po A → ∀ x ∀ y ∀ z ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 27 : wff = 19.21bbi (step 26) |- ( R Po A → ∀ z ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 28 : wff = 19.21bi (step 27) |- ( R Po A → ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 29 : wff = com12 (step 28) |- ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( R Po A → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ) ;;
	step 30 : wff = vtocl3ga (step 10, step 16, step 22, step 29) |- ( ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) → ( R Po A → ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ) ;;
	step 31 : wff = com12 (step 30) |- ( R Po A → ( ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) → ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ) ;;
	qed prop 1 = step 31 ;;
}

/*Sufficient conditions for a partial order.  (Contributed by NM,
       9-Jul-2014.) */

theorem ispod (ph : wff, x : set, y : set, z : set, A : class, R : class) disjointed(x y z A, x y z R, x y z ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ¬ x R x ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( ( x R y ∧ y R z ) → x R z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → R Po A ) ;;
}

proof of ispod {
	step 1 : wff = 3ad2antr1 (hyp 1) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ¬ x R x ) ;;
	step 2 : wff = jca (step 1, hyp 2) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 3 : wff = ralrimivvva (step 2) |- ( ph → ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 4 : wff = df-po () |- ( R Po A ↔ ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ph → R Po A ) ;;
	qed prop 1 = step 5 ;;
}

/*Perform the substitutions into the strict weak ordering law.
       (Contributed by Mario Carneiro, 31-Dec-2014.) */

theorem swopolem (ph : wff, x : set, y : set, z : set, A : class, R : class, X : class, Y : class, Z : class) disjointed(x y z A, x y z ph, x y z R, x y z X, y z Y, z Z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( x R y → ( x R z ∨ z R y ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ( X ∈ A ∧ Y ∈ A ∧ Z ∈ A ) ) → ( X R Y → ( X R Z ∨ Z R Y ) ) ) ;;
}

proof of swopolem {
	step 1 : wff = ralrimivvva (hyp 1) |- ( ph → ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( x R y → ( x R z ∨ z R y ) ) ) ;;
	step 2 : wff = breq1 () |- ( x = X → ( x R y ↔ X R y ) ) ;;
	step 3 : wff = breq1 () |- ( x = X → ( x R z ↔ X R z ) ) ;;
	step 4 : wff = orbi1d (step 3) |- ( x = X → ( ( x R z ∨ z R y ) ↔ ( X R z ∨ z R y ) ) ) ;;
	step 5 : wff = imbi12d (step 2, step 4) |- ( x = X → ( ( x R y → ( x R z ∨ z R y ) ) ↔ ( X R y → ( X R z ∨ z R y ) ) ) ) ;;
	step 6 : wff = breq2 () |- ( y = Y → ( X R y ↔ X R Y ) ) ;;
	step 7 : wff = breq2 () |- ( y = Y → ( z R y ↔ z R Y ) ) ;;
	step 8 : wff = orbi2d (step 7) |- ( y = Y → ( ( X R z ∨ z R y ) ↔ ( X R z ∨ z R Y ) ) ) ;;
	step 9 : wff = imbi12d (step 6, step 8) |- ( y = Y → ( ( X R y → ( X R z ∨ z R y ) ) ↔ ( X R Y → ( X R z ∨ z R Y ) ) ) ) ;;
	step 10 : wff = breq2 () |- ( z = Z → ( X R z ↔ X R Z ) ) ;;
	step 11 : wff = breq1 () |- ( z = Z → ( z R Y ↔ Z R Y ) ) ;;
	step 12 : wff = orbi12d (step 10, step 11) |- ( z = Z → ( ( X R z ∨ z R Y ) ↔ ( X R Z ∨ Z R Y ) ) ) ;;
	step 13 : wff = imbi2d (step 12) |- ( z = Z → ( ( X R Y → ( X R z ∨ z R Y ) ) ↔ ( X R Y → ( X R Z ∨ Z R Y ) ) ) ) ;;
	step 14 : wff = rspc3v (step 5, step 9, step 13) |- ( ( X ∈ A ∧ Y ∈ A ∧ Z ∈ A ) → ( ∀ x ∈ A ∀ y ∈ A ∀ z ∈ A ( x R y → ( x R z ∨ z R y ) ) → ( X R Y → ( X R Z ∨ Z R Y ) ) ) ) ;;
	step 15 : wff = mpan9 (step 1, step 14) |- ( ( ph ∧ ( X ∈ A ∧ Y ∈ A ∧ Z ∈ A ) ) → ( X R Y → ( X R Z ∨ Z R Y ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/*A strict weak order is a partial order.  (Contributed by Mario Carneiro,
       9-Jul-2014.) */

theorem swopo (ph : wff, x : set, y : set, z : set, A : class, R : class) disjointed(x y z A, x y z R, x y z ph) {
	hyp 1 : wff = |- ( ( ph ∧ ( y ∈ A ∧ z ∈ A ) ) → ( y R z → ¬ z R y ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( x R y → ( x R z ∨ z R y ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → R Po A ) ;;
}

proof of swopo {
	step 1 : wff = id () |- ( x ∈ A → x ∈ A ) ;;
	step 2 : wff = ancli (step 1) |- ( x ∈ A → ( x ∈ A ∧ x ∈ A ) ) ;;
	step 3 : wff = ralrimivva (hyp 1) |- ( ph → ∀ y ∈ A ∀ z ∈ A ( y R z → ¬ z R y ) ) ;;
	step 4 : wff = breq1 () |- ( y = x → ( y R z ↔ x R z ) ) ;;
	step 5 : wff = breq2 () |- ( y = x → ( z R y ↔ z R x ) ) ;;
	step 6 : wff = notbid (step 5) |- ( y = x → ( ¬ z R y ↔ ¬ z R x ) ) ;;
	step 7 : wff = imbi12d (step 4, step 6) |- ( y = x → ( ( y R z → ¬ z R y ) ↔ ( x R z → ¬ z R x ) ) ) ;;
	step 8 : wff = breq2 () |- ( z = x → ( x R z ↔ x R x ) ) ;;
	step 9 : wff = breq1 () |- ( z = x → ( z R x ↔ x R x ) ) ;;
	step 10 : wff = notbid (step 9) |- ( z = x → ( ¬ z R x ↔ ¬ x R x ) ) ;;
	step 11 : wff = imbi12d (step 8, step 10) |- ( z = x → ( ( x R z → ¬ z R x ) ↔ ( x R x → ¬ x R x ) ) ) ;;
	step 12 : wff = rspc2va (step 7, step 11) |- ( ( ( x ∈ A ∧ x ∈ A ) ∧ ∀ y ∈ A ∀ z ∈ A ( y R z → ¬ z R y ) ) → ( x R x → ¬ x R x ) ) ;;
	step 13 : wff = syl2anr (step 2, step 3, step 12) |- ( ( ph ∧ x ∈ A ) → ( x R x → ¬ x R x ) ) ;;
	step 14 : wff = pm2.01d (step 13) |- ( ( ph ∧ x ∈ A ) → ¬ x R x ) ;;
	step 15 : wff = 3adantr1 (hyp 1) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( y R z → ¬ z R y ) ) ;;
	step 16 : wff = imp (hyp 2) |- ( ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) ∧ x R y ) → ( x R z ∨ z R y ) ) ;;
	step 17 : wff = orcomd (step 16) |- ( ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) ∧ x R y ) → ( z R y ∨ x R z ) ) ;;
	step 18 : wff = ord (step 17) |- ( ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) ∧ x R y ) → ( ¬ z R y → x R z ) ) ;;
	step 19 : wff = expimpd (step 18) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( ( x R y ∧ ¬ z R y ) → x R z ) ) ;;
	step 20 : wff = sylan2d (step 15, step 19) |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 21 : wff = ispod (step 14, step 20) |- ( ph → R Po A ) ;;
	qed prop 1 = step 21 ;;
}

/*A partial order relation is irreflexive.  (Contributed by NM,
     27-Mar-1997.) */

theorem poirr (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( R Po A ∧ B ∈ A ) → ¬ B R B ) ;;
}

proof of poirr {
	step 1 : wff = df-3an () |- ( ( B ∈ A ∧ B ∈ A ∧ B ∈ A ) ↔ ( ( B ∈ A ∧ B ∈ A ) ∧ B ∈ A ) ) ;;
	step 2 : wff = anabs1 () |- ( ( ( B ∈ A ∧ B ∈ A ) ∧ B ∈ A ) ↔ ( B ∈ A ∧ B ∈ A ) ) ;;
	step 3 : wff = anidm () |- ( ( B ∈ A ∧ B ∈ A ) ↔ B ∈ A ) ;;
	step 4 : wff = 3bitrri (step 1, step 2, step 3) |- ( B ∈ A ↔ ( B ∈ A ∧ B ∈ A ∧ B ∈ A ) ) ;;
	step 5 : wff = pocl () |- ( R Po A → ( ( B ∈ A ∧ B ∈ A ∧ B ∈ A ) → ( ¬ B R B ∧ ( ( B R B ∧ B R B ) → B R B ) ) ) ) ;;
	step 6 : wff = imp (step 5) |- ( ( R Po A ∧ ( B ∈ A ∧ B ∈ A ∧ B ∈ A ) ) → ( ¬ B R B ∧ ( ( B R B ∧ B R B ) → B R B ) ) ) ;;
	step 7 : wff = simpld (step 6) |- ( ( R Po A ∧ ( B ∈ A ∧ B ∈ A ∧ B ∈ A ) ) → ¬ B R B ) ;;
	step 8 : wff = sylan2b (step 4, step 7) |- ( ( R Po A ∧ B ∈ A ) → ¬ B R B ) ;;
	qed prop 1 = step 8 ;;
}

/*A partial order relation is a transitive relation.  (Contributed by NM,
     27-Mar-1997.) */

theorem potr (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
}

proof of potr {
	step 1 : wff = pocl () |- ( R Po A → ( ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) → ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ) ;;
	step 2 : wff = imp (step 1) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ¬ B R B ∧ ( ( B R C ∧ C R D ) → B R D ) ) ) ;;
	step 3 : wff = simprd (step 2) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A partial order relation has no 2-cycle loops.  (Contributed by NM,
     27-Mar-1997.) */

theorem po2nr (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R C ∧ C R B ) ) ;;
}

proof of po2nr {
	step 1 : wff = poirr () |- ( ( R Po A ∧ B ∈ A ) → ¬ B R B ) ;;
	step 2 : wff = adantrr (step 1) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ B R B ) ;;
	step 3 : wff = potr () |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ B ∈ A ) ) → ( ( B R C ∧ C R B ) → B R B ) ) ;;
	step 4 : wff = 3exp2 (step 3) |- ( R Po A → ( B ∈ A → ( C ∈ A → ( B ∈ A → ( ( B R C ∧ C R B ) → B R B ) ) ) ) ) ;;
	step 5 : wff = com34 (step 4) |- ( R Po A → ( B ∈ A → ( B ∈ A → ( C ∈ A → ( ( B R C ∧ C R B ) → B R B ) ) ) ) ) ;;
	step 6 : wff = pm2.43d (step 5) |- ( R Po A → ( B ∈ A → ( C ∈ A → ( ( B R C ∧ C R B ) → B R B ) ) ) ) ;;
	step 7 : wff = imp32 (step 6) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ( B R C ∧ C R B ) → B R B ) ) ;;
	step 8 : wff = mtod (step 2, step 7) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R C ∧ C R B ) ) ;;
	qed prop 1 = step 8 ;;
}

/*A partial order relation has no 3-cycle loops.  (Contributed by NM,
     27-Mar-1997.) */

theorem po3nr (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ¬ ( B R C ∧ C R D ∧ D R B ) ) ;;
}

proof of po3nr {
	step 1 : wff = po2nr () |- ( ( R Po A ∧ ( B ∈ A ∧ D ∈ A ) ) → ¬ ( B R D ∧ D R B ) ) ;;
	step 2 : wff = 3adantr2 (step 1) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ¬ ( B R D ∧ D R B ) ) ;;
	step 3 : wff = df-3an () |- ( ( B R C ∧ C R D ∧ D R B ) ↔ ( ( B R C ∧ C R D ) ∧ D R B ) ) ;;
	step 4 : wff = potr () |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
	step 5 : wff = anim1d (step 4) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( ( B R C ∧ C R D ) ∧ D R B ) → ( B R D ∧ D R B ) ) ) ;;
	step 6 : wff = syl5bi (step 3, step 5) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ∧ D R B ) → ( B R D ∧ D R B ) ) ) ;;
	step 7 : wff = mtod (step 2, step 6) |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ¬ ( B R C ∧ C R D ∧ D R B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Any relation is a partial ordering of the empty set.  (Contributed by
       NM, 28-Mar-1997.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem po0 (R : class) disjointed(x y z R) {
	prop 1 : wff = |- R Po ∅ ;;
}

proof of po0 {
	var x : set, y : set, z : set;;
	step 1 : wff = ral0 () |- ∀ x ∈ ∅ ∀ y ∈ ∅ ∀ z ∈ ∅ ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 2 : wff = df-po () |- ( R Po ∅ ↔ ∀ x ∈ ∅ ∀ y ∈ ∅ ∀ z ∈ ∅ ( ¬ x R x ∧ ( ( x R y ∧ y R z ) → x R z ) ) ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- R Po ∅ ;;
	qed prop 1 = step 3 ;;
}

/*A function preserves a partial order relation.  (Contributed by Jeff
       Madsen, 18-Jun-2011.) */

theorem pofun (x : set, y : set, A : class, B : class, R : class, S : class, X : class, Y : class) disjointed(R v w x y z, S v w z, X v w y z, Y x z, A v w x z, B v w x z) {
	hyp 1 : wff = |- S = { 〈 x , y 〉 | X R Y } ;;
	hyp 2 : wff = |- ( x = y → X = Y ) ;;
	-----------------------
	prop 1 : wff = |- ( ( R Po B ∧ ∀ x ∈ A X ∈ B ) → S Po A ) ;;
}

proof of pofun {
	var z : set, w : set, v : set;;
	step 1 : wff = nfcsb1v () |- F/_ x [_ v / x ]_ X ;;
	step 2 : wff = nfel1 (step 1) |- F/ x [_ v / x ]_ X ∈ B ;;
	step 3 : wff = csbeq1a () |- ( x = v → X = [_ v / x ]_ X ) ;;
	step 4 : wff = eleq1d (step 3) |- ( x = v → ( X ∈ B ↔ [_ v / x ]_ X ∈ B ) ) ;;
	step 5 : wff = rspc (step 2, step 4) |- ( v ∈ A → ( ∀ x ∈ A X ∈ B → [_ v / x ]_ X ∈ B ) ) ;;
	step 6 : wff = impcom (step 5) |- ( ( ∀ x ∈ A X ∈ B ∧ v ∈ A ) → [_ v / x ]_ X ∈ B ) ;;
	step 7 : wff = poirr () |- ( ( R Po B ∧ [_ v / x ]_ X ∈ B ) → ¬ [_ v / x ]_ X R [_ v / x ]_ X ) ;;
	step 8 : wff = df-br () |- ( v S v ↔ 〈 v , v 〉 ∈ S ) ;;
	step 9 : wff = eleq2i (hyp 1) |- ( 〈 v , v 〉 ∈ S ↔ 〈 v , v 〉 ∈ { 〈 x , y 〉 | X R Y } ) ;;
	step 10 : wff = nfcsb1v () |- F/_ x [_ v / x ]_ X ;;
	step 11 : wff = nfcv () |- F/_ x R ;;
	step 12 : wff = nfcv () |- F/_ x Y ;;
	step 13 : wff = nfbr (step 10, step 11, step 12) |- F/ x [_ v / x ]_ X R Y ;;
	step 14 : wff = nfv () |- F/ y [_ v / x ]_ X R [_ v / x ]_ X ;;
	step 15 : wff = vex () |- v ∈ _V ;;
	step 16 : wff = vex () |- v ∈ _V ;;
	step 17 : wff = csbeq1a () |- ( x = v → X = [_ v / x ]_ X ) ;;
	step 18 : wff = breq1d (step 17) |- ( x = v → ( X R Y ↔ [_ v / x ]_ X R Y ) ) ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = nfcv () |- F/_ x Y ;;
	step 21 : wff = csbief (step 19, step 20, hyp 2) |- [_ y / x ]_ X = Y ;;
	step 22 : wff = csbeq1 () |- ( y = v → [_ y / x ]_ X = [_ v / x ]_ X ) ;;
	step 23 : wff = syl5eqr (step 21, step 22) |- ( y = v → Y = [_ v / x ]_ X ) ;;
	step 24 : wff = breq2d (step 23) |- ( y = v → ( [_ v / x ]_ X R Y ↔ [_ v / x ]_ X R [_ v / x ]_ X ) ) ;;
	step 25 : wff = opelopabf (step 13, step 14, step 15, step 16, step 18, step 24) |- ( 〈 v , v 〉 ∈ { 〈 x , y 〉 | X R Y } ↔ [_ v / x ]_ X R [_ v / x ]_ X ) ;;
	step 26 : wff = 3bitri (step 8, step 9, step 25) |- ( v S v ↔ [_ v / x ]_ X R [_ v / x ]_ X ) ;;
	step 27 : wff = sylnibr (step 7, step 26) |- ( ( R Po B ∧ [_ v / x ]_ X ∈ B ) → ¬ v S v ) ;;
	step 28 : wff = sylan2 (step 6, step 27) |- ( ( R Po B ∧ ( ∀ x ∈ A X ∈ B ∧ v ∈ A ) ) → ¬ v S v ) ;;
	step 29 : wff = anassrs (step 28) |- ( ( ( R Po B ∧ ∀ x ∈ A X ∈ B ) ∧ v ∈ A ) → ¬ v S v ) ;;
	step 30 : wff = nfcsb1v () |- F/_ x [_ v / x ]_ X ;;
	step 31 : wff = nfel1 (step 30) |- F/ x [_ v / x ]_ X ∈ B ;;
	step 32 : wff = csbeq1a () |- ( x = v → X = [_ v / x ]_ X ) ;;
	step 33 : wff = eleq1d (step 32) |- ( x = v → ( X ∈ B ↔ [_ v / x ]_ X ∈ B ) ) ;;
	step 34 : wff = rspc (step 31, step 33) |- ( v ∈ A → ( ∀ x ∈ A X ∈ B → [_ v / x ]_ X ∈ B ) ) ;;
	step 35 : wff = com12 (step 34) |- ( ∀ x ∈ A X ∈ B → ( v ∈ A → [_ v / x ]_ X ∈ B ) ) ;;
	step 36 : wff = nfcsb1v () |- F/_ x [_ w / x ]_ X ;;
	step 37 : wff = nfel1 (step 36) |- F/ x [_ w / x ]_ X ∈ B ;;
	step 38 : wff = csbeq1a () |- ( x = w → X = [_ w / x ]_ X ) ;;
	step 39 : wff = eleq1d (step 38) |- ( x = w → ( X ∈ B ↔ [_ w / x ]_ X ∈ B ) ) ;;
	step 40 : wff = rspc (step 37, step 39) |- ( w ∈ A → ( ∀ x ∈ A X ∈ B → [_ w / x ]_ X ∈ B ) ) ;;
	step 41 : wff = com12 (step 40) |- ( ∀ x ∈ A X ∈ B → ( w ∈ A → [_ w / x ]_ X ∈ B ) ) ;;
	step 42 : wff = nfcsb1v () |- F/_ x [_ z / x ]_ X ;;
	step 43 : wff = nfel1 (step 42) |- F/ x [_ z / x ]_ X ∈ B ;;
	step 44 : wff = csbeq1a () |- ( x = z → X = [_ z / x ]_ X ) ;;
	step 45 : wff = eleq1d (step 44) |- ( x = z → ( X ∈ B ↔ [_ z / x ]_ X ∈ B ) ) ;;
	step 46 : wff = rspc (step 43, step 45) |- ( z ∈ A → ( ∀ x ∈ A X ∈ B → [_ z / x ]_ X ∈ B ) ) ;;
	step 47 : wff = com12 (step 46) |- ( ∀ x ∈ A X ∈ B → ( z ∈ A → [_ z / x ]_ X ∈ B ) ) ;;
	step 48 : wff = 3anim123d (step 35, step 41, step 47) |- ( ∀ x ∈ A X ∈ B → ( ( v ∈ A ∧ w ∈ A ∧ z ∈ A ) → ( [_ v / x ]_ X ∈ B ∧ [_ w / x ]_ X ∈ B ∧ [_ z / x ]_ X ∈ B ) ) ) ;;
	step 49 : wff = imp (step 48) |- ( ( ∀ x ∈ A X ∈ B ∧ ( v ∈ A ∧ w ∈ A ∧ z ∈ A ) ) → ( [_ v / x ]_ X ∈ B ∧ [_ w / x ]_ X ∈ B ∧ [_ z / x ]_ X ∈ B ) ) ;;
	step 50 : wff = adantll (step 49) |- ( ( ( R Po B ∧ ∀ x ∈ A X ∈ B ) ∧ ( v ∈ A ∧ w ∈ A ∧ z ∈ A ) ) → ( [_ v / x ]_ X ∈ B ∧ [_ w / x ]_ X ∈ B ∧ [_ z / x ]_ X ∈ B ) ) ;;
	step 51 : wff = potr () |- ( ( R Po B ∧ ( [_ v / x ]_ X ∈ B ∧ [_ w / x ]_ X ∈ B ∧ [_ z / x ]_ X ∈ B ) ) → ( ( [_ v / x ]_ X R [_ w / x ]_ X ∧ [_ w / x ]_ X R [_ z / x ]_ X ) → [_ v / x ]_ X R [_ z / x ]_ X ) ) ;;
	step 52 : wff = df-br () |- ( v S w ↔ 〈 v , w 〉 ∈ S ) ;;
	step 53 : wff = eleq2i (hyp 1) |- ( 〈 v , w 〉 ∈ S ↔ 〈 v , w 〉 ∈ { 〈 x , y 〉 | X R Y } ) ;;
	step 54 : wff = nfcsb1v () |- F/_ x [_ v / x ]_ X ;;
	step 55 : wff = nfcv () |- F/_ x R ;;
	step 56 : wff = nfcv () |- F/_ x Y ;;
	step 57 : wff = nfbr (step 54, step 55, step 56) |- F/ x [_ v / x ]_ X R Y ;;
	step 58 : wff = nfv () |- F/ y [_ v / x ]_ X R [_ w / x ]_ X ;;
	step 59 : wff = vex () |- v ∈ _V ;;
	step 60 : wff = vex () |- w ∈ _V ;;
	step 61 : wff = csbeq1a () |- ( x = v → X = [_ v / x ]_ X ) ;;
	step 62 : wff = breq1d (step 61) |- ( x = v → ( X R Y ↔ [_ v / x ]_ X R Y ) ) ;;
	step 63 : wff = vex () |- y ∈ _V ;;
	step 64 : wff = nfcv () |- F/_ x Y ;;
	step 65 : wff = csbief (step 63, step 64, hyp 2) |- [_ y / x ]_ X = Y ;;
	step 66 : wff = csbeq1 () |- ( y = w → [_ y / x ]_ X = [_ w / x ]_ X ) ;;
	step 67 : wff = syl5eqr (step 65, step 66) |- ( y = w → Y = [_ w / x ]_ X ) ;;
	step 68 : wff = breq2d (step 67) |- ( y = w → ( [_ v / x ]_ X R Y ↔ [_ v / x ]_ X R [_ w / x ]_ X ) ) ;;
	step 69 : wff = opelopabf (step 57, step 58, step 59, step 60, step 62, step 68) |- ( 〈 v , w 〉 ∈ { 〈 x , y 〉 | X R Y } ↔ [_ v / x ]_ X R [_ w / x ]_ X ) ;;
	step 70 : wff = 3bitri (step 52, step 53, step 69) |- ( v S w ↔ [_ v / x ]_ X R [_ w / x ]_ X ) ;;
	step 71 : wff = df-br () |- ( w S z ↔ 〈 w , z 〉 ∈ S ) ;;
	step 72 : wff = eleq2i (hyp 1) |- ( 〈 w , z 〉 ∈ S ↔ 〈 w , z 〉 ∈ { 〈 x , y 〉 | X R Y } ) ;;
	step 73 : wff = nfcsb1v () |- F/_ x [_ w / x ]_ X ;;
	step 74 : wff = nfcv () |- F/_ x R ;;
	step 75 : wff = nfcv () |- F/_ x Y ;;
	step 76 : wff = nfbr (step 73, step 74, step 75) |- F/ x [_ w / x ]_ X R Y ;;
	step 77 : wff = nfv () |- F/ y [_ w / x ]_ X R [_ z / x ]_ X ;;
	step 78 : wff = vex () |- w ∈ _V ;;
	step 79 : wff = vex () |- z ∈ _V ;;
	step 80 : wff = csbeq1a () |- ( x = w → X = [_ w / x ]_ X ) ;;
	step 81 : wff = breq1d (step 80) |- ( x = w → ( X R Y ↔ [_ w / x ]_ X R Y ) ) ;;
	step 82 : wff = vex () |- y ∈ _V ;;
	step 83 : wff = nfcv () |- F/_ x Y ;;
	step 84 : wff = csbief (step 82, step 83, hyp 2) |- [_ y / x ]_ X = Y ;;
	step 85 : wff = csbeq1 () |- ( y = z → [_ y / x ]_ X = [_ z / x ]_ X ) ;;
	step 86 : wff = syl5eqr (step 84, step 85) |- ( y = z → Y = [_ z / x ]_ X ) ;;
	step 87 : wff = breq2d (step 86) |- ( y = z → ( [_ w / x ]_ X R Y ↔ [_ w / x ]_ X R [_ z / x ]_ X ) ) ;;
	step 88 : wff = opelopabf (step 76, step 77, step 78, step 79, step 81, step 87) |- ( 〈 w , z 〉 ∈ { 〈 x , y 〉 | X R Y } ↔ [_ w / x ]_ X R [_ z / x ]_ X ) ;;
	step 89 : wff = 3bitri (step 71, step 72, step 88) |- ( w S z ↔ [_ w / x ]_ X R [_ z / x ]_ X ) ;;
	step 90 : wff = anbi12i (step 70, step 89) |- ( ( v S w ∧ w S z ) ↔ ( [_ v / x ]_ X R [_ w / x ]_ X ∧ [_ w / x ]_ X R [_ z / x ]_ X ) ) ;;
	step 91 : wff = df-br () |- ( v S z ↔ 〈 v , z 〉 ∈ S ) ;;
	step 92 : wff = eleq2i (hyp 1) |- ( 〈 v , z 〉 ∈ S ↔ 〈 v , z 〉 ∈ { 〈 x , y 〉 | X R Y } ) ;;
	step 93 : wff = nfcsb1v () |- F/_ x [_ v / x ]_ X ;;
	step 94 : wff = nfcv () |- F/_ x R ;;
	step 95 : wff = nfcv () |- F/_ x Y ;;
	step 96 : wff = nfbr (step 93, step 94, step 95) |- F/ x [_ v / x ]_ X R Y ;;
	step 97 : wff = nfv () |- F/ y [_ v / x ]_ X R [_ z / x ]_ X ;;
	step 98 : wff = vex () |- v ∈ _V ;;
	step 99 : wff = vex () |- z ∈ _V ;;
	step 100 : wff = csbeq1a () |- ( x = v → X = [_ v / x ]_ X ) ;;
	step 101 : wff = breq1d (step 100) |- ( x = v → ( X R Y ↔ [_ v / x ]_ X R Y ) ) ;;
	step 102 : wff = vex () |- y ∈ _V ;;
	step 103 : wff = nfcv () |- F/_ x Y ;;
	step 104 : wff = csbief (step 102, step 103, hyp 2) |- [_ y / x ]_ X = Y ;;
	step 105 : wff = csbeq1 () |- ( y = z → [_ y / x ]_ X = [_ z / x ]_ X ) ;;
	step 106 : wff = syl5eqr (step 104, step 105) |- ( y = z → Y = [_ z / x ]_ X ) ;;
	step 107 : wff = breq2d (step 106) |- ( y = z → ( [_ v / x ]_ X R Y ↔ [_ v / x ]_ X R [_ z / x ]_ X ) ) ;;
	step 108 : wff = opelopabf (step 96, step 97, step 98, step 99, step 101, step 107) |- ( 〈 v , z 〉 ∈ { 〈 x , y 〉 | X R Y } ↔ [_ v / x ]_ X R [_ z / x ]_ X ) ;;
	step 109 : wff = 3bitri (step 91, step 92, step 108) |- ( v S z ↔ [_ v / x ]_ X R [_ z / x ]_ X ) ;;
	step 110 : wff = 3imtr4g (step 51, step 90, step 109) |- ( ( R Po B ∧ ( [_ v / x ]_ X ∈ B ∧ [_ w / x ]_ X ∈ B ∧ [_ z / x ]_ X ∈ B ) ) → ( ( v S w ∧ w S z ) → v S z ) ) ;;
	step 111 : wff = adantlr (step 110) |- ( ( ( R Po B ∧ ∀ x ∈ A X ∈ B ) ∧ ( [_ v / x ]_ X ∈ B ∧ [_ w / x ]_ X ∈ B ∧ [_ z / x ]_ X ∈ B ) ) → ( ( v S w ∧ w S z ) → v S z ) ) ;;
	step 112 : wff = syldan (step 50, step 111) |- ( ( ( R Po B ∧ ∀ x ∈ A X ∈ B ) ∧ ( v ∈ A ∧ w ∈ A ∧ z ∈ A ) ) → ( ( v S w ∧ w S z ) → v S z ) ) ;;
	step 113 : wff = ispod (step 29, step 112) |- ( ( R Po B ∧ ∀ x ∈ A X ∈ B ) → S Po A ) ;;
	qed prop 1 = step 113 ;;
}

/*A strict linear order is a strict partial order.  (Contributed by NM,
       28-Mar-1997.) */

theorem sopo (A : class, R : class) disjointed(x y R, x y A) {
	prop 1 : wff = |- ( R Or A → R Po A ) ;;
}

proof of sopo {
	var x : set, y : set;;
	step 1 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( R Or A → R Po A ) ;;
	qed prop 1 = step 2 ;;
}

/*Subset theorem for the strict ordering predicate.  (Contributed by NM,
       16-Mar-1997.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem soss (A : class, B : class, R : class) disjointed(x y R, x y A, x y B) {
	prop 1 : wff = |- ( A ⊆ B → ( R Or B → R Or A ) ) ;;
}

proof of soss {
	var x : set, y : set;;
	step 1 : wff = poss () |- ( A ⊆ B → ( R Po B → R Po A ) ) ;;
	step 2 : wff = ssel () |- ( A ⊆ B → ( x ∈ A → x ∈ B ) ) ;;
	step 3 : wff = ssel () |- ( A ⊆ B → ( y ∈ A → y ∈ B ) ) ;;
	step 4 : wff = anim12d (step 2, step 3) |- ( A ⊆ B → ( ( x ∈ A ∧ y ∈ A ) → ( x ∈ B ∧ y ∈ B ) ) ) ;;
	step 5 : wff = imim1d (step 4) |- ( A ⊆ B → ( ( ( x ∈ B ∧ y ∈ B ) → ( x R y ∨ x = y ∨ y R x ) ) → ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ) ) ;;
	step 6 : wff = 2alimdv (step 5) |- ( A ⊆ B → ( ∀ x ∀ y ( ( x ∈ B ∧ y ∈ B ) → ( x R y ∨ x = y ∨ y R x ) ) → ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ) ) ;;
	step 7 : wff = r2al () |- ( ∀ x ∈ B ∀ y ∈ B ( x R y ∨ x = y ∨ y R x ) ↔ ∀ x ∀ y ( ( x ∈ B ∧ y ∈ B ) → ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 8 : wff = r2al () |- ( ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 9 : wff = 3imtr4g (step 6, step 7, step 8) |- ( A ⊆ B → ( ∀ x ∈ B ∀ y ∈ B ( x R y ∨ x = y ∨ y R x ) → ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 10 : wff = anim12d (step 1, step 9) |- ( A ⊆ B → ( ( R Po B ∧ ∀ x ∈ B ∀ y ∈ B ( x R y ∨ x = y ∨ y R x ) ) → ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ) ;;
	step 11 : wff = df-so () |- ( R Or B ↔ ( R Po B ∧ ∀ x ∈ B ∀ y ∈ B ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 12 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 13 : wff = 3imtr4g (step 10, step 11, step 12) |- ( A ⊆ B → ( R Or B → R Or A ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Equality theorem for the strict ordering predicate.  (Contributed by NM,
       16-Mar-1997.) */

theorem soeq1 (A : class, R : class, S : class) disjointed(x y R, x y S, x y A) {
	prop 1 : wff = |- ( R = S → ( R Or A ↔ S Or A ) ) ;;
}

proof of soeq1 {
	var x : set, y : set;;
	step 1 : wff = poeq1 () |- ( R = S → ( R Po A ↔ S Po A ) ) ;;
	step 2 : wff = breq () |- ( R = S → ( x R y ↔ x S y ) ) ;;
	step 3 : wff = biidd () |- ( R = S → ( x = y ↔ x = y ) ) ;;
	step 4 : wff = breq () |- ( R = S → ( y R x ↔ y S x ) ) ;;
	step 5 : wff = 3orbi123d (step 2, step 3, step 4) |- ( R = S → ( ( x R y ∨ x = y ∨ y R x ) ↔ ( x S y ∨ x = y ∨ y S x ) ) ) ;;
	step 6 : wff = 2ralbidv (step 5) |- ( R = S → ( ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ↔ ∀ x ∈ A ∀ y ∈ A ( x S y ∨ x = y ∨ y S x ) ) ) ;;
	step 7 : wff = anbi12d (step 1, step 6) |- ( R = S → ( ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ↔ ( S Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x S y ∨ x = y ∨ y S x ) ) ) ) ;;
	step 8 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 9 : wff = df-so () |- ( S Or A ↔ ( S Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x S y ∨ x = y ∨ y S x ) ) ) ;;
	step 10 : wff = 3bitr4g (step 7, step 8, step 9) |- ( R = S → ( R Or A ↔ S Or A ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Equality theorem for the strict ordering predicate.  (Contributed by NM,
     16-Mar-1997.) */

theorem soeq2 (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( A = B → ( R Or A ↔ R Or B ) ) ;;
}

proof of soeq2 {
	step 1 : wff = soss () |- ( A ⊆ B → ( R Or B → R Or A ) ) ;;
	step 2 : wff = soss () |- ( B ⊆ A → ( R Or A → R Or B ) ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( A ⊆ B ∧ B ⊆ A ) → ( ( R Or B → R Or A ) ∧ ( R Or A → R Or B ) ) ) ;;
	step 4 : wff = eqss () |- ( A = B ↔ ( A ⊆ B ∧ B ⊆ A ) ) ;;
	step 5 : wff = dfbi2 () |- ( ( R Or B ↔ R Or A ) ↔ ( ( R Or B → R Or A ) ∧ ( R Or A → R Or B ) ) ) ;;
	step 6 : wff = 3imtr4i (step 3, step 4, step 5) |- ( A = B → ( R Or B ↔ R Or A ) ) ;;
	step 7 : wff = bicomd (step 6) |- ( A = B → ( R Or A ↔ R Or B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*A strict order relation is irreflexive.  (Contributed by NM,
     24-Nov-1995.) */

theorem sonr (A : class, B : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ B ∈ A ) → ¬ B R B ) ;;
}

proof of sonr {
	step 1 : wff = sopo () |- ( R Or A → R Po A ) ;;
	step 2 : wff = poirr () |- ( ( R Po A ∧ B ∈ A ) → ¬ B R B ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( R Or A ∧ B ∈ A ) → ¬ B R B ) ;;
	qed prop 1 = step 3 ;;
}

/*A strict order relation is a transitive relation.  (Contributed by NM,
     21-Jan-1996.) */

theorem sotr (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
}

proof of sotr {
	step 1 : wff = sopo () |- ( R Or A → R Po A ) ;;
	step 2 : wff = potr () |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A strict order relation is linear (satisfies trichotomy).  (Contributed
       by NM, 21-Jan-1996.) */

theorem solin (A : class, B : class, C : class, R : class) disjointed(x y A, x y B, x y C, x y R) {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C ∨ B = C ∨ C R B ) ) ;;
}

proof of solin {
	var x : set, y : set;;
	step 1 : wff = breq1 () |- ( x = B → ( x R y ↔ B R y ) ) ;;
	step 2 : wff = eqeq1 () |- ( x = B → ( x = y ↔ B = y ) ) ;;
	step 3 : wff = breq2 () |- ( x = B → ( y R x ↔ y R B ) ) ;;
	step 4 : wff = 3orbi123d (step 1, step 2, step 3) |- ( x = B → ( ( x R y ∨ x = y ∨ y R x ) ↔ ( B R y ∨ B = y ∨ y R B ) ) ) ;;
	step 5 : wff = imbi2d (step 4) |- ( x = B → ( ( R Or A → ( x R y ∨ x = y ∨ y R x ) ) ↔ ( R Or A → ( B R y ∨ B = y ∨ y R B ) ) ) ) ;;
	step 6 : wff = breq2 () |- ( y = C → ( B R y ↔ B R C ) ) ;;
	step 7 : wff = eqeq2 () |- ( y = C → ( B = y ↔ B = C ) ) ;;
	step 8 : wff = breq1 () |- ( y = C → ( y R B ↔ C R B ) ) ;;
	step 9 : wff = 3orbi123d (step 6, step 7, step 8) |- ( y = C → ( ( B R y ∨ B = y ∨ y R B ) ↔ ( B R C ∨ B = C ∨ C R B ) ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( y = C → ( ( R Or A → ( B R y ∨ B = y ∨ y R B ) ) ↔ ( R Or A → ( B R C ∨ B = C ∨ C R B ) ) ) ) ;;
	step 11 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 12 : wff = rsp2 () |- ( ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) → ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 13 : wff = adantl (step 12) |- ( ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) → ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 14 : wff = sylbi (step 11, step 13) |- ( R Or A → ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 15 : wff = com12 (step 14) |- ( ( x ∈ A ∧ y ∈ A ) → ( R Or A → ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 16 : wff = vtocl2ga (step 5, step 10, step 15) |- ( ( B ∈ A ∧ C ∈ A ) → ( R Or A → ( B R C ∨ B = C ∨ C R B ) ) ) ;;
	step 17 : wff = impcom (step 16) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C ∨ B = C ∨ C R B ) ) ;;
	qed prop 1 = step 17 ;;
}

/*A strict order relation has no 2-cycle loops.  (Contributed by NM,
     21-Jan-1996.) */

theorem so2nr (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R C ∧ C R B ) ) ;;
}

proof of so2nr {
	step 1 : wff = sopo () |- ( R Or A → R Po A ) ;;
	step 2 : wff = po2nr () |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R C ∧ C R B ) ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R C ∧ C R B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A strict order relation has no 3-cycle loops.  (Contributed by NM,
     21-Jan-1996.) */

theorem so3nr (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ¬ ( B R C ∧ C R D ∧ D R B ) ) ;;
}

proof of so3nr {
	step 1 : wff = sopo () |- ( R Or A → R Po A ) ;;
	step 2 : wff = po3nr () |- ( ( R Po A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ¬ ( B R C ∧ C R D ∧ D R B ) ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ¬ ( B R C ∧ C R D ∧ D R B ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A strict order relation satisfies strict trichotomy.  (Contributed by NM,
     19-Feb-1996.) */

theorem sotric (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C ↔ ¬ ( B = C ∨ C R B ) ) ) ;;
}

proof of sotric {
	step 1 : wff = sonr () |- ( ( R Or A ∧ B ∈ A ) → ¬ B R B ) ;;
	step 2 : wff = breq2 () |- ( B = C → ( B R B ↔ B R C ) ) ;;
	step 3 : wff = notbid (step 2) |- ( B = C → ( ¬ B R B ↔ ¬ B R C ) ) ;;
	step 4 : wff = syl5ibcom (step 1, step 3) |- ( ( R Or A ∧ B ∈ A ) → ( B = C → ¬ B R C ) ) ;;
	step 5 : wff = adantrr (step 4) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C → ¬ B R C ) ) ;;
	step 6 : wff = so2nr () |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R C ∧ C R B ) ) ;;
	step 7 : wff = imnan () |- ( ( B R C → ¬ C R B ) ↔ ¬ ( B R C ∧ C R B ) ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C → ¬ C R B ) ) ;;
	step 9 : wff = con2d (step 8) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( C R B → ¬ B R C ) ) ;;
	step 10 : wff = jaod (step 5, step 9) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ( B = C ∨ C R B ) → ¬ B R C ) ) ;;
	step 11 : wff = solin () |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C ∨ B = C ∨ C R B ) ) ;;
	step 12 : wff = 3orass () |- ( ( B R C ∨ B = C ∨ C R B ) ↔ ( B R C ∨ ( B = C ∨ C R B ) ) ) ;;
	step 13 : wff = df-or () |- ( ( B R C ∨ ( B = C ∨ C R B ) ) ↔ ( ¬ B R C → ( B = C ∨ C R B ) ) ) ;;
	step 14 : wff = bitri (step 12, step 13) |- ( ( B R C ∨ B = C ∨ C R B ) ↔ ( ¬ B R C → ( B = C ∨ C R B ) ) ) ;;
	step 15 : wff = sylib (step 11, step 14) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ¬ B R C → ( B = C ∨ C R B ) ) ) ;;
	step 16 : wff = impbid (step 10, step 15) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ( B = C ∨ C R B ) ↔ ¬ B R C ) ) ;;
	step 17 : wff = con2bid (step 16) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C ↔ ¬ ( B = C ∨ C R B ) ) ) ;;
	qed prop 1 = step 17 ;;
}

/*Trichotomy law for strict order relation.  (Contributed by NM,
     9-Apr-1996.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem sotrieq (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C ↔ ¬ ( B R C ∨ C R B ) ) ) ;;
}

proof of sotrieq {
	step 1 : wff = sonr () |- ( ( R Or A ∧ B ∈ A ) → ¬ B R B ) ;;
	step 2 : wff = adantrr (step 1) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ B R B ) ;;
	step 3 : wff = pm1.2 () |- ( ( B R B ∨ B R B ) → B R B ) ;;
	step 4 : wff = nsyl (step 2, step 3) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ¬ ( B R B ∨ B R B ) ) ;;
	step 5 : wff = breq2 () |- ( B = C → ( B R B ↔ B R C ) ) ;;
	step 6 : wff = breq1 () |- ( B = C → ( B R B ↔ C R B ) ) ;;
	step 7 : wff = orbi12d (step 5, step 6) |- ( B = C → ( ( B R B ∨ B R B ) ↔ ( B R C ∨ C R B ) ) ) ;;
	step 8 : wff = notbid (step 7) |- ( B = C → ( ¬ ( B R B ∨ B R B ) ↔ ¬ ( B R C ∨ C R B ) ) ) ;;
	step 9 : wff = syl5ibcom (step 4, step 8) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C → ¬ ( B R C ∨ C R B ) ) ) ;;
	step 10 : wff = con2d (step 9) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ( B R C ∨ C R B ) → ¬ B = C ) ) ;;
	step 11 : wff = solin () |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B R C ∨ B = C ∨ C R B ) ) ;;
	step 12 : wff = 3orass () |- ( ( B R C ∨ B = C ∨ C R B ) ↔ ( B R C ∨ ( B = C ∨ C R B ) ) ) ;;
	step 13 : wff = or12 () |- ( ( B R C ∨ ( B = C ∨ C R B ) ) ↔ ( B = C ∨ ( B R C ∨ C R B ) ) ) ;;
	step 14 : wff = df-or () |- ( ( B = C ∨ ( B R C ∨ C R B ) ) ↔ ( ¬ B = C → ( B R C ∨ C R B ) ) ) ;;
	step 15 : wff = 3bitri (step 12, step 13, step 14) |- ( ( B R C ∨ B = C ∨ C R B ) ↔ ( ¬ B = C → ( B R C ∨ C R B ) ) ) ;;
	step 16 : wff = sylib (step 11, step 15) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ¬ B = C → ( B R C ∨ C R B ) ) ) ;;
	step 17 : wff = impbid (step 10, step 16) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( ( B R C ∨ C R B ) ↔ ¬ B = C ) ) ;;
	step 18 : wff = con2bid (step 17) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C ↔ ¬ ( B R C ∨ C R B ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/*Trichotomy law for strict order relation.  (Contributed by NM,
     5-May-1999.) */

theorem sotrieq2 (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C ↔ ( ¬ B R C ∧ ¬ C R B ) ) ) ;;
}

proof of sotrieq2 {
	step 1 : wff = sotrieq () |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C ↔ ¬ ( B R C ∨ C R B ) ) ) ;;
	step 2 : wff = ioran () |- ( ¬ ( B R C ∨ C R B ) ↔ ( ¬ B R C ∧ ¬ C R B ) ) ;;
	step 3 : wff = syl6bb (step 1, step 2) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( B = C ↔ ( ¬ B R C ∧ ¬ C R B ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A transitivity relation.  (Read ` B <_ C ` and ` C < D ` implies
     ` B < D ` .)  (Contributed by Mario Carneiro, 10-May-2013.) */

theorem sotr2 (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( ¬ C R B ∧ C R D ) → B R D ) ) ;;
}

proof of sotr2 {
	step 1 : wff = sotric () |- ( ( R Or A ∧ ( C ∈ A ∧ B ∈ A ) ) → ( C R B ↔ ¬ ( C = B ∨ B R C ) ) ) ;;
	step 2 : wff = ancom2s (step 1) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ) ) → ( C R B ↔ ¬ ( C = B ∨ B R C ) ) ) ;;
	step 3 : wff = 3adantr3 (step 2) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( C R B ↔ ¬ ( C = B ∨ B R C ) ) ) ;;
	step 4 : wff = con2bid (step 3) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( C = B ∨ B R C ) ↔ ¬ C R B ) ) ;;
	step 5 : wff = breq1 () |- ( C = B → ( C R D ↔ B R D ) ) ;;
	step 6 : wff = biimpd (step 5) |- ( C = B → ( C R D → B R D ) ) ;;
	step 7 : wff = a1i (step 6) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( C = B → ( C R D → B R D ) ) ) ;;
	step 8 : wff = sotr () |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( B R C ∧ C R D ) → B R D ) ) ;;
	step 9 : wff = exp3a (step 8) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( B R C → ( C R D → B R D ) ) ) ;;
	step 10 : wff = jaod (step 7, step 9) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( C = B ∨ B R C ) → ( C R D → B R D ) ) ) ;;
	step 11 : wff = sylbird (step 4, step 10) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ¬ C R B → ( C R D → B R D ) ) ) ;;
	step 12 : wff = imp3a (step 11) |- ( ( R Or A ∧ ( B ∈ A ∧ C ∈ A ∧ D ∈ A ) ) → ( ( ¬ C R B ∧ C R D ) → B R D ) ) ;;
	qed prop 1 = step 12 ;;
}

/*An irreflexive, transitive, linear relation is a strict ordering.
       (Contributed by NM, 21-Jan-1996.)  (Revised by Mario Carneiro,
       9-Jul-2014.) */

theorem issod (ph : wff, x : set, y : set, A : class, R : class) disjointed(x y R, x y A, x y ph) {
	hyp 1 : wff = |- ( ph → R Po A ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ A ) ) → ( x R y ∨ x = y ∨ y R x ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → R Or A ) ;;
}

proof of issod {
	step 1 : wff = ralrimivva (hyp 2) |- ( ph → ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 2 : wff = df-so () |- ( R Or A ↔ ( R Po A ∧ ∀ x ∈ A ∀ y ∈ A ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 3 : wff = sylanbrc (hyp 1, step 1, step 2) |- ( ph → R Or A ) ;;
	qed prop 1 = step 3 ;;
}

/*An irreflexive, transitive, linear relation is a strict ordering.
       (Contributed by NM, 21-Jan-1996.)  (Revised by Mario Carneiro,
       9-Jul-2014.) */

theorem issoi (x : set, y : set, z : set, A : class, R : class) disjointed(x y z R, x y z A) {
	hyp 1 : wff = |- ( x ∈ A → ¬ x R x ) ;;
	hyp 2 : wff = |- ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ( x R y ∧ y R z ) → x R z ) ) ;;
	hyp 3 : wff = |- ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ;;
	-----------------------
	prop 1 : wff = |- R Or A ;;
}

proof of issoi {
	step 1 : wff = adantl (hyp 1) |- ( ( T. ∧ x ∈ A ) → ¬ x R x ) ;;
	step 2 : wff = adantl (hyp 2) |- ( ( T. ∧ ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) ) → ( ( x R y ∧ y R z ) → x R z ) ) ;;
	step 3 : wff = ispod (step 1, step 2) |- ( T. → R Po A ) ;;
	step 4 : wff = adantl (hyp 3) |- ( ( T. ∧ ( x ∈ A ∧ y ∈ A ) ) → ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 5 : wff = issod (step 3, step 4) |- ( T. → R Or A ) ;;
	step 6 : wff = trud (step 5) |- R Or A ;;
	qed prop 1 = step 6 ;;
}

/*Deduce strict ordering from its properties.  (Contributed by NM,
       29-Jan-1996.)  (Revised by Mario Carneiro, 9-Jul-2014.) */

theorem isso2i (x : set, y : set, z : set, A : class, R : class) disjointed(x y z R, x y z A) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ A ) → ( x R y ↔ ¬ ( x = y ∨ y R x ) ) ) ;;
	hyp 2 : wff = |- ( ( x ∈ A ∧ y ∈ A ∧ z ∈ A ) → ( ( x R y ∧ y R z ) → x R z ) ) ;;
	-----------------------
	prop 1 : wff = |- R Or A ;;
}

proof of isso2i {
	step 1 : wff = eqid () |- x = x ;;
	step 2 : wff = orci (step 1) |- ( x = x ∨ x R x ) ;;
	step 3 : wff = eleq1 () |- ( y = x → ( y ∈ A ↔ x ∈ A ) ) ;;
	step 4 : wff = anbi2d (step 3) |- ( y = x → ( ( x ∈ A ∧ y ∈ A ) ↔ ( x ∈ A ∧ x ∈ A ) ) ) ;;
	step 5 : wff = eqeq2 () |- ( y = x → ( x = y ↔ x = x ) ) ;;
	step 6 : wff = breq1 () |- ( y = x → ( y R x ↔ x R x ) ) ;;
	step 7 : wff = orbi12d (step 5, step 6) |- ( y = x → ( ( x = y ∨ y R x ) ↔ ( x = x ∨ x R x ) ) ) ;;
	step 8 : wff = breq2 () |- ( y = x → ( x R y ↔ x R x ) ) ;;
	step 9 : wff = notbid (step 8) |- ( y = x → ( ¬ x R y ↔ ¬ x R x ) ) ;;
	step 10 : wff = bibi12d (step 7, step 9) |- ( y = x → ( ( ( x = y ∨ y R x ) ↔ ¬ x R y ) ↔ ( ( x = x ∨ x R x ) ↔ ¬ x R x ) ) ) ;;
	step 11 : wff = imbi12d (step 4, step 10) |- ( y = x → ( ( ( x ∈ A ∧ y ∈ A ) → ( ( x = y ∨ y R x ) ↔ ¬ x R y ) ) ↔ ( ( x ∈ A ∧ x ∈ A ) → ( ( x = x ∨ x R x ) ↔ ¬ x R x ) ) ) ) ;;
	step 12 : wff = con2bid (hyp 1) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( x = y ∨ y R x ) ↔ ¬ x R y ) ) ;;
	step 13 : wff = chvarv (step 11, step 12) |- ( ( x ∈ A ∧ x ∈ A ) → ( ( x = x ∨ x R x ) ↔ ¬ x R x ) ) ;;
	step 14 : wff = mpbii (step 2, step 13) |- ( ( x ∈ A ∧ x ∈ A ) → ¬ x R x ) ;;
	step 15 : wff = anidms (step 14) |- ( x ∈ A → ¬ x R x ) ;;
	step 16 : wff = con2bid (hyp 1) |- ( ( x ∈ A ∧ y ∈ A ) → ( ( x = y ∨ y R x ) ↔ ¬ x R y ) ) ;;
	step 17 : wff = biimprd (step 16) |- ( ( x ∈ A ∧ y ∈ A ) → ( ¬ x R y → ( x = y ∨ y R x ) ) ) ;;
	step 18 : wff = 3orass () |- ( ( x R y ∨ x = y ∨ y R x ) ↔ ( x R y ∨ ( x = y ∨ y R x ) ) ) ;;
	step 19 : wff = df-or () |- ( ( x R y ∨ ( x = y ∨ y R x ) ) ↔ ( ¬ x R y → ( x = y ∨ y R x ) ) ) ;;
	step 20 : wff = bitri (step 18, step 19) |- ( ( x R y ∨ x = y ∨ y R x ) ↔ ( ¬ x R y → ( x = y ∨ y R x ) ) ) ;;
	step 21 : wff = sylibr (step 17, step 20) |- ( ( x ∈ A ∧ y ∈ A ) → ( x R y ∨ x = y ∨ y R x ) ) ;;
	step 22 : wff = issoi (step 15, hyp 2, step 21) |- R Or A ;;
	qed prop 1 = step 22 ;;
}

/*Any relation is a strict ordering of the empty set.  (Contributed by NM,
       16-Mar-1997.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem so0 (R : class) disjointed(x y R) {
	prop 1 : wff = |- R Or ∅ ;;
}

proof of so0 {
	var x : set, y : set;;
	step 1 : wff = po0 () |- R Po ∅ ;;
	step 2 : wff = ral0 () |- ∀ x ∈ ∅ ∀ y ∈ ∅ ( x R y ∨ x = y ∨ y R x ) ;;
	step 3 : wff = df-so () |- ( R Or ∅ ↔ ( R Po ∅ ∧ ∀ x ∈ ∅ ∀ y ∈ ∅ ( x R y ∨ x = y ∨ y R x ) ) ) ;;
	step 4 : wff = mpbir2an (step 1, step 2, step 3) |- R Or ∅ ;;
	qed prop 1 = step 4 ;;
}

/*A totally ordered set has at most one minimal element.  (Contributed by
       Mario Carneiro, 24-Jun-2015.)  (Revised by NM, 16-Jun-2017.) */

theorem somo (x : set, y : set, A : class, R : class) disjointed(x y z A, x y z R) {
	prop 1 : wff = |- ( R Or A → ∃* x ∈ A ∀ y ∈ A ¬ y R x ) ;;
}

proof of somo {
	var z : set;;
	step 1 : wff = breq1 () |- ( y = x → ( y R z ↔ x R z ) ) ;;
	step 2 : wff = notbid (step 1) |- ( y = x → ( ¬ y R z ↔ ¬ x R z ) ) ;;
	step 3 : wff = rspcv (step 2) |- ( x ∈ A → ( ∀ y ∈ A ¬ y R z → ¬ x R z ) ) ;;
	step 4 : wff = breq1 () |- ( y = z → ( y R x ↔ z R x ) ) ;;
	step 5 : wff = notbid (step 4) |- ( y = z → ( ¬ y R x ↔ ¬ z R x ) ) ;;
	step 6 : wff = rspcv (step 5) |- ( z ∈ A → ( ∀ y ∈ A ¬ y R x → ¬ z R x ) ) ;;
	step 7 : wff = im2anan9 (step 3, step 6) |- ( ( x ∈ A ∧ z ∈ A ) → ( ( ∀ y ∈ A ¬ y R z ∧ ∀ y ∈ A ¬ y R x ) → ( ¬ x R z ∧ ¬ z R x ) ) ) ;;
	step 8 : wff = ancomsd (step 7) |- ( ( x ∈ A ∧ z ∈ A ) → ( ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) → ( ¬ x R z ∧ ¬ z R x ) ) ) ;;
	step 9 : wff = imp (step 8) |- ( ( ( x ∈ A ∧ z ∈ A ) ∧ ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) ) → ( ¬ x R z ∧ ¬ z R x ) ) ;;
	step 10 : wff = ioran () |- ( ¬ ( x R z ∨ z R x ) ↔ ( ¬ x R z ∧ ¬ z R x ) ) ;;
	step 11 : wff = solin () |- ( ( R Or A ∧ ( x ∈ A ∧ z ∈ A ) ) → ( x R z ∨ x = z ∨ z R x ) ) ;;
	step 12 : wff = df-3or () |- ( ( x R z ∨ x = z ∨ z R x ) ↔ ( ( x R z ∨ x = z ) ∨ z R x ) ) ;;
	step 13 : wff = or32 () |- ( ( ( x R z ∨ x = z ) ∨ z R x ) ↔ ( ( x R z ∨ z R x ) ∨ x = z ) ) ;;
	step 14 : wff = bitri (step 12, step 13) |- ( ( x R z ∨ x = z ∨ z R x ) ↔ ( ( x R z ∨ z R x ) ∨ x = z ) ) ;;
	step 15 : wff = sylib (step 11, step 14) |- ( ( R Or A ∧ ( x ∈ A ∧ z ∈ A ) ) → ( ( x R z ∨ z R x ) ∨ x = z ) ) ;;
	step 16 : wff = ord (step 15) |- ( ( R Or A ∧ ( x ∈ A ∧ z ∈ A ) ) → ( ¬ ( x R z ∨ z R x ) → x = z ) ) ;;
	step 17 : wff = syl5bir (step 10, step 16) |- ( ( R Or A ∧ ( x ∈ A ∧ z ∈ A ) ) → ( ( ¬ x R z ∧ ¬ z R x ) → x = z ) ) ;;
	step 18 : wff = syl5 (step 9, step 17) |- ( ( R Or A ∧ ( x ∈ A ∧ z ∈ A ) ) → ( ( ( x ∈ A ∧ z ∈ A ) ∧ ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) ) → x = z ) ) ;;
	step 19 : wff = exp4b (step 18) |- ( R Or A → ( ( x ∈ A ∧ z ∈ A ) → ( ( x ∈ A ∧ z ∈ A ) → ( ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) → x = z ) ) ) ) ;;
	step 20 : wff = pm2.43d (step 19) |- ( R Or A → ( ( x ∈ A ∧ z ∈ A ) → ( ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) → x = z ) ) ) ;;
	step 21 : wff = ralrimivv (step 20) |- ( R Or A → ∀ x ∈ A ∀ z ∈ A ( ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) → x = z ) ) ;;
	step 22 : wff = breq2 () |- ( x = z → ( y R x ↔ y R z ) ) ;;
	step 23 : wff = notbid (step 22) |- ( x = z → ( ¬ y R x ↔ ¬ y R z ) ) ;;
	step 24 : wff = ralbidv (step 23) |- ( x = z → ( ∀ y ∈ A ¬ y R x ↔ ∀ y ∈ A ¬ y R z ) ) ;;
	step 25 : wff = rmo4 (step 24) |- ( ∃* x ∈ A ∀ y ∈ A ¬ y R x ↔ ∀ x ∈ A ∀ z ∈ A ( ( ∀ y ∈ A ¬ y R x ∧ ∀ y ∈ A ¬ y R z ) → x = z ) ) ;;
	step 26 : wff = sylibr (step 21, step 25) |- ( R Or A → ∃* x ∈ A ∀ y ∈ A ¬ y R x ) ;;
	qed prop 1 = step 26 ;;
}


