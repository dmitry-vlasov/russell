import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Replacement.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            Introduce the Axiom of Power Sets

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Axiom of Power Sets.  An axiom of Zermelo-Fraenkel set theory.  It
       states that a set ` y ` exists that includes the power set of a given
       set ` x ` i.e. contains every subset of ` x ` .  The variant ~ axpow2
       uses explicit subset notation.  A version using class notation is
       ~ pwex .  (Contributed by NM, 5-Aug-1993.) */

axiom ax-pow (x : set, y : set, z : set, w : set) disjointed(x y z w) {
	prop 1 : wff = |- ∃ y ∀ z ( ∀ w ( w ∈ z → w ∈ x ) → z ∈ y ) ;;
}

/*Axiom of Power Sets expressed with the fewest number of different
       variables.  (Contributed by NM, 14-Aug-2003.) */

theorem zfpow (x : set, y : set, z : set) disjointed(x y z w) {
	prop 1 : wff = |- ∃ x ∀ y ( ∀ x ( x ∈ y → x ∈ z ) → y ∈ x ) ;;
}

proof of zfpow {
	var w : set;;
	step 1 : wff = ax-pow () |- ∃ x ∀ y ( ∀ w ( w ∈ y → w ∈ z ) → y ∈ x ) ;;
	step 2 : wff = elequ1 () |- ( w = x → ( w ∈ y ↔ x ∈ y ) ) ;;
	step 3 : wff = elequ1 () |- ( w = x → ( w ∈ z ↔ x ∈ z ) ) ;;
	step 4 : wff = imbi12d (step 2, step 3) |- ( w = x → ( ( w ∈ y → w ∈ z ) ↔ ( x ∈ y → x ∈ z ) ) ) ;;
	step 5 : wff = cbvalv (step 4) |- ( ∀ w ( w ∈ y → w ∈ z ) ↔ ∀ x ( x ∈ y → x ∈ z ) ) ;;
	step 6 : wff = imbi1i (step 5) |- ( ( ∀ w ( w ∈ y → w ∈ z ) → y ∈ x ) ↔ ( ∀ x ( x ∈ y → x ∈ z ) → y ∈ x ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ y ( ∀ w ( w ∈ y → w ∈ z ) → y ∈ x ) ↔ ∀ y ( ∀ x ( x ∈ y → x ∈ z ) → y ∈ x ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ x ∀ y ( ∀ w ( w ∈ y → w ∈ z ) → y ∈ x ) ↔ ∃ x ∀ y ( ∀ x ( x ∈ y → x ∈ z ) → y ∈ x ) ) ;;
	step 9 : wff = mpbi (step 1, step 8) |- ∃ x ∀ y ( ∀ x ( x ∈ y → x ∈ z ) → y ∈ x ) ;;
	qed prop 1 = step 9 ;;
}

/*A variant of the Axiom of Power Sets ~ ax-pow using subset notation.
       Problem in {BellMachover] p. 466.  (Contributed by NM, 4-Jun-2006.) */

theorem axpow2 (x : set, y : set, z : set) disjointed(x y z w) {
	prop 1 : wff = |- ∃ y ∀ z ( z ⊆ x → z ∈ y ) ;;
}

proof of axpow2 {
	var w : set;;
	step 1 : wff = ax-pow () |- ∃ y ∀ z ( ∀ w ( w ∈ z → w ∈ x ) → z ∈ y ) ;;
	step 2 : wff = dfss2 () |- ( z ⊆ x ↔ ∀ w ( w ∈ z → w ∈ x ) ) ;;
	step 3 : wff = imbi1i (step 2) |- ( ( z ⊆ x → z ∈ y ) ↔ ( ∀ w ( w ∈ z → w ∈ x ) → z ∈ y ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ z ( z ⊆ x → z ∈ y ) ↔ ∀ z ( ∀ w ( w ∈ z → w ∈ x ) → z ∈ y ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ∀ z ( z ⊆ x → z ∈ y ) ↔ ∃ y ∀ z ( ∀ w ( w ∈ z → w ∈ x ) → z ∈ y ) ) ;;
	step 6 : wff = mpbir (step 1, step 5) |- ∃ y ∀ z ( z ⊆ x → z ∈ y ) ;;
	qed prop 1 = step 6 ;;
}

/*A variant of the Axiom of Power Sets ~ ax-pow .  For any set ` x ` ,
       there exists a set ` y ` whose members are exactly the subsets of ` x `
       i.e. the power set of ` x ` .  Axiom Pow of [BellMachover] p. 466.
       (Contributed by NM, 4-Jun-2006.) */

theorem axpow3 (x : set, y : set, z : set) disjointed(x y z) {
	prop 1 : wff = |- ∃ y ∀ z ( z ⊆ x ↔ z ∈ y ) ;;
}

proof of axpow3 {
	step 1 : wff = axpow2 () |- ∃ y ∀ z ( z ⊆ x → z ∈ y ) ;;
	step 2 : wff = bm1.3ii (step 1) |- ∃ y ∀ z ( z ∈ y ↔ z ⊆ x ) ;;
	step 3 : wff = bicom () |- ( ( z ⊆ x ↔ z ∈ y ) ↔ ( z ∈ y ↔ z ⊆ x ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ z ( z ⊆ x ↔ z ∈ y ) ↔ ∀ z ( z ∈ y ↔ z ⊆ x ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ∀ z ( z ⊆ x ↔ z ∈ y ) ↔ ∃ y ∀ z ( z ∈ y ↔ z ⊆ x ) ) ;;
	step 6 : wff = mpbir (step 2, step 5) |- ∃ y ∀ z ( z ⊆ x ↔ z ∈ y ) ;;
	qed prop 1 = step 6 ;;
}

/*Every set is an element of some other set.  See ~ elALT for a shorter
       proof using more axioms.  (Contributed by NM, 4-Jan-2002.)  (Proof
       shortened by Andrew Salmon, 25-Jul-2011.) */

theorem el (x : set, y : set) disjointed(x y z) {
	prop 1 : wff = |- ∃ y x ∈ y ;;
}

proof of el {
	var z : set;;
	step 1 : wff = zfpow () |- ∃ y ∀ z ( ∀ y ( y ∈ z → y ∈ x ) → z ∈ y ) ;;
	step 2 : wff = ax-14 () |- ( z = x → ( y ∈ z → y ∈ x ) ) ;;
	step 3 : wff = alrimiv (step 2) |- ( z = x → ∀ y ( y ∈ z → y ∈ x ) ) ;;
	step 4 : wff = ax-13 () |- ( z = x → ( z ∈ y → x ∈ y ) ) ;;
	step 5 : wff = embantd (step 3, step 4) |- ( z = x → ( ( ∀ y ( y ∈ z → y ∈ x ) → z ∈ y ) → x ∈ y ) ) ;;
	step 6 : wff = spimv (step 5) |- ( ∀ z ( ∀ y ( y ∈ z → y ∈ x ) → z ∈ y ) → x ∈ y ) ;;
	step 7 : wff = eximi (step 6) |- ( ∃ y ∀ z ( ∀ y ( y ∈ z → y ∈ x ) → z ∈ y ) → ∃ y x ∈ y ) ;;
	step 8 : wff = ax-mp (step 1, step 7) |- ∃ y x ∈ y ;;
	qed prop 1 = step 8 ;;
}

/*Power set axiom expressed in class notation.  Axiom 4 of [TakeutiZaring]
       p. 17.  (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Andrew
       Salmon, 25-Jul-2011.) */

theorem pwex (A : class) disjointed(A x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- Pow A ∈ _V ;;
}

proof of pwex {
	var x : set, y : set, z : set;;
	step 1 : wff = pweq () |- ( z = A → Pow z = Pow A ) ;;
	step 2 : wff = eleq1d (step 1) |- ( z = A → ( Pow z ∈ _V ↔ Pow A ∈ _V ) ) ;;
	step 3 : wff = df-pw () |- Pow z = { y | y ⊆ z } ;;
	step 4 : wff = axpow2 () |- ∃ x ∀ y ( y ⊆ z → y ∈ x ) ;;
	step 5 : wff = bm1.3ii (step 4) |- ∃ x ∀ y ( y ∈ x ↔ y ⊆ z ) ;;
	step 6 : wff = abeq2 () |- ( x = { y | y ⊆ z } ↔ ∀ y ( y ∈ x ↔ y ⊆ z ) ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ x x = { y | y ⊆ z } ↔ ∃ x ∀ y ( y ∈ x ↔ y ⊆ z ) ) ;;
	step 8 : wff = mpbir (step 5, step 7) |- ∃ x x = { y | y ⊆ z } ;;
	step 9 : wff = issetri (step 8) |- { y | y ⊆ z } ∈ _V ;;
	step 10 : wff = eqeltri (step 3, step 9) |- Pow z ∈ _V ;;
	step 11 : wff = vtocl (hyp 1, step 2, step 10) |- Pow A ∈ _V ;;
	qed prop 1 = step 11 ;;
}

/*Power set axiom expressed in class notation, with the sethood
       requirement as an antecedent.  Axiom 4 of [TakeutiZaring] p. 17.
       (Contributed by NM, 30-Oct-2003.) */

theorem pwexg (A : class, V : class) disjointed(x A) {
	prop 1 : wff = |- ( A ∈ V → Pow A ∈ _V ) ;;
}

proof of pwexg {
	var x : set;;
	step 1 : wff = pweq () |- ( x = A → Pow x = Pow A ) ;;
	step 2 : wff = eleq1d (step 1) |- ( x = A → ( Pow x ∈ _V ↔ Pow A ∈ _V ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = pwex (step 3) |- Pow x ∈ _V ;;
	step 5 : wff = vtoclg (step 2, step 4) |- ( A ∈ V → Pow A ∈ _V ) ;;
	qed prop 1 = step 5 ;;
}

/*Existence of a class of subsets.  (Contributed by NM, 15-Jul-2006.)
       (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem abssexg (ph : wff, x : set, A : class, V : class) disjointed(x A) {
	prop 1 : wff = |- ( A ∈ V → { x | ( x ⊆ A ∧ ph ) } ∈ _V ) ;;
}

proof of abssexg {
	step 1 : wff = pwexg () |- ( A ∈ V → Pow A ∈ _V ) ;;
	step 2 : wff = df-pw () |- Pow A = { x | x ⊆ A } ;;
	step 3 : wff = eleq1i (step 2) |- ( Pow A ∈ _V ↔ { x | x ⊆ A } ∈ _V ) ;;
	step 4 : wff = simpl () |- ( ( x ⊆ A ∧ ph ) → x ⊆ A ) ;;
	step 5 : wff = ss2abi (step 4) |- { x | ( x ⊆ A ∧ ph ) } ⊆ { x | x ⊆ A } ;;
	step 6 : wff = ssexg () |- ( ( { x | ( x ⊆ A ∧ ph ) } ⊆ { x | x ⊆ A } ∧ { x | x ⊆ A } ∈ _V ) → { x | ( x ⊆ A ∧ ph ) } ∈ _V ) ;;
	step 7 : wff = mpan (step 5, step 6) |- ( { x | x ⊆ A } ∈ _V → { x | ( x ⊆ A ∧ ph ) } ∈ _V ) ;;
	step 8 : wff = sylbi (step 3, step 7) |- ( Pow A ∈ _V → { x | ( x ⊆ A ∧ ph ) } ∈ _V ) ;;
	step 9 : wff = syl (step 1, step 8) |- ( A ∈ V → { x | ( x ⊆ A ∧ ph ) } ∈ _V ) ;;
	qed prop 1 = step 9 ;;
}

/*A singleton is a set.  Theorem 7.13 of [Quine] p. 51, but proved using
       only Extensionality, Power Set, and Separation.  Unlike the proof of
       ~ zfpair , Replacement is not needed.  (Contributed by NM, 7-Aug-1994.)
       (Proof shortened by Andrew Salmon, 25-Jul-2011.)  See also ~ snex .
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem snexALT (A : class) disjointed(A) {
	prop 1 : wff = |- { A } ∈ _V ;;
}

proof of snexALT {
	step 1 : wff = snsspw () |- { A } ⊆ Pow A ;;
	step 2 : wff = ssexg () |- ( ( { A } ⊆ Pow A ∧ Pow A ∈ _V ) → { A } ∈ _V ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( Pow A ∈ _V → { A } ∈ _V ) ;;
	step 4 : wff = pwexg () |- ( A ∈ _V → Pow A ∈ _V ) ;;
	step 5 : wff = con3i (step 4) |- ( ¬ Pow A ∈ _V → ¬ A ∈ _V ) ;;
	step 6 : wff = snprc () |- ( ¬ A ∈ _V ↔ { A } = ∅ ) ;;
	step 7 : wff = biimpi (step 6) |- ( ¬ A ∈ _V → { A } = ∅ ) ;;
	step 8 : wff = 0ex () |- ∅ ∈ _V ;;
	step 9 : wff = syl6eqel (step 7, step 8) |- ( ¬ A ∈ _V → { A } ∈ _V ) ;;
	step 10 : wff = syl (step 5, step 9) |- ( ¬ Pow A ∈ _V → { A } ∈ _V ) ;;
	step 11 : wff = pm2.61i (step 3, step 10) |- { A } ∈ _V ;;
	qed prop 1 = step 11 ;;
}

/*The power set of the empty set (the ordinal 1) is a set.  See also
     ~ p0exALT .  (Contributed by NM, 23-Dec-1993.) */

theorem p0ex ()  {
	prop 1 : wff = |- { ∅ } ∈ _V ;;
}

proof of p0ex {
	step 1 : wff = pw0 () |- Pow ∅ = { ∅ } ;;
	step 2 : wff = 0ex () |- ∅ ∈ _V ;;
	step 3 : wff = pwex (step 2) |- Pow ∅ ∈ _V ;;
	step 4 : wff = eqeltrri (step 1, step 3) |- { ∅ } ∈ _V ;;
	qed prop 1 = step 4 ;;
}

/*The power set of the empty set (the ordinal 1) is a set.  Alternate proof
     which is longer and quite different from the proof of ~ p0ex if ~ snexALT
     is expanded.  (Contributed by NM, 23-Dec-1993.)
     (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem p0exALT ()  {
	prop 1 : wff = |- { ∅ } ∈ _V ;;
}

proof of p0exALT {
	step 1 : wff = snexALT () |- { ∅ } ∈ _V ;;
	qed prop 1 = step 1 ;;
}

/*The power set of the power set of the empty set (the ordinal 2) is a set.
     (Contributed by NM, 5-Aug-1993.) */

theorem pp0ex ()  {
	prop 1 : wff = |- { ∅ , { ∅ } } ∈ _V ;;
}

proof of pp0ex {
	step 1 : wff = pwpw0 () |- Pow { ∅ } = { ∅ , { ∅ } } ;;
	step 2 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 3 : wff = pwex (step 2) |- Pow { ∅ } ∈ _V ;;
	step 4 : wff = eqeltrri (step 1, step 3) |- { ∅ , { ∅ } } ∈ _V ;;
	qed prop 1 = step 4 ;;
}

/*The ordinal number 3 is a set, proved without the Axiom of Union
     ~ ax-un .  (Contributed by NM, 2-May-2009.) */

theorem ord3ex ()  {
	prop 1 : wff = |- { ∅ , { ∅ } , { ∅ , { ∅ } } } ∈ _V ;;
}

proof of ord3ex {
	step 1 : wff = df-tp () |- { ∅ , { ∅ } , { ∅ , { ∅ } } } = ( { ∅ , { ∅ } } ∪ { { ∅ , { ∅ } } } ) ;;
	step 2 : wff = pwpr () |- Pow { ∅ , { ∅ } } = ( { ∅ , { ∅ } } ∪ { { { ∅ } } , { ∅ , { ∅ } } } ) ;;
	step 3 : wff = pp0ex () |- { ∅ , { ∅ } } ∈ _V ;;
	step 4 : wff = pwex (step 3) |- Pow { ∅ , { ∅ } } ∈ _V ;;
	step 5 : wff = eqeltrri (step 2, step 4) |- ( { ∅ , { ∅ } } ∪ { { { ∅ } } , { ∅ , { ∅ } } } ) ∈ _V ;;
	step 6 : wff = snsspr2 () |- { { ∅ , { ∅ } } } ⊆ { { { ∅ } } , { ∅ , { ∅ } } } ;;
	step 7 : wff = unss2 () |- ( { { ∅ , { ∅ } } } ⊆ { { { ∅ } } , { ∅ , { ∅ } } } → ( { ∅ , { ∅ } } ∪ { { ∅ , { ∅ } } } ) ⊆ ( { ∅ , { ∅ } } ∪ { { { ∅ } } , { ∅ , { ∅ } } } ) ) ;;
	step 8 : wff = ax-mp (step 6, step 7) |- ( { ∅ , { ∅ } } ∪ { { ∅ , { ∅ } } } ) ⊆ ( { ∅ , { ∅ } } ∪ { { { ∅ } } , { ∅ , { ∅ } } } ) ;;
	step 9 : wff = ssexi (step 5, step 8) |- ( { ∅ , { ∅ } } ∪ { { ∅ , { ∅ } } } ) ∈ _V ;;
	step 10 : wff = eqeltri (step 1, step 9) |- { ∅ , { ∅ } , { ∅ , { ∅ } } } ∈ _V ;;
	qed prop 1 = step 10 ;;
}

/*At least two sets exist (or in terms of first-order logic, the universe
       of discourse has two or more objects).  Note that we may not substitute
       the same variable for both ` x ` and ` y ` (as indicated by the distinct
       variable requirement), for otherwise we would contradict ~ stdpc6 .

       This theorem is proved directly from set theory axioms (no set theory
       definitions) and does not use ~ ax-ext or ~ ax-sep .  See ~ dtruALT for
       a shorter proof using these axioms.

       The proof makes use of dummy variables ` z ` and ` w ` which do not
       appear in the final theorem.  They must be distinct from each other and
       from ` x ` and ` y ` .  In other words, if we were to substitute ` x `
       for ` z ` throughout the proof, the proof would fail.  Although this
       requirement is made explicitly in the set.mm source file, it is implicit
       on the web page (i.e. doesn't appear in the "Distinct variable group").
       (Contributed by NM, 7-Nov-2006.) */

theorem dtru (x : set, y : set) disjointed(w x y z) {
	prop 1 : wff = |- ¬ ∀ x x = y ;;
}

proof of dtru {
	var z : set, w : set;;
	step 1 : wff = el () |- ∃ w x ∈ w ;;
	step 2 : wff = ax-nul () |- ∃ z ∀ x ¬ x ∈ z ;;
	step 3 : wff = sp () |- ( ∀ x ¬ x ∈ z → ¬ x ∈ z ) ;;
	step 4 : wff = eximi (step 3) |- ( ∃ z ∀ x ¬ x ∈ z → ∃ z ¬ x ∈ z ) ;;
	step 5 : wff = ax-mp (step 2, step 4) |- ∃ z ¬ x ∈ z ;;
	step 6 : wff = eeanv () |- ( ∃ w ∃ z ( x ∈ w ∧ ¬ x ∈ z ) ↔ ( ∃ w x ∈ w ∧ ∃ z ¬ x ∈ z ) ) ;;
	step 7 : wff = mpbir2an (step 1, step 5, step 6) |- ∃ w ∃ z ( x ∈ w ∧ ¬ x ∈ z ) ;;
	step 8 : wff = ax-14 () |- ( w = z → ( x ∈ w → x ∈ z ) ) ;;
	step 9 : wff = com12 (step 8) |- ( x ∈ w → ( w = z → x ∈ z ) ) ;;
	step 10 : wff = con3and (step 9) |- ( ( x ∈ w ∧ ¬ x ∈ z ) → ¬ w = z ) ;;
	step 11 : wff = 2eximi (step 10) |- ( ∃ w ∃ z ( x ∈ w ∧ ¬ x ∈ z ) → ∃ w ∃ z ¬ w = z ) ;;
	step 12 : wff = ax-mp (step 7, step 11) |- ∃ w ∃ z ¬ w = z ;;
	step 13 : wff = equequ2 () |- ( z = y → ( w = z ↔ w = y ) ) ;;
	step 14 : wff = notbid (step 13) |- ( z = y → ( ¬ w = z ↔ ¬ w = y ) ) ;;
	step 15 : wff = ax-8 () |- ( x = w → ( x = y → w = y ) ) ;;
	step 16 : wff = con3d (step 15) |- ( x = w → ( ¬ w = y → ¬ x = y ) ) ;;
	step 17 : wff = spimev (step 16) |- ( ¬ w = y → ∃ x ¬ x = y ) ;;
	step 18 : wff = syl6bi (step 14, step 17) |- ( z = y → ( ¬ w = z → ∃ x ¬ x = y ) ) ;;
	step 19 : wff = ax-8 () |- ( x = z → ( x = y → z = y ) ) ;;
	step 20 : wff = con3d (step 19) |- ( x = z → ( ¬ z = y → ¬ x = y ) ) ;;
	step 21 : wff = spimev (step 20) |- ( ¬ z = y → ∃ x ¬ x = y ) ;;
	step 22 : wff = a1d (step 21) |- ( ¬ z = y → ( ¬ w = z → ∃ x ¬ x = y ) ) ;;
	step 23 : wff = pm2.61i (step 18, step 22) |- ( ¬ w = z → ∃ x ¬ x = y ) ;;
	step 24 : wff = exlimivv (step 23) |- ( ∃ w ∃ z ¬ w = z → ∃ x ¬ x = y ) ;;
	step 25 : wff = ax-mp (step 12, step 24) |- ∃ x ¬ x = y ;;
	step 26 : wff = exnal () |- ( ∃ x ¬ x = y ↔ ¬ ∀ x x = y ) ;;
	step 27 : wff = mpbi (step 25, step 26) |- ¬ ∀ x x = y ;;
	qed prop 1 = step 27 ;;
}

/*This theorem shows that axiom ~ ax-16 is redundant in the presence of
       theorem ~ dtru , which states simply that at least two things exist.
       This justifies the remark at
       ~ http://us.metamath.org/mpeuni/mmzfcnd.html#twoness (which links to
       this theorem).  (Contributed by NM, 7-Nov-2006.) */

theorem ax16b (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
}

proof of ax16b {
	step 1 : wff = dtru () |- ¬ ∀ x x = y ;;
	step 2 : wff = pm2.21i (step 1) |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Existential uniqueness implies there is a value for which the wff
       argument is false.  (Contributed by NM, 24-Oct-2010.) */

theorem eunex (ph : wff, x : set) disjointed(x y, y ph) {
	prop 1 : wff = |- ( ∃! x ph → ∃ x ¬ ph ) ;;
}

proof of eunex {
	var y : set;;
	step 1 : wff = dtru () |- ¬ ∀ x x = y ;;
	step 2 : wff = alim () |- ( ∀ x ( ph → x = y ) → ( ∀ x ph → ∀ x x = y ) ) ;;
	step 3 : wff = mtoi (step 1, step 2) |- ( ∀ x ( ph → x = y ) → ¬ ∀ x ph ) ;;
	step 4 : wff = exlimiv (step 3) |- ( ∃ y ∀ x ( ph → x = y ) → ¬ ∀ x ph ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) → ¬ ∀ x ph ) ;;
	step 6 : wff = nfv () |- F/ y ph ;;
	step 7 : wff = eu3 (step 6) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 8 : wff = exnal () |- ( ∃ x ¬ ph ↔ ¬ ∀ x ph ) ;;
	step 9 : wff = 3imtr4i (step 5, step 7, step 8) |- ( ∃! x ph → ∃ x ¬ ph ) ;;
	qed prop 1 = step 9 ;;
}

/*A set variable is not free from itself.  The proof relies on ~ dtru ,
       that is, it is not true in a one-element domain.  (Contributed by Mario
       Carneiro, 8-Oct-2016.) */

theorem nfnid (x : set) disjointed(w x y z) {
	prop 1 : wff = |- ¬ F/_ x x ;;
}

proof of nfnid {
	var y : set, z : set, w : set;;
	step 1 : wff = dtru () |- ¬ ∀ z z = w ;;
	step 2 : wff = ax-ext () |- ( ∀ y ( y ∈ z ↔ y ∈ w ) → z = w ) ;;
	step 3 : wff = sps (step 2) |- ( ∀ w ∀ y ( y ∈ z ↔ y ∈ w ) → z = w ) ;;
	step 4 : wff = alimi (step 3) |- ( ∀ z ∀ w ∀ y ( y ∈ z ↔ y ∈ w ) → ∀ z z = w ) ;;
	step 5 : wff = mto (step 1, step 4) |- ¬ ∀ z ∀ w ∀ y ( y ∈ z ↔ y ∈ w ) ;;
	step 6 : wff = df-nfc () |- ( F/_ x x ↔ ∀ y F/ x y ∈ x ) ;;
	step 7 : wff = sbnf2 () |- ( F/ x y ∈ x ↔ ∀ z ∀ w ( [ z / x ] y ∈ x ↔ [ w / x ] y ∈ x ) ) ;;
	step 8 : wff = elsb4 () |- ( [ z / x ] y ∈ x ↔ y ∈ z ) ;;
	step 9 : wff = elsb4 () |- ( [ w / x ] y ∈ x ↔ y ∈ w ) ;;
	step 10 : wff = bibi12i (step 8, step 9) |- ( ( [ z / x ] y ∈ x ↔ [ w / x ] y ∈ x ) ↔ ( y ∈ z ↔ y ∈ w ) ) ;;
	step 11 : wff = 2albii (step 10) |- ( ∀ z ∀ w ( [ z / x ] y ∈ x ↔ [ w / x ] y ∈ x ) ↔ ∀ z ∀ w ( y ∈ z ↔ y ∈ w ) ) ;;
	step 12 : wff = bitri (step 7, step 11) |- ( F/ x y ∈ x ↔ ∀ z ∀ w ( y ∈ z ↔ y ∈ w ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ y F/ x y ∈ x ↔ ∀ y ∀ z ∀ w ( y ∈ z ↔ y ∈ w ) ) ;;
	step 14 : wff = alrot3 () |- ( ∀ y ∀ z ∀ w ( y ∈ z ↔ y ∈ w ) ↔ ∀ z ∀ w ∀ y ( y ∈ z ↔ y ∈ w ) ) ;;
	step 15 : wff = 3bitri (step 6, step 13, step 14) |- ( F/_ x x ↔ ∀ z ∀ w ∀ y ( y ∈ z ↔ y ∈ w ) ) ;;
	step 16 : wff = mtbir (step 5, step 15) |- ¬ F/_ x x ;;
	qed prop 1 = step 16 ;;
}

/*The "distinctor" expression ` -. A. x x = y ` , stating that ` x ` and
       ` y ` are not the same variable, can be written in terms of ` F/ ` in
       the obvious way.  This theorem is not true in a one-element domain,
       because then ` F/_ x y ` and ` A. x x = y ` will both be true.
       (Contributed by Mario Carneiro, 8-Oct-2016.) */

theorem nfcvb (x : set, y : set) disjointed(x y, x, y) {
	prop 1 : wff = |- ( F/_ x y ↔ ¬ ∀ x x = y ) ;;
}

proof of nfcvb {
	step 1 : wff = nfnid () |- ¬ F/_ y y ;;
	step 2 : wff = eqidd () |- ( ∀ x x = y → y = y ) ;;
	step 3 : wff = drnfc1 (step 2) |- ( ∀ x x = y → ( F/_ x y ↔ F/_ y y ) ) ;;
	step 4 : wff = mtbiri (step 1, step 3) |- ( ∀ x x = y → ¬ F/_ x y ) ;;
	step 5 : wff = con2i (step 4) |- ( F/_ x y → ¬ ∀ x x = y ) ;;
	step 6 : wff = nfcvf () |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	step 7 : wff = impbii (step 5, step 6) |- ( F/_ x y ↔ ¬ ∀ x x = y ) ;;
	qed prop 1 = step 7 ;;
}

/*A class is a subclass of the power class of its union.  Exercise 6(b) of
       [Enderton] p. 38.  (Contributed by NM, 14-Oct-1996.) */

theorem pwuni (A : class) disjointed(A x) {
	prop 1 : wff = |- A ⊆ Pow ⋃ A ;;
}

proof of pwuni {
	var x : set;;
	step 1 : wff = elssuni () |- ( x ∈ A → x ⊆ ⋃ A ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = elpw (step 2) |- ( x ∈ Pow ⋃ A ↔ x ⊆ ⋃ A ) ;;
	step 4 : wff = sylibr (step 1, step 3) |- ( x ∈ A → x ∈ Pow ⋃ A ) ;;
	step 5 : wff = ssriv (step 4) |- A ⊆ Pow ⋃ A ;;
	qed prop 1 = step 5 ;;
}

/*A version of ~ dtru ("two things exist") with a shorter proof that uses
       more axioms but may be easier to understand.

       Assuming that ZF set theory is consistent, we cannot prove this theorem
       unless we specify that ` x ` and ` y ` be distinct.  Specifically,
       theorem ~ spcev requires that ` x ` must not occur in the subexpression
       ` -. y = { (/) } ` in step 4 nor in the subexpression ` -. y = (/) ` in
       step 9.  The proof verifier will require that ` x ` and ` y ` be in a
       distinct variable group to ensure this.  You can check this by deleting
       the $d statement in set.mm and rerunning the verifier, which will print
       a detailed explanation of the distinct variable violation.  (Contributed
       by NM, 15-Jul-1994.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem dtruALT (x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ¬ ∀ x x = y ;;
}

proof of dtruALT {
	step 1 : wff = 0inp0 () |- ( y = ∅ → ¬ y = { ∅ } ) ;;
	step 2 : wff = p0ex () |- { ∅ } ∈ _V ;;
	step 3 : wff = eqeq2 () |- ( x = { ∅ } → ( y = x ↔ y = { ∅ } ) ) ;;
	step 4 : wff = notbid (step 3) |- ( x = { ∅ } → ( ¬ y = x ↔ ¬ y = { ∅ } ) ) ;;
	step 5 : wff = spcev (step 2, step 4) |- ( ¬ y = { ∅ } → ∃ x ¬ y = x ) ;;
	step 6 : wff = syl (step 1, step 5) |- ( y = ∅ → ∃ x ¬ y = x ) ;;
	step 7 : wff = 0ex () |- ∅ ∈ _V ;;
	step 8 : wff = eqeq2 () |- ( x = ∅ → ( y = x ↔ y = ∅ ) ) ;;
	step 9 : wff = notbid (step 8) |- ( x = ∅ → ( ¬ y = x ↔ ¬ y = ∅ ) ) ;;
	step 10 : wff = spcev (step 7, step 9) |- ( ¬ y = ∅ → ∃ x ¬ y = x ) ;;
	step 11 : wff = pm2.61i (step 6, step 10) |- ∃ x ¬ y = x ;;
	step 12 : wff = exnal () |- ( ∃ x ¬ y = x ↔ ¬ ∀ x y = x ) ;;
	step 13 : wff = eqcom () |- ( y = x ↔ x = y ) ;;
	step 14 : wff = albii (step 13) |- ( ∀ x y = x ↔ ∀ x x = y ) ;;
	step 15 : wff = xchbinx (step 12, step 14) |- ( ∃ x ¬ y = x ↔ ¬ ∀ x x = y ) ;;
	step 16 : wff = mpbi (step 11, step 15) |- ¬ ∀ x x = y ;;
	qed prop 1 = step 16 ;;
}

/*Corollary of ~ dtru .  This example illustrates the danger of blindly
       trusting the standard Deduction Theorem without accounting for free
       variables: the theorem form of this deduction is not valid, as shown by
       ~ dtrucor2 .  (Contributed by NM, 27-Jun-2002.) */

theorem dtrucor (x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- x = y ;;
	-----------------------
	prop 1 : wff = |- x ≠ y ;;
}

proof of dtrucor {
	step 1 : wff = dtru () |- ¬ ∀ x x = y ;;
	step 2 : wff = pm2.21i (step 1) |- ( ∀ x x = y → x ≠ y ) ;;
	step 3 : wff = mpg (step 2, hyp 1) |- x ≠ y ;;
	qed prop 1 = step 3 ;;
}

/*The theorem form of the deduction ~ dtrucor leads to a contradiction, as
       mentioned in the "Wrong!" example at
       ~ http://us.metamath.org/mpeuni/mmdeduction.html#bad .  (Contributed by
       NM, 20-Oct-2007.) */

theorem dtrucor2 (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( x = y → x ≠ y ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ∧ ¬ ph ) ;;
}

proof of dtrucor2 {
	step 1 : wff = a9e () |- ∃ x x = y ;;
	step 2 : wff = necon2bi (hyp 1) |- ( x = y → ¬ x = y ) ;;
	step 3 : wff = pm2.01 () |- ( ( x = y → ¬ x = y ) → ¬ x = y ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ¬ x = y ;;
	step 5 : wff = nex (step 4) |- ¬ ∃ x x = y ;;
	step 6 : wff = pm2.24ii (step 1, step 5) |- ( ph ∧ ¬ ph ) ;;
	qed prop 1 = step 6 ;;
}

/*Demonstration of a theorem (scheme) that requires (meta)variables ` x `
       and ` y ` to be distinct, but no others.  It bundles the theorem schemes
       ` E. x ( x = y -> x e. x ) ` and ` E. x ( x = y -> y e. x ) ` .  Compare
       ~ dvdemo2 .  ("Bundles" is a term introduced by Raph Levien.)
       (Contributed by NM, 1-Dec-2006.) */

theorem dvdemo1 (x : set, y : set, z : set) disjointed(x y) {
	prop 1 : wff = |- ∃ x ( x = y → z ∈ x ) ;;
}

proof of dvdemo1 {
	step 1 : wff = dtru () |- ¬ ∀ x x = y ;;
	step 2 : wff = exnal () |- ( ∃ x ¬ x = y ↔ ¬ ∀ x x = y ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- ∃ x ¬ x = y ;;
	step 4 : wff = pm2.21 () |- ( ¬ x = y → ( x = y → z ∈ x ) ) ;;
	step 5 : wff = eximi (step 4) |- ( ∃ x ¬ x = y → ∃ x ( x = y → z ∈ x ) ) ;;
	step 6 : wff = ax-mp (step 3, step 5) |- ∃ x ( x = y → z ∈ x ) ;;
	qed prop 1 = step 6 ;;
}

/*Demonstration of a theorem (scheme) that requires (meta)variables ` x `
       and ` z ` to be distinct, but no others.  It bundles the theorem schemes
       ` E. x ( x = x -> z e. x ) ` and ` E. x ( x = y -> y e. x ) ` .  Compare
       ~ dvdemo1 .  (Contributed by NM, 1-Dec-2006.) */

theorem dvdemo2 (x : set, y : set, z : set) disjointed(x z) {
	prop 1 : wff = |- ∃ x ( x = y → z ∈ x ) ;;
}

proof of dvdemo2 {
	step 1 : wff = el () |- ∃ x z ∈ x ;;
	step 2 : wff = ax-1 () |- ( z ∈ x → ( x = y → z ∈ x ) ) ;;
	step 3 : wff = eximi (step 2) |- ( ∃ x z ∈ x → ∃ x ( x = y → z ∈ x ) ) ;;
	step 4 : wff = ax-mp (step 1, step 3) |- ∃ x ( x = y → z ∈ x ) ;;
	qed prop 1 = step 4 ;;
}


