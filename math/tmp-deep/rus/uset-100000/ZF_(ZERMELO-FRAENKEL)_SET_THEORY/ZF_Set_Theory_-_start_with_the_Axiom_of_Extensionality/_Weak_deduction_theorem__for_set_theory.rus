import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/The_empty_set.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           "Weak deduction theorem" for set theory

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  In a Hilbert system of logic (which consists of a set of axioms, modus
  ponens, and the generalization rule), converting a deduction to a proof using
  the Deduction Theorem (taught in introductory logic books) involves an
  exponential increase of the number of steps as hypotheses are successively
  eliminated.  Here is a trick that is not as general as the Deduction Theorem
  but requires only a linear increase in the number of steps.

  The general problem:  We want to convert a deduction
    P |- Q
  into a proof of the theorem
    |- P -> Q
  i.e. we want to eliminate the hypothesis P.  Normally this is done using the
  Deduction (meta)Theorem, which looks at the microscopic steps of the
  deduction and usually doubles or triples the number of these microscopic
  steps for each hypothesis that is eliminated.  We will look at a special case
  of this problem, without appealing to the Deduction Theorem.

  We assume ZF with class notation.  A and B are arbitrary (possibly
  proper) classes.  P, Q, R, S and T are wffs.

  We define the conditional operator, if(P,A,B), as follows:
    if(P,A,B) =def= { x | (x \in A & P) v (x \in B & -. P) }
  (where x does not occur in A, B, or P).

  Lemma 1.
    A = if(P,A,B) -> (P <-> R), B = if(P,A,B) -> (S <-> R), S |- R
  Proof:  Logic and Axiom of Extensionality.

  Lemma 2.
    A = if(P,A,B) -> (Q <-> T), T |- P -> Q
  Proof:  Logic and Axiom of Extensionality.

  Here's a simple example that illustrates how it works.  Suppose we have
  a deduction
    Ord A |- Tr A
  which means, "Assume A is an ordinal class.  Then A is a transitive class."
  Note that A is a class variable that may be substituted with any class
  expression, so this is really a deduction scheme.

  We want to convert this to a proof of the theorem (scheme)
    |- Ord A -> Tr A.

  The catch is that we must be able to prove "Ord A" for at least one
  object A (and this is what makes it weaker than the ordinary Deduction
  Theorem).  However, it is easy to prove |- Ord 0 (the empty set is
  ordinal).  (For a typical textbook "theorem," i.e. deduction, there is
  usually at least one object satisfying each hypothesis, otherwise the
  theorem would not be very useful.  We can always go back to the standard
  Deduction Theorem for those hypotheses where this is not the case.)
  Continuing with the example:

  Equality axioms (and Extensionality) yield
    |- A = if(Ord A, A, 0) -> (Ord A <-> Ord if(Ord A, A, 0))  (1)
    |- 0 = if(Ord A, A, 0) -> (Ord 0 <-> Ord if(Ord A, A, 0))  (2)
  From (1), (2) and |- Ord 0, Lemma 1 yields
    |- Ord if(Ord A, A, 0)                                       (3)
  From (3) and substituting if(Ord A, A, 0) for
  A in the original deduction,
    |- Tr if(Ord A, A, 0)                                        (4)
  Equality axioms (and Extensionality) yield
    |- A = if(Ord A, A, 0) -> (Tr A <-> Tr if(Ord A, A, 0))    (5)
  From (4) and (5), Lemma 2 yields
    |- Ord A -> Tr A                                               (Q.E.D.)

*/

/* These lemmas are used to convert hypotheses into antecedents,
     when there is at least one class making the hypothesis true. */

/* Declare new constant symbols. */

constant {
	symbol if ;;
}

/* Conditional operator (was "ded" for "deduction class"). */

/* Extend class notation to include the conditional operator.  See ~ df-if
     for a description.  (In older databases this was denoted "ded".) */

rule cif (ph : wff, A : class, B : class) {
	term : class = # if ( ph , A , B ) ;;
}

/* Define the conditional operator.  Read ` if ( ph , A , B ) ` as "if
       ` ph ` then ` A ` else ` B ` ."  See ~ iftrue and ~ iffalse for its
       values.  In mathematical literature, this operator is rarely defined
       formally but is implicit in informal definitions such as "let f(x)=0 if
       x=0 and 1/x otherwise."  (In older versions of this database, this
       operator was denoted "ded" and called the "deduction class.")

       An important use for us is in conjunction with the weak deduction
       theorem, which converts a hypothesis into an antecedent.  In that role,
       ` A ` is a class variable in the hypothesis and ` B ` is a class
       (usually a constant) that makes the hypothesis true when it is
       substituted for ` A ` .  See ~ dedth for the main part of the weak
       deduction theorem, ~ elimhyp to eliminate a hypothesis, and ~ keephyp to
       keep a hypothesis.  See the Deduction Theorem link on the Metamath Proof
       Explorer Home Page for a description of the weak deduction theorem.
       (Contributed by NM, 15-May-1999.) */

definition df-if (ph : wff, x : set, A : class, B : class) disjointed(x ph, x A, x B) {
	defiendum : class = # if ( ph , A , B ) ;;
	definiens : class = # { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* An alternate definition of the conditional operator ~ df-if with one
       fewer connectives (but probably less intuitive to understand).
       (Contributed by NM, 30-Jan-2006.) */

theorem dfif2 (ph : wff, x : set, A : class, B : class) disjointed(x ph, x A, x B) {
	prop 1 : wff = |- if ( ph , A , B ) = { x | ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) } ;;
}

proof of dfif2 {
	step 1 : wff = df-if () |- if ( ph , A , B ) = { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } ;;
	step 2 : wff = df-or () |- ( ( ( x ∈ B ∧ ¬ ph ) ∨ ( x ∈ A ∧ ph ) ) ↔ ( ¬ ( x ∈ B ∧ ¬ ph ) → ( x ∈ A ∧ ph ) ) ) ;;
	step 3 : wff = orcom () |- ( ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) ↔ ( ( x ∈ B ∧ ¬ ph ) ∨ ( x ∈ A ∧ ph ) ) ) ;;
	step 4 : wff = iman () |- ( ( x ∈ B → ph ) ↔ ¬ ( x ∈ B ∧ ¬ ph ) ) ;;
	step 5 : wff = imbi1i (step 4) |- ( ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) ↔ ( ¬ ( x ∈ B ∧ ¬ ph ) → ( x ∈ A ∧ ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 2, step 3, step 5) |- ( ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) ↔ ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) ) ;;
	step 7 : wff = abbii (step 6) |- { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } = { x | ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) } ;;
	step 8 : wff = eqtri (step 1, step 7) |- if ( ph , A , B ) = { x | ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) } ;;
	qed prop 1 = step 8 ;;
}

/* An alternate definition of the conditional operator ~ df-if as a simple
       class abstraction.  (Contributed by Mario Carneiro, 8-Sep-2013.) */

theorem dfif6 (ph : wff, x : set, A : class, B : class) disjointed(x ph, x A, x B) {
	prop 1 : wff = |- if ( ph , A , B ) = ( { x ∈ A | ph } ∪ { x ∈ B | ¬ ph } ) ;;
}

proof of dfif6 {
	step 1 : wff = unab () |- ( { x | ( x ∈ A ∧ ph ) } ∪ { x | ( x ∈ B ∧ ¬ ph ) } ) = { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } ;;
	step 2 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 3 : wff = df-rab () |- { x ∈ B | ¬ ph } = { x | ( x ∈ B ∧ ¬ ph ) } ;;
	step 4 : wff = uneq12i (step 2, step 3) |- ( { x ∈ A | ph } ∪ { x ∈ B | ¬ ph } ) = ( { x | ( x ∈ A ∧ ph ) } ∪ { x | ( x ∈ B ∧ ¬ ph ) } ) ;;
	step 5 : wff = df-if () |- if ( ph , A , B ) = { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } ;;
	step 6 : wff = 3eqtr4ri (step 1, step 4, step 5) |- if ( ph , A , B ) = ( { x ∈ A | ph } ∪ { x ∈ B | ¬ ph } ) ;;
	qed prop 1 = step 6 ;;
}

/* Equality theorem for conditional operator.  (Contributed by NM,
       1-Sep-2004.)  (Revised by Mario Carneiro, 8-Sep-2013.) */

theorem ifeq1 (ph : wff, A : class, B : class, C : class) disjointed(x ph, x A, x B, x C) {
	prop 1 : wff = |- ( A = B → if ( ph , A , C ) = if ( ph , B , C ) ) ;;
}

proof of ifeq1 {
	var x : set;;
	step 1 : wff = rabeq () |- ( A = B → { x ∈ A | ph } = { x ∈ B | ph } ) ;;
	step 2 : wff = uneq1d (step 1) |- ( A = B → ( { x ∈ A | ph } ∪ { x ∈ C | ¬ ph } ) = ( { x ∈ B | ph } ∪ { x ∈ C | ¬ ph } ) ) ;;
	step 3 : wff = dfif6 () |- if ( ph , A , C ) = ( { x ∈ A | ph } ∪ { x ∈ C | ¬ ph } ) ;;
	step 4 : wff = dfif6 () |- if ( ph , B , C ) = ( { x ∈ B | ph } ∪ { x ∈ C | ¬ ph } ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → if ( ph , A , C ) = if ( ph , B , C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Equality theorem for conditional operator.  (Contributed by NM,
       1-Sep-2004.)  (Revised by Mario Carneiro, 8-Sep-2013.) */

theorem ifeq2 (ph : wff, A : class, B : class, C : class) disjointed(x ph, x A, x B, x C) {
	prop 1 : wff = |- ( A = B → if ( ph , C , A ) = if ( ph , C , B ) ) ;;
}

proof of ifeq2 {
	var x : set;;
	step 1 : wff = rabeq () |- ( A = B → { x ∈ A | ¬ ph } = { x ∈ B | ¬ ph } ) ;;
	step 2 : wff = uneq2d (step 1) |- ( A = B → ( { x ∈ C | ph } ∪ { x ∈ A | ¬ ph } ) = ( { x ∈ C | ph } ∪ { x ∈ B | ¬ ph } ) ) ;;
	step 3 : wff = dfif6 () |- if ( ph , C , A ) = ( { x ∈ C | ph } ∪ { x ∈ A | ¬ ph } ) ;;
	step 4 : wff = dfif6 () |- if ( ph , C , B ) = ( { x ∈ C | ph } ∪ { x ∈ B | ¬ ph } ) ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → if ( ph , C , A ) = if ( ph , C , B ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Value of the conditional operator when its first argument is true.
       (Contributed by NM, 15-May-1999.)  (Proof shortened by Andrew Salmon,
       26-Jun-2011.) */

theorem iftrue (ph : wff, A : class, B : class) disjointed(x ph, x A, x B) {
	prop 1 : wff = |- ( ph → if ( ph , A , B ) = A ) ;;
}

proof of iftrue {
	var x : set;;
	step 1 : wff = dedlem0a () |- ( ph → ( x ∈ A ↔ ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) ) ) ;;
	step 2 : wff = abbi2dv (step 1) |- ( ph → A = { x | ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) } ) ;;
	step 3 : wff = dfif2 () |- if ( ph , A , B ) = { x | ( ( x ∈ B → ph ) → ( x ∈ A ∧ ph ) ) } ;;
	step 4 : wff = syl6reqr (step 2, step 3) |- ( ph → if ( ph , A , B ) = A ) ;;
	qed prop 1 = step 4 ;;
}

/* Value of the conditional operator when its first argument is false.
       (Contributed by NM, 14-Aug-1999.) */

theorem iffalse (ph : wff, A : class, B : class) disjointed(x ph, x A, x B) {
	prop 1 : wff = |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
}

proof of iffalse {
	var x : set;;
	step 1 : wff = dedlemb () |- ( ¬ ph → ( x ∈ B ↔ ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) ) ) ;;
	step 2 : wff = abbi2dv (step 1) |- ( ¬ ph → B = { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } ) ;;
	step 3 : wff = df-if () |- if ( ph , A , B ) = { x | ( ( x ∈ A ∧ ph ) ∨ ( x ∈ B ∧ ¬ ph ) ) } ;;
	step 4 : wff = syl6reqr (step 2, step 3) |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	qed prop 1 = step 4 ;;
}

/* When values are unequal, but an "if" condition checks if they are equal,
     then the "false" branch results.  This is a simple utility to provide a
     slight shortening and simplification of proofs vs. applying ~ iffalse
     directly in this case.  It happens, e.g., in ~ oevn0 .  (Contributed by
     David A. Wheeler, 15-May-2015.) */

theorem ifnefalse (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( A ≠ B → if ( A = B , C , D ) = D ) ;;
}

proof of ifnefalse {
	step 1 : wff = df-ne () |- ( A ≠ B ↔ ¬ A = B ) ;;
	step 2 : wff = iffalse () |- ( ¬ A = B → if ( A = B , C , D ) = D ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( A ≠ B → if ( A = B , C , D ) = D ) ;;
	qed prop 1 = step 3 ;;
}

/* Distribute a function over an if-clause.  (Contributed by Mario
       Carneiro, 14-Aug-2013.) */

theorem ifsb (ph : wff, A : class, B : class, C : class, D : class, E : class)  {
	hyp 1 : wff = |- ( if ( ph , A , B ) = A → C = D ) ;;
	hyp 2 : wff = |- ( if ( ph , A , B ) = B → C = E ) ;;
	-----------------------
	prop 1 : wff = |- C = if ( ph , D , E ) ;;
}

proof of ifsb {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 2 : wff = syl (step 1, hyp 1) |- ( ph → C = D ) ;;
	step 3 : wff = iftrue () |- ( ph → if ( ph , D , E ) = D ) ;;
	step 4 : wff = eqtr4d (step 2, step 3) |- ( ph → C = if ( ph , D , E ) ) ;;
	step 5 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 6 : wff = syl (step 5, hyp 2) |- ( ¬ ph → C = E ) ;;
	step 7 : wff = iffalse () |- ( ¬ ph → if ( ph , D , E ) = E ) ;;
	step 8 : wff = eqtr4d (step 6, step 7) |- ( ¬ ph → C = if ( ph , D , E ) ) ;;
	step 9 : wff = pm2.61i (step 4, step 8) |- C = if ( ph , D , E ) ;;
	qed prop 1 = step 9 ;;
}

/* Alternate definition of the conditional operator ~ df-if .  Note that
       ` ph ` is independent of ` x ` i.e. a constant true or false.
       (Contributed by NM, 25-Aug-2013.)  (Revised by Mario Carneiro,
       8-Sep-2013.) */

theorem dfif3 (ph : wff, x : set, A : class, B : class, C : class) disjointed(y A, y B, x y ph) {
	hyp 1 : wff = |- C = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- if ( ph , A , B ) = ( ( A ∩ C ) ∪ ( B ∩ ( _V ∖ C ) ) ) ;;
}

proof of dfif3 {
	var y : set;;
	step 1 : wff = dfif6 () |- if ( ph , A , B ) = ( { y ∈ A | ph } ∪ { y ∈ B | ¬ ph } ) ;;
	step 2 : wff = biidd () |- ( x = y → ( ph ↔ ph ) ) ;;
	step 3 : wff = cbvabv (step 2) |- { x | ph } = { y | ph } ;;
	step 4 : wff = eqtri (hyp 1, step 3) |- C = { y | ph } ;;
	step 5 : wff = ineq2i (step 4) |- ( A ∩ C ) = ( A ∩ { y | ph } ) ;;
	step 6 : wff = dfrab3 () |- { y ∈ A | ph } = ( A ∩ { y | ph } ) ;;
	step 7 : wff = eqtr4i (step 5, step 6) |- ( A ∩ C ) = { y ∈ A | ph } ;;
	step 8 : wff = dfrab3 () |- { y ∈ B | ¬ ph } = ( B ∩ { y | ¬ ph } ) ;;
	step 9 : wff = notab () |- { y | ¬ ph } = ( _V ∖ { y | ph } ) ;;
	step 10 : wff = biidd () |- ( x = y → ( ph ↔ ph ) ) ;;
	step 11 : wff = cbvabv (step 10) |- { x | ph } = { y | ph } ;;
	step 12 : wff = eqtri (hyp 1, step 11) |- C = { y | ph } ;;
	step 13 : wff = difeq2i (step 12) |- ( _V ∖ C ) = ( _V ∖ { y | ph } ) ;;
	step 14 : wff = eqtr4i (step 9, step 13) |- { y | ¬ ph } = ( _V ∖ C ) ;;
	step 15 : wff = ineq2i (step 14) |- ( B ∩ { y | ¬ ph } ) = ( B ∩ ( _V ∖ C ) ) ;;
	step 16 : wff = eqtr2i (step 8, step 15) |- ( B ∩ ( _V ∖ C ) ) = { y ∈ B | ¬ ph } ;;
	step 17 : wff = uneq12i (step 7, step 16) |- ( ( A ∩ C ) ∪ ( B ∩ ( _V ∖ C ) ) ) = ( { y ∈ A | ph } ∪ { y ∈ B | ¬ ph } ) ;;
	step 18 : wff = eqtr4i (step 1, step 17) |- if ( ph , A , B ) = ( ( A ∩ C ) ∪ ( B ∩ ( _V ∖ C ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Alternate definition of the conditional operator ~ df-if .  Note that
       ` ph ` is independent of ` x ` i.e. a constant true or false.
       (Contributed by NM, 25-Aug-2013.) */

theorem dfif4 (ph : wff, x : set, A : class, B : class, C : class) disjointed(x ph) {
	hyp 1 : wff = |- C = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- if ( ph , A , B ) = ( ( A ∪ B ) ∩ ( ( A ∪ ( _V ∖ C ) ) ∩ ( B ∪ C ) ) ) ;;
}

proof of dfif4 {
	step 1 : wff = dfif3 (hyp 1) |- if ( ph , A , B ) = ( ( A ∩ C ) ∪ ( B ∩ ( _V ∖ C ) ) ) ;;
	step 2 : wff = undir () |- ( ( A ∩ C ) ∪ ( B ∩ ( _V ∖ C ) ) ) = ( ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ∩ ( C ∪ ( B ∩ ( _V ∖ C ) ) ) ) ;;
	step 3 : wff = undi () |- ( A ∪ ( B ∩ ( _V ∖ C ) ) ) = ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ;;
	step 4 : wff = undi () |- ( C ∪ ( B ∩ ( _V ∖ C ) ) ) = ( ( C ∪ B ) ∩ ( C ∪ ( _V ∖ C ) ) ) ;;
	step 5 : wff = uncom () |- ( C ∪ B ) = ( B ∪ C ) ;;
	step 6 : wff = undifv () |- ( C ∪ ( _V ∖ C ) ) = _V ;;
	step 7 : wff = ineq12i (step 5, step 6) |- ( ( C ∪ B ) ∩ ( C ∪ ( _V ∖ C ) ) ) = ( ( B ∪ C ) ∩ _V ) ;;
	step 8 : wff = inv1 () |- ( ( B ∪ C ) ∩ _V ) = ( B ∪ C ) ;;
	step 9 : wff = 3eqtri (step 4, step 7, step 8) |- ( C ∪ ( B ∩ ( _V ∖ C ) ) ) = ( B ∪ C ) ;;
	step 10 : wff = ineq12i (step 3, step 9) |- ( ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ∩ ( C ∪ ( B ∩ ( _V ∖ C ) ) ) ) = ( ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ∩ ( B ∪ C ) ) ;;
	step 11 : wff = inass () |- ( ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ∩ ( B ∪ C ) ) = ( ( A ∪ B ) ∩ ( ( A ∪ ( _V ∖ C ) ) ∩ ( B ∪ C ) ) ) ;;
	step 12 : wff = eqtri (step 10, step 11) |- ( ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ∩ ( C ∪ ( B ∩ ( _V ∖ C ) ) ) ) = ( ( A ∪ B ) ∩ ( ( A ∪ ( _V ∖ C ) ) ∩ ( B ∪ C ) ) ) ;;
	step 13 : wff = 3eqtri (step 1, step 2, step 12) |- if ( ph , A , B ) = ( ( A ∪ B ) ∩ ( ( A ∪ ( _V ∖ C ) ) ∩ ( B ∪ C ) ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Alternate definition of the conditional operator ~ df-if .  Note that
       ` ph ` is independent of ` x ` i.e. a constant true or false (see also
       ~ abvor0 ).  (Contributed by G&eacute;rard Lang, 18-Aug-2013.) */

theorem dfif5 (ph : wff, x : set, A : class, B : class, C : class) disjointed(x ph) {
	hyp 1 : wff = |- C = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- if ( ph , A , B ) = ( ( A ∩ B ) ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
}

proof of dfif5 {
	step 1 : wff = inindi () |- ( ( A ∪ B ) ∩ ( ( A ∪ ( _V ∖ C ) ) ∩ ( B ∪ C ) ) ) = ( ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ∩ ( ( A ∪ B ) ∩ ( B ∪ C ) ) ) ;;
	step 2 : wff = dfif4 (hyp 1) |- if ( ph , A , B ) = ( ( A ∪ B ) ∩ ( ( A ∪ ( _V ∖ C ) ) ∩ ( B ∪ C ) ) ) ;;
	step 3 : wff = undir () |- ( ( A ∩ B ) ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) = ( ( A ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ∩ ( B ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ) ;;
	step 4 : wff = unidm () |- ( A ∪ A ) = A ;;
	step 5 : wff = uneq1i (step 4) |- ( ( A ∪ A ) ∪ ( B ∩ ( _V ∖ C ) ) ) = ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ;;
	step 6 : wff = unass () |- ( ( A ∪ A ) ∪ ( B ∩ ( _V ∖ C ) ) ) = ( A ∪ ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ) ;;
	step 7 : wff = undi () |- ( A ∪ ( B ∩ ( _V ∖ C ) ) ) = ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ;;
	step 8 : wff = 3eqtr3ri (step 5, step 6, step 7) |- ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) = ( A ∪ ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ) ;;
	step 9 : wff = undi () |- ( A ∪ ( ( A ∖ B ) ∩ C ) ) = ( ( A ∪ ( A ∖ B ) ) ∩ ( A ∪ C ) ) ;;
	step 10 : wff = undifabs () |- ( A ∪ ( A ∖ B ) ) = A ;;
	step 11 : wff = ineq1i (step 10) |- ( ( A ∪ ( A ∖ B ) ) ∩ ( A ∪ C ) ) = ( A ∩ ( A ∪ C ) ) ;;
	step 12 : wff = inabs () |- ( A ∩ ( A ∪ C ) ) = A ;;
	step 13 : wff = eqtri (step 11, step 12) |- ( ( A ∪ ( A ∖ B ) ) ∩ ( A ∪ C ) ) = A ;;
	step 14 : wff = eqtri (step 9, step 13) |- ( A ∪ ( ( A ∖ B ) ∩ C ) ) = A ;;
	step 15 : wff = undif2 () |- ( A ∪ ( B ∖ A ) ) = ( A ∪ B ) ;;
	step 16 : wff = ineq1i (step 15) |- ( ( A ∪ ( B ∖ A ) ) ∩ ( A ∪ ( _V ∖ C ) ) ) = ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ;;
	step 17 : wff = undi () |- ( A ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) = ( ( A ∪ ( B ∖ A ) ) ∩ ( A ∪ ( _V ∖ C ) ) ) ;;
	step 18 : wff = undi () |- ( A ∪ ( B ∩ ( _V ∖ C ) ) ) = ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ;;
	step 19 : wff = 3eqtr4i (step 16, step 17, step 18) |- ( A ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) = ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ;;
	step 20 : wff = uneq12i (step 14, step 19) |- ( ( A ∪ ( ( A ∖ B ) ∩ C ) ) ∪ ( A ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) = ( A ∪ ( A ∪ ( B ∩ ( _V ∖ C ) ) ) ) ;;
	step 21 : wff = eqtr4i (step 8, step 20) |- ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) = ( ( A ∪ ( ( A ∖ B ) ∩ C ) ) ∪ ( A ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 22 : wff = unundi () |- ( A ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) = ( ( A ∪ ( ( A ∖ B ) ∩ C ) ) ∪ ( A ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 23 : wff = eqtr4i (step 21, step 22) |- ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) = ( A ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 24 : wff = unass () |- ( ( ( A ∩ C ) ∪ B ) ∪ B ) = ( ( A ∩ C ) ∪ ( B ∪ B ) ) ;;
	step 25 : wff = undi () |- ( B ∪ ( A ∩ C ) ) = ( ( B ∪ A ) ∩ ( B ∪ C ) ) ;;
	step 26 : wff = uncom () |- ( ( A ∩ C ) ∪ B ) = ( B ∪ ( A ∩ C ) ) ;;
	step 27 : wff = undif2 () |- ( B ∪ ( A ∖ B ) ) = ( B ∪ A ) ;;
	step 28 : wff = ineq1i (step 27) |- ( ( B ∪ ( A ∖ B ) ) ∩ ( B ∪ C ) ) = ( ( B ∪ A ) ∩ ( B ∪ C ) ) ;;
	step 29 : wff = 3eqtr4i (step 25, step 26, step 28) |- ( ( A ∩ C ) ∪ B ) = ( ( B ∪ ( A ∖ B ) ) ∩ ( B ∪ C ) ) ;;
	step 30 : wff = undi () |- ( B ∪ ( ( A ∖ B ) ∩ C ) ) = ( ( B ∪ ( A ∖ B ) ) ∩ ( B ∪ C ) ) ;;
	step 31 : wff = eqtr4i (step 29, step 30) |- ( ( A ∩ C ) ∪ B ) = ( B ∪ ( ( A ∖ B ) ∩ C ) ) ;;
	step 32 : wff = undi () |- ( B ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) = ( ( B ∪ ( B ∖ A ) ) ∩ ( B ∪ ( _V ∖ C ) ) ) ;;
	step 33 : wff = undifabs () |- ( B ∪ ( B ∖ A ) ) = B ;;
	step 34 : wff = ineq1i (step 33) |- ( ( B ∪ ( B ∖ A ) ) ∩ ( B ∪ ( _V ∖ C ) ) ) = ( B ∩ ( B ∪ ( _V ∖ C ) ) ) ;;
	step 35 : wff = inabs () |- ( B ∩ ( B ∪ ( _V ∖ C ) ) ) = B ;;
	step 36 : wff = 3eqtrri (step 32, step 34, step 35) |- B = ( B ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ;;
	step 37 : wff = uneq12i (step 31, step 36) |- ( ( ( A ∩ C ) ∪ B ) ∪ B ) = ( ( B ∪ ( ( A ∖ B ) ∩ C ) ) ∪ ( B ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 38 : wff = unidm () |- ( B ∪ B ) = B ;;
	step 39 : wff = uneq2i (step 38) |- ( ( A ∩ C ) ∪ ( B ∪ B ) ) = ( ( A ∩ C ) ∪ B ) ;;
	step 40 : wff = 3eqtr3ri (step 24, step 37, step 39) |- ( ( A ∩ C ) ∪ B ) = ( ( B ∪ ( ( A ∖ B ) ∩ C ) ) ∪ ( B ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 41 : wff = uncom () |- ( B ∪ C ) = ( C ∪ B ) ;;
	step 42 : wff = ineq2i (step 41) |- ( ( A ∪ B ) ∩ ( B ∪ C ) ) = ( ( A ∪ B ) ∩ ( C ∪ B ) ) ;;
	step 43 : wff = undir () |- ( ( A ∩ C ) ∪ B ) = ( ( A ∪ B ) ∩ ( C ∪ B ) ) ;;
	step 44 : wff = eqtr4i (step 42, step 43) |- ( ( A ∪ B ) ∩ ( B ∪ C ) ) = ( ( A ∩ C ) ∪ B ) ;;
	step 45 : wff = unundi () |- ( B ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) = ( ( B ∪ ( ( A ∖ B ) ∩ C ) ) ∪ ( B ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 46 : wff = 3eqtr4i (step 40, step 44, step 45) |- ( ( A ∪ B ) ∩ ( B ∪ C ) ) = ( B ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	step 47 : wff = ineq12i (step 23, step 46) |- ( ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ∩ ( ( A ∪ B ) ∩ ( B ∪ C ) ) ) = ( ( A ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ∩ ( B ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ) ;;
	step 48 : wff = eqtr4i (step 3, step 47) |- ( ( A ∩ B ) ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) = ( ( ( A ∪ B ) ∩ ( A ∪ ( _V ∖ C ) ) ) ∩ ( ( A ∪ B ) ∩ ( B ∪ C ) ) ) ;;
	step 49 : wff = 3eqtr4i (step 1, step 2, step 48) |- if ( ph , A , B ) = ( ( A ∩ B ) ∪ ( ( ( A ∖ B ) ∩ C ) ∪ ( ( B ∖ A ) ∩ ( _V ∖ C ) ) ) ) ;;
	qed prop 1 = step 49 ;;
}

/* Equality theorem for conditional operators.  (Contributed by NM,
     1-Sep-2004.) */

theorem ifeq12 (ph : wff, A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → if ( ph , A , C ) = if ( ph , B , D ) ) ;;
}

proof of ifeq12 {
	step 1 : wff = ifeq1 () |- ( A = B → if ( ph , A , C ) = if ( ph , B , C ) ) ;;
	step 2 : wff = ifeq2 () |- ( C = D → if ( ph , B , C ) = if ( ph , B , D ) ) ;;
	step 3 : wff = sylan9eq (step 1, step 2) |- ( ( A = B ∧ C = D ) → if ( ph , A , C ) = if ( ph , B , D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Equality deduction for conditional operator.  (Contributed by NM,
       16-Feb-2005.) */

theorem ifeq1d (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
}

proof of ifeq1d {
	step 1 : wff = ifeq1 () |- ( A = B → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for conditional operator.  (Contributed by NM,
       16-Feb-2005.) */

theorem ifeq2d (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
}

proof of ifeq2d {
	step 1 : wff = ifeq2 () |- ( A = B → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for conditional operator.  (Contributed by NM,
       24-Mar-2015.) */

theorem ifeq12d (ph : wff, ps : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , A , C ) = if ( ps , B , D ) ) ;;
}

proof of ifeq12d {
	step 1 : wff = ifeq1d (hyp 1) |- ( ph → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	step 2 : wff = ifeq2d (hyp 2) |- ( ph → if ( ps , B , C ) = if ( ps , B , D ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → if ( ps , A , C ) = if ( ps , B , D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Equivalence theorem for conditional operators.  (Contributed by Raph
     Levien, 15-Jan-2004.) */

theorem ifbi (ph : wff, ps : wff, A : class, B : class)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → if ( ph , A , B ) = if ( ps , A , B ) ) ;;
}

proof of ifbi {
	step 1 : wff = dfbi3 () |- ( ( ph ↔ ps ) ↔ ( ( ph ∧ ps ) ∨ ( ¬ ph ∧ ¬ ps ) ) ) ;;
	step 2 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 3 : wff = iftrue () |- ( ps → if ( ps , A , B ) = A ) ;;
	step 4 : wff = eqcomd (step 3) |- ( ps → A = if ( ps , A , B ) ) ;;
	step 5 : wff = sylan9eq (step 2, step 4) |- ( ( ph ∧ ps ) → if ( ph , A , B ) = if ( ps , A , B ) ) ;;
	step 6 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 7 : wff = iffalse () |- ( ¬ ps → if ( ps , A , B ) = B ) ;;
	step 8 : wff = eqcomd (step 7) |- ( ¬ ps → B = if ( ps , A , B ) ) ;;
	step 9 : wff = sylan9eq (step 6, step 8) |- ( ( ¬ ph ∧ ¬ ps ) → if ( ph , A , B ) = if ( ps , A , B ) ) ;;
	step 10 : wff = jaoi (step 5, step 9) |- ( ( ( ph ∧ ps ) ∨ ( ¬ ph ∧ ¬ ps ) ) → if ( ph , A , B ) = if ( ps , A , B ) ) ;;
	step 11 : wff = sylbi (step 1, step 10) |- ( ( ph ↔ ps ) → if ( ph , A , B ) = if ( ps , A , B ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Equivalence deduction for conditional operators.  (Contributed by NM,
       18-Apr-2005.) */

theorem ifbid (ph : wff, ps : wff, ch : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , A , B ) = if ( ch , A , B ) ) ;;
}

proof of ifbid {
	step 1 : wff = ifbi () |- ( ( ps ↔ ch ) → if ( ps , A , B ) = if ( ch , A , B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → if ( ps , A , B ) = if ( ch , A , B ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equivalence/equality inference for conditional operators.  (Contributed
       by Paul Chapman, 22-Jun-2011.) */

theorem ifbieq2i (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- if ( ph , C , A ) = if ( ps , C , B ) ;;
}

proof of ifbieq2i {
	step 1 : wff = ifbi () |- ( ( ph ↔ ps ) → if ( ph , C , A ) = if ( ps , C , A ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- if ( ph , C , A ) = if ( ps , C , A ) ;;
	step 3 : wff = ifeq2 () |- ( A = B → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	step 4 : wff = ax-mp (hyp 2, step 3) |- if ( ps , C , A ) = if ( ps , C , B ) ;;
	step 5 : wff = eqtri (step 2, step 4) |- if ( ph , C , A ) = if ( ps , C , B ) ;;
	qed prop 1 = step 5 ;;
}

/* Equivalence/equality deduction for conditional operators.  (Contributed
       by Paul Chapman, 22-Jun-2011.) */

theorem ifbieq2d (ph : wff, ps : wff, ch : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , C , A ) = if ( ch , C , B ) ) ;;
}

proof of ifbieq2d {
	step 1 : wff = ifbid (hyp 1) |- ( ph → if ( ps , C , A ) = if ( ch , C , A ) ) ;;
	step 2 : wff = ifeq2d (hyp 2) |- ( ph → if ( ch , C , A ) = if ( ch , C , B ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → if ( ps , C , A ) = if ( ch , C , B ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Equivalence deduction for conditional operators.  (Contributed by NM,
       18-Mar-2013.) */

theorem ifbieq12i (ph : wff, ps : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- if ( ph , A , B ) = if ( ps , C , D ) ;;
}

proof of ifbieq12i {
	step 1 : wff = ifeq1 () |- ( A = C → if ( ph , A , B ) = if ( ph , C , B ) ) ;;
	step 2 : wff = ax-mp (hyp 2, step 1) |- if ( ph , A , B ) = if ( ph , C , B ) ;;
	step 3 : wff = ifbieq2i (hyp 1, hyp 3) |- if ( ph , C , B ) = if ( ps , C , D ) ;;
	step 4 : wff = eqtri (step 2, step 3) |- if ( ph , A , B ) = if ( ps , C , D ) ;;
	qed prop 1 = step 4 ;;
}

/* Equivalence deduction for conditional operators.  (Contributed by Jeff
       Madsen, 2-Sep-2009.) */

theorem ifbieq12d (ph : wff, ps : wff, ch : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	hyp 3 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , A , B ) = if ( ch , C , D ) ) ;;
}

proof of ifbieq12d {
	step 1 : wff = ifbid (hyp 1) |- ( ph → if ( ps , A , B ) = if ( ch , A , B ) ) ;;
	step 2 : wff = ifeq12d (hyp 2, hyp 3) |- ( ph → if ( ch , A , B ) = if ( ch , C , D ) ) ;;
	step 3 : wff = eqtrd (step 1, step 2) |- ( ph → if ( ps , A , B ) = if ( ch , C , D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction version of ~ nfif .  (Contributed by NM, 15-Feb-2013.)
       (Revised by Mario Carneiro, 13-Oct-2016.) */

theorem nfifd (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x y, y A, y B, y ph, y ps) {
	hyp 1 : wff = |- ( ph → F/ x ps ) ;;
	hyp 2 : wff = |- ( ph → F/_ x A ) ;;
	hyp 3 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x if ( ps , A , B ) ) ;;
}

proof of nfifd {
	var y : set;;
	step 1 : wff = dfif2 () |- if ( ps , A , B ) = { y | ( ( y ∈ B → ps ) → ( y ∈ A ∧ ps ) ) } ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = nfcrd (hyp 3) |- ( ph → F/ x y ∈ B ) ;;
	step 4 : wff = nfimd (step 3, hyp 1) |- ( ph → F/ x ( y ∈ B → ps ) ) ;;
	step 5 : wff = nfcrd (hyp 2) |- ( ph → F/ x y ∈ A ) ;;
	step 6 : wff = nfand (step 5, hyp 1) |- ( ph → F/ x ( y ∈ A ∧ ps ) ) ;;
	step 7 : wff = nfimd (step 4, step 6) |- ( ph → F/ x ( ( y ∈ B → ps ) → ( y ∈ A ∧ ps ) ) ) ;;
	step 8 : wff = nfabd (step 2, step 7) |- ( ph → F/_ x { y | ( ( y ∈ B → ps ) → ( y ∈ A ∧ ps ) ) } ) ;;
	step 9 : wff = nfcxfrd (step 1, step 8) |- ( ph → F/_ x if ( ps , A , B ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Bound-variable hypothesis builder for a conditional operator.
       (Contributed by NM, 16-Feb-2005.)  (Proof shortened by Andrew Salmon,
       26-Jun-2011.) */

theorem nfif (ph : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/_ x A ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x if ( ph , A , B ) ;;
}

proof of nfif {
	step 1 : wff = a1i (hyp 1) |- ( T. → F/ x ph ) ;;
	step 2 : wff = a1i (hyp 2) |- ( T. → F/_ x A ) ;;
	step 3 : wff = a1i (hyp 3) |- ( T. → F/_ x B ) ;;
	step 4 : wff = nfifd (step 1, step 2, step 3) |- ( T. → F/_ x if ( ph , A , B ) ) ;;
	step 5 : wff = trud (step 4) |- F/_ x if ( ph , A , B ) ;;
	qed prop 1 = step 5 ;;
}

/* Conditional equality.  (Contributed by Jeff Madsen, 2-Sep-2009.) */

theorem ifeq1da (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ( ph ∧ ps ) → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
}

proof of ifeq1da {
	step 1 : wff = ifeq1d (hyp 1) |- ( ( ph ∧ ps ) → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	step 2 : wff = iffalse () |- ( ¬ ps → if ( ps , A , C ) = C ) ;;
	step 3 : wff = iffalse () |- ( ¬ ps → if ( ps , B , C ) = C ) ;;
	step 4 : wff = eqtr4d (step 2, step 3) |- ( ¬ ps → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ph ∧ ¬ ps ) → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	step 6 : wff = pm2.61dan (step 1, step 5) |- ( ph → if ( ps , A , C ) = if ( ps , B , C ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Conditional equality.  (Contributed by Jeff Madsen, 2-Sep-2009.) */

theorem ifeq2da (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ( ph ∧ ¬ ps ) → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
}

proof of ifeq2da {
	step 1 : wff = iftrue () |- ( ps → if ( ps , C , A ) = C ) ;;
	step 2 : wff = iftrue () |- ( ps → if ( ps , C , B ) = C ) ;;
	step 3 : wff = eqtr4d (step 1, step 2) |- ( ps → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	step 4 : wff = adantl (step 3) |- ( ( ph ∧ ps ) → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	step 5 : wff = ifeq2d (hyp 1) |- ( ( ph ∧ ¬ ps ) → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	step 6 : wff = pm2.61dan (step 4, step 5) |- ( ph → if ( ps , C , A ) = if ( ps , C , B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Conditional closure.  (Contributed by Jeff Madsen, 2-Sep-2009.) */

theorem ifclda (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ( ph ∧ ps ) → A ∈ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ¬ ps ) → B ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → if ( ps , A , B ) ∈ C ) ;;
}

proof of ifclda {
	step 1 : wff = iftrue () |- ( ps → if ( ps , A , B ) = A ) ;;
	step 2 : wff = adantl (step 1) |- ( ( ph ∧ ps ) → if ( ps , A , B ) = A ) ;;
	step 3 : wff = eqeltrd (step 2, hyp 1) |- ( ( ph ∧ ps ) → if ( ps , A , B ) ∈ C ) ;;
	step 4 : wff = iffalse () |- ( ¬ ps → if ( ps , A , B ) = B ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ph ∧ ¬ ps ) → if ( ps , A , B ) = B ) ;;
	step 6 : wff = eqeltrd (step 5, hyp 2) |- ( ( ph ∧ ¬ ps ) → if ( ps , A , B ) ∈ C ) ;;
	step 7 : wff = pm2.61dan (step 3, step 6) |- ( ph → if ( ps , A , B ) ∈ C ) ;;
	qed prop 1 = step 7 ;;
}

/* Distribute proper substitution through the conditional operator.
       (Contributed by NM, 24-Feb-2013.)  (Revised by Mario Carneiro,
       14-Nov-2016.) */

theorem csbifg (ph : wff, x : set, A : class, B : class, C : class, V : class) disjointed(y A, y B, y C, y ph, x y) {
	prop 1 : wff = |- ( A ∈ V → [_ A / x ]_ if ( ph , B , C ) = if ( [. A / x ]. ph , [_ A / x ]_ B , [_ A / x ]_ C ) ) ;;
}

proof of csbifg {
	var y : set;;
	step 1 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ if ( ph , B , C ) = [_ A / x ]_ if ( ph , B , C ) ) ;;
	step 2 : wff = dfsbcq2 () |- ( y = A → ( [ y / x ] ph ↔ [. A / x ]. ph ) ) ;;
	step 3 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ B = [_ A / x ]_ B ) ;;
	step 4 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ C = [_ A / x ]_ C ) ;;
	step 5 : wff = ifbieq12d (step 2, step 3, step 4) |- ( y = A → if ( [ y / x ] ph , [_ y / x ]_ B , [_ y / x ]_ C ) = if ( [. A / x ]. ph , [_ A / x ]_ B , [_ A / x ]_ C ) ) ;;
	step 6 : wff = eqeq12d (step 1, step 5) |- ( y = A → ( [_ y / x ]_ if ( ph , B , C ) = if ( [ y / x ] ph , [_ y / x ]_ B , [_ y / x ]_ C ) ↔ [_ A / x ]_ if ( ph , B , C ) = if ( [. A / x ]. ph , [_ A / x ]_ B , [_ A / x ]_ C ) ) ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 9 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 10 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ C ;;
	step 11 : wff = nfif (step 8, step 9, step 10) |- F/_ x if ( [ y / x ] ph , [_ y / x ]_ B , [_ y / x ]_ C ) ;;
	step 12 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 13 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 14 : wff = csbeq1a () |- ( x = y → C = [_ y / x ]_ C ) ;;
	step 15 : wff = ifbieq12d (step 12, step 13, step 14) |- ( x = y → if ( ph , B , C ) = if ( [ y / x ] ph , [_ y / x ]_ B , [_ y / x ]_ C ) ) ;;
	step 16 : wff = csbief (step 7, step 11, step 15) |- [_ y / x ]_ if ( ph , B , C ) = if ( [ y / x ] ph , [_ y / x ]_ B , [_ y / x ]_ C ) ;;
	step 17 : wff = vtoclg (step 6, step 16) |- ( A ∈ V → [_ A / x ]_ if ( ph , B , C ) = if ( [. A / x ]. ph , [_ A / x ]_ B , [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Elimination of a conditional operator contained in a wff ` ps ` .
       (Contributed by NM, 15-Feb-2005.) */

theorem elimif (ph : wff, ps : wff, ch : wff, th : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( if ( ph , A , B ) = A → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( if ( ph , A , B ) = B → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ps ↔ ( ( ph ∧ ch ) ∨ ( ¬ ph ∧ th ) ) ) ;;
}

proof of elimif {
	step 1 : wff = exmid () |- ( ph ∨ ¬ ph ) ;;
	step 2 : wff = biantrur (step 1) |- ( ps ↔ ( ( ph ∨ ¬ ph ) ∧ ps ) ) ;;
	step 3 : wff = andir () |- ( ( ( ph ∨ ¬ ph ) ∧ ps ) ↔ ( ( ph ∧ ps ) ∨ ( ¬ ph ∧ ps ) ) ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 5 : wff = syl (step 4, hyp 1) |- ( ph → ( ps ↔ ch ) ) ;;
	step 6 : wff = pm5.32i (step 5) |- ( ( ph ∧ ps ) ↔ ( ph ∧ ch ) ) ;;
	step 7 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 8 : wff = syl (step 7, hyp 2) |- ( ¬ ph → ( ps ↔ th ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( ¬ ph ∧ ps ) ↔ ( ¬ ph ∧ th ) ) ;;
	step 10 : wff = orbi12i (step 6, step 9) |- ( ( ( ph ∧ ps ) ∨ ( ¬ ph ∧ ps ) ) ↔ ( ( ph ∧ ch ) ∨ ( ¬ ph ∧ th ) ) ) ;;
	step 11 : wff = 3bitri (step 2, step 3, step 10) |- ( ps ↔ ( ( ph ∧ ch ) ∨ ( ¬ ph ∧ th ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/* A wff ` th ` containing a conditional operator is true when both of
         its cases are true.  (Contributed by NM, 15-Feb-2015.) */

theorem ifbothda (ph : wff, ps : wff, ch : wff, th : wff, et : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , B ) → ( ps ↔ th ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , A , B ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( ( et ∧ ph ) → ps ) ;;
	hyp 4 : wff = |- ( ( et ∧ ¬ ph ) → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( et → th ) ;;
}

proof of ifbothda {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , B ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ps ↔ th ) ) ;;
	step 4 : wff = adantl (step 3) |- ( ( et ∧ ph ) → ( ps ↔ th ) ) ;;
	step 5 : wff = mpbid (hyp 3, step 4) |- ( ( et ∧ ph ) → th ) ;;
	step 6 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 7 : wff = eqcomd (step 6) |- ( ¬ ph → B = if ( ph , A , B ) ) ;;
	step 8 : wff = syl (step 7, hyp 2) |- ( ¬ ph → ( ch ↔ th ) ) ;;
	step 9 : wff = adantl (step 8) |- ( ( et ∧ ¬ ph ) → ( ch ↔ th ) ) ;;
	step 10 : wff = mpbid (hyp 4, step 9) |- ( ( et ∧ ¬ ph ) → th ) ;;
	step 11 : wff = pm2.61dan (step 5, step 10) |- ( et → th ) ;;
	qed prop 1 = step 11 ;;
}

/* A wff ` th ` containing a conditional operator is true when both of its
       cases are true.  (Contributed by NM, 3-Sep-2006.)  (Revised by Mario
       Carneiro, 15-Feb-2015.) */

theorem ifboth (ph : wff, ps : wff, ch : wff, th : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , B ) → ( ps ↔ th ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , A , B ) → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps ∧ ch ) → th ) ;;
}

proof of ifboth {
	step 1 : wff = simpll () |- ( ( ( ps ∧ ch ) ∧ ph ) → ps ) ;;
	step 2 : wff = simplr () |- ( ( ( ps ∧ ch ) ∧ ¬ ph ) → ch ) ;;
	step 3 : wff = ifbothda (hyp 1, hyp 2, step 1, step 2) |- ( ( ps ∧ ch ) → th ) ;;
	qed prop 1 = step 3 ;;
}

/* Identical true and false arguments in the conditional operator.
     (Contributed by NM, 18-Apr-2005.) */

theorem ifid (ph : wff, A : class)  {
	prop 1 : wff = |- if ( ph , A , A ) = A ;;
}

proof of ifid {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , A ) = A ) ;;
	step 2 : wff = iffalse () |- ( ¬ ph → if ( ph , A , A ) = A ) ;;
	step 3 : wff = pm2.61i (step 1, step 2) |- if ( ph , A , A ) = A ;;
	qed prop 1 = step 3 ;;
}

/* Expansion of an equality with a conditional operator.  (Contributed by NM,
     14-Feb-2005.) */

theorem eqif (ph : wff, A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = if ( ph , B , C ) ↔ ( ( ph ∧ A = B ) ∨ ( ¬ ph ∧ A = C ) ) ) ;;
}

proof of eqif {
	step 1 : wff = eqeq2 () |- ( if ( ph , B , C ) = B → ( A = if ( ph , B , C ) ↔ A = B ) ) ;;
	step 2 : wff = eqeq2 () |- ( if ( ph , B , C ) = C → ( A = if ( ph , B , C ) ↔ A = C ) ) ;;
	step 3 : wff = elimif (step 1, step 2) |- ( A = if ( ph , B , C ) ↔ ( ( ph ∧ A = B ) ∨ ( ¬ ph ∧ A = C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in a conditional operator.  (Contributed by NM,
     14-Feb-2005.) */

theorem elif (ph : wff, A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∈ if ( ph , B , C ) ↔ ( ( ph ∧ A ∈ B ) ∨ ( ¬ ph ∧ A ∈ C ) ) ) ;;
}

proof of elif {
	step 1 : wff = eleq2 () |- ( if ( ph , B , C ) = B → ( A ∈ if ( ph , B , C ) ↔ A ∈ B ) ) ;;
	step 2 : wff = eleq2 () |- ( if ( ph , B , C ) = C → ( A ∈ if ( ph , B , C ) ↔ A ∈ C ) ) ;;
	step 3 : wff = elimif (step 1, step 2) |- ( A ∈ if ( ph , B , C ) ↔ ( ( ph ∧ A ∈ B ) ∨ ( ¬ ph ∧ A ∈ C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership of a conditional operator.  (Contributed by NM,
     10-Sep-2005.) */

theorem ifel (ph : wff, A : class, B : class, C : class)  {
	prop 1 : wff = |- ( if ( ph , A , B ) ∈ C ↔ ( ( ph ∧ A ∈ C ) ∨ ( ¬ ph ∧ B ∈ C ) ) ) ;;
}

proof of ifel {
	step 1 : wff = eleq1 () |- ( if ( ph , A , B ) = A → ( if ( ph , A , B ) ∈ C ↔ A ∈ C ) ) ;;
	step 2 : wff = eleq1 () |- ( if ( ph , A , B ) = B → ( if ( ph , A , B ) ∈ C ↔ B ∈ C ) ) ;;
	step 3 : wff = elimif (step 1, step 2) |- ( if ( ph , A , B ) ∈ C ↔ ( ( ph ∧ A ∈ C ) ∨ ( ¬ ph ∧ B ∈ C ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership (closure) of a conditional operator.  (Contributed by NM,
     4-Apr-2005.) */

theorem ifcl (ph : wff, A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ C ) → if ( ph , A , B ) ∈ C ) ;;
}

proof of ifcl {
	step 1 : wff = eleq1 () |- ( A = if ( ph , A , B ) → ( A ∈ C ↔ if ( ph , A , B ) ∈ C ) ) ;;
	step 2 : wff = eleq1 () |- ( B = if ( ph , A , B ) → ( B ∈ C ↔ if ( ph , A , B ) ∈ C ) ) ;;
	step 3 : wff = ifboth (step 1, step 2) |- ( ( A ∈ C ∧ B ∈ C ) → if ( ph , A , B ) ∈ C ) ;;
	qed prop 1 = step 3 ;;
}

/* The possible values of a conditional operator.  (Contributed by NM,
     17-Jun-2007.)  (Proof shortened by Andrew Salmon, 26-Jun-2011.) */

theorem ifeqor (ph : wff, A : class, B : class)  {
	prop 1 : wff = |- ( if ( ph , A , B ) = A ∨ if ( ph , A , B ) = B ) ;;
}

proof of ifeqor {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 2 : wff = con3i (step 1) |- ( ¬ if ( ph , A , B ) = A → ¬ ph ) ;;
	step 3 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ¬ if ( ph , A , B ) = A → if ( ph , A , B ) = B ) ;;
	step 5 : wff = orri (step 4) |- ( if ( ph , A , B ) = A ∨ if ( ph , A , B ) = B ) ;;
	qed prop 1 = step 5 ;;
}

/* Negating the first argument swaps the last two arguments of a conditional
     operator.  (Contributed by NM, 21-Jun-2007.) */

theorem ifnot (ph : wff, A : class, B : class)  {
	prop 1 : wff = |- if ( ¬ ph , A , B ) = if ( ph , B , A ) ;;
}

proof of ifnot {
	step 1 : wff = notnot1 () |- ( ph → ¬ ¬ ph ) ;;
	step 2 : wff = iffalse () |- ( ¬ ¬ ph → if ( ¬ ph , A , B ) = B ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → if ( ¬ ph , A , B ) = B ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , A ) = B ) ;;
	step 5 : wff = eqtr4d (step 3, step 4) |- ( ph → if ( ¬ ph , A , B ) = if ( ph , B , A ) ) ;;
	step 6 : wff = iftrue () |- ( ¬ ph → if ( ¬ ph , A , B ) = A ) ;;
	step 7 : wff = iffalse () |- ( ¬ ph → if ( ph , B , A ) = A ) ;;
	step 8 : wff = eqtr4d (step 6, step 7) |- ( ¬ ph → if ( ¬ ph , A , B ) = if ( ph , B , A ) ) ;;
	step 9 : wff = pm2.61i (step 5, step 8) |- if ( ¬ ph , A , B ) = if ( ph , B , A ) ;;
	qed prop 1 = step 9 ;;
}

/* Rewrite a conjunction in an if statement as two nested conditionals.
     (Contributed by Mario Carneiro, 28-Jul-2014.) */

theorem ifan (ph : wff, ps : wff, A : class, B : class)  {
	prop 1 : wff = |- if ( ( ph ∧ ps ) , A , B ) = if ( ph , if ( ps , A , B ) , B ) ;;
}

proof of ifan {
	step 1 : wff = iftrue () |- ( ph → if ( ph , if ( ps , A , B ) , B ) = if ( ps , A , B ) ) ;;
	step 2 : wff = ibar () |- ( ph → ( ps ↔ ( ph ∧ ps ) ) ) ;;
	step 3 : wff = ifbid (step 2) |- ( ph → if ( ps , A , B ) = if ( ( ph ∧ ps ) , A , B ) ) ;;
	step 4 : wff = eqtr2d (step 1, step 3) |- ( ph → if ( ( ph ∧ ps ) , A , B ) = if ( ph , if ( ps , A , B ) , B ) ) ;;
	step 5 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 6 : wff = con3i (step 5) |- ( ¬ ph → ¬ ( ph ∧ ps ) ) ;;
	step 7 : wff = iffalse () |- ( ¬ ( ph ∧ ps ) → if ( ( ph ∧ ps ) , A , B ) = B ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ¬ ph → if ( ( ph ∧ ps ) , A , B ) = B ) ;;
	step 9 : wff = iffalse () |- ( ¬ ph → if ( ph , if ( ps , A , B ) , B ) = B ) ;;
	step 10 : wff = eqtr4d (step 8, step 9) |- ( ¬ ph → if ( ( ph ∧ ps ) , A , B ) = if ( ph , if ( ps , A , B ) , B ) ) ;;
	step 11 : wff = pm2.61i (step 4, step 10) |- if ( ( ph ∧ ps ) , A , B ) = if ( ph , if ( ps , A , B ) , B ) ;;
	qed prop 1 = step 11 ;;
}

/* Rewrite a disjunction in an if statement as two nested conditionals.
     (Contributed by Mario Carneiro, 28-Jul-2014.) */

theorem ifor (ph : wff, ps : wff, A : class, B : class)  {
	prop 1 : wff = |- if ( ( ph ∨ ps ) , A , B ) = if ( ph , A , if ( ps , A , B ) ) ;;
}

proof of ifor {
	step 1 : wff = iftrue () |- ( ( ph ∨ ps ) → if ( ( ph ∨ ps ) , A , B ) = A ) ;;
	step 2 : wff = orcs (step 1) |- ( ph → if ( ( ph ∨ ps ) , A , B ) = A ) ;;
	step 3 : wff = iftrue () |- ( ph → if ( ph , A , if ( ps , A , B ) ) = A ) ;;
	step 4 : wff = eqtr4d (step 2, step 3) |- ( ph → if ( ( ph ∨ ps ) , A , B ) = if ( ph , A , if ( ps , A , B ) ) ) ;;
	step 5 : wff = iffalse () |- ( ¬ ph → if ( ph , A , if ( ps , A , B ) ) = if ( ps , A , B ) ) ;;
	step 6 : wff = biorf () |- ( ¬ ph → ( ps ↔ ( ph ∨ ps ) ) ) ;;
	step 7 : wff = ifbid (step 6) |- ( ¬ ph → if ( ps , A , B ) = if ( ( ph ∨ ps ) , A , B ) ) ;;
	step 8 : wff = eqtr2d (step 5, step 7) |- ( ¬ ph → if ( ( ph ∨ ps ) , A , B ) = if ( ph , A , if ( ps , A , B ) ) ) ;;
	step 9 : wff = pm2.61i (step 4, step 8) |- if ( ( ph ∨ ps ) , A , B ) = if ( ph , A , if ( ps , A , B ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Weak deduction theorem that eliminates a hypothesis ` ph ` , making it
       become an antecedent.  We assume that a proof exists for ` ph ` when the
       class variable ` A ` is replaced with a specific class ` B ` .  The
       hypothesis ` ch ` should be assigned to the inference, and the
       inference's hypothesis eliminated with ~ elimhyp .  If the inference has
       other hypotheses with class variable ` A ` , these can be kept by
       assigning ~ keephyp to them.  For more information, see the Deduction
       Theorem ~ http://us.metamath.org/mpeuni/mmdeduction.html .  (Contributed
       by NM, 15-May-1999.) */

theorem dedth (ph : wff, ps : wff, ch : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , B ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ch ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of dedth {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , B ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ps ↔ ch ) ) ;;
	step 4 : wff = mpbiri (hyp 2, step 3) |- ( ph → ps ) ;;
	qed prop 1 = step 4 ;;
}

/* Weak deduction theorem eliminating two hypotheses.  This theorem is
       simpler to use than ~ dedth2v but requires that each hypothesis has
       exactly one class variable.  See also comments in ~ dedth .
       (Contributed by NM, 15-May-1999.) */

theorem dedth2h (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , C ) → ( ch ↔ th ) ) ;;
	hyp 2 : wff = |- ( B = if ( ps , B , D ) → ( th ↔ ta ) ) ;;
	hyp 3 : wff = |- ta ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → ch ) ;;
}

proof of dedth2h {
	step 1 : wff = imbi2d (hyp 1) |- ( A = if ( ph , A , C ) → ( ( ps → ch ) ↔ ( ps → th ) ) ) ;;
	step 2 : wff = dedth (hyp 2, hyp 3) |- ( ps → th ) ;;
	step 3 : wff = dedth (step 1, step 2) |- ( ph → ( ps → ch ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( ph ∧ ps ) → ch ) ;;
	qed prop 1 = step 4 ;;
}

/* Weak deduction theorem eliminating three hypotheses.  See comments in
       ~ dedth2h .  (Contributed by NM, 15-May-1999.) */

theorem dedth3h (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, A : class, B : class, C : class, D : class, R : class, S : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , D ) → ( th ↔ ta ) ) ;;
	hyp 2 : wff = |- ( B = if ( ps , B , R ) → ( ta ↔ et ) ) ;;
	hyp 3 : wff = |- ( C = if ( ch , C , S ) → ( et ↔ ze ) ) ;;
	hyp 4 : wff = |- ze ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ∧ ch ) → th ) ;;
}

proof of dedth3h {
	step 1 : wff = imbi2d (hyp 1) |- ( A = if ( ph , A , D ) → ( ( ( ps ∧ ch ) → th ) ↔ ( ( ps ∧ ch ) → ta ) ) ) ;;
	step 2 : wff = dedth2h (hyp 2, hyp 3, hyp 4) |- ( ( ps ∧ ch ) → ta ) ;;
	step 3 : wff = dedth (step 1, step 2) |- ( ph → ( ( ps ∧ ch ) → th ) ) ;;
	step 4 : wff = 3impib (step 3) |- ( ( ph ∧ ps ∧ ch ) → th ) ;;
	qed prop 1 = step 4 ;;
}

/* Weak deduction theorem eliminating four hypotheses.  See comments in
       ~ dedth2h .  (Contributed by NM, 16-May-1999.) */

theorem dedth4h (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, si : wff, rh : wff, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , R ) → ( ta ↔ et ) ) ;;
	hyp 2 : wff = |- ( B = if ( ps , B , S ) → ( et ↔ ze ) ) ;;
	hyp 3 : wff = |- ( C = if ( ch , C , F ) → ( ze ↔ si ) ) ;;
	hyp 4 : wff = |- ( D = if ( th , D , G ) → ( si ↔ rh ) ) ;;
	hyp 5 : wff = |- rh ;;
	-----------------------
	prop 1 : wff = |- ( ( ( ph ∧ ps ) ∧ ( ch ∧ th ) ) → ta ) ;;
}

proof of dedth4h {
	step 1 : wff = imbi2d (hyp 1) |- ( A = if ( ph , A , R ) → ( ( ( ch ∧ th ) → ta ) ↔ ( ( ch ∧ th ) → et ) ) ) ;;
	step 2 : wff = imbi2d (hyp 2) |- ( B = if ( ps , B , S ) → ( ( ( ch ∧ th ) → et ) ↔ ( ( ch ∧ th ) → ze ) ) ) ;;
	step 3 : wff = dedth2h (hyp 3, hyp 4, hyp 5) |- ( ( ch ∧ th ) → ze ) ;;
	step 4 : wff = dedth2h (step 1, step 2, step 3) |- ( ( ph ∧ ps ) → ( ( ch ∧ th ) → ta ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( ( ph ∧ ps ) ∧ ( ch ∧ th ) ) → ta ) ;;
	qed prop 1 = step 5 ;;
}

/* Weak deduction theorem for eliminating a hypothesis with 2 class
       variables.  Note: if the hypothesis can be separated into two
       hypotheses, each with one class variable, then ~ dedth2h is simpler to
       use.  See also comments in ~ dedth .  (Contributed by NM, 13-Aug-1999.)
       (Proof shortened by Eric Schmidt, 28-Jul-2009.) */

theorem dedth2v (ph : wff, ps : wff, ch : wff, th : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , C ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , D ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- th ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of dedth2v {
	step 1 : wff = dedth2h (hyp 1, hyp 2, hyp 3) |- ( ( ph ∧ ph ) → ps ) ;;
	step 2 : wff = anidms (step 1) |- ( ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Weak deduction theorem for eliminating a hypothesis with 3 class
       variables.  See comments in ~ dedth2v .  (Contributed by NM,
       13-Aug-1999.)  (Proof shortened by Eric Schmidt, 28-Jul-2009.) */

theorem dedth3v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, A : class, B : class, C : class, D : class, R : class, S : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , D ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , R ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , C , S ) → ( th ↔ ta ) ) ;;
	hyp 4 : wff = |- ta ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of dedth3v {
	step 1 : wff = dedth3h (hyp 1, hyp 2, hyp 3, hyp 4) |- ( ( ph ∧ ph ∧ ph ) → ps ) ;;
	step 2 : wff = 3anidm12 (step 1) |- ( ( ph ∧ ph ) → ps ) ;;
	step 3 : wff = anidms (step 2) |- ( ph → ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Weak deduction theorem for eliminating a hypothesis with 4 class
       variables.  See comments in ~ dedth2v .  (Contributed by NM,
       21-Apr-2007.)  (Proof shortened by Eric Schmidt, 28-Jul-2009.) */

theorem dedth4v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, A : class, B : class, C : class, D : class, R : class, S : class, T : class, U : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , R ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , S ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , C , T ) → ( th ↔ ta ) ) ;;
	hyp 4 : wff = |- ( D = if ( ph , D , U ) → ( ta ↔ et ) ) ;;
	hyp 5 : wff = |- et ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of dedth4v {
	step 1 : wff = dedth4h (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5) |- ( ( ( ph ∧ ph ) ∧ ( ph ∧ ph ) ) → ps ) ;;
	step 2 : wff = anidms (step 1) |- ( ( ph ∧ ph ) → ps ) ;;
	step 3 : wff = anidms (step 2) |- ( ph → ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Eliminate a hypothesis containing class variable ` A ` when it is known
       for a specific class ` B ` .  For more information, see comments in
       ~ dedth .  (Contributed by NM, 15-May-1999.) */

theorem elimhyp (ph : wff, ps : wff, ch : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , B ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , A , B ) → ( ch ↔ ps ) ) ;;
	hyp 3 : wff = |- ch ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of elimhyp {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , B ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ph ↔ ps ) ) ;;
	step 4 : wff = ibi (step 3) |- ( ph → ps ) ;;
	step 5 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 6 : wff = eqcomd (step 5) |- ( ¬ ph → B = if ( ph , A , B ) ) ;;
	step 7 : wff = syl (step 6, hyp 2) |- ( ¬ ph → ( ch ↔ ps ) ) ;;
	step 8 : wff = mpbii (hyp 3, step 7) |- ( ¬ ph → ps ) ;;
	step 9 : wff = pm2.61i (step 4, step 8) |- ps ;;
	qed prop 1 = step 9 ;;
}

/* Eliminate a hypothesis containing 2 class variables.  (Contributed by
       NM, 14-Aug-1999.) */

theorem elimhyp2v (ph : wff, ch : wff, th : wff, ta : wff, et : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , C ) → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , D ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , A , C ) → ( ta ↔ et ) ) ;;
	hyp 4 : wff = |- ( D = if ( ph , B , D ) → ( et ↔ th ) ) ;;
	hyp 5 : wff = |- ta ;;
	-----------------------
	prop 1 : wff = |- th ;;
}

proof of elimhyp2v {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , C ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , C ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ph ↔ ch ) ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , D ) = B ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ph → B = if ( ph , B , D ) ) ;;
	step 6 : wff = syl (step 5, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 7 : wff = bitrd (step 3, step 6) |- ( ph → ( ph ↔ th ) ) ;;
	step 8 : wff = ibi (step 7) |- ( ph → th ) ;;
	step 9 : wff = iffalse () |- ( ¬ ph → if ( ph , A , C ) = C ) ;;
	step 10 : wff = eqcomd (step 9) |- ( ¬ ph → C = if ( ph , A , C ) ) ;;
	step 11 : wff = syl (step 10, hyp 3) |- ( ¬ ph → ( ta ↔ et ) ) ;;
	step 12 : wff = iffalse () |- ( ¬ ph → if ( ph , B , D ) = D ) ;;
	step 13 : wff = eqcomd (step 12) |- ( ¬ ph → D = if ( ph , B , D ) ) ;;
	step 14 : wff = syl (step 13, hyp 4) |- ( ¬ ph → ( et ↔ th ) ) ;;
	step 15 : wff = bitrd (step 11, step 14) |- ( ¬ ph → ( ta ↔ th ) ) ;;
	step 16 : wff = mpbii (hyp 5, step 15) |- ( ¬ ph → th ) ;;
	step 17 : wff = pm2.61i (step 8, step 16) |- th ;;
	qed prop 1 = step 17 ;;
}

/* Eliminate a hypothesis containing 3 class variables.  (Contributed by
       NM, 14-Aug-1999.) */

theorem elimhyp3v (ph : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, si : wff, A : class, B : class, C : class, D : class, R : class, S : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , D ) → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , R ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , C , S ) → ( th ↔ ta ) ) ;;
	hyp 4 : wff = |- ( D = if ( ph , A , D ) → ( et ↔ ze ) ) ;;
	hyp 5 : wff = |- ( R = if ( ph , B , R ) → ( ze ↔ si ) ) ;;
	hyp 6 : wff = |- ( S = if ( ph , C , S ) → ( si ↔ ta ) ) ;;
	hyp 7 : wff = |- et ;;
	-----------------------
	prop 1 : wff = |- ta ;;
}

proof of elimhyp3v {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , D ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , D ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ph ↔ ch ) ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , R ) = B ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ph → B = if ( ph , B , R ) ) ;;
	step 6 : wff = syl (step 5, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 7 : wff = iftrue () |- ( ph → if ( ph , C , S ) = C ) ;;
	step 8 : wff = eqcomd (step 7) |- ( ph → C = if ( ph , C , S ) ) ;;
	step 9 : wff = syl (step 8, hyp 3) |- ( ph → ( th ↔ ta ) ) ;;
	step 10 : wff = 3bitrd (step 3, step 6, step 9) |- ( ph → ( ph ↔ ta ) ) ;;
	step 11 : wff = ibi (step 10) |- ( ph → ta ) ;;
	step 12 : wff = iffalse () |- ( ¬ ph → if ( ph , A , D ) = D ) ;;
	step 13 : wff = eqcomd (step 12) |- ( ¬ ph → D = if ( ph , A , D ) ) ;;
	step 14 : wff = syl (step 13, hyp 4) |- ( ¬ ph → ( et ↔ ze ) ) ;;
	step 15 : wff = iffalse () |- ( ¬ ph → if ( ph , B , R ) = R ) ;;
	step 16 : wff = eqcomd (step 15) |- ( ¬ ph → R = if ( ph , B , R ) ) ;;
	step 17 : wff = syl (step 16, hyp 5) |- ( ¬ ph → ( ze ↔ si ) ) ;;
	step 18 : wff = iffalse () |- ( ¬ ph → if ( ph , C , S ) = S ) ;;
	step 19 : wff = eqcomd (step 18) |- ( ¬ ph → S = if ( ph , C , S ) ) ;;
	step 20 : wff = syl (step 19, hyp 6) |- ( ¬ ph → ( si ↔ ta ) ) ;;
	step 21 : wff = 3bitrd (step 14, step 17, step 20) |- ( ¬ ph → ( et ↔ ta ) ) ;;
	step 22 : wff = mpbii (hyp 7, step 21) |- ( ¬ ph → ta ) ;;
	step 23 : wff = pm2.61i (step 11, step 22) |- ta ;;
	qed prop 1 = step 23 ;;
}

/* Eliminate a hypothesis containing 4 class variables (for use with the
       weak deduction theorem ~ dedth ).  (Contributed by NM, 16-Apr-2005.) */

theorem elimhyp4v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, si : wff, rh : wff, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , D ) → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , R ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , C , S ) → ( th ↔ ta ) ) ;;
	hyp 4 : wff = |- ( F = if ( ph , F , G ) → ( ta ↔ ps ) ) ;;
	hyp 5 : wff = |- ( D = if ( ph , A , D ) → ( et ↔ ze ) ) ;;
	hyp 6 : wff = |- ( R = if ( ph , B , R ) → ( ze ↔ si ) ) ;;
	hyp 7 : wff = |- ( S = if ( ph , C , S ) → ( si ↔ rh ) ) ;;
	hyp 8 : wff = |- ( G = if ( ph , F , G ) → ( rh ↔ ps ) ) ;;
	hyp 9 : wff = |- et ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of elimhyp4v {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , D ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , D ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ph ↔ ch ) ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , R ) = B ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ph → B = if ( ph , B , R ) ) ;;
	step 6 : wff = syl (step 5, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 7 : wff = bitrd (step 3, step 6) |- ( ph → ( ph ↔ th ) ) ;;
	step 8 : wff = iftrue () |- ( ph → if ( ph , C , S ) = C ) ;;
	step 9 : wff = eqcomd (step 8) |- ( ph → C = if ( ph , C , S ) ) ;;
	step 10 : wff = syl (step 9, hyp 3) |- ( ph → ( th ↔ ta ) ) ;;
	step 11 : wff = iftrue () |- ( ph → if ( ph , F , G ) = F ) ;;
	step 12 : wff = eqcomd (step 11) |- ( ph → F = if ( ph , F , G ) ) ;;
	step 13 : wff = syl (step 12, hyp 4) |- ( ph → ( ta ↔ ps ) ) ;;
	step 14 : wff = 3bitrd (step 7, step 10, step 13) |- ( ph → ( ph ↔ ps ) ) ;;
	step 15 : wff = ibi (step 14) |- ( ph → ps ) ;;
	step 16 : wff = iffalse () |- ( ¬ ph → if ( ph , A , D ) = D ) ;;
	step 17 : wff = eqcomd (step 16) |- ( ¬ ph → D = if ( ph , A , D ) ) ;;
	step 18 : wff = syl (step 17, hyp 5) |- ( ¬ ph → ( et ↔ ze ) ) ;;
	step 19 : wff = iffalse () |- ( ¬ ph → if ( ph , B , R ) = R ) ;;
	step 20 : wff = eqcomd (step 19) |- ( ¬ ph → R = if ( ph , B , R ) ) ;;
	step 21 : wff = syl (step 20, hyp 6) |- ( ¬ ph → ( ze ↔ si ) ) ;;
	step 22 : wff = bitrd (step 18, step 21) |- ( ¬ ph → ( et ↔ si ) ) ;;
	step 23 : wff = iffalse () |- ( ¬ ph → if ( ph , C , S ) = S ) ;;
	step 24 : wff = eqcomd (step 23) |- ( ¬ ph → S = if ( ph , C , S ) ) ;;
	step 25 : wff = syl (step 24, hyp 7) |- ( ¬ ph → ( si ↔ rh ) ) ;;
	step 26 : wff = iffalse () |- ( ¬ ph → if ( ph , F , G ) = G ) ;;
	step 27 : wff = eqcomd (step 26) |- ( ¬ ph → G = if ( ph , F , G ) ) ;;
	step 28 : wff = syl (step 27, hyp 8) |- ( ¬ ph → ( rh ↔ ps ) ) ;;
	step 29 : wff = 3bitrd (step 22, step 25, step 28) |- ( ¬ ph → ( et ↔ ps ) ) ;;
	step 30 : wff = mpbii (hyp 9, step 29) |- ( ¬ ph → ps ) ;;
	step 31 : wff = pm2.61i (step 15, step 30) |- ps ;;
	qed prop 1 = step 31 ;;
}

/* Eliminate a membership hypothesis for weak deduction theorem, when
       special case ` B e. C ` is provable.  (Contributed by NM,
       15-May-1999.) */

theorem elimel (A : class, B : class, C : class)  {
	hyp 1 : wff = |- B ∈ C ;;
	-----------------------
	prop 1 : wff = |- if ( A ∈ C , A , B ) ∈ C ;;
}

proof of elimel {
	step 1 : wff = eleq1 () |- ( A = if ( A ∈ C , A , B ) → ( A ∈ C ↔ if ( A ∈ C , A , B ) ∈ C ) ) ;;
	step 2 : wff = eleq1 () |- ( B = if ( A ∈ C , A , B ) → ( B ∈ C ↔ if ( A ∈ C , A , B ) ∈ C ) ) ;;
	step 3 : wff = elimhyp (step 1, step 2, hyp 1) |- if ( A ∈ C , A , B ) ∈ C ;;
	qed prop 1 = step 3 ;;
}

/* Version of ~ elimhyp where the hypothesis is deduced from the final
       antecedent.  See ~ ghomgrplem for an example of its use.  (Contributed
       by Paul Chapman, 25-Mar-2008.) */

theorem elimdhyp (ph : wff, ps : wff, ch : wff, th : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( A = if ( ph , A , B ) → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( B = if ( ph , A , B ) → ( th ↔ ch ) ) ;;
	hyp 4 : wff = |- th ;;
	-----------------------
	prop 1 : wff = |- ch ;;
}

proof of elimdhyp {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , B ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , B ) ) ;;
	step 3 : wff = syl (step 2, hyp 2) |- ( ph → ( ps ↔ ch ) ) ;;
	step 4 : wff = mpbid (hyp 1, step 3) |- ( ph → ch ) ;;
	step 5 : wff = iffalse () |- ( ¬ ph → if ( ph , A , B ) = B ) ;;
	step 6 : wff = eqcomd (step 5) |- ( ¬ ph → B = if ( ph , A , B ) ) ;;
	step 7 : wff = syl (step 6, hyp 3) |- ( ¬ ph → ( th ↔ ch ) ) ;;
	step 8 : wff = mpbii (hyp 4, step 7) |- ( ¬ ph → ch ) ;;
	step 9 : wff = pm2.61i (step 4, step 8) |- ch ;;
	qed prop 1 = step 9 ;;
}

/* Transform a hypothesis ` ps ` that we want to keep (but contains the
       same class variable ` A ` used in the eliminated hypothesis) for use
       with the weak deduction theorem.  (Contributed by NM, 15-May-1999.) */

theorem keephyp (ph : wff, ps : wff, ch : wff, th : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , B ) → ( ps ↔ th ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , A , B ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ps ;;
	hyp 4 : wff = |- ch ;;
	-----------------------
	prop 1 : wff = |- th ;;
}

proof of keephyp {
	step 1 : wff = ifboth (hyp 1, hyp 2) |- ( ( ps ∧ ch ) → th ) ;;
	step 2 : wff = mp2an (hyp 3, hyp 4, step 1) |- th ;;
	qed prop 1 = step 2 ;;
}

/* Keep a hypothesis containing 2 class variables (for use with the weak
       deduction theorem ~ dedth ).  (Contributed by NM, 16-Apr-2005.) */

theorem keephyp2v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , C ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , D ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , A , C ) → ( ta ↔ et ) ) ;;
	hyp 4 : wff = |- ( D = if ( ph , B , D ) → ( et ↔ th ) ) ;;
	hyp 5 : wff = |- ps ;;
	hyp 6 : wff = |- ta ;;
	-----------------------
	prop 1 : wff = |- th ;;
}

proof of keephyp2v {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , C ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , C ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( ps ↔ ch ) ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , D ) = B ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ph → B = if ( ph , B , D ) ) ;;
	step 6 : wff = syl (step 5, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 7 : wff = bitrd (step 3, step 6) |- ( ph → ( ps ↔ th ) ) ;;
	step 8 : wff = mpbii (hyp 5, step 7) |- ( ph → th ) ;;
	step 9 : wff = iffalse () |- ( ¬ ph → if ( ph , A , C ) = C ) ;;
	step 10 : wff = eqcomd (step 9) |- ( ¬ ph → C = if ( ph , A , C ) ) ;;
	step 11 : wff = syl (step 10, hyp 3) |- ( ¬ ph → ( ta ↔ et ) ) ;;
	step 12 : wff = iffalse () |- ( ¬ ph → if ( ph , B , D ) = D ) ;;
	step 13 : wff = eqcomd (step 12) |- ( ¬ ph → D = if ( ph , B , D ) ) ;;
	step 14 : wff = syl (step 13, hyp 4) |- ( ¬ ph → ( et ↔ th ) ) ;;
	step 15 : wff = bitrd (step 11, step 14) |- ( ¬ ph → ( ta ↔ th ) ) ;;
	step 16 : wff = mpbii (hyp 6, step 15) |- ( ¬ ph → th ) ;;
	step 17 : wff = pm2.61i (step 8, step 16) |- th ;;
	qed prop 1 = step 17 ;;
}

/* Keep a hypothesis containing 3 class variables.  (Contributed by NM,
       27-Sep-1999.) */

theorem keephyp3v (ph : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, si : wff, rh : wff, A : class, B : class, C : class, D : class, R : class, S : class)  {
	hyp 1 : wff = |- ( A = if ( ph , A , D ) → ( rh ↔ ch ) ) ;;
	hyp 2 : wff = |- ( B = if ( ph , B , R ) → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( C = if ( ph , C , S ) → ( th ↔ ta ) ) ;;
	hyp 4 : wff = |- ( D = if ( ph , A , D ) → ( et ↔ ze ) ) ;;
	hyp 5 : wff = |- ( R = if ( ph , B , R ) → ( ze ↔ si ) ) ;;
	hyp 6 : wff = |- ( S = if ( ph , C , S ) → ( si ↔ ta ) ) ;;
	hyp 7 : wff = |- rh ;;
	hyp 8 : wff = |- et ;;
	-----------------------
	prop 1 : wff = |- ta ;;
}

proof of keephyp3v {
	step 1 : wff = iftrue () |- ( ph → if ( ph , A , D ) = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → A = if ( ph , A , D ) ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( ph → ( rh ↔ ch ) ) ;;
	step 4 : wff = iftrue () |- ( ph → if ( ph , B , R ) = B ) ;;
	step 5 : wff = eqcomd (step 4) |- ( ph → B = if ( ph , B , R ) ) ;;
	step 6 : wff = syl (step 5, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 7 : wff = iftrue () |- ( ph → if ( ph , C , S ) = C ) ;;
	step 8 : wff = eqcomd (step 7) |- ( ph → C = if ( ph , C , S ) ) ;;
	step 9 : wff = syl (step 8, hyp 3) |- ( ph → ( th ↔ ta ) ) ;;
	step 10 : wff = 3bitrd (step 3, step 6, step 9) |- ( ph → ( rh ↔ ta ) ) ;;
	step 11 : wff = mpbii (hyp 7, step 10) |- ( ph → ta ) ;;
	step 12 : wff = iffalse () |- ( ¬ ph → if ( ph , A , D ) = D ) ;;
	step 13 : wff = eqcomd (step 12) |- ( ¬ ph → D = if ( ph , A , D ) ) ;;
	step 14 : wff = syl (step 13, hyp 4) |- ( ¬ ph → ( et ↔ ze ) ) ;;
	step 15 : wff = iffalse () |- ( ¬ ph → if ( ph , B , R ) = R ) ;;
	step 16 : wff = eqcomd (step 15) |- ( ¬ ph → R = if ( ph , B , R ) ) ;;
	step 17 : wff = syl (step 16, hyp 5) |- ( ¬ ph → ( ze ↔ si ) ) ;;
	step 18 : wff = iffalse () |- ( ¬ ph → if ( ph , C , S ) = S ) ;;
	step 19 : wff = eqcomd (step 18) |- ( ¬ ph → S = if ( ph , C , S ) ) ;;
	step 20 : wff = syl (step 19, hyp 6) |- ( ¬ ph → ( si ↔ ta ) ) ;;
	step 21 : wff = 3bitrd (step 14, step 17, step 20) |- ( ¬ ph → ( et ↔ ta ) ) ;;
	step 22 : wff = mpbii (hyp 8, step 21) |- ( ¬ ph → ta ) ;;
	step 23 : wff = pm2.61i (step 11, step 22) |- ta ;;
	qed prop 1 = step 23 ;;
}

/* Keep a membership hypothesis for weak deduction theorem, when special
       case ` B e. C ` is provable.  (Contributed by NM, 14-Aug-1999.) */

theorem keepel (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ C ;;
	hyp 2 : wff = |- B ∈ C ;;
	-----------------------
	prop 1 : wff = |- if ( ph , A , B ) ∈ C ;;
}

proof of keepel {
	step 1 : wff = eleq1 () |- ( A = if ( ph , A , B ) → ( A ∈ C ↔ if ( ph , A , B ) ∈ C ) ) ;;
	step 2 : wff = eleq1 () |- ( B = if ( ph , A , B ) → ( B ∈ C ↔ if ( ph , A , B ) ∈ C ) ) ;;
	step 3 : wff = keephyp (step 1, step 2, hyp 1, hyp 2) |- if ( ph , A , B ) ∈ C ;;
	qed prop 1 = step 3 ;;
}

/* Conditional operator existence.  (Contributed by NM, 2-Sep-2004.) */

theorem ifex (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- if ( ph , A , B ) ∈ _V ;;
}

proof of ifex {
	step 1 : wff = keepel (hyp 1, hyp 2) |- if ( ph , A , B ) ∈ _V ;;
	qed prop 1 = step 1 ;;
}

/* Conditional operator existence.  (Contributed by NM, 21-Mar-2011.) */

theorem ifexg (ph : wff, A : class, B : class, V : class, W : class) disjointed(A x y, B y, ph x y) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → if ( ph , A , B ) ∈ _V ) ;;
}

proof of ifexg {
	var x : set, y : set;;
	step 1 : wff = ifeq1 () |- ( x = A → if ( ph , x , y ) = if ( ph , A , y ) ) ;;
	step 2 : wff = eleq1d (step 1) |- ( x = A → ( if ( ph , x , y ) ∈ _V ↔ if ( ph , A , y ) ∈ _V ) ) ;;
	step 3 : wff = ifeq2 () |- ( y = B → if ( ph , A , y ) = if ( ph , A , B ) ) ;;
	step 4 : wff = eleq1d (step 3) |- ( y = B → ( if ( ph , A , y ) ∈ _V ↔ if ( ph , A , B ) ∈ _V ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = vex () |- y ∈ _V ;;
	step 7 : wff = ifex (step 5, step 6) |- if ( ph , x , y ) ∈ _V ;;
	step 8 : wff = vtocl2g (step 2, step 4, step 7) |- ( ( A ∈ V ∧ B ∈ W ) → if ( ph , A , B ) ∈ _V ) ;;
	qed prop 1 = step 8 ;;
}


