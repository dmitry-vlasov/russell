import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Ordered-pair_class_abstractions_(class_builders).rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Transitive classes

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Declare a new symbol. */

constant {
	symbol Tr ;;
}

/*Transitive predicate (read:  "the following class is
              transitive") */

/*Extend wff notation to include transitive classes.  Notation from
     [TakeutiZaring] p. 35. */

rule wtr (A : class) {
	term : wff = # Tr A ;;
}

/*Define the transitive class predicate.  Not to be confused with a
     transitive relation (see ~ cotr ).  Definition of [Enderton] p. 71
     extended to arbitrary classes.  For alternate definitions, see ~ dftr2
     (which is suggestive of the word "transitive"), ~ dftr3 , ~ dftr4 ,
     ~ dftr5 , and (when ` A ` is a set) ~ unisuc .  The term "complete" is
     used instead of "transitive" in Definition 3 of [Suppes] p. 130.
     (Contributed by NM, 29-Aug-1993.) */

definition df-tr (A : class)  {
	defiendum : wff = # Tr A ;;
	definiens : wff = # ⋃ A ⊆ A ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*An alternate way of defining a transitive class.  Exercise 7 of
       [TakeutiZaring] p. 40.  (Contributed by NM, 24-Apr-1994.) */

theorem dftr2 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Tr A ↔ ∀ x ∀ y ( ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ) ;;
}

proof of dftr2 {
	step 1 : wff = dfss2 () |- ( ⋃ A ⊆ A ↔ ∀ x ( x ∈ ⋃ A → x ∈ A ) ) ;;
	step 2 : wff = df-tr () |- ( Tr A ↔ ⋃ A ⊆ A ) ;;
	step 3 : wff = 19.23v () |- ( ∀ y ( ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ↔ ( ∃ y ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ) ;;
	step 4 : wff = eluni () |- ( x ∈ ⋃ A ↔ ∃ y ( x ∈ y ∧ y ∈ A ) ) ;;
	step 5 : wff = imbi1i (step 4) |- ( ( x ∈ ⋃ A → x ∈ A ) ↔ ( ∃ y ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ) ;;
	step 6 : wff = bitr4i (step 3, step 5) |- ( ∀ y ( ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ↔ ( x ∈ ⋃ A → x ∈ A ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ x ∀ y ( ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ↔ ∀ x ( x ∈ ⋃ A → x ∈ A ) ) ;;
	step 8 : wff = 3bitr4i (step 1, step 2, step 7) |- ( Tr A ↔ ∀ x ∀ y ( ( x ∈ y ∧ y ∈ A ) → x ∈ A ) ) ;;
	qed prop 1 = step 8 ;;
}

/*An alternate way of defining a transitive class.  (Contributed by NM,
       20-Mar-2004.) */

theorem dftr5 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Tr A ↔ ∀ x ∈ A ∀ y ∈ x y ∈ A ) ;;
}

proof of dftr5 {
	step 1 : wff = dftr2 () |- ( Tr A ↔ ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ) ;;
	step 2 : wff = alcom () |- ( ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ∀ x ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ) ;;
	step 3 : wff = impexp () |- ( ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ( y ∈ x → ( x ∈ A → y ∈ A ) ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ∀ y ( y ∈ x → ( x ∈ A → y ∈ A ) ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ y ∈ x ( x ∈ A → y ∈ A ) ↔ ∀ y ( y ∈ x → ( x ∈ A → y ∈ A ) ) ) ;;
	step 6 : wff = bitr4i (step 4, step 5) |- ( ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ∀ y ∈ x ( x ∈ A → y ∈ A ) ) ;;
	step 7 : wff = r19.21v () |- ( ∀ y ∈ x ( x ∈ A → y ∈ A ) ↔ ( x ∈ A → ∀ y ∈ x y ∈ A ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ( x ∈ A → ∀ y ∈ x y ∈ A ) ) ;;
	step 9 : wff = albii (step 8) |- ( ∀ x ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ∀ x ( x ∈ A → ∀ y ∈ x y ∈ A ) ) ;;
	step 10 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∈ x y ∈ A ↔ ∀ x ( x ∈ A → ∀ y ∈ x y ∈ A ) ) ;;
	step 11 : wff = bitr4i (step 9, step 10) |- ( ∀ x ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ∀ x ∈ A ∀ y ∈ x y ∈ A ) ;;
	step 12 : wff = bitri (step 2, step 11) |- ( ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ∀ x ∈ A ∀ y ∈ x y ∈ A ) ;;
	step 13 : wff = bitri (step 1, step 12) |- ( Tr A ↔ ∀ x ∈ A ∀ y ∈ x y ∈ A ) ;;
	qed prop 1 = step 13 ;;
}

/*An alternate way of defining a transitive class.  Definition 7.1 of
       [TakeutiZaring] p. 35.  (Contributed by NM, 29-Aug-1993.) */

theorem dftr3 (x : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( Tr A ↔ ∀ x ∈ A x ⊆ A ) ;;
}

proof of dftr3 {
	var y : set;;
	step 1 : wff = dftr5 () |- ( Tr A ↔ ∀ x ∈ A ∀ y ∈ x y ∈ A ) ;;
	step 2 : wff = dfss3 () |- ( x ⊆ A ↔ ∀ y ∈ x y ∈ A ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ x ∈ A x ⊆ A ↔ ∀ x ∈ A ∀ y ∈ x y ∈ A ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( Tr A ↔ ∀ x ∈ A x ⊆ A ) ;;
	qed prop 1 = step 4 ;;
}

/*An alternate way of defining a transitive class.  Definition of [Enderton]
     p. 71.  (Contributed by NM, 29-Aug-1993.) */

theorem dftr4 (A : class)  {
	prop 1 : wff = |- ( Tr A ↔ A ⊆ Pow A ) ;;
}

proof of dftr4 {
	step 1 : wff = df-tr () |- ( Tr A ↔ ⋃ A ⊆ A ) ;;
	step 2 : wff = sspwuni () |- ( A ⊆ Pow A ↔ ⋃ A ⊆ A ) ;;
	step 3 : wff = bitr4i (step 1, step 2) |- ( Tr A ↔ A ⊆ Pow A ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality theorem for the transitive class predicate.  (Contributed by NM,
     17-Sep-1993.) */

theorem treq (A : class, B : class)  {
	prop 1 : wff = |- ( A = B → ( Tr A ↔ Tr B ) ) ;;
}

proof of treq {
	step 1 : wff = unieq () |- ( A = B → ⋃ A = ⋃ B ) ;;
	step 2 : wff = sseq1d (step 1) |- ( A = B → ( ⋃ A ⊆ A ↔ ⋃ B ⊆ A ) ) ;;
	step 3 : wff = sseq2 () |- ( A = B → ( ⋃ B ⊆ A ↔ ⋃ B ⊆ B ) ) ;;
	step 4 : wff = bitrd (step 2, step 3) |- ( A = B → ( ⋃ A ⊆ A ↔ ⋃ B ⊆ B ) ) ;;
	step 5 : wff = df-tr () |- ( Tr A ↔ ⋃ A ⊆ A ) ;;
	step 6 : wff = df-tr () |- ( Tr B ↔ ⋃ B ⊆ B ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( A = B → ( Tr A ↔ Tr B ) ) ;;
	qed prop 1 = step 7 ;;
}

/*In a transitive class, the membership relation is transitive.
       (Contributed by NM, 19-Apr-1994.)  (Proof shortened by Andrew Salmon,
       9-Jul-2011.) */

theorem trel (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( Tr A → ( ( B ∈ C ∧ C ∈ A ) → B ∈ A ) ) ;;
}

proof of trel {
	var x : set, y : set;;
	step 1 : wff = dftr2 () |- ( Tr A ↔ ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ) ;;
	step 2 : wff = eleq12 () |- ( ( y = B ∧ x = C ) → ( y ∈ x ↔ B ∈ C ) ) ;;
	step 3 : wff = eleq1 () |- ( x = C → ( x ∈ A ↔ C ∈ A ) ) ;;
	step 4 : wff = adantl (step 3) |- ( ( y = B ∧ x = C ) → ( x ∈ A ↔ C ∈ A ) ) ;;
	step 5 : wff = anbi12d (step 2, step 4) |- ( ( y = B ∧ x = C ) → ( ( y ∈ x ∧ x ∈ A ) ↔ ( B ∈ C ∧ C ∈ A ) ) ) ;;
	step 6 : wff = eleq1 () |- ( y = B → ( y ∈ A ↔ B ∈ A ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( y = B ∧ x = C ) → ( y ∈ A ↔ B ∈ A ) ) ;;
	step 8 : wff = imbi12d (step 5, step 7) |- ( ( y = B ∧ x = C ) → ( ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ↔ ( ( B ∈ C ∧ C ∈ A ) → B ∈ A ) ) ) ;;
	step 9 : wff = spc2gv (step 8) |- ( ( B ∈ C ∧ C ∈ A ) → ( ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) → ( ( B ∈ C ∧ C ∈ A ) → B ∈ A ) ) ) ;;
	step 10 : wff = pm2.43b (step 9) |- ( ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) → ( ( B ∈ C ∧ C ∈ A ) → B ∈ A ) ) ;;
	step 11 : wff = sylbi (step 1, step 10) |- ( Tr A → ( ( B ∈ C ∧ C ∈ A ) → B ∈ A ) ) ;;
	qed prop 1 = step 11 ;;
}

/*In a transitive class, the membership relation is transitive.
     (Contributed by NM, 19-Apr-1994.) */

theorem trel3 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( Tr A → ( ( B ∈ C ∧ C ∈ D ∧ D ∈ A ) → B ∈ A ) ) ;;
}

proof of trel3 {
	step 1 : wff = 3anass () |- ( ( B ∈ C ∧ C ∈ D ∧ D ∈ A ) ↔ ( B ∈ C ∧ ( C ∈ D ∧ D ∈ A ) ) ) ;;
	step 2 : wff = trel () |- ( Tr A → ( ( C ∈ D ∧ D ∈ A ) → C ∈ A ) ) ;;
	step 3 : wff = anim2d (step 2) |- ( Tr A → ( ( B ∈ C ∧ ( C ∈ D ∧ D ∈ A ) ) → ( B ∈ C ∧ C ∈ A ) ) ) ;;
	step 4 : wff = syl5bi (step 1, step 3) |- ( Tr A → ( ( B ∈ C ∧ C ∈ D ∧ D ∈ A ) → ( B ∈ C ∧ C ∈ A ) ) ) ;;
	step 5 : wff = trel () |- ( Tr A → ( ( B ∈ C ∧ C ∈ A ) → B ∈ A ) ) ;;
	step 6 : wff = syld (step 4, step 5) |- ( Tr A → ( ( B ∈ C ∧ C ∈ D ∧ D ∈ A ) → B ∈ A ) ) ;;
	qed prop 1 = step 6 ;;
}

/*An element of a transitive class is a subset of the class.  (Contributed
       by NM, 7-Aug-1994.) */

theorem trss (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( Tr A → ( B ∈ A → B ⊆ A ) ) ;;
}

proof of trss {
	var x : set;;
	step 1 : wff = eleq1 () |- ( x = B → ( x ∈ A ↔ B ∈ A ) ) ;;
	step 2 : wff = sseq1 () |- ( x = B → ( x ⊆ A ↔ B ⊆ A ) ) ;;
	step 3 : wff = imbi12d (step 1, step 2) |- ( x = B → ( ( x ∈ A → x ⊆ A ) ↔ ( B ∈ A → B ⊆ A ) ) ) ;;
	step 4 : wff = imbi2d (step 3) |- ( x = B → ( ( Tr A → ( x ∈ A → x ⊆ A ) ) ↔ ( Tr A → ( B ∈ A → B ⊆ A ) ) ) ) ;;
	step 5 : wff = dftr3 () |- ( Tr A ↔ ∀ x ∈ A x ⊆ A ) ;;
	step 6 : wff = rsp () |- ( ∀ x ∈ A x ⊆ A → ( x ∈ A → x ⊆ A ) ) ;;
	step 7 : wff = sylbi (step 5, step 6) |- ( Tr A → ( x ∈ A → x ⊆ A ) ) ;;
	step 8 : wff = vtoclg (step 4, step 7) |- ( B ∈ A → ( Tr A → ( B ∈ A → B ⊆ A ) ) ) ;;
	step 9 : wff = pm2.43b (step 8) |- ( Tr A → ( B ∈ A → B ⊆ A ) ) ;;
	qed prop 1 = step 9 ;;
}

/*The intersection of transitive classes is transitive.  (Contributed by
       NM, 9-May-1994.) */

theorem trin (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( Tr A ∧ Tr B ) → Tr ( A ∩ B ) ) ;;
}

proof of trin {
	var x : set;;
	step 1 : wff = elin () |- ( x ∈ ( A ∩ B ) ↔ ( x ∈ A ∧ x ∈ B ) ) ;;
	step 2 : wff = trss () |- ( Tr A → ( x ∈ A → x ⊆ A ) ) ;;
	step 3 : wff = trss () |- ( Tr B → ( x ∈ B → x ⊆ B ) ) ;;
	step 4 : wff = im2anan9 (step 2, step 3) |- ( ( Tr A ∧ Tr B ) → ( ( x ∈ A ∧ x ∈ B ) → ( x ⊆ A ∧ x ⊆ B ) ) ) ;;
	step 5 : wff = syl5bi (step 1, step 4) |- ( ( Tr A ∧ Tr B ) → ( x ∈ ( A ∩ B ) → ( x ⊆ A ∧ x ⊆ B ) ) ) ;;
	step 6 : wff = ssin () |- ( ( x ⊆ A ∧ x ⊆ B ) ↔ x ⊆ ( A ∩ B ) ) ;;
	step 7 : wff = syl6ib (step 5, step 6) |- ( ( Tr A ∧ Tr B ) → ( x ∈ ( A ∩ B ) → x ⊆ ( A ∩ B ) ) ) ;;
	step 8 : wff = ralrimiv (step 7) |- ( ( Tr A ∧ Tr B ) → ∀ x ∈ ( A ∩ B ) x ⊆ ( A ∩ B ) ) ;;
	step 9 : wff = dftr3 () |- ( Tr ( A ∩ B ) ↔ ∀ x ∈ ( A ∩ B ) x ⊆ ( A ∩ B ) ) ;;
	step 10 : wff = sylibr (step 8, step 9) |- ( ( Tr A ∧ Tr B ) → Tr ( A ∩ B ) ) ;;
	qed prop 1 = step 10 ;;
}

/*The empty set is transitive.  (Contributed by NM, 16-Sep-1993.) */

theorem tr0 ()  {
	prop 1 : wff = |- Tr ∅ ;;
}

proof of tr0 {
	step 1 : wff = 0ss () |- ∅ ⊆ Pow ∅ ;;
	step 2 : wff = dftr4 () |- ( Tr ∅ ↔ ∅ ⊆ Pow ∅ ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- Tr ∅ ;;
	qed prop 1 = step 3 ;;
}

/*The universe is transitive.  (Contributed by NM, 14-Sep-2003.) */

theorem trv ()  {
	prop 1 : wff = |- Tr _V ;;
}

proof of trv {
	step 1 : wff = ssv () |- ⋃ _V ⊆ _V ;;
	step 2 : wff = df-tr () |- ( Tr _V ↔ ⋃ _V ⊆ _V ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- Tr _V ;;
	qed prop 1 = step 3 ;;
}

/*The indexed union of a class of transitive sets is transitive.
       (Contributed by Mario Carneiro, 16-Nov-2014.) */

theorem triun (x : set, A : class, B : class) disjointed(x y A, y B) {
	prop 1 : wff = |- ( ∀ x ∈ A Tr B → Tr ⋃_ x ∈ A B ) ;;
}

proof of triun {
	var y : set;;
	step 1 : wff = eliun () |- ( y ∈ ⋃_ x ∈ A B ↔ ∃ x ∈ A y ∈ B ) ;;
	step 2 : wff = r19.29 () |- ( ( ∀ x ∈ A Tr B ∧ ∃ x ∈ A y ∈ B ) → ∃ x ∈ A ( Tr B ∧ y ∈ B ) ) ;;
	step 3 : wff = nfcv () |- F/_ x y ;;
	step 4 : wff = nfiu1 () |- F/_ x ⋃_ x ∈ A B ;;
	step 5 : wff = nfss (step 3, step 4) |- F/ x y ⊆ ⋃_ x ∈ A B ;;
	step 6 : wff = trss () |- ( Tr B → ( y ∈ B → y ⊆ B ) ) ;;
	step 7 : wff = imp (step 6) |- ( ( Tr B ∧ y ∈ B ) → y ⊆ B ) ;;
	step 8 : wff = ssiun2 () |- ( x ∈ A → B ⊆ ⋃_ x ∈ A B ) ;;
	step 9 : wff = sstr2 () |- ( y ⊆ B → ( B ⊆ ⋃_ x ∈ A B → y ⊆ ⋃_ x ∈ A B ) ) ;;
	step 10 : wff = syl5com (step 8, step 9) |- ( x ∈ A → ( y ⊆ B → y ⊆ ⋃_ x ∈ A B ) ) ;;
	step 11 : wff = syl5 (step 7, step 10) |- ( x ∈ A → ( ( Tr B ∧ y ∈ B ) → y ⊆ ⋃_ x ∈ A B ) ) ;;
	step 12 : wff = rexlimi (step 5, step 11) |- ( ∃ x ∈ A ( Tr B ∧ y ∈ B ) → y ⊆ ⋃_ x ∈ A B ) ;;
	step 13 : wff = syl (step 2, step 12) |- ( ( ∀ x ∈ A Tr B ∧ ∃ x ∈ A y ∈ B ) → y ⊆ ⋃_ x ∈ A B ) ;;
	step 14 : wff = sylan2b (step 1, step 13) |- ( ( ∀ x ∈ A Tr B ∧ y ∈ ⋃_ x ∈ A B ) → y ⊆ ⋃_ x ∈ A B ) ;;
	step 15 : wff = ralrimiva (step 14) |- ( ∀ x ∈ A Tr B → ∀ y ∈ ⋃_ x ∈ A B y ⊆ ⋃_ x ∈ A B ) ;;
	step 16 : wff = dftr3 () |- ( Tr ⋃_ x ∈ A B ↔ ∀ y ∈ ⋃_ x ∈ A B y ⊆ ⋃_ x ∈ A B ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ∀ x ∈ A Tr B → Tr ⋃_ x ∈ A B ) ;;
	qed prop 1 = step 17 ;;
}

/*The union of a class of transitive sets is transitive.  Exercise 5(a) of
       [Enderton] p. 73.  (Contributed by Scott Fenton, 21-Feb-2011.)  (Proof
       shortened by Mario Carneiro, 26-Apr-2014.) */

theorem truni (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( ∀ x ∈ A Tr x → Tr ⋃ A ) ;;
}

proof of truni {
	step 1 : wff = triun () |- ( ∀ x ∈ A Tr x → Tr ⋃_ x ∈ A x ) ;;
	step 2 : wff = uniiun () |- ⋃ A = ⋃_ x ∈ A x ;;
	step 3 : wff = treq () |- ( ⋃ A = ⋃_ x ∈ A x → ( Tr ⋃ A ↔ Tr ⋃_ x ∈ A x ) ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ( Tr ⋃ A ↔ Tr ⋃_ x ∈ A x ) ;;
	step 5 : wff = sylibr (step 1, step 4) |- ( ∀ x ∈ A Tr x → Tr ⋃ A ) ;;
	qed prop 1 = step 5 ;;
}

/*The intersection of a class of transitive sets is transitive.  Exercise
       5(b) of [Enderton] p. 73.  (Contributed by Scott Fenton,
       25-Feb-2011.) */

theorem trint (x : set, A : class) disjointed(x y A, y) {
	prop 1 : wff = |- ( ∀ x ∈ A Tr x → Tr ⋂ A ) ;;
}

proof of trint {
	var y : set;;
	step 1 : wff = dftr3 () |- ( Tr x ↔ ∀ y ∈ x y ⊆ x ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A Tr x ↔ ∀ x ∈ A ∀ y ∈ x y ⊆ x ) ;;
	step 3 : wff = biimpi (step 2) |- ( ∀ x ∈ A Tr x → ∀ x ∈ A ∀ y ∈ x y ⊆ x ) ;;
	step 4 : wff = df-ral () |- ( ∀ y ∈ x y ⊆ x ↔ ∀ y ( y ∈ x → y ⊆ x ) ) ;;
	step 5 : wff = ralbii (step 4) |- ( ∀ x ∈ A ∀ y ∈ x y ⊆ x ↔ ∀ x ∈ A ∀ y ( y ∈ x → y ⊆ x ) ) ;;
	step 6 : wff = ralcom4 () |- ( ∀ x ∈ A ∀ y ( y ∈ x → y ⊆ x ) ↔ ∀ y ∀ x ∈ A ( y ∈ x → y ⊆ x ) ) ;;
	step 7 : wff = bitri (step 5, step 6) |- ( ∀ x ∈ A ∀ y ∈ x y ⊆ x ↔ ∀ y ∀ x ∈ A ( y ∈ x → y ⊆ x ) ) ;;
	step 8 : wff = sylib (step 3, step 7) |- ( ∀ x ∈ A Tr x → ∀ y ∀ x ∈ A ( y ∈ x → y ⊆ x ) ) ;;
	step 9 : wff = ralim () |- ( ∀ x ∈ A ( y ∈ x → y ⊆ x ) → ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 10 : wff = alimi (step 9) |- ( ∀ y ∀ x ∈ A ( y ∈ x → y ⊆ x ) → ∀ y ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 11 : wff = syl (step 8, step 10) |- ( ∀ x ∈ A Tr x → ∀ y ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 12 : wff = dftr3 () |- ( Tr ⋂ A ↔ ∀ y ∈ ⋂ A y ⊆ ⋂ A ) ;;
	step 13 : wff = df-ral () |- ( ∀ y ∈ ⋂ A y ⊆ ⋂ A ↔ ∀ y ( y ∈ ⋂ A → y ⊆ ⋂ A ) ) ;;
	step 14 : wff = vex () |- y ∈ _V ;;
	step 15 : wff = elint2 (step 14) |- ( y ∈ ⋂ A ↔ ∀ x ∈ A y ∈ x ) ;;
	step 16 : wff = ssint () |- ( y ⊆ ⋂ A ↔ ∀ x ∈ A y ⊆ x ) ;;
	step 17 : wff = imbi12i (step 15, step 16) |- ( ( y ∈ ⋂ A → y ⊆ ⋂ A ) ↔ ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 18 : wff = albii (step 17) |- ( ∀ y ( y ∈ ⋂ A → y ⊆ ⋂ A ) ↔ ∀ y ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 19 : wff = bitri (step 13, step 18) |- ( ∀ y ∈ ⋂ A y ⊆ ⋂ A ↔ ∀ y ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 20 : wff = bitri (step 12, step 19) |- ( Tr ⋂ A ↔ ∀ y ( ∀ x ∈ A y ∈ x → ∀ x ∈ A y ⊆ x ) ) ;;
	step 21 : wff = sylibr (step 11, step 20) |- ( ∀ x ∈ A Tr x → Tr ⋂ A ) ;;
	qed prop 1 = step 21 ;;
}

/*If ` A ` is transitive and non-null, then ` |^| A ` is a subset of
       ` A ` .  (Contributed by Scott Fenton, 3-Mar-2011.) */

theorem trintss (A : class) disjointed(x y A, y) {
	prop 1 : wff = |- ( ( A ≠ ∅ ∧ Tr A ) → ⋂ A ⊆ A ) ;;
}

proof of trintss {
	var x : set, y : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = elint2 (step 1) |- ( y ∈ ⋂ A ↔ ∀ x ∈ A y ∈ x ) ;;
	step 3 : wff = r19.2z () |- ( ( A ≠ ∅ ∧ ∀ x ∈ A y ∈ x ) → ∃ x ∈ A y ∈ x ) ;;
	step 4 : wff = ex (step 3) |- ( A ≠ ∅ → ( ∀ x ∈ A y ∈ x → ∃ x ∈ A y ∈ x ) ) ;;
	step 5 : wff = trel () |- ( Tr A → ( ( y ∈ x ∧ x ∈ A ) → y ∈ A ) ) ;;
	step 6 : wff = exp3acom23 (step 5) |- ( Tr A → ( x ∈ A → ( y ∈ x → y ∈ A ) ) ) ;;
	step 7 : wff = rexlimdv (step 6) |- ( Tr A → ( ∃ x ∈ A y ∈ x → y ∈ A ) ) ;;
	step 8 : wff = sylan9 (step 4, step 7) |- ( ( A ≠ ∅ ∧ Tr A ) → ( ∀ x ∈ A y ∈ x → y ∈ A ) ) ;;
	step 9 : wff = syl5bi (step 2, step 8) |- ( ( A ≠ ∅ ∧ Tr A ) → ( y ∈ ⋂ A → y ∈ A ) ) ;;
	step 10 : wff = ssrdv (step 9) |- ( ( A ≠ ∅ ∧ Tr A ) → ⋂ A ⊆ A ) ;;
	qed prop 1 = step 10 ;;
}

/*Any non-empty transitive class includes its intersection.  Exercise 2 in
       [TakeutiZaring] p. 44.  (Contributed by Andrew Salmon, 14-Nov-2011.) */

theorem trint0 (A : class) disjointed(x A) {
	prop 1 : wff = |- ( ( Tr A ∧ A ≠ ∅ ) → ⋂ A ⊆ A ) ;;
}

proof of trint0 {
	var x : set;;
	step 1 : wff = n0 () |- ( A ≠ ∅ ↔ ∃ x x ∈ A ) ;;
	step 2 : wff = intss1 () |- ( x ∈ A → ⋂ A ⊆ x ) ;;
	step 3 : wff = trss () |- ( Tr A → ( x ∈ A → x ⊆ A ) ) ;;
	step 4 : wff = com12 (step 3) |- ( x ∈ A → ( Tr A → x ⊆ A ) ) ;;
	step 5 : wff = sstr2 () |- ( ⋂ A ⊆ x → ( x ⊆ A → ⋂ A ⊆ A ) ) ;;
	step 6 : wff = sylsyld (step 2, step 4, step 5) |- ( x ∈ A → ( Tr A → ⋂ A ⊆ A ) ) ;;
	step 7 : wff = exlimiv (step 6) |- ( ∃ x x ∈ A → ( Tr A → ⋂ A ⊆ A ) ) ;;
	step 8 : wff = sylbi (step 1, step 7) |- ( A ≠ ∅ → ( Tr A → ⋂ A ⊆ A ) ) ;;
	step 9 : wff = impcom (step 8) |- ( ( Tr A ∧ A ≠ ∅ ) → ⋂ A ⊆ A ) ;;
	qed prop 1 = step 9 ;;
}


