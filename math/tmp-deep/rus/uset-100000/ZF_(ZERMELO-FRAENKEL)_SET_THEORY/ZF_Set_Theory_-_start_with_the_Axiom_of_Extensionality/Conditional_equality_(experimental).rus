import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/The_universal_class.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                    Conditional equality (experimental)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  This is a very useless definition, which "abbreviates" ` ( x = y -> ph ) ` as
  ` CondEq ( x = y -> ph ) ` . What this display hides, though, is that the
  first expression, even though it has a shorter constant string, is actually
  much more complicated in its parse tree: it is parsed as
  (wi (wceq (cv vx) (cv vy)) wph), while the ` CondEq ` version is parsed as
  (wcdeq vx vy wph).  It also allows us to give a name to the specific 3-ary
  operation ` ( x = y -> ph ) ` .

  This is all used as part of a metatheorem: we want to say that
  ` |- ( x = y -> ( ph ( x ) <-> ph ( y ) ) ) ` and
  ` |- ( x = y -> A ( x ) = A ( y ) ) ` are provable, for any expressions
  ` ph ( x ) ` or ` A ( x ) ` in the language.  The proof is by induction, so
  the base case is each of the primitives, which is why you will see a theorem
  for each of the set.mm primitive operations.

  The metatheorem comes with a disjoint variables assumption: every variable in
  ` ph ( x ) ` is assumed disjoint from ` x ` except ` x ` itself.  For such a
  proof by induction, we must consider each of the possible forms of
  ` ph ( x ) ` .  If it is a variable other than ` x ` , then we have
  ` CondEq ( x = y -> A = A ) ` or ` CondEq ( x = y -> ( ph <-> ph ) ) ` ,
  which is provable by ~ cdeqth and reflexivity.  Since we are only working
  with class and wff expressions, it can't be ` x ` itself in set.mm, but if it
  was we'd have to also prove ` CondEq ( x = y -> x = y ) ` (where _set_
  equality is being used on the right).

  Otherwise, it is a primitive operation applied to smaller expressions.  In
  these cases, for each set variable parameter to the operation, we must
  consider if it is equal to ` x ` or not, which yields 2^n proof obligations.
  Luckily, all primitive operations in set.mm have either zero or one set
  variable, so we only need to prove one statement for the non-set constructors
  (like implication) and two for the constructors taking a set (the forall and
  the class builder).

  In each of the primitive proofs, we are allowed to assume that ` y ` is
  disjoint from ` ph ( x ) ` and vice versa, because this is maintained through
  the induction.  This is how we satisfy the DV assumptions of ~ cdeqab1 and
  ~ cdeqab .

*/

constant {
	symbol CondEq ;;
}

/*conditional equality */

/*Extend wff notation to include conditional equality.  This is a technical
     device used in the proof that ` F/ ` is the not-free predicate, and that
     definitions are conservative as a result. */

rule wcdeq (ph : wff, x : set, y : set) {
	term : wff = # CondEq ( x = y → ph ) ;;
}

/*Define conditional equality.  All the notation to the left of the ` <-> `
     is fake; the parentheses and arrows are all part of the notation, which
     could equally well be written ` CondEq x y ph ` .  On the right side is
     the actual implication arrow.  The reason for this definition is to
     "flatten" the structure on the right side (whose tree structure is
     something like (wi (wceq (cv vx) (cv vy)) wph) ) into just (wcdeq vx vy
     wph).  (Contributed by Mario Carneiro, 11-Aug-2016.) */

definition df-cdeq (ph : wff, x : set, y : set)  {
	defiendum : wff = # CondEq ( x = y → ph ) ;;
	definiens : wff = # ( x = y → ph ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Deduce conditional equality.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem cdeqi (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( x = y → ph ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ph ) ;;
}

proof of cdeqi {
	step 1 : wff = df-cdeq () |- ( CondEq ( x = y → ph ) ↔ ( x = y → ph ) ) ;;
	step 2 : wff = mpbir (hyp 1, step 1) |- CondEq ( x = y → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Property of conditional equality.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem cdeqri (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- CondEq ( x = y → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( x = y → ph ) ;;
}

proof of cdeqri {
	step 1 : wff = df-cdeq () |- ( CondEq ( x = y → ph ) ↔ ( x = y → ph ) ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- ( x = y → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduce conditional equality from a theorem.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem cdeqth (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ph ) ;;
}

proof of cdeqth {
	step 1 : wff = a1i (hyp 1) |- ( x = y → ph ) ;;
	step 2 : wff = cdeqi (step 1) |- CondEq ( x = y → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Distribute conditional equality over negation.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem cdeqnot (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
}

proof of cdeqnot {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 2 : wff = notbid (step 1) |- ( x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 3 : wff = cdeqi (step 2) |- CondEq ( x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Distribute conditional equality over quantification.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) */

theorem cdeqal (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x z, y z) {
	hyp 1 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ( ∀ z ph ↔ ∀ z ps ) ) ;;
}

proof of cdeqal {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 2 : wff = albidv (step 1) |- ( x = y → ( ∀ z ph ↔ ∀ z ps ) ) ;;
	step 3 : wff = cdeqi (step 2) |- CondEq ( x = y → ( ∀ z ph ↔ ∀ z ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Distribute conditional equality over abstraction.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) */

theorem cdeqab (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x z, y z) {
	hyp 1 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → { z | ph } = { z | ps } ) ;;
}

proof of cdeqab {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 2 : wff = abbidv (step 1) |- ( x = y → { z | ph } = { z | ps } ) ;;
	step 3 : wff = cdeqi (step 2) |- CondEq ( x = y → { z | ph } = { z | ps } ) ;;
	qed prop 1 = step 3 ;;
}

/*Distribute conditional equality over quantification.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) */

theorem cdeqal1 (ph : wff, ps : wff, x : set, y : set) disjointed(x ps, y ph) {
	hyp 1 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ( ∀ x ph ↔ ∀ y ps ) ) ;;
}

proof of cdeqal1 {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 2 : wff = cbvalv (step 1) |- ( ∀ x ph ↔ ∀ y ps ) ;;
	step 3 : wff = a1i (step 2) |- ( x = y → ( ∀ x ph ↔ ∀ y ps ) ) ;;
	step 4 : wff = cdeqi (step 3) |- CondEq ( x = y → ( ∀ x ph ↔ ∀ y ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Distribute conditional equality over abstraction.  (Contributed by
         Mario Carneiro, 11-Aug-2016.) */

theorem cdeqab1 (ph : wff, ps : wff, x : set, y : set) disjointed(x ps, y ph) {
	hyp 1 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → { x | ph } = { y | ps } ) ;;
}

proof of cdeqab1 {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 2 : wff = cbvabv (step 1) |- { x | ph } = { y | ps } ;;
	step 3 : wff = a1i (step 2) |- ( x = y → { x | ph } = { y | ps } ) ;;
	step 4 : wff = cdeqi (step 3) |- CondEq ( x = y → { x | ph } = { y | ps } ) ;;
	qed prop 1 = step 4 ;;
}

/*Distribute conditional equality over implication.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem cdeqim (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set)  {
	hyp 1 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- CondEq ( x = y → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ( ( ph → ch ) ↔ ( ps → th ) ) ) ;;
}

proof of cdeqim {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 2 : wff = cdeqri (hyp 2) |- ( x = y → ( ch ↔ th ) ) ;;
	step 3 : wff = imbi12d (step 1, step 2) |- ( x = y → ( ( ph → ch ) ↔ ( ps → th ) ) ) ;;
	step 4 : wff = cdeqi (step 3) |- CondEq ( x = y → ( ( ph → ch ) ↔ ( ps → th ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Conditional equality for set-to-class promotion.  (Contributed by Mario
     Carneiro, 11-Aug-2016.) */

theorem cdeqcv (x : set, y : set)  {
	prop 1 : wff = |- CondEq ( x = y → x = y ) ;;
}

proof of cdeqcv {
	step 1 : wff = id () |- ( x = y → x = y ) ;;
	step 2 : wff = cdeqi (step 1) |- CondEq ( x = y → x = y ) ;;
	qed prop 1 = step 2 ;;
}

/*Distribute conditional equality over equality.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem cdeqeq (x : set, y : set, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- CondEq ( x = y → A = B ) ;;
	hyp 2 : wff = |- CondEq ( x = y → C = D ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ( A = C ↔ B = D ) ) ;;
}

proof of cdeqeq {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → A = B ) ;;
	step 2 : wff = cdeqri (hyp 2) |- ( x = y → C = D ) ;;
	step 3 : wff = eqeq12d (step 1, step 2) |- ( x = y → ( A = C ↔ B = D ) ) ;;
	step 4 : wff = cdeqi (step 3) |- CondEq ( x = y → ( A = C ↔ B = D ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Distribute conditional equality over elementhood.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem cdeqel (x : set, y : set, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- CondEq ( x = y → A = B ) ;;
	hyp 2 : wff = |- CondEq ( x = y → C = D ) ;;
	-----------------------
	prop 1 : wff = |- CondEq ( x = y → ( A ∈ C ↔ B ∈ D ) ) ;;
}

proof of cdeqel {
	step 1 : wff = cdeqri (hyp 1) |- ( x = y → A = B ) ;;
	step 2 : wff = cdeqri (hyp 2) |- ( x = y → C = D ) ;;
	step 3 : wff = eleq12d (step 1, step 2) |- ( x = y → ( A ∈ C ↔ B ∈ D ) ) ;;
	step 4 : wff = cdeqi (step 3) |- CondEq ( x = y → ( A ∈ C ↔ B ∈ D ) ) ;;
	qed prop 1 = step 4 ;;
}

/*If we have a conditional equality proof, where ` ph ` is ` ph ( x ) `
       and ` ps ` is ` ph ( y ) ` , and ` ph ( x ) ` in fact does not have
       ` x ` free in it according to ` F/ ` , then ` ph ( x ) <-> ph ( y ) `
       unconditionally.  This proves that ` F/ x ph ` is actually a not-free
       predicate.  (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfcdeq (ph : wff, ps : wff, x : set, y : set) disjointed(x ps, y ph) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- CondEq ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ps ) ;;
}

proof of nfcdeq {
	step 1 : wff = sbf (hyp 1) |- ( [ y / x ] ph ↔ ph ) ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cdeqri (hyp 2) |- ( x = y → ( ph ↔ ps ) ) ;;
	step 4 : wff = sbie (step 2, step 3) |- ( [ y / x ] ph ↔ ps ) ;;
	step 5 : wff = bitr3i (step 1, step 4) |- ( ph ↔ ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Variation of ~ nfcdeq for classes.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfccdeq (x : set, y : set, A : class, B : class) disjointed(x z B, y z A) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- CondEq ( x = y → A = B ) ;;
	-----------------------
	prop 1 : wff = |- A = B ;;
}

proof of nfccdeq {
	var z : set;;
	step 1 : wff = nfcri (hyp 1) |- F/ x z ∈ A ;;
	step 2 : wff = equid () |- z = z ;;
	step 3 : wff = cdeqth (step 2) |- CondEq ( x = y → z = z ) ;;
	step 4 : wff = cdeqel (step 3, hyp 2) |- CondEq ( x = y → ( z ∈ A ↔ z ∈ B ) ) ;;
	step 5 : wff = nfcdeq (step 1, step 4) |- ( z ∈ A ↔ z ∈ B ) ;;
	step 6 : wff = eqriv (step 5) |- A = B ;;
	qed prop 1 = step 6 ;;
}

/*Let the computer know the theorems to look for to prove the metatheorem */

/*$j
    condequality 'wcdeq' from 'cdeqth';
    condcongruence 'cdeqnot' 'cdeqim' 'cdeqal1' 'cdeqal' 'cdeqcv' 'cdeqeq'
      'cdeqel' 'cdeqab1' 'cdeqab';
    notfree 'wnf' from 'nfcdeq';
    notfree 'wnfc' from 'nfccdeq';
  */


