import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Negated_equality_and_membership.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Restricted quantification

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Extend wff notation to include restricted universal quantification. */

rule wral (ph : wff, x : set, A : class) {
	term : wff = # ∀ x ∈ A ph ;;
}

/*Extend wff notation to include restricted existential quantification. */

rule wrex (ph : wff, x : set, A : class) {
	term : wff = # ∃ x ∈ A ph ;;
}

/*Extend wff notation to include restricted existential uniqueness. */

rule wreu (ph : wff, x : set, A : class) {
	term : wff = # ∃! x ∈ A ph ;;
}

/*Extend wff notation to include restricted "at most one." */

rule wrmo (ph : wff, x : set, A : class) {
	term : wff = # ∃* x ∈ A ph ;;
}

/*Extend class notation to include the restricted class abstraction (class
     builder). */

rule crab (ph : wff, x : set, A : class) {
	term : class = # { x ∈ A | ph } ;;
}

/*Define restricted universal quantification.  Special case of Definition
     4.15(3) of [TakeutiZaring] p. 22.  (Contributed by NM, 19-Aug-1993.) */

definition df-ral (ph : wff, x : set, A : class)  {
	defiendum : wff = # ∀ x ∈ A ph ;;
	definiens : wff = # ∀ x ( x ∈ A → ph ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define restricted existential quantification.  Special case of Definition
     4.15(4) of [TakeutiZaring] p. 22.  (Contributed by NM, 30-Aug-1993.) */

definition df-rex (ph : wff, x : set, A : class)  {
	defiendum : wff = # ∃ x ∈ A ph ;;
	definiens : wff = # ∃ x ( x ∈ A ∧ ph ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define restricted existential uniqueness.  (Contributed by NM,
     22-Nov-1994.) */

definition df-reu (ph : wff, x : set, A : class)  {
	defiendum : wff = # ∃! x ∈ A ph ;;
	definiens : wff = # ∃! x ( x ∈ A ∧ ph ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define restricted "at most one".  (Contributed by NM, 16-Jun-2017.) */

definition df-rmo (ph : wff, x : set, A : class)  {
	defiendum : wff = # ∃* x ∈ A ph ;;
	definiens : wff = # ∃* x ( x ∈ A ∧ ph ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define a restricted class abstraction (class builder), which is the class
     of all ` x ` in ` A ` such that ` ph ` is true.  Definition of
     [TakeutiZaring] p. 20.  (Contributed by NM, 22-Nov-1994.) */

definition df-rab (ph : wff, x : set, A : class)  {
	defiendum : class = # { x ∈ A | ph } ;;
	definiens : class = # { x | ( x ∈ A ∧ ph ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Relationship between restricted universal and existential quantifiers.
     (Contributed by NM, 21-Jan-1997.) */

theorem ralnex (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ¬ ph ↔ ¬ ∃ x ∈ A ph ) ;;
}

proof of ralnex {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ¬ ph ↔ ∀ x ( x ∈ A → ¬ ph ) ) ;;
	step 2 : wff = alinexa () |- ( ∀ x ( x ∈ A → ¬ ph ) ↔ ¬ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = xchbinxr (step 2, step 3) |- ( ∀ x ( x ∈ A → ¬ ph ) ↔ ¬ ∃ x ∈ A ph ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( ∀ x ∈ A ¬ ph ↔ ¬ ∃ x ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/*Relationship between restricted universal and existential quantifiers.
     (Contributed by NM, 21-Jan-1997.) */

theorem rexnal (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ¬ ph ↔ ¬ ∀ x ∈ A ph ) ;;
}

proof of rexnal {
	step 1 : wff = df-rex () |- ( ∃ x ∈ A ¬ ph ↔ ∃ x ( x ∈ A ∧ ¬ ph ) ) ;;
	step 2 : wff = exanali () |- ( ∃ x ( x ∈ A ∧ ¬ ph ) ↔ ¬ ∀ x ( x ∈ A → ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 4 : wff = xchbinxr (step 2, step 3) |- ( ∃ x ( x ∈ A ∧ ¬ ph ) ↔ ¬ ∀ x ∈ A ph ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( ∃ x ∈ A ¬ ph ↔ ¬ ∀ x ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/*Relationship between restricted universal and existential quantifiers.
     (Contributed by NM, 21-Jan-1997.) */

theorem dfral2 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ¬ ∃ x ∈ A ¬ ph ) ;;
}

proof of dfral2 {
	step 1 : wff = rexnal () |- ( ∃ x ∈ A ¬ ph ↔ ¬ ∀ x ∈ A ph ) ;;
	step 2 : wff = con2bii (step 1) |- ( ∀ x ∈ A ph ↔ ¬ ∃ x ∈ A ¬ ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Relationship between restricted universal and existential quantifiers.
     (Contributed by NM, 21-Jan-1997.) */

theorem dfrex2 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ¬ ∀ x ∈ A ¬ ph ) ;;
}

proof of dfrex2 {
	step 1 : wff = ralnex () |- ( ∀ x ∈ A ¬ ph ↔ ¬ ∃ x ∈ A ph ) ;;
	step 2 : wff = con2bii (step 1) |- ( ∃ x ∈ A ph ↔ ¬ ∀ x ∈ A ¬ ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted universal quantifier (deduction
       rule).  (Contributed by NM, 6-Oct-2003.) */

theorem ralbida (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
}

proof of ralbida {
	step 1 : wff = pm5.74da (hyp 2) |- ( ph → ( ( x ∈ A → ps ) ↔ ( x ∈ A → ch ) ) ) ;;
	step 2 : wff = albid (hyp 1, step 1) |- ( ph → ( ∀ x ( x ∈ A → ps ) ↔ ∀ x ( x ∈ A → ch ) ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 4 : wff = df-ral () |- ( ∀ x ∈ A ch ↔ ∀ x ( x ∈ A → ch ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 6-Oct-2003.) */

theorem rexbida (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
}

proof of rexbida {
	step 1 : wff = pm5.32da (hyp 2) |- ( ph → ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ) ;;
	step 2 : wff = exbid (hyp 1, step 1) |- ( ph → ( ∃ x ( x ∈ A ∧ ps ) ↔ ∃ x ( x ∈ A ∧ ch ) ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ A ps ↔ ∃ x ( x ∈ A ∧ ps ) ) ;;
	step 4 : wff = df-rex () |- ( ∃ x ∈ A ch ↔ ∃ x ( x ∈ A ∧ ch ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted universal quantifier (deduction
       rule).  (Contributed by NM, 4-Mar-1997.) */

theorem ralbidva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
}

proof of ralbidva {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = ralbida (step 1, hyp 1) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 9-Mar-1997.) */

theorem rexbidva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
}

proof of rexbidva {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = rexbida (step 1, hyp 1) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted universal quantifier (deduction
       rule).  (Contributed by NM, 27-Jun-1998.) */

theorem ralbid (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
}

proof of ralbid {
	step 1 : wff = adantr (hyp 2) |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	step 2 : wff = ralbida (hyp 1, step 1) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 27-Jun-1998.) */

theorem rexbid (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
}

proof of rexbid {
	step 1 : wff = adantr (hyp 2) |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	step 2 : wff = rexbida (hyp 1, step 1) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted universal quantifier (deduction
       rule).  (Contributed by NM, 20-Nov-1994.) */

theorem ralbidv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
}

proof of ralbidv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = ralbid (step 1, hyp 1) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 20-Nov-1994.) */

theorem rexbidv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
}

proof of rexbidv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = rexbid (step 1, hyp 1) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted universal quantifier (deduction
       rule).  (Contributed by NM, 6-Apr-1997.) */

theorem ralbidv2 (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ( x ∈ A → ps ) ↔ ( x ∈ B → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ) ;;
}

proof of ralbidv2 {
	step 1 : wff = albidv (hyp 1) |- ( ph → ( ∀ x ( x ∈ A → ps ) ↔ ∀ x ( x ∈ B → ch ) ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ B ch ↔ ∀ x ( x ∈ B → ch ) ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 22-May-1999.) */

theorem rexbidv2 (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ( x ∈ A ∧ ps ) ↔ ( x ∈ B ∧ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ) ;;
}

proof of rexbidv2 {
	step 1 : wff = exbidv (hyp 1) |- ( ph → ( ∃ x ( x ∈ A ∧ ps ) ↔ ∃ x ( x ∈ B ∧ ch ) ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ A ps ↔ ∃ x ( x ∈ A ∧ ps ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ B ch ↔ ∃ x ( x ∈ B ∧ ch ) ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference adding restricted universal quantifier to both sides of an
       equivalence.  (Contributed by NM, 23-Nov-1994.)  (Revised by Mario
       Carneiro, 17-Oct-2016.) */

theorem ralbii (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ;;
}

proof of ralbii {
	step 1 : wff = a1i (hyp 1) |- ( T. → ( ph ↔ ps ) ) ;;
	step 2 : wff = ralbidv (step 1) |- ( T. → ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ) ;;
	step 3 : wff = trud (step 2) |- ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference adding restricted existential quantifier to both sides of an
       equivalence.  (Contributed by NM, 23-Nov-1994.)  (Revised by Mario
       Carneiro, 17-Oct-2016.) */

theorem rexbii (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ x ∈ A ps ) ;;
}

proof of rexbii {
	step 1 : wff = a1i (hyp 1) |- ( T. → ( ph ↔ ps ) ) ;;
	step 2 : wff = rexbidv (step 1) |- ( T. → ( ∃ x ∈ A ph ↔ ∃ x ∈ A ps ) ) ;;
	step 3 : wff = trud (step 2) |- ( ∃ x ∈ A ph ↔ ∃ x ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference adding two restricted universal quantifiers to both sides of
       an equivalence.  (Contributed by NM, 1-Aug-2004.) */

theorem 2ralbii (ph : wff, ps : wff, x : set, y : set, A : class, B : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∈ A ∀ y ∈ B ps ) ;;
}

proof of 2ralbii {
	step 1 : wff = ralbii (hyp 1) |- ( ∀ y ∈ B ph ↔ ∀ y ∈ B ps ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∈ A ∀ y ∈ B ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference adding two restricted existential quantifiers to both sides of
       an equivalence.  (Contributed by NM, 11-Nov-1995.) */

theorem 2rexbii (ph : wff, ps : wff, x : set, y : set, A : class, B : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∈ A ∃ y ∈ B ps ) ;;
}

proof of 2rexbii {
	step 1 : wff = rexbii (hyp 1) |- ( ∃ y ∈ B ph ↔ ∃ y ∈ B ps ) ;;
	step 2 : wff = rexbii (step 1) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∈ A ∃ y ∈ B ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference adding different restricted universal quantifiers to each side
       of an equivalence.  (Contributed by NM, 15-Aug-2005.) */

theorem ralbii2 (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- ( ( x ∈ A → ph ) ↔ ( x ∈ B → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ x ∈ B ps ) ;;
}

proof of ralbii2 {
	step 1 : wff = albii (hyp 1) |- ( ∀ x ( x ∈ A → ph ) ↔ ∀ x ( x ∈ B → ps ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ B ps ↔ ∀ x ( x ∈ B → ps ) ) ;;
	step 4 : wff = 3bitr4i (step 1, step 2, step 3) |- ( ∀ x ∈ A ph ↔ ∀ x ∈ B ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference adding different restricted existential quantifiers to each
       side of an equivalence.  (Contributed by NM, 4-Feb-2004.) */

theorem rexbii2 (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- ( ( x ∈ A ∧ ph ) ↔ ( x ∈ B ∧ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ x ∈ B ps ) ;;
}

proof of rexbii2 {
	step 1 : wff = exbii (hyp 1) |- ( ∃ x ( x ∈ A ∧ ph ) ↔ ∃ x ( x ∈ B ∧ ps ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ B ps ↔ ∃ x ( x ∈ B ∧ ps ) ) ;;
	step 4 : wff = 3bitr4i (step 1, step 2, step 3) |- ( ∃ x ∈ A ph ↔ ∃ x ∈ B ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality deduction for restricted universal quantifier, changing both
       formula and quantifier domain.  Inference form.  (Contributed by David
       Moews, 1-May-2017.) */

theorem raleqbii (ps : wff, ch : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ;;
}

proof of raleqbii {
	step 1 : wff = eleq2i (hyp 1) |- ( x ∈ A ↔ x ∈ B ) ;;
	step 2 : wff = imbi12i (step 1, hyp 2) |- ( ( x ∈ A → ps ) ↔ ( x ∈ B → ch ) ) ;;
	step 3 : wff = ralbii2 (step 2) |- ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted existential quantifier, changing both
       formula and quantifier domain.  Inference form.  (Contributed by David
       Moews, 1-May-2017.) */

theorem rexeqbii (ps : wff, ch : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ;;
}

proof of rexeqbii {
	step 1 : wff = eleq2i (hyp 1) |- ( x ∈ A ↔ x ∈ B ) ;;
	step 2 : wff = anbi12i (step 1, hyp 2) |- ( ( x ∈ A ∧ ps ) ↔ ( x ∈ B ∧ ch ) ) ;;
	step 3 : wff = rexbii2 (step 2) |- ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference adding restricted universal quantifier to both sides of an
       equivalence.  (Contributed by NM, 26-Nov-2000.) */

theorem ralbiia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ;;
}

proof of ralbiia {
	step 1 : wff = pm5.74i (hyp 1) |- ( ( x ∈ A → ph ) ↔ ( x ∈ A → ps ) ) ;;
	step 2 : wff = ralbii2 (step 1) |- ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference adding restricted existential quantifier to both sides of an
       equivalence.  (Contributed by NM, 26-Oct-1999.) */

theorem rexbiia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ x ∈ A ps ) ;;
}

proof of rexbiia {
	step 1 : wff = pm5.32i (hyp 1) |- ( ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ps ) ) ;;
	step 2 : wff = rexbii2 (step 1) |- ( ∃ x ∈ A ph ↔ ∃ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference adding two restricted existential quantifiers to both sides of
       an equivalence.  (Contributed by NM, 1-Aug-2004.) */

theorem 2rexbiia (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y, y A) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∈ A ∃ y ∈ B ps ) ;;
}

proof of 2rexbiia {
	step 1 : wff = rexbidva (hyp 1) |- ( x ∈ A → ( ∃ y ∈ B ph ↔ ∃ y ∈ B ps ) ) ;;
	step 2 : wff = rexbiia (step 1) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∈ A ∃ y ∈ B ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Double restricted universal quantification.  (Contributed by Mario
       Carneiro, 14-Oct-2016.) */

theorem r2alf (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y) {
	hyp 1 : wff = |- F/_ y A ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
}

proof of r2alf {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ( x ∈ A → ∀ y ∈ B ph ) ) ;;
	step 2 : wff = nfcri (hyp 1) |- F/ y x ∈ A ;;
	step 3 : wff = 19.21 (step 2) |- ( ∀ y ( x ∈ A → ( y ∈ B → ph ) ) ↔ ( x ∈ A → ∀ y ( y ∈ B → ph ) ) ) ;;
	step 4 : wff = impexp () |- ( ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ( x ∈ A → ( y ∈ B → ph ) ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ∀ y ( x ∈ A → ( y ∈ B → ph ) ) ) ;;
	step 6 : wff = df-ral () |- ( ∀ y ∈ B ph ↔ ∀ y ( y ∈ B → ph ) ) ;;
	step 7 : wff = imbi2i (step 6) |- ( ( x ∈ A → ∀ y ∈ B ph ) ↔ ( x ∈ A → ∀ y ( y ∈ B → ph ) ) ) ;;
	step 8 : wff = 3bitr4i (step 3, step 5, step 7) |- ( ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ( x ∈ A → ∀ y ∈ B ph ) ) ;;
	step 9 : wff = albii (step 8) |- ( ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ∀ x ( x ∈ A → ∀ y ∈ B ph ) ) ;;
	step 10 : wff = bitr4i (step 1, step 9) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Double restricted existential quantification.  (Contributed by Mario
       Carneiro, 14-Oct-2016.) */

theorem r2exf (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y) {
	hyp 1 : wff = |- F/_ y A ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
}

proof of r2exf {
	step 1 : wff = df-rex () |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 2 : wff = nfcri (hyp 1) |- F/ y x ∈ A ;;
	step 3 : wff = 19.42 (step 2) |- ( ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ ∃ y ( y ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = anass () |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ y ∈ B ph ↔ ∃ y ( y ∈ B ∧ ph ) ) ;;
	step 7 : wff = anbi2i (step 6) |- ( ( x ∈ A ∧ ∃ y ∈ B ph ) ↔ ( x ∈ A ∧ ∃ y ( y ∈ B ∧ ph ) ) ) ;;
	step 8 : wff = 3bitr4i (step 3, step 5, step 7) |- ( ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 10 : wff = bitr4i (step 1, step 9) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Double restricted universal quantification.  (Contributed by NM,
       19-Nov-1995.) */

theorem r2al (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
}

proof of r2al {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = r2alf (step 1) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Double restricted existential quantification.  (Contributed by NM,
       11-Nov-1995.) */

theorem r2ex (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
}

proof of r2ex {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = r2exf (step 1) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted universal quantifier (deduction
       rule).  (Contributed by NM, 24-Feb-2004.) */

theorem 2ralbida (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y, y A) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ y ph ;;
	hyp 3 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ∀ y ∈ B ps ↔ ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
}

proof of 2ralbida {
	step 1 : wff = nfv () |- F/ y x ∈ A ;;
	step 2 : wff = nfan (hyp 2, step 1) |- F/ y ( ph ∧ x ∈ A ) ;;
	step 3 : wff = anassrs (hyp 3) |- ( ( ( ph ∧ x ∈ A ) ∧ y ∈ B ) → ( ps ↔ ch ) ) ;;
	step 4 : wff = ralbida (step 2, step 3) |- ( ( ph ∧ x ∈ A ) → ( ∀ y ∈ B ps ↔ ∀ y ∈ B ch ) ) ;;
	step 5 : wff = ralbida (hyp 1, step 4) |- ( ph → ( ∀ x ∈ A ∀ y ∈ B ps ↔ ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted universal quantifiers (deduction
       rule).  (Contributed by NM, 4-Mar-1997.) */

theorem 2ralbidva (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, y A) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ∀ y ∈ B ps ↔ ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
}

proof of 2ralbidva {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = 2ralbida (step 1, step 2, hyp 1) |- ( ph → ( ∀ x ∈ A ∀ y ∈ B ps ↔ ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Formula-building rule for restricted existential quantifiers (deduction
       rule).  (Contributed by NM, 15-Dec-2004.) */

theorem 2rexbidva (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, y A) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps ↔ ∃ x ∈ A ∃ y ∈ B ch ) ) ;;
}

proof of 2rexbidva {
	step 1 : wff = anassrs (hyp 1) |- ( ( ( ph ∧ x ∈ A ) ∧ y ∈ B ) → ( ps ↔ ch ) ) ;;
	step 2 : wff = rexbidva (step 1) |- ( ( ph ∧ x ∈ A ) → ( ∃ y ∈ B ps ↔ ∃ y ∈ B ch ) ) ;;
	step 3 : wff = rexbidva (step 2) |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps ↔ ∃ x ∈ A ∃ y ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Formula-building rule for restricted universal quantifiers (deduction
       rule).  (Contributed by NM, 28-Jan-2006.)  (Revised by Szymon
       Jaroszewicz, 16-Mar-2007.) */

theorem 2ralbidv (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x ph, y ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ∀ y ∈ B ps ↔ ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
}

proof of 2ralbidv {
	step 1 : wff = ralbidv (hyp 1) |- ( ph → ( ∀ y ∈ B ps ↔ ∀ y ∈ B ch ) ) ;;
	step 2 : wff = ralbidv (step 1) |- ( ph → ( ∀ x ∈ A ∀ y ∈ B ps ↔ ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifiers (deduction
       rule).  (Contributed by NM, 28-Jan-2006.) */

theorem 2rexbidv (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x ph, y ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps ↔ ∃ x ∈ A ∃ y ∈ B ch ) ) ;;
}

proof of 2rexbidv {
	step 1 : wff = rexbidv (hyp 1) |- ( ph → ( ∃ y ∈ B ps ↔ ∃ y ∈ B ch ) ) ;;
	step 2 : wff = rexbidv (step 1) |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps ↔ ∃ x ∈ A ∃ y ∈ B ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted quantifiers (deduction rule).
       (Contributed by NM, 28-Jan-2006.) */

theorem rexralbidv (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x ph, y ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ∀ y ∈ B ps ↔ ∃ x ∈ A ∀ y ∈ B ch ) ) ;;
}

proof of rexralbidv {
	step 1 : wff = ralbidv (hyp 1) |- ( ph → ( ∀ y ∈ B ps ↔ ∀ y ∈ B ch ) ) ;;
	step 2 : wff = rexbidv (step 1) |- ( ph → ( ∃ x ∈ A ∀ y ∈ B ps ↔ ∃ x ∈ A ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*A transformation of restricted quantifiers and logical connectives.
     (Contributed by NM, 4-Sep-2005.) */

theorem ralinexa (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ¬ ps ) ↔ ¬ ∃ x ∈ A ( ph ∧ ps ) ) ;;
}

proof of ralinexa {
	step 1 : wff = imnan () |- ( ( ph → ¬ ps ) ↔ ¬ ( ph ∧ ps ) ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ( ph → ¬ ps ) ↔ ∀ x ∈ A ¬ ( ph ∧ ps ) ) ;;
	step 3 : wff = ralnex () |- ( ∀ x ∈ A ¬ ( ph ∧ ps ) ↔ ¬ ∃ x ∈ A ( ph ∧ ps ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∀ x ∈ A ( ph → ¬ ps ) ↔ ¬ ∃ x ∈ A ( ph ∧ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*A transformation of restricted quantifiers and logical connectives.
     (Contributed by NM, 4-Sep-2005.) */

theorem rexanali (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∧ ¬ ps ) ↔ ¬ ∀ x ∈ A ( ph → ps ) ) ;;
}

proof of rexanali {
	step 1 : wff = annim () |- ( ( ph ∧ ¬ ps ) ↔ ¬ ( ph → ps ) ) ;;
	step 2 : wff = rexbii (step 1) |- ( ∃ x ∈ A ( ph ∧ ¬ ps ) ↔ ∃ x ∈ A ¬ ( ph → ps ) ) ;;
	step 3 : wff = rexnal () |- ( ∃ x ∈ A ¬ ( ph → ps ) ↔ ¬ ∀ x ∈ A ( ph → ps ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ x ∈ A ( ph ∧ ¬ ps ) ↔ ¬ ∀ x ∈ A ( ph → ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Two ways to say " ` A ` belongs to ` B ` ."  (Contributed by NM,
       22-Nov-1994.) */

theorem risset (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∈ B ↔ ∃ x ∈ B x = A ) ;;
}

proof of risset {
	step 1 : wff = exancom () |- ( ∃ x ( x ∈ B ∧ x = A ) ↔ ∃ x ( x = A ∧ x ∈ B ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ B x = A ↔ ∃ x ( x ∈ B ∧ x = A ) ) ;;
	step 3 : wff = df-clel () |- ( A ∈ B ↔ ∃ x ( x = A ∧ x ∈ B ) ) ;;
	step 4 : wff = 3bitr4ri (step 1, step 2, step 3) |- ( A ∈ B ↔ ∃ x ∈ B x = A ) ;;
	qed prop 1 = step 4 ;;
}

/*Bound-variable hypothesis builder for restricted quantification.
       (Contributed by NM, 1-Sep-1999.)  (Revised by David Abernethy,
       13-Dec-2009.) */

theorem hbral (ph : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- ( y ∈ A → ∀ x y ∈ A ) ;;
	hyp 2 : wff = |- ( ph → ∀ x ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ y ∈ A ph → ∀ x ∀ y ∈ A ph ) ;;
}

proof of hbral {
	step 1 : wff = df-ral () |- ( ∀ y ∈ A ph ↔ ∀ y ( y ∈ A → ph ) ) ;;
	step 2 : wff = hbim (hyp 1, hyp 2) |- ( ( y ∈ A → ph ) → ∀ x ( y ∈ A → ph ) ) ;;
	step 3 : wff = hbal (step 2) |- ( ∀ y ( y ∈ A → ph ) → ∀ x ∀ y ( y ∈ A → ph ) ) ;;
	step 4 : wff = hbxfrbi (step 1, step 3) |- ( ∀ y ∈ A ph → ∀ x ∀ y ∈ A ph ) ;;
	qed prop 1 = step 4 ;;
}

/*` x ` is not free in ` A. x e. A ph ` .  (Contributed by NM,
     18-Oct-1996.) */

theorem hbra1 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ph → ∀ x ∀ x ∈ A ph ) ;;
}

proof of hbra1 {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 2 : wff = hba1 () |- ( ∀ x ( x ∈ A → ph ) → ∀ x ∀ x ( x ∈ A → ph ) ) ;;
	step 3 : wff = hbxfrbi (step 1, step 2) |- ( ∀ x ∈ A ph → ∀ x ∀ x ∈ A ph ) ;;
	qed prop 1 = step 3 ;;
}

/*` x ` is not free in ` A. x e. A ph ` .  (Contributed by NM,
     18-Oct-1996.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem nfra1 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- F/ x ∀ x ∈ A ph ;;
}

proof of nfra1 {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ( x ∈ A → ph ) ;;
	step 3 : wff = nfxfr (step 1, step 2) |- F/ x ∀ x ∈ A ph ;;
	qed prop 1 = step 3 ;;
}

/*Deduction version of ~ nfral .  (Contributed by NM, 15-Feb-2013.)
       (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem nfrald (ph : wff, ps : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/_ x A ) ;;
	hyp 3 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∀ y ∈ A ps ) ;;
}

proof of nfrald {
	step 1 : wff = df-ral () |- ( ∀ y ∈ A ps ↔ ∀ y ( y ∈ A → ps ) ) ;;
	step 2 : wff = nfcvf () |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x y ) ;;
	step 4 : wff = adantr (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x A ) ;;
	step 5 : wff = nfeld (step 3, step 4) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x y ∈ A ) ;;
	step 6 : wff = adantr (hyp 3) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 7 : wff = nfimd (step 5, step 6) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ( y ∈ A → ps ) ) ;;
	step 8 : wff = nfald2 (hyp 1, step 7) |- ( ph → F/ x ∀ y ( y ∈ A → ps ) ) ;;
	step 9 : wff = nfxfrd (step 1, step 8) |- ( ph → F/ x ∀ y ∈ A ps ) ;;
	qed prop 1 = step 9 ;;
}

/*Deduction version of ~ nfrex .  (Contributed by Mario Carneiro,
       14-Oct-2016.) */

theorem nfrexd (ph : wff, ps : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/_ x A ) ;;
	hyp 3 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃ y ∈ A ps ) ;;
}

proof of nfrexd {
	step 1 : wff = dfrex2 () |- ( ∃ y ∈ A ps ↔ ¬ ∀ y ∈ A ¬ ps ) ;;
	step 2 : wff = nfnd (hyp 3) |- ( ph → F/ x ¬ ps ) ;;
	step 3 : wff = nfrald (hyp 1, hyp 2, step 2) |- ( ph → F/ x ∀ y ∈ A ¬ ps ) ;;
	step 4 : wff = nfnd (step 3) |- ( ph → F/ x ¬ ∀ y ∈ A ¬ ps ) ;;
	step 5 : wff = nfxfrd (step 1, step 4) |- ( ph → F/ x ∃ y ∈ A ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for restricted quantification.
       (Contributed by NM, 1-Sep-1999.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem nfral (ph : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ∀ y ∈ A ph ;;
}

proof of nfral {
	step 1 : wff = nftru () |- F/ y T. ;;
	step 2 : wff = a1i (hyp 1) |- ( T. → F/_ x A ) ;;
	step 3 : wff = a1i (hyp 2) |- ( T. → F/ x ph ) ;;
	step 4 : wff = nfrald (step 1, step 2, step 3) |- ( T. → F/ x ∀ y ∈ A ph ) ;;
	step 5 : wff = trud (step 4) |- F/ x ∀ y ∈ A ph ;;
	qed prop 1 = step 5 ;;
}

/*Similar to Lemma 24 of [Monk2] p. 114, except the quantification of the
       antecedent is restricted.  Derived automatically from ~ hbra2VD .
       Contributed by Alan Sare 31-Dec-2011.  (Contributed by NM,
       31-Dec-2011.) */

theorem nfra2 (ph : wff, x : set, y : set, A : class, B : class) disjointed(A y) {
	prop 1 : wff = |- F/ y ∀ x ∈ A ∀ y ∈ B ph ;;
}

proof of nfra2 {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = nfra1 () |- F/ y ∀ y ∈ B ph ;;
	step 3 : wff = nfral (step 1, step 2) |- F/ y ∀ x ∈ A ∀ y ∈ B ph ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for restricted quantification.
       (Contributed by NM, 1-Sep-1999.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem nfrex (ph : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ∃ y ∈ A ph ;;
}

proof of nfrex {
	step 1 : wff = dfrex2 () |- ( ∃ y ∈ A ph ↔ ¬ ∀ y ∈ A ¬ ph ) ;;
	step 2 : wff = nfn (hyp 2) |- F/ x ¬ ph ;;
	step 3 : wff = nfral (hyp 1, step 2) |- F/ x ∀ y ∈ A ¬ ph ;;
	step 4 : wff = nfn (step 3) |- F/ x ¬ ∀ y ∈ A ¬ ph ;;
	step 5 : wff = nfxfr (step 1, step 4) |- F/ x ∃ y ∈ A ph ;;
	qed prop 1 = step 5 ;;
}

/*` x ` is not free in ` E. x e. A ph ` .  (Contributed by NM,
     19-Mar-1997.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem nfre1 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- F/ x ∃ x ∈ A ph ;;
}

proof of nfre1 {
	step 1 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = nfe1 () |- F/ x ∃ x ( x ∈ A ∧ ph ) ;;
	step 3 : wff = nfxfr (step 1, step 2) |- F/ x ∃ x ∈ A ph ;;
	qed prop 1 = step 3 ;;
}

/*Triple restricted universal quantification.  (Contributed by NM,
       19-Nov-1995.) */

theorem r3al (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x y z, y z A, z B) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ x ∀ y ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ) ;;
}

proof of r3al {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ↔ ∀ x ( x ∈ A → ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 2 : wff = r2al () |- ( ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ x ∈ A ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ;;
	step 4 : wff = 3anass () |- ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ z ∈ C ) ) ) ;;
	step 5 : wff = imbi1i (step 4) |- ( ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ( ( x ∈ A ∧ ( y ∈ B ∧ z ∈ C ) ) → ph ) ) ;;
	step 6 : wff = impexp () |- ( ( ( x ∈ A ∧ ( y ∈ B ∧ z ∈ C ) ) → ph ) ↔ ( x ∈ A → ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 7 : wff = bitri (step 5, step 6) |- ( ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ( x ∈ A → ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ∀ z ( x ∈ A → ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 9 : wff = 19.21v () |- ( ∀ z ( x ∈ A → ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ↔ ( x ∈ A → ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 10 : wff = bitri (step 8, step 9) |- ( ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ( x ∈ A → ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ y ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ∀ y ( x ∈ A → ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 12 : wff = 19.21v () |- ( ∀ y ( x ∈ A → ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ↔ ( x ∈ A → ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 13 : wff = bitri (step 11, step 12) |- ( ∀ y ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ( x ∈ A → ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 14 : wff = albii (step 13) |- ( ∀ x ∀ y ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ↔ ∀ x ( x ∈ A → ∀ y ∀ z ( ( y ∈ B ∧ z ∈ C ) → ph ) ) ) ;;
	step 15 : wff = 3bitr4i (step 1, step 3, step 14) |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ x ∀ y ∀ z ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ) ;;
	qed prop 1 = step 15 ;;
}

/*Universal quantification implies restricted quantification.  (Contributed
     by NM, 20-Oct-2006.) */

theorem alral (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ph → ∀ x ∈ A ph ) ;;
}

proof of alral {
	step 1 : wff = ax-1 () |- ( ph → ( x ∈ A → ph ) ) ;;
	step 2 : wff = alimi (step 1) |- ( ∀ x ph → ∀ x ( x ∈ A → ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 4 : wff = sylibr (step 2, step 3) |- ( ∀ x ph → ∀ x ∈ A ph ) ;;
	qed prop 1 = step 4 ;;
}

/*Restricted existence implies existence.  (Contributed by NM,
     11-Nov-1995.) */

theorem rexex (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ph → ∃ x ph ) ;;
}

proof of rexex {
	step 1 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = simpr () |- ( ( x ∈ A ∧ ph ) → ph ) ;;
	step 3 : wff = eximi (step 2) |- ( ∃ x ( x ∈ A ∧ ph ) → ∃ x ph ) ;;
	step 4 : wff = sylbi (step 1, step 3) |- ( ∃ x ∈ A ph → ∃ x ph ) ;;
	qed prop 1 = step 4 ;;
}

/*Restricted specialization.  (Contributed by NM, 17-Oct-1996.) */

theorem rsp (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ph → ( x ∈ A → ph ) ) ;;
}

proof of rsp {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 2 : wff = sp () |- ( ∀ x ( x ∈ A → ph ) → ( x ∈ A → ph ) ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( ∀ x ∈ A ph → ( x ∈ A → ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Restricted specialization.  (Contributed by NM, 12-Oct-1999.) */

theorem rspe (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ( x ∈ A ∧ ph ) → ∃ x ∈ A ph ) ;;
}

proof of rspe {
	step 1 : wff = 19.8a () |- ( ( x ∈ A ∧ ph ) → ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ( x ∈ A ∧ ph ) → ∃ x ∈ A ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Restricted specialization.  (Contributed by NM, 11-Feb-1997.) */

theorem rsp2 (ph : wff, x : set, y : set, A : class, B : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph → ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
}

proof of rsp2 {
	step 1 : wff = rsp () |- ( ∀ x ∈ A ∀ y ∈ B ph → ( x ∈ A → ∀ y ∈ B ph ) ) ;;
	step 2 : wff = rsp () |- ( ∀ y ∈ B ph → ( y ∈ B → ph ) ) ;;
	step 3 : wff = syl6 (step 1, step 2) |- ( ∀ x ∈ A ∀ y ∈ B ph → ( x ∈ A → ( y ∈ B → ph ) ) ) ;;
	step 4 : wff = imp3a (step 3) |- ( ∀ x ∈ A ∀ y ∈ B ph → ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Restricted specialization.  (Contributed by FL, 4-Jun-2012.) */

theorem rsp2e (ph : wff, x : set, y : set, A : class, B : class)  {
	prop 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ∃ x ∈ A ∃ y ∈ B ph ) ;;
}

proof of rsp2e {
	step 1 : wff = simp1 () |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) → x ∈ A ) ;;
	step 2 : wff = rspe () |- ( ( y ∈ B ∧ ph ) → ∃ y ∈ B ph ) ;;
	step 3 : wff = 3adant1 (step 2) |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ∃ y ∈ B ph ) ;;
	step 4 : wff = 19.8a () |- ( ( x ∈ A ∧ ∃ y ∈ B ph ) → ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 5 : wff = syl2anc (step 1, step 3, step 4) |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 7 : wff = sylibr (step 5, step 6) |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ∃ x ∈ A ∃ y ∈ B ph ) ;;
	qed prop 1 = step 7 ;;
}

/*Specialization rule for restricted quantification.  (Contributed by NM,
       19-Nov-1994.) */

theorem rspec (ph : wff, x : set, A : class)  {
	hyp 1 : wff = |- ∀ x ∈ A ph ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A → ph ) ;;
}

proof of rspec {
	step 1 : wff = rsp () |- ( ∀ x ∈ A ph → ( x ∈ A → ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( x ∈ A → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Generalization rule for restricted quantification.  (Contributed by NM,
       19-Nov-1994.) */

theorem rgen (ph : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ph ) ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ph ;;
}

proof of rgen {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 2 : wff = mpgbir (step 1, hyp 1) |- ∀ x ∈ A ph ;;
	qed prop 1 = step 2 ;;
}

/*Generalization rule for restricted quantification.  Note that ` x ` and
       ` y ` needn't be distinct (and illustrates the use of ~ dvelim ).
       (Contributed by NM, 23-Nov-1994.)  (Proof shortened by Andrew Salmon,
       25-May-2011.)  (Proof modification is discouraged. */

theorem rgen2a (ph : wff, x : set, y : set, A : class) disjointed(y z A, x z) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ A ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ∀ y ∈ A ph ;;
}

proof of rgen2a {
	var z : set;;
	step 1 : wff = eleq1 () |- ( y = x → ( y ∈ A ↔ x ∈ A ) ) ;;
	step 2 : wff = ex (hyp 1) |- ( x ∈ A → ( y ∈ A → ph ) ) ;;
	step 3 : wff = syl6bi (step 1, step 2) |- ( y = x → ( y ∈ A → ( y ∈ A → ph ) ) ) ;;
	step 4 : wff = pm2.43d (step 3) |- ( y = x → ( y ∈ A → ph ) ) ;;
	step 5 : wff = alimi (step 4) |- ( ∀ y y = x → ∀ y ( y ∈ A → ph ) ) ;;
	step 6 : wff = a1d (step 5) |- ( ∀ y y = x → ( x ∈ A → ∀ y ( y ∈ A → ph ) ) ) ;;
	step 7 : wff = eleq1 () |- ( z = x → ( z ∈ A ↔ x ∈ A ) ) ;;
	step 8 : wff = dvelimv (step 7) |- ( ¬ ∀ y y = x → ( x ∈ A → ∀ y x ∈ A ) ) ;;
	step 9 : wff = ex (hyp 1) |- ( x ∈ A → ( y ∈ A → ph ) ) ;;
	step 10 : wff = alimi (step 9) |- ( ∀ y x ∈ A → ∀ y ( y ∈ A → ph ) ) ;;
	step 11 : wff = syl6 (step 8, step 10) |- ( ¬ ∀ y y = x → ( x ∈ A → ∀ y ( y ∈ A → ph ) ) ) ;;
	step 12 : wff = pm2.61i (step 6, step 11) |- ( x ∈ A → ∀ y ( y ∈ A → ph ) ) ;;
	step 13 : wff = df-ral () |- ( ∀ y ∈ A ph ↔ ∀ y ( y ∈ A → ph ) ) ;;
	step 14 : wff = sylibr (step 12, step 13) |- ( x ∈ A → ∀ y ∈ A ph ) ;;
	step 15 : wff = rgen (step 14) |- ∀ x ∈ A ∀ y ∈ A ph ;;
	qed prop 1 = step 15 ;;
}

/*Generalization rule for restricted quantification.  (Contributed by NM,
       18-Jun-2014.) */

theorem rgenw (ph : wff, x : set, A : class)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ph ;;
}

proof of rgenw {
	step 1 : wff = a1i (hyp 1) |- ( x ∈ A → ph ) ;;
	step 2 : wff = rgen (step 1) |- ∀ x ∈ A ph ;;
	qed prop 1 = step 2 ;;
}

/*Generalization rule for restricted quantification.  Note that ` x ` and
       ` y ` needn't be distinct.  (Contributed by NM, 18-Jun-2014.) */

theorem rgen2w (ph : wff, x : set, y : set, A : class, B : class)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ∀ y ∈ B ph ;;
}

proof of rgen2w {
	step 1 : wff = rgenw (hyp 1) |- ∀ y ∈ B ph ;;
	step 2 : wff = rgenw (step 1) |- ∀ x ∈ A ∀ y ∈ B ph ;;
	qed prop 1 = step 2 ;;
}

/*Modus ponens combined with restricted generalization.  (Contributed by
       NM, 10-Aug-2004.) */

theorem mprg (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ∀ x ∈ A ph → ps ) ;;
	hyp 2 : wff = |- ( x ∈ A → ph ) ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of mprg {
	step 1 : wff = rgen (hyp 2) |- ∀ x ∈ A ph ;;
	step 2 : wff = ax-mp (step 1, hyp 1) |- ps ;;
	qed prop 1 = step 2 ;;
}

/*Modus ponens on biconditional combined with restricted generalization.
       (Contributed by NM, 21-Mar-2004.) */

theorem mprgbir (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph ↔ ∀ x ∈ A ps ) ;;
	hyp 2 : wff = |- ( x ∈ A → ps ) ;;
	-----------------------
	prop 1 : wff = |- ph ;;
}

proof of mprgbir {
	step 1 : wff = rgen (hyp 2) |- ∀ x ∈ A ps ;;
	step 2 : wff = mpbir (step 1, hyp 1) |- ph ;;
	qed prop 1 = step 2 ;;
}

/*Distribution of restricted quantification over implication.  (Contributed
     by NM, 9-Feb-1997.) */

theorem ralim (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) → ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ) ;;
}

proof of ralim {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ( ph → ps ) ↔ ∀ x ( x ∈ A → ( ph → ps ) ) ) ;;
	step 2 : wff = ax-2 () |- ( ( x ∈ A → ( ph → ps ) ) → ( ( x ∈ A → ph ) → ( x ∈ A → ps ) ) ) ;;
	step 3 : wff = al2imi (step 2) |- ( ∀ x ( x ∈ A → ( ph → ps ) ) → ( ∀ x ( x ∈ A → ph ) → ∀ x ( x ∈ A → ps ) ) ) ;;
	step 4 : wff = sylbi (step 1, step 3) |- ( ∀ x ∈ A ( ph → ps ) → ( ∀ x ( x ∈ A → ph ) → ∀ x ( x ∈ A → ps ) ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 6 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 7 : wff = 3imtr4g (step 4, step 5, step 6) |- ( ∀ x ∈ A ( ph → ps ) → ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Inference quantifying both antecedent and consequent.  (Contributed by
       NM, 22-Feb-2004.) */

theorem ralimi2 (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- ( ( x ∈ A → ph ) → ( x ∈ B → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph → ∀ x ∈ B ps ) ;;
}

proof of ralimi2 {
	step 1 : wff = alimi (hyp 1) |- ( ∀ x ( x ∈ A → ph ) → ∀ x ( x ∈ B → ps ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ B ps ↔ ∀ x ( x ∈ B → ps ) ) ;;
	step 4 : wff = 3imtr4i (step 1, step 2, step 3) |- ( ∀ x ∈ A ph → ∀ x ∈ B ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference quantifying both antecedent and consequent.  (Contributed by
       NM, 19-Jul-1996.) */

theorem ralimia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ;;
}

proof of ralimia {
	step 1 : wff = a2i (hyp 1) |- ( ( x ∈ A → ph ) → ( x ∈ A → ps ) ) ;;
	step 2 : wff = ralimi2 (step 1) |- ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference quantifying both antecedent and consequent.  (Contributed by
       NM, 4-Aug-2007.) */

theorem ralimiaa (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ( x ∈ A ∧ ph ) → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ;;
}

proof of ralimiaa {
	step 1 : wff = ex (hyp 1) |- ( x ∈ A → ( ph → ps ) ) ;;
	step 2 : wff = ralimia (step 1) |- ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference quantifying both antecedent and consequent, with strong
       hypothesis.  (Contributed by NM, 4-Mar-1997.) */

theorem ralimi (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ;;
}

proof of ralimi {
	step 1 : wff = a1i (hyp 1) |- ( x ∈ A → ( ph → ps ) ) ;;
	step 2 : wff = ralimia (step 1) |- ( ∀ x ∈ A ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference quantifying antecedent, nested antecedent, and consequent,
       with a strong hypothesis.  (Contributed by NM, 19-Dec-2006.) */

theorem ral2imi (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
}

proof of ral2imi {
	step 1 : wff = ralimi (hyp 1) |- ( ∀ x ∈ A ph → ∀ x ∈ A ( ps → ch ) ) ;;
	step 2 : wff = ralim () |- ( ∀ x ∈ A ( ps → ch ) → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ∀ x ∈ A ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Deduction quantifying both antecedent and consequent, based on Theorem
       19.20 of [Margaris] p. 90.  (Contributed by NM, 22-Sep-2003.) */

theorem ralimdaa (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
}

proof of ralimdaa {
	step 1 : wff = ex (hyp 2) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = a2d (step 1) |- ( ph → ( ( x ∈ A → ps ) → ( x ∈ A → ch ) ) ) ;;
	step 3 : wff = alimd (hyp 1, step 2) |- ( ph → ( ∀ x ( x ∈ A → ps ) → ∀ x ( x ∈ A → ch ) ) ) ;;
	step 4 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ x ∈ A ch ↔ ∀ x ( x ∈ A → ch ) ) ;;
	step 6 : wff = 3imtr4g (step 3, step 4, step 5) |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Deduction quantifying both antecedent and consequent, based on Theorem
       19.20 of [Margaris] p. 90.  (Contributed by NM, 22-May-1999.) */

theorem ralimdva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
}

proof of ralimdva {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = ralimdaa (step 1, hyp 1) |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction quantifying both antecedent and consequent, based on Theorem
       19.20 of [Margaris] p. 90.  (Contributed by NM, 8-Oct-2003.) */

theorem ralimdv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
}

proof of ralimdv {
	step 1 : wff = adantr (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	step 2 : wff = ralimdva (step 1) |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference quantifying both antecedent and consequent.  (Contributed by
       NM, 1-Feb-2005.) */

theorem ralimdv2 (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ( x ∈ A → ps ) → ( x ∈ B → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ B ch ) ) ;;
}

proof of ralimdv2 {
	step 1 : wff = alimdv (hyp 1) |- ( ph → ( ∀ x ( x ∈ A → ps ) → ∀ x ( x ∈ B → ch ) ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ B ch ↔ ∀ x ( x ∈ B → ch ) ) ;;
	step 4 : wff = 3imtr4g (step 1, step 2, step 3) |- ( ph → ( ∀ x ∈ A ps → ∀ x ∈ B ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 10-Oct-1999.) */

theorem ralrimi (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( x ∈ A → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ps ) ;;
}

proof of ralrimi {
	step 1 : wff = alrimi (hyp 1, hyp 2) |- ( ph → ∀ x ( x ∈ A → ps ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 22-Nov-1994.) */

theorem ralrimiv (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( x ∈ A → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ps ) ;;
}

proof of ralrimiv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = ralrimi (step 1, hyp 1) |- ( ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 2-Jan-2006.) */

theorem ralrimiva (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ps ) ;;
}

proof of ralrimiva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( x ∈ A → ps ) ) ;;
	step 2 : wff = ralrimiv (step 1) |- ( ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 18-Jun-2014.) */

theorem ralrimivw (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ps ) ;;
}

proof of ralrimivw {
	step 1 : wff = a1d (hyp 1) |- ( ph → ( x ∈ A → ps ) ) ;;
	step 2 : wff = ralrimiv (step 1) |- ( ph → ∀ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Theorem 19.21 of [Margaris] p. 90 with restricted quantifiers (closed
       theorem version).  (Contributed by NM, 1-Mar-2008.) */

theorem r19.21t (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( F/ x ph → ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ) ;;
}

proof of r19.21t {
	step 1 : wff = bi2.04 () |- ( ( x ∈ A → ( ph → ps ) ) ↔ ( ph → ( x ∈ A → ps ) ) ) ;;
	step 2 : wff = albii (step 1) |- ( ∀ x ( x ∈ A → ( ph → ps ) ) ↔ ∀ x ( ph → ( x ∈ A → ps ) ) ) ;;
	step 3 : wff = 19.21t () |- ( F/ x ph → ( ∀ x ( ph → ( x ∈ A → ps ) ) ↔ ( ph → ∀ x ( x ∈ A → ps ) ) ) ) ;;
	step 4 : wff = syl5bb (step 2, step 3) |- ( F/ x ph → ( ∀ x ( x ∈ A → ( ph → ps ) ) ↔ ( ph → ∀ x ( x ∈ A → ps ) ) ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ x ∈ A ( ph → ps ) ↔ ∀ x ( x ∈ A → ( ph → ps ) ) ) ;;
	step 6 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 7 : wff = imbi2i (step 6) |- ( ( ph → ∀ x ∈ A ps ) ↔ ( ph → ∀ x ( x ∈ A → ps ) ) ) ;;
	step 8 : wff = 3bitr4g (step 4, step 5, step 7) |- ( F/ x ph → ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Theorem 19.21 of [Margaris] p. 90 with restricted quantifiers.
       (Contributed by Scott Fenton, 30-Mar-2011.) */

theorem r19.21 (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ;;
}

proof of r19.21 {
	step 1 : wff = r19.21t () |- ( F/ x ph → ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Theorem 19.21 of [Margaris] p. 90 with restricted quantifiers.
       (Contributed by NM, 15-Oct-2003.)  (Proof shortened by Andrew Salmon,
       30-May-2011.) */

theorem r19.21v (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ;;
}

proof of r19.21v {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = r19.21 (step 1) |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ph → ∀ x ∈ A ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 16-Feb-2004.) */

theorem ralrimd (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( ph → ( ps → ( x ∈ A → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ∀ x ∈ A ch ) ) ;;
}

proof of ralrimd {
	step 1 : wff = alrimd (hyp 1, hyp 2, hyp 3) |- ( ph → ( ps → ∀ x ( x ∈ A → ch ) ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ch ↔ ∀ x ( x ∈ A → ch ) ) ;;
	step 3 : wff = syl6ibr (step 1, step 2) |- ( ph → ( ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 27-May-1998.) */

theorem ralrimdv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ps) {
	hyp 1 : wff = |- ( ph → ( ps → ( x ∈ A → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ∀ x ∈ A ch ) ) ;;
}

proof of ralrimdv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = ralrimd (step 1, step 2, hyp 1) |- ( ph → ( ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 2-Feb-2008.) */

theorem ralrimdva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ps) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ∀ x ∈ A ch ) ) ;;
}

proof of ralrimdva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = com23 (step 1) |- ( ph → ( ps → ( x ∈ A → ch ) ) ) ;;
	step 3 : wff = ralrimdv (step 2) |- ( ph → ( ps → ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version with double quantification.)  (Contributed by NM,
       24-Jul-2004.) */

theorem ralrimivv (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, y A) {
	hyp 1 : wff = |- ( ph → ( ( x ∈ A ∧ y ∈ B ) → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ∀ y ∈ B ps ) ;;
}

proof of ralrimivv {
	step 1 : wff = exp3a (hyp 1) |- ( ph → ( x ∈ A → ( y ∈ B → ps ) ) ) ;;
	step 2 : wff = ralrimdv (step 1) |- ( ph → ( x ∈ A → ∀ y ∈ B ps ) ) ;;
	step 3 : wff = ralrimiv (step 2) |- ( ph → ∀ x ∈ A ∀ y ∈ B ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version with double quantification.)  (Contributed by Jeff
       Madsen, 19-Jun-2011.) */

theorem ralrimivva (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(ph x y, A y) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ∀ y ∈ B ps ) ;;
}

proof of ralrimivva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( ( x ∈ A ∧ y ∈ B ) → ps ) ) ;;
	step 2 : wff = ralrimivv (step 1) |- ( ph → ∀ x ∈ A ∀ y ∈ B ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version with triple quantification.)  (Contributed by Mario
       Carneiro, 9-Jul-2014.) */

theorem ralrimivvva (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(ph x y z, A y z, B z) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) ) → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ps ) ;;
}

proof of ralrimivvva {
	step 1 : wff = 3exp2 (hyp 1) |- ( ph → ( x ∈ A → ( y ∈ B → ( z ∈ C → ps ) ) ) ) ;;
	step 2 : wff = imp41 (step 1) |- ( ( ( ( ph ∧ x ∈ A ) ∧ y ∈ B ) ∧ z ∈ C ) → ps ) ;;
	step 3 : wff = ralrimiva (step 2) |- ( ( ( ph ∧ x ∈ A ) ∧ y ∈ B ) → ∀ z ∈ C ps ) ;;
	step 4 : wff = ralrimiva (step 3) |- ( ( ph ∧ x ∈ A ) → ∀ y ∈ B ∀ z ∈ C ps ) ;;
	step 5 : wff = ralrimiva (step 4) |- ( ph → ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version with double quantification.)  (Contributed by NM,
       1-Jun-2005.) */

theorem ralrimdvv (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, x y ps, y A) {
	hyp 1 : wff = |- ( ph → ( ps → ( ( x ∈ A ∧ y ∈ B ) → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
}

proof of ralrimdvv {
	step 1 : wff = imp (hyp 1) |- ( ( ph ∧ ps ) → ( ( x ∈ A ∧ y ∈ B ) → ch ) ) ;;
	step 2 : wff = ralrimivv (step 1) |- ( ( ph ∧ ps ) → ∀ x ∈ A ∀ y ∈ B ch ) ;;
	step 3 : wff = ex (step 2) |- ( ph → ( ps → ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version with double quantification.)  (Contributed by NM,
       2-Feb-2008.) */

theorem ralrimdvva (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, x y ps, y A) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
}

proof of ralrimdvva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( ( x ∈ A ∧ y ∈ B ) → ( ps → ch ) ) ) ;;
	step 2 : wff = com23 (step 1) |- ( ph → ( ps → ( ( x ∈ A ∧ y ∈ B ) → ch ) ) ) ;;
	step 3 : wff = ralrimdvv (step 2) |- ( ph → ( ps → ∀ x ∈ A ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Generalization rule for restricted quantification.  (Contributed by NM,
       30-May-1999.) */

theorem rgen2 (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y, y A) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ∀ y ∈ B ph ;;
}

proof of rgen2 {
	step 1 : wff = ralrimiva (hyp 1) |- ( x ∈ A → ∀ y ∈ B ph ) ;;
	step 2 : wff = rgen (step 1) |- ∀ x ∈ A ∀ y ∈ B ph ;;
	qed prop 1 = step 2 ;;
}

/*Generalization rule for restricted quantification.  (Contributed by NM,
       12-Jan-2008.) */

theorem rgen3 (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(y z A, z B, x y z) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ;;
}

proof of rgen3 {
	step 1 : wff = 3expa (hyp 1) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ z ∈ C ) → ph ) ;;
	step 2 : wff = ralrimiva (step 1) |- ( ( x ∈ A ∧ y ∈ B ) → ∀ z ∈ C ph ) ;;
	step 3 : wff = rgen2 (step 2) |- ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 20-Nov-1994.) */

theorem r19.21bi (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph → ∀ x ∈ A ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ x ∈ A ) → ps ) ;;
}

proof of r19.21bi {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → ∀ x ( x ∈ A → ps ) ) ;;
	step 3 : wff = 19.21bi (step 2) |- ( ph → ( x ∈ A → ps ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( ph ∧ x ∈ A ) → ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Specialization rule for restricted quantification.  (Contributed by NM,
       20-Nov-1994.) */

theorem rspec2 (ph : wff, x : set, y : set, A : class, B : class)  {
	hyp 1 : wff = |- ∀ x ∈ A ∀ y ∈ B ph ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → ph ) ;;
}

proof of rspec2 {
	step 1 : wff = rspec (hyp 1) |- ( x ∈ A → ∀ y ∈ B ph ) ;;
	step 2 : wff = r19.21bi (step 1) |- ( ( x ∈ A ∧ y ∈ B ) → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Specialization rule for restricted quantification.  (Contributed by NM,
       20-Nov-1994.) */

theorem rspec3 (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ;;
	-----------------------
	prop 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ;;
}

proof of rspec3 {
	step 1 : wff = rspec2 (hyp 1) |- ( ( x ∈ A ∧ y ∈ B ) → ∀ z ∈ C ph ) ;;
	step 2 : wff = r19.21bi (step 1) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ z ∈ C ) → ph ) ;;
	step 3 : wff = 3impa (step 2) |- ( ( x ∈ A ∧ y ∈ B ∧ z ∈ C ) → ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 21-Nov-1994.) */

theorem r19.21be (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph → ∀ x ∈ A ps ) ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∈ A ( ph → ps ) ;;
}

proof of r19.21be {
	step 1 : wff = r19.21bi (hyp 1) |- ( ( ph ∧ x ∈ A ) → ps ) ;;
	step 2 : wff = expcom (step 1) |- ( x ∈ A → ( ph → ps ) ) ;;
	step 3 : wff = rgen (step 2) |- ∀ x ∈ A ( ph → ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference adding restricted existential quantifier to negated wff.
       (Contributed by NM, 16-Oct-2003.) */

theorem nrex (ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ¬ ps ) ;;
	-----------------------
	prop 1 : wff = |- ¬ ∃ x ∈ A ps ;;
}

proof of nrex {
	step 1 : wff = rgen (hyp 1) |- ∀ x ∈ A ¬ ps ;;
	step 2 : wff = ralnex () |- ( ∀ x ∈ A ¬ ps ↔ ¬ ∃ x ∈ A ps ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- ¬ ∃ x ∈ A ps ;;
	qed prop 1 = step 3 ;;
}

/*Deduction adding restricted existential quantifier to negated wff.
       (Contributed by NM, 16-Oct-2003.) */

theorem nrexdv (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ¬ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ∃ x ∈ A ps ) ;;
}

proof of nrexdv {
	step 1 : wff = ralrimiva (hyp 1) |- ( ph → ∀ x ∈ A ¬ ps ) ;;
	step 2 : wff = ralnex () |- ( ∀ x ∈ A ¬ ps ↔ ¬ ∃ x ∈ A ps ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ph → ¬ ∃ x ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Theorem 19.22 of [Margaris] p. 90.  (Restricted quantifier version.)
     (Contributed by NM, 22-Nov-1994.)  (Proof shortened by Andrew Salmon,
     30-May-2011.) */

theorem rexim (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) → ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
}

proof of rexim {
	step 1 : wff = con3 () |- ( ( ph → ps ) → ( ¬ ps → ¬ ph ) ) ;;
	step 2 : wff = ral2imi (step 1) |- ( ∀ x ∈ A ( ph → ps ) → ( ∀ x ∈ A ¬ ps → ∀ x ∈ A ¬ ph ) ) ;;
	step 3 : wff = con3d (step 2) |- ( ∀ x ∈ A ( ph → ps ) → ( ¬ ∀ x ∈ A ¬ ph → ¬ ∀ x ∈ A ¬ ps ) ) ;;
	step 4 : wff = dfrex2 () |- ( ∃ x ∈ A ph ↔ ¬ ∀ x ∈ A ¬ ph ) ;;
	step 5 : wff = dfrex2 () |- ( ∃ x ∈ A ps ↔ ¬ ∀ x ∈ A ¬ ps ) ;;
	step 6 : wff = 3imtr4g (step 3, step 4, step 5) |- ( ∀ x ∈ A ( ph → ps ) → ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Inference quantifying both antecedent and consequent.  (Contributed by
       NM, 10-Feb-1997.) */

theorem reximia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ;;
}

proof of reximia {
	step 1 : wff = rexim () |- ( ∀ x ∈ A ( ph → ps ) → ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	step 2 : wff = mprg (step 1, hyp 1) |- ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference quantifying both antecedent and consequent, based on Theorem
       19.22 of [Margaris] p. 90.  (Contributed by NM, 8-Nov-2004.) */

theorem reximi2 (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- ( ( x ∈ A ∧ ph ) → ( x ∈ B ∧ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ∃ x ∈ B ps ) ;;
}

proof of reximi2 {
	step 1 : wff = eximi (hyp 1) |- ( ∃ x ( x ∈ A ∧ ph ) → ∃ x ( x ∈ B ∧ ps ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ B ps ↔ ∃ x ( x ∈ B ∧ ps ) ) ;;
	step 4 : wff = 3imtr4i (step 1, step 2, step 3) |- ( ∃ x ∈ A ph → ∃ x ∈ B ps ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference quantifying both antecedent and consequent.  (Contributed by
       NM, 18-Oct-1996.) */

theorem reximi (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ;;
}

proof of reximi {
	step 1 : wff = a1i (hyp 1) |- ( x ∈ A → ( ph → ps ) ) ;;
	step 2 : wff = reximia (step 1) |- ( ∃ x ∈ A ph → ∃ x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from Theorem 19.22 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 31-Aug-1999.) */

theorem reximdai (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
}

proof of reximdai {
	step 1 : wff = ralrimi (hyp 1, hyp 2) |- ( ph → ∀ x ∈ A ( ps → ch ) ) ;;
	step 2 : wff = rexim () |- ( ∀ x ∈ A ( ps → ch ) → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Deduction quantifying both antecedent and consequent, based on Theorem
       19.22 of [Margaris] p. 90.  (Contributed by NM, 17-Sep-2003.) */

theorem reximdv2 (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ( x ∈ A ∧ ps ) → ( x ∈ B ∧ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ B ch ) ) ;;
}

proof of reximdv2 {
	step 1 : wff = eximdv (hyp 1) |- ( ph → ( ∃ x ( x ∈ A ∧ ps ) → ∃ x ( x ∈ B ∧ ch ) ) ) ;;
	step 2 : wff = df-rex () |- ( ∃ x ∈ A ps ↔ ∃ x ( x ∈ A ∧ ps ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ B ch ↔ ∃ x ( x ∈ B ∧ ch ) ) ;;
	step 4 : wff = 3imtr4g (step 1, step 2, step 3) |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ B ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Deduction quantifying both antecedent and consequent, based on Theorem
       19.22 of [Margaris] p. 90.  (Contributed by NM, 14-Nov-2002.) */

theorem reximdvai (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
}

proof of reximdvai {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = reximdai (step 1, hyp 1) |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from Theorem 19.22 of [Margaris] p. 90.  (Restricted
       quantifier version with strong hypothesis.)  (Contributed by NM,
       24-Jun-1998.) */

theorem reximdv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
}

proof of reximdv {
	step 1 : wff = a1d (hyp 1) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = reximdvai (step 1) |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction quantifying both antecedent and consequent, based on Theorem
       19.22 of [Margaris] p. 90.  (Contributed by NM, 22-May-1999.) */

theorem reximdva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
}

proof of reximdva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = reximdvai (step 1) |- ( ph → ( ∃ x ∈ A ps → ∃ x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Theorem 19.12 of [Margaris] p. 89 with restricted quantifiers.
       (Contributed by NM, 15-Oct-2003.)  (Proof shortened by Andrew Salmon,
       30-May-2011.) */

theorem r19.12 (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y, y A, x B) {
	prop 1 : wff = |- ( ∃ x ∈ A ∀ y ∈ B ph → ∀ y ∈ B ∃ x ∈ A ph ) ;;
}

proof of r19.12 {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = nfra1 () |- F/ y ∀ y ∈ B ph ;;
	step 3 : wff = nfrex (step 1, step 2) |- F/ y ∃ x ∈ A ∀ y ∈ B ph ;;
	step 4 : wff = ax-1 () |- ( ∃ x ∈ A ∀ y ∈ B ph → ( y ∈ B → ∃ x ∈ A ∀ y ∈ B ph ) ) ;;
	step 5 : wff = ralrimi (step 3, step 4) |- ( ∃ x ∈ A ∀ y ∈ B ph → ∀ y ∈ B ∃ x ∈ A ∀ y ∈ B ph ) ;;
	step 6 : wff = rsp () |- ( ∀ y ∈ B ph → ( y ∈ B → ph ) ) ;;
	step 7 : wff = com12 (step 6) |- ( y ∈ B → ( ∀ y ∈ B ph → ph ) ) ;;
	step 8 : wff = reximdv (step 7) |- ( y ∈ B → ( ∃ x ∈ A ∀ y ∈ B ph → ∃ x ∈ A ph ) ) ;;
	step 9 : wff = ralimia (step 8) |- ( ∀ y ∈ B ∃ x ∈ A ∀ y ∈ B ph → ∀ y ∈ B ∃ x ∈ A ph ) ;;
	step 10 : wff = syl (step 5, step 9) |- ( ∃ x ∈ A ∀ y ∈ B ph → ∀ y ∈ B ∃ x ∈ A ph ) ;;
	qed prop 1 = step 10 ;;
}

/*Closed theorem form of ~ r19.23 .  (Contributed by NM, 4-Mar-2013.)
     (Revised by Mario Carneiro, 8-Oct-2016.) */

theorem r19.23t (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( F/ x ps → ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ) ;;
}

proof of r19.23t {
	step 1 : wff = 19.23t () |- ( F/ x ps → ( ∀ x ( ( x ∈ A ∧ ph ) → ps ) ↔ ( ∃ x ( x ∈ A ∧ ph ) → ps ) ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ( ph → ps ) ↔ ∀ x ( x ∈ A → ( ph → ps ) ) ) ;;
	step 3 : wff = impexp () |- ( ( ( x ∈ A ∧ ph ) → ps ) ↔ ( x ∈ A → ( ph → ps ) ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x ( ( x ∈ A ∧ ph ) → ps ) ↔ ∀ x ( x ∈ A → ( ph → ps ) ) ) ;;
	step 5 : wff = bitr4i (step 2, step 4) |- ( ∀ x ∈ A ( ph → ps ) ↔ ∀ x ( ( x ∈ A ∧ ph ) → ps ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 7 : wff = imbi1i (step 6) |- ( ( ∃ x ∈ A ph → ps ) ↔ ( ∃ x ( x ∈ A ∧ ph ) → ps ) ) ;;
	step 8 : wff = 3bitr4g (step 1, step 5, step 7) |- ( F/ x ps → ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Theorem 19.23 of [Margaris] p. 90 with restricted quantifiers.
       (Contributed by NM, 22-Oct-2010.)  (Proof shortened by Mario Carneiro,
       8-Oct-2016.) */

theorem r19.23 (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ps ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ;;
}

proof of r19.23 {
	step 1 : wff = r19.23t () |- ( F/ x ps → ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Theorem 19.23 of [Margaris] p. 90 with restricted quantifiers.
       (Contributed by NM, 31-Aug-1999.) */

theorem r19.23v (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ;;
}

proof of r19.23v {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = r19.23 (step 1) |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.21 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 30-Nov-2003.)  (Proof
       shortened by Andrew Salmon, 30-May-2011.) */

theorem rexlimi (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x ∈ A → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ps ) ;;
}

proof of rexlimi {
	step 1 : wff = rgen (hyp 2) |- ∀ x ∈ A ( ph → ps ) ;;
	step 2 : wff = r19.23 (hyp 1) |- ( ∀ x ∈ A ( ph → ps ) ↔ ( ∃ x ∈ A ph → ps ) ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- ( ∃ x ∈ A ph → ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 20-Nov-1994.) */

theorem rexlimiv (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	hyp 1 : wff = |- ( x ∈ A → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ps ) ;;
}

proof of rexlimiv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = rexlimi (step 1, hyp 1) |- ( ∃ x ∈ A ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 18-Dec-2006.) */

theorem rexlimiva (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ ph ) → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ps ) ;;
}

proof of rexlimiva {
	step 1 : wff = ex (hyp 1) |- ( x ∈ A → ( ph → ps ) ) ;;
	step 2 : wff = rexlimiv (step 1) |- ( ∃ x ∈ A ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Weaker version of ~ rexlimiv .  (Contributed by FL, 19-Sep-2011.) */

theorem rexlimivw (ph : wff, ps : wff, x : set, A : class) disjointed(ps x) {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph → ps ) ;;
}

proof of rexlimivw {
	step 1 : wff = a1i (hyp 1) |- ( x ∈ A → ( ph → ps ) ) ;;
	step 2 : wff = rexlimiv (step 1) |- ( ∃ x ∈ A ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 27-May-1998.)  (Proof shortened by Andrew
       Salmon, 30-May-2011.) */

theorem rexlimd (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ x ch ;;
	hyp 3 : wff = |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimd {
	step 1 : wff = ralrimi (hyp 1, hyp 3) |- ( ph → ∀ x ∈ A ( ps → ch ) ) ;;
	step 2 : wff = r19.23 (hyp 2) |- ( ∀ x ∈ A ( ps → ch ) ↔ ( ∃ x ∈ A ps → ch ) ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Version of ~ rexlimd with deduction version of second hypothesis.
       (Contributed by NM, 21-Jul-2013.)  (Revised by Mario Carneiro,
       8-Oct-2016.) */

theorem rexlimd2 (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → F/ x ch ) ;;
	hyp 3 : wff = |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimd2 {
	step 1 : wff = ralrimi (hyp 1, hyp 3) |- ( ph → ∀ x ∈ A ( ps → ch ) ) ;;
	step 2 : wff = r19.23t () |- ( F/ x ch → ( ∀ x ∈ A ( ps → ch ) ↔ ( ∃ x ∈ A ps → ch ) ) ) ;;
	step 3 : wff = syl (hyp 2, step 2) |- ( ph → ( ∀ x ∈ A ( ps → ch ) ↔ ( ∃ x ∈ A ps → ch ) ) ) ;;
	step 4 : wff = mpbid (step 1, step 3) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 14-Nov-2002.)  (Proof shortened by Eric
       Schmidt, 22-Dec-2006.) */

theorem rexlimdv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimdv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfv () |- F/ x ch ;;
	step 3 : wff = rexlimd (step 1, step 2, hyp 1) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 20-Jan-2007.) */

theorem rexlimdva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimdva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = rexlimdv (step 1) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by Mario Carneiro, 15-Jun-2016.) */

theorem rexlimdvaa (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ ps ) ) → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimdvaa {
	step 1 : wff = expr (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( ps → ch ) ) ;;
	step 2 : wff = rexlimdva (step 1) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  Frequently-used variant of ~ rexlimdv .  (Contributed by NM,
       7-Jun-2015.) */

theorem rexlimdv3a (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ∧ ps ) → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimdv3a {
	step 1 : wff = 3exp (hyp 1) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = rexlimdv (step 1) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 18-Jun-2014.) */

theorem rexlimdvw (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
}

proof of rexlimdvw {
	step 1 : wff = a1d (hyp 1) |- ( ph → ( x ∈ A → ( ps → ch ) ) ) ;;
	step 2 : wff = rexlimdv (step 1) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Restricted existential elimination rule of natural deduction.
       (Contributed by Mario Carneiro, 15-Jun-2016.) */

theorem rexlimddv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ph → ∃ x ∈ A ps ) ;;
	hyp 2 : wff = |- ( ( ph ∧ ( x ∈ A ∧ ps ) ) → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of rexlimddv {
	step 1 : wff = rexlimdvaa (hyp 2) |- ( ph → ( ∃ x ∈ A ps → ch ) ) ;;
	step 2 : wff = mpd (hyp 1, step 1) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90 (restricted quantifier
       version).  (Contributed by NM, 17-Feb-2004.) */

theorem rexlimivv (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y ps, y A) {
	hyp 1 : wff = |- ( ( x ∈ A ∧ y ∈ B ) → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph → ps ) ;;
}

proof of rexlimivv {
	step 1 : wff = rexlimdva (hyp 1) |- ( x ∈ A → ( ∃ y ∈ B ph → ps ) ) ;;
	step 2 : wff = rexlimiv (step 1) |- ( ∃ x ∈ A ∃ y ∈ B ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 22-Jul-2004.) */

theorem rexlimdvv (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, x y ch, y A) {
	hyp 1 : wff = |- ( ph → ( ( x ∈ A ∧ y ∈ B ) → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps → ch ) ) ;;
}

proof of rexlimdvv {
	step 1 : wff = expdimp (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( y ∈ B → ( ps → ch ) ) ) ;;
	step 2 : wff = rexlimdv (step 1) |- ( ( ph ∧ x ∈ A ) → ( ∃ y ∈ B ps → ch ) ) ;;
	step 3 : wff = rexlimdva (step 2) |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps → ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from Theorem 19.23 of [Margaris] p. 90.  (Restricted
       quantifier version.)  (Contributed by NM, 18-Jun-2014.) */

theorem rexlimdvva (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y ph, x y ch, y A) {
	hyp 1 : wff = |- ( ( ph ∧ ( x ∈ A ∧ y ∈ B ) ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps → ch ) ) ;;
}

proof of rexlimdvva {
	step 1 : wff = ex (hyp 1) |- ( ph → ( ( x ∈ A ∧ y ∈ B ) → ( ps → ch ) ) ) ;;
	step 2 : wff = rexlimdvv (step 1) |- ( ph → ( ∃ x ∈ A ∃ y ∈ B ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Theorem 19.26 of [Margaris] p. 90 with restricted quantifiers.
     (Contributed by NM, 28-Jan-1997.)  (Proof shortened by Andrew Salmon,
     30-May-2011.) */

theorem r19.26 (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph ∧ ps ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ) ;;
}

proof of r19.26 {
	step 1 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ x ∈ A ( ph ∧ ps ) → ∀ x ∈ A ph ) ;;
	step 3 : wff = simpr () |- ( ( ph ∧ ps ) → ps ) ;;
	step 4 : wff = ralimi (step 3) |- ( ∀ x ∈ A ( ph ∧ ps ) → ∀ x ∈ A ps ) ;;
	step 5 : wff = jca (step 2, step 4) |- ( ∀ x ∈ A ( ph ∧ ps ) → ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ) ;;
	step 6 : wff = pm3.2 () |- ( ph → ( ps → ( ph ∧ ps ) ) ) ;;
	step 7 : wff = ral2imi (step 6) |- ( ∀ x ∈ A ph → ( ∀ x ∈ A ps → ∀ x ∈ A ( ph ∧ ps ) ) ) ;;
	step 8 : wff = imp (step 7) |- ( ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) → ∀ x ∈ A ( ph ∧ ps ) ) ;;
	step 9 : wff = impbii (step 5, step 8) |- ( ∀ x ∈ A ( ph ∧ ps ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Theorem 19.26 of [Margaris] p. 90 with 2 restricted quantifiers.
     (Contributed by NM, 10-Aug-2004.) */

theorem r19.26-2 (ph : wff, ps : wff, x : set, y : set, A : class, B : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ( ph ∧ ps ) ↔ ( ∀ x ∈ A ∀ y ∈ B ph ∧ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
}

proof of r19.26-2 {
	step 1 : wff = r19.26 () |- ( ∀ y ∈ B ( ph ∧ ps ) ↔ ( ∀ y ∈ B ph ∧ ∀ y ∈ B ps ) ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ∀ y ∈ B ( ph ∧ ps ) ↔ ∀ x ∈ A ( ∀ y ∈ B ph ∧ ∀ y ∈ B ps ) ) ;;
	step 3 : wff = r19.26 () |- ( ∀ x ∈ A ( ∀ y ∈ B ph ∧ ∀ y ∈ B ps ) ↔ ( ∀ x ∈ A ∀ y ∈ B ph ∧ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∀ x ∈ A ∀ y ∈ B ( ph ∧ ps ) ↔ ( ∀ x ∈ A ∀ y ∈ B ph ∧ ∀ x ∈ A ∀ y ∈ B ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Theorem 19.26 of [Margaris] p. 90 with 3 restricted quantifiers.
     (Contributed by FL, 22-Nov-2010.) */

theorem r19.26-3 (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph ∧ ps ∧ ch ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ∧ ∀ x ∈ A ch ) ) ;;
}

proof of r19.26-3 {
	step 1 : wff = df-3an () |- ( ( ph ∧ ps ∧ ch ) ↔ ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ( ph ∧ ps ∧ ch ) ↔ ∀ x ∈ A ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 3 : wff = r19.26 () |- ( ∀ x ∈ A ( ( ph ∧ ps ) ∧ ch ) ↔ ( ∀ x ∈ A ( ph ∧ ps ) ∧ ∀ x ∈ A ch ) ) ;;
	step 4 : wff = r19.26 () |- ( ∀ x ∈ A ( ph ∧ ps ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( ∀ x ∈ A ( ph ∧ ps ) ∧ ∀ x ∈ A ch ) ↔ ( ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ∧ ∀ x ∈ A ch ) ) ;;
	step 6 : wff = df-3an () |- ( ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ∧ ∀ x ∈ A ch ) ↔ ( ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ∧ ∀ x ∈ A ch ) ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ( ∀ x ∈ A ( ph ∧ ps ) ∧ ∀ x ∈ A ch ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ∧ ∀ x ∈ A ch ) ) ;;
	step 8 : wff = 3bitri (step 2, step 3, step 7) |- ( ∀ x ∈ A ( ph ∧ ps ∧ ch ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ∧ ∀ x ∈ A ch ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Theorem 19.26 of [Margaris] p. 90 with mixed quantifiers.  (Contributed by
     NM, 22-Feb-2004.) */

theorem r19.26m (ph : wff, ps : wff, x : set, A : class, B : class)  {
	prop 1 : wff = |- ( ∀ x ( ( x ∈ A → ph ) ∧ ( x ∈ B → ps ) ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ B ps ) ) ;;
}

proof of r19.26m {
	step 1 : wff = 19.26 () |- ( ∀ x ( ( x ∈ A → ph ) ∧ ( x ∈ B → ps ) ) ↔ ( ∀ x ( x ∈ A → ph ) ∧ ∀ x ( x ∈ B → ps ) ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ B ps ↔ ∀ x ( x ∈ B → ps ) ) ;;
	step 4 : wff = anbi12i (step 2, step 3) |- ( ( ∀ x ∈ A ph ∧ ∀ x ∈ B ps ) ↔ ( ∀ x ( x ∈ A → ph ) ∧ ∀ x ( x ∈ B → ps ) ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( ∀ x ( ( x ∈ A → ph ) ∧ ( x ∈ B → ps ) ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ B ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Distribute a restricted universal quantifier over a biconditional.
     Theorem 19.15 of [Margaris] p. 90 with restricted quantification.
     (Contributed by NM, 6-Oct-2003.) */

theorem ralbi (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph ↔ ps ) → ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ) ;;
}

proof of ralbi {
	step 1 : wff = nfra1 () |- F/ x ∀ x ∈ A ( ph ↔ ps ) ;;
	step 2 : wff = rsp () |- ( ∀ x ∈ A ( ph ↔ ps ) → ( x ∈ A → ( ph ↔ ps ) ) ) ;;
	step 3 : wff = imp (step 2) |- ( ( ∀ x ∈ A ( ph ↔ ps ) ∧ x ∈ A ) → ( ph ↔ ps ) ) ;;
	step 4 : wff = ralbida (step 1, step 3) |- ( ∀ x ∈ A ( ph ↔ ps ) → ( ∀ x ∈ A ph ↔ ∀ x ∈ A ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Split a biconditional and distribute quantifier.  (Contributed by NM,
     3-Jun-2012.) */

theorem ralbiim (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph ↔ ps ) ↔ ( ∀ x ∈ A ( ph → ps ) ∧ ∀ x ∈ A ( ps → ph ) ) ) ;;
}

proof of ralbiim {
	step 1 : wff = dfbi2 () |- ( ( ph ↔ ps ) ↔ ( ( ph → ps ) ∧ ( ps → ph ) ) ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ( ph ↔ ps ) ↔ ∀ x ∈ A ( ( ph → ps ) ∧ ( ps → ph ) ) ) ;;
	step 3 : wff = r19.26 () |- ( ∀ x ∈ A ( ( ph → ps ) ∧ ( ps → ph ) ) ↔ ( ∀ x ∈ A ( ph → ps ) ∧ ∀ x ∈ A ( ps → ph ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∀ x ∈ A ( ph ↔ ps ) ↔ ( ∀ x ∈ A ( ph → ps ) ∧ ∀ x ∈ A ( ps → ph ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Restricted version of one direction of Theorem 19.27 of [Margaris]
       p. 90.  (The other direction doesn't hold when ` A ` is empty.)
       (Contributed by NM, 3-Jun-2004.)  (Proof shortened by Andrew Salmon,
       30-May-2011.) */

theorem r19.27av (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	prop 1 : wff = |- ( ( ∀ x ∈ A ph ∧ ps ) → ∀ x ∈ A ( ph ∧ ps ) ) ;;
}

proof of r19.27av {
	step 1 : wff = ax-1 () |- ( ps → ( x ∈ A → ps ) ) ;;
	step 2 : wff = ralrimiv (step 1) |- ( ps → ∀ x ∈ A ps ) ;;
	step 3 : wff = anim2i (step 2) |- ( ( ∀ x ∈ A ph ∧ ps ) → ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ) ;;
	step 4 : wff = r19.26 () |- ( ∀ x ∈ A ( ph ∧ ps ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ps ) ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ( ∀ x ∈ A ph ∧ ps ) → ∀ x ∈ A ( ph ∧ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted version of one direction of Theorem 19.28 of [Margaris]
       p. 90.  (The other direction doesn't hold when ` A ` is empty.)
       (Contributed by NM, 2-Apr-2004.) */

theorem r19.28av (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	prop 1 : wff = |- ( ( ph ∧ ∀ x ∈ A ps ) → ∀ x ∈ A ( ph ∧ ps ) ) ;;
}

proof of r19.28av {
	step 1 : wff = r19.27av () |- ( ( ∀ x ∈ A ps ∧ ph ) → ∀ x ∈ A ( ps ∧ ph ) ) ;;
	step 2 : wff = ancom () |- ( ( ph ∧ ∀ x ∈ A ps ) ↔ ( ∀ x ∈ A ps ∧ ph ) ) ;;
	step 3 : wff = ancom () |- ( ( ph ∧ ps ) ↔ ( ps ∧ ph ) ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ x ∈ A ( ph ∧ ps ) ↔ ∀ x ∈ A ( ps ∧ ph ) ) ;;
	step 5 : wff = 3imtr4i (step 1, step 2, step 4) |- ( ( ph ∧ ∀ x ∈ A ps ) → ∀ x ∈ A ( ph ∧ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Theorem 19.29 of [Margaris] p. 90 with restricted quantifiers.
     (Contributed by NM, 31-Aug-1999.)  (Proof shortened by Andrew Salmon,
     30-May-2011.) */

theorem r19.29 (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ( ∀ x ∈ A ph ∧ ∃ x ∈ A ps ) → ∃ x ∈ A ( ph ∧ ps ) ) ;;
}

proof of r19.29 {
	step 1 : wff = pm3.2 () |- ( ph → ( ps → ( ph ∧ ps ) ) ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ x ∈ A ph → ∀ x ∈ A ( ps → ( ph ∧ ps ) ) ) ;;
	step 3 : wff = rexim () |- ( ∀ x ∈ A ( ps → ( ph ∧ ps ) ) → ( ∃ x ∈ A ps → ∃ x ∈ A ( ph ∧ ps ) ) ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ∀ x ∈ A ph → ( ∃ x ∈ A ps → ∃ x ∈ A ( ph ∧ ps ) ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( ∀ x ∈ A ph ∧ ∃ x ∈ A ps ) → ∃ x ∈ A ( ph ∧ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Variation of Theorem 19.29 of [Margaris] p. 90 with restricted
     quantifiers.  (Contributed by NM, 31-Aug-1999.) */

theorem r19.29r (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ( ∃ x ∈ A ph ∧ ∀ x ∈ A ps ) → ∃ x ∈ A ( ph ∧ ps ) ) ;;
}

proof of r19.29r {
	step 1 : wff = r19.29 () |- ( ( ∀ x ∈ A ps ∧ ∃ x ∈ A ph ) → ∃ x ∈ A ( ps ∧ ph ) ) ;;
	step 2 : wff = ancom () |- ( ( ∃ x ∈ A ph ∧ ∀ x ∈ A ps ) ↔ ( ∀ x ∈ A ps ∧ ∃ x ∈ A ph ) ) ;;
	step 3 : wff = ancom () |- ( ( ph ∧ ps ) ↔ ( ps ∧ ph ) ) ;;
	step 4 : wff = rexbii (step 3) |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ∃ x ∈ A ( ps ∧ ph ) ) ;;
	step 5 : wff = 3imtr4i (step 1, step 2, step 4) |- ( ( ∃ x ∈ A ph ∧ ∀ x ∈ A ps ) → ∃ x ∈ A ( ph ∧ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Theorem 19.30 of [Margaris] p. 90 with restricted quantifiers.
     (Contributed by Scott Fenton, 25-Feb-2011.) */

theorem r19.30 (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph ∨ ps ) → ( ∀ x ∈ A ph ∨ ∃ x ∈ A ps ) ) ;;
}

proof of r19.30 {
	step 1 : wff = ralim () |- ( ∀ x ∈ A ( ¬ ps → ph ) → ( ∀ x ∈ A ¬ ps → ∀ x ∈ A ph ) ) ;;
	step 2 : wff = orcom () |- ( ( ph ∨ ps ) ↔ ( ps ∨ ph ) ) ;;
	step 3 : wff = df-or () |- ( ( ps ∨ ph ) ↔ ( ¬ ps → ph ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ( ph ∨ ps ) ↔ ( ¬ ps → ph ) ) ;;
	step 5 : wff = ralbii (step 4) |- ( ∀ x ∈ A ( ph ∨ ps ) ↔ ∀ x ∈ A ( ¬ ps → ph ) ) ;;
	step 6 : wff = orcom () |- ( ( ∀ x ∈ A ph ∨ ¬ ∀ x ∈ A ¬ ps ) ↔ ( ¬ ∀ x ∈ A ¬ ps ∨ ∀ x ∈ A ph ) ) ;;
	step 7 : wff = dfrex2 () |- ( ∃ x ∈ A ps ↔ ¬ ∀ x ∈ A ¬ ps ) ;;
	step 8 : wff = orbi2i (step 7) |- ( ( ∀ x ∈ A ph ∨ ∃ x ∈ A ps ) ↔ ( ∀ x ∈ A ph ∨ ¬ ∀ x ∈ A ¬ ps ) ) ;;
	step 9 : wff = imor () |- ( ( ∀ x ∈ A ¬ ps → ∀ x ∈ A ph ) ↔ ( ¬ ∀ x ∈ A ¬ ps ∨ ∀ x ∈ A ph ) ) ;;
	step 10 : wff = 3bitr4i (step 6, step 8, step 9) |- ( ( ∀ x ∈ A ph ∨ ∃ x ∈ A ps ) ↔ ( ∀ x ∈ A ¬ ps → ∀ x ∈ A ph ) ) ;;
	step 11 : wff = 3imtr4i (step 1, step 5, step 10) |- ( ∀ x ∈ A ( ph ∨ ps ) → ( ∀ x ∈ A ph ∨ ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Theorem 19.32 of [Margaris] p. 90 with restricted quantifiers.
       (Contributed by NM, 25-Nov-2003.) */

theorem r19.32v (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph ∨ ps ) ↔ ( ph ∨ ∀ x ∈ A ps ) ) ;;
}

proof of r19.32v {
	step 1 : wff = r19.21v () |- ( ∀ x ∈ A ( ¬ ph → ps ) ↔ ( ¬ ph → ∀ x ∈ A ps ) ) ;;
	step 2 : wff = df-or () |- ( ( ph ∨ ps ) ↔ ( ¬ ph → ps ) ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ x ∈ A ( ph ∨ ps ) ↔ ∀ x ∈ A ( ¬ ph → ps ) ) ;;
	step 4 : wff = df-or () |- ( ( ph ∨ ∀ x ∈ A ps ) ↔ ( ¬ ph → ∀ x ∈ A ps ) ) ;;
	step 5 : wff = 3bitr4i (step 1, step 3, step 4) |- ( ∀ x ∈ A ( ph ∨ ps ) ↔ ( ph ∨ ∀ x ∈ A ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted quantifier version of Theorem 19.35 of [Margaris] p. 90.
     (Contributed by NM, 20-Sep-2003.) */

theorem r19.35 (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph → ps ) ↔ ( ∀ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
}

proof of r19.35 {
	step 1 : wff = r19.26 () |- ( ∀ x ∈ A ( ph ∧ ¬ ps ) ↔ ( ∀ x ∈ A ph ∧ ∀ x ∈ A ¬ ps ) ) ;;
	step 2 : wff = annim () |- ( ( ph ∧ ¬ ps ) ↔ ¬ ( ph → ps ) ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ x ∈ A ( ph ∧ ¬ ps ) ↔ ∀ x ∈ A ¬ ( ph → ps ) ) ;;
	step 4 : wff = df-an () |- ( ( ∀ x ∈ A ph ∧ ∀ x ∈ A ¬ ps ) ↔ ¬ ( ∀ x ∈ A ph → ¬ ∀ x ∈ A ¬ ps ) ) ;;
	step 5 : wff = 3bitr3i (step 1, step 3, step 4) |- ( ∀ x ∈ A ¬ ( ph → ps ) ↔ ¬ ( ∀ x ∈ A ph → ¬ ∀ x ∈ A ¬ ps ) ) ;;
	step 6 : wff = con2bii (step 5) |- ( ( ∀ x ∈ A ph → ¬ ∀ x ∈ A ¬ ps ) ↔ ¬ ∀ x ∈ A ¬ ( ph → ps ) ) ;;
	step 7 : wff = dfrex2 () |- ( ∃ x ∈ A ps ↔ ¬ ∀ x ∈ A ¬ ps ) ;;
	step 8 : wff = imbi2i (step 7) |- ( ( ∀ x ∈ A ph → ∃ x ∈ A ps ) ↔ ( ∀ x ∈ A ph → ¬ ∀ x ∈ A ¬ ps ) ) ;;
	step 9 : wff = dfrex2 () |- ( ∃ x ∈ A ( ph → ps ) ↔ ¬ ∀ x ∈ A ¬ ( ph → ps ) ) ;;
	step 10 : wff = 3bitr4ri (step 6, step 8, step 9) |- ( ∃ x ∈ A ( ph → ps ) ↔ ( ∀ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 10 ;;
}

/*One direction of a restricted quantifier version of Theorem 19.36 of
       [Margaris] p. 90.  The other direction doesn't hold when ` A ` is
       empty.  (Contributed by NM, 22-Oct-2003.) */

theorem r19.36av (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph → ps ) → ( ∀ x ∈ A ph → ps ) ) ;;
}

proof of r19.36av {
	step 1 : wff = r19.35 () |- ( ∃ x ∈ A ( ph → ps ) ↔ ( ∀ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	step 2 : wff = idd () |- ( x ∈ A → ( ps → ps ) ) ;;
	step 3 : wff = rexlimiv (step 2) |- ( ∃ x ∈ A ps → ps ) ;;
	step 4 : wff = imim2i (step 3) |- ( ( ∀ x ∈ A ph → ∃ x ∈ A ps ) → ( ∀ x ∈ A ph → ps ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( ∃ x ∈ A ( ph → ps ) → ( ∀ x ∈ A ph → ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted version of one direction of Theorem 19.37 of [Margaris]
       p. 90.  (The other direction doesn't hold when ` A ` is empty.)
       (Contributed by FL, 13-May-2012.)  (Revised by Mario Carneiro,
       11-Dec-2016.) */

theorem r19.37 (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ( ph → ps ) → ( ph → ∃ x ∈ A ps ) ) ;;
}

proof of r19.37 {
	step 1 : wff = r19.35 () |- ( ∃ x ∈ A ( ph → ps ) ↔ ( ∀ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	step 2 : wff = ax-1 () |- ( ph → ( x ∈ A → ph ) ) ;;
	step 3 : wff = ralrimi (hyp 1, step 2) |- ( ph → ∀ x ∈ A ph ) ;;
	step 4 : wff = imim1i (step 3) |- ( ( ∀ x ∈ A ph → ∃ x ∈ A ps ) → ( ph → ∃ x ∈ A ps ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( ∃ x ∈ A ( ph → ps ) → ( ph → ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted version of one direction of Theorem 19.37 of [Margaris]
       p. 90.  (The other direction doesn't hold when ` A ` is empty.)
       (Contributed by NM, 2-Apr-2004.) */

theorem r19.37av (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph → ps ) → ( ph → ∃ x ∈ A ps ) ) ;;
}

proof of r19.37av {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = r19.37 (step 1) |- ( ∃ x ∈ A ( ph → ps ) → ( ph → ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Restricted quantifier version of Theorem 19.40 of [Margaris] p. 90.
     (Contributed by NM, 2-Apr-2004.) */

theorem r19.40 (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∧ ps ) → ( ∃ x ∈ A ph ∧ ∃ x ∈ A ps ) ) ;;
}

proof of r19.40 {
	step 1 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 2 : wff = reximi (step 1) |- ( ∃ x ∈ A ( ph ∧ ps ) → ∃ x ∈ A ph ) ;;
	step 3 : wff = simpr () |- ( ( ph ∧ ps ) → ps ) ;;
	step 4 : wff = reximi (step 3) |- ( ∃ x ∈ A ( ph ∧ ps ) → ∃ x ∈ A ps ) ;;
	step 5 : wff = jca (step 2, step 4) |- ( ∃ x ∈ A ( ph ∧ ps ) → ( ∃ x ∈ A ph ∧ ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted quantifier version of Theorem 19.41 of [Margaris] p. 90.
       (Contributed by NM, 1-Nov-2010.) */

theorem r19.41 (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ps ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ps ) ) ;;
}

proof of r19.41 {
	step 1 : wff = anass () |- ( ( ( x ∈ A ∧ ph ) ∧ ps ) ↔ ( x ∈ A ∧ ( ph ∧ ps ) ) ) ;;
	step 2 : wff = exbii (step 1) |- ( ∃ x ( ( x ∈ A ∧ ph ) ∧ ps ) ↔ ∃ x ( x ∈ A ∧ ( ph ∧ ps ) ) ) ;;
	step 3 : wff = 19.41 (hyp 1) |- ( ∃ x ( ( x ∈ A ∧ ph ) ∧ ps ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ps ) ) ;;
	step 4 : wff = bitr3i (step 2, step 3) |- ( ∃ x ( x ∈ A ∧ ( ph ∧ ps ) ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ps ) ) ;;
	step 5 : wff = df-rex () |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ∃ x ( x ∈ A ∧ ( ph ∧ ps ) ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 7 : wff = anbi1i (step 6) |- ( ( ∃ x ∈ A ph ∧ ps ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ps ) ) ;;
	step 8 : wff = 3bitr4i (step 4, step 5, step 7) |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Restricted quantifier version of Theorem 19.41 of [Margaris] p. 90.
       (Contributed by NM, 17-Dec-2003.) */

theorem r19.41v (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ps ) ) ;;
}

proof of r19.41v {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = r19.41 (step 1) |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Restricted version of Theorem 19.42 of [Margaris] p. 90.  (Contributed
       by NM, 27-May-1998.) */

theorem r19.42v (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ( ph ∧ ∃ x ∈ A ps ) ) ;;
}

proof of r19.42v {
	step 1 : wff = r19.41v () |- ( ∃ x ∈ A ( ps ∧ ph ) ↔ ( ∃ x ∈ A ps ∧ ph ) ) ;;
	step 2 : wff = ancom () |- ( ( ph ∧ ps ) ↔ ( ps ∧ ph ) ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ∃ x ∈ A ( ps ∧ ph ) ) ;;
	step 4 : wff = ancom () |- ( ( ph ∧ ∃ x ∈ A ps ) ↔ ( ∃ x ∈ A ps ∧ ph ) ) ;;
	step 5 : wff = 3bitr4i (step 1, step 3, step 4) |- ( ∃ x ∈ A ( ph ∧ ps ) ↔ ( ph ∧ ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted version of Theorem 19.43 of [Margaris] p. 90.  (Contributed by
     NM, 27-May-1998.)  (Proof shortened by Andrew Salmon, 30-May-2011.) */

theorem r19.43 (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∨ ps ) ↔ ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) ) ;;
}

proof of r19.43 {
	step 1 : wff = r19.35 () |- ( ∃ x ∈ A ( ¬ ph → ps ) ↔ ( ∀ x ∈ A ¬ ph → ∃ x ∈ A ps ) ) ;;
	step 2 : wff = df-or () |- ( ( ph ∨ ps ) ↔ ( ¬ ph → ps ) ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ x ∈ A ( ph ∨ ps ) ↔ ∃ x ∈ A ( ¬ ph → ps ) ) ;;
	step 4 : wff = df-or () |- ( ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) ↔ ( ¬ ∃ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	step 5 : wff = ralnex () |- ( ∀ x ∈ A ¬ ph ↔ ¬ ∃ x ∈ A ph ) ;;
	step 6 : wff = imbi1i (step 5) |- ( ( ∀ x ∈ A ¬ ph → ∃ x ∈ A ps ) ↔ ( ¬ ∃ x ∈ A ph → ∃ x ∈ A ps ) ) ;;
	step 7 : wff = bitr4i (step 4, step 6) |- ( ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) ↔ ( ∀ x ∈ A ¬ ph → ∃ x ∈ A ps ) ) ;;
	step 8 : wff = 3bitr4i (step 1, step 3, step 7) |- ( ∃ x ∈ A ( ph ∨ ps ) ↔ ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/*One direction of a restricted quantifier version of Theorem 19.44 of
       [Margaris] p. 90.  The other direction doesn't hold when ` A ` is
       empty.  (Contributed by NM, 2-Apr-2004.) */

theorem r19.44av (ph : wff, ps : wff, x : set, A : class) disjointed(x ps) {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∨ ps ) → ( ∃ x ∈ A ph ∨ ps ) ) ;;
}

proof of r19.44av {
	step 1 : wff = r19.43 () |- ( ∃ x ∈ A ( ph ∨ ps ) ↔ ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) ) ;;
	step 2 : wff = idd () |- ( x ∈ A → ( ps → ps ) ) ;;
	step 3 : wff = rexlimiv (step 2) |- ( ∃ x ∈ A ps → ps ) ;;
	step 4 : wff = orim2i (step 3) |- ( ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) → ( ∃ x ∈ A ph ∨ ps ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( ∃ x ∈ A ( ph ∨ ps ) → ( ∃ x ∈ A ph ∨ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Restricted version of one direction of Theorem 19.45 of [Margaris]
       p. 90.  (The other direction doesn't hold when ` A ` is empty.)
       (Contributed by NM, 2-Apr-2004.) */

theorem r19.45av (ph : wff, ps : wff, x : set, A : class) disjointed(x ph) {
	prop 1 : wff = |- ( ∃ x ∈ A ( ph ∨ ps ) → ( ph ∨ ∃ x ∈ A ps ) ) ;;
}

proof of r19.45av {
	step 1 : wff = r19.43 () |- ( ∃ x ∈ A ( ph ∨ ps ) ↔ ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) ) ;;
	step 2 : wff = idd () |- ( x ∈ A → ( ph → ph ) ) ;;
	step 3 : wff = rexlimiv (step 2) |- ( ∃ x ∈ A ph → ph ) ;;
	step 4 : wff = orim1i (step 3) |- ( ( ∃ x ∈ A ph ∨ ∃ x ∈ A ps ) → ( ph ∨ ∃ x ∈ A ps ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( ∃ x ∈ A ( ph ∨ ps ) → ( ph ∨ ∃ x ∈ A ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Commutation of restricted quantifiers.  (Contributed by Mario Carneiro,
       14-Oct-2016.) */

theorem ralcomf (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y) {
	hyp 1 : wff = |- F/_ y A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ y ∈ B ∀ x ∈ A ph ) ;;
}

proof of ralcomf {
	step 1 : wff = ancomsimp () |- ( ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ( ( y ∈ B ∧ x ∈ A ) → ph ) ) ;;
	step 2 : wff = 2albii (step 1) |- ( ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ∀ x ∀ y ( ( y ∈ B ∧ x ∈ A ) → ph ) ) ;;
	step 3 : wff = alcom () |- ( ∀ x ∀ y ( ( y ∈ B ∧ x ∈ A ) → ph ) ↔ ∀ y ∀ x ( ( y ∈ B ∧ x ∈ A ) → ph ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ↔ ∀ y ∀ x ( ( y ∈ B ∧ x ∈ A ) → ph ) ) ;;
	step 5 : wff = r2alf (hyp 1) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ) → ph ) ) ;;
	step 6 : wff = r2alf (hyp 2) |- ( ∀ y ∈ B ∀ x ∈ A ph ↔ ∀ y ∀ x ( ( y ∈ B ∧ x ∈ A ) → ph ) ) ;;
	step 7 : wff = 3bitr4i (step 4, step 5, step 6) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ y ∈ B ∀ x ∈ A ph ) ;;
	qed prop 1 = step 7 ;;
}

/*Commutation of restricted quantifiers.  (Contributed by Mario Carneiro,
       14-Oct-2016.) */

theorem rexcomf (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y) {
	hyp 1 : wff = |- F/_ y A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ y ∈ B ∃ x ∈ A ph ) ;;
}

proof of rexcomf {
	step 1 : wff = ancom () |- ( ( x ∈ A ∧ y ∈ B ) ↔ ( y ∈ B ∧ x ∈ A ) ) ;;
	step 2 : wff = anbi1i (step 1) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ( ( y ∈ B ∧ x ∈ A ) ∧ ph ) ) ;;
	step 3 : wff = 2exbii (step 2) |- ( ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ∃ x ∃ y ( ( y ∈ B ∧ x ∈ A ) ∧ ph ) ) ;;
	step 4 : wff = excom () |- ( ∃ x ∃ y ( ( y ∈ B ∧ x ∈ A ) ∧ ph ) ↔ ∃ y ∃ x ( ( y ∈ B ∧ x ∈ A ) ∧ ph ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ↔ ∃ y ∃ x ( ( y ∈ B ∧ x ∈ A ) ∧ ph ) ) ;;
	step 6 : wff = r2exf (hyp 1) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ph ) ) ;;
	step 7 : wff = r2exf (hyp 2) |- ( ∃ y ∈ B ∃ x ∈ A ph ↔ ∃ y ∃ x ( ( y ∈ B ∧ x ∈ A ) ∧ ph ) ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ y ∈ B ∃ x ∈ A ph ) ;;
	qed prop 1 = step 8 ;;
}

/*Commutation of restricted quantifiers.  (Contributed by NM,
       13-Oct-1999.)  (Revised by Mario Carneiro, 14-Oct-2016.) */

theorem ralcom (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y, x B, y A) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ y ∈ B ∀ x ∈ A ph ) ;;
}

proof of ralcom {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = ralcomf (step 1, step 2) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ y ∈ B ∀ x ∈ A ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Commutation of restricted quantifiers.  (Contributed by NM,
       19-Nov-1995.)  (Revised by Mario Carneiro, 14-Oct-2016.) */

theorem rexcom (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y, x B, y A) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ y ∈ B ∃ x ∈ A ph ) ;;
}

proof of rexcom {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = rexcomf (step 1, step 2) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ y ∈ B ∃ x ∈ A ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Swap 1st and 3rd restricted existential quantifiers.  (Contributed by
       NM, 8-Apr-2015.) */

theorem rexcom13 (ph : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(y z A, x z B, x y C) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ph ↔ ∃ z ∈ C ∃ y ∈ B ∃ x ∈ A ph ) ;;
}

proof of rexcom13 {
	step 1 : wff = rexcom () |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ph ↔ ∃ y ∈ B ∃ x ∈ A ∃ z ∈ C ph ) ;;
	step 2 : wff = rexcom () |- ( ∃ x ∈ A ∃ z ∈ C ph ↔ ∃ z ∈ C ∃ x ∈ A ph ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ y ∈ B ∃ x ∈ A ∃ z ∈ C ph ↔ ∃ y ∈ B ∃ z ∈ C ∃ x ∈ A ph ) ;;
	step 4 : wff = rexcom () |- ( ∃ y ∈ B ∃ z ∈ C ∃ x ∈ A ph ↔ ∃ z ∈ C ∃ y ∈ B ∃ x ∈ A ph ) ;;
	step 5 : wff = 3bitri (step 1, step 3, step 4) |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ph ↔ ∃ z ∈ C ∃ y ∈ B ∃ x ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/*Rotate existential restricted quantifiers twice.  (Contributed by NM,
       8-Apr-2015.) */

theorem rexrot4 (ph : wff, x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class) disjointed(w z A, w z B, w x y C, x y z D) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ∃ w ∈ D ph ↔ ∃ z ∈ C ∃ w ∈ D ∃ x ∈ A ∃ y ∈ B ph ) ;;
}

proof of rexrot4 {
	step 1 : wff = rexcom13 () |- ( ∃ y ∈ B ∃ z ∈ C ∃ w ∈ D ph ↔ ∃ w ∈ D ∃ z ∈ C ∃ y ∈ B ph ) ;;
	step 2 : wff = rexbii (step 1) |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ∃ w ∈ D ph ↔ ∃ x ∈ A ∃ w ∈ D ∃ z ∈ C ∃ y ∈ B ph ) ;;
	step 3 : wff = rexcom13 () |- ( ∃ x ∈ A ∃ w ∈ D ∃ z ∈ C ∃ y ∈ B ph ↔ ∃ z ∈ C ∃ w ∈ D ∃ x ∈ A ∃ y ∈ B ph ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ∃ w ∈ D ph ↔ ∃ z ∈ C ∃ w ∈ D ∃ x ∈ A ∃ y ∈ B ph ) ;;
	qed prop 1 = step 4 ;;
}

/*Commutation of restricted quantifiers.  Note that ` x ` and ` y `
       needn't be distinct (this makes the proof longer).  (Contributed by NM,
       24-Nov-1994.)  (Proof shortened by Mario Carneiro, 17-Oct-2016.) */

theorem ralcom2 (ph : wff, x : set, y : set, A : class) disjointed(y A, x A) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ A ph → ∀ y ∈ A ∀ x ∈ A ph ) ;;
}

proof of ralcom2 {
	step 1 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 2 : wff = sps (step 1) |- ( ∀ x x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 3 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 4 : wff = sps (step 3) |- ( ∀ x x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 5 : wff = imbi1d (step 4) |- ( ∀ x x = y → ( ( x ∈ A → ph ) ↔ ( y ∈ A → ph ) ) ) ;;
	step 6 : wff = dral1 (step 5) |- ( ∀ x x = y → ( ∀ x ( x ∈ A → ph ) ↔ ∀ y ( y ∈ A → ph ) ) ) ;;
	step 7 : wff = bicomd (step 6) |- ( ∀ x x = y → ( ∀ y ( y ∈ A → ph ) ↔ ∀ x ( x ∈ A → ph ) ) ) ;;
	step 8 : wff = df-ral () |- ( ∀ y ∈ A ph ↔ ∀ y ( y ∈ A → ph ) ) ;;
	step 9 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 10 : wff = 3bitr4g (step 7, step 8, step 9) |- ( ∀ x x = y → ( ∀ y ∈ A ph ↔ ∀ x ∈ A ph ) ) ;;
	step 11 : wff = imbi12d (step 2, step 10) |- ( ∀ x x = y → ( ( x ∈ A → ∀ y ∈ A ph ) ↔ ( y ∈ A → ∀ x ∈ A ph ) ) ) ;;
	step 12 : wff = dral1 (step 11) |- ( ∀ x x = y → ( ∀ x ( x ∈ A → ∀ y ∈ A ph ) ↔ ∀ y ( y ∈ A → ∀ x ∈ A ph ) ) ) ;;
	step 13 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∈ A ph ↔ ∀ x ( x ∈ A → ∀ y ∈ A ph ) ) ;;
	step 14 : wff = df-ral () |- ( ∀ y ∈ A ∀ x ∈ A ph ↔ ∀ y ( y ∈ A → ∀ x ∈ A ph ) ) ;;
	step 15 : wff = 3bitr4g (step 12, step 13, step 14) |- ( ∀ x x = y → ( ∀ x ∈ A ∀ y ∈ A ph ↔ ∀ y ∈ A ∀ x ∈ A ph ) ) ;;
	step 16 : wff = biimpd (step 15) |- ( ∀ x x = y → ( ∀ x ∈ A ∀ y ∈ A ph → ∀ y ∈ A ∀ x ∈ A ph ) ) ;;
	step 17 : wff = nfnae () |- F/ y ¬ ∀ x x = y ;;
	step 18 : wff = nfra2 () |- F/ y ∀ x ∈ A ∀ y ∈ A ph ;;
	step 19 : wff = nfan (step 17, step 18) |- F/ y ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) ;;
	step 20 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 21 : wff = nfra1 () |- F/ x ∀ x ∈ A ∀ y ∈ A ph ;;
	step 22 : wff = nfan (step 20, step 21) |- F/ x ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) ;;
	step 23 : wff = nfcvf () |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	step 24 : wff = adantr (step 23) |- ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) → F/_ x y ) ;;
	step 25 : wff = nfcvd () |- ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) → F/_ x A ) ;;
	step 26 : wff = nfeld (step 24, step 25) |- ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) → F/ x y ∈ A ) ;;
	step 27 : wff = nfan1 (step 22, step 26) |- F/ x ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) ∧ y ∈ A ) ;;
	step 28 : wff = rsp2 () |- ( ∀ x ∈ A ∀ y ∈ A ph → ( ( x ∈ A ∧ y ∈ A ) → ph ) ) ;;
	step 29 : wff = ancomsd (step 28) |- ( ∀ x ∈ A ∀ y ∈ A ph → ( ( y ∈ A ∧ x ∈ A ) → ph ) ) ;;
	step 30 : wff = expdimp (step 29) |- ( ( ∀ x ∈ A ∀ y ∈ A ph ∧ y ∈ A ) → ( x ∈ A → ph ) ) ;;
	step 31 : wff = adantll (step 30) |- ( ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) ∧ y ∈ A ) → ( x ∈ A → ph ) ) ;;
	step 32 : wff = ralrimi (step 27, step 31) |- ( ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) ∧ y ∈ A ) → ∀ x ∈ A ph ) ;;
	step 33 : wff = ex (step 32) |- ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) → ( y ∈ A → ∀ x ∈ A ph ) ) ;;
	step 34 : wff = ralrimi (step 19, step 33) |- ( ( ¬ ∀ x x = y ∧ ∀ x ∈ A ∀ y ∈ A ph ) → ∀ y ∈ A ∀ x ∈ A ph ) ;;
	step 35 : wff = ex (step 34) |- ( ¬ ∀ x x = y → ( ∀ x ∈ A ∀ y ∈ A ph → ∀ y ∈ A ∀ x ∈ A ph ) ) ;;
	step 36 : wff = pm2.61i (step 16, step 35) |- ( ∀ x ∈ A ∀ y ∈ A ph → ∀ y ∈ A ∀ x ∈ A ph ) ;;
	qed prop 1 = step 36 ;;
}

/*A commutative law for restricted quantifiers that swaps the domain of
       the restriction.  (Contributed by NM, 22-Feb-2004.) */

theorem ralcom3 (ph : wff, x : set, A : class, B : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( x ∈ B → ph ) ↔ ∀ x ∈ B ( x ∈ A → ph ) ) ;;
}

proof of ralcom3 {
	step 1 : wff = pm2.04 () |- ( ( x ∈ A → ( x ∈ B → ph ) ) → ( x ∈ B → ( x ∈ A → ph ) ) ) ;;
	step 2 : wff = ralimi2 (step 1) |- ( ∀ x ∈ A ( x ∈ B → ph ) → ∀ x ∈ B ( x ∈ A → ph ) ) ;;
	step 3 : wff = pm2.04 () |- ( ( x ∈ B → ( x ∈ A → ph ) ) → ( x ∈ A → ( x ∈ B → ph ) ) ) ;;
	step 4 : wff = ralimi2 (step 3) |- ( ∀ x ∈ B ( x ∈ A → ph ) → ∀ x ∈ A ( x ∈ B → ph ) ) ;;
	step 5 : wff = impbii (step 2, step 4) |- ( ∀ x ∈ A ( x ∈ B → ph ) ↔ ∀ x ∈ B ( x ∈ A → ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Rearrange existential quantifiers.  (Contributed by NM, 27-Oct-2010.)
       (Proof shortened by Andrew Salmon, 30-May-2011.) */

theorem reean (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(y A, x B, x y) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ) ;;
}

proof of reean {
	step 1 : wff = an4 () |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ( ph ∧ ps ) ) ↔ ( ( x ∈ A ∧ ph ) ∧ ( y ∈ B ∧ ps ) ) ) ;;
	step 2 : wff = 2exbii (step 1) |- ( ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ( ph ∧ ps ) ) ↔ ∃ x ∃ y ( ( x ∈ A ∧ ph ) ∧ ( y ∈ B ∧ ps ) ) ) ;;
	step 3 : wff = nfv () |- F/ y x ∈ A ;;
	step 4 : wff = nfan (step 3, hyp 1) |- F/ y ( x ∈ A ∧ ph ) ;;
	step 5 : wff = nfv () |- F/ x y ∈ B ;;
	step 6 : wff = nfan (step 5, hyp 2) |- F/ x ( y ∈ B ∧ ps ) ;;
	step 7 : wff = eean (step 4, step 6) |- ( ∃ x ∃ y ( ( x ∈ A ∧ ph ) ∧ ( y ∈ B ∧ ps ) ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃ y ( y ∈ B ∧ ps ) ) ) ;;
	step 8 : wff = bitri (step 2, step 7) |- ( ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ( ph ∧ ps ) ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃ y ( y ∈ B ∧ ps ) ) ) ;;
	step 9 : wff = r2ex () |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ↔ ∃ x ∃ y ( ( x ∈ A ∧ y ∈ B ) ∧ ( ph ∧ ps ) ) ) ;;
	step 10 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 11 : wff = df-rex () |- ( ∃ y ∈ B ps ↔ ∃ y ( y ∈ B ∧ ps ) ) ;;
	step 12 : wff = anbi12i (step 10, step 11) |- ( ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃ y ( y ∈ B ∧ ps ) ) ) ;;
	step 13 : wff = 3bitr4i (step 8, step 9, step 12) |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Rearrange existential quantifiers.  (Contributed by NM, 9-May-1999.) */

theorem reeanv (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(y ph, x ps, x y, y A, x B) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ) ;;
}

proof of reeanv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = reean (step 1, step 2) |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Rearrange three existential quantifiers.  (Contributed by Jeff Madsen,
       11-Jun-2010.) */

theorem 3reeanv (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(ph y z, ps x z, ch x y, A y, B x z, C x y) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ( ph ∧ ps ∧ ch ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ∧ ∃ z ∈ C ch ) ) ;;
}

proof of 3reeanv {
	step 1 : wff = r19.41v () |- ( ∃ x ∈ A ( ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ↔ ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 2 : wff = reeanv () |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ↔ ( ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( ∃ x ∈ A ( ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ↔ ( ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 5 : wff = df-3an () |- ( ( ph ∧ ps ∧ ch ) ↔ ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 6 : wff = 2rexbii (step 5) |- ( ∃ y ∈ B ∃ z ∈ C ( ph ∧ ps ∧ ch ) ↔ ∃ y ∈ B ∃ z ∈ C ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 7 : wff = reeanv () |- ( ∃ y ∈ B ∃ z ∈ C ( ( ph ∧ ps ) ∧ ch ) ↔ ( ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 8 : wff = bitri (step 6, step 7) |- ( ∃ y ∈ B ∃ z ∈ C ( ph ∧ ps ∧ ch ) ↔ ( ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 9 : wff = rexbii (step 8) |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ( ph ∧ ps ∧ ch ) ↔ ∃ x ∈ A ( ∃ y ∈ B ( ph ∧ ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 10 : wff = df-3an () |- ( ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ∧ ∃ z ∈ C ch ) ↔ ( ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ) ∧ ∃ z ∈ C ch ) ) ;;
	step 11 : wff = 3bitr4i (step 4, step 9, step 10) |- ( ∃ x ∈ A ∃ y ∈ B ∃ z ∈ C ( ph ∧ ps ∧ ch ) ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ B ps ∧ ∃ z ∈ C ch ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Distribute quantification over "or".  (Contributed by Jeff Madsen,
       19-Jun-2010.) */

theorem 2ralor (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(ph y, ps x, A y, B x, x y) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ( ph ∨ ps ) ↔ ( ∀ x ∈ A ph ∨ ∀ y ∈ B ps ) ) ;;
}

proof of 2ralor {
	step 1 : wff = rexnal () |- ( ∃ x ∈ A ¬ ph ↔ ¬ ∀ x ∈ A ph ) ;;
	step 2 : wff = rexnal () |- ( ∃ y ∈ B ¬ ps ↔ ¬ ∀ y ∈ B ps ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( ∃ x ∈ A ¬ ph ∧ ∃ y ∈ B ¬ ps ) ↔ ( ¬ ∀ x ∈ A ph ∧ ¬ ∀ y ∈ B ps ) ) ;;
	step 4 : wff = ioran () |- ( ¬ ( ph ∨ ps ) ↔ ( ¬ ph ∧ ¬ ps ) ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ y ∈ B ¬ ( ph ∨ ps ) ↔ ∃ y ∈ B ( ¬ ph ∧ ¬ ps ) ) ;;
	step 6 : wff = rexnal () |- ( ∃ y ∈ B ¬ ( ph ∨ ps ) ↔ ¬ ∀ y ∈ B ( ph ∨ ps ) ) ;;
	step 7 : wff = bitr3i (step 5, step 6) |- ( ∃ y ∈ B ( ¬ ph ∧ ¬ ps ) ↔ ¬ ∀ y ∈ B ( ph ∨ ps ) ) ;;
	step 8 : wff = rexbii (step 7) |- ( ∃ x ∈ A ∃ y ∈ B ( ¬ ph ∧ ¬ ps ) ↔ ∃ x ∈ A ¬ ∀ y ∈ B ( ph ∨ ps ) ) ;;
	step 9 : wff = reeanv () |- ( ∃ x ∈ A ∃ y ∈ B ( ¬ ph ∧ ¬ ps ) ↔ ( ∃ x ∈ A ¬ ph ∧ ∃ y ∈ B ¬ ps ) ) ;;
	step 10 : wff = rexnal () |- ( ∃ x ∈ A ¬ ∀ y ∈ B ( ph ∨ ps ) ↔ ¬ ∀ x ∈ A ∀ y ∈ B ( ph ∨ ps ) ) ;;
	step 11 : wff = 3bitr3ri (step 8, step 9, step 10) |- ( ¬ ∀ x ∈ A ∀ y ∈ B ( ph ∨ ps ) ↔ ( ∃ x ∈ A ¬ ph ∧ ∃ y ∈ B ¬ ps ) ) ;;
	step 12 : wff = ioran () |- ( ¬ ( ∀ x ∈ A ph ∨ ∀ y ∈ B ps ) ↔ ( ¬ ∀ x ∈ A ph ∧ ¬ ∀ y ∈ B ps ) ) ;;
	step 13 : wff = 3bitr4i (step 3, step 11, step 12) |- ( ¬ ∀ x ∈ A ∀ y ∈ B ( ph ∨ ps ) ↔ ¬ ( ∀ x ∈ A ph ∨ ∀ y ∈ B ps ) ) ;;
	step 14 : wff = con4bii (step 13) |- ( ∀ x ∈ A ∀ y ∈ B ( ph ∨ ps ) ↔ ( ∀ x ∈ A ph ∨ ∀ y ∈ B ps ) ) ;;
	qed prop 1 = step 14 ;;
}

/*` x ` is not free in ` E! x e. A ph ` .  (Contributed by NM,
     19-Mar-1997.) */

theorem nfreu1 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- F/ x ∃! x ∈ A ph ;;
}

proof of nfreu1 {
	step 1 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = nfeu1 () |- F/ x ∃! x ( x ∈ A ∧ ph ) ;;
	step 3 : wff = nfxfr (step 1, step 2) |- F/ x ∃! x ∈ A ph ;;
	qed prop 1 = step 3 ;;
}

/*` x ` is not free in ` E* x e. A ph ` .  (Contributed by NM,
     16-Jun-2017.) */

theorem nfrmo1 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- F/ x ∃* x ∈ A ph ;;
}

proof of nfrmo1 {
	step 1 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = nfmo1 () |- F/ x ∃* x ( x ∈ A ∧ ph ) ;;
	step 3 : wff = nfxfr (step 1, step 2) |- F/ x ∃* x ∈ A ph ;;
	qed prop 1 = step 3 ;;
}

/*Deduction version of ~ nfreu .  (Contributed by NM, 15-Feb-2013.)
       (Revised by Mario Carneiro, 8-Oct-2016.) */

theorem nfreud (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x, y, A, ph) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/_ x A ) ;;
	hyp 3 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃! y ∈ A ps ) ;;
}

proof of nfreud {
	step 1 : wff = df-reu () |- ( ∃! y ∈ A ps ↔ ∃! y ( y ∈ A ∧ ps ) ) ;;
	step 2 : wff = nfcvf () |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x y ) ;;
	step 4 : wff = adantr (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x A ) ;;
	step 5 : wff = nfeld (step 3, step 4) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x y ∈ A ) ;;
	step 6 : wff = adantr (hyp 3) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 7 : wff = nfand (step 5, step 6) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ( y ∈ A ∧ ps ) ) ;;
	step 8 : wff = nfeud2 (hyp 1, step 7) |- ( ph → F/ x ∃! y ( y ∈ A ∧ ps ) ) ;;
	step 9 : wff = nfxfrd (step 1, step 8) |- ( ph → F/ x ∃! y ∈ A ps ) ;;
	qed prop 1 = step 9 ;;
}

/*Deduction version of ~ nfrmo .  (Contributed by NM, 17-Jun-2017.) */

theorem nfrmod (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x, y, A, ph) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/_ x A ) ;;
	hyp 3 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃* y ∈ A ps ) ;;
}

proof of nfrmod {
	step 1 : wff = df-rmo () |- ( ∃* y ∈ A ps ↔ ∃* y ( y ∈ A ∧ ps ) ) ;;
	step 2 : wff = nfcvf () |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x y ) ;;
	step 4 : wff = adantr (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x A ) ;;
	step 5 : wff = nfeld (step 3, step 4) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x y ∈ A ) ;;
	step 6 : wff = adantr (hyp 3) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 7 : wff = nfand (step 5, step 6) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ( y ∈ A ∧ ps ) ) ;;
	step 8 : wff = nfmod2 (hyp 1, step 7) |- ( ph → F/ x ∃* y ( y ∈ A ∧ ps ) ) ;;
	step 9 : wff = nfxfrd (step 1, step 8) |- ( ph → F/ x ∃* y ∈ A ps ) ;;
	qed prop 1 = step 9 ;;
}

/*Bound-variable hypothesis builder for restricted uniqueness.
       (Contributed by NM, 30-Oct-2010.)  (Revised by Mario Carneiro,
       8-Oct-2016.) */

theorem nfreu (ph : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ∃! y ∈ A ph ;;
}

proof of nfreu {
	step 1 : wff = nftru () |- F/ y T. ;;
	step 2 : wff = a1i (hyp 1) |- ( T. → F/_ x A ) ;;
	step 3 : wff = a1i (hyp 2) |- ( T. → F/ x ph ) ;;
	step 4 : wff = nfreud (step 1, step 2, step 3) |- ( T. → F/ x ∃! y ∈ A ph ) ;;
	step 5 : wff = trud (step 4) |- F/ x ∃! y ∈ A ph ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for restricted uniqueness.
       (Contributed by NM, 16-Jun-2017.) */

theorem nfrmo (ph : wff, x : set, y : set, A : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ∃* y ∈ A ph ;;
}

proof of nfrmo {
	step 1 : wff = df-rmo () |- ( ∃* y ∈ A ph ↔ ∃* y ( y ∈ A ∧ ph ) ) ;;
	step 2 : wff = nftru () |- F/ y T. ;;
	step 3 : wff = nfcvf () |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	step 4 : wff = a1i (hyp 1) |- ( ¬ ∀ x x = y → F/_ x A ) ;;
	step 5 : wff = nfeld (step 3, step 4) |- ( ¬ ∀ x x = y → F/ x y ∈ A ) ;;
	step 6 : wff = a1i (hyp 2) |- ( ¬ ∀ x x = y → F/ x ph ) ;;
	step 7 : wff = nfand (step 5, step 6) |- ( ¬ ∀ x x = y → F/ x ( y ∈ A ∧ ph ) ) ;;
	step 8 : wff = adantl (step 7) |- ( ( T. ∧ ¬ ∀ x x = y ) → F/ x ( y ∈ A ∧ ph ) ) ;;
	step 9 : wff = nfmod2 (step 2, step 8) |- ( T. → F/ x ∃* y ( y ∈ A ∧ ph ) ) ;;
	step 10 : wff = trud (step 9) |- F/ x ∃* y ( y ∈ A ∧ ph ) ;;
	step 11 : wff = nfxfr (step 1, step 10) |- F/ x ∃* y ∈ A ph ;;
	qed prop 1 = step 11 ;;
}

/*An "identity" law of concretion for restricted abstraction.  Special case
     of Definition 2.1 of [Quine] p. 16.  (Contributed by NM, 9-Oct-2003.) */

theorem rabid (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( x ∈ { x ∈ A | ph } ↔ ( x ∈ A ∧ ph ) ) ;;
}

proof of rabid {
	step 1 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 2 : wff = abeq2i (step 1) |- ( x ∈ { x ∈ A | ph } ↔ ( x ∈ A ∧ ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*An "identity" law for restricted class abstraction.  (Contributed by NM,
       9-Oct-2003.)  (Proof shortened by Andrew Salmon, 30-May-2011.) */

theorem rabid2 (ph : wff, x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( A = { x ∈ A | ph } ↔ ∀ x ∈ A ph ) ;;
}

proof of rabid2 {
	step 1 : wff = abeq2 () |- ( A = { x | ( x ∈ A ∧ ph ) } ↔ ∀ x ( x ∈ A ↔ ( x ∈ A ∧ ph ) ) ) ;;
	step 2 : wff = pm4.71 () |- ( ( x ∈ A → ph ) ↔ ( x ∈ A ↔ ( x ∈ A ∧ ph ) ) ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ x ( x ∈ A → ph ) ↔ ∀ x ( x ∈ A ↔ ( x ∈ A ∧ ph ) ) ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( A = { x | ( x ∈ A ∧ ph ) } ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 5 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 6 : wff = eqeq2i (step 5) |- ( A = { x ∈ A | ph } ↔ A = { x | ( x ∈ A ∧ ph ) } ) ;;
	step 7 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 8 : wff = 3bitr4i (step 4, step 6, step 7) |- ( A = { x ∈ A | ph } ↔ ∀ x ∈ A ph ) ;;
	qed prop 1 = step 8 ;;
}

/*Equivalent wff's correspond to equal restricted class abstractions.
       Closed theorem form of ~ rabbidva .  (Contributed by NM,
       25-Nov-2013.) */

theorem rabbi (ps : wff, ch : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ps ↔ ch ) ↔ { x ∈ A | ps } = { x ∈ A | ch } ) ;;
}

proof of rabbi {
	step 1 : wff = abbi () |- ( ∀ x ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ↔ { x | ( x ∈ A ∧ ps ) } = { x | ( x ∈ A ∧ ch ) } ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ A ( ps ↔ ch ) ↔ ∀ x ( x ∈ A → ( ps ↔ ch ) ) ) ;;
	step 3 : wff = pm5.32 () |- ( ( x ∈ A → ( ps ↔ ch ) ) ↔ ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x ( x ∈ A → ( ps ↔ ch ) ) ↔ ∀ x ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∀ x ∈ A ( ps ↔ ch ) ↔ ∀ x ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ) ;;
	step 6 : wff = df-rab () |- { x ∈ A | ps } = { x | ( x ∈ A ∧ ps ) } ;;
	step 7 : wff = df-rab () |- { x ∈ A | ch } = { x | ( x ∈ A ∧ ch ) } ;;
	step 8 : wff = eqeq12i (step 6, step 7) |- ( { x ∈ A | ps } = { x ∈ A | ch } ↔ { x | ( x ∈ A ∧ ps ) } = { x | ( x ∈ A ∧ ch ) } ) ;;
	step 9 : wff = 3bitr4i (step 1, step 5, step 8) |- ( ∀ x ∈ A ( ps ↔ ch ) ↔ { x ∈ A | ps } = { x ∈ A | ch } ) ;;
	qed prop 1 = step 9 ;;
}

/*Swap with a membership relation in a restricted class abstraction.
     (Contributed by NM, 4-Jul-2005.) */

theorem rabswap (x : set, A : class, B : class)  {
	prop 1 : wff = |- { x ∈ A | x ∈ B } = { x ∈ B | x ∈ A } ;;
}

proof of rabswap {
	step 1 : wff = ancom () |- ( ( x ∈ A ∧ x ∈ B ) ↔ ( x ∈ B ∧ x ∈ A ) ) ;;
	step 2 : wff = abbii (step 1) |- { x | ( x ∈ A ∧ x ∈ B ) } = { x | ( x ∈ B ∧ x ∈ A ) } ;;
	step 3 : wff = df-rab () |- { x ∈ A | x ∈ B } = { x | ( x ∈ A ∧ x ∈ B ) } ;;
	step 4 : wff = df-rab () |- { x ∈ B | x ∈ A } = { x | ( x ∈ B ∧ x ∈ A ) } ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- { x ∈ A | x ∈ B } = { x ∈ B | x ∈ A } ;;
	qed prop 1 = step 5 ;;
}

/*The abstraction variable in a restricted class abstraction isn't free.
       (Contributed by NM, 19-Mar-1997.) */

theorem nfrab1 (ph : wff, x : set, A : class) disjointed(x) {
	prop 1 : wff = |- F/_ x { x ∈ A | ph } ;;
}

proof of nfrab1 {
	step 1 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 2 : wff = nfab1 () |- F/_ x { x | ( x ∈ A ∧ ph ) } ;;
	step 3 : wff = nfcxfr (step 1, step 2) |- F/_ x { x ∈ A | ph } ;;
	qed prop 1 = step 3 ;;
}

/*A variable not free in a wff remains so in a restricted class
       abstraction.  (Contributed by NM, 13-Oct-2003.)  (Revised by Mario
       Carneiro, 9-Oct-2016.) */

theorem nfrab (ph : wff, x : set, y : set, A : class) disjointed(x z, y z, z A) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x { y ∈ A | ph } ;;
}

proof of nfrab {
	var z : set;;
	step 1 : wff = df-rab () |- { y ∈ A | ph } = { y | ( y ∈ A ∧ ph ) } ;;
	step 2 : wff = nftru () |- F/ y T. ;;
	step 3 : wff = nfcri (hyp 2) |- F/ x z ∈ A ;;
	step 4 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 5 : wff = dvelimnf (step 3, step 4) |- ( ¬ ∀ x x = y → F/ x y ∈ A ) ;;
	step 6 : wff = a1i (hyp 1) |- ( ¬ ∀ x x = y → F/ x ph ) ;;
	step 7 : wff = nfand (step 5, step 6) |- ( ¬ ∀ x x = y → F/ x ( y ∈ A ∧ ph ) ) ;;
	step 8 : wff = adantl (step 7) |- ( ( T. ∧ ¬ ∀ x x = y ) → F/ x ( y ∈ A ∧ ph ) ) ;;
	step 9 : wff = nfabd2 (step 2, step 8) |- ( T. → F/_ x { y | ( y ∈ A ∧ ph ) } ) ;;
	step 10 : wff = trud (step 9) |- F/_ x { y | ( y ∈ A ∧ ph ) } ;;
	step 11 : wff = nfcxfr (step 1, step 10) |- F/_ x { y ∈ A | ph } ;;
	qed prop 1 = step 11 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by Mario Carneiro, 19-Nov-2016.) */

theorem reubida (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃! x ∈ A ps ↔ ∃! x ∈ A ch ) ) ;;
}

proof of reubida {
	step 1 : wff = pm5.32da (hyp 2) |- ( ph → ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ) ;;
	step 2 : wff = eubid (hyp 1, step 1) |- ( ph → ( ∃! x ( x ∈ A ∧ ps ) ↔ ∃! x ( x ∈ A ∧ ch ) ) ) ;;
	step 3 : wff = df-reu () |- ( ∃! x ∈ A ps ↔ ∃! x ( x ∈ A ∧ ps ) ) ;;
	step 4 : wff = df-reu () |- ( ∃! x ∈ A ch ↔ ∃! x ( x ∈ A ∧ ch ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( ph → ( ∃! x ∈ A ps ↔ ∃! x ∈ A ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 13-Nov-2004.) */

theorem reubidva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃! x ∈ A ps ↔ ∃! x ∈ A ch ) ) ;;
}

proof of reubidva {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = reubida (step 1, hyp 1) |- ( ph → ( ∃! x ∈ A ps ↔ ∃! x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 17-Oct-1996.) */

theorem reubidv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃! x ∈ A ps ↔ ∃! x ∈ A ch ) ) ;;
}

proof of reubidv {
	step 1 : wff = adantr (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	step 2 : wff = reubidva (step 1) |- ( ph → ( ∃! x ∈ A ps ↔ ∃! x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (inference
       rule).  (Contributed by NM, 14-Nov-2004.) */

theorem reubiia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ∃! x ∈ A ps ) ;;
}

proof of reubiia {
	step 1 : wff = pm5.32i (hyp 1) |- ( ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ps ) ) ;;
	step 2 : wff = eubii (step 1) |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ∃! x ( x ∈ A ∧ ps ) ) ;;
	step 3 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = df-reu () |- ( ∃! x ∈ A ps ↔ ∃! x ( x ∈ A ∧ ps ) ) ;;
	step 5 : wff = 3bitr4i (step 2, step 3, step 4) |- ( ∃! x ∈ A ph ↔ ∃! x ∈ A ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted existential quantifier (inference
       rule).  (Contributed by NM, 22-Oct-1999.) */

theorem reubii (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ∃! x ∈ A ps ) ;;
}

proof of reubii {
	step 1 : wff = a1i (hyp 1) |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	step 2 : wff = reubiia (step 1) |- ( ∃! x ∈ A ph ↔ ∃! x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 16-Jun-2017.) */

theorem rmobida (ph : wff, ps : wff, ch : wff, x : set, A : class)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃* x ∈ A ps ↔ ∃* x ∈ A ch ) ) ;;
}

proof of rmobida {
	step 1 : wff = pm5.32da (hyp 2) |- ( ph → ( ( x ∈ A ∧ ps ) ↔ ( x ∈ A ∧ ch ) ) ) ;;
	step 2 : wff = mobid (hyp 1, step 1) |- ( ph → ( ∃* x ( x ∈ A ∧ ps ) ↔ ∃* x ( x ∈ A ∧ ch ) ) ) ;;
	step 3 : wff = df-rmo () |- ( ∃* x ∈ A ps ↔ ∃* x ( x ∈ A ∧ ps ) ) ;;
	step 4 : wff = df-rmo () |- ( ∃* x ∈ A ch ↔ ∃* x ( x ∈ A ∧ ch ) ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( ph → ( ∃* x ∈ A ps ↔ ∃* x ∈ A ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 16-Jun-2017.) */

theorem rmobidva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃* x ∈ A ps ↔ ∃* x ∈ A ch ) ) ;;
}

proof of rmobidva {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = rmobida (step 1, hyp 1) |- ( ph → ( ∃* x ∈ A ps ↔ ∃* x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (deduction
       rule).  (Contributed by NM, 16-Jun-2017.) */

theorem rmobidv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃* x ∈ A ps ↔ ∃* x ∈ A ch ) ) ;;
}

proof of rmobidv {
	step 1 : wff = adantr (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	step 2 : wff = rmobidva (step 1) |- ( ph → ( ∃* x ∈ A ps ↔ ∃* x ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for restricted existential quantifier (inference
       rule).  (Contributed by NM, 16-Jun-2017.) */

theorem rmobiia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ A ph ↔ ∃* x ∈ A ps ) ;;
}

proof of rmobiia {
	step 1 : wff = pm5.32i (hyp 1) |- ( ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ps ) ) ;;
	step 2 : wff = mobii (step 1) |- ( ∃* x ( x ∈ A ∧ ph ) ↔ ∃* x ( x ∈ A ∧ ps ) ) ;;
	step 3 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = df-rmo () |- ( ∃* x ∈ A ps ↔ ∃* x ( x ∈ A ∧ ps ) ) ;;
	step 5 : wff = 3bitr4i (step 2, step 3, step 4) |- ( ∃* x ∈ A ph ↔ ∃* x ∈ A ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Formula-building rule for restricted existential quantifier (inference
       rule).  (Contributed by NM, 16-Jun-2017.) */

theorem rmobii (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ A ph ↔ ∃* x ∈ A ps ) ;;
}

proof of rmobii {
	step 1 : wff = a1i (hyp 1) |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	step 2 : wff = rmobiia (step 1) |- ( ∃* x ∈ A ph ↔ ∃* x ∈ A ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for restricted universal quantifier, with
       bound-variable hypotheses instead of distinct variable restrictions.
       (Contributed by NM, 7-Mar-2004.)  (Revised by Andrew Salmon,
       11-Jul-2011.) */

theorem raleqf (ph : wff, x : set, A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ) ;;
}

proof of raleqf {
	step 1 : wff = nfeq (hyp 1, hyp 2) |- F/ x A = B ;;
	step 2 : wff = eleq2 () |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = imbi1d (step 2) |- ( A = B → ( ( x ∈ A → ph ) ↔ ( x ∈ B → ph ) ) ) ;;
	step 4 : wff = albid (step 1, step 3) |- ( A = B → ( ∀ x ( x ∈ A → ph ) ↔ ∀ x ( x ∈ B → ph ) ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 6 : wff = df-ral () |- ( ∀ x ∈ B ph ↔ ∀ x ( x ∈ B → ph ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for restricted existential quantifier, with
       bound-variable hypotheses instead of distinct variable restrictions.
       (Contributed by NM, 9-Oct-2003.)  (Revised by Andrew Salmon,
       11-Jul-2011.) */

theorem rexeqf (ph : wff, x : set, A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ) ;;
}

proof of rexeqf {
	step 1 : wff = nfeq (hyp 1, hyp 2) |- F/ x A = B ;;
	step 2 : wff = eleq2 () |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = anbi1d (step 2) |- ( A = B → ( ( x ∈ A ∧ ph ) ↔ ( x ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = exbid (step 1, step 3) |- ( A = B → ( ∃ x ( x ∈ A ∧ ph ) ↔ ∃ x ( x ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ x ∈ B ph ↔ ∃ x ( x ∈ B ∧ ph ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for restricted uniqueness quantifier, with
       bound-variable hypotheses instead of distinct variable restrictions.
       (Contributed by NM, 5-Apr-2004.)  (Revised by Andrew Salmon,
       11-Jul-2011.) */

theorem reueq1f (ph : wff, x : set, A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ph ) ) ;;
}

proof of reueq1f {
	step 1 : wff = nfeq (hyp 1, hyp 2) |- F/ x A = B ;;
	step 2 : wff = eleq2 () |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = anbi1d (step 2) |- ( A = B → ( ( x ∈ A ∧ ph ) ↔ ( x ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = eubid (step 1, step 3) |- ( A = B → ( ∃! x ( x ∈ A ∧ ph ) ↔ ∃! x ( x ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 6 : wff = df-reu () |- ( ∃! x ∈ B ph ↔ ∃! x ( x ∈ B ∧ ph ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for restricted uniqueness quantifier, with
       bound-variable hypotheses instead of distinct variable restrictions.
       (Contributed by Alexander van der Vekens, 17-Jun-2017.) */

theorem rmoeq1f (ph : wff, x : set, A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ph ) ) ;;
}

proof of rmoeq1f {
	step 1 : wff = nfeq (hyp 1, hyp 2) |- F/ x A = B ;;
	step 2 : wff = eleq2 () |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = anbi1d (step 2) |- ( A = B → ( ( x ∈ A ∧ ph ) ↔ ( x ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = mobid (step 1, step 3) |- ( A = B → ( ∃* x ( x ∈ A ∧ ph ) ↔ ∃* x ( x ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 6 : wff = df-rmo () |- ( ∃* x ∈ B ph ↔ ∃* x ( x ∈ B ∧ ph ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for restricted universal quantifier.  (Contributed by
       NM, 16-Nov-1995.) */

theorem raleq (ph : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ) ;;
}

proof of raleq {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = raleqf (step 1, step 2) |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality theorem for restricted existential quantifier.  (Contributed by
       NM, 29-Oct-1995.) */

theorem rexeq (ph : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ) ;;
}

proof of rexeq {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = rexeqf (step 1, step 2) |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality theorem for restricted uniqueness quantifier.  (Contributed by
       NM, 5-Apr-2004.) */

theorem reueq1 (ph : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ph ) ) ;;
}

proof of reueq1 {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = reueq1f (step 1, step 2) |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality theorem for restricted uniqueness quantifier.  (Contributed by
       Alexander van der Vekens, 17-Jun-2017.) */

theorem rmoeq1 (ph : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ph ) ) ;;
}

proof of rmoeq1 {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = rmoeq1f (step 1, step 2) |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality inference for restricted universal qualifier.  (Contributed by
       Paul Chapman, 22-Jun-2011.) */

theorem raleqi (ph : wff, x : set, A : class, B : class) disjointed(A x, B x) {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ;;
}

proof of raleqi {
	step 1 : wff = raleq () |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality inference for restricted existential qualifier.  (Contributed
       by Mario Carneiro, 23-Apr-2015.) */

theorem rexeqi (ph : wff, x : set, A : class, B : class) disjointed(A x, B x) {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ;;
}

proof of rexeqi {
	step 1 : wff = rexeq () |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for restricted universal quantifier.  (Contributed by
       NM, 13-Nov-2005.) */

theorem raleqdv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ps ) ) ;;
}

proof of raleqdv {
	step 1 : wff = raleq () |- ( A = B → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ps ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for restricted existential quantifier.  (Contributed
       by NM, 14-Jan-2007.) */

theorem rexeqdv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ps ) ) ;;
}

proof of rexeqdv {
	step 1 : wff = rexeq () |- ( A = B → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ps ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality deduction for restricted universal quantifier.  (Contributed by
       NM, 16-Nov-1995.) */

theorem raleqbi1dv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( A = B → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ps ) ) ;;
}

proof of raleqbi1dv {
	step 1 : wff = raleq () |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ph ) ) ;;
	step 2 : wff = ralbidv (hyp 1) |- ( A = B → ( ∀ x ∈ B ph ↔ ∀ x ∈ B ps ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( A = B → ( ∀ x ∈ A ph ↔ ∀ x ∈ B ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted existential quantifier.  (Contributed
       by NM, 18-Mar-1997.) */

theorem rexeqbi1dv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( A = B → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ps ) ) ;;
}

proof of rexeqbi1dv {
	step 1 : wff = rexeq () |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ph ) ) ;;
	step 2 : wff = rexbidv (hyp 1) |- ( A = B → ( ∃ x ∈ B ph ↔ ∃ x ∈ B ps ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( A = B → ( ∃ x ∈ A ph ↔ ∃ x ∈ B ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted uniqueness quantifier.  (Contributed
       by NM, 5-Apr-2004.) */

theorem reueqd (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( A = B → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ps ) ) ;;
}

proof of reueqd {
	step 1 : wff = reueq1 () |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ph ) ) ;;
	step 2 : wff = reubidv (hyp 1) |- ( A = B → ( ∃! x ∈ B ph ↔ ∃! x ∈ B ps ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( A = B → ( ∃! x ∈ A ph ↔ ∃! x ∈ B ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted uniqueness quantifier.  (Contributed
       by Alexander van der Vekens, 17-Jun-2017.) */

theorem rmoeqd (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( A = B → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ps ) ) ;;
}

proof of rmoeqd {
	step 1 : wff = rmoeq1 () |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ph ) ) ;;
	step 2 : wff = rmobidv (hyp 1) |- ( A = B → ( ∃* x ∈ B ph ↔ ∃* x ∈ B ps ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( A = B → ( ∃* x ∈ A ph ↔ ∃* x ∈ B ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted universal quantifier.  (Contributed by
       NM, 6-Nov-2007.) */

theorem raleqbidv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ) ;;
}

proof of raleqbidv {
	step 1 : wff = raleqdv (hyp 1) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ps ) ) ;;
	step 2 : wff = ralbidv (hyp 2) |- ( ph → ( ∀ x ∈ B ps ↔ ∀ x ∈ B ch ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted universal quantifier.  (Contributed by
       NM, 6-Nov-2007.) */

theorem rexeqbidv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ) ;;
}

proof of rexeqbidv {
	step 1 : wff = rexeqdv (hyp 1) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ps ) ) ;;
	step 2 : wff = rexbidv (hyp 2) |- ( ph → ( ∃ x ∈ B ps ↔ ∃ x ∈ B ch ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted universal quantifier.  (Contributed by
       Mario Carneiro, 5-Jan-2017.) */

theorem raleqbidva (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ) ;;
}

proof of raleqbidva {
	step 1 : wff = ralbidva (hyp 2) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ A ch ) ) ;;
	step 2 : wff = raleqdv (hyp 1) |- ( ph → ( ∀ x ∈ A ch ↔ ∀ x ∈ B ch ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ x ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality deduction for restricted universal quantifier.  (Contributed by
       Mario Carneiro, 5-Jan-2017.) */

theorem rexeqbidva (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ) ;;
}

proof of rexeqbidva {
	step 1 : wff = rexbidva (hyp 2) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ A ch ) ) ;;
	step 2 : wff = rexeqdv (hyp 1) |- ( ph → ( ∃ x ∈ A ch ↔ ∃ x ∈ B ch ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ x ∈ B ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Unrestricted "at most one" implies restricted "at most one".  (Contributed
     by NM, 16-Jun-2017.) */

theorem mormo (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃* x ph → ∃* x ∈ A ph ) ;;
}

proof of mormo {
	step 1 : wff = moan () |- ( ∃* x ph → ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ∃* x ph → ∃* x ∈ A ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Restricted uniqueness in terms of "at most one."  (Contributed by NM,
     23-May-1999.)  (Revised by NM, 16-Jun-2017.) */

theorem reu5 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ) ;;
}

proof of reu5 {
	step 1 : wff = eu5 () |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃* x ( x ∈ A ∧ ph ) ) ) ;;
	step 2 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 5 : wff = anbi12i (step 3, step 4) |- ( ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃* x ( x ∈ A ∧ ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 1, step 2, step 5) |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Restricted unique existence implies restricted existence.  (Contributed by
     NM, 19-Aug-1999.) */

theorem reurex (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃! x ∈ A ph → ∃ x ∈ A ph ) ;;
}

proof of reurex {
	step 1 : wff = reu5 () |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ) ;;
	step 2 : wff = simplbi (step 1) |- ( ∃! x ∈ A ph → ∃ x ∈ A ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Restricted existential uniqueness implies restricted "at most one."
     (Contributed by NM, 16-Jun-2017.) */

theorem reurmo (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃! x ∈ A ph → ∃* x ∈ A ph ) ;;
}

proof of reurmo {
	step 1 : wff = reu5 () |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( ∃! x ∈ A ph → ∃* x ∈ A ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Restricted "at most one" in term of uniqueness.  (Contributed by NM,
     16-Jun-2017.) */

theorem rmo5 (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃* x ∈ A ph ↔ ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ) ;;
}

proof of rmo5 {
	step 1 : wff = df-mo () |- ( ∃* x ( x ∈ A ∧ ph ) ↔ ( ∃ x ( x ∈ A ∧ ph ) → ∃! x ( x ∈ A ∧ ph ) ) ) ;;
	step 2 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 5 : wff = imbi12i (step 3, step 4) |- ( ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ↔ ( ∃ x ( x ∈ A ∧ ph ) → ∃! x ( x ∈ A ∧ ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 1, step 2, step 5) |- ( ∃* x ∈ A ph ↔ ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Nonexistence implies restricted "at most one".  (Contributed by NM,
     17-Jun-2017.) */

theorem nrexrmo (ph : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ¬ ∃ x ∈ A ph → ∃* x ∈ A ph ) ;;
}

proof of nrexrmo {
	step 1 : wff = pm2.21 () |- ( ¬ ∃ x ∈ A ph → ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ) ;;
	step 2 : wff = rmo5 () |- ( ∃* x ∈ A ph ↔ ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ¬ ∃ x ∈ A ph → ∃* x ∈ A ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 7-Mar-2004.)  (Revised by Mario Carneiro,
       9-Oct-2016.) */

theorem cbvralf (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x z, y z, z A, z ps, z ph) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/ y ph ;;
	hyp 4 : wff = |- F/ x ps ;;
	hyp 5 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A ps ) ;;
}

proof of cbvralf {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ( x ∈ A → ph ) ;;
	step 2 : wff = nfcri (hyp 1) |- F/ x z ∈ A ;;
	step 3 : wff = nfs1v () |- F/ x [ z / x ] ph ;;
	step 4 : wff = nfim (step 2, step 3) |- F/ x ( z ∈ A → [ z / x ] ph ) ;;
	step 5 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 6 : wff = sbequ12 () |- ( x = z → ( ph ↔ [ z / x ] ph ) ) ;;
	step 7 : wff = imbi12d (step 5, step 6) |- ( x = z → ( ( x ∈ A → ph ) ↔ ( z ∈ A → [ z / x ] ph ) ) ) ;;
	step 8 : wff = cbval (step 1, step 4, step 7) |- ( ∀ x ( x ∈ A → ph ) ↔ ∀ z ( z ∈ A → [ z / x ] ph ) ) ;;
	step 9 : wff = nfcri (hyp 2) |- F/ y z ∈ A ;;
	step 10 : wff = nfsb (hyp 3) |- F/ y [ z / x ] ph ;;
	step 11 : wff = nfim (step 9, step 10) |- F/ y ( z ∈ A → [ z / x ] ph ) ;;
	step 12 : wff = nfv () |- F/ z ( y ∈ A → ps ) ;;
	step 13 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 14 : wff = sbequ () |- ( z = y → ( [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 15 : wff = sbie (hyp 4, hyp 5) |- ( [ y / x ] ph ↔ ps ) ;;
	step 16 : wff = syl6bb (step 14, step 15) |- ( z = y → ( [ z / x ] ph ↔ ps ) ) ;;
	step 17 : wff = imbi12d (step 13, step 16) |- ( z = y → ( ( z ∈ A → [ z / x ] ph ) ↔ ( y ∈ A → ps ) ) ) ;;
	step 18 : wff = cbval (step 11, step 12, step 17) |- ( ∀ z ( z ∈ A → [ z / x ] ph ) ↔ ∀ y ( y ∈ A → ps ) ) ;;
	step 19 : wff = bitri (step 8, step 18) |- ( ∀ x ( x ∈ A → ph ) ↔ ∀ y ( y ∈ A → ps ) ) ;;
	step 20 : wff = df-ral () |- ( ∀ x ∈ A ph ↔ ∀ x ( x ∈ A → ph ) ) ;;
	step 21 : wff = df-ral () |- ( ∀ y ∈ A ps ↔ ∀ y ( y ∈ A → ps ) ) ;;
	step 22 : wff = 3bitr4i (step 19, step 20, step 21) |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A ps ) ;;
	qed prop 1 = step 22 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by FL, 27-Apr-2008.)  (Revised by Mario Carneiro,
       9-Oct-2016.) */

theorem cbvrexf (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x, y, A, ps, ph) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/ y ph ;;
	hyp 4 : wff = |- F/ x ps ;;
	hyp 5 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
}

proof of cbvrexf {
	step 1 : wff = nfn (hyp 3) |- F/ y ¬ ph ;;
	step 2 : wff = nfn (hyp 4) |- F/ x ¬ ps ;;
	step 3 : wff = notbid (hyp 5) |- ( x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 4 : wff = cbvralf (hyp 1, hyp 2, step 1, step 2, step 3) |- ( ∀ x ∈ A ¬ ph ↔ ∀ y ∈ A ¬ ps ) ;;
	step 5 : wff = notbii (step 4) |- ( ¬ ∀ x ∈ A ¬ ph ↔ ¬ ∀ y ∈ A ¬ ps ) ;;
	step 6 : wff = dfrex2 () |- ( ∃ x ∈ A ph ↔ ¬ ∀ x ∈ A ¬ ph ) ;;
	step 7 : wff = dfrex2 () |- ( ∃ y ∈ A ps ↔ ¬ ∀ y ∈ A ¬ ps ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
	qed prop 1 = step 8 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 31-Jul-2003.) */

theorem cbvral (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, ph, ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A ps ) ;;
}

proof of cbvral {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = cbvralf (step 1, step 2, hyp 1, hyp 2, hyp 3) |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 31-Jul-2003.)  (Proof shortened by Andrew Salmon,
       8-Jun-2011.) */

theorem cbvrex (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, ph, ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
}

proof of cbvrex {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = cbvrexf (step 1, step 2, hyp 1, hyp 2, hyp 3) |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Change the bound variable of a restricted uniqueness quantifier using
       implicit substitution.  (Contributed by Mario Carneiro, 15-Oct-2016.) */

theorem cbvreu (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x z A, y z A, z ph, z ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ∃! y ∈ A ps ) ;;
}

proof of cbvreu {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ( x ∈ A ∧ ph ) ;;
	step 2 : wff = sb8eu (step 1) |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ∃! z [ z / x ] ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = sban () |- ( [ z / x ] ( x ∈ A ∧ ph ) ↔ ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ) ;;
	step 4 : wff = eubii (step 3) |- ( ∃! z [ z / x ] ( x ∈ A ∧ ph ) ↔ ∃! z ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ) ;;
	step 5 : wff = clelsb3 () |- ( [ z / x ] x ∈ A ↔ z ∈ A ) ;;
	step 6 : wff = anbi1i (step 5) |- ( ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ↔ ( z ∈ A ∧ [ z / x ] ph ) ) ;;
	step 7 : wff = eubii (step 6) |- ( ∃! z ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ↔ ∃! z ( z ∈ A ∧ [ z / x ] ph ) ) ;;
	step 8 : wff = nfv () |- F/ y z ∈ A ;;
	step 9 : wff = nfsb (hyp 1) |- F/ y [ z / x ] ph ;;
	step 10 : wff = nfan (step 8, step 9) |- F/ y ( z ∈ A ∧ [ z / x ] ph ) ;;
	step 11 : wff = nfv () |- F/ z ( y ∈ A ∧ ps ) ;;
	step 12 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 13 : wff = sbequ () |- ( z = y → ( [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 14 : wff = sbie (hyp 2, hyp 3) |- ( [ y / x ] ph ↔ ps ) ;;
	step 15 : wff = syl6bb (step 13, step 14) |- ( z = y → ( [ z / x ] ph ↔ ps ) ) ;;
	step 16 : wff = anbi12d (step 12, step 15) |- ( z = y → ( ( z ∈ A ∧ [ z / x ] ph ) ↔ ( y ∈ A ∧ ps ) ) ) ;;
	step 17 : wff = cbveu (step 10, step 11, step 16) |- ( ∃! z ( z ∈ A ∧ [ z / x ] ph ) ↔ ∃! y ( y ∈ A ∧ ps ) ) ;;
	step 18 : wff = bitri (step 7, step 17) |- ( ∃! z ( [ z / x ] x ∈ A ∧ [ z / x ] ph ) ↔ ∃! y ( y ∈ A ∧ ps ) ) ;;
	step 19 : wff = 3bitri (step 2, step 4, step 18) |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ∃! y ( y ∈ A ∧ ps ) ) ;;
	step 20 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 21 : wff = df-reu () |- ( ∃! y ∈ A ps ↔ ∃! y ( y ∈ A ∧ ps ) ) ;;
	step 22 : wff = 3bitr4i (step 19, step 20, step 21) |- ( ∃! x ∈ A ph ↔ ∃! y ∈ A ps ) ;;
	qed prop 1 = step 22 ;;
}

/*Change the bound variable of restricted "at most one" using implicit
       substitution.  (Contributed by NM, 16-Jun-2017.) */

theorem cbvrmo (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, ph, ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ A ph ↔ ∃* y ∈ A ps ) ;;
}

proof of cbvrmo {
	step 1 : wff = cbvrex (hyp 1, hyp 2, hyp 3) |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
	step 2 : wff = cbvreu (hyp 1, hyp 2, hyp 3) |- ( ∃! x ∈ A ph ↔ ∃! y ∈ A ps ) ;;
	step 3 : wff = imbi12i (step 1, step 2) |- ( ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ↔ ( ∃ y ∈ A ps → ∃! y ∈ A ps ) ) ;;
	step 4 : wff = rmo5 () |- ( ∃* x ∈ A ph ↔ ( ∃ x ∈ A ph → ∃! x ∈ A ph ) ) ;;
	step 5 : wff = rmo5 () |- ( ∃* y ∈ A ps ↔ ( ∃ y ∈ A ps → ∃! y ∈ A ps ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( ∃* x ∈ A ph ↔ ∃* y ∈ A ps ) ;;
	qed prop 1 = step 6 ;;
}

/*Change the bound variable of a restricted universal quantifier using
       implicit substitution.  (Contributed by NM, 28-Jan-1997.) */

theorem cbvralv (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A ps ) ;;
}

proof of cbvralv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbvral (step 1, step 2, hyp 1) |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Change the bound variable of a restricted existential quantifier using
       implicit substitution.  (Contributed by NM, 2-Jun-1998.) */

theorem cbvrexv (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
}

proof of cbvrexv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbvrex (step 1, step 2, hyp 1) |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Change the bound variable of a restricted uniqueness quantifier using
       implicit substitution.  (Contributed by NM, 5-Apr-2004.)  (Revised by
       Mario Carneiro, 15-Oct-2016.) */

theorem cbvreuv (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ∃! y ∈ A ps ) ;;
}

proof of cbvreuv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbvreu (step 1, step 2, hyp 1) |- ( ∃! x ∈ A ph ↔ ∃! y ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Change the bound variable of a restricted uniqueness quantifier using
       implicit substitution.  (Contributed by Alexander van der Vekens,
       17-Jun-2017.) */

theorem cbvrmov (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x A, y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ A ph ↔ ∃* y ∈ A ps ) ;;
}

proof of cbvrmov {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbvrmo (step 1, step 2, hyp 1) |- ( ∃* x ∈ A ph ↔ ∃* y ∈ A ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Rule used to change the bound variable in a restricted universal
       quantifier with implicit substitution which also changes the quantifier
       domain.  Deduction form.  (Contributed by David Moews, 1-May-2017.) */

theorem cbvraldva2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(A y, ps y, B x, ch x, x ph y) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = y ) → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ y ∈ B ch ) ) ;;
}

proof of cbvraldva2 {
	step 1 : wff = simpr () |- ( ( ph ∧ x = y ) → x = y ) ;;
	step 2 : wff = eleq12d (step 1, hyp 2) |- ( ( ph ∧ x = y ) → ( x ∈ A ↔ y ∈ B ) ) ;;
	step 3 : wff = imbi12d (step 2, hyp 1) |- ( ( ph ∧ x = y ) → ( ( x ∈ A → ps ) ↔ ( y ∈ B → ch ) ) ) ;;
	step 4 : wff = cbvaldva (step 3) |- ( ph → ( ∀ x ( x ∈ A → ps ) ↔ ∀ y ( y ∈ B → ch ) ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ x ∈ A ps ↔ ∀ x ( x ∈ A → ps ) ) ;;
	step 6 : wff = df-ral () |- ( ∀ y ∈ B ch ↔ ∀ y ( y ∈ B → ch ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ y ∈ B ch ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Rule used to change the bound variable in a restricted existential
       quantifier with implicit substitution which also changes the quantifier
       domain.  Deduction form.  (Contributed by David Moews, 1-May-2017.) */

theorem cbvrexdva2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(A y, ps y, B x, ch x, x ph y) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = y ) → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ y ∈ B ch ) ) ;;
}

proof of cbvrexdva2 {
	step 1 : wff = simpr () |- ( ( ph ∧ x = y ) → x = y ) ;;
	step 2 : wff = eleq12d (step 1, hyp 2) |- ( ( ph ∧ x = y ) → ( x ∈ A ↔ y ∈ B ) ) ;;
	step 3 : wff = anbi12d (step 2, hyp 1) |- ( ( ph ∧ x = y ) → ( ( x ∈ A ∧ ps ) ↔ ( y ∈ B ∧ ch ) ) ) ;;
	step 4 : wff = cbvexdva (step 3) |- ( ph → ( ∃ x ( x ∈ A ∧ ps ) ↔ ∃ y ( y ∈ B ∧ ch ) ) ) ;;
	step 5 : wff = df-rex () |- ( ∃ x ∈ A ps ↔ ∃ x ( x ∈ A ∧ ps ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ y ∈ B ch ↔ ∃ y ( y ∈ B ∧ ch ) ) ;;
	step 7 : wff = 3bitr4g (step 4, step 5, step 6) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ y ∈ B ch ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Rule used to change the bound variable in a restricted universal
       quantifier with implicit substitution.  Deduction form.  (Contributed by
       David Moews, 1-May-2017.) */

theorem cbvraldva (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(ps y, ch x, A x y, x ph y) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ A ps ↔ ∀ y ∈ A ch ) ) ;;
}

proof of cbvraldva {
	step 1 : wff = eqidd () |- ( ( ph ∧ x = y ) → A = A ) ;;
	step 2 : wff = cbvraldva2 (hyp 1, step 1) |- ( ph → ( ∀ x ∈ A ps ↔ ∀ y ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Rule used to change the bound variable in a restricted existential
       quantifier with implicit substitution.  Deduction form.  (Contributed by
       David Moews, 1-May-2017.) */

theorem cbvrexdva (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(ps y, ch x, A x y, x ph y) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ∈ A ps ↔ ∃ y ∈ A ch ) ) ;;
}

proof of cbvrexdva {
	step 1 : wff = eqidd () |- ( ( ph ∧ x = y ) → A = A ) ;;
	step 2 : wff = cbvrexdva2 (hyp 1, step 1) |- ( ph → ( ∃ x ∈ A ps ↔ ∃ y ∈ A ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Change bound variables of double restricted universal quantification,
       using implicit substitution.  (Contributed by NM, 10-Aug-2004.) */

theorem cbvral2v (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set, w : set, A : class, B : class) disjointed(x A, z A, x y B, z y B, w B, z ph, y ps, x ch, w ch) {
	hyp 1 : wff = |- ( x = z → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = w → ( ch ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ z ∈ A ∀ w ∈ B ps ) ;;
}

proof of cbvral2v {
	step 1 : wff = ralbidv (hyp 1) |- ( x = z → ( ∀ y ∈ B ph ↔ ∀ y ∈ B ch ) ) ;;
	step 2 : wff = cbvralv (step 1) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ z ∈ A ∀ y ∈ B ch ) ;;
	step 3 : wff = cbvralv (hyp 2) |- ( ∀ y ∈ B ch ↔ ∀ w ∈ B ps ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ z ∈ A ∀ y ∈ B ch ↔ ∀ z ∈ A ∀ w ∈ B ps ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∀ x ∈ A ∀ y ∈ B ph ↔ ∀ z ∈ A ∀ w ∈ B ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Change bound variables of double restricted universal quantification,
       using implicit substitution.  (Contributed by FL, 2-Jul-2012.) */

theorem cbvrex2v (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set, w : set, A : class, B : class) disjointed(A x, A z, B w, B x y, B z y, ch w, ch x, ph z, ps y) {
	hyp 1 : wff = |- ( x = z → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = w → ( ch ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ z ∈ A ∃ w ∈ B ps ) ;;
}

proof of cbvrex2v {
	step 1 : wff = rexbidv (hyp 1) |- ( x = z → ( ∃ y ∈ B ph ↔ ∃ y ∈ B ch ) ) ;;
	step 2 : wff = cbvrexv (step 1) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ z ∈ A ∃ y ∈ B ch ) ;;
	step 3 : wff = cbvrexv (hyp 2) |- ( ∃ y ∈ B ch ↔ ∃ w ∈ B ps ) ;;
	step 4 : wff = rexbii (step 3) |- ( ∃ z ∈ A ∃ y ∈ B ch ↔ ∃ z ∈ A ∃ w ∈ B ps ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ z ∈ A ∃ w ∈ B ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Change bound variables of triple restricted universal quantification,
       using implicit substitution.  (Contributed by NM, 10-May-2005.) */

theorem cbvral3v (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, w : set, v : set, u : set, A : class, B : class, C : class) disjointed(w ph, z ps, x ch, v ch, y u th, x A, w A, x y B, w y B, v B, x y z C, w y z C, v z C, z y C, z C, u C) {
	hyp 1 : wff = |- ( x = w → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = v → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( z = u → ( th ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ w ∈ A ∀ v ∈ B ∀ u ∈ C ps ) ;;
}

proof of cbvral3v {
	step 1 : wff = 2ralbidv (hyp 1) |- ( x = w → ( ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ y ∈ B ∀ z ∈ C ch ) ) ;;
	step 2 : wff = cbvralv (step 1) |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ w ∈ A ∀ y ∈ B ∀ z ∈ C ch ) ;;
	step 3 : wff = cbvral2v (hyp 2, hyp 3) |- ( ∀ y ∈ B ∀ z ∈ C ch ↔ ∀ v ∈ B ∀ u ∈ C ps ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ w ∈ A ∀ y ∈ B ∀ z ∈ C ch ↔ ∀ w ∈ A ∀ v ∈ B ∀ u ∈ C ps ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∀ x ∈ A ∀ y ∈ B ∀ z ∈ C ph ↔ ∀ w ∈ A ∀ v ∈ B ∀ u ∈ C ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Change bound variable by using a substitution.  (Contributed by NM,
       20-Nov-2005.)  (Revised by Andrew Salmon, 11-Jul-2011.) */

theorem cbvralsv (ph : wff, x : set, y : set, A : class) disjointed(z x A, y A, z y ph) {
	prop 1 : wff = |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A [ y / x ] ph ) ;;
}

proof of cbvralsv {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ph ;;
	step 2 : wff = nfs1v () |- F/ x [ z / x ] ph ;;
	step 3 : wff = sbequ12 () |- ( x = z → ( ph ↔ [ z / x ] ph ) ) ;;
	step 4 : wff = cbvral (step 1, step 2, step 3) |- ( ∀ x ∈ A ph ↔ ∀ z ∈ A [ z / x ] ph ) ;;
	step 5 : wff = nfv () |- F/ y ph ;;
	step 6 : wff = nfsb (step 5) |- F/ y [ z / x ] ph ;;
	step 7 : wff = nfv () |- F/ z [ y / x ] ph ;;
	step 8 : wff = sbequ () |- ( z = y → ( [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 9 : wff = cbvral (step 6, step 7, step 8) |- ( ∀ z ∈ A [ z / x ] ph ↔ ∀ y ∈ A [ y / x ] ph ) ;;
	step 10 : wff = bitri (step 4, step 9) |- ( ∀ x ∈ A ph ↔ ∀ y ∈ A [ y / x ] ph ) ;;
	qed prop 1 = step 10 ;;
}

/*Change bound variable by using a substitution.  (Contributed by NM,
       2-Mar-2008.)  (Revised by Andrew Salmon, 11-Jul-2011.) */

theorem cbvrexsv (ph : wff, x : set, y : set, A : class) disjointed(z x A, y z ph, y A) {
	prop 1 : wff = |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A [ y / x ] ph ) ;;
}

proof of cbvrexsv {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ph ;;
	step 2 : wff = nfs1v () |- F/ x [ z / x ] ph ;;
	step 3 : wff = sbequ12 () |- ( x = z → ( ph ↔ [ z / x ] ph ) ) ;;
	step 4 : wff = cbvrex (step 1, step 2, step 3) |- ( ∃ x ∈ A ph ↔ ∃ z ∈ A [ z / x ] ph ) ;;
	step 5 : wff = nfv () |- F/ y ph ;;
	step 6 : wff = nfsb (step 5) |- F/ y [ z / x ] ph ;;
	step 7 : wff = nfv () |- F/ z [ y / x ] ph ;;
	step 8 : wff = sbequ () |- ( z = y → ( [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 9 : wff = cbvrex (step 6, step 7, step 8) |- ( ∃ z ∈ A [ z / x ] ph ↔ ∃ y ∈ A [ y / x ] ph ) ;;
	step 10 : wff = bitri (step 4, step 9) |- ( ∃ x ∈ A ph ↔ ∃ y ∈ A [ y / x ] ph ) ;;
	qed prop 1 = step 10 ;;
}

/*Implicit to explicit substitution that swaps variables in a quantified
       expression.  (Contributed by NM, 5-Sep-2004.) */

theorem sbralie (ph : wff, ps : wff, x : set, y : set) disjointed(x y z, y z ph, x z ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( [ x / y ] ∀ x ∈ y ph ↔ ∀ y ∈ x ps ) ;;
}

proof of sbralie {
	var z : set;;
	step 1 : wff = cbvralsv () |- ( ∀ x ∈ y ph ↔ ∀ z ∈ y [ z / x ] ph ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ x / y ] ∀ x ∈ y ph ↔ [ x / y ] ∀ z ∈ y [ z / x ] ph ) ;;
	step 3 : wff = nfv () |- F/ y ∀ z ∈ x [ z / x ] ph ;;
	step 4 : wff = raleq () |- ( y = x → ( ∀ z ∈ y [ z / x ] ph ↔ ∀ z ∈ x [ z / x ] ph ) ) ;;
	step 5 : wff = sbie (step 3, step 4) |- ( [ x / y ] ∀ z ∈ y [ z / x ] ph ↔ ∀ z ∈ x [ z / x ] ph ) ;;
	step 6 : wff = bitri (step 2, step 5) |- ( [ x / y ] ∀ x ∈ y ph ↔ ∀ z ∈ x [ z / x ] ph ) ;;
	step 7 : wff = cbvralsv () |- ( ∀ z ∈ x [ z / x ] ph ↔ ∀ y ∈ x [ y / z ] [ z / x ] ph ) ;;
	step 8 : wff = nfv () |- F/ z ph ;;
	step 9 : wff = sbco2 (step 8) |- ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ;;
	step 10 : wff = nfv () |- F/ x ps ;;
	step 11 : wff = sbie (step 10, hyp 1) |- ( [ y / x ] ph ↔ ps ) ;;
	step 12 : wff = bitri (step 9, step 11) |- ( [ y / z ] [ z / x ] ph ↔ ps ) ;;
	step 13 : wff = ralbii (step 12) |- ( ∀ y ∈ x [ y / z ] [ z / x ] ph ↔ ∀ y ∈ x ps ) ;;
	step 14 : wff = bitri (step 7, step 13) |- ( ∀ z ∈ x [ z / x ] ph ↔ ∀ y ∈ x ps ) ;;
	step 15 : wff = bitri (step 6, step 14) |- ( [ x / y ] ∀ x ∈ y ph ↔ ∀ y ∈ x ps ) ;;
	qed prop 1 = step 15 ;;
}

/*Equivalent wff's yield equal restricted class abstractions (inference
       rule).  (Contributed by NM, 22-May-1999.) */

theorem rabbiia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { x ∈ A | ph } = { x ∈ A | ps } ;;
}

proof of rabbiia {
	step 1 : wff = pm5.32i (hyp 1) |- ( ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ps ) ) ;;
	step 2 : wff = abbii (step 1) |- { x | ( x ∈ A ∧ ph ) } = { x | ( x ∈ A ∧ ps ) } ;;
	step 3 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 4 : wff = df-rab () |- { x ∈ A | ps } = { x | ( x ∈ A ∧ ps ) } ;;
	step 5 : wff = 3eqtr4i (step 2, step 3, step 4) |- { x ∈ A | ph } = { x ∈ A | ps } ;;
	qed prop 1 = step 5 ;;
}

/*Equivalent wff's yield equal restricted class abstractions (deduction
       rule).  (Contributed by NM, 28-Nov-2003.) */

theorem rabbidva (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x ∈ A | ps } = { x ∈ A | ch } ) ;;
}

proof of rabbidva {
	step 1 : wff = ralrimiva (hyp 1) |- ( ph → ∀ x ∈ A ( ps ↔ ch ) ) ;;
	step 2 : wff = rabbi () |- ( ∀ x ∈ A ( ps ↔ ch ) ↔ { x ∈ A | ps } = { x ∈ A | ch } ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ph → { x ∈ A | ps } = { x ∈ A | ch } ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalent wff's yield equal restricted class abstractions (deduction
       rule).  (Contributed by NM, 10-Feb-1995.) */

theorem rabbidv (ph : wff, ps : wff, ch : wff, x : set, A : class) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x ∈ A | ps } = { x ∈ A | ch } ) ;;
}

proof of rabbidv {
	step 1 : wff = adantr (hyp 1) |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	step 2 : wff = rabbidva (step 1) |- ( ph → { x ∈ A | ps } = { x ∈ A | ch } ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality theorem for restricted class abstractions, with bound-variable
       hypotheses instead of distinct variable restrictions.  (Contributed by
       NM, 7-Mar-2004.) */

theorem rabeqf (ph : wff, x : set, A : class, B : class) disjointed(A, B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( A = B → { x ∈ A | ph } = { x ∈ B | ph } ) ;;
}

proof of rabeqf {
	step 1 : wff = nfeq (hyp 1, hyp 2) |- F/ x A = B ;;
	step 2 : wff = eleq2 () |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = anbi1d (step 2) |- ( A = B → ( ( x ∈ A ∧ ph ) ↔ ( x ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = abbid (step 1, step 3) |- ( A = B → { x | ( x ∈ A ∧ ph ) } = { x | ( x ∈ B ∧ ph ) } ) ;;
	step 5 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 6 : wff = df-rab () |- { x ∈ B | ph } = { x | ( x ∈ B ∧ ph ) } ;;
	step 7 : wff = 3eqtr4g (step 4, step 5, step 6) |- ( A = B → { x ∈ A | ph } = { x ∈ B | ph } ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality theorem for restricted class abstractions.  (Contributed by NM,
       15-Oct-2003.) */

theorem rabeq (ph : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A = B → { x ∈ A | ph } = { x ∈ B | ph } ) ;;
}

proof of rabeq {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = rabeqf (step 1, step 2) |- ( A = B → { x ∈ A | ph } = { x ∈ B | ph } ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality of restricted class abstractions.  (Contributed by Jeff Madsen,
       1-Dec-2009.) */

theorem rabeqbidv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(A x, B x, ph x) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x ∈ A | ps } = { x ∈ B | ch } ) ;;
}

proof of rabeqbidv {
	step 1 : wff = rabeq () |- ( A = B → { x ∈ A | ps } = { x ∈ B | ps } ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → { x ∈ A | ps } = { x ∈ B | ps } ) ;;
	step 3 : wff = rabbidv (hyp 2) |- ( ph → { x ∈ B | ps } = { x ∈ B | ch } ) ;;
	step 4 : wff = eqtrd (step 2, step 3) |- ( ph → { x ∈ A | ps } = { x ∈ B | ch } ) ;;
	qed prop 1 = step 4 ;;
}

/*Equality of restricted class abstractions.  (Contributed by Mario
       Carneiro, 26-Jan-2017.) */

theorem rabeqbidva (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(A x, B x, ph x) {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x ∈ A | ps } = { x ∈ B | ch } ) ;;
}

proof of rabeqbidva {
	step 1 : wff = rabbidva (hyp 2) |- ( ph → { x ∈ A | ps } = { x ∈ A | ch } ) ;;
	step 2 : wff = rabeq () |- ( A = B → { x ∈ A | ch } = { x ∈ B | ch } ) ;;
	step 3 : wff = syl (hyp 1, step 2) |- ( ph → { x ∈ A | ch } = { x ∈ B | ch } ) ;;
	step 4 : wff = eqtrd (step 1, step 3) |- ( ph → { x ∈ A | ps } = { x ∈ B | ch } ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference rule from equality of a class variable and a restricted class
       abstraction.  (Contributed by NM, 16-Feb-2004.) */

theorem rabeq2i (ph : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- A = { x ∈ B | ph } ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A ↔ ( x ∈ B ∧ ph ) ) ;;
}

proof of rabeq2i {
	step 1 : wff = eleq2i (hyp 1) |- ( x ∈ A ↔ x ∈ { x ∈ B | ph } ) ;;
	step 2 : wff = rabid () |- ( x ∈ { x ∈ B | ph } ↔ ( x ∈ B ∧ ph ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( x ∈ A ↔ ( x ∈ B ∧ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Rule to change the bound variable in a restricted class abstraction,
       using implicit substitution.  This version has bound-variable hypotheses
       in place of distinct variable conditions.  (Contributed by Andrew
       Salmon, 11-Jul-2011.)  (Revised by Mario Carneiro, 9-Oct-2016.) */

theorem cbvrab (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x z, y z, A z, ph z, ps z) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/ y ph ;;
	hyp 4 : wff = |- F/ x ps ;;
	hyp 5 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { x ∈ A | ph } = { y ∈ A | ps } ;;
}

proof of cbvrab {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ( x ∈ A ∧ ph ) ;;
	step 2 : wff = nfcri (hyp 1) |- F/ x z ∈ A ;;
	step 3 : wff = nfs1v () |- F/ x [ z / x ] ph ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ x ( z ∈ A ∧ [ z / x ] ph ) ;;
	step 5 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 6 : wff = sbequ12 () |- ( x = z → ( ph ↔ [ z / x ] ph ) ) ;;
	step 7 : wff = anbi12d (step 5, step 6) |- ( x = z → ( ( x ∈ A ∧ ph ) ↔ ( z ∈ A ∧ [ z / x ] ph ) ) ) ;;
	step 8 : wff = cbvab (step 1, step 4, step 7) |- { x | ( x ∈ A ∧ ph ) } = { z | ( z ∈ A ∧ [ z / x ] ph ) } ;;
	step 9 : wff = nfcri (hyp 2) |- F/ y z ∈ A ;;
	step 10 : wff = nfsb (hyp 3) |- F/ y [ z / x ] ph ;;
	step 11 : wff = nfan (step 9, step 10) |- F/ y ( z ∈ A ∧ [ z / x ] ph ) ;;
	step 12 : wff = nfv () |- F/ z ( y ∈ A ∧ ps ) ;;
	step 13 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 14 : wff = sbequ () |- ( z = y → ( [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 15 : wff = sbie (hyp 4, hyp 5) |- ( [ y / x ] ph ↔ ps ) ;;
	step 16 : wff = syl6bb (step 14, step 15) |- ( z = y → ( [ z / x ] ph ↔ ps ) ) ;;
	step 17 : wff = anbi12d (step 13, step 16) |- ( z = y → ( ( z ∈ A ∧ [ z / x ] ph ) ↔ ( y ∈ A ∧ ps ) ) ) ;;
	step 18 : wff = cbvab (step 11, step 12, step 17) |- { z | ( z ∈ A ∧ [ z / x ] ph ) } = { y | ( y ∈ A ∧ ps ) } ;;
	step 19 : wff = eqtri (step 8, step 18) |- { x | ( x ∈ A ∧ ph ) } = { y | ( y ∈ A ∧ ps ) } ;;
	step 20 : wff = df-rab () |- { x ∈ A | ph } = { x | ( x ∈ A ∧ ph ) } ;;
	step 21 : wff = df-rab () |- { y ∈ A | ps } = { y | ( y ∈ A ∧ ps ) } ;;
	step 22 : wff = 3eqtr4i (step 19, step 20, step 21) |- { x ∈ A | ph } = { y ∈ A | ps } ;;
	qed prop 1 = step 22 ;;
}

/*Rule to change the bound variable in a restricted class abstraction,
       using implicit substitution.  (Contributed by NM, 26-May-1999.) */

theorem cbvrabv (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { x ∈ A | ph } = { y ∈ A | ps } ;;
}

proof of cbvrabv {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = nfv () |- F/ y ph ;;
	step 4 : wff = nfv () |- F/ x ps ;;
	step 5 : wff = cbvrab (step 1, step 2, step 3, step 4, hyp 1) |- { x ∈ A | ph } = { y ∈ A | ps } ;;
	qed prop 1 = step 5 ;;
}


