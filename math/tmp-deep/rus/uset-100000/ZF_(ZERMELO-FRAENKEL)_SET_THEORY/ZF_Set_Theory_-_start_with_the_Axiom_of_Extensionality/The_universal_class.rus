import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Restricted_quantification.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        The universal class

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Declare the symbol for the universal class. */

constant {
	symbol _V ;;
}

/* Letter V (for the universal class) */

/* Extend class notation to include the universal class symbol. */

rule cvv () {
	term : class = # _V ;;
}

/* Soundness justification theorem for ~ df-v .  (Contributed by Rodolfo
       Medina, 27-Apr-2010.) */

theorem vjust (x : set, y : set) disjointed(z x, z y) {
	prop 1 : wff = |- { x | x = x } = { y | y = y } ;;
}

proof of vjust {
	var z : set;;
	step 1 : wff = equid () |- x = x ;;
	step 2 : wff = sbt (step 1) |- [ z / x ] x = x ;;
	step 3 : wff = equid () |- y = y ;;
	step 4 : wff = sbt (step 3) |- [ z / y ] y = y ;;
	step 5 : wff = 2th (step 2, step 4) |- ( [ z / x ] x = x ↔ [ z / y ] y = y ) ;;
	step 6 : wff = df-clab () |- ( z ∈ { x | x = x } ↔ [ z / x ] x = x ) ;;
	step 7 : wff = df-clab () |- ( z ∈ { y | y = y } ↔ [ z / y ] y = y ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( z ∈ { x | x = x } ↔ z ∈ { y | y = y } ) ;;
	step 9 : wff = eqriv (step 8) |- { x | x = x } = { y | y = y } ;;
	qed prop 1 = step 9 ;;
}

/* Define the universal class.  Definition 5.20 of [TakeutiZaring] p. 21.
     Also Definition 2.9 of [Quine] p. 19.  (Contributed by NM, 5-Aug-1993.) */

definition df-v (x : set)  {
	defiendum : class = # _V ;;
	definiens : class = # { x | x = x } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* All set variables are sets (see ~ isset ).  Theorem 6.8 of [Quine] p. 43.
     (Contributed by NM, 5-Aug-1993.) */

theorem vex (x : set)  {
	prop 1 : wff = |- x ∈ _V ;;
}

proof of vex {
	step 1 : wff = eqid () |- x = x ;;
	step 2 : wff = df-v () |- _V = { x | x = x } ;;
	step 3 : wff = abeq2i (step 2) |- ( x ∈ _V ↔ x = x ) ;;
	step 4 : wff = mpbir (step 1, step 3) |- x ∈ _V ;;
	qed prop 1 = step 4 ;;
}

/* Two ways to say " ` A ` is a set":  A class ` A ` is a member of the
       universal class ` _V ` (see ~ df-v ) if and only if the class ` A `
       exists (i.e. there exists some set ` x ` equal to class ` A ` ).
       Theorem 6.9 of [Quine] p. 43. _Notational convention_:  We will use the
       notational device " ` A e. _V ` " to mean " ` A ` is a set" very
       frequently, for example in ~ uniex .  Note the when ` A ` is not a set,
       it is called a proper class.  In some theorems, such as ~ uniexg , in
       order to shorten certain proofs we use the more general antecedent
       ` A e. V ` instead of ` A e. _V ` to mean " ` A ` is a set."

       Note that a constant is implicitly considered distinct from all
       variables.  This is why ` _V ` is not included in the distinct variable
       list, even though ~ df-clel requires that the expression substituted for
       ` B ` not contain ` x ` .  (Also, the Metamath spec does not allow
       constants in the distinct variable list.)  (Contributed by NM,
       5-Aug-1993.) */

theorem isset (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( A ∈ _V ↔ ∃ x x = A ) ;;
}

proof of isset {
	step 1 : wff = df-clel () |- ( A ∈ _V ↔ ∃ x ( x = A ∧ x ∈ _V ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = biantru (step 2) |- ( x = A ↔ ( x = A ∧ x ∈ _V ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ x x = A ↔ ∃ x ( x = A ∧ x ∈ _V ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	qed prop 1 = step 5 ;;
}

/* A version of isset that does not require x and A to be distinct.
       (Contributed by Andrew Salmon, 6-Jun-2011.)  (Revised by Mario Carneiro,
       10-Oct-2016.) */

theorem issetf (x : set, A : class) disjointed(A y, x y) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ _V ↔ ∃ x x = A ) ;;
}

proof of issetf {
	var y : set;;
	step 1 : wff = isset () |- ( A ∈ _V ↔ ∃ y y = A ) ;;
	step 2 : wff = nfeq2 (hyp 1) |- F/ x y = A ;;
	step 3 : wff = nfv () |- F/ y x = A ;;
	step 4 : wff = eqeq1 () |- ( y = x → ( y = A ↔ x = A ) ) ;;
	step 5 : wff = cbvex (step 2, step 3, step 4) |- ( ∃ y y = A ↔ ∃ x x = A ) ;;
	step 6 : wff = bitri (step 1, step 5) |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	qed prop 1 = step 6 ;;
}

/* A way to say " ` A ` is a set" (inference rule).  (Contributed by NM,
       5-Aug-1993.) */

theorem isseti (x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ∃ x x = A ;;
}

proof of isseti {
	step 1 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- ∃ x x = A ;;
	qed prop 1 = step 2 ;;
}

/* A way to say " ` A ` is a set" (inference rule).  (Contributed by NM,
       5-Aug-1993.) */

theorem issetri (x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- ∃ x x = A ;;
	-----------------------
	prop 1 : wff = |- A ∈ _V ;;
}

proof of issetri {
	step 1 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 2 : wff = mpbir (hyp 1, step 1) |- A ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/* If a class is a member of another class, it is a set.  Theorem 6.12 of
       [Quine] p. 44.  (Contributed by NM, 5-Aug-1993.)  (Proof shortened by
       Andrew Salmon, 8-Jun-2011.) */

theorem elex (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∈ B → A ∈ _V ) ;;
}

proof of elex {
	var x : set;;
	step 1 : wff = exsimpl () |- ( ∃ x ( x = A ∧ x ∈ B ) → ∃ x x = A ) ;;
	step 2 : wff = df-clel () |- ( A ∈ B ↔ ∃ x ( x = A ∧ x ∈ B ) ) ;;
	step 3 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 4 : wff = 3imtr4i (step 1, step 2, step 3) |- ( A ∈ B → A ∈ _V ) ;;
	qed prop 1 = step 4 ;;
}

/* If a class is a member of another class, it is a set.  (Contributed by
       NM, 11-Jun-1994.) */

theorem elexi (A : class, B : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	-----------------------
	prop 1 : wff = |- A ∈ _V ;;
}

proof of elexi {
	step 1 : wff = elex () |- ( A ∈ B → A ∈ _V ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- A ∈ _V ;;
	qed prop 1 = step 2 ;;
}

/* An element of a class exists.  (Contributed by NM, 1-May-1995.) */

theorem elisset (x : set, A : class, V : class) disjointed(x A) {
	prop 1 : wff = |- ( A ∈ V → ∃ x x = A ) ;;
}

proof of elisset {
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( A ∈ V → ∃ x x = A ) ;;
	qed prop 1 = step 3 ;;
}

/* If two classes each contain another class, then both contain some set.
       (Contributed by Alan Sare, 24-Oct-2011.) */

theorem elex22 (x : set, A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( ( A ∈ B ∧ A ∈ C ) → ∃ x ( x ∈ B ∧ x ∈ C ) ) ;;
}

proof of elex22 {
	step 1 : wff = eleq1a () |- ( A ∈ B → ( x = A → x ∈ B ) ) ;;
	step 2 : wff = eleq1a () |- ( A ∈ C → ( x = A → x ∈ C ) ) ;;
	step 3 : wff = anim12ii (step 1, step 2) |- ( ( A ∈ B ∧ A ∈ C ) → ( x = A → ( x ∈ B ∧ x ∈ C ) ) ) ;;
	step 4 : wff = alrimiv (step 3) |- ( ( A ∈ B ∧ A ∈ C ) → ∀ x ( x = A → ( x ∈ B ∧ x ∈ C ) ) ) ;;
	step 5 : wff = elisset () |- ( A ∈ B → ∃ x x = A ) ;;
	step 6 : wff = adantr (step 5) |- ( ( A ∈ B ∧ A ∈ C ) → ∃ x x = A ) ;;
	step 7 : wff = exim () |- ( ∀ x ( x = A → ( x ∈ B ∧ x ∈ C ) ) → ( ∃ x x = A → ∃ x ( x ∈ B ∧ x ∈ C ) ) ) ;;
	step 8 : wff = sylc (step 4, step 6, step 7) |- ( ( A ∈ B ∧ A ∈ C ) → ∃ x ( x ∈ B ∧ x ∈ C ) ) ;;
	qed prop 1 = step 8 ;;
}

/* If a class contains another class, then it contains some set.
       (Contributed by Alan Sare, 25-Sep-2011.) */

theorem elex2 (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∈ B → ∃ x x ∈ B ) ;;
}

proof of elex2 {
	step 1 : wff = eleq1a () |- ( A ∈ B → ( x = A → x ∈ B ) ) ;;
	step 2 : wff = alrimiv (step 1) |- ( A ∈ B → ∀ x ( x = A → x ∈ B ) ) ;;
	step 3 : wff = elisset () |- ( A ∈ B → ∃ x x = A ) ;;
	step 4 : wff = exim () |- ( ∀ x ( x = A → x ∈ B ) → ( ∃ x x = A → ∃ x x ∈ B ) ) ;;
	step 5 : wff = sylc (step 2, step 3, step 4) |- ( A ∈ B → ∃ x x ∈ B ) ;;
	qed prop 1 = step 5 ;;
}

/* A universal quantifier restricted to the universe is unrestricted.
     (Contributed by NM, 26-Mar-2004.) */

theorem ralv (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∀ x ∈ _V ph ↔ ∀ x ph ) ;;
}

proof of ralv {
	step 1 : wff = df-ral () |- ( ∀ x ∈ _V ph ↔ ∀ x ( x ∈ _V → ph ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = a1bi (step 2) |- ( ph ↔ ( x ∈ _V → ph ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x ph ↔ ∀ x ( x ∈ _V → ph ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( ∀ x ∈ _V ph ↔ ∀ x ph ) ;;
	qed prop 1 = step 5 ;;
}

/* An existential quantifier restricted to the universe is unrestricted.
     (Contributed by NM, 26-Mar-2004.) */

theorem rexv (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃ x ∈ _V ph ↔ ∃ x ph ) ;;
}

proof of rexv {
	step 1 : wff = df-rex () |- ( ∃ x ∈ _V ph ↔ ∃ x ( x ∈ _V ∧ ph ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = biantrur (step 2) |- ( ph ↔ ( x ∈ _V ∧ ph ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ x ph ↔ ∃ x ( x ∈ _V ∧ ph ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( ∃ x ∈ _V ph ↔ ∃ x ph ) ;;
	qed prop 1 = step 5 ;;
}

/* A uniqueness quantifier restricted to the universe is unrestricted.
     (Contributed by NM, 1-Nov-2010.) */

theorem reuv (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃! x ∈ _V ph ↔ ∃! x ph ) ;;
}

proof of reuv {
	step 1 : wff = df-reu () |- ( ∃! x ∈ _V ph ↔ ∃! x ( x ∈ _V ∧ ph ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = biantrur (step 2) |- ( ph ↔ ( x ∈ _V ∧ ph ) ) ;;
	step 4 : wff = eubii (step 3) |- ( ∃! x ph ↔ ∃! x ( x ∈ _V ∧ ph ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( ∃! x ∈ _V ph ↔ ∃! x ph ) ;;
	qed prop 1 = step 5 ;;
}

/* A uniqueness quantifier restricted to the universe is unrestricted.
     (Contributed by Alexander van der Vekens, 17-Jun-2017.) */

theorem rmov (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃* x ∈ _V ph ↔ ∃* x ph ) ;;
}

proof of rmov {
	step 1 : wff = df-rmo () |- ( ∃* x ∈ _V ph ↔ ∃* x ( x ∈ _V ∧ ph ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = biantrur (step 2) |- ( ph ↔ ( x ∈ _V ∧ ph ) ) ;;
	step 4 : wff = mobii (step 3) |- ( ∃* x ph ↔ ∃* x ( x ∈ _V ∧ ph ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( ∃* x ∈ _V ph ↔ ∃* x ph ) ;;
	qed prop 1 = step 5 ;;
}

/* A class abstraction restricted to the universe is unrestricted.
     (Contributed by NM, 27-Dec-2004.)  (Proof shortened by Andrew Salmon,
     8-Jun-2011.) */

theorem rabab (ph : wff, x : set)  {
	prop 1 : wff = |- { x ∈ _V | ph } = { x | ph } ;;
}

proof of rabab {
	step 1 : wff = df-rab () |- { x ∈ _V | ph } = { x | ( x ∈ _V ∧ ph ) } ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = biantrur (step 2) |- ( ph ↔ ( x ∈ _V ∧ ph ) ) ;;
	step 4 : wff = abbii (step 3) |- { x | ph } = { x | ( x ∈ _V ∧ ph ) } ;;
	step 5 : wff = eqtr4i (step 1, step 4) |- { x ∈ _V | ph } = { x | ph } ;;
	qed prop 1 = step 5 ;;
}

/* Commutation of restricted and unrestricted universal quantifiers.
       (Contributed by NM, 26-Mar-2004.)  (Proof shortened by Andrew Salmon,
       8-Jun-2011.) */

theorem ralcom4 (ph : wff, x : set, y : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ph ↔ ∀ y ∀ x ∈ A ph ) ;;
}

proof of ralcom4 {
	step 1 : wff = ralcom () |- ( ∀ x ∈ A ∀ y ∈ _V ph ↔ ∀ y ∈ _V ∀ x ∈ A ph ) ;;
	step 2 : wff = ralv () |- ( ∀ y ∈ _V ph ↔ ∀ y ph ) ;;
	step 3 : wff = ralbii (step 2) |- ( ∀ x ∈ A ∀ y ∈ _V ph ↔ ∀ x ∈ A ∀ y ph ) ;;
	step 4 : wff = ralv () |- ( ∀ y ∈ _V ∀ x ∈ A ph ↔ ∀ y ∀ x ∈ A ph ) ;;
	step 5 : wff = 3bitr3i (step 1, step 3, step 4) |- ( ∀ x ∈ A ∀ y ph ↔ ∀ y ∀ x ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/* Commutation of restricted and unrestricted existential quantifiers.
       (Contributed by NM, 12-Apr-2004.)  (Proof shortened by Andrew Salmon,
       8-Jun-2011.) */

theorem rexcom4 (ph : wff, x : set, y : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( ∃ x ∈ A ∃ y ph ↔ ∃ y ∃ x ∈ A ph ) ;;
}

proof of rexcom4 {
	step 1 : wff = rexcom () |- ( ∃ x ∈ A ∃ y ∈ _V ph ↔ ∃ y ∈ _V ∃ x ∈ A ph ) ;;
	step 2 : wff = rexv () |- ( ∃ y ∈ _V ph ↔ ∃ y ph ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ x ∈ A ∃ y ∈ _V ph ↔ ∃ x ∈ A ∃ y ph ) ;;
	step 4 : wff = rexv () |- ( ∃ y ∈ _V ∃ x ∈ A ph ↔ ∃ y ∃ x ∈ A ph ) ;;
	step 5 : wff = 3bitr3i (step 1, step 3, step 4) |- ( ∃ x ∈ A ∃ y ph ↔ ∃ y ∃ x ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/* Specialized existential commutation lemma.  (Contributed by Jeff Madsen,
       1-Jun-2011.) */

theorem rexcom4a (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(A x, x y, ph x) {
	prop 1 : wff = |- ( ∃ x ∃ y ∈ A ( ph ∧ ps ) ↔ ∃ y ∈ A ( ph ∧ ∃ x ps ) ) ;;
}

proof of rexcom4a {
	step 1 : wff = rexcom4 () |- ( ∃ y ∈ A ∃ x ( ph ∧ ps ) ↔ ∃ x ∃ y ∈ A ( ph ∧ ps ) ) ;;
	step 2 : wff = 19.42v () |- ( ∃ x ( ph ∧ ps ) ↔ ( ph ∧ ∃ x ps ) ) ;;
	step 3 : wff = rexbii (step 2) |- ( ∃ y ∈ A ∃ x ( ph ∧ ps ) ↔ ∃ y ∈ A ( ph ∧ ∃ x ps ) ) ;;
	step 4 : wff = bitr3i (step 1, step 3) |- ( ∃ x ∃ y ∈ A ( ph ∧ ps ) ↔ ∃ y ∈ A ( ph ∧ ∃ x ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Specialized existential commutation lemma.  (Contributed by Jeff Madsen,
       1-Jun-2011.) */

theorem rexcom4b (ph : wff, x : set, y : set, A : class, B : class) disjointed(A x, x y, ph x, B x) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ∈ A ( ph ∧ x = B ) ↔ ∃ y ∈ A ph ) ;;
}

proof of rexcom4b {
	step 1 : wff = rexcom4a () |- ( ∃ x ∃ y ∈ A ( ph ∧ x = B ) ↔ ∃ y ∈ A ( ph ∧ ∃ x x = B ) ) ;;
	step 2 : wff = isseti (hyp 1) |- ∃ x x = B ;;
	step 3 : wff = biantru (step 2) |- ( ph ↔ ( ph ∧ ∃ x x = B ) ) ;;
	step 4 : wff = rexbii (step 3) |- ( ∃ y ∈ A ph ↔ ∃ y ∈ A ( ph ∧ ∃ x x = B ) ) ;;
	step 5 : wff = bitr4i (step 1, step 4) |- ( ∃ x ∃ y ∈ A ( ph ∧ x = B ) ↔ ∃ y ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/* Closed theorem version of ~ ceqsalg .  (Contributed by NM,
       28-Feb-2013.)  (Revised by Mario Carneiro, 10-Oct-2016.) */

theorem ceqsalt (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x A) {
	prop 1 : wff = |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( x = A → ph ) ↔ ps ) ) ;;
}

proof of ceqsalt {
	step 1 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 2 : wff = 3ad2ant3 (step 1) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ∃ x x = A ) ;;
	step 3 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 4 : wff = imim3i (step 3) |- ( ( x = A → ( ph ↔ ps ) ) → ( ( x = A → ph ) → ( x = A → ps ) ) ) ;;
	step 5 : wff = al2imi (step 4) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( ∀ x ( x = A → ph ) → ∀ x ( x = A → ps ) ) ) ;;
	step 6 : wff = 3ad2ant2 (step 5) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( x = A → ph ) → ∀ x ( x = A → ps ) ) ) ;;
	step 7 : wff = 19.23t () |- ( F/ x ps → ( ∀ x ( x = A → ps ) ↔ ( ∃ x x = A → ps ) ) ) ;;
	step 8 : wff = 3ad2ant1 (step 7) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( x = A → ps ) ↔ ( ∃ x x = A → ps ) ) ) ;;
	step 9 : wff = sylibd (step 6, step 8) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( x = A → ph ) → ( ∃ x x = A → ps ) ) ) ;;
	step 10 : wff = mpid (step 2, step 9) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( x = A → ph ) → ps ) ) ;;
	step 11 : wff = bi2 () |- ( ( ph ↔ ps ) → ( ps → ph ) ) ;;
	step 12 : wff = imim2i (step 11) |- ( ( x = A → ( ph ↔ ps ) ) → ( x = A → ( ps → ph ) ) ) ;;
	step 13 : wff = com23 (step 12) |- ( ( x = A → ( ph ↔ ps ) ) → ( ps → ( x = A → ph ) ) ) ;;
	step 14 : wff = alimi (step 13) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ∀ x ( ps → ( x = A → ph ) ) ) ;;
	step 15 : wff = 3ad2ant2 (step 14) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ∀ x ( ps → ( x = A → ph ) ) ) ;;
	step 16 : wff = 19.21t () |- ( F/ x ps → ( ∀ x ( ps → ( x = A → ph ) ) ↔ ( ps → ∀ x ( x = A → ph ) ) ) ) ;;
	step 17 : wff = 3ad2ant1 (step 16) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( ps → ( x = A → ph ) ) ↔ ( ps → ∀ x ( x = A → ph ) ) ) ) ;;
	step 18 : wff = mpbid (step 15, step 17) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ps → ∀ x ( x = A → ph ) ) ) ;;
	step 19 : wff = impbid (step 10, step 18) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ V ) → ( ∀ x ( x = A → ph ) ↔ ps ) ) ;;
	qed prop 1 = step 19 ;;
}

/* Restricted quantifier version of ~ ceqsalt .  (Contributed by NM,
       28-Feb-2013.)  (Revised by Mario Carneiro, 10-Oct-2016.) */

theorem ceqsralt (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ∈ B ( x = A → ph ) ↔ ps ) ) ;;
}

proof of ceqsralt {
	step 1 : wff = df-ral () |- ( ∀ x ∈ B ( x = A → ph ) ↔ ∀ x ( x ∈ B → ( x = A → ph ) ) ) ;;
	step 2 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 3 : wff = pm5.32ri (step 2) |- ( ( x ∈ B ∧ x = A ) ↔ ( A ∈ B ∧ x = A ) ) ;;
	step 4 : wff = imbi1i (step 3) |- ( ( ( x ∈ B ∧ x = A ) → ph ) ↔ ( ( A ∈ B ∧ x = A ) → ph ) ) ;;
	step 5 : wff = impexp () |- ( ( ( x ∈ B ∧ x = A ) → ph ) ↔ ( x ∈ B → ( x = A → ph ) ) ) ;;
	step 6 : wff = impexp () |- ( ( ( A ∈ B ∧ x = A ) → ph ) ↔ ( A ∈ B → ( x = A → ph ) ) ) ;;
	step 7 : wff = 3bitr3i (step 4, step 5, step 6) |- ( ( x ∈ B → ( x = A → ph ) ) ↔ ( A ∈ B → ( x = A → ph ) ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ( x ∈ B → ( x = A → ph ) ) ↔ ∀ x ( A ∈ B → ( x = A → ph ) ) ) ;;
	step 9 : wff = a1i (step 8) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ( x ∈ B → ( x = A → ph ) ) ↔ ∀ x ( A ∈ B → ( x = A → ph ) ) ) ) ;;
	step 10 : wff = syl5bb (step 1, step 9) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ∈ B ( x = A → ph ) ↔ ∀ x ( A ∈ B → ( x = A → ph ) ) ) ) ;;
	step 11 : wff = 19.21v () |- ( ∀ x ( A ∈ B → ( x = A → ph ) ) ↔ ( A ∈ B → ∀ x ( x = A → ph ) ) ) ;;
	step 12 : wff = syl6bb (step 10, step 11) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ∈ B ( x = A → ph ) ↔ ( A ∈ B → ∀ x ( x = A → ph ) ) ) ) ;;
	step 13 : wff = biimt () |- ( A ∈ B → ( ∀ x ( x = A → ph ) ↔ ( A ∈ B → ∀ x ( x = A → ph ) ) ) ) ;;
	step 14 : wff = 3ad2ant3 (step 13) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ( x = A → ph ) ↔ ( A ∈ B → ∀ x ( x = A → ph ) ) ) ) ;;
	step 15 : wff = ceqsalt () |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ( x = A → ph ) ↔ ps ) ) ;;
	step 16 : wff = 3bitr2d (step 12, step 14, step 15) |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ∈ B ( x = A → ph ) ↔ ps ) ) ;;
	qed prop 1 = step 16 ;;
}

/* A representation of explicit substitution of a class for a variable,
       inferred from an implicit substitution hypothesis.  (Contributed by NM,
       29-Oct-2003.)  (Proof shortened by Andrew Salmon, 8-Jun-2011.) */

theorem ceqsalg (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∀ x ( x = A → ph ) ↔ ps ) ) ;;
}

proof of ceqsalg {
	step 1 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ( x = A → ph ) ;;
	step 3 : wff = biimpd (hyp 2) |- ( x = A → ( ph → ps ) ) ;;
	step 4 : wff = a2i (step 3) |- ( ( x = A → ph ) → ( x = A → ps ) ) ;;
	step 5 : wff = sps (step 4) |- ( ∀ x ( x = A → ph ) → ( x = A → ps ) ) ;;
	step 6 : wff = exlimd (step 2, hyp 1, step 5) |- ( ∀ x ( x = A → ph ) → ( ∃ x x = A → ps ) ) ;;
	step 7 : wff = syl5com (step 1, step 6) |- ( A ∈ V → ( ∀ x ( x = A → ph ) → ps ) ) ;;
	step 8 : wff = biimprcd (hyp 2) |- ( ps → ( x = A → ph ) ) ;;
	step 9 : wff = alrimi (hyp 1, step 8) |- ( ps → ∀ x ( x = A → ph ) ) ;;
	step 10 : wff = impbid1 (step 7, step 9) |- ( A ∈ V → ( ∀ x ( x = A → ph ) ↔ ps ) ) ;;
	qed prop 1 = step 10 ;;
}

/* A representation of explicit substitution of a class for a variable,
       inferred from an implicit substitution hypothesis.  (Contributed by NM,
       18-Aug-1993.) */

theorem ceqsal (ph : wff, ps : wff, x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- A ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = A → ph ) ↔ ps ) ;;
}

proof of ceqsal {
	step 1 : wff = ceqsalg (hyp 1, hyp 3) |- ( A ∈ _V → ( ∀ x ( x = A → ph ) ↔ ps ) ) ;;
	step 2 : wff = ax-mp (hyp 2, step 1) |- ( ∀ x ( x = A → ph ) ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A representation of explicit substitution of a class for a variable,
       inferred from an implicit substitution hypothesis.  (Contributed by NM,
       18-Aug-1993.) */

theorem ceqsalv (ph : wff, ps : wff, x : set, A : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = A → ph ) ↔ ps ) ;;
}

proof of ceqsalv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = ceqsal (step 1, hyp 1, hyp 2) |- ( ∀ x ( x = A → ph ) ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted quantifier version of ~ ceqsalv .  (Contributed by NM,
       21-Jun-2013.) */

theorem ceqsralv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ( ∀ x ∈ B ( x = A → ph ) ↔ ps ) ) ;;
}

proof of ceqsralv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = ax-gen (hyp 1) |- ∀ x ( x = A → ( ph ↔ ps ) ) ;;
	step 3 : wff = ceqsralt () |- ( ( F/ x ps ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ∧ A ∈ B ) → ( ∀ x ∈ B ( x = A → ph ) ↔ ps ) ) ;;
	step 4 : wff = mp3an12 (step 1, step 2, step 3) |- ( A ∈ B → ( ∀ x ∈ B ( x = A → ph ) ↔ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Implicit substitution for class with embedded variable.  (Contributed by
       NM, 17-May-1996.) */

theorem gencl (ph : wff, ps : wff, ch : wff, th : wff, x : set, A : class, B : class) disjointed(x ps) {
	hyp 1 : wff = |- ( th ↔ ∃ x ( ch ∧ A = B ) ) ;;
	hyp 2 : wff = |- ( A = B → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( ch → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( th → ps ) ;;
}

proof of gencl {
	step 1 : wff = syl5ib (hyp 3, hyp 2) |- ( A = B → ( ch → ps ) ) ;;
	step 2 : wff = impcom (step 1) |- ( ( ch ∧ A = B ) → ps ) ;;
	step 3 : wff = exlimiv (step 2) |- ( ∃ x ( ch ∧ A = B ) → ps ) ;;
	step 4 : wff = sylbi (hyp 1, step 3) |- ( th → ps ) ;;
	qed prop 1 = step 4 ;;
}

/* Implicit substitution for class with embedded variable.  (Contributed by
       NM, 17-May-1996.) */

theorem 2gencl (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class, R : class, S : class) disjointed(x y, x R, x ps, y C, y S, y ch) {
	hyp 1 : wff = |- ( C ∈ S ↔ ∃ x ∈ R A = C ) ;;
	hyp 2 : wff = |- ( D ∈ S ↔ ∃ y ∈ R B = D ) ;;
	hyp 3 : wff = |- ( A = C → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ( B = D → ( ps ↔ ch ) ) ;;
	hyp 5 : wff = |- ( ( x ∈ R ∧ y ∈ R ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( C ∈ S ∧ D ∈ S ) → ch ) ;;
}

proof of 2gencl {
	step 1 : wff = df-rex () |- ( ∃ y ∈ R B = D ↔ ∃ y ( y ∈ R ∧ B = D ) ) ;;
	step 2 : wff = bitri (hyp 2, step 1) |- ( D ∈ S ↔ ∃ y ( y ∈ R ∧ B = D ) ) ;;
	step 3 : wff = imbi2d (hyp 4) |- ( B = D → ( ( C ∈ S → ps ) ↔ ( C ∈ S → ch ) ) ) ;;
	step 4 : wff = df-rex () |- ( ∃ x ∈ R A = C ↔ ∃ x ( x ∈ R ∧ A = C ) ) ;;
	step 5 : wff = bitri (hyp 1, step 4) |- ( C ∈ S ↔ ∃ x ( x ∈ R ∧ A = C ) ) ;;
	step 6 : wff = imbi2d (hyp 3) |- ( A = C → ( ( y ∈ R → ph ) ↔ ( y ∈ R → ps ) ) ) ;;
	step 7 : wff = ex (hyp 5) |- ( x ∈ R → ( y ∈ R → ph ) ) ;;
	step 8 : wff = gencl (step 5, step 6, step 7) |- ( C ∈ S → ( y ∈ R → ps ) ) ;;
	step 9 : wff = com12 (step 8) |- ( y ∈ R → ( C ∈ S → ps ) ) ;;
	step 10 : wff = gencl (step 2, step 3, step 9) |- ( D ∈ S → ( C ∈ S → ch ) ) ;;
	step 11 : wff = impcom (step 10) |- ( ( C ∈ S ∧ D ∈ S ) → ch ) ;;
	qed prop 1 = step 11 ;;
}

/* Implicit substitution for class with embedded variable.  (Contributed by
       NM, 17-May-1996.) */

theorem 3gencl (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, S : class, F : class, G : class) disjointed(x y z, y z D, z F, x y R, y z S, x ps, y ch, z th) {
	hyp 1 : wff = |- ( D ∈ S ↔ ∃ x ∈ R A = D ) ;;
	hyp 2 : wff = |- ( F ∈ S ↔ ∃ y ∈ R B = F ) ;;
	hyp 3 : wff = |- ( G ∈ S ↔ ∃ z ∈ R C = G ) ;;
	hyp 4 : wff = |- ( A = D → ( ph ↔ ps ) ) ;;
	hyp 5 : wff = |- ( B = F → ( ps ↔ ch ) ) ;;
	hyp 6 : wff = |- ( C = G → ( ch ↔ th ) ) ;;
	hyp 7 : wff = |- ( ( x ∈ R ∧ y ∈ R ∧ z ∈ R ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( D ∈ S ∧ F ∈ S ∧ G ∈ S ) → th ) ;;
}

proof of 3gencl {
	step 1 : wff = df-rex () |- ( ∃ z ∈ R C = G ↔ ∃ z ( z ∈ R ∧ C = G ) ) ;;
	step 2 : wff = bitri (hyp 3, step 1) |- ( G ∈ S ↔ ∃ z ( z ∈ R ∧ C = G ) ) ;;
	step 3 : wff = imbi2d (hyp 6) |- ( C = G → ( ( ( D ∈ S ∧ F ∈ S ) → ch ) ↔ ( ( D ∈ S ∧ F ∈ S ) → th ) ) ) ;;
	step 4 : wff = imbi2d (hyp 4) |- ( A = D → ( ( z ∈ R → ph ) ↔ ( z ∈ R → ps ) ) ) ;;
	step 5 : wff = imbi2d (hyp 5) |- ( B = F → ( ( z ∈ R → ps ) ↔ ( z ∈ R → ch ) ) ) ;;
	step 6 : wff = 3expia (hyp 7) |- ( ( x ∈ R ∧ y ∈ R ) → ( z ∈ R → ph ) ) ;;
	step 7 : wff = 2gencl (hyp 1, hyp 2, step 4, step 5, step 6) |- ( ( D ∈ S ∧ F ∈ S ) → ( z ∈ R → ch ) ) ;;
	step 8 : wff = com12 (step 7) |- ( z ∈ R → ( ( D ∈ S ∧ F ∈ S ) → ch ) ) ;;
	step 9 : wff = gencl (step 2, step 3, step 8) |- ( G ∈ S → ( ( D ∈ S ∧ F ∈ S ) → th ) ) ;;
	step 10 : wff = com12 (step 9) |- ( ( D ∈ S ∧ F ∈ S ) → ( G ∈ S → th ) ) ;;
	step 11 : wff = 3impia (step 10) |- ( ( D ∈ S ∧ F ∈ S ∧ G ∈ S ) → th ) ;;
	qed prop 1 = step 11 ;;
}

/* Implicit substitution inference for general classes.  (Contributed by
       NM, 26-Aug-2007.) */

theorem cgsexg (ph : wff, ps : wff, ch : wff, x : set, A : class, V : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- ( x = A → ch ) ;;
	hyp 2 : wff = |- ( ch → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∃ x ( ch ∧ ph ) ↔ ps ) ) ;;
}

proof of cgsexg {
	step 1 : wff = biimpa (hyp 2) |- ( ( ch ∧ ph ) → ps ) ;;
	step 2 : wff = exlimiv (step 1) |- ( ∃ x ( ch ∧ ph ) → ps ) ;;
	step 3 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 4 : wff = eximi (hyp 1) |- ( ∃ x x = A → ∃ x ch ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( A ∈ V → ∃ x ch ) ;;
	step 6 : wff = biimprcd (hyp 2) |- ( ps → ( ch → ph ) ) ;;
	step 7 : wff = ancld (step 6) |- ( ps → ( ch → ( ch ∧ ph ) ) ) ;;
	step 8 : wff = eximdv (step 7) |- ( ps → ( ∃ x ch → ∃ x ( ch ∧ ph ) ) ) ;;
	step 9 : wff = syl5com (step 5, step 8) |- ( A ∈ V → ( ps → ∃ x ( ch ∧ ph ) ) ) ;;
	step 10 : wff = impbid2 (step 2, step 9) |- ( A ∈ V → ( ∃ x ( ch ∧ ph ) ↔ ps ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Implicit substitution inference for general classes.  (Contributed by
       NM, 26-Jul-1995.) */

theorem cgsex2g (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x y ps, x y A, x y B) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ch ) ;;
	hyp 2 : wff = |- ( ch → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( ∃ x ∃ y ( ch ∧ ph ) ↔ ps ) ) ;;
}

proof of cgsex2g {
	step 1 : wff = biimpa (hyp 2) |- ( ( ch ∧ ph ) → ps ) ;;
	step 2 : wff = exlimivv (step 1) |- ( ∃ x ∃ y ( ch ∧ ph ) → ps ) ;;
	step 3 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 4 : wff = elisset () |- ( B ∈ W → ∃ y y = B ) ;;
	step 5 : wff = anim12i (step 3, step 4) |- ( ( A ∈ V ∧ B ∈ W ) → ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 6 : wff = eeanv () |- ( ∃ x ∃ y ( x = A ∧ y = B ) ↔ ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 7 : wff = sylibr (step 5, step 6) |- ( ( A ∈ V ∧ B ∈ W ) → ∃ x ∃ y ( x = A ∧ y = B ) ) ;;
	step 8 : wff = 2eximi (hyp 1) |- ( ∃ x ∃ y ( x = A ∧ y = B ) → ∃ x ∃ y ch ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( ( A ∈ V ∧ B ∈ W ) → ∃ x ∃ y ch ) ;;
	step 10 : wff = biimprcd (hyp 2) |- ( ps → ( ch → ph ) ) ;;
	step 11 : wff = ancld (step 10) |- ( ps → ( ch → ( ch ∧ ph ) ) ) ;;
	step 12 : wff = 2eximdv (step 11) |- ( ps → ( ∃ x ∃ y ch → ∃ x ∃ y ( ch ∧ ph ) ) ) ;;
	step 13 : wff = syl5com (step 9, step 12) |- ( ( A ∈ V ∧ B ∈ W ) → ( ps → ∃ x ∃ y ( ch ∧ ph ) ) ) ;;
	step 14 : wff = impbid2 (step 2, step 13) |- ( ( A ∈ V ∧ B ∈ W ) → ( ∃ x ∃ y ( ch ∧ ph ) ↔ ps ) ) ;;
	qed prop 1 = step 14 ;;
}

/* An implicit substitution inference for 4 general classes.  (Contributed
       by NM, 5-Aug-1995.) */

theorem cgsex4g (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class, R : class, S : class) disjointed(x y z w A, x y z w B, x y z w C, x y z w D, x y z w ps) {
	hyp 1 : wff = |- ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) → ch ) ;;
	hyp 2 : wff = |- ( ch → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ ( C ∈ R ∧ D ∈ S ) ) → ( ∃ x ∃ y ∃ z ∃ w ( ch ∧ ph ) ↔ ps ) ) ;;
}

proof of cgsex4g {
	step 1 : wff = biimpa (hyp 2) |- ( ( ch ∧ ph ) → ps ) ;;
	step 2 : wff = exlimivv (step 1) |- ( ∃ z ∃ w ( ch ∧ ph ) → ps ) ;;
	step 3 : wff = exlimivv (step 2) |- ( ∃ x ∃ y ∃ z ∃ w ( ch ∧ ph ) → ps ) ;;
	step 4 : wff = elisset () |- ( A ∈ R → ∃ x x = A ) ;;
	step 5 : wff = elisset () |- ( B ∈ S → ∃ y y = B ) ;;
	step 6 : wff = anim12i (step 4, step 5) |- ( ( A ∈ R ∧ B ∈ S ) → ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 7 : wff = eeanv () |- ( ∃ x ∃ y ( x = A ∧ y = B ) ↔ ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( A ∈ R ∧ B ∈ S ) → ∃ x ∃ y ( x = A ∧ y = B ) ) ;;
	step 9 : wff = elisset () |- ( C ∈ R → ∃ z z = C ) ;;
	step 10 : wff = elisset () |- ( D ∈ S → ∃ w w = D ) ;;
	step 11 : wff = anim12i (step 9, step 10) |- ( ( C ∈ R ∧ D ∈ S ) → ( ∃ z z = C ∧ ∃ w w = D ) ) ;;
	step 12 : wff = eeanv () |- ( ∃ z ∃ w ( z = C ∧ w = D ) ↔ ( ∃ z z = C ∧ ∃ w w = D ) ) ;;
	step 13 : wff = sylibr (step 11, step 12) |- ( ( C ∈ R ∧ D ∈ S ) → ∃ z ∃ w ( z = C ∧ w = D ) ) ;;
	step 14 : wff = anim12i (step 8, step 13) |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ ( C ∈ R ∧ D ∈ S ) ) → ( ∃ x ∃ y ( x = A ∧ y = B ) ∧ ∃ z ∃ w ( z = C ∧ w = D ) ) ) ;;
	step 15 : wff = ee4anv () |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ↔ ( ∃ x ∃ y ( x = A ∧ y = B ) ∧ ∃ z ∃ w ( z = C ∧ w = D ) ) ) ;;
	step 16 : wff = sylibr (step 14, step 15) |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ ( C ∈ R ∧ D ∈ S ) ) → ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ) ;;
	step 17 : wff = 2eximi (hyp 1) |- ( ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) → ∃ z ∃ w ch ) ;;
	step 18 : wff = 2eximi (step 17) |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) → ∃ x ∃ y ∃ z ∃ w ch ) ;;
	step 19 : wff = syl (step 16, step 18) |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ ( C ∈ R ∧ D ∈ S ) ) → ∃ x ∃ y ∃ z ∃ w ch ) ;;
	step 20 : wff = biimprcd (hyp 2) |- ( ps → ( ch → ph ) ) ;;
	step 21 : wff = ancld (step 20) |- ( ps → ( ch → ( ch ∧ ph ) ) ) ;;
	step 22 : wff = 2eximdv (step 21) |- ( ps → ( ∃ z ∃ w ch → ∃ z ∃ w ( ch ∧ ph ) ) ) ;;
	step 23 : wff = 2eximdv (step 22) |- ( ps → ( ∃ x ∃ y ∃ z ∃ w ch → ∃ x ∃ y ∃ z ∃ w ( ch ∧ ph ) ) ) ;;
	step 24 : wff = syl5com (step 19, step 23) |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ ( C ∈ R ∧ D ∈ S ) ) → ( ps → ∃ x ∃ y ∃ z ∃ w ( ch ∧ ph ) ) ) ;;
	step 25 : wff = impbid2 (step 3, step 24) |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ ( C ∈ R ∧ D ∈ S ) ) → ( ∃ x ∃ y ∃ z ∃ w ( ch ∧ ph ) ↔ ps ) ) ;;
	qed prop 1 = step 25 ;;
}

/* Elimination of an existential quantifier, using implicit substitution.
       (Contributed by NM, 2-Mar-1995.)  (Revised by Mario Carneiro,
       10-Oct-2016.) */

theorem ceqsex (ph : wff, ps : wff, x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- A ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( x = A ∧ ph ) ↔ ps ) ;;
}

proof of ceqsex {
	step 1 : wff = biimpa (hyp 3) |- ( ( x = A ∧ ph ) → ps ) ;;
	step 2 : wff = exlimi (hyp 1, step 1) |- ( ∃ x ( x = A ∧ ph ) → ps ) ;;
	step 3 : wff = biimprcd (hyp 3) |- ( ps → ( x = A → ph ) ) ;;
	step 4 : wff = alrimi (hyp 1, step 3) |- ( ps → ∀ x ( x = A → ph ) ) ;;
	step 5 : wff = isseti (hyp 2) |- ∃ x x = A ;;
	step 6 : wff = exintr () |- ( ∀ x ( x = A → ph ) → ( ∃ x x = A → ∃ x ( x = A ∧ ph ) ) ) ;;
	step 7 : wff = ee10 (step 4, step 5, step 6) |- ( ps → ∃ x ( x = A ∧ ph ) ) ;;
	step 8 : wff = impbii (step 2, step 7) |- ( ∃ x ( x = A ∧ ph ) ↔ ps ) ;;
	qed prop 1 = step 8 ;;
}

/* Elimination of an existential quantifier, using implicit substitution.
       (Contributed by NM, 2-Mar-1995.) */

theorem ceqsexv (ph : wff, ps : wff, x : set, A : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( x = A ∧ ph ) ↔ ps ) ;;
}

proof of ceqsexv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = ceqsex (step 1, hyp 1, hyp 2) |- ( ∃ x ( x = A ∧ ph ) ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Elimination of two existential quantifiers, using implicit
       substitution.  (Contributed by Scott Fenton, 7-Jun-2006.) */

theorem ceqsex2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- F/ y ch ;;
	hyp 3 : wff = |- A ∈ _V ;;
	hyp 4 : wff = |- B ∈ _V ;;
	hyp 5 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 6 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ch ) ;;
}

proof of ceqsex2 {
	step 1 : wff = 3anass () |- ( ( x = A ∧ y = B ∧ ph ) ↔ ( x = A ∧ ( y = B ∧ ph ) ) ) ;;
	step 2 : wff = exbii (step 1) |- ( ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ∃ y ( x = A ∧ ( y = B ∧ ph ) ) ) ;;
	step 3 : wff = 19.42v () |- ( ∃ y ( x = A ∧ ( y = B ∧ ph ) ) ↔ ( x = A ∧ ∃ y ( y = B ∧ ph ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ( x = A ∧ ∃ y ( y = B ∧ ph ) ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ x ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ∃ x ( x = A ∧ ∃ y ( y = B ∧ ph ) ) ) ;;
	step 6 : wff = nfv () |- F/ x y = B ;;
	step 7 : wff = nfan (step 6, hyp 1) |- F/ x ( y = B ∧ ps ) ;;
	step 8 : wff = nfex (step 7) |- F/ x ∃ y ( y = B ∧ ps ) ;;
	step 9 : wff = anbi2d (hyp 5) |- ( x = A → ( ( y = B ∧ ph ) ↔ ( y = B ∧ ps ) ) ) ;;
	step 10 : wff = exbidv (step 9) |- ( x = A → ( ∃ y ( y = B ∧ ph ) ↔ ∃ y ( y = B ∧ ps ) ) ) ;;
	step 11 : wff = ceqsex (step 8, hyp 3, step 10) |- ( ∃ x ( x = A ∧ ∃ y ( y = B ∧ ph ) ) ↔ ∃ y ( y = B ∧ ps ) ) ;;
	step 12 : wff = ceqsex (hyp 2, hyp 4, hyp 6) |- ( ∃ y ( y = B ∧ ps ) ↔ ch ) ;;
	step 13 : wff = 3bitri (step 5, step 11, step 12) |- ( ∃ x ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ch ) ;;
	qed prop 1 = step 13 ;;
}

/* Elimination of two existential quantifiers, using implicit
       substitution.  (Contributed by Scott Fenton, 7-Jun-2006.) */

theorem ceqsex2v (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, x ps, y ch) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ch ) ;;
}

proof of ceqsex2v {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = nfv () |- F/ y ch ;;
	step 3 : wff = ceqsex2 (step 1, step 2, hyp 1, hyp 2, hyp 3, hyp 4) |- ( ∃ x ∃ y ( x = A ∧ y = B ∧ ph ) ↔ ch ) ;;
	qed prop 1 = step 3 ;;
}

/* Elimination of three existential quantifiers, using implicit
       substitution.  (Contributed by NM, 16-Aug-2011.) */

theorem ceqsex3v (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C, x ps, y ch, z th) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 5 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 6 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ th ) ;;
}

proof of ceqsex3v {
	step 1 : wff = anass () |- ( ( ( x = A ∧ ( y = B ∧ z = C ) ) ∧ ph ) ↔ ( x = A ∧ ( ( y = B ∧ z = C ) ∧ ph ) ) ) ;;
	step 2 : wff = 3anass () |- ( ( x = A ∧ y = B ∧ z = C ) ↔ ( x = A ∧ ( y = B ∧ z = C ) ) ) ;;
	step 3 : wff = anbi1i (step 2) |- ( ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ ( ( x = A ∧ ( y = B ∧ z = C ) ) ∧ ph ) ) ;;
	step 4 : wff = df-3an () |- ( ( y = B ∧ z = C ∧ ph ) ↔ ( ( y = B ∧ z = C ) ∧ ph ) ) ;;
	step 5 : wff = anbi2i (step 4) |- ( ( x = A ∧ ( y = B ∧ z = C ∧ ph ) ) ↔ ( x = A ∧ ( ( y = B ∧ z = C ) ∧ ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 1, step 3, step 5) |- ( ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ ( x = A ∧ ( y = B ∧ z = C ∧ ph ) ) ) ;;
	step 7 : wff = 2exbii (step 6) |- ( ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ ∃ y ∃ z ( x = A ∧ ( y = B ∧ z = C ∧ ph ) ) ) ;;
	step 8 : wff = 19.42vv () |- ( ∃ y ∃ z ( x = A ∧ ( y = B ∧ z = C ∧ ph ) ) ↔ ( x = A ∧ ∃ y ∃ z ( y = B ∧ z = C ∧ ph ) ) ) ;;
	step 9 : wff = bitri (step 7, step 8) |- ( ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ ( x = A ∧ ∃ y ∃ z ( y = B ∧ z = C ∧ ph ) ) ) ;;
	step 10 : wff = exbii (step 9) |- ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ ∃ x ( x = A ∧ ∃ y ∃ z ( y = B ∧ z = C ∧ ph ) ) ) ;;
	step 11 : wff = 3anbi3d (hyp 4) |- ( x = A → ( ( y = B ∧ z = C ∧ ph ) ↔ ( y = B ∧ z = C ∧ ps ) ) ) ;;
	step 12 : wff = 2exbidv (step 11) |- ( x = A → ( ∃ y ∃ z ( y = B ∧ z = C ∧ ph ) ↔ ∃ y ∃ z ( y = B ∧ z = C ∧ ps ) ) ) ;;
	step 13 : wff = ceqsexv (hyp 1, step 12) |- ( ∃ x ( x = A ∧ ∃ y ∃ z ( y = B ∧ z = C ∧ ph ) ) ↔ ∃ y ∃ z ( y = B ∧ z = C ∧ ps ) ) ;;
	step 14 : wff = ceqsex2v (hyp 2, hyp 3, hyp 5, hyp 6) |- ( ∃ y ∃ z ( y = B ∧ z = C ∧ ps ) ↔ th ) ;;
	step 15 : wff = bitri (step 13, step 14) |- ( ∃ x ( x = A ∧ ∃ y ∃ z ( y = B ∧ z = C ∧ ph ) ) ↔ th ) ;;
	step 16 : wff = bitri (step 10, step 15) |- ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ph ) ↔ th ) ;;
	qed prop 1 = step 16 ;;
}

/* Elimination of four existential quantifiers, using implicit
       substitution.  (Contributed by NM, 23-Sep-2011.) */

theorem ceqsex4v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, x : set, y : set, z : set, w : set, A : class, B : class, C : class, D : class) disjointed(x y z w A, x y z w B, x y z w C, x y z w D, x ps, y ch, z th, w ta) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	hyp 5 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 6 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 7 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 8 : wff = |- ( w = D → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ta ) ;;
}

proof of ceqsex4v {
	step 1 : wff = 19.42vv () |- ( ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ∧ ph ) ) ↔ ( ( x = A ∧ y = B ) ∧ ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ) ) ;;
	step 2 : wff = 3anass () |- ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ( ( x = A ∧ y = B ) ∧ ( ( z = C ∧ w = D ) ∧ ph ) ) ) ;;
	step 3 : wff = df-3an () |- ( ( z = C ∧ w = D ∧ ph ) ↔ ( ( z = C ∧ w = D ) ∧ ph ) ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ∧ ph ) ) ↔ ( ( x = A ∧ y = B ) ∧ ( ( z = C ∧ w = D ) ∧ ph ) ) ) ;;
	step 5 : wff = bitr4i (step 2, step 4) |- ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ∧ ph ) ) ) ;;
	step 6 : wff = 2exbii (step 5) |- ( ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ∧ ph ) ) ) ;;
	step 7 : wff = df-3an () |- ( ( x = A ∧ y = B ∧ ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ) ↔ ( ( x = A ∧ y = B ) ∧ ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ) ) ;;
	step 8 : wff = 3bitr4i (step 1, step 6, step 7) |- ( ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ( x = A ∧ y = B ∧ ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ) ) ;;
	step 9 : wff = 2exbii (step 8) |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ∃ x ∃ y ( x = A ∧ y = B ∧ ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ) ) ;;
	step 10 : wff = 3anbi3d (hyp 5) |- ( x = A → ( ( z = C ∧ w = D ∧ ph ) ↔ ( z = C ∧ w = D ∧ ps ) ) ) ;;
	step 11 : wff = 2exbidv (step 10) |- ( x = A → ( ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ↔ ∃ z ∃ w ( z = C ∧ w = D ∧ ps ) ) ) ;;
	step 12 : wff = 3anbi3d (hyp 6) |- ( y = B → ( ( z = C ∧ w = D ∧ ps ) ↔ ( z = C ∧ w = D ∧ ch ) ) ) ;;
	step 13 : wff = 2exbidv (step 12) |- ( y = B → ( ∃ z ∃ w ( z = C ∧ w = D ∧ ps ) ↔ ∃ z ∃ w ( z = C ∧ w = D ∧ ch ) ) ) ;;
	step 14 : wff = ceqsex2v (hyp 1, hyp 2, step 11, step 13) |- ( ∃ x ∃ y ( x = A ∧ y = B ∧ ∃ z ∃ w ( z = C ∧ w = D ∧ ph ) ) ↔ ∃ z ∃ w ( z = C ∧ w = D ∧ ch ) ) ;;
	step 15 : wff = ceqsex2v (hyp 3, hyp 4, hyp 7, hyp 8) |- ( ∃ z ∃ w ( z = C ∧ w = D ∧ ch ) ↔ ta ) ;;
	step 16 : wff = 3bitri (step 9, step 14, step 15) |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ph ) ↔ ta ) ;;
	qed prop 1 = step 16 ;;
}

/* Elimination of six existential quantifiers, using implicit
       substitution.  (Contributed by NM, 21-Sep-2011.) */

theorem ceqsex6v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, x : set, y : set, z : set, w : set, v : set, u : set, A : class, B : class, C : class, D : class, E : class, F : class) disjointed(x y z w v u A, x y z w v u B, x y z w v u C, x y z w v u D, x y z w v u E, x y z w v u F, x ps, y ch, z th, w ta, v et, u ze) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	hyp 5 : wff = |- E ∈ _V ;;
	hyp 6 : wff = |- F ∈ _V ;;
	hyp 7 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 8 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 9 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 10 : wff = |- ( w = D → ( th ↔ ta ) ) ;;
	hyp 11 : wff = |- ( v = E → ( ta ↔ et ) ) ;;
	hyp 12 : wff = |- ( u = F → ( et ↔ ze ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ∃ z ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ze ) ;;
}

proof of ceqsex6v {
	step 1 : wff = 3anass () |- ( ( ( x = A ∧ y = B ∧ z = C ) ∧ ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ( ( x = A ∧ y = B ∧ z = C ) ∧ ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ) ;;
	step 2 : wff = 3exbii (step 1) |- ( ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ) ;;
	step 3 : wff = 19.42vvv () |- ( ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ↔ ( ( x = A ∧ y = B ∧ z = C ) ∧ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ( ( x = A ∧ y = B ∧ z = C ) ∧ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ) ;;
	step 5 : wff = 3exbii (step 4) |- ( ∃ x ∃ y ∃ z ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ) ;;
	step 6 : wff = anbi2d (hyp 7) |- ( x = A → ( ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ( ( w = D ∧ v = E ∧ u = F ) ∧ ps ) ) ) ;;
	step 7 : wff = 3exbidv (step 6) |- ( x = A → ( ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ps ) ) ) ;;
	step 8 : wff = anbi2d (hyp 8) |- ( y = B → ( ( ( w = D ∧ v = E ∧ u = F ) ∧ ps ) ↔ ( ( w = D ∧ v = E ∧ u = F ) ∧ ch ) ) ) ;;
	step 9 : wff = 3exbidv (step 8) |- ( y = B → ( ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ps ) ↔ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ch ) ) ) ;;
	step 10 : wff = anbi2d (hyp 9) |- ( z = C → ( ( ( w = D ∧ v = E ∧ u = F ) ∧ ch ) ↔ ( ( w = D ∧ v = E ∧ u = F ) ∧ th ) ) ) ;;
	step 11 : wff = 3exbidv (step 10) |- ( z = C → ( ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ch ) ↔ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ th ) ) ) ;;
	step 12 : wff = ceqsex3v (hyp 1, hyp 2, hyp 3, step 7, step 9, step 11) |- ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ↔ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ th ) ) ;;
	step 13 : wff = ceqsex3v (hyp 4, hyp 5, hyp 6, hyp 10, hyp 11, hyp 12) |- ( ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ th ) ↔ ze ) ;;
	step 14 : wff = bitri (step 12, step 13) |- ( ∃ x ∃ y ∃ z ( ( x = A ∧ y = B ∧ z = C ) ∧ ∃ w ∃ v ∃ u ( ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ) ↔ ze ) ;;
	step 15 : wff = bitri (step 5, step 14) |- ( ∃ x ∃ y ∃ z ∃ w ∃ v ∃ u ( ( x = A ∧ y = B ∧ z = C ) ∧ ( w = D ∧ v = E ∧ u = F ) ∧ ph ) ↔ ze ) ;;
	qed prop 1 = step 15 ;;
}

/* Elimination of eight existential quantifiers, using implicit
       substitution.  (Contributed by NM, 23-Sep-2011.) */

theorem ceqsex8v (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff, ze : wff, si : wff, rh : wff, x : set, y : set, z : set, w : set, v : set, u : set, t : set, A : class, B : class, C : class, D : class, E : class, F : class, G : class, H : class, s : set) disjointed(x y z w v u t s A, x y z w v u t s B, x y z w v u t s C, x y z w v u t s D, x y z w v u t s E, x y z w v u t s F, x y z w v u t s G, x y z w v u t s H, x ps, y ch, z th, w ta, v et, u ze, t si, s rh) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- D ∈ _V ;;
	hyp 5 : wff = |- E ∈ _V ;;
	hyp 6 : wff = |- F ∈ _V ;;
	hyp 7 : wff = |- G ∈ _V ;;
	hyp 8 : wff = |- H ∈ _V ;;
	hyp 9 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 10 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 11 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 12 : wff = |- ( w = D → ( th ↔ ta ) ) ;;
	hyp 13 : wff = |- ( v = E → ( ta ↔ et ) ) ;;
	hyp 14 : wff = |- ( u = F → ( et ↔ ze ) ) ;;
	hyp 15 : wff = |- ( t = G → ( ze ↔ si ) ) ;;
	hyp 16 : wff = |- ( s = H → ( si ↔ rh ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ∃ z ∃ w ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ rh ) ;;
}

proof of ceqsex8v {
	step 1 : wff = 19.42vv () |- ( ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 2 : wff = 2exbii (step 1) |- ( ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ∃ v ∃ u ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 3 : wff = 19.42vv () |- ( ∃ v ∃ u ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 5 : wff = 3anass () |- ( ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ) ) ;;
	step 6 : wff = df-3an () |- ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ↔ ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ) ;;
	step 7 : wff = anbi2i (step 6) |- ( ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ) ) ;;
	step 8 : wff = bitr4i (step 5, step 7) |- ( ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 9 : wff = 2exbii (step 8) |- ( ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 10 : wff = 2exbii (step 9) |- ( ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 11 : wff = df-3an () |- ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 12 : wff = 3bitr4i (step 4, step 10, step 11) |- ( ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 13 : wff = 2exbii (step 12) |- ( ∃ z ∃ w ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 14 : wff = 2exbii (step 13) |- ( ∃ x ∃ y ∃ z ∃ w ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ) ;;
	step 15 : wff = 3anbi3d (hyp 9) |- ( x = A → ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ↔ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ps ) ) ) ;;
	step 16 : wff = 4exbidv (step 15) |- ( x = A → ( ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ↔ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ps ) ) ) ;;
	step 17 : wff = 3anbi3d (hyp 10) |- ( y = B → ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ps ) ↔ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ch ) ) ) ;;
	step 18 : wff = 4exbidv (step 17) |- ( y = B → ( ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ps ) ↔ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ch ) ) ) ;;
	step 19 : wff = 3anbi3d (hyp 11) |- ( z = C → ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ch ) ↔ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ th ) ) ) ;;
	step 20 : wff = 4exbidv (step 19) |- ( z = C → ( ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ch ) ↔ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ th ) ) ) ;;
	step 21 : wff = 3anbi3d (hyp 12) |- ( w = D → ( ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ th ) ↔ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ta ) ) ) ;;
	step 22 : wff = 4exbidv (step 21) |- ( w = D → ( ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ th ) ↔ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ta ) ) ) ;;
	step 23 : wff = ceqsex4v (hyp 1, hyp 2, hyp 3, hyp 4, step 16, step 18, step 20, step 22) |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ta ) ) ;;
	step 24 : wff = ceqsex4v (hyp 5, hyp 6, hyp 7, hyp 8, hyp 13, hyp 14, hyp 15, hyp 16) |- ( ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ta ) ↔ rh ) ;;
	step 25 : wff = bitri (step 23, step 24) |- ( ∃ x ∃ y ∃ z ∃ w ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ∧ ∃ v ∃ u ∃ t ∃ s ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ∧ ph ) ) ↔ rh ) ;;
	step 26 : wff = bitri (step 14, step 25) |- ( ∃ x ∃ y ∃ z ∃ w ∃ v ∃ u ∃ t ∃ s ( ( ( x = A ∧ y = B ) ∧ ( z = C ∧ w = D ) ) ∧ ( ( v = E ∧ u = F ) ∧ ( t = G ∧ s = H ) ) ∧ ph ) ↔ rh ) ;;
	qed prop 1 = step 26 ;;
}

/* Change of bound variable using implicit substitution.  (Contributed by
       NM, 17-May-1996.)  (Proof shortened by Andrew Salmon, 8-Jun-2011.) */

theorem gencbvex (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, A : class) disjointed(x ps, y ph, x th, y ch, y A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( A = y → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( A = y → ( ch ↔ th ) ) ;;
	hyp 4 : wff = |- ( th ↔ ∃ x ( ch ∧ A = y ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( ch ∧ ph ) ↔ ∃ y ( th ∧ ps ) ) ;;
}

proof of gencbvex {
	step 1 : wff = excom () |- ( ∃ x ∃ y ( y = A ∧ ( th ∧ ps ) ) ↔ ∃ y ∃ x ( y = A ∧ ( th ∧ ps ) ) ) ;;
	step 2 : wff = anbi12d (hyp 3, hyp 2) |- ( A = y → ( ( ch ∧ ph ) ↔ ( th ∧ ps ) ) ) ;;
	step 3 : wff = bicomd (step 2) |- ( A = y → ( ( th ∧ ps ) ↔ ( ch ∧ ph ) ) ) ;;
	step 4 : wff = eqcoms (step 3) |- ( y = A → ( ( th ∧ ps ) ↔ ( ch ∧ ph ) ) ) ;;
	step 5 : wff = ceqsexv (hyp 1, step 4) |- ( ∃ y ( y = A ∧ ( th ∧ ps ) ) ↔ ( ch ∧ ph ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ x ∃ y ( y = A ∧ ( th ∧ ps ) ) ↔ ∃ x ( ch ∧ ph ) ) ;;
	step 7 : wff = 19.41v () |- ( ∃ x ( y = A ∧ ( th ∧ ps ) ) ↔ ( ∃ x y = A ∧ ( th ∧ ps ) ) ) ;;
	step 8 : wff = simpr () |- ( ( ∃ x y = A ∧ ( th ∧ ps ) ) → ( th ∧ ps ) ) ;;
	step 9 : wff = eqcom () |- ( A = y ↔ y = A ) ;;
	step 10 : wff = biimpi (step 9) |- ( A = y → y = A ) ;;
	step 11 : wff = adantl (step 10) |- ( ( ch ∧ A = y ) → y = A ) ;;
	step 12 : wff = eximi (step 11) |- ( ∃ x ( ch ∧ A = y ) → ∃ x y = A ) ;;
	step 13 : wff = sylbi (hyp 4, step 12) |- ( th → ∃ x y = A ) ;;
	step 14 : wff = adantr (step 13) |- ( ( th ∧ ps ) → ∃ x y = A ) ;;
	step 15 : wff = ancri (step 14) |- ( ( th ∧ ps ) → ( ∃ x y = A ∧ ( th ∧ ps ) ) ) ;;
	step 16 : wff = impbii (step 8, step 15) |- ( ( ∃ x y = A ∧ ( th ∧ ps ) ) ↔ ( th ∧ ps ) ) ;;
	step 17 : wff = bitri (step 7, step 16) |- ( ∃ x ( y = A ∧ ( th ∧ ps ) ) ↔ ( th ∧ ps ) ) ;;
	step 18 : wff = exbii (step 17) |- ( ∃ y ∃ x ( y = A ∧ ( th ∧ ps ) ) ↔ ∃ y ( th ∧ ps ) ) ;;
	step 19 : wff = 3bitr3i (step 1, step 6, step 18) |- ( ∃ x ( ch ∧ ph ) ↔ ∃ y ( th ∧ ps ) ) ;;
	qed prop 1 = step 19 ;;
}

/* Restatement of ~ gencbvex with weaker hypotheses.  (Contributed by
       Jeffrey Hankins, 6-Dec-2006.) */

theorem gencbvex2 (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, A : class) disjointed(x ps, y ph, x th, y ch, y A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( A = y → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( A = y → ( ch ↔ th ) ) ;;
	hyp 4 : wff = |- ( th → ∃ x ( ch ∧ A = y ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( ch ∧ ph ) ↔ ∃ y ( th ∧ ps ) ) ;;
}

proof of gencbvex2 {
	step 1 : wff = biimpac (hyp 3) |- ( ( ch ∧ A = y ) → th ) ;;
	step 2 : wff = exlimiv (step 1) |- ( ∃ x ( ch ∧ A = y ) → th ) ;;
	step 3 : wff = impbii (hyp 4, step 2) |- ( th ↔ ∃ x ( ch ∧ A = y ) ) ;;
	step 4 : wff = gencbvex (hyp 1, hyp 2, hyp 3, step 3) |- ( ∃ x ( ch ∧ ph ) ↔ ∃ y ( th ∧ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Change of bound variable using implicit substitution.  (Contributed by
       NM, 17-May-1996.) */

theorem gencbval (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, A : class) disjointed(x ps, y ph, x th, y ch, y A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( A = y → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( A = y → ( ch ↔ th ) ) ;;
	hyp 4 : wff = |- ( th ↔ ∃ x ( ch ∧ A = y ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( ch → ph ) ↔ ∀ y ( th → ps ) ) ;;
}

proof of gencbval {
	step 1 : wff = notbid (hyp 2) |- ( A = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = gencbvex (hyp 1, step 1, hyp 3, hyp 4) |- ( ∃ x ( ch ∧ ¬ ph ) ↔ ∃ y ( th ∧ ¬ ps ) ) ;;
	step 3 : wff = exanali () |- ( ∃ x ( ch ∧ ¬ ph ) ↔ ¬ ∀ x ( ch → ph ) ) ;;
	step 4 : wff = exanali () |- ( ∃ y ( th ∧ ¬ ps ) ↔ ¬ ∀ y ( th → ps ) ) ;;
	step 5 : wff = 3bitr3i (step 2, step 3, step 4) |- ( ¬ ∀ x ( ch → ph ) ↔ ¬ ∀ y ( th → ps ) ) ;;
	step 6 : wff = con4bii (step 5) |- ( ∀ x ( ch → ph ) ↔ ∀ y ( th → ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Introduce an explicit substitution into an implicit substitution
       hypothesis.  See also ~ csbhypf .  (Contributed by Raph Levien,
       10-Apr-2004.) */

theorem sbhypf (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(A x, x y) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( y = A → ( [ y / x ] ph ↔ ps ) ) ;;
}

proof of sbhypf {
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = eqeq1 () |- ( x = y → ( x = A ↔ y = A ) ) ;;
	step 3 : wff = ceqsexv (step 1, step 2) |- ( ∃ x ( x = y ∧ x = A ) ↔ y = A ) ;;
	step 4 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 5 : wff = nfbi (step 4, hyp 1) |- F/ x ( [ y / x ] ph ↔ ps ) ;;
	step 6 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 7 : wff = bicomd (step 6) |- ( x = y → ( [ y / x ] ph ↔ ph ) ) ;;
	step 8 : wff = sylan9bb (step 7, hyp 2) |- ( ( x = y ∧ x = A ) → ( [ y / x ] ph ↔ ps ) ) ;;
	step 9 : wff = exlimi (step 5, step 8) |- ( ∃ x ( x = y ∧ x = A ) → ( [ y / x ] ph ↔ ps ) ) ;;
	step 10 : wff = sylbir (step 3, step 9) |- ( y = A → ( [ y / x ] ph ↔ ps ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Closed theorem form of ~ vtoclgf .  (Contributed by NM, 17-Feb-2013.)
       (Revised by Mario Carneiro, 12-Oct-2016.) */

theorem vtoclgft (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(z A, x z) {
	prop 1 : wff = |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ V ) → ps ) ;;
}

proof of vtoclgft {
	var z : set;;
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = elisset () |- ( A ∈ _V → ∃ z z = A ) ;;
	step 3 : wff = 3ad2ant3 (step 2) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ∃ z z = A ) ;;
	step 4 : wff = nfnfc1 () |- F/ x F/_ x A ;;
	step 5 : wff = nfcvd () |- ( F/_ x A → F/_ x z ) ;;
	step 6 : wff = id () |- ( F/_ x A → F/_ x A ) ;;
	step 7 : wff = nfeqd (step 5, step 6) |- ( F/_ x A → F/ x z = A ) ;;
	step 8 : wff = eqeq1 () |- ( z = x → ( z = A ↔ x = A ) ) ;;
	step 9 : wff = a1i (step 8) |- ( F/_ x A → ( z = x → ( z = A ↔ x = A ) ) ) ;;
	step 10 : wff = cbvexd (step 4, step 7, step 9) |- ( F/_ x A → ( ∃ z z = A ↔ ∃ x x = A ) ) ;;
	step 11 : wff = ad2antrr (step 10) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ) → ( ∃ z z = A ↔ ∃ x x = A ) ) ;;
	step 12 : wff = 3adant3 (step 11) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ( ∃ z z = A ↔ ∃ x x = A ) ) ;;
	step 13 : wff = mpbid (step 3, step 12) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ∃ x x = A ) ;;
	step 14 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 15 : wff = imim2i (step 14) |- ( ( x = A → ( ph ↔ ps ) ) → ( x = A → ( ph → ps ) ) ) ;;
	step 16 : wff = com23 (step 15) |- ( ( x = A → ( ph ↔ ps ) ) → ( ph → ( x = A → ps ) ) ) ;;
	step 17 : wff = imp (step 16) |- ( ( ( x = A → ( ph ↔ ps ) ) ∧ ph ) → ( x = A → ps ) ) ;;
	step 18 : wff = alanimi (step 17) |- ( ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) → ∀ x ( x = A → ps ) ) ;;
	step 19 : wff = 3ad2ant2 (step 18) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ∀ x ( x = A → ps ) ) ;;
	step 20 : wff = simp1r () |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → F/ x ps ) ;;
	step 21 : wff = 19.23t () |- ( F/ x ps → ( ∀ x ( x = A → ps ) ↔ ( ∃ x x = A → ps ) ) ) ;;
	step 22 : wff = syl (step 20, step 21) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ( ∀ x ( x = A → ps ) ↔ ( ∃ x x = A → ps ) ) ) ;;
	step 23 : wff = mpbid (step 19, step 22) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ( ∃ x x = A → ps ) ) ;;
	step 24 : wff = mpd (step 13, step 23) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ _V ) → ps ) ;;
	step 25 : wff = syl3an3 (step 1, step 24) |- ( ( ( F/_ x A ∧ F/ x ps ) ∧ ( ∀ x ( x = A → ( ph ↔ ps ) ) ∧ ∀ x ph ) ∧ A ∈ V ) → ps ) ;;
	qed prop 1 = step 25 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
         Mario Carneiro, 15-Oct-2016.) */

theorem vtocldf (ph : wff, ps : wff, ch : wff, x : set, A : class, V : class)  {
	hyp 1 : wff = |- ( ph → A ∈ V ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( ph → ps ) ;;
	hyp 4 : wff = |- F/ x ph ;;
	hyp 5 : wff = |- ( ph → F/_ x A ) ;;
	hyp 6 : wff = |- ( ph → F/ x ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of vtocldf {
	step 1 : wff = ex (hyp 2) |- ( ph → ( x = A → ( ps ↔ ch ) ) ) ;;
	step 2 : wff = alrimi (hyp 4, step 1) |- ( ph → ∀ x ( x = A → ( ps ↔ ch ) ) ) ;;
	step 3 : wff = alrimi (hyp 4, hyp 3) |- ( ph → ∀ x ps ) ;;
	step 4 : wff = vtoclgft () |- ( ( ( F/_ x A ∧ F/ x ch ) ∧ ( ∀ x ( x = A → ( ps ↔ ch ) ) ∧ ∀ x ps ) ∧ A ∈ V ) → ch ) ;;
	step 5 : wff = syl221anc (hyp 5, hyp 6, step 2, step 3, hyp 1, step 4) |- ( ph → ch ) ;;
	qed prop 1 = step 5 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       Mario Carneiro, 15-Oct-2016.) */

theorem vtocld (ph : wff, ps : wff, ch : wff, x : set, A : class, V : class) disjointed(x A, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ V ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of vtocld {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfcvd () |- ( ph → F/_ x A ) ;;
	step 3 : wff = nfvd () |- ( ph → F/ x ch ) ;;
	step 4 : wff = vtocldf (hyp 1, hyp 2, hyp 3, step 1, step 2, step 3) |- ( ph → ch ) ;;
	qed prop 1 = step 4 ;;
}

/* Implicit substitution of a class for a set variable.  This is a
       generalization of ~ chvar .  (Contributed by NM, 30-Aug-1993.) */

theorem vtoclf (ph : wff, ps : wff, x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- A ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of vtoclf {
	step 1 : wff = isseti (hyp 2) |- ∃ x x = A ;;
	step 2 : wff = biimpd (hyp 3) |- ( x = A → ( ph → ps ) ) ;;
	step 3 : wff = eximi (step 2) |- ( ∃ x x = A → ∃ x ( ph → ps ) ) ;;
	step 4 : wff = ax-mp (step 1, step 3) |- ∃ x ( ph → ps ) ;;
	step 5 : wff = 19.36i (hyp 1, step 4) |- ( ∀ x ph → ps ) ;;
	step 6 : wff = mpg (step 5, hyp 4) |- ps ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 30-Aug-1993.) */

theorem vtocl (ph : wff, ps : wff, x : set, A : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of vtocl {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = vtoclf (step 1, hyp 1, hyp 2, hyp 3) |- ps ;;
	qed prop 1 = step 2 ;;
}

/* Implicit substitution of classes for set variables.  (Contributed by NM,
       26-Jul-1995.)  (Proof shortened by Andrew Salmon, 8-Jun-2011.) */

theorem vtocl2 (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of vtocl2 {
	step 1 : wff = isseti (hyp 1) |- ∃ x x = A ;;
	step 2 : wff = isseti (hyp 2) |- ∃ y y = B ;;
	step 3 : wff = eeanv () |- ( ∃ x ∃ y ( x = A ∧ y = B ) ↔ ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 4 : wff = biimpd (hyp 3) |- ( ( x = A ∧ y = B ) → ( ph → ps ) ) ;;
	step 5 : wff = 2eximi (step 4) |- ( ∃ x ∃ y ( x = A ∧ y = B ) → ∃ x ∃ y ( ph → ps ) ) ;;
	step 6 : wff = sylbir (step 3, step 5) |- ( ( ∃ x x = A ∧ ∃ y y = B ) → ∃ x ∃ y ( ph → ps ) ) ;;
	step 7 : wff = mp2an (step 1, step 2, step 6) |- ∃ x ∃ y ( ph → ps ) ;;
	step 8 : wff = 19.36v () |- ( ∃ y ( ph → ps ) ↔ ( ∀ y ph → ps ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ x ∃ y ( ph → ps ) ↔ ∃ x ( ∀ y ph → ps ) ) ;;
	step 10 : wff = mpbi (step 7, step 9) |- ∃ x ( ∀ y ph → ps ) ;;
	step 11 : wff = 19.36aiv (step 10) |- ( ∀ x ∀ y ph → ps ) ;;
	step 12 : wff = ax-gen (hyp 4) |- ∀ y ph ;;
	step 13 : wff = mpg (step 11, step 12) |- ps ;;
	qed prop 1 = step 13 ;;
}

/* Implicit substitution of classes for set variables.  (Contributed by NM,
       3-Jun-1995.)  (Proof shortened by Andrew Salmon, 8-Jun-2011.) */

theorem vtocl3 (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(x y z A, x y z B, x y z C, x y z ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ ps ) ) ;;
	hyp 5 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of vtocl3 {
	step 1 : wff = isseti (hyp 1) |- ∃ x x = A ;;
	step 2 : wff = isseti (hyp 2) |- ∃ y y = B ;;
	step 3 : wff = isseti (hyp 3) |- ∃ z z = C ;;
	step 4 : wff = eeeanv () |- ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ↔ ( ∃ x x = A ∧ ∃ y y = B ∧ ∃ z z = C ) ) ;;
	step 5 : wff = biimpd (hyp 4) |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph → ps ) ) ;;
	step 6 : wff = eximi (step 5) |- ( ∃ z ( x = A ∧ y = B ∧ z = C ) → ∃ z ( ph → ps ) ) ;;
	step 7 : wff = 2eximi (step 6) |- ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) → ∃ x ∃ y ∃ z ( ph → ps ) ) ;;
	step 8 : wff = sylbir (step 4, step 7) |- ( ( ∃ x x = A ∧ ∃ y y = B ∧ ∃ z z = C ) → ∃ x ∃ y ∃ z ( ph → ps ) ) ;;
	step 9 : wff = mp3an (step 1, step 2, step 3, step 8) |- ∃ x ∃ y ∃ z ( ph → ps ) ;;
	step 10 : wff = 19.36v () |- ( ∃ z ( ph → ps ) ↔ ( ∀ z ph → ps ) ) ;;
	step 11 : wff = 2exbii (step 10) |- ( ∃ x ∃ y ∃ z ( ph → ps ) ↔ ∃ x ∃ y ( ∀ z ph → ps ) ) ;;
	step 12 : wff = mpbi (step 9, step 11) |- ∃ x ∃ y ( ∀ z ph → ps ) ;;
	step 13 : wff = 19.36v () |- ( ∃ y ( ∀ z ph → ps ) ↔ ( ∀ y ∀ z ph → ps ) ) ;;
	step 14 : wff = exbii (step 13) |- ( ∃ x ∃ y ( ∀ z ph → ps ) ↔ ∃ x ( ∀ y ∀ z ph → ps ) ) ;;
	step 15 : wff = mpbi (step 12, step 14) |- ∃ x ( ∀ y ∀ z ph → ps ) ;;
	step 16 : wff = 19.36aiv (step 15) |- ( ∀ x ∀ y ∀ z ph → ps ) ;;
	step 17 : wff = gen2 (hyp 5) |- ∀ y ∀ z ph ;;
	step 18 : wff = mpg (step 16, step 17) |- ps ;;
	qed prop 1 = step 18 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 23-Dec-1993.) */

theorem vtoclb (ph : wff, ps : wff, ch : wff, th : wff, x : set, A : class) disjointed(x A, x ch, x th) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 3 : wff = |- ( x = A → ( ps ↔ th ) ) ;;
	hyp 4 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ch ↔ th ) ;;
}

proof of vtoclb {
	step 1 : wff = bibi12d (hyp 2, hyp 3) |- ( x = A → ( ( ph ↔ ps ) ↔ ( ch ↔ th ) ) ) ;;
	step 2 : wff = vtocl (hyp 1, step 1, hyp 4) |- ( ch ↔ th ) ;;
	qed prop 1 = step 2 ;;
}

/* Implicit substitution of a class for a set variable, with bound-variable
       hypotheses in place of distinct variable restrictions.  (Contributed by
       NM, 21-Sep-2003.)  (Proof shortened by Mario Carneiro, 10-Oct-2016.) */

theorem vtoclgf (ph : wff, ps : wff, x : set, A : class, V : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ps ) ;;
}

proof of vtoclgf {
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = issetf (hyp 1) |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 3 : wff = mpbii (hyp 4, hyp 3) |- ( x = A → ps ) ;;
	step 4 : wff = exlimi (hyp 2, step 3) |- ( ∃ x x = A → ps ) ;;
	step 5 : wff = sylbi (step 2, step 4) |- ( A ∈ _V → ps ) ;;
	step 6 : wff = syl (step 1, step 5) |- ( A ∈ V → ps ) ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution of a class expression for a set variable.
       (Contributed by NM, 17-Apr-1995.) */

theorem vtoclg (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ps ) ;;
}

proof of vtoclg {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = vtoclgf (step 1, step 2, hyp 1, hyp 2) |- ( A ∈ V → ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 29-Apr-1994.) */

theorem vtoclbg (ph : wff, ps : wff, ch : wff, th : wff, x : set, A : class, V : class) disjointed(x A, x ch, x th) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( x = A → ( ps ↔ th ) ) ;;
	hyp 3 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ch ↔ th ) ) ;;
}

proof of vtoclbg {
	step 1 : wff = bibi12d (hyp 1, hyp 2) |- ( x = A → ( ( ph ↔ ps ) ↔ ( ch ↔ th ) ) ) ;;
	step 2 : wff = vtoclg (step 1, hyp 3) |- ( A ∈ V → ( ch ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 25-Apr-1995.) */

theorem vtocl2gf (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, V : class, W : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/_ y B ;;
	hyp 4 : wff = |- F/ x ps ;;
	hyp 5 : wff = |- F/ y ch ;;
	hyp 6 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 7 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 8 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ch ) ;;
}

proof of vtocl2gf {
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = nfel1 (hyp 2) |- F/ y A ∈ _V ;;
	step 3 : wff = nfim (step 2, hyp 5) |- F/ y ( A ∈ _V → ch ) ;;
	step 4 : wff = imbi2d (hyp 7) |- ( y = B → ( ( A ∈ _V → ps ) ↔ ( A ∈ _V → ch ) ) ) ;;
	step 5 : wff = vtoclgf (hyp 1, hyp 4, hyp 6, hyp 8) |- ( A ∈ _V → ps ) ;;
	step 6 : wff = vtoclgf (hyp 3, step 3, step 4, step 5) |- ( B ∈ W → ( A ∈ _V → ch ) ) ;;
	step 7 : wff = mpan9 (step 1, step 6) |- ( ( A ∈ V ∧ B ∈ W ) → ch ) ;;
	qed prop 1 = step 7 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 10-Aug-2013.)  (Revised by Mario Carneiro, 10-Oct-2016.) */

theorem vtocl3gf (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, V : class, W : class, X : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/_ z A ;;
	hyp 4 : wff = |- F/_ y B ;;
	hyp 5 : wff = |- F/_ z B ;;
	hyp 6 : wff = |- F/_ z C ;;
	hyp 7 : wff = |- F/ x ps ;;
	hyp 8 : wff = |- F/ y ch ;;
	hyp 9 : wff = |- F/ z th ;;
	hyp 10 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 11 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 12 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 13 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → th ) ;;
}

proof of vtocl3gf {
	step 1 : wff = elex () |- ( A ∈ V → A ∈ _V ) ;;
	step 2 : wff = nfel1 (hyp 2) |- F/ y A ∈ _V ;;
	step 3 : wff = nfim (step 2, hyp 8) |- F/ y ( A ∈ _V → ch ) ;;
	step 4 : wff = nfel1 (hyp 3) |- F/ z A ∈ _V ;;
	step 5 : wff = nfim (step 4, hyp 9) |- F/ z ( A ∈ _V → th ) ;;
	step 6 : wff = imbi2d (hyp 11) |- ( y = B → ( ( A ∈ _V → ps ) ↔ ( A ∈ _V → ch ) ) ) ;;
	step 7 : wff = imbi2d (hyp 12) |- ( z = C → ( ( A ∈ _V → ch ) ↔ ( A ∈ _V → th ) ) ) ;;
	step 8 : wff = vtoclgf (hyp 1, hyp 7, hyp 10, hyp 13) |- ( A ∈ _V → ps ) ;;
	step 9 : wff = vtocl2gf (hyp 4, hyp 5, hyp 6, step 3, step 5, step 6, step 7, step 8) |- ( ( B ∈ W ∧ C ∈ X ) → ( A ∈ _V → th ) ) ;;
	step 10 : wff = mpan9 (step 1, step 9) |- ( ( A ∈ V ∧ ( B ∈ W ∧ C ∈ X ) ) → th ) ;;
	step 11 : wff = 3impb (step 10) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → th ) ;;
	qed prop 1 = step 11 ;;
}

/* Implicit substitution of 2 classes for 2 set variables.  (Contributed by
       NM, 25-Apr-1995.) */

theorem vtocl2g (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x A, y A, y B, x ps, y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ch ) ;;
}

proof of vtocl2g {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = nfcv () |- F/_ y B ;;
	step 4 : wff = nfv () |- F/ x ps ;;
	step 5 : wff = nfv () |- F/ y ch ;;
	step 6 : wff = vtocl2gf (step 1, step 2, step 3, step 4, step 5, hyp 1, hyp 2, hyp 3) |- ( ( A ∈ V ∧ B ∈ W ) → ch ) ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 17-Feb-2006.)  (Revised by Mario Carneiro, 10-Oct-2016.) */

theorem vtoclgaf (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 4 : wff = |- ( x ∈ B → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ps ) ;;
}

proof of vtoclgaf {
	step 1 : wff = nfel1 (hyp 1) |- F/ x A ∈ B ;;
	step 2 : wff = nfim (step 1, hyp 2) |- F/ x ( A ∈ B → ps ) ;;
	step 3 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 4 : wff = imbi12d (step 3, hyp 3) |- ( x = A → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) ;;
	step 5 : wff = vtoclgf (hyp 1, step 2, step 4, hyp 4) |- ( A ∈ B → ( A ∈ B → ps ) ) ;;
	step 6 : wff = pm2.43i (step 5) |- ( A ∈ B → ps ) ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 20-Aug-1995.) */

theorem vtoclga (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( x ∈ B → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ps ) ;;
}

proof of vtoclga {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = vtoclgaf (step 1, step 2, hyp 1, hyp 2) |- ( A ∈ B → ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Implicit substitution of 2 classes for 2 set variables.  (Contributed by
       NM, 10-Aug-2013.) */

theorem vtocl2gaf (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y C, x y D) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/_ y B ;;
	hyp 4 : wff = |- F/ x ps ;;
	hyp 5 : wff = |- F/ y ch ;;
	hyp 6 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 7 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 8 : wff = |- ( ( x ∈ C ∧ y ∈ D ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ch ) ;;
}

proof of vtocl2gaf {
	step 1 : wff = nfel1 (hyp 1) |- F/ x A ∈ C ;;
	step 2 : wff = nfv () |- F/ x y ∈ D ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ x ( A ∈ C ∧ y ∈ D ) ;;
	step 4 : wff = nfim (step 3, hyp 4) |- F/ x ( ( A ∈ C ∧ y ∈ D ) → ps ) ;;
	step 5 : wff = nfel1 (hyp 2) |- F/ y A ∈ C ;;
	step 6 : wff = nfel1 (hyp 3) |- F/ y B ∈ D ;;
	step 7 : wff = nfan (step 5, step 6) |- F/ y ( A ∈ C ∧ B ∈ D ) ;;
	step 8 : wff = nfim (step 7, hyp 5) |- F/ y ( ( A ∈ C ∧ B ∈ D ) → ch ) ;;
	step 9 : wff = eleq1 () |- ( x = A → ( x ∈ C ↔ A ∈ C ) ) ;;
	step 10 : wff = anbi1d (step 9) |- ( x = A → ( ( x ∈ C ∧ y ∈ D ) ↔ ( A ∈ C ∧ y ∈ D ) ) ) ;;
	step 11 : wff = imbi12d (step 10, hyp 6) |- ( x = A → ( ( ( x ∈ C ∧ y ∈ D ) → ph ) ↔ ( ( A ∈ C ∧ y ∈ D ) → ps ) ) ) ;;
	step 12 : wff = eleq1 () |- ( y = B → ( y ∈ D ↔ B ∈ D ) ) ;;
	step 13 : wff = anbi2d (step 12) |- ( y = B → ( ( A ∈ C ∧ y ∈ D ) ↔ ( A ∈ C ∧ B ∈ D ) ) ) ;;
	step 14 : wff = imbi12d (step 13, hyp 7) |- ( y = B → ( ( ( A ∈ C ∧ y ∈ D ) → ps ) ↔ ( ( A ∈ C ∧ B ∈ D ) → ch ) ) ) ;;
	step 15 : wff = vtocl2gf (hyp 1, hyp 2, hyp 3, step 4, step 8, step 11, step 14, hyp 8) |- ( ( A ∈ C ∧ B ∈ D ) → ( ( A ∈ C ∧ B ∈ D ) → ch ) ) ;;
	step 16 : wff = pm2.43i (step 15) |- ( ( A ∈ C ∧ B ∈ D ) → ch ) ;;
	qed prop 1 = step 16 ;;
}

/* Implicit substitution of 2 classes for 2 set variables.  (Contributed by
       NM, 20-Aug-1995.) */

theorem vtocl2ga (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, y B, x y C, x y D, x ps, y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( ( x ∈ C ∧ y ∈ D ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ch ) ;;
}

proof of vtocl2ga {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = nfcv () |- F/_ y B ;;
	step 4 : wff = nfv () |- F/ x ps ;;
	step 5 : wff = nfv () |- F/ y ch ;;
	step 6 : wff = vtocl2gaf (step 1, step 2, step 3, step 4, step 5, hyp 1, hyp 2, hyp 3) |- ( ( A ∈ C ∧ B ∈ D ) → ch ) ;;
	qed prop 1 = step 6 ;;
}

/* Implicit substitution of 3 classes for 3 set variables.  (Contributed by
       NM, 10-Aug-2013.)  (Revised by Mario Carneiro, 11-Oct-2016.) */

theorem vtocl3gaf (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, T : class) disjointed(x y z R, x y z S, x y z T) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ y A ;;
	hyp 3 : wff = |- F/_ z A ;;
	hyp 4 : wff = |- F/_ y B ;;
	hyp 5 : wff = |- F/_ z B ;;
	hyp 6 : wff = |- F/_ z C ;;
	hyp 7 : wff = |- F/ x ps ;;
	hyp 8 : wff = |- F/ y ch ;;
	hyp 9 : wff = |- F/ z th ;;
	hyp 10 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 11 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 12 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 13 : wff = |- ( ( x ∈ R ∧ y ∈ S ∧ z ∈ T ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → th ) ;;
}

proof of vtocl3gaf {
	step 1 : wff = nfel1 (hyp 1) |- F/ x A ∈ R ;;
	step 2 : wff = nfv () |- F/ x y ∈ S ;;
	step 3 : wff = nfv () |- F/ x z ∈ T ;;
	step 4 : wff = nf3an (step 1, step 2, step 3) |- F/ x ( A ∈ R ∧ y ∈ S ∧ z ∈ T ) ;;
	step 5 : wff = nfim (step 4, hyp 7) |- F/ x ( ( A ∈ R ∧ y ∈ S ∧ z ∈ T ) → ps ) ;;
	step 6 : wff = nfel1 (hyp 2) |- F/ y A ∈ R ;;
	step 7 : wff = nfel1 (hyp 4) |- F/ y B ∈ S ;;
	step 8 : wff = nfv () |- F/ y z ∈ T ;;
	step 9 : wff = nf3an (step 6, step 7, step 8) |- F/ y ( A ∈ R ∧ B ∈ S ∧ z ∈ T ) ;;
	step 10 : wff = nfim (step 9, hyp 8) |- F/ y ( ( A ∈ R ∧ B ∈ S ∧ z ∈ T ) → ch ) ;;
	step 11 : wff = nfel1 (hyp 3) |- F/ z A ∈ R ;;
	step 12 : wff = nfel1 (hyp 5) |- F/ z B ∈ S ;;
	step 13 : wff = nfel1 (hyp 6) |- F/ z C ∈ T ;;
	step 14 : wff = nf3an (step 11, step 12, step 13) |- F/ z ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ;;
	step 15 : wff = nfim (step 14, hyp 9) |- F/ z ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → th ) ;;
	step 16 : wff = eleq1 () |- ( x = A → ( x ∈ R ↔ A ∈ R ) ) ;;
	step 17 : wff = 3anbi1d (step 16) |- ( x = A → ( ( x ∈ R ∧ y ∈ S ∧ z ∈ T ) ↔ ( A ∈ R ∧ y ∈ S ∧ z ∈ T ) ) ) ;;
	step 18 : wff = imbi12d (step 17, hyp 10) |- ( x = A → ( ( ( x ∈ R ∧ y ∈ S ∧ z ∈ T ) → ph ) ↔ ( ( A ∈ R ∧ y ∈ S ∧ z ∈ T ) → ps ) ) ) ;;
	step 19 : wff = eleq1 () |- ( y = B → ( y ∈ S ↔ B ∈ S ) ) ;;
	step 20 : wff = 3anbi2d (step 19) |- ( y = B → ( ( A ∈ R ∧ y ∈ S ∧ z ∈ T ) ↔ ( A ∈ R ∧ B ∈ S ∧ z ∈ T ) ) ) ;;
	step 21 : wff = imbi12d (step 20, hyp 11) |- ( y = B → ( ( ( A ∈ R ∧ y ∈ S ∧ z ∈ T ) → ps ) ↔ ( ( A ∈ R ∧ B ∈ S ∧ z ∈ T ) → ch ) ) ) ;;
	step 22 : wff = eleq1 () |- ( z = C → ( z ∈ T ↔ C ∈ T ) ) ;;
	step 23 : wff = 3anbi3d (step 22) |- ( z = C → ( ( A ∈ R ∧ B ∈ S ∧ z ∈ T ) ↔ ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ) ) ;;
	step 24 : wff = imbi12d (step 23, hyp 12) |- ( z = C → ( ( ( A ∈ R ∧ B ∈ S ∧ z ∈ T ) → ch ) ↔ ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → th ) ) ) ;;
	step 25 : wff = vtocl3gf (hyp 1, hyp 2, hyp 3, hyp 4, hyp 5, hyp 6, step 5, step 10, step 15, step 18, step 21, step 24, hyp 13) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → th ) ) ;;
	step 26 : wff = pm2.43i (step 25) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → th ) ;;
	qed prop 1 = step 26 ;;
}

/* Implicit substitution of 3 classes for 3 set variables.  (Contributed by
       NM, 20-Aug-1995.) */

theorem vtocl3ga (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, D : class, R : class, S : class) disjointed(x y z A, y z B, z C, x y z D, x y z R, x y z S, x ps, y ch, z th) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	hyp 3 : wff = |- ( z = C → ( ch ↔ th ) ) ;;
	hyp 4 : wff = |- ( ( x ∈ D ∧ y ∈ R ∧ z ∈ S ) → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ D ∧ B ∈ R ∧ C ∈ S ) → th ) ;;
}

proof of vtocl3ga {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ y A ;;
	step 3 : wff = nfcv () |- F/_ z A ;;
	step 4 : wff = nfcv () |- F/_ y B ;;
	step 5 : wff = nfcv () |- F/_ z B ;;
	step 6 : wff = nfcv () |- F/_ z C ;;
	step 7 : wff = nfv () |- F/ x ps ;;
	step 8 : wff = nfv () |- F/ y ch ;;
	step 9 : wff = nfv () |- F/ z th ;;
	step 10 : wff = vtocl3gaf (step 1, step 2, step 3, step 4, step 5, step 6, step 7, step 8, step 9, hyp 1, hyp 2, hyp 3, hyp 4) |- ( ( A ∈ D ∧ B ∈ R ∧ C ∈ S ) → th ) ;;
	qed prop 1 = step 10 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 10-Jan-2004.) */

theorem vtocleg (ph : wff, x : set, A : class, V : class) disjointed(x A, x ph) {
	hyp 1 : wff = |- ( x = A → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ph ) ;;
}

proof of vtocleg {
	step 1 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 2 : wff = exlimiv (hyp 1) |- ( ∃ x x = A → ph ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( A ∈ V → ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Implicit substitution of a class for a set variable.  (Closed theorem
       version of ~ vtoclef .)  (Contributed by NM, 7-Nov-2005.)  (Revised by
       Mario Carneiro, 11-Oct-2016.) */

theorem vtoclegft (ph : wff, x : set, A : class, B : class) disjointed(x A) {
	prop 1 : wff = |- ( ( A ∈ B ∧ F/ x ph ∧ ∀ x ( x = A → ph ) ) → ph ) ;;
}

proof of vtoclegft {
	step 1 : wff = elisset () |- ( A ∈ B → ∃ x x = A ) ;;
	step 2 : wff = exim () |- ( ∀ x ( x = A → ph ) → ( ∃ x x = A → ∃ x ph ) ) ;;
	step 3 : wff = mpan9 (step 1, step 2) |- ( ( A ∈ B ∧ ∀ x ( x = A → ph ) ) → ∃ x ph ) ;;
	step 4 : wff = 3adant2 (step 3) |- ( ( A ∈ B ∧ F/ x ph ∧ ∀ x ( x = A → ph ) ) → ∃ x ph ) ;;
	step 5 : wff = 19.9t () |- ( F/ x ph → ( ∃ x ph ↔ ph ) ) ;;
	step 6 : wff = 3ad2ant2 (step 5) |- ( ( A ∈ B ∧ F/ x ph ∧ ∀ x ( x = A → ph ) ) → ( ∃ x ph ↔ ph ) ) ;;
	step 7 : wff = mpbid (step 4, step 6) |- ( ( A ∈ B ∧ F/ x ph ∧ ∀ x ( x = A → ph ) ) → ph ) ;;
	qed prop 1 = step 7 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 18-Aug-1993.) */

theorem vtoclef (ph : wff, x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- A ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ph ) ;;
	-----------------------
	prop 1 : wff = |- ph ;;
}

proof of vtoclef {
	step 1 : wff = isseti (hyp 2) |- ∃ x x = A ;;
	step 2 : wff = exlimi (hyp 1, hyp 3) |- ( ∃ x x = A → ph ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ph ;;
	qed prop 1 = step 3 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 9-Sep-1993.) */

theorem vtocle (ph : wff, x : set, A : class) disjointed(x A, x ph) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ph ) ;;
	-----------------------
	prop 1 : wff = |- ph ;;
}

proof of vtocle {
	step 1 : wff = vtocleg (hyp 2) |- ( A ∈ _V → ph ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ph ;;
	qed prop 1 = step 2 ;;
}

/* Implicit substitution of a class for a set variable.  (Contributed by
       NM, 21-Nov-1994.) */

theorem vtoclri (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ∀ x ∈ B ph ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ps ) ;;
}

proof of vtoclri {
	step 1 : wff = rspec (hyp 2) |- ( x ∈ B → ph ) ;;
	step 2 : wff = vtoclga (hyp 1, step 1) |- ( A ∈ B → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A closed version of ~ spcimgf .  (Contributed by Mario Carneiro,
       4-Jan-2017.) */

theorem spcimgft (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = A → ( ph → ps ) ) → ( A ∈ B → ( ∀ x ph → ps ) ) ) ;;
}

proof of spcimgft {
	step 1 : wff = elex () |- ( A ∈ B → A ∈ _V ) ;;
	step 2 : wff = issetf (hyp 2) |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 3 : wff = exim () |- ( ∀ x ( x = A → ( ph → ps ) ) → ( ∃ x x = A → ∃ x ( ph → ps ) ) ) ;;
	step 4 : wff = syl5bi (step 2, step 3) |- ( ∀ x ( x = A → ( ph → ps ) ) → ( A ∈ _V → ∃ x ( ph → ps ) ) ) ;;
	step 5 : wff = 19.36 (hyp 1) |- ( ∃ x ( ph → ps ) ↔ ( ∀ x ph → ps ) ) ;;
	step 6 : wff = syl6ib (step 4, step 5) |- ( ∀ x ( x = A → ( ph → ps ) ) → ( A ∈ _V → ( ∀ x ph → ps ) ) ) ;;
	step 7 : wff = syl5 (step 1, step 6) |- ( ∀ x ( x = A → ( ph → ps ) ) → ( A ∈ B → ( ∀ x ph → ps ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* A closed version of ~ spcgf .  (Contributed by Andrew Salmon,
       6-Jun-2011.)  (Revised by Mario Carneiro, 4-Jan-2017.) */

theorem spcgft (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( ∀ x ph → ps ) ) ) ;;
}

proof of spcgft {
	step 1 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 2 : wff = imim2i (step 1) |- ( ( x = A → ( ph ↔ ps ) ) → ( x = A → ( ph → ps ) ) ) ;;
	step 3 : wff = alimi (step 2) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ∀ x ( x = A → ( ph → ps ) ) ) ;;
	step 4 : wff = spcimgft (hyp 1, hyp 2) |- ( ∀ x ( x = A → ( ph → ps ) ) → ( A ∈ B → ( ∀ x ph → ps ) ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( ∀ x ph → ps ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rule of specialization, using implicit substitution.  Compare Theorem
         7.3 of [Quine] p. 44.  (Contributed by Mario Carneiro, 4-Jan-2017.) */

theorem spcimgf (ph : wff, ps : wff, x : set, A : class, V : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∀ x ph → ps ) ) ;;
}

proof of spcimgf {
	step 1 : wff = spcimgft (hyp 2, hyp 1) |- ( ∀ x ( x = A → ( ph → ps ) ) → ( A ∈ V → ( ∀ x ph → ps ) ) ) ;;
	step 2 : wff = mpg (step 1, hyp 3) |- ( A ∈ V → ( ∀ x ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Existential specialization, using implicit substitution.  (Contributed
       by Mario Carneiro, 4-Jan-2017.) */

theorem spcimegf (ph : wff, ps : wff, x : set, A : class, V : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ps → ph ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ps → ∃ x ph ) ) ;;
}

proof of spcimegf {
	step 1 : wff = nfn (hyp 2) |- F/ x ¬ ps ;;
	step 2 : wff = con3d (hyp 3) |- ( x = A → ( ¬ ph → ¬ ps ) ) ;;
	step 3 : wff = spcimgf (hyp 1, step 1, step 2) |- ( A ∈ V → ( ∀ x ¬ ph → ¬ ps ) ) ;;
	step 4 : wff = con2d (step 3) |- ( A ∈ V → ( ps → ¬ ∀ x ¬ ph ) ) ;;
	step 5 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 6 : wff = syl6ibr (step 4, step 5) |- ( A ∈ V → ( ps → ∃ x ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Rule of specialization, using implicit substitution.  Compare Theorem
       7.3 of [Quine] p. 44.  (Contributed by NM, 2-Feb-1997.)  (Revised by
       Andrew Salmon, 12-Aug-2011.) */

theorem spcgf (ph : wff, ps : wff, x : set, A : class, V : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∀ x ph → ps ) ) ;;
}

proof of spcgf {
	step 1 : wff = spcgft (hyp 2, hyp 1) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ V → ( ∀ x ph → ps ) ) ) ;;
	step 2 : wff = mpg (step 1, hyp 3) |- ( A ∈ V → ( ∀ x ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Existential specialization, using implicit substitution.  (Contributed
       by NM, 2-Feb-1997.) */

theorem spcegf (ph : wff, ps : wff, x : set, A : class, V : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ps → ∃ x ph ) ) ;;
}

proof of spcegf {
	step 1 : wff = nfn (hyp 2) |- F/ x ¬ ps ;;
	step 2 : wff = notbid (hyp 3) |- ( x = A → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 3 : wff = spcgf (hyp 1, step 1, step 2) |- ( A ∈ V → ( ∀ x ¬ ph → ¬ ps ) ) ;;
	step 4 : wff = con2d (step 3) |- ( A ∈ V → ( ps → ¬ ∀ x ¬ ph ) ) ;;
	step 5 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 6 : wff = syl6ibr (step 4, step 5) |- ( A ∈ V → ( ps → ∃ x ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed
         by Mario Carneiro, 4-Jan-2017.) */

theorem spcimdv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ps → ch ) ) ;;
}

proof of spcimdv {
	step 1 : wff = ex (hyp 2) |- ( ph → ( x = A → ( ps → ch ) ) ) ;;
	step 2 : wff = alrimiv (step 1) |- ( ph → ∀ x ( x = A → ( ps → ch ) ) ) ;;
	step 3 : wff = nfv () |- F/ x ch ;;
	step 4 : wff = nfcv () |- F/_ x A ;;
	step 5 : wff = spcimgft (step 3, step 4) |- ( ∀ x ( x = A → ( ps → ch ) ) → ( A ∈ B → ( ∀ x ps → ch ) ) ) ;;
	step 6 : wff = sylc (step 2, hyp 1, step 5) |- ( ph → ( ∀ x ps → ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Rule of specialization, using implicit substitution.  Analogous to
         ~ rspcdv .  (Contributed by David Moews, 1-May-2017.) */

theorem spcdv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ps → ch ) ) ;;
}

proof of spcdv {
	step 1 : wff = biimpd (hyp 2) |- ( ( ph ∧ x = A ) → ( ps → ch ) ) ;;
	step 2 : wff = spcimdv (hyp 1, step 1) |- ( ph → ( ∀ x ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted existential specialization, using implicit substitution.
       (Contributed by Mario Carneiro, 4-Jan-2017.) */

theorem spcimedv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ch → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ∃ x ps ) ) ;;
}

proof of spcimedv {
	step 1 : wff = con3d (hyp 2) |- ( ( ph ∧ x = A ) → ( ¬ ps → ¬ ch ) ) ;;
	step 2 : wff = spcimdv (hyp 1, step 1) |- ( ph → ( ∀ x ¬ ps → ¬ ch ) ) ;;
	step 3 : wff = con2d (step 2) |- ( ph → ( ch → ¬ ∀ x ¬ ps ) ) ;;
	step 4 : wff = df-ex () |- ( ∃ x ps ↔ ¬ ∀ x ¬ ps ) ;;
	step 5 : wff = syl6ibr (step 3, step 4) |- ( ph → ( ch → ∃ x ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rule of specialization, using implicit substitution.  Compare Theorem
       7.3 of [Quine] p. 44.  (Contributed by NM, 22-Jun-1994.) */

theorem spcgv (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∀ x ph → ps ) ) ;;
}

proof of spcgv {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = spcgf (step 1, step 2, hyp 1) |- ( A ∈ V → ( ∀ x ph → ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Existential specialization, using implicit substitution.  (Contributed
       by NM, 14-Aug-1994.) */

theorem spcegv (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ps → ∃ x ph ) ) ;;
}

proof of spcegv {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = spcegf (step 1, step 2, hyp 1) |- ( A ∈ V → ( ps → ∃ x ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Existential specialization with 2 quantifiers, using implicit
       substitution.  (Contributed by NM, 3-Aug-1995.) */

theorem spc2egv (ph : wff, ps : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( ps → ∃ x ∃ y ph ) ) ;;
}

proof of spc2egv {
	step 1 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 2 : wff = elisset () |- ( B ∈ W → ∃ y y = B ) ;;
	step 3 : wff = anim12i (step 1, step 2) |- ( ( A ∈ V ∧ B ∈ W ) → ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 4 : wff = eeanv () |- ( ∃ x ∃ y ( x = A ∧ y = B ) ↔ ( ∃ x x = A ∧ ∃ y y = B ) ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ( A ∈ V ∧ B ∈ W ) → ∃ x ∃ y ( x = A ∧ y = B ) ) ;;
	step 6 : wff = biimprcd (hyp 1) |- ( ps → ( ( x = A ∧ y = B ) → ph ) ) ;;
	step 7 : wff = 2eximdv (step 6) |- ( ps → ( ∃ x ∃ y ( x = A ∧ y = B ) → ∃ x ∃ y ph ) ) ;;
	step 8 : wff = syl5com (step 5, step 7) |- ( ( A ∈ V ∧ B ∈ W ) → ( ps → ∃ x ∃ y ph ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Specialization with 2 quantifiers, using implicit substitution.
       (Contributed by NM, 27-Apr-2004.) */

theorem spc2gv (ph : wff, ps : wff, x : set, y : set, A : class, B : class, V : class, W : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ( ∀ x ∀ y ph → ps ) ) ;;
}

proof of spc2gv {
	step 1 : wff = notbid (hyp 1) |- ( ( x = A ∧ y = B ) → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = spc2egv (step 1) |- ( ( A ∈ V ∧ B ∈ W ) → ( ¬ ps → ∃ x ∃ y ¬ ph ) ) ;;
	step 3 : wff = 2nalexn () |- ( ¬ ∀ x ∀ y ph ↔ ∃ x ∃ y ¬ ph ) ;;
	step 4 : wff = syl6ibr (step 2, step 3) |- ( ( A ∈ V ∧ B ∈ W ) → ( ¬ ps → ¬ ∀ x ∀ y ph ) ) ;;
	step 5 : wff = con4d (step 4) |- ( ( A ∈ V ∧ B ∈ W ) → ( ∀ x ∀ y ph → ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Existential specialization with 3 quantifiers, using implicit
       substitution.  (Contributed by NM, 12-May-2008.) */

theorem spc3egv (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, V : class, W : class, X : class) disjointed(x y z A, x y z B, x y z C, x y z ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ps → ∃ x ∃ y ∃ z ph ) ) ;;
}

proof of spc3egv {
	step 1 : wff = elisset () |- ( A ∈ V → ∃ x x = A ) ;;
	step 2 : wff = elisset () |- ( B ∈ W → ∃ y y = B ) ;;
	step 3 : wff = elisset () |- ( C ∈ X → ∃ z z = C ) ;;
	step 4 : wff = 3anim123i (step 1, step 2, step 3) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ∃ x x = A ∧ ∃ y y = B ∧ ∃ z z = C ) ) ;;
	step 5 : wff = eeeanv () |- ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ↔ ( ∃ x x = A ∧ ∃ y y = B ∧ ∃ z z = C ) ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) ) ;;
	step 7 : wff = biimprcd (hyp 1) |- ( ps → ( ( x = A ∧ y = B ∧ z = C ) → ph ) ) ;;
	step 8 : wff = eximdv (step 7) |- ( ps → ( ∃ z ( x = A ∧ y = B ∧ z = C ) → ∃ z ph ) ) ;;
	step 9 : wff = 2eximdv (step 8) |- ( ps → ( ∃ x ∃ y ∃ z ( x = A ∧ y = B ∧ z = C ) → ∃ x ∃ y ∃ z ph ) ) ;;
	step 10 : wff = syl5com (step 6, step 9) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ps → ∃ x ∃ y ∃ z ph ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Specialization with 3 quantifiers, using implicit substitution.
       (Contributed by NM, 12-May-2008.) */

theorem spc3gv (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class, V : class, W : class, X : class) disjointed(x y z A, x y z B, x y z C, x y z ps) {
	hyp 1 : wff = |- ( ( x = A ∧ y = B ∧ z = C ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ∀ x ∀ y ∀ z ph → ps ) ) ;;
}

proof of spc3gv {
	step 1 : wff = notbid (hyp 1) |- ( ( x = A ∧ y = B ∧ z = C ) → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = spc3egv (step 1) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ¬ ps → ∃ x ∃ y ∃ z ¬ ph ) ) ;;
	step 3 : wff = exnal () |- ( ∃ z ¬ ph ↔ ¬ ∀ z ph ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ∃ z ¬ ph ↔ ∃ y ¬ ∀ z ph ) ;;
	step 5 : wff = exnal () |- ( ∃ y ¬ ∀ z ph ↔ ¬ ∀ y ∀ z ph ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( ∃ y ∃ z ¬ ph ↔ ¬ ∀ y ∀ z ph ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ x ∃ y ∃ z ¬ ph ↔ ∃ x ¬ ∀ y ∀ z ph ) ;;
	step 8 : wff = exnal () |- ( ∃ x ¬ ∀ y ∀ z ph ↔ ¬ ∀ x ∀ y ∀ z ph ) ;;
	step 9 : wff = bitr2i (step 7, step 8) |- ( ¬ ∀ x ∀ y ∀ z ph ↔ ∃ x ∃ y ∃ z ¬ ph ) ;;
	step 10 : wff = syl6ibr (step 2, step 9) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ¬ ps → ¬ ∀ x ∀ y ∀ z ph ) ) ;;
	step 11 : wff = con4d (step 10) |- ( ( A ∈ V ∧ B ∈ W ∧ C ∈ X ) → ( ∀ x ∀ y ∀ z ph → ps ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Rule of specialization, using implicit substitution.  (Contributed by
       NM, 22-Jun-1994.) */

theorem spcv (ph : wff, ps : wff, x : set, A : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph → ps ) ;;
}

proof of spcv {
	step 1 : wff = spcgv (hyp 2) |- ( A ∈ _V → ( ∀ x ph → ps ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ∀ x ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Existential specialization, using implicit substitution.  (Contributed
       by NM, 31-Dec-1993.)  (Proof shortened by Eric Schmidt, 22-Dec-2006.) */

theorem spcev (ph : wff, ps : wff, x : set, A : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ps → ∃ x ph ) ;;
}

proof of spcev {
	step 1 : wff = spcegv (hyp 2) |- ( A ∈ _V → ( ps → ∃ x ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ps → ∃ x ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Existential specialization, using implicit substitution.  (Contributed
       by NM, 3-Aug-1995.) */

theorem spc2ev (ph : wff, ps : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x y B, x y ps) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- ( ( x = A ∧ y = B ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ps → ∃ x ∃ y ph ) ;;
}

proof of spc2ev {
	step 1 : wff = spc2egv (hyp 3) |- ( ( A ∈ _V ∧ B ∈ _V ) → ( ps → ∃ x ∃ y ph ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( ps → ∃ x ∃ y ph ) ;;
	qed prop 1 = step 2 ;;
}

/* A closed version of ~ rspc .  (Contributed by Andrew Salmon,
       6-Jun-2011.) */

theorem rspct (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- F/ x ps ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ) ;;
}

proof of rspct {
	step 1 : wff = df-ral () |- ( ∀ x ∈ B ph ↔ ∀ x ( x ∈ B → ph ) ) ;;
	step 2 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 3 : wff = adantr (step 2) |- ( ( x = A ∧ ( ph ↔ ps ) ) → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 4 : wff = simpr () |- ( ( x = A ∧ ( ph ↔ ps ) ) → ( ph ↔ ps ) ) ;;
	step 5 : wff = imbi12d (step 3, step 4) |- ( ( x = A ∧ ( ph ↔ ps ) ) → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) ;;
	step 6 : wff = ex (step 5) |- ( x = A → ( ( ph ↔ ps ) → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) ) ;;
	step 7 : wff = a2i (step 6) |- ( ( x = A → ( ph ↔ ps ) ) → ( x = A → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) ) ;;
	step 8 : wff = alimi (step 7) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ∀ x ( x = A → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) ) ;;
	step 9 : wff = nfv () |- F/ x A ∈ B ;;
	step 10 : wff = nfim (step 9, hyp 1) |- F/ x ( A ∈ B → ps ) ;;
	step 11 : wff = nfcv () |- F/_ x A ;;
	step 12 : wff = spcgft (step 10, step 11) |- ( ∀ x ( x = A → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) → ( A ∈ B → ( ∀ x ( x ∈ B → ph ) → ( A ∈ B → ps ) ) ) ) ;;
	step 13 : wff = syl (step 8, step 12) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( ∀ x ( x ∈ B → ph ) → ( A ∈ B → ps ) ) ) ) ;;
	step 14 : wff = syl7bi (step 1, step 13) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( ∀ x ∈ B ph → ( A ∈ B → ps ) ) ) ) ;;
	step 15 : wff = com34 (step 14) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ) ) ;;
	step 16 : wff = pm2.43d (step 15) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed by
       NM, 19-Apr-2005.)  (Revised by Mario Carneiro, 11-Oct-2016.) */

theorem rspc (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
}

proof of rspc {
	step 1 : wff = df-ral () |- ( ∀ x ∈ B ph ↔ ∀ x ( x ∈ B → ph ) ) ;;
	step 2 : wff = nfcv () |- F/_ x A ;;
	step 3 : wff = nfv () |- F/ x A ∈ B ;;
	step 4 : wff = nfim (step 3, hyp 1) |- F/ x ( A ∈ B → ps ) ;;
	step 5 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 6 : wff = imbi12d (step 5, hyp 2) |- ( x = A → ( ( x ∈ B → ph ) ↔ ( A ∈ B → ps ) ) ) ;;
	step 7 : wff = spcgf (step 2, step 4, step 6) |- ( A ∈ B → ( ∀ x ( x ∈ B → ph ) → ( A ∈ B → ps ) ) ) ;;
	step 8 : wff = pm2.43a (step 7) |- ( A ∈ B → ( ∀ x ( x ∈ B → ph ) → ps ) ) ;;
	step 9 : wff = syl5bi (step 1, step 8) |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Restricted existential specialization, using implicit substitution.
       (Contributed by NM, 26-May-1998.)  (Revised by Mario Carneiro,
       11-Oct-2016.) */

theorem rspce (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ B ∧ ps ) → ∃ x ∈ B ph ) ;;
}

proof of rspce {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x A ∈ B ;;
	step 3 : wff = nfan (step 2, hyp 1) |- F/ x ( A ∈ B ∧ ps ) ;;
	step 4 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 5 : wff = anbi12d (step 4, hyp 2) |- ( x = A → ( ( x ∈ B ∧ ph ) ↔ ( A ∈ B ∧ ps ) ) ) ;;
	step 6 : wff = spcegf (step 1, step 3, step 5) |- ( A ∈ B → ( ( A ∈ B ∧ ps ) → ∃ x ( x ∈ B ∧ ph ) ) ) ;;
	step 7 : wff = anabsi5 (step 6) |- ( ( A ∈ B ∧ ps ) → ∃ x ( x ∈ B ∧ ph ) ) ;;
	step 8 : wff = df-rex () |- ( ∃ x ∈ B ph ↔ ∃ x ( x ∈ B ∧ ph ) ) ;;
	step 9 : wff = sylibr (step 7, step 8) |- ( ( A ∈ B ∧ ps ) → ∃ x ∈ B ph ) ;;
	qed prop 1 = step 9 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed by
       NM, 26-May-1998.) */

theorem rspcv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
}

proof of rspcv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = rspc (step 1, hyp 1) |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed by
       NM, 2-Feb-2006.) */

theorem rspccv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ B ph → ( A ∈ B → ps ) ) ;;
}

proof of rspccv {
	step 1 : wff = rspcv (hyp 1) |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
	step 2 : wff = com12 (step 1) |- ( ∀ x ∈ B ph → ( A ∈ B → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed by
       NM, 13-Sep-2005.) */

theorem rspcva (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ B ∧ ∀ x ∈ B ph ) → ps ) ;;
}

proof of rspcva {
	step 1 : wff = rspcv (hyp 1) |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
	step 2 : wff = imp (step 1) |- ( ( A ∈ B ∧ ∀ x ∈ B ph ) → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed by
       NM, 26-Jul-2006.)  (Proof shortened by Andrew Salmon, 8-Jun-2011.) */

theorem rspccva (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ∀ x ∈ B ph ∧ A ∈ B ) → ps ) ;;
}

proof of rspccva {
	step 1 : wff = rspcv (hyp 1) |- ( A ∈ B → ( ∀ x ∈ B ph → ps ) ) ;;
	step 2 : wff = impcom (step 1) |- ( ( ∀ x ∈ B ph ∧ A ∈ B ) → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted existential specialization, using implicit substitution.
       (Contributed by NM, 26-May-1998.) */

theorem rspcev (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ B ∧ ps ) → ∃ x ∈ B ph ) ;;
}

proof of rspcev {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = rspce (step 1, hyp 1) |- ( ( A ∈ B ∧ ps ) → ∃ x ∈ B ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed
         by Mario Carneiro, 4-Jan-2017.) */

theorem rspcimdv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ B ps → ch ) ) ;;
}

proof of rspcimdv {
	step 1 : wff = df-ral () |- ( ∀ x ∈ B ps ↔ ∀ x ( x ∈ B → ps ) ) ;;
	step 2 : wff = simpr () |- ( ( ph ∧ x = A ) → x = A ) ;;
	step 3 : wff = eleq1d (step 2) |- ( ( ph ∧ x = A ) → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 4 : wff = biimprd (step 3) |- ( ( ph ∧ x = A ) → ( A ∈ B → x ∈ B ) ) ;;
	step 5 : wff = imim12d (step 4, hyp 2) |- ( ( ph ∧ x = A ) → ( ( x ∈ B → ps ) → ( A ∈ B → ch ) ) ) ;;
	step 6 : wff = spcimdv (hyp 1, step 5) |- ( ph → ( ∀ x ( x ∈ B → ps ) → ( A ∈ B → ch ) ) ) ;;
	step 7 : wff = mpid (hyp 1, step 6) |- ( ph → ( ∀ x ( x ∈ B → ps ) → ch ) ) ;;
	step 8 : wff = syl5bi (step 1, step 7) |- ( ph → ( ∀ x ∈ B ps → ch ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Restricted existential specialization, using implicit substitution.
       (Contributed by Mario Carneiro, 4-Jan-2017.) */

theorem rspcimedv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ch → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ∃ x ∈ B ps ) ) ;;
}

proof of rspcimedv {
	step 1 : wff = con3d (hyp 2) |- ( ( ph ∧ x = A ) → ( ¬ ps → ¬ ch ) ) ;;
	step 2 : wff = rspcimdv (hyp 1, step 1) |- ( ph → ( ∀ x ∈ B ¬ ps → ¬ ch ) ) ;;
	step 3 : wff = con2d (step 2) |- ( ph → ( ch → ¬ ∀ x ∈ B ¬ ps ) ) ;;
	step 4 : wff = dfrex2 () |- ( ∃ x ∈ B ps ↔ ¬ ∀ x ∈ B ¬ ps ) ;;
	step 5 : wff = syl6ibr (step 3, step 4) |- ( ph → ( ch → ∃ x ∈ B ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Restricted specialization, using implicit substitution.  (Contributed by
       NM, 17-Feb-2007.)  (Revised by Mario Carneiro, 4-Jan-2017.) */

theorem rspcdv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ∈ B ps → ch ) ) ;;
}

proof of rspcdv {
	step 1 : wff = biimpd (hyp 2) |- ( ( ph ∧ x = A ) → ( ps → ch ) ) ;;
	step 2 : wff = rspcimdv (hyp 1, step 1) |- ( ph → ( ∀ x ∈ B ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted existential specialization, using implicit substitution.
       (Contributed by FL, 17-Apr-2007.)  (Revised by Mario Carneiro,
       4-Jan-2017.) */

theorem rspcedv (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph, x ch) {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x = A ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ∃ x ∈ B ps ) ) ;;
}

proof of rspcedv {
	step 1 : wff = biimprd (hyp 2) |- ( ( ph ∧ x = A ) → ( ch → ps ) ) ;;
	step 2 : wff = rspcimedv (hyp 1, step 1) |- ( ph → ( ch → ∃ x ∈ B ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* 2-variable restricted specialization, using implicit substitution.
       (Contributed by NM, 9-Nov-2012.) */

theorem rspc2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, y B, x C, x y D) {
	hyp 1 : wff = |- F/ x ch ;;
	hyp 2 : wff = |- F/ y ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 4 : wff = |- ( y = B → ( ch ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( ∀ x ∈ C ∀ y ∈ D ph → ps ) ) ;;
}

proof of rspc2 {
	step 1 : wff = nfcv () |- F/_ x D ;;
	step 2 : wff = nfral (step 1, hyp 1) |- F/ x ∀ y ∈ D ch ;;
	step 3 : wff = ralbidv (hyp 3) |- ( x = A → ( ∀ y ∈ D ph ↔ ∀ y ∈ D ch ) ) ;;
	step 4 : wff = rspc (step 2, step 3) |- ( A ∈ C → ( ∀ x ∈ C ∀ y ∈ D ph → ∀ y ∈ D ch ) ) ;;
	step 5 : wff = rspc (hyp 2, hyp 4) |- ( B ∈ D → ( ∀ y ∈ D ch → ps ) ) ;;
	step 6 : wff = sylan9 (step 4, step 5) |- ( ( A ∈ C ∧ B ∈ D ) → ( ∀ x ∈ C ∀ y ∈ D ph → ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* 2-variable restricted specialization, using implicit substitution.
       (Contributed by NM, 13-Sep-1999.) */

theorem rspc2v (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, y B, x C, x y D, x ch, y ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ch ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( ∀ x ∈ C ∀ y ∈ D ph → ps ) ) ;;
}

proof of rspc2v {
	step 1 : wff = nfv () |- F/ x ch ;;
	step 2 : wff = nfv () |- F/ y ps ;;
	step 3 : wff = rspc2 (step 1, step 2, hyp 1, hyp 2) |- ( ( A ∈ C ∧ B ∈ D ) → ( ∀ x ∈ C ∀ y ∈ D ph → ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* 2-variable restricted specialization, using implicit substitution.
       (Contributed by NM, 18-Jun-2014.) */

theorem rspc2va (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, y B, x C, x y D, x ch, y ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ch ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∀ x ∈ C ∀ y ∈ D ph ) → ps ) ;;
}

proof of rspc2va {
	step 1 : wff = rspc2v (hyp 1, hyp 2) |- ( ( A ∈ C ∧ B ∈ D ) → ( ∀ x ∈ C ∀ y ∈ D ph → ps ) ) ;;
	step 2 : wff = imp (step 1) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∀ x ∈ C ∀ y ∈ D ph ) → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* 2-variable restricted existential specialization, using implicit
       substitution.  (Contributed by NM, 16-Oct-1999.) */

theorem rspc2ev (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, y B, x C, x y D, x ch, y ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ch ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ∧ ps ) → ∃ x ∈ C ∃ y ∈ D ph ) ;;
}

proof of rspc2ev {
	step 1 : wff = rspcev (hyp 2) |- ( ( B ∈ D ∧ ps ) → ∃ y ∈ D ch ) ;;
	step 2 : wff = anim2i (step 1) |- ( ( A ∈ C ∧ ( B ∈ D ∧ ps ) ) → ( A ∈ C ∧ ∃ y ∈ D ch ) ) ;;
	step 3 : wff = 3impb (step 2) |- ( ( A ∈ C ∧ B ∈ D ∧ ps ) → ( A ∈ C ∧ ∃ y ∈ D ch ) ) ;;
	step 4 : wff = rexbidv (hyp 1) |- ( x = A → ( ∃ y ∈ D ph ↔ ∃ y ∈ D ch ) ) ;;
	step 5 : wff = rspcev (step 4) |- ( ( A ∈ C ∧ ∃ y ∈ D ch ) → ∃ x ∈ C ∃ y ∈ D ph ) ;;
	step 6 : wff = syl (step 3, step 5) |- ( ( A ∈ C ∧ B ∈ D ∧ ps ) → ∃ x ∈ C ∃ y ∈ D ph ) ;;
	qed prop 1 = step 6 ;;
}

/* 3-variable restricted specialization, using implicit substitution.
       (Contributed by NM, 10-May-2005.) */

theorem rspc3v (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, T : class) disjointed(z ps, x ch, y th, x y z A, y z B, z C, x R, x y S, x y z T) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( z = C → ( th ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → ( ∀ x ∈ R ∀ y ∈ S ∀ z ∈ T ph → ps ) ) ;;
}

proof of rspc3v {
	step 1 : wff = ralbidv (hyp 1) |- ( x = A → ( ∀ z ∈ T ph ↔ ∀ z ∈ T ch ) ) ;;
	step 2 : wff = ralbidv (hyp 2) |- ( y = B → ( ∀ z ∈ T ch ↔ ∀ z ∈ T th ) ) ;;
	step 3 : wff = rspc2v (step 1, step 2) |- ( ( A ∈ R ∧ B ∈ S ) → ( ∀ x ∈ R ∀ y ∈ S ∀ z ∈ T ph → ∀ z ∈ T th ) ) ;;
	step 4 : wff = rspcv (hyp 3) |- ( C ∈ T → ( ∀ z ∈ T th → ps ) ) ;;
	step 5 : wff = sylan9 (step 3, step 4) |- ( ( ( A ∈ R ∧ B ∈ S ) ∧ C ∈ T ) → ( ∀ x ∈ R ∀ y ∈ S ∀ z ∈ T ph → ps ) ) ;;
	step 6 : wff = 3impa (step 5) |- ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) → ( ∀ x ∈ R ∀ y ∈ S ∀ z ∈ T ph → ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* 3-variable restricted existentional specialization, using implicit
       substitution.  (Contributed by NM, 25-Jul-2012.) */

theorem rspc3ev (ph : wff, ps : wff, ch : wff, th : wff, x : set, y : set, z : set, A : class, B : class, C : class, R : class, S : class, T : class) disjointed(z ps, x ch, y th, x y z A, y z B, z C, x R, x y S, x y z T) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ch ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( z = C → ( th ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ∧ ps ) → ∃ x ∈ R ∃ y ∈ S ∃ z ∈ T ph ) ;;
}

proof of rspc3ev {
	step 1 : wff = simpl1 () |- ( ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ∧ ps ) → A ∈ R ) ;;
	step 2 : wff = simpl2 () |- ( ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ∧ ps ) → B ∈ S ) ;;
	step 3 : wff = rspcev (hyp 3) |- ( ( C ∈ T ∧ ps ) → ∃ z ∈ T th ) ;;
	step 4 : wff = 3ad2antl3 (step 3) |- ( ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ∧ ps ) → ∃ z ∈ T th ) ;;
	step 5 : wff = rexbidv (hyp 1) |- ( x = A → ( ∃ z ∈ T ph ↔ ∃ z ∈ T ch ) ) ;;
	step 6 : wff = rexbidv (hyp 2) |- ( y = B → ( ∃ z ∈ T ch ↔ ∃ z ∈ T th ) ) ;;
	step 7 : wff = rspc2ev (step 5, step 6) |- ( ( A ∈ R ∧ B ∈ S ∧ ∃ z ∈ T th ) → ∃ x ∈ R ∃ y ∈ S ∃ z ∈ T ph ) ;;
	step 8 : wff = syl3anc (step 1, step 2, step 4, step 7) |- ( ( ( A ∈ R ∧ B ∈ S ∧ C ∈ T ) ∧ ps ) → ∃ x ∈ R ∃ y ∈ S ∃ z ∈ T ph ) ;;
	qed prop 1 = step 8 ;;
}

/* A variable introduction law for class equality.  (Contributed by NM,
       14-Apr-1995.)  (Proof shortened by Andrew Salmon, 8-Jun-2011.) */

theorem eqvinc (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A = B ↔ ∃ x ( x = A ∧ x = B ) ) ;;
}

proof of eqvinc {
	step 1 : wff = isseti (hyp 1) |- ∃ x x = A ;;
	step 2 : wff = ax-1 () |- ( x = A → ( A = B → x = A ) ) ;;
	step 3 : wff = eqtr () |- ( ( x = A ∧ A = B ) → x = B ) ;;
	step 4 : wff = ex (step 3) |- ( x = A → ( A = B → x = B ) ) ;;
	step 5 : wff = jca (step 2, step 4) |- ( x = A → ( ( A = B → x = A ) ∧ ( A = B → x = B ) ) ) ;;
	step 6 : wff = eximi (step 5) |- ( ∃ x x = A → ∃ x ( ( A = B → x = A ) ∧ ( A = B → x = B ) ) ) ;;
	step 7 : wff = pm3.43 () |- ( ( ( A = B → x = A ) ∧ ( A = B → x = B ) ) → ( A = B → ( x = A ∧ x = B ) ) ) ;;
	step 8 : wff = eximi (step 7) |- ( ∃ x ( ( A = B → x = A ) ∧ ( A = B → x = B ) ) → ∃ x ( A = B → ( x = A ∧ x = B ) ) ) ;;
	step 9 : wff = mp2b (step 1, step 6, step 8) |- ∃ x ( A = B → ( x = A ∧ x = B ) ) ;;
	step 10 : wff = 19.37aiv (step 9) |- ( A = B → ∃ x ( x = A ∧ x = B ) ) ;;
	step 11 : wff = eqtr2 () |- ( ( x = A ∧ x = B ) → A = B ) ;;
	step 12 : wff = exlimiv (step 11) |- ( ∃ x ( x = A ∧ x = B ) → A = B ) ;;
	step 13 : wff = impbii (step 10, step 12) |- ( A = B ↔ ∃ x ( x = A ∧ x = B ) ) ;;
	qed prop 1 = step 13 ;;
}

/* A variable introduction law for class equality, using bound-variable
       hypotheses instead of distinct variable conditions.  (Contributed by NM,
       14-Sep-2003.) */

theorem eqvincf (x : set, A : class, B : class) disjointed(A y, B y, x y) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	hyp 3 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A = B ↔ ∃ x ( x = A ∧ x = B ) ) ;;
}

proof of eqvincf {
	var y : set;;
	step 1 : wff = eqvinc (hyp 3) |- ( A = B ↔ ∃ y ( y = A ∧ y = B ) ) ;;
	step 2 : wff = nfeq2 (hyp 1) |- F/ x y = A ;;
	step 3 : wff = nfeq2 (hyp 2) |- F/ x y = B ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ x ( y = A ∧ y = B ) ;;
	step 5 : wff = nfv () |- F/ y ( x = A ∧ x = B ) ;;
	step 6 : wff = eqeq1 () |- ( y = x → ( y = A ↔ x = A ) ) ;;
	step 7 : wff = eqeq1 () |- ( y = x → ( y = B ↔ x = B ) ) ;;
	step 8 : wff = anbi12d (step 6, step 7) |- ( y = x → ( ( y = A ∧ y = B ) ↔ ( x = A ∧ x = B ) ) ) ;;
	step 9 : wff = cbvex (step 4, step 5, step 8) |- ( ∃ y ( y = A ∧ y = B ) ↔ ∃ x ( x = A ∧ x = B ) ) ;;
	step 10 : wff = bitri (step 1, step 9) |- ( A = B ↔ ∃ x ( x = A ∧ x = B ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Two ways to express substitution of ` A ` for ` x ` in ` ph ` .
       (Contributed by NM, 2-Mar-1995.) */

theorem alexeq (ph : wff, x : set, A : class) disjointed(x A y, ph y) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = A → ph ) ↔ ∃ x ( x = A ∧ ph ) ) ;;
}

proof of alexeq {
	var y : set;;
	step 1 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( y = A → ( ( x = y ∧ ph ) ↔ ( x = A ∧ ph ) ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( y = A → ( ∃ x ( x = y ∧ ph ) ↔ ∃ x ( x = A ∧ ph ) ) ) ;;
	step 4 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 5 : wff = imbi1d (step 4) |- ( y = A → ( ( x = y → ph ) ↔ ( x = A → ph ) ) ) ;;
	step 6 : wff = albidv (step 5) |- ( y = A → ( ∀ x ( x = y → ph ) ↔ ∀ x ( x = A → ph ) ) ) ;;
	step 7 : wff = sb56 () |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
	step 8 : wff = vtoclb (hyp 1, step 3, step 6, step 7) |- ( ∃ x ( x = A ∧ ph ) ↔ ∀ x ( x = A → ph ) ) ;;
	step 9 : wff = bicomi (step 8) |- ( ∀ x ( x = A → ph ) ↔ ∃ x ( x = A ∧ ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Equality implies equivalence with substitution.  (Contributed by NM,
       2-Mar-1995.) */

theorem ceqex (ph : wff, x : set, A : class) disjointed(x A y, ph y) {
	prop 1 : wff = |- ( x = A → ( ph ↔ ∃ x ( x = A ∧ ph ) ) ) ;;
}

proof of ceqex {
	var y : set;;
	step 1 : wff = 19.8a () |- ( x = A → ∃ x x = A ) ;;
	step 2 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( x = A → A ∈ _V ) ;;
	step 4 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 5 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( y = A → ( ( x = y ∧ ph ) ↔ ( x = A ∧ ph ) ) ) ;;
	step 7 : wff = exbidv (step 6) |- ( y = A → ( ∃ x ( x = y ∧ ph ) ↔ ∃ x ( x = A ∧ ph ) ) ) ;;
	step 8 : wff = bibi2d (step 7) |- ( y = A → ( ( ph ↔ ∃ x ( x = y ∧ ph ) ) ↔ ( ph ↔ ∃ x ( x = A ∧ ph ) ) ) ) ;;
	step 9 : wff = imbi12d (step 4, step 8) |- ( y = A → ( ( x = y → ( ph ↔ ∃ x ( x = y ∧ ph ) ) ) ↔ ( x = A → ( ph ↔ ∃ x ( x = A ∧ ph ) ) ) ) ) ;;
	step 10 : wff = 19.8a () |- ( ( x = y ∧ ph ) → ∃ x ( x = y ∧ ph ) ) ;;
	step 11 : wff = ex (step 10) |- ( x = y → ( ph → ∃ x ( x = y ∧ ph ) ) ) ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = alexeq (step 12) |- ( ∀ x ( x = y → ph ) ↔ ∃ x ( x = y ∧ ph ) ) ;;
	step 14 : wff = sp () |- ( ∀ x ( x = y → ph ) → ( x = y → ph ) ) ;;
	step 15 : wff = com12 (step 14) |- ( x = y → ( ∀ x ( x = y → ph ) → ph ) ) ;;
	step 16 : wff = syl5bir (step 13, step 15) |- ( x = y → ( ∃ x ( x = y ∧ ph ) → ph ) ) ;;
	step 17 : wff = impbid (step 11, step 16) |- ( x = y → ( ph ↔ ∃ x ( x = y ∧ ph ) ) ) ;;
	step 18 : wff = vtoclg (step 9, step 17) |- ( A ∈ _V → ( x = A → ( ph ↔ ∃ x ( x = A ∧ ph ) ) ) ) ;;
	step 19 : wff = mpcom (step 3, step 18) |- ( x = A → ( ph ↔ ∃ x ( x = A ∧ ph ) ) ) ;;
	qed prop 1 = step 19 ;;
}

/* A representation of explicit substitution of a class for a variable,
       inferred from an implicit substitution hypothesis.  (Contributed by NM,
       11-Oct-2004.) */

theorem ceqsexg (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∃ x ( x = A ∧ ph ) ↔ ps ) ) ;;
}

proof of ceqsexg {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfe1 () |- F/ x ∃ x ( x = A ∧ ph ) ;;
	step 3 : wff = nfbi (step 2, hyp 1) |- F/ x ( ∃ x ( x = A ∧ ph ) ↔ ps ) ;;
	step 4 : wff = ceqex () |- ( x = A → ( ph ↔ ∃ x ( x = A ∧ ph ) ) ) ;;
	step 5 : wff = bibi12d (step 4, hyp 2) |- ( x = A → ( ( ph ↔ ph ) ↔ ( ∃ x ( x = A ∧ ph ) ↔ ps ) ) ) ;;
	step 6 : wff = biid () |- ( ph ↔ ph ) ;;
	step 7 : wff = vtoclgf (step 1, step 3, step 5, step 6) |- ( A ∈ V → ( ∃ x ( x = A ∧ ph ) ↔ ps ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Elimination of an existential quantifier, using implicit substitution.
       (Contributed by NM, 29-Dec-1996.) */

theorem ceqsexgv (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( ∃ x ( x = A ∧ ph ) ↔ ps ) ) ;;
}

proof of ceqsexgv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = ceqsexg (step 1, hyp 1) |- ( A ∈ V → ( ∃ x ( x = A ∧ ph ) ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Elimination of a restricted existential quantifier, using implicit
       substitution.  (Contributed by NM, 30-Apr-2004.) */

theorem ceqsrexv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ps ) ) ;;
}

proof of ceqsrexv {
	step 1 : wff = df-rex () |- ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ∃ x ( x ∈ B ∧ ( x = A ∧ ph ) ) ) ;;
	step 2 : wff = an12 () |- ( ( x = A ∧ ( x ∈ B ∧ ph ) ) ↔ ( x ∈ B ∧ ( x = A ∧ ph ) ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x ( x = A ∧ ( x ∈ B ∧ ph ) ) ↔ ∃ x ( x ∈ B ∧ ( x = A ∧ ph ) ) ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ∃ x ( x = A ∧ ( x ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 6 : wff = anbi12d (step 5, hyp 1) |- ( x = A → ( ( x ∈ B ∧ ph ) ↔ ( A ∈ B ∧ ps ) ) ) ;;
	step 7 : wff = ceqsexgv (step 6) |- ( A ∈ B → ( ∃ x ( x = A ∧ ( x ∈ B ∧ ph ) ) ↔ ( A ∈ B ∧ ps ) ) ) ;;
	step 8 : wff = bianabs (step 7) |- ( A ∈ B → ( ∃ x ( x = A ∧ ( x ∈ B ∧ ph ) ) ↔ ps ) ) ;;
	step 9 : wff = syl5bb (step 4, step 8) |- ( A ∈ B → ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Elimination of a restricted existential quantifier, using implicit
       substitution.  (Contributed by Mario Carneiro, 14-Mar-2014.) */

theorem ceqsrexbv (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ( A ∈ B ∧ ps ) ) ;;
}

proof of ceqsrexbv {
	step 1 : wff = r19.42v () |- ( ∃ x ∈ B ( A ∈ B ∧ ( x = A ∧ ph ) ) ↔ ( A ∈ B ∧ ∃ x ∈ B ( x = A ∧ ph ) ) ) ;;
	step 2 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 3 : wff = adantr (step 2) |- ( ( x = A ∧ ph ) → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 4 : wff = pm5.32ri (step 3) |- ( ( x ∈ B ∧ ( x = A ∧ ph ) ) ↔ ( A ∈ B ∧ ( x = A ∧ ph ) ) ) ;;
	step 5 : wff = bicomi (step 4) |- ( ( A ∈ B ∧ ( x = A ∧ ph ) ) ↔ ( x ∈ B ∧ ( x = A ∧ ph ) ) ) ;;
	step 6 : wff = baib (step 5) |- ( x ∈ B → ( ( A ∈ B ∧ ( x = A ∧ ph ) ) ↔ ( x = A ∧ ph ) ) ) ;;
	step 7 : wff = rexbiia (step 6) |- ( ∃ x ∈ B ( A ∈ B ∧ ( x = A ∧ ph ) ) ↔ ∃ x ∈ B ( x = A ∧ ph ) ) ;;
	step 8 : wff = ceqsrexv (hyp 1) |- ( A ∈ B → ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ps ) ) ;;
	step 9 : wff = pm5.32i (step 8) |- ( ( A ∈ B ∧ ∃ x ∈ B ( x = A ∧ ph ) ) ↔ ( A ∈ B ∧ ps ) ) ;;
	step 10 : wff = 3bitr3i (step 1, step 7, step 9) |- ( ∃ x ∈ B ( x = A ∧ ph ) ↔ ( A ∈ B ∧ ps ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Elimination of a restricted existential quantifier, using implicit
       substitution.  (Contributed by NM, 29-Oct-2005.) */

theorem ceqsrex2v (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class, B : class, C : class, D : class) disjointed(x y A, x y B, x C, x y D, x ps, y ch) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( y = B → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ C ∧ B ∈ D ) → ( ∃ x ∈ C ∃ y ∈ D ( ( x = A ∧ y = B ) ∧ ph ) ↔ ch ) ) ;;
}

proof of ceqsrex2v {
	step 1 : wff = anass () |- ( ( ( x = A ∧ y = B ) ∧ ph ) ↔ ( x = A ∧ ( y = B ∧ ph ) ) ) ;;
	step 2 : wff = rexbii (step 1) |- ( ∃ y ∈ D ( ( x = A ∧ y = B ) ∧ ph ) ↔ ∃ y ∈ D ( x = A ∧ ( y = B ∧ ph ) ) ) ;;
	step 3 : wff = r19.42v () |- ( ∃ y ∈ D ( x = A ∧ ( y = B ∧ ph ) ) ↔ ( x = A ∧ ∃ y ∈ D ( y = B ∧ ph ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ y ∈ D ( ( x = A ∧ y = B ) ∧ ph ) ↔ ( x = A ∧ ∃ y ∈ D ( y = B ∧ ph ) ) ) ;;
	step 5 : wff = rexbii (step 4) |- ( ∃ x ∈ C ∃ y ∈ D ( ( x = A ∧ y = B ) ∧ ph ) ↔ ∃ x ∈ C ( x = A ∧ ∃ y ∈ D ( y = B ∧ ph ) ) ) ;;
	step 6 : wff = anbi2d (hyp 1) |- ( x = A → ( ( y = B ∧ ph ) ↔ ( y = B ∧ ps ) ) ) ;;
	step 7 : wff = rexbidv (step 6) |- ( x = A → ( ∃ y ∈ D ( y = B ∧ ph ) ↔ ∃ y ∈ D ( y = B ∧ ps ) ) ) ;;
	step 8 : wff = ceqsrexv (step 7) |- ( A ∈ C → ( ∃ x ∈ C ( x = A ∧ ∃ y ∈ D ( y = B ∧ ph ) ) ↔ ∃ y ∈ D ( y = B ∧ ps ) ) ) ;;
	step 9 : wff = syl5bb (step 5, step 8) |- ( A ∈ C → ( ∃ x ∈ C ∃ y ∈ D ( ( x = A ∧ y = B ) ∧ ph ) ↔ ∃ y ∈ D ( y = B ∧ ps ) ) ) ;;
	step 10 : wff = ceqsrexv (hyp 2) |- ( B ∈ D → ( ∃ y ∈ D ( y = B ∧ ps ) ↔ ch ) ) ;;
	step 11 : wff = sylan9bb (step 9, step 10) |- ( ( A ∈ C ∧ B ∈ D ) → ( ∃ x ∈ C ∃ y ∈ D ( ( x = A ∧ y = B ) ∧ ph ) ↔ ch ) ) ;;
	qed prop 1 = step 11 ;;
}

/* An alternate definition of class membership when the class is a set.
       (Contributed by NM, 18-Aug-1993.) */

theorem clel2 (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B ↔ ∀ x ( x = A → x ∈ B ) ) ;;
}

proof of clel2 {
	step 1 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 2 : wff = ceqsalv (hyp 1, step 1) |- ( ∀ x ( x = A → x ∈ B ) ↔ A ∈ B ) ;;
	step 3 : wff = bicomi (step 2) |- ( A ∈ B ↔ ∀ x ( x = A → x ∈ B ) ) ;;
	qed prop 1 = step 3 ;;
}

/* An alternate definition of class membership when the class is a set.
       (Contributed by NM, 13-Aug-2005.) */

theorem clel3g (x : set, A : class, B : class, V : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( B ∈ V → ( A ∈ B ↔ ∃ x ( x = B ∧ A ∈ x ) ) ) ;;
}

proof of clel3g {
	step 1 : wff = eleq2 () |- ( x = B → ( A ∈ x ↔ A ∈ B ) ) ;;
	step 2 : wff = ceqsexgv (step 1) |- ( B ∈ V → ( ∃ x ( x = B ∧ A ∈ x ) ↔ A ∈ B ) ) ;;
	step 3 : wff = bicomd (step 2) |- ( B ∈ V → ( A ∈ B ↔ ∃ x ( x = B ∧ A ∈ x ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* An alternate definition of class membership when the class is a set.
       (Contributed by NM, 18-Aug-1993.) */

theorem clel3 (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B ↔ ∃ x ( x = B ∧ A ∈ x ) ) ;;
}

proof of clel3 {
	step 1 : wff = clel3g () |- ( B ∈ _V → ( A ∈ B ↔ ∃ x ( x = B ∧ A ∈ x ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ B ↔ ∃ x ( x = B ∧ A ∈ x ) ) ;;
	qed prop 1 = step 2 ;;
}

/* An alternate definition of class membership when the class is a set.
       (Contributed by NM, 18-Aug-1993.) */

theorem clel4 (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B ↔ ∀ x ( x = B → A ∈ x ) ) ;;
}

proof of clel4 {
	step 1 : wff = eleq2 () |- ( x = B → ( A ∈ x ↔ A ∈ B ) ) ;;
	step 2 : wff = ceqsalv (hyp 1, step 1) |- ( ∀ x ( x = B → A ∈ x ) ↔ A ∈ B ) ;;
	step 3 : wff = bicomi (step 2) |- ( A ∈ B ↔ ∀ x ( x = B → A ∈ x ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Compare theorem *13.183 in [WhiteheadRussell] p. 178.  Only ` A ` is
       required to be a set.  (Contributed by Andrew Salmon, 3-Jun-2011.) */

theorem pm13.183 (z : set, A : class, B : class, V : class) disjointed(y A z, y B z) {
	prop 1 : wff = |- ( A ∈ V → ( A = B ↔ ∀ z ( z = A ↔ z = B ) ) ) ;;
}

proof of pm13.183 {
	var y : set;;
	step 1 : wff = eqeq1 () |- ( y = A → ( y = B ↔ A = B ) ) ;;
	step 2 : wff = eqeq2 () |- ( y = A → ( z = y ↔ z = A ) ) ;;
	step 3 : wff = bibi1d (step 2) |- ( y = A → ( ( z = y ↔ z = B ) ↔ ( z = A ↔ z = B ) ) ) ;;
	step 4 : wff = albidv (step 3) |- ( y = A → ( ∀ z ( z = y ↔ z = B ) ↔ ∀ z ( z = A ↔ z = B ) ) ) ;;
	step 5 : wff = eqeq2 () |- ( y = B → ( z = y ↔ z = B ) ) ;;
	step 6 : wff = alrimiv (step 5) |- ( y = B → ∀ z ( z = y ↔ z = B ) ) ;;
	step 7 : wff = stdpc4 () |- ( ∀ z ( z = y ↔ z = B ) → [ y / z ] ( z = y ↔ z = B ) ) ;;
	step 8 : wff = sbbi () |- ( [ y / z ] ( z = y ↔ z = B ) ↔ ( [ y / z ] z = y ↔ [ y / z ] z = B ) ) ;;
	step 9 : wff = eqsb3 () |- ( [ y / z ] z = B ↔ y = B ) ;;
	step 10 : wff = bibi2i (step 9) |- ( ( [ y / z ] z = y ↔ [ y / z ] z = B ) ↔ ( [ y / z ] z = y ↔ y = B ) ) ;;
	step 11 : wff = equsb1 () |- [ y / z ] z = y ;;
	step 12 : wff = bi1 () |- ( ( [ y / z ] z = y ↔ y = B ) → ( [ y / z ] z = y → y = B ) ) ;;
	step 13 : wff = mpi (step 11, step 12) |- ( ( [ y / z ] z = y ↔ y = B ) → y = B ) ;;
	step 14 : wff = sylbi (step 10, step 13) |- ( ( [ y / z ] z = y ↔ [ y / z ] z = B ) → y = B ) ;;
	step 15 : wff = sylbi (step 8, step 14) |- ( [ y / z ] ( z = y ↔ z = B ) → y = B ) ;;
	step 16 : wff = syl (step 7, step 15) |- ( ∀ z ( z = y ↔ z = B ) → y = B ) ;;
	step 17 : wff = impbii (step 6, step 16) |- ( y = B ↔ ∀ z ( z = y ↔ z = B ) ) ;;
	step 18 : wff = vtoclbg (step 1, step 4, step 17) |- ( A ∈ V → ( A = B ↔ ∀ z ( z = A ↔ z = B ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Restricted quantifier version of Theorem 19.3 of [Margaris] p. 89.  We
       don't need the non-empty class condition of ~ r19.3rzv when there is an
       outer quantifier.  (Contributed by NM, 25-Oct-2012.) */

theorem rr19.3v (ph : wff, x : set, y : set, A : class) disjointed(y A, x y, y ph) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ A ph ↔ ∀ x ∈ A ph ) ;;
}

proof of rr19.3v {
	step 1 : wff = biidd () |- ( y = x → ( ph ↔ ph ) ) ;;
	step 2 : wff = rspcv (step 1) |- ( x ∈ A → ( ∀ y ∈ A ph → ph ) ) ;;
	step 3 : wff = ralimia (step 2) |- ( ∀ x ∈ A ∀ y ∈ A ph → ∀ x ∈ A ph ) ;;
	step 4 : wff = ax-1 () |- ( ph → ( y ∈ A → ph ) ) ;;
	step 5 : wff = ralrimiv (step 4) |- ( ph → ∀ y ∈ A ph ) ;;
	step 6 : wff = ralimi (step 5) |- ( ∀ x ∈ A ph → ∀ x ∈ A ∀ y ∈ A ph ) ;;
	step 7 : wff = impbii (step 3, step 6) |- ( ∀ x ∈ A ∀ y ∈ A ph ↔ ∀ x ∈ A ph ) ;;
	qed prop 1 = step 7 ;;
}

/* Restricted quantifier version of Theorem 19.28 of [Margaris] p. 90.  We
       don't need the non-empty class condition of ~ r19.28zv when there is an
       outer quantifier.  (Contributed by NM, 29-Oct-2012.) */

theorem rr19.28v (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(y A, x y, y ph) {
	prop 1 : wff = |- ( ∀ x ∈ A ∀ y ∈ A ( ph ∧ ps ) ↔ ∀ x ∈ A ( ph ∧ ∀ y ∈ A ps ) ) ;;
}

proof of rr19.28v {
	step 1 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 2 : wff = ralimi (step 1) |- ( ∀ y ∈ A ( ph ∧ ps ) → ∀ y ∈ A ph ) ;;
	step 3 : wff = biidd () |- ( y = x → ( ph ↔ ph ) ) ;;
	step 4 : wff = rspcv (step 3) |- ( x ∈ A → ( ∀ y ∈ A ph → ph ) ) ;;
	step 5 : wff = syl5 (step 2, step 4) |- ( x ∈ A → ( ∀ y ∈ A ( ph ∧ ps ) → ph ) ) ;;
	step 6 : wff = simpr () |- ( ( ph ∧ ps ) → ps ) ;;
	step 7 : wff = ralimi (step 6) |- ( ∀ y ∈ A ( ph ∧ ps ) → ∀ y ∈ A ps ) ;;
	step 8 : wff = a1i (step 7) |- ( x ∈ A → ( ∀ y ∈ A ( ph ∧ ps ) → ∀ y ∈ A ps ) ) ;;
	step 9 : wff = jcad (step 5, step 8) |- ( x ∈ A → ( ∀ y ∈ A ( ph ∧ ps ) → ( ph ∧ ∀ y ∈ A ps ) ) ) ;;
	step 10 : wff = ralimia (step 9) |- ( ∀ x ∈ A ∀ y ∈ A ( ph ∧ ps ) → ∀ x ∈ A ( ph ∧ ∀ y ∈ A ps ) ) ;;
	step 11 : wff = r19.28av () |- ( ( ph ∧ ∀ y ∈ A ps ) → ∀ y ∈ A ( ph ∧ ps ) ) ;;
	step 12 : wff = ralimi (step 11) |- ( ∀ x ∈ A ( ph ∧ ∀ y ∈ A ps ) → ∀ x ∈ A ∀ y ∈ A ( ph ∧ ps ) ) ;;
	step 13 : wff = impbii (step 10, step 12) |- ( ∀ x ∈ A ∀ y ∈ A ( ph ∧ ps ) ↔ ∀ x ∈ A ( ph ∧ ∀ y ∈ A ps ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Membership in a class abstraction, using implicit substitution.  (Closed
       theorem version of ~ elabg .)  (Contributed by NM, 7-Nov-2005.)  (Proof
       shortened by Andrew Salmon, 8-Jun-2011.) */

theorem elabgt (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x ps) {
	prop 1 : wff = |- ( ( A ∈ B ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
}

proof of elabgt {
	step 1 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 2 : wff = eleq1 () |- ( x = A → ( x ∈ { x | ph } ↔ A ∈ { x | ph } ) ) ;;
	step 3 : wff = syl5bbr (step 1, step 2) |- ( x = A → ( ph ↔ A ∈ { x | ph } ) ) ;;
	step 4 : wff = bibi1d (step 3) |- ( x = A → ( ( ph ↔ ps ) ↔ ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 5 : wff = biimpd (step 4) |- ( x = A → ( ( ph ↔ ps ) → ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 6 : wff = a2i (step 5) |- ( ( x = A → ( ph ↔ ps ) ) → ( x = A → ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 7 : wff = alimi (step 6) |- ( ∀ x ( x = A → ( ph ↔ ps ) ) → ∀ x ( x = A → ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 8 : wff = nfcv () |- F/_ x A ;;
	step 9 : wff = nfab1 () |- F/_ x { x | ph } ;;
	step 10 : wff = nfel2 (step 9) |- F/ x A ∈ { x | ph } ;;
	step 11 : wff = nfv () |- F/ x ps ;;
	step 12 : wff = nfbi (step 10, step 11) |- F/ x ( A ∈ { x | ph } ↔ ps ) ;;
	step 13 : wff = pm5.5 () |- ( x = A → ( ( x = A → ( A ∈ { x | ph } ↔ ps ) ) ↔ ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 14 : wff = spcgf (step 8, step 12, step 13) |- ( A ∈ B → ( ∀ x ( x = A → ( A ∈ { x | ph } ↔ ps ) ) → ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 15 : wff = imp (step 14) |- ( ( A ∈ B ∧ ∀ x ( x = A → ( A ∈ { x | ph } ↔ ps ) ) ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 16 : wff = sylan2 (step 7, step 15) |- ( ( A ∈ B ∧ ∀ x ( x = A → ( ph ↔ ps ) ) ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Membership in a class abstraction, using implicit substitution.  Compare
       Theorem 6.13 of [Quine] p. 44.  This version has bound-variable
       hypotheses in place of distinct variable restrictions.  (Contributed by
       NM, 21-Sep-2003.)  (Revised by Mario Carneiro, 12-Oct-2016.) */

theorem elabgf (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ( A ∈ { x | ph } ↔ ps ) ) ;;
}

proof of elabgf {
	step 1 : wff = nfab1 () |- F/_ x { x | ph } ;;
	step 2 : wff = nfel (hyp 1, step 1) |- F/ x A ∈ { x | ph } ;;
	step 3 : wff = nfbi (step 2, hyp 2) |- F/ x ( A ∈ { x | ph } ↔ ps ) ;;
	step 4 : wff = eleq1 () |- ( x = A → ( x ∈ { x | ph } ↔ A ∈ { x | ph } ) ) ;;
	step 5 : wff = bibi12d (step 4, hyp 3) |- ( x = A → ( ( x ∈ { x | ph } ↔ ph ) ↔ ( A ∈ { x | ph } ↔ ps ) ) ) ;;
	step 6 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 7 : wff = vtoclgf (hyp 1, step 3, step 5, step 6) |- ( A ∈ B → ( A ∈ { x | ph } ↔ ps ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Membership in a class abstraction, using implicit substitution.
       (Contributed by NM, 1-Aug-1994.)  (Revised by Mario Carneiro,
       12-Oct-2016.) */

theorem elabf (ph : wff, ps : wff, x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- A ∈ _V ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { x | ph } ↔ ps ) ;;
}

proof of elabf {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = elabgf (step 1, hyp 1, hyp 3) |- ( A ∈ _V → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 3 : wff = ax-mp (hyp 2, step 2) |- ( A ∈ { x | ph } ↔ ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in a class abstraction, using implicit substitution.  Compare
       Theorem 6.13 of [Quine] p. 44.  (Contributed by NM, 1-Aug-1994.) */

theorem elab (ph : wff, ps : wff, x : set, A : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { x | ph } ↔ ps ) ;;
}

proof of elab {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = elabf (step 1, hyp 1, hyp 2) |- ( A ∈ { x | ph } ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Membership in a class abstraction, using implicit substitution.  Compare
       Theorem 6.13 of [Quine] p. 44.  (Contributed by NM, 14-Apr-1995.) */

theorem elabg (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( A ∈ { x | ph } ↔ ps ) ) ;;
}

proof of elabg {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = elabgf (step 1, step 2, hyp 1) |- ( A ∈ V → ( A ∈ { x | ph } ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in a class abstraction, using implicit substitution.
       (Contributed by NM, 13-Sep-1995.) */

theorem elab2g (ph : wff, ps : wff, x : set, A : class, B : class, V : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- B = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ( A ∈ B ↔ ps ) ) ;;
}

proof of elab2g {
	step 1 : wff = eleq2i (hyp 2) |- ( A ∈ B ↔ A ∈ { x | ph } ) ;;
	step 2 : wff = elabg (hyp 1) |- ( A ∈ V → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 3 : wff = syl5bb (step 1, step 2) |- ( A ∈ V → ( A ∈ B ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in a class abstraction, using implicit substitution.
       (Contributed by NM, 13-Sep-1995.) */

theorem elab2 (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- B = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B ↔ ps ) ;;
}

proof of elab2 {
	step 1 : wff = elab2g (hyp 2, hyp 3) |- ( A ∈ _V → ( A ∈ B ↔ ps ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ B ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Membership in a class abstraction, using implicit substitution.
       (Contributed by NM, 17-Oct-2012.) */

theorem elab4g (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- B = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B ↔ ( A ∈ _V ∧ ps ) ) ;;
}

proof of elab4g {
	step 1 : wff = elex () |- ( A ∈ B → A ∈ _V ) ;;
	step 2 : wff = elab2g (hyp 1, hyp 2) |- ( A ∈ _V → ( A ∈ B ↔ ps ) ) ;;
	step 3 : wff = biadan2 (step 1, step 2) |- ( A ∈ B ↔ ( A ∈ _V ∧ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in a class abstraction, with a weaker antecedent than
       ~ elabgf .  (Contributed by NM, 6-Sep-2011.) */

theorem elab3gf (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps → A ∈ B ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
}

proof of elab3gf {
	step 1 : wff = elabgf (hyp 1, hyp 2, hyp 3) |- ( A ∈ { x | ph } → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 2 : wff = ibi (step 1) |- ( A ∈ { x | ph } → ps ) ;;
	step 3 : wff = pm2.21 () |- ( ¬ ps → ( ps → A ∈ { x | ph } ) ) ;;
	step 4 : wff = impbid2 (step 2, step 3) |- ( ¬ ps → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 5 : wff = elabgf (hyp 1, hyp 2, hyp 3) |- ( A ∈ B → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 6 : wff = ja (step 4, step 5) |- ( ( ps → A ∈ B ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Membership in a class abstraction, with a weaker antecedent than
       ~ elabg .  (Contributed by NM, 29-Aug-2006.) */

theorem elab3g (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps → A ∈ B ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
}

proof of elab3g {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = elab3gf (step 1, step 2, hyp 1) |- ( ( ps → A ∈ B ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in a class abstraction using implicit substitution.
       (Contributed by NM, 10-Nov-2000.) */

theorem elab3 (ph : wff, ps : wff, x : set, A : class) disjointed(x ps, x A) {
	hyp 1 : wff = |- ( ps → A ∈ _V ) ;;
	hyp 2 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { x | ph } ↔ ps ) ;;
}

proof of elab3 {
	step 1 : wff = elab3g (hyp 2) |- ( ( ps → A ∈ _V ) → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ { x | ph } ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Membership in a restricted class abstraction, using implicit
       substitution.  This version has bound-variable hypotheses in place of
       distinct variable restrictions.  (Contributed by NM, 21-Sep-2003.) */

theorem elrabf (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	hyp 3 : wff = |- F/ x ps ;;
	hyp 4 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
}

proof of elrabf {
	step 1 : wff = elex () |- ( A ∈ { x ∈ B | ph } → A ∈ _V ) ;;
	step 2 : wff = elex () |- ( A ∈ B → A ∈ _V ) ;;
	step 3 : wff = adantr (step 2) |- ( ( A ∈ B ∧ ps ) → A ∈ _V ) ;;
	step 4 : wff = df-rab () |- { x ∈ B | ph } = { x | ( x ∈ B ∧ ph ) } ;;
	step 5 : wff = eleq2i (step 4) |- ( A ∈ { x ∈ B | ph } ↔ A ∈ { x | ( x ∈ B ∧ ph ) } ) ;;
	step 6 : wff = nfel (hyp 1, hyp 2) |- F/ x A ∈ B ;;
	step 7 : wff = nfan (step 6, hyp 3) |- F/ x ( A ∈ B ∧ ps ) ;;
	step 8 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 9 : wff = anbi12d (step 8, hyp 4) |- ( x = A → ( ( x ∈ B ∧ ph ) ↔ ( A ∈ B ∧ ps ) ) ) ;;
	step 10 : wff = elabgf (hyp 1, step 7, step 9) |- ( A ∈ _V → ( A ∈ { x | ( x ∈ B ∧ ph ) } ↔ ( A ∈ B ∧ ps ) ) ) ;;
	step 11 : wff = syl5bb (step 5, step 10) |- ( A ∈ _V → ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ) ;;
	step 12 : wff = pm5.21nii (step 1, step 3, step 11) |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Membership in a restricted class abstraction, using implicit
       substitution.  (Contributed by NM, 21-May-1999.) */

theorem elrab (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x ps, x A, x B) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
}

proof of elrab {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfcv () |- F/_ x B ;;
	step 3 : wff = nfv () |- F/ x ps ;;
	step 4 : wff = elrabf (step 1, step 2, step 3, hyp 1) |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Membership in a restricted class abstraction, using implicit
       substitution.  (Contributed by NM, 5-Oct-2006.) */

theorem elrab3 (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x ps, x A, x B) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ B → ( A ∈ { x ∈ B | ph } ↔ ps ) ) ;;
}

proof of elrab3 {
	step 1 : wff = elrab (hyp 1) |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
	step 2 : wff = baib (step 1) |- ( A ∈ B → ( A ∈ { x ∈ B | ph } ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Membership in a class abstraction, using implicit substitution.
       (Contributed by NM, 2-Nov-2006.) */

theorem elrab2 (ph : wff, ps : wff, x : set, A : class, B : class, C : class) disjointed(x ps, x A, x B) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- C = { x ∈ B | ph } ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ C ↔ ( A ∈ B ∧ ps ) ) ;;
}

proof of elrab2 {
	step 1 : wff = eleq2i (hyp 2) |- ( A ∈ C ↔ A ∈ { x ∈ B | ph } ) ;;
	step 2 : wff = elrab (hyp 1) |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A ∈ C ↔ ( A ∈ B ∧ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Universal quantification over a class abstraction.  (Contributed by Jeff
       Madsen, 10-Jun-2010.) */

theorem ralab (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x y, y ps) {
	hyp 1 : wff = |- ( y = x → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ { y | ph } ch ↔ ∀ x ( ps → ch ) ) ;;
}

proof of ralab {
	step 1 : wff = df-ral () |- ( ∀ x ∈ { y | ph } ch ↔ ∀ x ( x ∈ { y | ph } → ch ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = elab (step 2, hyp 1) |- ( x ∈ { y | ph } ↔ ps ) ;;
	step 4 : wff = imbi1i (step 3) |- ( ( x ∈ { y | ph } → ch ) ↔ ( ps → ch ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ x ( x ∈ { y | ph } → ch ) ↔ ∀ x ( ps → ch ) ) ;;
	step 6 : wff = bitri (step 1, step 5) |- ( ∀ x ∈ { y | ph } ch ↔ ∀ x ( ps → ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Universal quantification over a restricted class abstraction.
       (Contributed by Jeff Madsen, 10-Jun-2010.) */

theorem ralrab (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(x y, y A, y ps) {
	hyp 1 : wff = |- ( y = x → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ { y ∈ A | ph } ch ↔ ∀ x ∈ A ( ps → ch ) ) ;;
}

proof of ralrab {
	step 1 : wff = elrab (hyp 1) |- ( x ∈ { y ∈ A | ph } ↔ ( x ∈ A ∧ ps ) ) ;;
	step 2 : wff = imbi1i (step 1) |- ( ( x ∈ { y ∈ A | ph } → ch ) ↔ ( ( x ∈ A ∧ ps ) → ch ) ) ;;
	step 3 : wff = impexp () |- ( ( ( x ∈ A ∧ ps ) → ch ) ↔ ( x ∈ A → ( ps → ch ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ( x ∈ { y ∈ A | ph } → ch ) ↔ ( x ∈ A → ( ps → ch ) ) ) ;;
	step 5 : wff = ralbii2 (step 4) |- ( ∀ x ∈ { y ∈ A | ph } ch ↔ ∀ x ∈ A ( ps → ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Existential quantification over a class abstraction.  (Contributed by
       Mario Carneiro, 23-Jan-2014.)  (Revised by Mario Carneiro,
       3-Sep-2015.) */

theorem rexab (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x y, y ps) {
	hyp 1 : wff = |- ( y = x → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ { y | ph } ch ↔ ∃ x ( ps ∧ ch ) ) ;;
}

proof of rexab {
	step 1 : wff = df-rex () |- ( ∃ x ∈ { y | ph } ch ↔ ∃ x ( x ∈ { y | ph } ∧ ch ) ) ;;
	step 2 : wff = vex () |- x ∈ _V ;;
	step 3 : wff = elab (step 2, hyp 1) |- ( x ∈ { y | ph } ↔ ps ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( x ∈ { y | ph } ∧ ch ) ↔ ( ps ∧ ch ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ x ( x ∈ { y | ph } ∧ ch ) ↔ ∃ x ( ps ∧ ch ) ) ;;
	step 6 : wff = bitri (step 1, step 5) |- ( ∃ x ∈ { y | ph } ch ↔ ∃ x ( ps ∧ ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Existential quantification over a class abstraction.  (Contributed by
       Jeff Madsen, 17-Jun-2011.)  (Revised by Mario Carneiro, 3-Sep-2015.) */

theorem rexrab (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(x y, y A, y ps) {
	hyp 1 : wff = |- ( y = x → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ { y ∈ A | ph } ch ↔ ∃ x ∈ A ( ps ∧ ch ) ) ;;
}

proof of rexrab {
	step 1 : wff = elrab (hyp 1) |- ( x ∈ { y ∈ A | ph } ↔ ( x ∈ A ∧ ps ) ) ;;
	step 2 : wff = anbi1i (step 1) |- ( ( x ∈ { y ∈ A | ph } ∧ ch ) ↔ ( ( x ∈ A ∧ ps ) ∧ ch ) ) ;;
	step 3 : wff = anass () |- ( ( ( x ∈ A ∧ ps ) ∧ ch ) ↔ ( x ∈ A ∧ ( ps ∧ ch ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ( x ∈ { y ∈ A | ph } ∧ ch ) ↔ ( x ∈ A ∧ ( ps ∧ ch ) ) ) ;;
	step 5 : wff = rexbii2 (step 4) |- ( ∃ x ∈ { y ∈ A | ph } ch ↔ ∃ x ∈ A ( ps ∧ ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Universal quantification over a class abstraction.  (Contributed by
       Mario Carneiro, 3-Sep-2015.) */

theorem ralab2 (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x y, x ch, x ph, y ps) {
	hyp 1 : wff = |- ( x = y → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ { y | ph } ps ↔ ∀ y ( ph → ch ) ) ;;
}

proof of ralab2 {
	step 1 : wff = df-ral () |- ( ∀ x ∈ { y | ph } ps ↔ ∀ x ( x ∈ { y | ph } → ps ) ) ;;
	step 2 : wff = nfsab1 () |- F/ y x ∈ { y | ph } ;;
	step 3 : wff = nfv () |- F/ y ps ;;
	step 4 : wff = nfim (step 2, step 3) |- F/ y ( x ∈ { y | ph } → ps ) ;;
	step 5 : wff = nfv () |- F/ x ( ph → ch ) ;;
	step 6 : wff = eleq1 () |- ( x = y → ( x ∈ { y | ph } ↔ y ∈ { y | ph } ) ) ;;
	step 7 : wff = abid () |- ( y ∈ { y | ph } ↔ ph ) ;;
	step 8 : wff = syl6bb (step 6, step 7) |- ( x = y → ( x ∈ { y | ph } ↔ ph ) ) ;;
	step 9 : wff = imbi12d (step 8, hyp 1) |- ( x = y → ( ( x ∈ { y | ph } → ps ) ↔ ( ph → ch ) ) ) ;;
	step 10 : wff = cbval (step 4, step 5, step 9) |- ( ∀ x ( x ∈ { y | ph } → ps ) ↔ ∀ y ( ph → ch ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( ∀ x ∈ { y | ph } ps ↔ ∀ y ( ph → ch ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Universal quantification over a restricted class abstraction.
       (Contributed by Mario Carneiro, 3-Sep-2015.) */

theorem ralrab2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(x y, x A, x ch, x ph, y ps) {
	hyp 1 : wff = |- ( x = y → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∈ { y ∈ A | ph } ps ↔ ∀ y ∈ A ( ph → ch ) ) ;;
}

proof of ralrab2 {
	step 1 : wff = df-rab () |- { y ∈ A | ph } = { y | ( y ∈ A ∧ ph ) } ;;
	step 2 : wff = raleqi (step 1) |- ( ∀ x ∈ { y ∈ A | ph } ps ↔ ∀ x ∈ { y | ( y ∈ A ∧ ph ) } ps ) ;;
	step 3 : wff = ralab2 (hyp 1) |- ( ∀ x ∈ { y | ( y ∈ A ∧ ph ) } ps ↔ ∀ y ( ( y ∈ A ∧ ph ) → ch ) ) ;;
	step 4 : wff = impexp () |- ( ( ( y ∈ A ∧ ph ) → ch ) ↔ ( y ∈ A → ( ph → ch ) ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ y ( ( y ∈ A ∧ ph ) → ch ) ↔ ∀ y ( y ∈ A → ( ph → ch ) ) ) ;;
	step 6 : wff = df-ral () |- ( ∀ y ∈ A ( ph → ch ) ↔ ∀ y ( y ∈ A → ( ph → ch ) ) ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ∀ y ( ( y ∈ A ∧ ph ) → ch ) ↔ ∀ y ∈ A ( ph → ch ) ) ;;
	step 8 : wff = 3bitri (step 2, step 3, step 7) |- ( ∀ x ∈ { y ∈ A | ph } ps ↔ ∀ y ∈ A ( ph → ch ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Existential quantification over a class abstraction.  (Contributed by
       Mario Carneiro, 3-Sep-2015.) */

theorem rexab2 (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x y, x ch, x ph, y ps) {
	hyp 1 : wff = |- ( x = y → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ { y | ph } ps ↔ ∃ y ( ph ∧ ch ) ) ;;
}

proof of rexab2 {
	step 1 : wff = df-rex () |- ( ∃ x ∈ { y | ph } ps ↔ ∃ x ( x ∈ { y | ph } ∧ ps ) ) ;;
	step 2 : wff = nfsab1 () |- F/ y x ∈ { y | ph } ;;
	step 3 : wff = nfv () |- F/ y ps ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ y ( x ∈ { y | ph } ∧ ps ) ;;
	step 5 : wff = nfv () |- F/ x ( ph ∧ ch ) ;;
	step 6 : wff = eleq1 () |- ( x = y → ( x ∈ { y | ph } ↔ y ∈ { y | ph } ) ) ;;
	step 7 : wff = abid () |- ( y ∈ { y | ph } ↔ ph ) ;;
	step 8 : wff = syl6bb (step 6, step 7) |- ( x = y → ( x ∈ { y | ph } ↔ ph ) ) ;;
	step 9 : wff = anbi12d (step 8, hyp 1) |- ( x = y → ( ( x ∈ { y | ph } ∧ ps ) ↔ ( ph ∧ ch ) ) ) ;;
	step 10 : wff = cbvex (step 4, step 5, step 9) |- ( ∃ x ( x ∈ { y | ph } ∧ ps ) ↔ ∃ y ( ph ∧ ch ) ) ;;
	step 11 : wff = bitri (step 1, step 10) |- ( ∃ x ∈ { y | ph } ps ↔ ∃ y ( ph ∧ ch ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Existential quantification over a class abstraction.  (Contributed by
       Mario Carneiro, 3-Sep-2015.) */

theorem rexrab2 (ph : wff, ps : wff, ch : wff, x : set, y : set, A : class) disjointed(x y, x A, x ch, x ph, y ps) {
	hyp 1 : wff = |- ( x = y → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∈ { y ∈ A | ph } ps ↔ ∃ y ∈ A ( ph ∧ ch ) ) ;;
}

proof of rexrab2 {
	step 1 : wff = df-rab () |- { y ∈ A | ph } = { y | ( y ∈ A ∧ ph ) } ;;
	step 2 : wff = rexeqi (step 1) |- ( ∃ x ∈ { y ∈ A | ph } ps ↔ ∃ x ∈ { y | ( y ∈ A ∧ ph ) } ps ) ;;
	step 3 : wff = rexab2 (hyp 1) |- ( ∃ x ∈ { y | ( y ∈ A ∧ ph ) } ps ↔ ∃ y ( ( y ∈ A ∧ ph ) ∧ ch ) ) ;;
	step 4 : wff = anass () |- ( ( ( y ∈ A ∧ ph ) ∧ ch ) ↔ ( y ∈ A ∧ ( ph ∧ ch ) ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ( ( y ∈ A ∧ ph ) ∧ ch ) ↔ ∃ y ( y ∈ A ∧ ( ph ∧ ch ) ) ) ;;
	step 6 : wff = df-rex () |- ( ∃ y ∈ A ( ph ∧ ch ) ↔ ∃ y ( y ∈ A ∧ ( ph ∧ ch ) ) ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ∃ y ( ( y ∈ A ∧ ph ) ∧ ch ) ↔ ∃ y ∈ A ( ph ∧ ch ) ) ;;
	step 8 : wff = 3bitri (step 2, step 3, step 7) |- ( ∃ x ∈ { y ∈ A | ph } ps ↔ ∃ y ∈ A ( ph ∧ ch ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Identity used to create closed-form versions of bound-variable
       hypothesis builders for class expressions.  (Contributed by NM,
       10-Nov-2005.)  (Proof shortened by Mario Carneiro, 12-Oct-2016.) */

theorem abidnf (x : set, z : set, A : class) disjointed(x z, A z) {
	prop 1 : wff = |- ( F/_ x A → { z | ∀ x z ∈ A } = A ) ;;
}

proof of abidnf {
	step 1 : wff = sp () |- ( ∀ x z ∈ A → z ∈ A ) ;;
	step 2 : wff = nfcr () |- ( F/_ x A → F/ x z ∈ A ) ;;
	step 3 : wff = nfrd (step 2) |- ( F/_ x A → ( z ∈ A → ∀ x z ∈ A ) ) ;;
	step 4 : wff = impbid2 (step 1, step 3) |- ( F/_ x A → ( ∀ x z ∈ A ↔ z ∈ A ) ) ;;
	step 5 : wff = abbi1dv (step 4) |- ( F/_ x A → { z | ∀ x z ∈ A } = A ) ;;
	qed prop 1 = step 5 ;;
}

/* A deduction theorem for converting the inference ` |- F/_ x A ` =>
       ` |- ph ` into a closed theorem.  Use ~ nfa1 and ~ nfab to eliminate the
       hypothesis of the substitution instance ` ps ` of the inference.  For
       converting the inference form into a deduction form, ~ abidnf is
       useful.  (Contributed by NM, 8-Dec-2006.) */

theorem dedhb (ph : wff, ps : wff, x : set, z : set, A : class) disjointed(x z, z A) {
	hyp 1 : wff = |- ( A = { z | ∀ x z ∈ A } → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ps ;;
	-----------------------
	prop 1 : wff = |- ( F/_ x A → ph ) ;;
}

proof of dedhb {
	step 1 : wff = abidnf () |- ( F/_ x A → { z | ∀ x z ∈ A } = A ) ;;
	step 2 : wff = eqcomd (step 1) |- ( F/_ x A → A = { z | ∀ x z ∈ A } ) ;;
	step 3 : wff = syl (step 2, hyp 1) |- ( F/_ x A → ( ph ↔ ps ) ) ;;
	step 4 : wff = mpbiri (hyp 2, step 3) |- ( F/_ x A → ph ) ;;
	qed prop 1 = step 4 ;;
}

/* A condition which implies existential uniqueness.  (Contributed by Jeff
       Hankins, 8-Sep-2009.) */

theorem eqeu (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(y ph, x y ps, x y A) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ B ∧ ps ∧ ∀ x ( ph → x = A ) ) → ∃! x ph ) ;;
}

proof of eqeu {
	var y : set;;
	step 1 : wff = spcegv (hyp 1) |- ( A ∈ B → ( ps → ∃ x ph ) ) ;;
	step 2 : wff = imp (step 1) |- ( ( A ∈ B ∧ ps ) → ∃ x ph ) ;;
	step 3 : wff = 3adant3 (step 2) |- ( ( A ∈ B ∧ ps ∧ ∀ x ( ph → x = A ) ) → ∃ x ph ) ;;
	step 4 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 5 : wff = imbi2d (step 4) |- ( y = A → ( ( ph → x = y ) ↔ ( ph → x = A ) ) ) ;;
	step 6 : wff = albidv (step 5) |- ( y = A → ( ∀ x ( ph → x = y ) ↔ ∀ x ( ph → x = A ) ) ) ;;
	step 7 : wff = spcegv (step 6) |- ( A ∈ B → ( ∀ x ( ph → x = A ) → ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 8 : wff = imp (step 7) |- ( ( A ∈ B ∧ ∀ x ( ph → x = A ) ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 9 : wff = 3adant2 (step 8) |- ( ( A ∈ B ∧ ps ∧ ∀ x ( ph → x = A ) ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 10 : wff = nfv () |- F/ y ph ;;
	step 11 : wff = eu3 (step 10) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 12 : wff = sylanbrc (step 3, step 9, step 11) |- ( ( A ∈ B ∧ ps ∧ ∀ x ( ph → x = A ) ) → ∃! x ph ) ;;
	qed prop 1 = step 12 ;;
}

/* Equality has existential uniqueness.  (Contributed by NM,
       25-Nov-1994.) */

theorem eueq (x : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( A ∈ _V ↔ ∃! x x = A ) ;;
}

proof of eueq {
	var y : set;;
	step 1 : wff = eqtr3 () |- ( ( x = A ∧ y = A ) → x = y ) ;;
	step 2 : wff = gen2 (step 1) |- ∀ x ∀ y ( ( x = A ∧ y = A ) → x = y ) ;;
	step 3 : wff = biantru (step 2) |- ( ∃ x x = A ↔ ( ∃ x x = A ∧ ∀ x ∀ y ( ( x = A ∧ y = A ) → x = y ) ) ) ;;
	step 4 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 5 : wff = eqeq1 () |- ( x = y → ( x = A ↔ y = A ) ) ;;
	step 6 : wff = eu4 (step 5) |- ( ∃! x x = A ↔ ( ∃ x x = A ∧ ∀ x ∀ y ( ( x = A ∧ y = A ) → x = y ) ) ) ;;
	step 7 : wff = 3bitr4i (step 3, step 4, step 6) |- ( A ∈ _V ↔ ∃! x x = A ) ;;
	qed prop 1 = step 7 ;;
}

/* Equality has existential uniqueness.  (Contributed by NM,
       5-Apr-1995.) */

theorem eueq1 (x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ∃! x x = A ;;
}

proof of eueq1 {
	step 1 : wff = eueq () |- ( A ∈ _V ↔ ∃! x x = A ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- ∃! x x = A ;;
	qed prop 1 = step 2 ;;
}

/* Equality has existential uniqueness (split into 2 cases).  (Contributed
       by NM, 5-Apr-1995.) */

theorem eueq2 (ph : wff, x : set, A : class, B : class) disjointed(x ph, x A, x B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ;;
}

proof of eueq2 {
	step 1 : wff = notnot1 () |- ( ph → ¬ ¬ ph ) ;;
	step 2 : wff = eueq1 (hyp 1) |- ∃! x x = A ;;
	step 3 : wff = euanv () |- ( ∃! x ( ph ∧ x = A ) ↔ ( ph ∧ ∃! x x = A ) ) ;;
	step 4 : wff = biimpri (step 3) |- ( ( ph ∧ ∃! x x = A ) → ∃! x ( ph ∧ x = A ) ) ;;
	step 5 : wff = mpan2 (step 2, step 4) |- ( ph → ∃! x ( ph ∧ x = A ) ) ;;
	step 6 : wff = euorv () |- ( ( ¬ ¬ ph ∧ ∃! x ( ph ∧ x = A ) ) → ∃! x ( ¬ ph ∨ ( ph ∧ x = A ) ) ) ;;
	step 7 : wff = syl2anc (step 1, step 5, step 6) |- ( ph → ∃! x ( ¬ ph ∨ ( ph ∧ x = A ) ) ) ;;
	step 8 : wff = orcom () |- ( ( ¬ ph ∨ ( ph ∧ x = A ) ) ↔ ( ( ph ∧ x = A ) ∨ ¬ ph ) ) ;;
	step 9 : wff = notnot1 () |- ( ph → ¬ ¬ ph ) ;;
	step 10 : wff = bianfd (step 9) |- ( ph → ( ¬ ph ↔ ( ¬ ph ∧ x = B ) ) ) ;;
	step 11 : wff = orbi2d (step 10) |- ( ph → ( ( ( ph ∧ x = A ) ∨ ¬ ph ) ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ) ;;
	step 12 : wff = syl5bb (step 8, step 11) |- ( ph → ( ( ¬ ph ∨ ( ph ∧ x = A ) ) ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ) ;;
	step 13 : wff = eubidv (step 12) |- ( ph → ( ∃! x ( ¬ ph ∨ ( ph ∧ x = A ) ) ↔ ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ) ;;
	step 14 : wff = mpbid (step 7, step 13) |- ( ph → ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ;;
	step 15 : wff = eueq1 (hyp 2) |- ∃! x x = B ;;
	step 16 : wff = euanv () |- ( ∃! x ( ¬ ph ∧ x = B ) ↔ ( ¬ ph ∧ ∃! x x = B ) ) ;;
	step 17 : wff = biimpri (step 16) |- ( ( ¬ ph ∧ ∃! x x = B ) → ∃! x ( ¬ ph ∧ x = B ) ) ;;
	step 18 : wff = mpan2 (step 15, step 17) |- ( ¬ ph → ∃! x ( ¬ ph ∧ x = B ) ) ;;
	step 19 : wff = euorv () |- ( ( ¬ ph ∧ ∃! x ( ¬ ph ∧ x = B ) ) → ∃! x ( ph ∨ ( ¬ ph ∧ x = B ) ) ) ;;
	step 20 : wff = mpdan (step 18, step 19) |- ( ¬ ph → ∃! x ( ph ∨ ( ¬ ph ∧ x = B ) ) ) ;;
	step 21 : wff = id () |- ( ¬ ph → ¬ ph ) ;;
	step 22 : wff = bianfd (step 21) |- ( ¬ ph → ( ph ↔ ( ph ∧ x = A ) ) ) ;;
	step 23 : wff = orbi1d (step 22) |- ( ¬ ph → ( ( ph ∨ ( ¬ ph ∧ x = B ) ) ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ) ;;
	step 24 : wff = eubidv (step 23) |- ( ¬ ph → ( ∃! x ( ph ∨ ( ¬ ph ∧ x = B ) ) ↔ ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ) ;;
	step 25 : wff = mpbid (step 20, step 24) |- ( ¬ ph → ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ) ;;
	step 26 : wff = pm2.61i (step 14, step 25) |- ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ph ∧ x = B ) ) ;;
	qed prop 1 = step 26 ;;
}

/* Equality has existential uniqueness (split into 3 cases).  (Contributed
       by NM, 5-Apr-1995.)  (Proof shortened by Mario Carneiro,
       28-Sep-2015.) */

theorem eueq3 (ph : wff, ps : wff, x : set, A : class, B : class, C : class) disjointed(x ph, x ps, x A, x B, x C) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	hyp 3 : wff = |- C ∈ _V ;;
	hyp 4 : wff = |- ¬ ( ph ∧ ps ) ;;
	-----------------------
	prop 1 : wff = |- ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ;;
}

proof of eueq3 {
	step 1 : wff = eueq1 (hyp 1) |- ∃! x x = A ;;
	step 2 : wff = ibar () |- ( ph → ( x = A ↔ ( ph ∧ x = A ) ) ) ;;
	step 3 : wff = pm2.45 () |- ( ¬ ( ph ∨ ps ) → ¬ ph ) ;;
	step 4 : wff = imnani (hyp 4) |- ( ph → ¬ ps ) ;;
	step 5 : wff = con2i (step 4) |- ( ps → ¬ ph ) ;;
	step 6 : wff = jaoi (step 3, step 5) |- ( ( ¬ ( ph ∨ ps ) ∨ ps ) → ¬ ph ) ;;
	step 7 : wff = con2i (step 6) |- ( ph → ¬ ( ¬ ( ph ∨ ps ) ∨ ps ) ) ;;
	step 8 : wff = pm2.45 () |- ( ¬ ( ph ∨ ps ) → ¬ ph ) ;;
	step 9 : wff = con2i (step 8) |- ( ph → ¬ ¬ ( ph ∨ ps ) ) ;;
	step 10 : wff = bianfd (step 9) |- ( ph → ( ¬ ( ph ∨ ps ) ↔ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 11 : wff = imnani (hyp 4) |- ( ph → ¬ ps ) ;;
	step 12 : wff = bianfd (step 11) |- ( ph → ( ps ↔ ( ps ∧ x = C ) ) ) ;;
	step 13 : wff = orbi12d (step 10, step 12) |- ( ph → ( ( ¬ ( ph ∨ ps ) ∨ ps ) ↔ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 14 : wff = mtbid (step 7, step 13) |- ( ph → ¬ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 15 : wff = biorf () |- ( ¬ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) → ( ( ph ∧ x = A ) ↔ ( ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ∨ ( ph ∧ x = A ) ) ) ) ;;
	step 16 : wff = syl (step 14, step 15) |- ( ph → ( ( ph ∧ x = A ) ↔ ( ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ∨ ( ph ∧ x = A ) ) ) ) ;;
	step 17 : wff = bitrd (step 2, step 16) |- ( ph → ( x = A ↔ ( ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ∨ ( ph ∧ x = A ) ) ) ) ;;
	step 18 : wff = 3orrot () |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ∨ ( ph ∧ x = A ) ) ) ;;
	step 19 : wff = df-3or () |- ( ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ∨ ( ph ∧ x = A ) ) ↔ ( ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ∨ ( ph ∧ x = A ) ) ) ;;
	step 20 : wff = bitri (step 18, step 19) |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ∨ ( ph ∧ x = A ) ) ) ;;
	step 21 : wff = syl6bbr (step 17, step 20) |- ( ph → ( x = A ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 22 : wff = eubidv (step 21) |- ( ph → ( ∃! x x = A ↔ ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 23 : wff = mpbii (step 1, step 22) |- ( ph → ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 24 : wff = eueq1 (hyp 3) |- ∃! x x = C ;;
	step 25 : wff = ibar () |- ( ps → ( x = C ↔ ( ps ∧ x = C ) ) ) ;;
	step 26 : wff = imnani (hyp 4) |- ( ph → ¬ ps ) ;;
	step 27 : wff = adantr (step 26) |- ( ( ph ∧ x = A ) → ¬ ps ) ;;
	step 28 : wff = pm2.46 () |- ( ¬ ( ph ∨ ps ) → ¬ ps ) ;;
	step 29 : wff = adantr (step 28) |- ( ( ¬ ( ph ∨ ps ) ∧ x = B ) → ¬ ps ) ;;
	step 30 : wff = jaoi (step 27, step 29) |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) → ¬ ps ) ;;
	step 31 : wff = con2i (step 30) |- ( ps → ¬ ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 32 : wff = biorf () |- ( ¬ ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) → ( ( ps ∧ x = C ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 33 : wff = syl (step 31, step 32) |- ( ps → ( ( ps ∧ x = C ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 34 : wff = bitrd (step 25, step 33) |- ( ps → ( x = C ↔ ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 35 : wff = df-3or () |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 36 : wff = syl6bbr (step 34, step 35) |- ( ps → ( x = C ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 37 : wff = eubidv (step 36) |- ( ps → ( ∃! x x = C ↔ ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 38 : wff = mpbii (step 24, step 37) |- ( ps → ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 39 : wff = eueq1 (hyp 2) |- ∃! x x = B ;;
	step 40 : wff = ibar () |- ( ¬ ( ph ∨ ps ) → ( x = B ↔ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 41 : wff = simpl () |- ( ( ph ∧ x = A ) → ph ) ;;
	step 42 : wff = simpl () |- ( ( ps ∧ x = C ) → ps ) ;;
	step 43 : wff = orim12i (step 41, step 42) |- ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) → ( ph ∨ ps ) ) ;;
	step 44 : wff = con3i (step 43) |- ( ¬ ( ph ∨ ps ) → ¬ ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 45 : wff = biorf () |- ( ¬ ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) → ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ) ;;
	step 46 : wff = syl (step 44, step 45) |- ( ¬ ( ph ∨ ps ) → ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ) ;;
	step 47 : wff = bitrd (step 40, step 46) |- ( ¬ ( ph ∨ ps ) → ( x = B ↔ ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ) ;;
	step 48 : wff = 3orcomb () |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 49 : wff = df-3or () |- ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 50 : wff = bitri (step 48, step 49) |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ( ph ∧ x = A ) ∨ ( ps ∧ x = C ) ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 51 : wff = syl6bbr (step 47, step 50) |- ( ¬ ( ph ∨ ps ) → ( x = B ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 52 : wff = eubidv (step 51) |- ( ¬ ( ph ∨ ps ) → ( ∃! x x = B ↔ ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 53 : wff = mpbii (step 39, step 52) |- ( ¬ ( ph ∨ ps ) → ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 54 : wff = ecase3 (step 23, step 38, step 53) |- ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ;;
	qed prop 1 = step 54 ;;
}

/* There is at most one set equal to a class.  (Contributed by NM,
       8-Mar-1995.) */

theorem moeq (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ∃* x x = A ;;
}

proof of moeq {
	step 1 : wff = isset () |- ( A ∈ _V ↔ ∃ x x = A ) ;;
	step 2 : wff = eueq () |- ( A ∈ _V ↔ ∃! x x = A ) ;;
	step 3 : wff = bitr3i (step 1, step 2) |- ( ∃ x x = A ↔ ∃! x x = A ) ;;
	step 4 : wff = biimpi (step 3) |- ( ∃ x x = A → ∃! x x = A ) ;;
	step 5 : wff = df-mo () |- ( ∃* x x = A ↔ ( ∃ x x = A → ∃! x x = A ) ) ;;
	step 6 : wff = mpbir (step 4, step 5) |- ∃* x x = A ;;
	qed prop 1 = step 6 ;;
}

/* "At most one" property of equality (split into 3 cases).  (The first 2
       hypotheses could be eliminated with longer proof.)  (Contributed by NM,
       23-Apr-1995.) */

theorem moeq3 (ph : wff, ps : wff, x : set, A : class, B : class, C : class) disjointed(x y ph, x y ps, x y A, x y B, x y C) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- C ∈ _V ;;
	hyp 3 : wff = |- ¬ ( ph ∧ ps ) ;;
	-----------------------
	prop 1 : wff = |- ∃* x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ;;
}

proof of moeq3 {
	var y : set;;
	step 1 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( y = A → ( ( ph ∧ x = y ) ↔ ( ph ∧ x = A ) ) ) ;;
	step 3 : wff = biidd () |- ( y = A → ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ↔ ( ¬ ( ph ∨ ps ) ∧ x = B ) ) ) ;;
	step 4 : wff = biidd () |- ( y = A → ( ( ps ∧ x = C ) ↔ ( ps ∧ x = C ) ) ) ;;
	step 5 : wff = 3orbi123d (step 2, step 3, step 4) |- ( y = A → ( ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 6 : wff = eubidv (step 5) |- ( y = A → ( ∃! x ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 7 : wff = vex () |- y ∈ _V ;;
	step 8 : wff = eueq3 (step 7, hyp 1, hyp 2, hyp 3) |- ∃! x ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ;;
	step 9 : wff = vtoclg (step 6, step 8) |- ( A ∈ _V → ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 10 : wff = eumo () |- ( ∃! x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) → ∃* x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( A ∈ _V → ∃* x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = eleq1 () |- ( x = A → ( x ∈ _V ↔ A ∈ _V ) ) ;;
	step 14 : wff = mpbii (step 12, step 13) |- ( x = A → A ∈ _V ) ;;
	step 15 : wff = pm2.21 () |- ( ¬ A ∈ _V → ( A ∈ _V → x = y ) ) ;;
	step 16 : wff = syl5 (step 14, step 15) |- ( ¬ A ∈ _V → ( x = A → x = y ) ) ;;
	step 17 : wff = anim2d (step 16) |- ( ¬ A ∈ _V → ( ( ph ∧ x = A ) → ( ph ∧ x = y ) ) ) ;;
	step 18 : wff = orim1d (step 17) |- ( ¬ A ∈ _V → ( ( ( ph ∧ x = A ) ∨ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) → ( ( ph ∧ x = y ) ∨ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ) ;;
	step 19 : wff = 3orass () |- ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ph ∧ x = A ) ∨ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 20 : wff = 3orass () |- ( ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ↔ ( ( ph ∧ x = y ) ∨ ( ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 21 : wff = 3imtr4g (step 18, step 19, step 20) |- ( ¬ A ∈ _V → ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) → ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 22 : wff = alrimiv (step 21) |- ( ¬ A ∈ _V → ∀ x ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) → ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 23 : wff = vex () |- y ∈ _V ;;
	step 24 : wff = eueq3 (step 23, hyp 1, hyp 2, hyp 3) |- ∃! x ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ;;
	step 25 : wff = euimmo () |- ( ∀ x ( ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) → ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) → ( ∃! x ( ( ph ∧ x = y ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) → ∃* x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ) ;;
	step 26 : wff = ee10 (step 22, step 24, step 25) |- ( ¬ A ∈ _V → ∃* x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ) ;;
	step 27 : wff = pm2.61i (step 11, step 26) |- ∃* x ( ( ph ∧ x = A ) ∨ ( ¬ ( ph ∨ ps ) ∧ x = B ) ∨ ( ps ∧ x = C ) ) ;;
	qed prop 1 = step 27 ;;
}

/* "At most one" remains true after substitution.  (Contributed by NM,
       9-Mar-1995.) */

theorem mosub (ph : wff, x : set, y : set, A : class) disjointed(x y A) {
	hyp 1 : wff = |- ∃* x ph ;;
	-----------------------
	prop 1 : wff = |- ∃* x ∃ y ( y = A ∧ ph ) ;;
}

proof of mosub {
	step 1 : wff = moeq () |- ∃* y y = A ;;
	step 2 : wff = ax-gen (hyp 1) |- ∀ y ∃* x ph ;;
	step 3 : wff = moexexv () |- ( ( ∃* y y = A ∧ ∀ y ∃* x ph ) → ∃* x ∃ y ( y = A ∧ ph ) ) ;;
	step 4 : wff = mp2an (step 1, step 2, step 3) |- ∃* x ∃ y ( y = A ∧ ph ) ;;
	qed prop 1 = step 4 ;;
}

/* Theorem for inferring "at most one."  (Contributed by NM,
       17-Oct-1996.) */

theorem mo2icl (ph : wff, x : set, A : class) disjointed(x y A, y ph) {
	prop 1 : wff = |- ( ∀ x ( ph → x = A ) → ∃* x ph ) ;;
}

proof of mo2icl {
	var y : set;;
	step 1 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 2 : wff = imbi2d (step 1) |- ( y = A → ( ( ph → x = y ) ↔ ( ph → x = A ) ) ) ;;
	step 3 : wff = albidv (step 2) |- ( y = A → ( ∀ x ( ph → x = y ) ↔ ∀ x ( ph → x = A ) ) ) ;;
	step 4 : wff = imbi1d (step 3) |- ( y = A → ( ( ∀ x ( ph → x = y ) → ∃* x ph ) ↔ ( ∀ x ( ph → x = A ) → ∃* x ph ) ) ) ;;
	step 5 : wff = 19.8a () |- ( ∀ x ( ph → x = y ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 6 : wff = nfv () |- F/ y ph ;;
	step 7 : wff = mo2 (step 6) |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 8 : wff = sylibr (step 5, step 7) |- ( ∀ x ( ph → x = y ) → ∃* x ph ) ;;
	step 9 : wff = vtoclg (step 4, step 8) |- ( A ∈ _V → ( ∀ x ( ph → x = A ) → ∃* x ph ) ) ;;
	step 10 : wff = vex () |- x ∈ _V ;;
	step 11 : wff = eleq1 () |- ( x = A → ( x ∈ _V ↔ A ∈ _V ) ) ;;
	step 12 : wff = mpbii (step 10, step 11) |- ( x = A → A ∈ _V ) ;;
	step 13 : wff = imim2i (step 12) |- ( ( ph → x = A ) → ( ph → A ∈ _V ) ) ;;
	step 14 : wff = con3rr3 (step 13) |- ( ¬ A ∈ _V → ( ( ph → x = A ) → ¬ ph ) ) ;;
	step 15 : wff = alimdv (step 14) |- ( ¬ A ∈ _V → ( ∀ x ( ph → x = A ) → ∀ x ¬ ph ) ) ;;
	step 16 : wff = alnex () |- ( ∀ x ¬ ph ↔ ¬ ∃ x ph ) ;;
	step 17 : wff = exmo () |- ( ∃ x ph ∨ ∃* x ph ) ;;
	step 18 : wff = ori (step 17) |- ( ¬ ∃ x ph → ∃* x ph ) ;;
	step 19 : wff = sylbi (step 16, step 18) |- ( ∀ x ¬ ph → ∃* x ph ) ;;
	step 20 : wff = syl6 (step 15, step 19) |- ( ¬ A ∈ _V → ( ∀ x ( ph → x = A ) → ∃* x ph ) ) ;;
	step 21 : wff = pm2.61i (step 9, step 20) |- ( ∀ x ( ph → x = A ) → ∃* x ph ) ;;
	qed prop 1 = step 21 ;;
}

/* Consequence of "at most one."  (Contributed by NM, 2-Jan-2015.) */

theorem mob2 (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x y A, y ph, x y ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ B ∧ ∃* x ph ∧ ph ) → ( x = A ↔ ps ) ) ;;
}

proof of mob2 {
	var y : set;;
	step 1 : wff = simp3 () |- ( ( A ∈ B ∧ ∃* x ph ∧ ph ) → ph ) ;;
	step 2 : wff = syl5ibcom (step 1, hyp 1) |- ( ( A ∈ B ∧ ∃* x ph ∧ ph ) → ( x = A → ps ) ) ;;
	step 3 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 4 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 5 : wff = mo4f (step 3, step 4) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 6 : wff = sp () |- ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 7 : wff = sylbi (step 5, step 6) |- ( ∃* x ph → ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 8 : wff = nfv () |- F/ x ps ;;
	step 9 : wff = sbhypf (step 8, hyp 1) |- ( y = A → ( [ y / x ] ph ↔ ps ) ) ;;
	step 10 : wff = anbi2d (step 9) |- ( y = A → ( ( ph ∧ [ y / x ] ph ) ↔ ( ph ∧ ps ) ) ) ;;
	step 11 : wff = eqeq2 () |- ( y = A → ( x = y ↔ x = A ) ) ;;
	step 12 : wff = imbi12d (step 10, step 11) |- ( y = A → ( ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ( ( ph ∧ ps ) → x = A ) ) ) ;;
	step 13 : wff = spcgv (step 12) |- ( A ∈ B → ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ( ph ∧ ps ) → x = A ) ) ) ;;
	step 14 : wff = syl5 (step 7, step 13) |- ( A ∈ B → ( ∃* x ph → ( ( ph ∧ ps ) → x = A ) ) ) ;;
	step 15 : wff = imp (step 14) |- ( ( A ∈ B ∧ ∃* x ph ) → ( ( ph ∧ ps ) → x = A ) ) ;;
	step 16 : wff = exp3a (step 15) |- ( ( A ∈ B ∧ ∃* x ph ) → ( ph → ( ps → x = A ) ) ) ;;
	step 17 : wff = 3impia (step 16) |- ( ( A ∈ B ∧ ∃* x ph ∧ ph ) → ( ps → x = A ) ) ;;
	step 18 : wff = impbid (step 2, step 17) |- ( ( A ∈ B ∧ ∃* x ph ∧ ph ) → ( x = A ↔ ps ) ) ;;
	qed prop 1 = step 18 ;;
}

/* Consequence of "at most one."  (Contributed by NM, 29-Jun-2008.) */

theorem moi2 (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ B ∧ ∃* x ph ) ∧ ( ph ∧ ps ) ) → x = A ) ;;
}

proof of moi2 {
	step 1 : wff = mob2 (hyp 1) |- ( ( A ∈ B ∧ ∃* x ph ∧ ph ) → ( x = A ↔ ps ) ) ;;
	step 2 : wff = 3expa (step 1) |- ( ( ( A ∈ B ∧ ∃* x ph ) ∧ ph ) → ( x = A ↔ ps ) ) ;;
	step 3 : wff = biimprd (step 2) |- ( ( ( A ∈ B ∧ ∃* x ph ) ∧ ph ) → ( ps → x = A ) ) ;;
	step 4 : wff = impr (step 3) |- ( ( ( A ∈ B ∧ ∃* x ph ) ∧ ( ph ∧ ps ) ) → x = A ) ;;
	qed prop 1 = step 4 ;;
}

/* Equality implied by "at most one."  (Contributed by NM, 18-Feb-2006.) */

theorem mob (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class, C : class, D : class) disjointed(x A, x B, x ch, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( x = B → ( ph ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ;;
}

proof of mob {
	step 1 : wff = elex () |- ( B ∈ D → B ∈ _V ) ;;
	step 2 : wff = nfcv () |- F/_ x A ;;
	step 3 : wff = nfv () |- F/ x B ∈ _V ;;
	step 4 : wff = nfmo1 () |- F/ x ∃* x ph ;;
	step 5 : wff = nfv () |- F/ x ps ;;
	step 6 : wff = nf3an (step 3, step 4, step 5) |- F/ x ( B ∈ _V ∧ ∃* x ph ∧ ps ) ;;
	step 7 : wff = nfv () |- F/ x ( A = B ↔ ch ) ;;
	step 8 : wff = nfim (step 6, step 7) |- F/ x ( ( B ∈ _V ∧ ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ;;
	step 9 : wff = 3anbi3d (hyp 1) |- ( x = A → ( ( B ∈ _V ∧ ∃* x ph ∧ ph ) ↔ ( B ∈ _V ∧ ∃* x ph ∧ ps ) ) ) ;;
	step 10 : wff = eqeq1 () |- ( x = A → ( x = B ↔ A = B ) ) ;;
	step 11 : wff = bibi1d (step 10) |- ( x = A → ( ( x = B ↔ ch ) ↔ ( A = B ↔ ch ) ) ) ;;
	step 12 : wff = imbi12d (step 9, step 11) |- ( x = A → ( ( ( B ∈ _V ∧ ∃* x ph ∧ ph ) → ( x = B ↔ ch ) ) ↔ ( ( B ∈ _V ∧ ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ) ) ;;
	step 13 : wff = mob2 (hyp 2) |- ( ( B ∈ _V ∧ ∃* x ph ∧ ph ) → ( x = B ↔ ch ) ) ;;
	step 14 : wff = vtoclgf (step 2, step 8, step 12, step 13) |- ( A ∈ C → ( ( B ∈ _V ∧ ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ) ;;
	step 15 : wff = com12 (step 14) |- ( ( B ∈ _V ∧ ∃* x ph ∧ ps ) → ( A ∈ C → ( A = B ↔ ch ) ) ) ;;
	step 16 : wff = 3expib (step 15) |- ( B ∈ _V → ( ( ∃* x ph ∧ ps ) → ( A ∈ C → ( A = B ↔ ch ) ) ) ) ;;
	step 17 : wff = syl (step 1, step 16) |- ( B ∈ D → ( ( ∃* x ph ∧ ps ) → ( A ∈ C → ( A = B ↔ ch ) ) ) ) ;;
	step 18 : wff = com3r (step 17) |- ( A ∈ C → ( B ∈ D → ( ( ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ) ) ;;
	step 19 : wff = imp (step 18) |- ( ( A ∈ C ∧ B ∈ D ) → ( ( ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ) ;;
	step 20 : wff = 3impib (step 19) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ;;
	qed prop 1 = step 20 ;;
}

/* Equality implied by "at most one."  (Contributed by NM, 18-Feb-2006.) */

theorem moi (ph : wff, ps : wff, ch : wff, x : set, A : class, B : class, C : class, D : class) disjointed(x A, x B, x ch, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( x = B → ( ph ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ∧ ( ps ∧ ch ) ) → A = B ) ;;
}

proof of moi {
	step 1 : wff = mob (hyp 1, hyp 2) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ∧ ps ) → ( A = B ↔ ch ) ) ;;
	step 2 : wff = biimprd (step 1) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ∧ ps ) → ( ch → A = B ) ) ;;
	step 3 : wff = 3expia (step 2) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ) → ( ps → ( ch → A = B ) ) ) ;;
	step 4 : wff = imp3a (step 3) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ) → ( ( ps ∧ ch ) → A = B ) ) ;;
	step 5 : wff = 3impia (step 4) |- ( ( ( A ∈ C ∧ B ∈ D ) ∧ ∃* x ph ∧ ( ps ∧ ch ) ) → A = B ) ;;
	qed prop 1 = step 5 ;;
}

/* Derive membership from uniqueness.  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem morex (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(B x, A x, ps x) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- ( x = B → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ∃ x ∈ A ph ∧ ∃* x ph ) → ( ps → B ∈ A ) ) ;;
}

proof of morex {
	step 1 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = exancom () |- ( ∃ x ( x ∈ A ∧ ph ) ↔ ∃ x ( ph ∧ x ∈ A ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ∃ x ∈ A ph ↔ ∃ x ( ph ∧ x ∈ A ) ) ;;
	step 4 : wff = nfmo1 () |- F/ x ∃* x ph ;;
	step 5 : wff = nfe1 () |- F/ x ∃ x ( ph ∧ x ∈ A ) ;;
	step 6 : wff = nfan (step 4, step 5) |- F/ x ( ∃* x ph ∧ ∃ x ( ph ∧ x ∈ A ) ) ;;
	step 7 : wff = mopick () |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ x ∈ A ) ) → ( ph → x ∈ A ) ) ;;
	step 8 : wff = alrimi (step 6, step 7) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ x ∈ A ) ) → ∀ x ( ph → x ∈ A ) ) ;;
	step 9 : wff = eleq1 () |- ( x = B → ( x ∈ A ↔ B ∈ A ) ) ;;
	step 10 : wff = imbi12d (hyp 2, step 9) |- ( x = B → ( ( ph → x ∈ A ) ↔ ( ps → B ∈ A ) ) ) ;;
	step 11 : wff = spcv (hyp 1, step 10) |- ( ∀ x ( ph → x ∈ A ) → ( ps → B ∈ A ) ) ;;
	step 12 : wff = syl (step 8, step 11) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ x ∈ A ) ) → ( ps → B ∈ A ) ) ;;
	step 13 : wff = sylan2b (step 3, step 12) |- ( ( ∃* x ph ∧ ∃ x ∈ A ph ) → ( ps → B ∈ A ) ) ;;
	step 14 : wff = ancoms (step 13) |- ( ( ∃ x ∈ A ph ∧ ∃* x ph ) → ( ps → B ∈ A ) ) ;;
	qed prop 1 = step 14 ;;
}

/* Transfer existential uniqueness from a variable ` x ` to another
       variable ` y ` contained in expression ` A ` .  (Contributed by NM,
       14-Nov-2004.) */

theorem euxfr2 (ph : wff, x : set, y : set, A : class) disjointed(x ph, x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ∃* y x = A ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∃ y ( x = A ∧ ph ) ↔ ∃! y ph ) ;;
}

proof of euxfr2 {
	step 1 : wff = 2euswap () |- ( ∀ x ∃* y ( x = A ∧ ph ) → ( ∃! x ∃ y ( x = A ∧ ph ) → ∃! y ∃ x ( x = A ∧ ph ) ) ) ;;
	step 2 : wff = moani (hyp 2) |- ∃* y ( ph ∧ x = A ) ;;
	step 3 : wff = ancom () |- ( ( ph ∧ x = A ) ↔ ( x = A ∧ ph ) ) ;;
	step 4 : wff = mobii (step 3) |- ( ∃* y ( ph ∧ x = A ) ↔ ∃* y ( x = A ∧ ph ) ) ;;
	step 5 : wff = mpbi (step 2, step 4) |- ∃* y ( x = A ∧ ph ) ;;
	step 6 : wff = mpg (step 1, step 5) |- ( ∃! x ∃ y ( x = A ∧ ph ) → ∃! y ∃ x ( x = A ∧ ph ) ) ;;
	step 7 : wff = 2euswap () |- ( ∀ y ∃* x ( x = A ∧ ph ) → ( ∃! y ∃ x ( x = A ∧ ph ) → ∃! x ∃ y ( x = A ∧ ph ) ) ) ;;
	step 8 : wff = moeq () |- ∃* x x = A ;;
	step 9 : wff = moani (step 8) |- ∃* x ( ph ∧ x = A ) ;;
	step 10 : wff = ancom () |- ( ( ph ∧ x = A ) ↔ ( x = A ∧ ph ) ) ;;
	step 11 : wff = mobii (step 10) |- ( ∃* x ( ph ∧ x = A ) ↔ ∃* x ( x = A ∧ ph ) ) ;;
	step 12 : wff = mpbi (step 9, step 11) |- ∃* x ( x = A ∧ ph ) ;;
	step 13 : wff = mpg (step 7, step 12) |- ( ∃! y ∃ x ( x = A ∧ ph ) → ∃! x ∃ y ( x = A ∧ ph ) ) ;;
	step 14 : wff = impbii (step 6, step 13) |- ( ∃! x ∃ y ( x = A ∧ ph ) ↔ ∃! y ∃ x ( x = A ∧ ph ) ) ;;
	step 15 : wff = biidd () |- ( x = A → ( ph ↔ ph ) ) ;;
	step 16 : wff = ceqsexv (hyp 1, step 15) |- ( ∃ x ( x = A ∧ ph ) ↔ ph ) ;;
	step 17 : wff = eubii (step 16) |- ( ∃! y ∃ x ( x = A ∧ ph ) ↔ ∃! y ph ) ;;
	step 18 : wff = bitri (step 14, step 17) |- ( ∃! x ∃ y ( x = A ∧ ph ) ↔ ∃! y ph ) ;;
	qed prop 1 = step 18 ;;
}

/* Transfer existential uniqueness from a variable ` x ` to another
       variable ` y ` contained in expression ` A ` .  (Contributed by NM,
       14-Nov-2004.) */

theorem euxfr (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x ps, y ph, x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- ∃! y x = A ;;
	hyp 3 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ∃! y ps ) ;;
}

proof of euxfr {
	step 1 : wff = euex () |- ( ∃! y x = A → ∃ y x = A ) ;;
	step 2 : wff = ax-mp (hyp 2, step 1) |- ∃ y x = A ;;
	step 3 : wff = biantrur (step 2) |- ( ph ↔ ( ∃ y x = A ∧ ph ) ) ;;
	step 4 : wff = 19.41v () |- ( ∃ y ( x = A ∧ ph ) ↔ ( ∃ y x = A ∧ ph ) ) ;;
	step 5 : wff = pm5.32i (hyp 3) |- ( ( x = A ∧ ph ) ↔ ( x = A ∧ ps ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ( x = A ∧ ph ) ↔ ∃ y ( x = A ∧ ps ) ) ;;
	step 7 : wff = 3bitr2i (step 3, step 4, step 6) |- ( ph ↔ ∃ y ( x = A ∧ ps ) ) ;;
	step 8 : wff = eubii (step 7) |- ( ∃! x ph ↔ ∃! x ∃ y ( x = A ∧ ps ) ) ;;
	step 9 : wff = eumoi (hyp 2) |- ∃* y x = A ;;
	step 10 : wff = euxfr2 (hyp 1, step 9) |- ( ∃! x ∃ y ( x = A ∧ ps ) ↔ ∃! y ps ) ;;
	step 11 : wff = bitri (step 8, step 10) |- ( ∃! x ph ↔ ∃! y ps ) ;;
	qed prop 1 = step 11 ;;
}

/* Existential uniqueness via an indirect equality.  (Contributed by NM,
       11-Oct-2010.) */

theorem euind (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class) disjointed(y z w ph, x z ps, y z w A, x z B, x y w) {
	hyp 1 : wff = |- B ∈ _V ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ( x = y → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) ∧ ∃ x ph ) → ∃! z ∀ x ( ph → z = A ) ) ;;
}

proof of euind {
	var w : set;;
	step 1 : wff = cbvexv (hyp 2) |- ( ∃ x ph ↔ ∃ y ps ) ;;
	step 2 : wff = isseti (hyp 1) |- ∃ z z = B ;;
	step 3 : wff = biantrur (step 2) |- ( ps ↔ ( ∃ z z = B ∧ ps ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ps ↔ ∃ y ( ∃ z z = B ∧ ps ) ) ;;
	step 5 : wff = 19.41v () |- ( ∃ z ( z = B ∧ ps ) ↔ ( ∃ z z = B ∧ ps ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ∃ z ( z = B ∧ ps ) ↔ ∃ y ( ∃ z z = B ∧ ps ) ) ;;
	step 7 : wff = excom () |- ( ∃ y ∃ z ( z = B ∧ ps ) ↔ ∃ z ∃ y ( z = B ∧ ps ) ) ;;
	step 8 : wff = bitr3i (step 6, step 7) |- ( ∃ y ( ∃ z z = B ∧ ps ) ↔ ∃ z ∃ y ( z = B ∧ ps ) ) ;;
	step 9 : wff = bitri (step 4, step 8) |- ( ∃ y ps ↔ ∃ z ∃ y ( z = B ∧ ps ) ) ;;
	step 10 : wff = bitri (step 1, step 9) |- ( ∃ x ph ↔ ∃ z ∃ y ( z = B ∧ ps ) ) ;;
	step 11 : wff = eqeq2 () |- ( A = B → ( z = A ↔ z = B ) ) ;;
	step 12 : wff = imim2i (step 11) |- ( ( ( ph ∧ ps ) → A = B ) → ( ( ph ∧ ps ) → ( z = A ↔ z = B ) ) ) ;;
	step 13 : wff = bi2 () |- ( ( z = A ↔ z = B ) → ( z = B → z = A ) ) ;;
	step 14 : wff = imim2i (step 13) |- ( ( ( ph ∧ ps ) → ( z = A ↔ z = B ) ) → ( ( ph ∧ ps ) → ( z = B → z = A ) ) ) ;;
	step 15 : wff = an31 () |- ( ( ( ph ∧ ps ) ∧ z = B ) ↔ ( ( z = B ∧ ps ) ∧ ph ) ) ;;
	step 16 : wff = imbi1i (step 15) |- ( ( ( ( ph ∧ ps ) ∧ z = B ) → z = A ) ↔ ( ( ( z = B ∧ ps ) ∧ ph ) → z = A ) ) ;;
	step 17 : wff = impexp () |- ( ( ( ( ph ∧ ps ) ∧ z = B ) → z = A ) ↔ ( ( ph ∧ ps ) → ( z = B → z = A ) ) ) ;;
	step 18 : wff = impexp () |- ( ( ( ( z = B ∧ ps ) ∧ ph ) → z = A ) ↔ ( ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 19 : wff = 3bitr3i (step 16, step 17, step 18) |- ( ( ( ph ∧ ps ) → ( z = B → z = A ) ) ↔ ( ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 20 : wff = sylib (step 14, step 19) |- ( ( ( ph ∧ ps ) → ( z = A ↔ z = B ) ) → ( ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 21 : wff = syl (step 12, step 20) |- ( ( ( ph ∧ ps ) → A = B ) → ( ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 22 : wff = 2alimi (step 21) |- ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) → ∀ x ∀ y ( ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 23 : wff = 19.23v () |- ( ∀ y ( ( z = B ∧ ps ) → ( ph → z = A ) ) ↔ ( ∃ y ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 24 : wff = albii (step 23) |- ( ∀ x ∀ y ( ( z = B ∧ ps ) → ( ph → z = A ) ) ↔ ∀ x ( ∃ y ( z = B ∧ ps ) → ( ph → z = A ) ) ) ;;
	step 25 : wff = 19.21v () |- ( ∀ x ( ∃ y ( z = B ∧ ps ) → ( ph → z = A ) ) ↔ ( ∃ y ( z = B ∧ ps ) → ∀ x ( ph → z = A ) ) ) ;;
	step 26 : wff = bitri (step 24, step 25) |- ( ∀ x ∀ y ( ( z = B ∧ ps ) → ( ph → z = A ) ) ↔ ( ∃ y ( z = B ∧ ps ) → ∀ x ( ph → z = A ) ) ) ;;
	step 27 : wff = sylib (step 22, step 26) |- ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) → ( ∃ y ( z = B ∧ ps ) → ∀ x ( ph → z = A ) ) ) ;;
	step 28 : wff = eximdv (step 27) |- ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) → ( ∃ z ∃ y ( z = B ∧ ps ) → ∃ z ∀ x ( ph → z = A ) ) ) ;;
	step 29 : wff = syl5bi (step 10, step 28) |- ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) → ( ∃ x ph → ∃ z ∀ x ( ph → z = A ) ) ) ;;
	step 30 : wff = imp (step 29) |- ( ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) ∧ ∃ x ph ) → ∃ z ∀ x ( ph → z = A ) ) ;;
	step 31 : wff = pm4.24 () |- ( ph ↔ ( ph ∧ ph ) ) ;;
	step 32 : wff = biimpi (step 31) |- ( ph → ( ph ∧ ph ) ) ;;
	step 33 : wff = prth () |- ( ( ( ph → z = A ) ∧ ( ph → w = A ) ) → ( ( ph ∧ ph ) → ( z = A ∧ w = A ) ) ) ;;
	step 34 : wff = eqtr3 () |- ( ( z = A ∧ w = A ) → z = w ) ;;
	step 35 : wff = syl56 (step 32, step 33, step 34) |- ( ( ( ph → z = A ) ∧ ( ph → w = A ) ) → ( ph → z = w ) ) ;;
	step 36 : wff = alanimi (step 35) |- ( ( ∀ x ( ph → z = A ) ∧ ∀ x ( ph → w = A ) ) → ∀ x ( ph → z = w ) ) ;;
	step 37 : wff = 19.23v () |- ( ∀ x ( ph → z = w ) ↔ ( ∃ x ph → z = w ) ) ;;
	step 38 : wff = biimpi (step 37) |- ( ∀ x ( ph → z = w ) → ( ∃ x ph → z = w ) ) ;;
	step 39 : wff = com12 (step 38) |- ( ∃ x ph → ( ∀ x ( ph → z = w ) → z = w ) ) ;;
	step 40 : wff = syl5 (step 36, step 39) |- ( ∃ x ph → ( ( ∀ x ( ph → z = A ) ∧ ∀ x ( ph → w = A ) ) → z = w ) ) ;;
	step 41 : wff = alrimivv (step 40) |- ( ∃ x ph → ∀ z ∀ w ( ( ∀ x ( ph → z = A ) ∧ ∀ x ( ph → w = A ) ) → z = w ) ) ;;
	step 42 : wff = adantl (step 41) |- ( ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) ∧ ∃ x ph ) → ∀ z ∀ w ( ( ∀ x ( ph → z = A ) ∧ ∀ x ( ph → w = A ) ) → z = w ) ) ;;
	step 43 : wff = eqeq1 () |- ( z = w → ( z = A ↔ w = A ) ) ;;
	step 44 : wff = imbi2d (step 43) |- ( z = w → ( ( ph → z = A ) ↔ ( ph → w = A ) ) ) ;;
	step 45 : wff = albidv (step 44) |- ( z = w → ( ∀ x ( ph → z = A ) ↔ ∀ x ( ph → w = A ) ) ) ;;
	step 46 : wff = eu4 (step 45) |- ( ∃! z ∀ x ( ph → z = A ) ↔ ( ∃ z ∀ x ( ph → z = A ) ∧ ∀ z ∀ w ( ( ∀ x ( ph → z = A ) ∧ ∀ x ( ph → w = A ) ) → z = w ) ) ) ;;
	step 47 : wff = sylanbrc (step 30, step 42, step 46) |- ( ( ∀ x ∀ y ( ( ph ∧ ps ) → A = B ) ∧ ∃ x ph ) → ∃! z ∀ x ( ph → z = A ) ) ;;
	qed prop 1 = step 47 ;;
}

/* A way to express restricted uniqueness.  (Contributed by NM,
       22-Nov-1994.) */

theorem reu2 (ph : wff, x : set, y : set, A : class) disjointed(x y A, x y, y ph) {
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
}

proof of reu2 {
	step 1 : wff = nfv () |- F/ y ( x ∈ A ∧ ph ) ;;
	step 2 : wff = eu2 (step 1) |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∀ x ∀ y ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ) ) ;;
	step 3 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 4 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 5 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ∀ x ( x ∈ A → ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 6 : wff = 19.21v () |- ( ∀ y ( x ∈ A → ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ↔ ( x ∈ A → ∀ y ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ) ;;
	step 7 : wff = nfv () |- F/ x y ∈ A ;;
	step 8 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 9 : wff = nfan (step 7, step 8) |- F/ x ( y ∈ A ∧ [ y / x ] ph ) ;;
	step 10 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 11 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 12 : wff = anbi12d (step 10, step 11) |- ( x = y → ( ( x ∈ A ∧ ph ) ↔ ( y ∈ A ∧ [ y / x ] ph ) ) ) ;;
	step 13 : wff = sbie (step 9, step 12) |- ( [ y / x ] ( x ∈ A ∧ ph ) ↔ ( y ∈ A ∧ [ y / x ] ph ) ) ;;
	step 14 : wff = anbi2i (step 13) |- ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) ↔ ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ [ y / x ] ph ) ) ) ;;
	step 15 : wff = an4 () |- ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ [ y / x ] ph ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( ph ∧ [ y / x ] ph ) ) ) ;;
	step 16 : wff = bitri (step 14, step 15) |- ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( ph ∧ [ y / x ] ph ) ) ) ;;
	step 17 : wff = imbi1i (step 16) |- ( ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ↔ ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( ph ∧ [ y / x ] ph ) ) → x = y ) ) ;;
	step 18 : wff = impexp () |- ( ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( ph ∧ [ y / x ] ph ) ) → x = y ) ↔ ( ( x ∈ A ∧ y ∈ A ) → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 19 : wff = impexp () |- ( ( ( x ∈ A ∧ y ∈ A ) → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ↔ ( x ∈ A → ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ) ;;
	step 20 : wff = 3bitri (step 17, step 18, step 19) |- ( ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ↔ ( x ∈ A → ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ) ;;
	step 21 : wff = albii (step 20) |- ( ∀ y ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ↔ ∀ y ( x ∈ A → ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ) ;;
	step 22 : wff = df-ral () |- ( ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ∀ y ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 23 : wff = imbi2i (step 22) |- ( ( x ∈ A → ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ↔ ( x ∈ A → ∀ y ( y ∈ A → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ) ;;
	step 24 : wff = 3bitr4i (step 6, step 21, step 23) |- ( ∀ y ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ↔ ( x ∈ A → ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 25 : wff = albii (step 24) |- ( ∀ x ∀ y ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ↔ ∀ x ( x ∈ A → ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 26 : wff = bitr4i (step 5, step 25) |- ( ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ∀ x ∀ y ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ) ;;
	step 27 : wff = anbi12i (step 4, step 26) |- ( ( ∃ x ∈ A ph ∧ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∀ x ∀ y ( ( ( x ∈ A ∧ ph ) ∧ [ y / x ] ( x ∈ A ∧ ph ) ) → x = y ) ) ) ;;
	step 28 : wff = 3bitr4i (step 2, step 3, step 27) |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	qed prop 1 = step 28 ;;
}

/* A way to express restricted uniqueness.  (Contributed by NM,
       20-Oct-2006.) */

theorem reu6 (ph : wff, x : set, y : set, A : class) disjointed(x y A, x y, y ph) {
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ) ;;
}

proof of reu6 {
	step 1 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = 19.28v () |- ( ∀ x ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ↔ ( y ∈ A ∧ ∀ x ( x ∈ A → ( ph ↔ x = y ) ) ) ) ;;
	step 3 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 4 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 5 : wff = anbi12d (step 3, step 4) |- ( x = y → ( ( x ∈ A ∧ ph ) ↔ ( y ∈ A ∧ [ y / x ] ph ) ) ) ;;
	step 6 : wff = eqeq1 () |- ( x = y → ( x = y ↔ y = y ) ) ;;
	step 7 : wff = bibi12d (step 5, step 6) |- ( x = y → ( ( ( x ∈ A ∧ ph ) ↔ x = y ) ↔ ( ( y ∈ A ∧ [ y / x ] ph ) ↔ y = y ) ) ) ;;
	step 8 : wff = eqid () |- y = y ;;
	step 9 : wff = tbt (step 8) |- ( ( y ∈ A ∧ [ y / x ] ph ) ↔ ( ( y ∈ A ∧ [ y / x ] ph ) ↔ y = y ) ) ;;
	step 10 : wff = simpl () |- ( ( y ∈ A ∧ [ y / x ] ph ) → y ∈ A ) ;;
	step 11 : wff = sylbir (step 9, step 10) |- ( ( ( y ∈ A ∧ [ y / x ] ph ) ↔ y = y ) → y ∈ A ) ;;
	step 12 : wff = syl6bi (step 7, step 11) |- ( x = y → ( ( ( x ∈ A ∧ ph ) ↔ x = y ) → y ∈ A ) ) ;;
	step 13 : wff = spimv (step 12) |- ( ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) → y ∈ A ) ;;
	step 14 : wff = bi1 () |- ( ( ( x ∈ A ∧ ph ) ↔ x = y ) → ( ( x ∈ A ∧ ph ) → x = y ) ) ;;
	step 15 : wff = expdimp (step 14) |- ( ( ( ( x ∈ A ∧ ph ) ↔ x = y ) ∧ x ∈ A ) → ( ph → x = y ) ) ;;
	step 16 : wff = bi2 () |- ( ( ( x ∈ A ∧ ph ) ↔ x = y ) → ( x = y → ( x ∈ A ∧ ph ) ) ) ;;
	step 17 : wff = simpr () |- ( ( x ∈ A ∧ ph ) → ph ) ;;
	step 18 : wff = syl6 (step 16, step 17) |- ( ( ( x ∈ A ∧ ph ) ↔ x = y ) → ( x = y → ph ) ) ;;
	step 19 : wff = adantr (step 18) |- ( ( ( ( x ∈ A ∧ ph ) ↔ x = y ) ∧ x ∈ A ) → ( x = y → ph ) ) ;;
	step 20 : wff = impbid (step 15, step 19) |- ( ( ( ( x ∈ A ∧ ph ) ↔ x = y ) ∧ x ∈ A ) → ( ph ↔ x = y ) ) ;;
	step 21 : wff = ex (step 20) |- ( ( ( x ∈ A ∧ ph ) ↔ x = y ) → ( x ∈ A → ( ph ↔ x = y ) ) ) ;;
	step 22 : wff = sps (step 21) |- ( ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) → ( x ∈ A → ( ph ↔ x = y ) ) ) ;;
	step 23 : wff = jca (step 13, step 22) |- ( ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) → ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ) ;;
	step 24 : wff = a5i (step 23) |- ( ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) → ∀ x ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ) ;;
	step 25 : wff = bi1 () |- ( ( ph ↔ x = y ) → ( ph → x = y ) ) ;;
	step 26 : wff = imim2i (step 25) |- ( ( x ∈ A → ( ph ↔ x = y ) ) → ( x ∈ A → ( ph → x = y ) ) ) ;;
	step 27 : wff = imp3a (step 26) |- ( ( x ∈ A → ( ph ↔ x = y ) ) → ( ( x ∈ A ∧ ph ) → x = y ) ) ;;
	step 28 : wff = adantl (step 27) |- ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) → ( ( x ∈ A ∧ ph ) → x = y ) ) ;;
	step 29 : wff = eleq1a () |- ( y ∈ A → ( x = y → x ∈ A ) ) ;;
	step 30 : wff = adantr (step 29) |- ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) → ( x = y → x ∈ A ) ) ;;
	step 31 : wff = imp (step 30) |- ( ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ∧ x = y ) → x ∈ A ) ;;
	step 32 : wff = bi2 () |- ( ( ph ↔ x = y ) → ( x = y → ph ) ) ;;
	step 33 : wff = imim2i (step 32) |- ( ( x ∈ A → ( ph ↔ x = y ) ) → ( x ∈ A → ( x = y → ph ) ) ) ;;
	step 34 : wff = com23 (step 33) |- ( ( x ∈ A → ( ph ↔ x = y ) ) → ( x = y → ( x ∈ A → ph ) ) ) ;;
	step 35 : wff = imp (step 34) |- ( ( ( x ∈ A → ( ph ↔ x = y ) ) ∧ x = y ) → ( x ∈ A → ph ) ) ;;
	step 36 : wff = adantll (step 35) |- ( ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ∧ x = y ) → ( x ∈ A → ph ) ) ;;
	step 37 : wff = jcai (step 31, step 36) |- ( ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ∧ x = y ) → ( x ∈ A ∧ ph ) ) ;;
	step 38 : wff = ex (step 37) |- ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) → ( x = y → ( x ∈ A ∧ ph ) ) ) ;;
	step 39 : wff = impbid (step 28, step 38) |- ( ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) → ( ( x ∈ A ∧ ph ) ↔ x = y ) ) ;;
	step 40 : wff = alimi (step 39) |- ( ∀ x ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) → ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) ) ;;
	step 41 : wff = impbii (step 24, step 40) |- ( ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) ↔ ∀ x ( y ∈ A ∧ ( x ∈ A → ( ph ↔ x = y ) ) ) ) ;;
	step 42 : wff = df-ral () |- ( ∀ x ∈ A ( ph ↔ x = y ) ↔ ∀ x ( x ∈ A → ( ph ↔ x = y ) ) ) ;;
	step 43 : wff = anbi2i (step 42) |- ( ( y ∈ A ∧ ∀ x ∈ A ( ph ↔ x = y ) ) ↔ ( y ∈ A ∧ ∀ x ( x ∈ A → ( ph ↔ x = y ) ) ) ) ;;
	step 44 : wff = 3bitr4i (step 2, step 41, step 43) |- ( ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) ↔ ( y ∈ A ∧ ∀ x ∈ A ( ph ↔ x = y ) ) ) ;;
	step 45 : wff = exbii (step 44) |- ( ∃ y ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) ↔ ∃ y ( y ∈ A ∧ ∀ x ∈ A ( ph ↔ x = y ) ) ) ;;
	step 46 : wff = df-eu () |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ∃ y ∀ x ( ( x ∈ A ∧ ph ) ↔ x = y ) ) ;;
	step 47 : wff = df-rex () |- ( ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ↔ ∃ y ( y ∈ A ∧ ∀ x ∈ A ( ph ↔ x = y ) ) ) ;;
	step 48 : wff = 3bitr4i (step 45, step 46, step 47) |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ) ;;
	step 49 : wff = bitri (step 1, step 48) |- ( ∃! x ∈ A ph ↔ ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ) ;;
	qed prop 1 = step 49 ;;
}

/* A way to express restricted uniqueness.  (Contributed by NM,
       24-Oct-2006.) */

theorem reu3 (ph : wff, x : set, y : set, A : class) disjointed(x y A, x y, y ph) {
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) ) ;;
}

proof of reu3 {
	step 1 : wff = reurex () |- ( ∃! x ∈ A ph → ∃ x ∈ A ph ) ;;
	step 2 : wff = reu6 () |- ( ∃! x ∈ A ph ↔ ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ) ;;
	step 3 : wff = bi1 () |- ( ( ph ↔ x = y ) → ( ph → x = y ) ) ;;
	step 4 : wff = ralimi (step 3) |- ( ∀ x ∈ A ( ph ↔ x = y ) → ∀ x ∈ A ( ph → x = y ) ) ;;
	step 5 : wff = reximi (step 4) |- ( ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) → ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) ;;
	step 6 : wff = sylbi (step 2, step 5) |- ( ∃! x ∈ A ph → ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) ;;
	step 7 : wff = jca (step 1, step 6) |- ( ∃! x ∈ A ph → ( ∃ x ∈ A ph ∧ ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) ) ;;
	step 8 : wff = rexex () |- ( ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) → ∃ y ∀ x ∈ A ( ph → x = y ) ) ;;
	step 9 : wff = anim2i (step 8) |- ( ( ∃ x ∈ A ph ∧ ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) → ( ∃ x ∈ A ph ∧ ∃ y ∀ x ∈ A ( ph → x = y ) ) ) ;;
	step 10 : wff = nfv () |- F/ y ( x ∈ A ∧ ph ) ;;
	step 11 : wff = eu3 (step 10) |- ( ∃! x ( x ∈ A ∧ ph ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃ y ∀ x ( ( x ∈ A ∧ ph ) → x = y ) ) ) ;;
	step 12 : wff = df-reu () |- ( ∃! x ∈ A ph ↔ ∃! x ( x ∈ A ∧ ph ) ) ;;
	step 13 : wff = df-rex () |- ( ∃ x ∈ A ph ↔ ∃ x ( x ∈ A ∧ ph ) ) ;;
	step 14 : wff = df-ral () |- ( ∀ x ∈ A ( ph → x = y ) ↔ ∀ x ( x ∈ A → ( ph → x = y ) ) ) ;;
	step 15 : wff = impexp () |- ( ( ( x ∈ A ∧ ph ) → x = y ) ↔ ( x ∈ A → ( ph → x = y ) ) ) ;;
	step 16 : wff = albii (step 15) |- ( ∀ x ( ( x ∈ A ∧ ph ) → x = y ) ↔ ∀ x ( x ∈ A → ( ph → x = y ) ) ) ;;
	step 17 : wff = bitr4i (step 14, step 16) |- ( ∀ x ∈ A ( ph → x = y ) ↔ ∀ x ( ( x ∈ A ∧ ph ) → x = y ) ) ;;
	step 18 : wff = exbii (step 17) |- ( ∃ y ∀ x ∈ A ( ph → x = y ) ↔ ∃ y ∀ x ( ( x ∈ A ∧ ph ) → x = y ) ) ;;
	step 19 : wff = anbi12i (step 13, step 18) |- ( ( ∃ x ∈ A ph ∧ ∃ y ∀ x ∈ A ( ph → x = y ) ) ↔ ( ∃ x ( x ∈ A ∧ ph ) ∧ ∃ y ∀ x ( ( x ∈ A ∧ ph ) → x = y ) ) ) ;;
	step 20 : wff = 3bitr4i (step 11, step 12, step 19) |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃ y ∀ x ∈ A ( ph → x = y ) ) ) ;;
	step 21 : wff = sylibr (step 9, step 20) |- ( ( ∃ x ∈ A ph ∧ ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) → ∃! x ∈ A ph ) ;;
	step 22 : wff = impbii (step 7, step 21) |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃ y ∈ A ∀ x ∈ A ( ph → x = y ) ) ) ;;
	qed prop 1 = step 22 ;;
}

/* A condition which implies existential uniqueness.  (Contributed by Mario
       Carneiro, 2-Oct-2015.) */

theorem reu6i (ph : wff, x : set, A : class, B : class) disjointed(x y A, x y B, y ph) {
	prop 1 : wff = |- ( ( B ∈ A ∧ ∀ x ∈ A ( ph ↔ x = B ) ) → ∃! x ∈ A ph ) ;;
}

proof of reu6i {
	var y : set;;
	step 1 : wff = eqeq2 () |- ( y = B → ( x = y ↔ x = B ) ) ;;
	step 2 : wff = bibi2d (step 1) |- ( y = B → ( ( ph ↔ x = y ) ↔ ( ph ↔ x = B ) ) ) ;;
	step 3 : wff = ralbidv (step 2) |- ( y = B → ( ∀ x ∈ A ( ph ↔ x = y ) ↔ ∀ x ∈ A ( ph ↔ x = B ) ) ) ;;
	step 4 : wff = rspcev (step 3) |- ( ( B ∈ A ∧ ∀ x ∈ A ( ph ↔ x = B ) ) → ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ) ;;
	step 5 : wff = reu6 () |- ( ∃! x ∈ A ph ↔ ∃ y ∈ A ∀ x ∈ A ( ph ↔ x = y ) ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ( B ∈ A ∧ ∀ x ∈ A ( ph ↔ x = B ) ) → ∃! x ∈ A ph ) ;;
	qed prop 1 = step 6 ;;
}

/* A condition which implies existential uniqueness.  (Contributed by Mario
       Carneiro, 2-Oct-2015.) */

theorem eqreu (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = B → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( B ∈ A ∧ ps ∧ ∀ x ∈ A ( ph → x = B ) ) → ∃! x ∈ A ph ) ;;
}

proof of eqreu {
	step 1 : wff = ralbiim () |- ( ∀ x ∈ A ( ph ↔ x = B ) ↔ ( ∀ x ∈ A ( ph → x = B ) ∧ ∀ x ∈ A ( x = B → ph ) ) ) ;;
	step 2 : wff = ceqsralv (hyp 1) |- ( B ∈ A → ( ∀ x ∈ A ( x = B → ph ) ↔ ps ) ) ;;
	step 3 : wff = anbi2d (step 2) |- ( B ∈ A → ( ( ∀ x ∈ A ( ph → x = B ) ∧ ∀ x ∈ A ( x = B → ph ) ) ↔ ( ∀ x ∈ A ( ph → x = B ) ∧ ps ) ) ) ;;
	step 4 : wff = syl5bb (step 1, step 3) |- ( B ∈ A → ( ∀ x ∈ A ( ph ↔ x = B ) ↔ ( ∀ x ∈ A ( ph → x = B ) ∧ ps ) ) ) ;;
	step 5 : wff = reu6i () |- ( ( B ∈ A ∧ ∀ x ∈ A ( ph ↔ x = B ) ) → ∃! x ∈ A ph ) ;;
	step 6 : wff = ex (step 5) |- ( B ∈ A → ( ∀ x ∈ A ( ph ↔ x = B ) → ∃! x ∈ A ph ) ) ;;
	step 7 : wff = sylbird (step 4, step 6) |- ( B ∈ A → ( ( ∀ x ∈ A ( ph → x = B ) ∧ ps ) → ∃! x ∈ A ph ) ) ;;
	step 8 : wff = 3impib (step 7) |- ( ( B ∈ A ∧ ∀ x ∈ A ( ph → x = B ) ∧ ps ) → ∃! x ∈ A ph ) ;;
	step 9 : wff = 3com23 (step 8) |- ( ( B ∈ A ∧ ps ∧ ∀ x ∈ A ( ph → x = B ) ) → ∃! x ∈ A ph ) ;;
	qed prop 1 = step 9 ;;
}

/* Restricted "at most one" using implicit substitution.  (Contributed by
       NM, 24-Oct-2006.)  (Revised by NM, 16-Jun-2017.) */

theorem rmo4 (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ A ph ↔ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ;;
}

proof of rmo4 {
	step 1 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 2 : wff = an4 () |- ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) ↔ ( ( x ∈ A ∧ y ∈ A ) ∧ ( ph ∧ ps ) ) ) ;;
	step 3 : wff = ancom () |- ( ( x ∈ A ∧ y ∈ A ) ↔ ( y ∈ A ∧ x ∈ A ) ) ;;
	step 4 : wff = anbi1i (step 3) |- ( ( ( x ∈ A ∧ y ∈ A ) ∧ ( ph ∧ ps ) ) ↔ ( ( y ∈ A ∧ x ∈ A ) ∧ ( ph ∧ ps ) ) ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) ↔ ( ( y ∈ A ∧ x ∈ A ) ∧ ( ph ∧ ps ) ) ) ;;
	step 6 : wff = imbi1i (step 5) |- ( ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) → x = y ) ↔ ( ( ( y ∈ A ∧ x ∈ A ) ∧ ( ph ∧ ps ) ) → x = y ) ) ;;
	step 7 : wff = impexp () |- ( ( ( ( y ∈ A ∧ x ∈ A ) ∧ ( ph ∧ ps ) ) → x = y ) ↔ ( ( y ∈ A ∧ x ∈ A ) → ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 8 : wff = impexp () |- ( ( ( y ∈ A ∧ x ∈ A ) → ( ( ph ∧ ps ) → x = y ) ) ↔ ( y ∈ A → ( x ∈ A → ( ( ph ∧ ps ) → x = y ) ) ) ) ;;
	step 9 : wff = 3bitri (step 6, step 7, step 8) |- ( ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) → x = y ) ↔ ( y ∈ A → ( x ∈ A → ( ( ph ∧ ps ) → x = y ) ) ) ) ;;
	step 10 : wff = albii (step 9) |- ( ∀ y ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) → x = y ) ↔ ∀ y ( y ∈ A → ( x ∈ A → ( ( ph ∧ ps ) → x = y ) ) ) ) ;;
	step 11 : wff = df-ral () |- ( ∀ y ∈ A ( x ∈ A → ( ( ph ∧ ps ) → x = y ) ) ↔ ∀ y ( y ∈ A → ( x ∈ A → ( ( ph ∧ ps ) → x = y ) ) ) ) ;;
	step 12 : wff = r19.21v () |- ( ∀ y ∈ A ( x ∈ A → ( ( ph ∧ ps ) → x = y ) ) ↔ ( x ∈ A → ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 13 : wff = 3bitr2i (step 10, step 11, step 12) |- ( ∀ y ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) → x = y ) ↔ ( x ∈ A → ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 14 : wff = albii (step 13) |- ( ∀ x ∀ y ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) → x = y ) ↔ ∀ x ( x ∈ A → ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 15 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 16 : wff = anbi12d (step 15, hyp 1) |- ( x = y → ( ( x ∈ A ∧ ph ) ↔ ( y ∈ A ∧ ps ) ) ) ;;
	step 17 : wff = mo4 (step 16) |- ( ∃* x ( x ∈ A ∧ ph ) ↔ ∀ x ∀ y ( ( ( x ∈ A ∧ ph ) ∧ ( y ∈ A ∧ ps ) ) → x = y ) ) ;;
	step 18 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ↔ ∀ x ( x ∈ A → ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 19 : wff = 3bitr4i (step 14, step 17, step 18) |- ( ∃* x ( x ∈ A ∧ ph ) ↔ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ;;
	step 20 : wff = bitri (step 1, step 19) |- ( ∃* x ∈ A ph ↔ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ;;
	qed prop 1 = step 20 ;;
}

/* Restricted uniqueness using implicit substitution.  (Contributed by NM,
       23-Nov-1994.) */

theorem reu4 (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
}

proof of reu4 {
	step 1 : wff = reu5 () |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ) ;;
	step 2 : wff = rmo4 (hyp 1) |- ( ∃* x ∈ A ph ↔ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( ∃ x ∈ A ph ∧ ∃* x ∈ A ph ) ↔ ( ∃ x ∈ A ph ∧ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∀ x ∈ A ∀ y ∈ A ( ( ph ∧ ps ) → x = y ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Restricted uniqueness using implicit substitution.  (Contributed by NM,
       24-Oct-2006.) */

theorem reu7 (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y z A, y z ph, x z ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃ x ∈ A ∀ y ∈ A ( ps → x = y ) ) ) ;;
}

proof of reu7 {
	var z : set;;
	step 1 : wff = reu3 () |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃ z ∈ A ∀ x ∈ A ( ph → x = z ) ) ) ;;
	step 2 : wff = eqeq1 () |- ( x = y → ( x = z ↔ y = z ) ) ;;
	step 3 : wff = eqcom () |- ( y = z ↔ z = y ) ;;
	step 4 : wff = syl6bb (step 2, step 3) |- ( x = y → ( x = z ↔ z = y ) ) ;;
	step 5 : wff = imbi12d (hyp 1, step 4) |- ( x = y → ( ( ph → x = z ) ↔ ( ps → z = y ) ) ) ;;
	step 6 : wff = cbvralv (step 5) |- ( ∀ x ∈ A ( ph → x = z ) ↔ ∀ y ∈ A ( ps → z = y ) ) ;;
	step 7 : wff = rexbii (step 6) |- ( ∃ z ∈ A ∀ x ∈ A ( ph → x = z ) ↔ ∃ z ∈ A ∀ y ∈ A ( ps → z = y ) ) ;;
	step 8 : wff = eqeq1 () |- ( z = x → ( z = y ↔ x = y ) ) ;;
	step 9 : wff = imbi2d (step 8) |- ( z = x → ( ( ps → z = y ) ↔ ( ps → x = y ) ) ) ;;
	step 10 : wff = ralbidv (step 9) |- ( z = x → ( ∀ y ∈ A ( ps → z = y ) ↔ ∀ y ∈ A ( ps → x = y ) ) ) ;;
	step 11 : wff = cbvrexv (step 10) |- ( ∃ z ∈ A ∀ y ∈ A ( ps → z = y ) ↔ ∃ x ∈ A ∀ y ∈ A ( ps → x = y ) ) ;;
	step 12 : wff = bitri (step 7, step 11) |- ( ∃ z ∈ A ∀ x ∈ A ( ph → x = z ) ↔ ∃ x ∈ A ∀ y ∈ A ( ps → x = y ) ) ;;
	step 13 : wff = anbi2i (step 12) |- ( ( ∃ x ∈ A ph ∧ ∃ z ∈ A ∀ x ∈ A ( ph → x = z ) ) ↔ ( ∃ x ∈ A ph ∧ ∃ x ∈ A ∀ y ∈ A ( ps → x = y ) ) ) ;;
	step 14 : wff = bitri (step 1, step 13) |- ( ∃! x ∈ A ph ↔ ( ∃ x ∈ A ph ∧ ∃ x ∈ A ∀ y ∈ A ( ps → x = y ) ) ) ;;
	qed prop 1 = step 14 ;;
}

/* Restricted uniqueness using implicit substitution.  (Contributed by NM,
       24-Oct-2006.) */

theorem reu8 (ph : wff, ps : wff, x : set, y : set, A : class) disjointed(x y A, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ∈ A ph ↔ ∃ x ∈ A ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ) ;;
}

proof of reu8 {
	step 1 : wff = cbvreuv (hyp 1) |- ( ∃! x ∈ A ph ↔ ∃! y ∈ A ps ) ;;
	step 2 : wff = reu6 () |- ( ∃! y ∈ A ps ↔ ∃ x ∈ A ∀ y ∈ A ( ps ↔ y = x ) ) ;;
	step 3 : wff = dfbi2 () |- ( ( ps ↔ y = x ) ↔ ( ( ps → y = x ) ∧ ( y = x → ps ) ) ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ y ∈ A ( ps ↔ y = x ) ↔ ∀ y ∈ A ( ( ps → y = x ) ∧ ( y = x → ps ) ) ) ;;
	step 5 : wff = ancom () |- ( ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ↔ ( ∀ y ∈ A ( ps → x = y ) ∧ ph ) ) ;;
	step 6 : wff = equcom () |- ( x = y ↔ y = x ) ;;
	step 7 : wff = imbi2i (step 6) |- ( ( ps → x = y ) ↔ ( ps → y = x ) ) ;;
	step 8 : wff = ralbii (step 7) |- ( ∀ y ∈ A ( ps → x = y ) ↔ ∀ y ∈ A ( ps → y = x ) ) ;;
	step 9 : wff = a1i (step 8) |- ( x ∈ A → ( ∀ y ∈ A ( ps → x = y ) ↔ ∀ y ∈ A ( ps → y = x ) ) ) ;;
	step 10 : wff = biimt () |- ( x ∈ A → ( ph ↔ ( x ∈ A → ph ) ) ) ;;
	step 11 : wff = df-ral () |- ( ∀ y ∈ A ( y = x → ps ) ↔ ∀ y ( y ∈ A → ( y = x → ps ) ) ) ;;
	step 12 : wff = bi2.04 () |- ( ( y ∈ A → ( y = x → ps ) ) ↔ ( y = x → ( y ∈ A → ps ) ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ y ( y ∈ A → ( y = x → ps ) ) ↔ ∀ y ( y = x → ( y ∈ A → ps ) ) ) ;;
	step 14 : wff = vex () |- x ∈ _V ;;
	step 15 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 16 : wff = imbi12d (step 15, hyp 1) |- ( x = y → ( ( x ∈ A → ph ) ↔ ( y ∈ A → ps ) ) ) ;;
	step 17 : wff = bicomd (step 16) |- ( x = y → ( ( y ∈ A → ps ) ↔ ( x ∈ A → ph ) ) ) ;;
	step 18 : wff = equcoms (step 17) |- ( y = x → ( ( y ∈ A → ps ) ↔ ( x ∈ A → ph ) ) ) ;;
	step 19 : wff = ceqsalv (step 14, step 18) |- ( ∀ y ( y = x → ( y ∈ A → ps ) ) ↔ ( x ∈ A → ph ) ) ;;
	step 20 : wff = 3bitrri (step 11, step 13, step 19) |- ( ( x ∈ A → ph ) ↔ ∀ y ∈ A ( y = x → ps ) ) ;;
	step 21 : wff = syl6bb (step 10, step 20) |- ( x ∈ A → ( ph ↔ ∀ y ∈ A ( y = x → ps ) ) ) ;;
	step 22 : wff = anbi12d (step 9, step 21) |- ( x ∈ A → ( ( ∀ y ∈ A ( ps → x = y ) ∧ ph ) ↔ ( ∀ y ∈ A ( ps → y = x ) ∧ ∀ y ∈ A ( y = x → ps ) ) ) ) ;;
	step 23 : wff = syl5bb (step 5, step 22) |- ( x ∈ A → ( ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ↔ ( ∀ y ∈ A ( ps → y = x ) ∧ ∀ y ∈ A ( y = x → ps ) ) ) ) ;;
	step 24 : wff = r19.26 () |- ( ∀ y ∈ A ( ( ps → y = x ) ∧ ( y = x → ps ) ) ↔ ( ∀ y ∈ A ( ps → y = x ) ∧ ∀ y ∈ A ( y = x → ps ) ) ) ;;
	step 25 : wff = syl6rbbr (step 23, step 24) |- ( x ∈ A → ( ∀ y ∈ A ( ( ps → y = x ) ∧ ( y = x → ps ) ) ↔ ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ) ) ;;
	step 26 : wff = syl5bb (step 4, step 25) |- ( x ∈ A → ( ∀ y ∈ A ( ps ↔ y = x ) ↔ ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ) ) ;;
	step 27 : wff = rexbiia (step 26) |- ( ∃ x ∈ A ∀ y ∈ A ( ps ↔ y = x ) ↔ ∃ x ∈ A ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ) ;;
	step 28 : wff = 3bitri (step 1, step 2, step 27) |- ( ∃! x ∈ A ph ↔ ∃ x ∈ A ( ph ∧ ∀ y ∈ A ( ps → x = y ) ) ) ;;
	qed prop 1 = step 28 ;;
}

/* Equality has existential uniqueness.  (Contributed by Mario Carneiro,
       1-Sep-2015.) */

theorem reueq (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( B ∈ A ↔ ∃! x ∈ A x = B ) ;;
}

proof of reueq {
	step 1 : wff = risset () |- ( B ∈ A ↔ ∃ x ∈ A x = B ) ;;
	step 2 : wff = moeq () |- ∃* x x = B ;;
	step 3 : wff = mormo () |- ( ∃* x x = B → ∃* x ∈ A x = B ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ∃* x ∈ A x = B ;;
	step 5 : wff = reu5 () |- ( ∃! x ∈ A x = B ↔ ( ∃ x ∈ A x = B ∧ ∃* x ∈ A x = B ) ) ;;
	step 6 : wff = mpbiran2 (step 4, step 5) |- ( ∃! x ∈ A x = B ↔ ∃ x ∈ A x = B ) ;;
	step 7 : wff = bitr4i (step 1, step 6) |- ( B ∈ A ↔ ∃! x ∈ A x = B ) ;;
	qed prop 1 = step 7 ;;
}

/* Restricted "at most one" still holds when a conjunct is added.
     (Contributed by NM, 16-Jun-2017.) */

theorem rmoan (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∃* x ∈ A ph → ∃* x ∈ A ( ps ∧ ph ) ) ;;
}

proof of rmoan {
	step 1 : wff = moan () |- ( ∃* x ( x ∈ A ∧ ph ) → ∃* x ( ps ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 2 : wff = an12 () |- ( ( ps ∧ ( x ∈ A ∧ ph ) ) ↔ ( x ∈ A ∧ ( ps ∧ ph ) ) ) ;;
	step 3 : wff = mobii (step 2) |- ( ∃* x ( ps ∧ ( x ∈ A ∧ ph ) ) ↔ ∃* x ( x ∈ A ∧ ( ps ∧ ph ) ) ) ;;
	step 4 : wff = sylib (step 1, step 3) |- ( ∃* x ( x ∈ A ∧ ph ) → ∃* x ( x ∈ A ∧ ( ps ∧ ph ) ) ) ;;
	step 5 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 6 : wff = df-rmo () |- ( ∃* x ∈ A ( ps ∧ ph ) ↔ ∃* x ( x ∈ A ∧ ( ps ∧ ph ) ) ) ;;
	step 7 : wff = 3imtr4i (step 4, step 5, step 6) |- ( ∃* x ∈ A ph → ∃* x ∈ A ( ps ∧ ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Restricted "at most one" is preserved through implication (note wff
     reversal).  (Contributed by Alexander van der Vekens, 17-Jun-2017.) */

theorem rmoim (ph : wff, ps : wff, x : set, A : class)  {
	prop 1 : wff = |- ( ∀ x ∈ A ( ph → ps ) → ( ∃* x ∈ A ps → ∃* x ∈ A ph ) ) ;;
}

proof of rmoim {
	step 1 : wff = df-ral () |- ( ∀ x ∈ A ( ph → ps ) ↔ ∀ x ( x ∈ A → ( ph → ps ) ) ) ;;
	step 2 : wff = imdistan () |- ( ( x ∈ A → ( ph → ps ) ) ↔ ( ( x ∈ A ∧ ph ) → ( x ∈ A ∧ ps ) ) ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ x ( x ∈ A → ( ph → ps ) ) ↔ ∀ x ( ( x ∈ A ∧ ph ) → ( x ∈ A ∧ ps ) ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( ∀ x ∈ A ( ph → ps ) ↔ ∀ x ( ( x ∈ A ∧ ph ) → ( x ∈ A ∧ ps ) ) ) ;;
	step 5 : wff = moim () |- ( ∀ x ( ( x ∈ A ∧ ph ) → ( x ∈ A ∧ ps ) ) → ( ∃* x ( x ∈ A ∧ ps ) → ∃* x ( x ∈ A ∧ ph ) ) ) ;;
	step 6 : wff = df-rmo () |- ( ∃* x ∈ A ps ↔ ∃* x ( x ∈ A ∧ ps ) ) ;;
	step 7 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 8 : wff = 3imtr4g (step 5, step 6, step 7) |- ( ∀ x ( ( x ∈ A ∧ ph ) → ( x ∈ A ∧ ps ) ) → ( ∃* x ∈ A ps → ∃* x ∈ A ph ) ) ;;
	step 9 : wff = sylbi (step 4, step 8) |- ( ∀ x ∈ A ( ph → ps ) → ( ∃* x ∈ A ps → ∃* x ∈ A ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Restricted "at most one" is preserved through implication (note wff
       reversal).  (Contributed by Alexander van der Vekens, 17-Jun-2017.) */

theorem rmoimia (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( x ∈ A → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ A ps → ∃* x ∈ A ph ) ;;
}

proof of rmoimia {
	step 1 : wff = rmoim () |- ( ∀ x ∈ A ( ph → ps ) → ( ∃* x ∈ A ps → ∃* x ∈ A ph ) ) ;;
	step 2 : wff = mprg (step 1, hyp 1) |- ( ∃* x ∈ A ps → ∃* x ∈ A ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Restricted "at most one" is preserved through implication (note wff
       reversal).  (Contributed by Alexander van der Vekens, 17-Jun-2017.) */

theorem rmoimi2 (ph : wff, ps : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- ∀ x ( ( x ∈ A ∧ ph ) → ( x ∈ B ∧ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ∈ B ps → ∃* x ∈ A ph ) ;;
}

proof of rmoimi2 {
	step 1 : wff = moim () |- ( ∀ x ( ( x ∈ A ∧ ph ) → ( x ∈ B ∧ ps ) ) → ( ∃* x ( x ∈ B ∧ ps ) → ∃* x ( x ∈ A ∧ ph ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ∃* x ( x ∈ B ∧ ps ) → ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 3 : wff = df-rmo () |- ( ∃* x ∈ B ps ↔ ∃* x ( x ∈ B ∧ ps ) ) ;;
	step 4 : wff = df-rmo () |- ( ∃* x ∈ A ph ↔ ∃* x ( x ∈ A ∧ ph ) ) ;;
	step 5 : wff = 3imtr4i (step 2, step 3, step 4) |- ( ∃* x ∈ B ps → ∃* x ∈ A ph ) ;;
	qed prop 1 = step 5 ;;
}

/* A condition allowing swap of uniqueness and existential quantifiers.
       (Contributed by Thierry Arnoux, 7-Apr-2017.)  (Revised by NM,
       16-Jun-2017.) */

theorem 2reuswap (ph : wff, x : set, y : set, A : class, B : class) disjointed(x y A, x B) {
	prop 1 : wff = |- ( ∀ x ∈ A ∃* y ∈ B ph → ( ∃! x ∈ A ∃ y ∈ B ph → ∃! y ∈ B ∃ x ∈ A ph ) ) ;;
}

proof of 2reuswap {
	step 1 : wff = df-rmo () |- ( ∃* y ∈ B ph ↔ ∃* y ( y ∈ B ∧ ph ) ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ∃* y ∈ B ph ↔ ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) ↔ ∀ x ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = moanimv () |- ( ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ x ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ∀ x ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ) ;;
	step 6 : wff = bitr4i (step 3, step 5) |- ( ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) ↔ ∀ x ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 7 : wff = 2euswap () |- ( ∀ x ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) → ( ∃! x ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) → ∃! y ∃ x ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ) ;;
	step 8 : wff = df-reu () |- ( ∃! x ∈ A ∃ y ∈ B ph ↔ ∃! x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 9 : wff = r19.42v () |- ( ∃ y ∈ B ( x ∈ A ∧ ph ) ↔ ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 10 : wff = df-rex () |- ( ∃ y ∈ B ( x ∈ A ∧ ph ) ↔ ∃ y ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 11 : wff = bitr3i (step 9, step 10) |- ( ( x ∈ A ∧ ∃ y ∈ B ph ) ↔ ∃ y ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 12 : wff = an12 () |- ( ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ y ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) ↔ ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 14 : wff = bitri (step 11, step 13) |- ( ( x ∈ A ∧ ∃ y ∈ B ph ) ↔ ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 15 : wff = eubii (step 14) |- ( ∃! x ( x ∈ A ∧ ∃ y ∈ B ph ) ↔ ∃! x ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 16 : wff = bitri (step 8, step 15) |- ( ∃! x ∈ A ∃ y ∈ B ph ↔ ∃! x ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 17 : wff = df-reu () |- ( ∃! y ∈ B ∃ x ∈ A ph ↔ ∃! y ( y ∈ B ∧ ∃ x ∈ A ph ) ) ;;
	step 18 : wff = r19.42v () |- ( ∃ x ∈ A ( y ∈ B ∧ ph ) ↔ ( y ∈ B ∧ ∃ x ∈ A ph ) ) ;;
	step 19 : wff = df-rex () |- ( ∃ x ∈ A ( y ∈ B ∧ ph ) ↔ ∃ x ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 20 : wff = bitr3i (step 18, step 19) |- ( ( y ∈ B ∧ ∃ x ∈ A ph ) ↔ ∃ x ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 21 : wff = eubii (step 20) |- ( ∃! y ( y ∈ B ∧ ∃ x ∈ A ph ) ↔ ∃! y ∃ x ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 22 : wff = bitri (step 17, step 21) |- ( ∃! y ∈ B ∃ x ∈ A ph ↔ ∃! y ∃ x ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 23 : wff = 3imtr4g (step 7, step 16, step 22) |- ( ∀ x ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) → ( ∃! x ∈ A ∃ y ∈ B ph → ∃! y ∈ B ∃ x ∈ A ph ) ) ;;
	step 24 : wff = sylbi (step 6, step 23) |- ( ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) → ( ∃! x ∈ A ∃ y ∈ B ph → ∃! y ∈ B ∃ x ∈ A ph ) ) ;;
	step 25 : wff = sylbi (step 2, step 24) |- ( ∀ x ∈ A ∃* y ∈ B ph → ( ∃! x ∈ A ∃ y ∈ B ph → ∃! y ∈ B ∃ x ∈ A ph ) ) ;;
	qed prop 1 = step 25 ;;
}

/* Existential uniqueness via an indirect equality.  (Contributed by NM,
       16-Oct-2010.) */

theorem reuind (ph : wff, ps : wff, x : set, y : set, z : set, A : class, B : class, C : class) disjointed(w y z A, x z B, w x y z C, w y z ph, x z ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( x = y → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) ∧ ∃ x ( A ∈ C ∧ ph ) ) → ∃! z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ;;
}

proof of reuind {
	var w : set;;
	step 1 : wff = eleq1d (hyp 2) |- ( x = y → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = anbi12d (step 1, hyp 1) |- ( x = y → ( ( A ∈ C ∧ ph ) ↔ ( B ∈ C ∧ ps ) ) ) ;;
	step 3 : wff = cbvexv (step 2) |- ( ∃ x ( A ∈ C ∧ ph ) ↔ ∃ y ( B ∈ C ∧ ps ) ) ;;
	step 4 : wff = r19.41v () |- ( ∃ z ∈ C ( z = B ∧ ps ) ↔ ( ∃ z ∈ C z = B ∧ ps ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ∃ z ∈ C ( z = B ∧ ps ) ↔ ∃ y ( ∃ z ∈ C z = B ∧ ps ) ) ;;
	step 6 : wff = rexcom4 () |- ( ∃ z ∈ C ∃ y ( z = B ∧ ps ) ↔ ∃ y ∃ z ∈ C ( z = B ∧ ps ) ) ;;
	step 7 : wff = risset () |- ( B ∈ C ↔ ∃ z ∈ C z = B ) ;;
	step 8 : wff = anbi1i (step 7) |- ( ( B ∈ C ∧ ps ) ↔ ( ∃ z ∈ C z = B ∧ ps ) ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ y ( B ∈ C ∧ ps ) ↔ ∃ y ( ∃ z ∈ C z = B ∧ ps ) ) ;;
	step 10 : wff = 3bitr4ri (step 5, step 6, step 9) |- ( ∃ y ( B ∈ C ∧ ps ) ↔ ∃ z ∈ C ∃ y ( z = B ∧ ps ) ) ;;
	step 11 : wff = bitri (step 3, step 10) |- ( ∃ x ( A ∈ C ∧ ph ) ↔ ∃ z ∈ C ∃ y ( z = B ∧ ps ) ) ;;
	step 12 : wff = eqeq2 () |- ( A = B → ( z = A ↔ z = B ) ) ;;
	step 13 : wff = imim2i (step 12) |- ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → ( z = A ↔ z = B ) ) ) ;;
	step 14 : wff = bi2 () |- ( ( z = A ↔ z = B ) → ( z = B → z = A ) ) ;;
	step 15 : wff = imim2i (step 14) |- ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → ( z = A ↔ z = B ) ) → ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → ( z = B → z = A ) ) ) ;;
	step 16 : wff = an31 () |- ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) ∧ z = B ) ↔ ( ( z = B ∧ ( B ∈ C ∧ ps ) ) ∧ ( A ∈ C ∧ ph ) ) ) ;;
	step 17 : wff = imbi1i (step 16) |- ( ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) ∧ z = B ) → z = A ) ↔ ( ( ( z = B ∧ ( B ∈ C ∧ ps ) ) ∧ ( A ∈ C ∧ ph ) ) → z = A ) ) ;;
	step 18 : wff = impexp () |- ( ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) ∧ z = B ) → z = A ) ↔ ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → ( z = B → z = A ) ) ) ;;
	step 19 : wff = impexp () |- ( ( ( ( z = B ∧ ( B ∈ C ∧ ps ) ) ∧ ( A ∈ C ∧ ph ) ) → z = A ) ↔ ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 20 : wff = 3bitr3i (step 17, step 18, step 19) |- ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → ( z = B → z = A ) ) ↔ ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 21 : wff = sylib (step 15, step 20) |- ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → ( z = A ↔ z = B ) ) → ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 22 : wff = syl (step 13, step 21) |- ( ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 23 : wff = 2alimi (step 22) |- ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ∀ x ∀ y ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 24 : wff = 19.23v () |- ( ∀ y ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ↔ ( ∃ y ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 25 : wff = an12 () |- ( ( z = B ∧ ( B ∈ C ∧ ps ) ) ↔ ( B ∈ C ∧ ( z = B ∧ ps ) ) ) ;;
	step 26 : wff = eleq1 () |- ( z = B → ( z ∈ C ↔ B ∈ C ) ) ;;
	step 27 : wff = adantr (step 26) |- ( ( z = B ∧ ps ) → ( z ∈ C ↔ B ∈ C ) ) ;;
	step 28 : wff = pm5.32ri (step 27) |- ( ( z ∈ C ∧ ( z = B ∧ ps ) ) ↔ ( B ∈ C ∧ ( z = B ∧ ps ) ) ) ;;
	step 29 : wff = bitr4i (step 25, step 28) |- ( ( z = B ∧ ( B ∈ C ∧ ps ) ) ↔ ( z ∈ C ∧ ( z = B ∧ ps ) ) ) ;;
	step 30 : wff = exbii (step 29) |- ( ∃ y ( z = B ∧ ( B ∈ C ∧ ps ) ) ↔ ∃ y ( z ∈ C ∧ ( z = B ∧ ps ) ) ) ;;
	step 31 : wff = 19.42v () |- ( ∃ y ( z ∈ C ∧ ( z = B ∧ ps ) ) ↔ ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) ) ;;
	step 32 : wff = bitri (step 30, step 31) |- ( ∃ y ( z = B ∧ ( B ∈ C ∧ ps ) ) ↔ ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) ) ;;
	step 33 : wff = imbi1i (step 32) |- ( ( ∃ y ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ↔ ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 34 : wff = bitri (step 24, step 33) |- ( ∀ y ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ↔ ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 35 : wff = albii (step 34) |- ( ∀ x ∀ y ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ↔ ∀ x ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 36 : wff = 19.21v () |- ( ∀ x ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ↔ ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 37 : wff = bitri (step 35, step 36) |- ( ∀ x ∀ y ( ( z = B ∧ ( B ∈ C ∧ ps ) ) → ( ( A ∈ C ∧ ph ) → z = A ) ) ↔ ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 38 : wff = sylib (step 23, step 37) |- ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ( ( z ∈ C ∧ ∃ y ( z = B ∧ ps ) ) → ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 39 : wff = exp3a (step 38) |- ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ( z ∈ C → ( ∃ y ( z = B ∧ ps ) → ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ) ) ;;
	step 40 : wff = reximdvai (step 39) |- ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ( ∃ z ∈ C ∃ y ( z = B ∧ ps ) → ∃ z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 41 : wff = syl5bi (step 11, step 40) |- ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) → ( ∃ x ( A ∈ C ∧ ph ) → ∃ z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ) ;;
	step 42 : wff = imp (step 41) |- ( ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) ∧ ∃ x ( A ∈ C ∧ ph ) ) → ∃ z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ;;
	step 43 : wff = pm4.24 () |- ( ( A ∈ C ∧ ph ) ↔ ( ( A ∈ C ∧ ph ) ∧ ( A ∈ C ∧ ph ) ) ) ;;
	step 44 : wff = biimpi (step 43) |- ( ( A ∈ C ∧ ph ) → ( ( A ∈ C ∧ ph ) ∧ ( A ∈ C ∧ ph ) ) ) ;;
	step 45 : wff = prth () |- ( ( ( ( A ∈ C ∧ ph ) → z = A ) ∧ ( ( A ∈ C ∧ ph ) → w = A ) ) → ( ( ( A ∈ C ∧ ph ) ∧ ( A ∈ C ∧ ph ) ) → ( z = A ∧ w = A ) ) ) ;;
	step 46 : wff = eqtr3 () |- ( ( z = A ∧ w = A ) → z = w ) ;;
	step 47 : wff = syl56 (step 44, step 45, step 46) |- ( ( ( ( A ∈ C ∧ ph ) → z = A ) ∧ ( ( A ∈ C ∧ ph ) → w = A ) ) → ( ( A ∈ C ∧ ph ) → z = w ) ) ;;
	step 48 : wff = alanimi (step 47) |- ( ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) → ∀ x ( ( A ∈ C ∧ ph ) → z = w ) ) ;;
	step 49 : wff = 19.23v () |- ( ∀ x ( ( A ∈ C ∧ ph ) → z = w ) ↔ ( ∃ x ( A ∈ C ∧ ph ) → z = w ) ) ;;
	step 50 : wff = biimpi (step 49) |- ( ∀ x ( ( A ∈ C ∧ ph ) → z = w ) → ( ∃ x ( A ∈ C ∧ ph ) → z = w ) ) ;;
	step 51 : wff = com12 (step 50) |- ( ∃ x ( A ∈ C ∧ ph ) → ( ∀ x ( ( A ∈ C ∧ ph ) → z = w ) → z = w ) ) ;;
	step 52 : wff = syl5 (step 48, step 51) |- ( ∃ x ( A ∈ C ∧ ph ) → ( ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) → z = w ) ) ;;
	step 53 : wff = a1d (step 52) |- ( ∃ x ( A ∈ C ∧ ph ) → ( ( z ∈ C ∧ w ∈ C ) → ( ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) → z = w ) ) ) ;;
	step 54 : wff = ralrimivv (step 53) |- ( ∃ x ( A ∈ C ∧ ph ) → ∀ z ∈ C ∀ w ∈ C ( ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) → z = w ) ) ;;
	step 55 : wff = adantl (step 54) |- ( ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) ∧ ∃ x ( A ∈ C ∧ ph ) ) → ∀ z ∈ C ∀ w ∈ C ( ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) → z = w ) ) ;;
	step 56 : wff = eqeq1 () |- ( z = w → ( z = A ↔ w = A ) ) ;;
	step 57 : wff = imbi2d (step 56) |- ( z = w → ( ( ( A ∈ C ∧ ph ) → z = A ) ↔ ( ( A ∈ C ∧ ph ) → w = A ) ) ) ;;
	step 58 : wff = albidv (step 57) |- ( z = w → ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ↔ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) ) ;;
	step 59 : wff = reu4 (step 58) |- ( ∃! z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ↔ ( ∃ z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ z ∈ C ∀ w ∈ C ( ( ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ∧ ∀ x ( ( A ∈ C ∧ ph ) → w = A ) ) → z = w ) ) ) ;;
	step 60 : wff = sylanbrc (step 42, step 55, step 59) |- ( ( ∀ x ∀ y ( ( ( A ∈ C ∧ ph ) ∧ ( B ∈ C ∧ ps ) ) → A = B ) ∧ ∃ x ( A ∈ C ∧ ph ) ) → ∃! z ∈ C ∀ x ( ( A ∈ C ∧ ph ) → z = A ) ) ;;
	qed prop 1 = step 60 ;;
}

/* Double restricted quantification with "at most one," analogous to
       ~ 2moex .  (Contributed by Alexander van der Vekens, 17-Jun-2017.) */

theorem 2rmorex (ph : wff, x : set, y : set, A : class, B : class) disjointed(y A, x B, x y) {
	prop 1 : wff = |- ( ∃* x ∈ A ∃ y ∈ B ph → ∀ y ∈ B ∃* x ∈ A ph ) ;;
}

proof of 2rmorex {
	step 1 : wff = nfcv () |- F/_ y A ;;
	step 2 : wff = nfre1 () |- F/ y ∃ y ∈ B ph ;;
	step 3 : wff = nfrmo (step 1, step 2) |- F/ y ∃* x ∈ A ∃ y ∈ B ph ;;
	step 4 : wff = rspe () |- ( ( y ∈ B ∧ ph ) → ∃ y ∈ B ph ) ;;
	step 5 : wff = ex (step 4) |- ( y ∈ B → ( ph → ∃ y ∈ B ph ) ) ;;
	step 6 : wff = ralrimivw (step 5) |- ( y ∈ B → ∀ x ∈ A ( ph → ∃ y ∈ B ph ) ) ;;
	step 7 : wff = rmoim () |- ( ∀ x ∈ A ( ph → ∃ y ∈ B ph ) → ( ∃* x ∈ A ∃ y ∈ B ph → ∃* x ∈ A ph ) ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( y ∈ B → ( ∃* x ∈ A ∃ y ∈ B ph → ∃* x ∈ A ph ) ) ;;
	step 9 : wff = com12 (step 8) |- ( ∃* x ∈ A ∃ y ∈ B ph → ( y ∈ B → ∃* x ∈ A ph ) ) ;;
	step 10 : wff = ralrimi (step 3, step 9) |- ( ∃* x ∈ A ∃ y ∈ B ph → ∀ y ∈ B ∃* x ∈ A ph ) ;;
	qed prop 1 = step 10 ;;
}

/* Lemma for ~ 2reu5 .  Note that ` E! x e. A E! y e. B ph ` does not mean
       "there is exactly one ` x ` in ` A ` and exactly one ` y ` in ` B ` such
       that ` ph ` holds;" see comment for ~ 2eu5 .  (Contributed by Alexander
       van der Vekens, 17-Jun-2017.) */

theorem 2reu5lem1 (ph : wff, x : set, y : set, A : class, B : class) disjointed(y A, x B, x y) {
	prop 1 : wff = |- ( ∃! x ∈ A ∃! y ∈ B ph ↔ ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
}

proof of 2reu5lem1 {
	step 1 : wff = df-reu () |- ( ∃! y ∈ B ph ↔ ∃! y ( y ∈ B ∧ ph ) ) ;;
	step 2 : wff = reubii (step 1) |- ( ∃! x ∈ A ∃! y ∈ B ph ↔ ∃! x ∈ A ∃! y ( y ∈ B ∧ ph ) ) ;;
	step 3 : wff = df-reu () |- ( ∃! x ∈ A ∃! y ( y ∈ B ∧ ph ) ↔ ∃! x ( x ∈ A ∧ ∃! y ( y ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = euanv () |- ( ∃! y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ ∃! y ( y ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = bicomi (step 4) |- ( ( x ∈ A ∧ ∃! y ( y ∈ B ∧ ph ) ) ↔ ∃! y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 6 : wff = 3anass () |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 7 : wff = bicomi (step 6) |- ( ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 8 : wff = eubii (step 7) |- ( ∃! y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 9 : wff = bitri (step 5, step 8) |- ( ( x ∈ A ∧ ∃! y ( y ∈ B ∧ ph ) ) ↔ ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 10 : wff = eubii (step 9) |- ( ∃! x ( x ∈ A ∧ ∃! y ( y ∈ B ∧ ph ) ) ↔ ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 11 : wff = bitri (step 3, step 10) |- ( ∃! x ∈ A ∃! y ( y ∈ B ∧ ph ) ↔ ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 12 : wff = bitri (step 2, step 11) |- ( ∃! x ∈ A ∃! y ∈ B ph ↔ ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Lemma for ~ 2reu5 .  (Contributed by Alexander van der Vekens,
       17-Jun-2017.) */

theorem 2reu5lem2 (ph : wff, x : set, y : set, A : class, B : class) disjointed(y A, x B, x y) {
	prop 1 : wff = |- ( ∀ x ∈ A ∃* y ∈ B ph ↔ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
}

proof of 2reu5lem2 {
	step 1 : wff = df-rmo () |- ( ∃* y ∈ B ph ↔ ∃* y ( y ∈ B ∧ ph ) ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A ∃* y ∈ B ph ↔ ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) ) ;;
	step 3 : wff = df-ral () |- ( ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) ↔ ∀ x ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = moanimv () |- ( ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ) ;;
	step 5 : wff = bicomi (step 4) |- ( ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ↔ ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 6 : wff = 3anass () |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 7 : wff = bicomi (step 6) |- ( ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 8 : wff = mobii (step 7) |- ( ∃* y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 9 : wff = bitri (step 5, step 8) |- ( ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ↔ ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 10 : wff = albii (step 9) |- ( ∀ x ( x ∈ A → ∃* y ( y ∈ B ∧ ph ) ) ↔ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 11 : wff = bitri (step 3, step 10) |- ( ∀ x ∈ A ∃* y ( y ∈ B ∧ ph ) ↔ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 12 : wff = bitri (step 2, step 11) |- ( ∀ x ∈ A ∃* y ∈ B ph ↔ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Lemma for ~ 2reu5 .  This lemma is interesting in its own right, showing
       that existential restriction in the last conjunct (the "at most one"
       part) is optional; compare ~ rmo2 .  (Contributed by Alexander van der
       Vekens, 17-Jun-2017.) */

theorem 2reu5lem3 (ph : wff, x : set, y : set, z : set, w : set, A : class, B : class) disjointed(w y z A, w x z B, x y, ph w, ph z) {
	prop 1 : wff = |- ( ( ∃! x ∈ A ∃! y ∈ B ph ∧ ∀ x ∈ A ∃* y ∈ B ph ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
}

proof of 2reu5lem3 {
	step 1 : wff = 2reu5lem1 () |- ( ∃! x ∈ A ∃! y ∈ B ph ↔ ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 2 : wff = 2reu5lem2 () |- ( ∀ x ∈ A ∃* y ∈ B ph ↔ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ;;
	step 3 : wff = anbi12i (step 1, step 2) |- ( ( ∃! x ∈ A ∃! y ∈ B ph ∧ ∀ x ∈ A ∃* y ∈ B ph ) ↔ ( ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ∧ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ) ;;
	step 4 : wff = 2eu5 () |- ( ( ∃! x ∃! y ( x ∈ A ∧ y ∈ B ∧ ph ) ∧ ∀ x ∃* y ( x ∈ A ∧ y ∈ B ∧ ph ) ) ↔ ( ∃ x ∃ y ( x ∈ A ∧ y ∈ B ∧ ph ) ∧ ∃ z ∃ w ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ) ) ;;
	step 5 : wff = 3anass () |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ) ;;
	step 7 : wff = 19.42v () |- ( ∃ y ( x ∈ A ∧ ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ ∃ y ( y ∈ B ∧ ph ) ) ) ;;
	step 8 : wff = df-rex () |- ( ∃ y ∈ B ph ↔ ∃ y ( y ∈ B ∧ ph ) ) ;;
	step 9 : wff = bicomi (step 8) |- ( ∃ y ( y ∈ B ∧ ph ) ↔ ∃ y ∈ B ph ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( x ∈ A ∧ ∃ y ( y ∈ B ∧ ph ) ) ↔ ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 11 : wff = 3bitri (step 6, step 7, step 10) |- ( ∃ y ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ x ∃ y ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 13 : wff = df-rex () |- ( ∃ x ∈ A ∃ y ∈ B ph ↔ ∃ x ( x ∈ A ∧ ∃ y ∈ B ph ) ) ;;
	step 14 : wff = bitr4i (step 12, step 13) |- ( ∃ x ∃ y ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ∃ x ∈ A ∃ y ∈ B ph ) ;;
	step 15 : wff = 3anan12 () |- ( ( x ∈ A ∧ y ∈ B ∧ ph ) ↔ ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) ) ;;
	step 16 : wff = imbi1i (step 15) |- ( ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ( ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) → ( x = z ∧ y = w ) ) ) ;;
	step 17 : wff = impexp () |- ( ( ( y ∈ B ∧ ( x ∈ A ∧ ph ) ) → ( x = z ∧ y = w ) ) ↔ ( y ∈ B → ( ( x ∈ A ∧ ph ) → ( x = z ∧ y = w ) ) ) ) ;;
	step 18 : wff = impexp () |- ( ( ( x ∈ A ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 19 : wff = imbi2i (step 18) |- ( ( y ∈ B → ( ( x ∈ A ∧ ph ) → ( x = z ∧ y = w ) ) ) ↔ ( y ∈ B → ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 20 : wff = 3bitri (step 16, step 17, step 19) |- ( ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ( y ∈ B → ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 21 : wff = albii (step 20) |- ( ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ∀ y ( y ∈ B → ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 22 : wff = df-ral () |- ( ∀ y ∈ B ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ↔ ∀ y ( y ∈ B → ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 23 : wff = r19.21v () |- ( ∀ y ∈ B ( x ∈ A → ( ph → ( x = z ∧ y = w ) ) ) ↔ ( x ∈ A → ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 24 : wff = 3bitr2i (step 21, step 22, step 23) |- ( ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ( x ∈ A → ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 25 : wff = albii (step 24) |- ( ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ∀ x ( x ∈ A → ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 26 : wff = df-ral () |- ( ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ( x ∈ A → ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 27 : wff = bitr4i (step 25, step 26) |- ( ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 28 : wff = exbii (step 27) |- ( ∃ w ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 29 : wff = exbii (step 28) |- ( ∃ z ∃ w ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 30 : wff = anbi12i (step 14, step 29) |- ( ( ∃ x ∃ y ( x ∈ A ∧ y ∈ B ∧ ph ) ∧ ∃ z ∃ w ∀ x ∀ y ( ( x ∈ A ∧ y ∈ B ∧ ph ) → ( x = z ∧ y = w ) ) ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 31 : wff = 3bitri (step 3, step 4, step 30) |- ( ( ∃! x ∈ A ∃! y ∈ B ph ∧ ∀ x ∈ A ∃* y ∈ B ph ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	qed prop 1 = step 31 ;;
}

/* Double restricted existential uniqueness in terms of restricted
       existential quantification and restricted universal quantification,
       analogous to ~ 2eu5 and ~ reu3 .  (Contributed by Alexander van der
       Vekens, 17-Jun-2017.) */

theorem 2reu5 (ph : wff, x : set, y : set, z : set, w : set, A : class, B : class) disjointed(w y z A, w x z B, x y, ph w, ph z, x A, y B) {
	prop 1 : wff = |- ( ( ∃! x ∈ A ∃! y ∈ B ph ∧ ∀ x ∈ A ∃* y ∈ B ph ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∈ A ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
}

proof of 2reu5 {
	step 1 : wff = r19.29r () |- ( ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) → ∃ x ∈ A ( ∃ y ∈ B ph ∧ ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 2 : wff = r19.29r () |- ( ( ∃ y ∈ B ph ∧ ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) → ∃ y ∈ B ( ph ∧ ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 3 : wff = reximi (step 2) |- ( ∃ x ∈ A ( ∃ y ∈ B ph ∧ ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) → ∃ x ∈ A ∃ y ∈ B ( ph ∧ ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 4 : wff = pm3.35 () |- ( ( ph ∧ ( ph → ( x = z ∧ y = w ) ) ) → ( x = z ∧ y = w ) ) ;;
	step 5 : wff = reximi (step 4) |- ( ∃ y ∈ B ( ph ∧ ( ph → ( x = z ∧ y = w ) ) ) → ∃ y ∈ B ( x = z ∧ y = w ) ) ;;
	step 6 : wff = reximi (step 5) |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ( ph → ( x = z ∧ y = w ) ) ) → ∃ x ∈ A ∃ y ∈ B ( x = z ∧ y = w ) ) ;;
	step 7 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 8 : wff = eleq1 () |- ( y = w → ( y ∈ B ↔ w ∈ B ) ) ;;
	step 9 : wff = bi2anan9 (step 7, step 8) |- ( ( x = z ∧ y = w ) → ( ( x ∈ A ∧ y ∈ B ) ↔ ( z ∈ A ∧ w ∈ B ) ) ) ;;
	step 10 : wff = biimpac (step 9) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ( x = z ∧ y = w ) ) → ( z ∈ A ∧ w ∈ B ) ) ;;
	step 11 : wff = ancomd (step 10) |- ( ( ( x ∈ A ∧ y ∈ B ) ∧ ( x = z ∧ y = w ) ) → ( w ∈ B ∧ z ∈ A ) ) ;;
	step 12 : wff = ex (step 11) |- ( ( x ∈ A ∧ y ∈ B ) → ( ( x = z ∧ y = w ) → ( w ∈ B ∧ z ∈ A ) ) ) ;;
	step 13 : wff = rexlimivv (step 12) |- ( ∃ x ∈ A ∃ y ∈ B ( x = z ∧ y = w ) → ( w ∈ B ∧ z ∈ A ) ) ;;
	step 14 : wff = syl (step 6, step 13) |- ( ∃ x ∈ A ∃ y ∈ B ( ph ∧ ( ph → ( x = z ∧ y = w ) ) ) → ( w ∈ B ∧ z ∈ A ) ) ;;
	step 15 : wff = 3syl (step 1, step 3, step 14) |- ( ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) → ( w ∈ B ∧ z ∈ A ) ) ;;
	step 16 : wff = ex (step 15) |- ( ∃ x ∈ A ∃ y ∈ B ph → ( ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) → ( w ∈ B ∧ z ∈ A ) ) ) ;;
	step 17 : wff = pm4.71rd (step 16) |- ( ∃ x ∈ A ∃ y ∈ B ph → ( ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ↔ ( ( w ∈ B ∧ z ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 18 : wff = anass () |- ( ( ( w ∈ B ∧ z ∈ A ) ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 19 : wff = syl6bb (step 17, step 18) |- ( ∃ x ∈ A ∃ y ∈ B ph → ( ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ↔ ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ) ;;
	step 20 : wff = 2exbidv (step 19) |- ( ∃ x ∈ A ∃ y ∈ B ph → ( ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ↔ ∃ z ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ) ;;
	step 21 : wff = pm5.32i (step 20) |- ( ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ) ;;
	step 22 : wff = 2reu5lem3 () |- ( ( ∃! x ∈ A ∃! y ∈ B ph ∧ ∀ x ∈ A ∃* y ∈ B ph ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 23 : wff = df-rex () |- ( ∃ z ∈ A ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ↔ ∃ z ( z ∈ A ∧ ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 24 : wff = r19.42v () |- ( ∃ w ∈ B ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ( z ∈ A ∧ ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 25 : wff = df-rex () |- ( ∃ w ∈ B ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 26 : wff = bitr3i (step 24, step 25) |- ( ( z ∈ A ∧ ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 27 : wff = exbii (step 26) |- ( ∃ z ( z ∈ A ∧ ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ∃ z ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 28 : wff = bitri (step 23, step 27) |- ( ∃ z ∈ A ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ↔ ∃ z ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 29 : wff = anbi2i (step 28) |- ( ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∈ A ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∃ w ( w ∈ B ∧ ( z ∈ A ∧ ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ) ) ;;
	step 30 : wff = 3bitr4i (step 21, step 22, step 29) |- ( ( ∃! x ∈ A ∃! y ∈ B ph ∧ ∀ x ∈ A ∃* y ∈ B ph ) ↔ ( ∃ x ∈ A ∃ y ∈ B ph ∧ ∃ z ∈ A ∃ w ∈ B ∀ x ∈ A ∀ y ∈ B ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	qed prop 1 = step 30 ;;
}


