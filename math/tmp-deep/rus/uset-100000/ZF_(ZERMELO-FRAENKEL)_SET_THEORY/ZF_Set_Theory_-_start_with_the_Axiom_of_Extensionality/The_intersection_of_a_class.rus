import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/The_union_of_a_class.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        The intersection of a class

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Declare class intersection symbol. */

constant {
	symbol ⋂ ;;
	ascii |^| ;;
	latex \bigcap ;;
}

/* Big cap */

/* Extend class notation to include the intersection of a class (read:
     'intersect ` A ` '). */

rule cint (A : class) {
	term : class = # ⋂ A ;;
}

/* Define the intersection of a class.  Definition 7.35 of [TakeutiZaring]
       p. 44.  For example, ` |^| { { 1 , 3 } , { 1 , 8 } } = { 1 } ` .
       Compare this with the intersection of two classes, ~ df-in .
       (Contributed by NM, 18-Aug-1993.) */

definition df-int (x : set, y : set, A : class) disjointed(x y A) {
	defiendum : class = # ⋂ A ;;
	definiens : class = # { x | ∀ y ( y ∈ A → x ∈ y ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Alternate definition of class intersection.  (Contributed by NM,
       28-Jun-1998.) */

theorem dfint2 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ⋂ A = { x | ∀ y ∈ A x ∈ y } ;;
}

proof of dfint2 {
	step 1 : wff = df-int () |- ⋂ A = { x | ∀ y ( y ∈ A → x ∈ y ) } ;;
	step 2 : wff = df-ral () |- ( ∀ y ∈ A x ∈ y ↔ ∀ y ( y ∈ A → x ∈ y ) ) ;;
	step 3 : wff = abbii (step 2) |- { x | ∀ y ∈ A x ∈ y } = { x | ∀ y ( y ∈ A → x ∈ y ) } ;;
	step 4 : wff = eqtr4i (step 1, step 3) |- ⋂ A = { x | ∀ y ∈ A x ∈ y } ;;
	qed prop 1 = step 4 ;;
}

/* Equality law for intersection.  (Contributed by NM, 13-Sep-1999.) */

theorem inteq (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A = B → ⋂ A = ⋂ B ) ;;
}

proof of inteq {
	var x : set, y : set;;
	step 1 : wff = raleq () |- ( A = B → ( ∀ y ∈ A x ∈ y ↔ ∀ y ∈ B x ∈ y ) ) ;;
	step 2 : wff = abbidv (step 1) |- ( A = B → { x | ∀ y ∈ A x ∈ y } = { x | ∀ y ∈ B x ∈ y } ) ;;
	step 3 : wff = dfint2 () |- ⋂ A = { x | ∀ y ∈ A x ∈ y } ;;
	step 4 : wff = dfint2 () |- ⋂ B = { x | ∀ y ∈ B x ∈ y } ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ⋂ A = ⋂ B ) ;;
	qed prop 1 = step 5 ;;
}

/* Equality inference for class intersection.  (Contributed by NM,
       2-Sep-2003.) */

theorem inteqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ⋂ A = ⋂ B ;;
}

proof of inteqi {
	step 1 : wff = inteq () |- ( A = B → ⋂ A = ⋂ B ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ⋂ A = ⋂ B ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for class intersection.  (Contributed by NM,
       2-Sep-2003.) */

theorem inteqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ⋂ A = ⋂ B ) ;;
}

proof of inteqd {
	step 1 : wff = inteq () |- ( A = B → ⋂ A = ⋂ B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ⋂ A = ⋂ B ) ;;
	qed prop 1 = step 2 ;;
}

/* Membership in class intersection.  (Contributed by NM, 21-May-1994.) */

theorem elint (x : set, A : class, B : class) disjointed(x A y, x B y) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ⋂ B ↔ ∀ x ( x ∈ B → A ∈ x ) ) ;;
}

proof of elint {
	var y : set;;
	step 1 : wff = eleq1 () |- ( y = A → ( y ∈ x ↔ A ∈ x ) ) ;;
	step 2 : wff = imbi2d (step 1) |- ( y = A → ( ( x ∈ B → y ∈ x ) ↔ ( x ∈ B → A ∈ x ) ) ) ;;
	step 3 : wff = albidv (step 2) |- ( y = A → ( ∀ x ( x ∈ B → y ∈ x ) ↔ ∀ x ( x ∈ B → A ∈ x ) ) ) ;;
	step 4 : wff = df-int () |- ⋂ B = { y | ∀ x ( x ∈ B → y ∈ x ) } ;;
	step 5 : wff = elab2 (hyp 1, step 3, step 4) |- ( A ∈ ⋂ B ↔ ∀ x ( x ∈ B → A ∈ x ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Membership in class intersection.  (Contributed by NM, 14-Oct-1999.) */

theorem elint2 (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ⋂ B ↔ ∀ x ∈ B A ∈ x ) ;;
}

proof of elint2 {
	step 1 : wff = elint (hyp 1) |- ( A ∈ ⋂ B ↔ ∀ x ( x ∈ B → A ∈ x ) ) ;;
	step 2 : wff = df-ral () |- ( ∀ x ∈ B A ∈ x ↔ ∀ x ( x ∈ B → A ∈ x ) ) ;;
	step 3 : wff = bitr4i (step 1, step 2) |- ( A ∈ ⋂ B ↔ ∀ x ∈ B A ∈ x ) ;;
	qed prop 1 = step 3 ;;
}

/* Membership in class intersection, with the sethood requirement expressed
       as an antecedent.  (Contributed by NM, 20-Nov-2003.) */

theorem elintg (x : set, A : class, B : class, V : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ ⋂ B ↔ ∀ x ∈ B A ∈ x ) ) ;;
}

proof of elintg {
	var y : set;;
	step 1 : wff = eleq1 () |- ( y = A → ( y ∈ ⋂ B ↔ A ∈ ⋂ B ) ) ;;
	step 2 : wff = eleq1 () |- ( y = A → ( y ∈ x ↔ A ∈ x ) ) ;;
	step 3 : wff = ralbidv (step 2) |- ( y = A → ( ∀ x ∈ B y ∈ x ↔ ∀ x ∈ B A ∈ x ) ) ;;
	step 4 : wff = vex () |- y ∈ _V ;;
	step 5 : wff = elint2 (step 4) |- ( y ∈ ⋂ B ↔ ∀ x ∈ B y ∈ x ) ;;
	step 6 : wff = vtoclbg (step 1, step 3, step 5) |- ( A ∈ V → ( A ∈ ⋂ B ↔ ∀ x ∈ B A ∈ x ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Membership in class intersection.  (Contributed by NM, 14-Oct-1999.)
       (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem elinti (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( A ∈ ⋂ B → ( C ∈ B → A ∈ C ) ) ;;
}

proof of elinti {
	var x : set;;
	step 1 : wff = elintg () |- ( A ∈ ⋂ B → ( A ∈ ⋂ B ↔ ∀ x ∈ B A ∈ x ) ) ;;
	step 2 : wff = eleq2 () |- ( x = C → ( A ∈ x ↔ A ∈ C ) ) ;;
	step 3 : wff = rspccv (step 2) |- ( ∀ x ∈ B A ∈ x → ( C ∈ B → A ∈ C ) ) ;;
	step 4 : wff = syl6bi (step 1, step 3) |- ( A ∈ ⋂ B → ( A ∈ ⋂ B → ( C ∈ B → A ∈ C ) ) ) ;;
	step 5 : wff = pm2.43i (step 4) |- ( A ∈ ⋂ B → ( C ∈ B → A ∈ C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Bound-variable hypothesis builder for intersection.  (Contributed by NM,
       2-Feb-1997.)  (Proof shortened by Andrew Salmon, 12-Aug-2011.) */

theorem nfint (x : set, A : class) disjointed(y z A, x y z) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x ⋂ A ;;
}

proof of nfint {
	var y : set, z : set;;
	step 1 : wff = dfint2 () |- ⋂ A = { y | ∀ z ∈ A y ∈ z } ;;
	step 2 : wff = nfv () |- F/ x y ∈ z ;;
	step 3 : wff = nfral (hyp 1, step 2) |- F/ x ∀ z ∈ A y ∈ z ;;
	step 4 : wff = nfab (step 3) |- F/_ x { y | ∀ z ∈ A y ∈ z } ;;
	step 5 : wff = nfcxfr (step 1, step 4) |- F/_ x ⋂ A ;;
	qed prop 1 = step 5 ;;
}

/* Membership in the intersection of a class abstraction.  (Contributed by
       NM, 30-Aug-1993.) */

theorem elintab (ph : wff, x : set, A : class) disjointed(A x y, ph y) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ⋂ { x | ph } ↔ ∀ x ( ph → A ∈ x ) ) ;;
}

proof of elintab {
	var y : set;;
	step 1 : wff = elint (hyp 1) |- ( A ∈ ⋂ { x | ph } ↔ ∀ y ( y ∈ { x | ph } → A ∈ y ) ) ;;
	step 2 : wff = nfsab1 () |- F/ x y ∈ { x | ph } ;;
	step 3 : wff = nfv () |- F/ x A ∈ y ;;
	step 4 : wff = nfim (step 2, step 3) |- F/ x ( y ∈ { x | ph } → A ∈ y ) ;;
	step 5 : wff = nfv () |- F/ y ( ph → A ∈ x ) ;;
	step 6 : wff = eleq1 () |- ( y = x → ( y ∈ { x | ph } ↔ x ∈ { x | ph } ) ) ;;
	step 7 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 8 : wff = syl6bb (step 6, step 7) |- ( y = x → ( y ∈ { x | ph } ↔ ph ) ) ;;
	step 9 : wff = eleq2 () |- ( y = x → ( A ∈ y ↔ A ∈ x ) ) ;;
	step 10 : wff = imbi12d (step 8, step 9) |- ( y = x → ( ( y ∈ { x | ph } → A ∈ y ) ↔ ( ph → A ∈ x ) ) ) ;;
	step 11 : wff = cbval (step 4, step 5, step 10) |- ( ∀ y ( y ∈ { x | ph } → A ∈ y ) ↔ ∀ x ( ph → A ∈ x ) ) ;;
	step 12 : wff = bitri (step 1, step 11) |- ( A ∈ ⋂ { x | ph } ↔ ∀ x ( ph → A ∈ x ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Membership in the intersection of a class abstraction.  (Contributed by
       NM, 17-Oct-1999.) */

theorem elintrab (ph : wff, x : set, A : class, B : class) disjointed(A x) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → A ∈ x ) ) ;;
}

proof of elintrab {
	step 1 : wff = elintab (hyp 1) |- ( A ∈ ⋂ { x | ( x ∈ B ∧ ph ) } ↔ ∀ x ( ( x ∈ B ∧ ph ) → A ∈ x ) ) ;;
	step 2 : wff = impexp () |- ( ( ( x ∈ B ∧ ph ) → A ∈ x ) ↔ ( x ∈ B → ( ph → A ∈ x ) ) ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ x ( ( x ∈ B ∧ ph ) → A ∈ x ) ↔ ∀ x ( x ∈ B → ( ph → A ∈ x ) ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( A ∈ ⋂ { x | ( x ∈ B ∧ ph ) } ↔ ∀ x ( x ∈ B → ( ph → A ∈ x ) ) ) ;;
	step 5 : wff = df-rab () |- { x ∈ B | ph } = { x | ( x ∈ B ∧ ph ) } ;;
	step 6 : wff = inteqi (step 5) |- ⋂ { x ∈ B | ph } = ⋂ { x | ( x ∈ B ∧ ph ) } ;;
	step 7 : wff = eleq2i (step 6) |- ( A ∈ ⋂ { x ∈ B | ph } ↔ A ∈ ⋂ { x | ( x ∈ B ∧ ph ) } ) ;;
	step 8 : wff = df-ral () |- ( ∀ x ∈ B ( ph → A ∈ x ) ↔ ∀ x ( x ∈ B → ( ph → A ∈ x ) ) ) ;;
	step 9 : wff = 3bitr4i (step 4, step 7, step 8) |- ( A ∈ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → A ∈ x ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Membership in the intersection of a class abstraction.  (Contributed by
       NM, 17-Feb-2007.) */

theorem elintrabg (ph : wff, x : set, A : class, B : class, V : class) disjointed(x y A, y B, y ph) {
	prop 1 : wff = |- ( A ∈ V → ( A ∈ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → A ∈ x ) ) ) ;;
}

proof of elintrabg {
	var y : set;;
	step 1 : wff = eleq1 () |- ( y = A → ( y ∈ ⋂ { x ∈ B | ph } ↔ A ∈ ⋂ { x ∈ B | ph } ) ) ;;
	step 2 : wff = eleq1 () |- ( y = A → ( y ∈ x ↔ A ∈ x ) ) ;;
	step 3 : wff = imbi2d (step 2) |- ( y = A → ( ( ph → y ∈ x ) ↔ ( ph → A ∈ x ) ) ) ;;
	step 4 : wff = ralbidv (step 3) |- ( y = A → ( ∀ x ∈ B ( ph → y ∈ x ) ↔ ∀ x ∈ B ( ph → A ∈ x ) ) ) ;;
	step 5 : wff = vex () |- y ∈ _V ;;
	step 6 : wff = elintrab (step 5) |- ( y ∈ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → y ∈ x ) ) ;;
	step 7 : wff = vtoclbg (step 1, step 4, step 6) |- ( A ∈ V → ( A ∈ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → A ∈ x ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* The intersection of the empty set is the universal class.  Exercise 2 of
       [TakeutiZaring] p. 44.  (Contributed by NM, 18-Aug-1993.) */

theorem int0 () disjointed(x y) {
	prop 1 : wff = |- ⋂ ∅ = _V ;;
}

proof of int0 {
	var x : set, y : set;;
	step 1 : wff = noel () |- ¬ y ∈ ∅ ;;
	step 2 : wff = pm2.21i (step 1) |- ( y ∈ ∅ → x ∈ y ) ;;
	step 3 : wff = ax-gen (step 2) |- ∀ y ( y ∈ ∅ → x ∈ y ) ;;
	step 4 : wff = eqid () |- x = x ;;
	step 5 : wff = 2th (step 3, step 4) |- ( ∀ y ( y ∈ ∅ → x ∈ y ) ↔ x = x ) ;;
	step 6 : wff = abbii (step 5) |- { x | ∀ y ( y ∈ ∅ → x ∈ y ) } = { x | x = x } ;;
	step 7 : wff = df-int () |- ⋂ ∅ = { x | ∀ y ( y ∈ ∅ → x ∈ y ) } ;;
	step 8 : wff = df-v () |- _V = { x | x = x } ;;
	step 9 : wff = 3eqtr4i (step 6, step 7, step 8) |- ⋂ ∅ = _V ;;
	qed prop 1 = step 9 ;;
}

/* An element of a class includes the intersection of the class.  Exercise
       4 of [TakeutiZaring] p. 44 (with correction), generalized to classes.
       (Contributed by NM, 18-Nov-1995.) */

theorem intss1 (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ∈ B → ⋂ B ⊆ A ) ;;
}

proof of intss1 {
	var x : set, y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = elint (step 1) |- ( x ∈ ⋂ B ↔ ∀ y ( y ∈ B → x ∈ y ) ) ;;
	step 3 : wff = eleq1 () |- ( y = A → ( y ∈ B ↔ A ∈ B ) ) ;;
	step 4 : wff = eleq2 () |- ( y = A → ( x ∈ y ↔ x ∈ A ) ) ;;
	step 5 : wff = imbi12d (step 3, step 4) |- ( y = A → ( ( y ∈ B → x ∈ y ) ↔ ( A ∈ B → x ∈ A ) ) ) ;;
	step 6 : wff = spcgv (step 5) |- ( A ∈ B → ( ∀ y ( y ∈ B → x ∈ y ) → ( A ∈ B → x ∈ A ) ) ) ;;
	step 7 : wff = pm2.43a (step 6) |- ( A ∈ B → ( ∀ y ( y ∈ B → x ∈ y ) → x ∈ A ) ) ;;
	step 8 : wff = syl5bi (step 2, step 7) |- ( A ∈ B → ( x ∈ ⋂ B → x ∈ A ) ) ;;
	step 9 : wff = ssrdv (step 8) |- ( A ∈ B → ⋂ B ⊆ A ) ;;
	qed prop 1 = step 9 ;;
}

/* Subclass of a class intersection.  Theorem 5.11(viii) of [Monk1] p. 52
       and its converse.  (Contributed by NM, 14-Oct-1999.) */

theorem ssint (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ⊆ ⋂ B ↔ ∀ x ∈ B A ⊆ x ) ;;
}

proof of ssint {
	var y : set;;
	step 1 : wff = dfss3 () |- ( A ⊆ ⋂ B ↔ ∀ y ∈ A y ∈ ⋂ B ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = elint2 (step 2) |- ( y ∈ ⋂ B ↔ ∀ x ∈ B y ∈ x ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ y ∈ A y ∈ ⋂ B ↔ ∀ y ∈ A ∀ x ∈ B y ∈ x ) ;;
	step 5 : wff = ralcom () |- ( ∀ y ∈ A ∀ x ∈ B y ∈ x ↔ ∀ x ∈ B ∀ y ∈ A y ∈ x ) ;;
	step 6 : wff = dfss3 () |- ( A ⊆ x ↔ ∀ y ∈ A y ∈ x ) ;;
	step 7 : wff = ralbii (step 6) |- ( ∀ x ∈ B A ⊆ x ↔ ∀ x ∈ B ∀ y ∈ A y ∈ x ) ;;
	step 8 : wff = bitr4i (step 5, step 7) |- ( ∀ y ∈ A ∀ x ∈ B y ∈ x ↔ ∀ x ∈ B A ⊆ x ) ;;
	step 9 : wff = 3bitri (step 1, step 4, step 8) |- ( A ⊆ ⋂ B ↔ ∀ x ∈ B A ⊆ x ) ;;
	qed prop 1 = step 9 ;;
}

/* Subclass of the intersection of a class abstraction.  (Contributed by
       NM, 31-Jul-2006.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem ssintab (ph : wff, x : set, A : class) disjointed(x y A, x y, y ph) {
	prop 1 : wff = |- ( A ⊆ ⋂ { x | ph } ↔ ∀ x ( ph → A ⊆ x ) ) ;;
}

proof of ssintab {
	var y : set;;
	step 1 : wff = ssint () |- ( A ⊆ ⋂ { x | ph } ↔ ∀ y ∈ { x | ph } A ⊆ y ) ;;
	step 2 : wff = sseq2 () |- ( y = x → ( A ⊆ y ↔ A ⊆ x ) ) ;;
	step 3 : wff = ralab2 (step 2) |- ( ∀ y ∈ { x | ph } A ⊆ y ↔ ∀ x ( ph → A ⊆ x ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( A ⊆ ⋂ { x | ph } ↔ ∀ x ( ph → A ⊆ x ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Subclass of the least upper bound.  (Contributed by NM, 8-Aug-2000.) */

theorem ssintub (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- A ⊆ ⋂ { x ∈ B | A ⊆ x } ;;
}

proof of ssintub {
	var y : set;;
	step 1 : wff = ssint () |- ( A ⊆ ⋂ { x ∈ B | A ⊆ x } ↔ ∀ y ∈ { x ∈ B | A ⊆ x } A ⊆ y ) ;;
	step 2 : wff = sseq2 () |- ( x = y → ( A ⊆ x ↔ A ⊆ y ) ) ;;
	step 3 : wff = elrab (step 2) |- ( y ∈ { x ∈ B | A ⊆ x } ↔ ( y ∈ B ∧ A ⊆ y ) ) ;;
	step 4 : wff = simprbi (step 3) |- ( y ∈ { x ∈ B | A ⊆ x } → A ⊆ y ) ;;
	step 5 : wff = mprgbir (step 1, step 4) |- A ⊆ ⋂ { x ∈ B | A ⊆ x } ;;
	qed prop 1 = step 5 ;;
}

/* Subclass of the minimum value of class of supersets.  (Contributed by
       NM, 10-Aug-2006.) */

theorem ssmin (ph : wff, x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- A ⊆ ⋂ { x | ( A ⊆ x ∧ ph ) } ;;
}

proof of ssmin {
	step 1 : wff = ssintab () |- ( A ⊆ ⋂ { x | ( A ⊆ x ∧ ph ) } ↔ ∀ x ( ( A ⊆ x ∧ ph ) → A ⊆ x ) ) ;;
	step 2 : wff = simpl () |- ( ( A ⊆ x ∧ ph ) → A ⊆ x ) ;;
	step 3 : wff = mpgbir (step 1, step 2) |- A ⊆ ⋂ { x | ( A ⊆ x ∧ ph ) } ;;
	qed prop 1 = step 3 ;;
}

/* Any member of a class is the smallest of those members that include it.
       (Contributed by NM, 13-Aug-2002.)  (Proof shortened by Andrew Salmon,
       9-Jul-2011.) */

theorem intmin (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ∈ B → ⋂ { x ∈ B | A ⊆ x } = A ) ;;
}

proof of intmin {
	var y : set;;
	step 1 : wff = vex () |- y ∈ _V ;;
	step 2 : wff = elintrab (step 1) |- ( y ∈ ⋂ { x ∈ B | A ⊆ x } ↔ ∀ x ∈ B ( A ⊆ x → y ∈ x ) ) ;;
	step 3 : wff = ssid () |- A ⊆ A ;;
	step 4 : wff = sseq2 () |- ( x = A → ( A ⊆ x ↔ A ⊆ A ) ) ;;
	step 5 : wff = eleq2 () |- ( x = A → ( y ∈ x ↔ y ∈ A ) ) ;;
	step 6 : wff = imbi12d (step 4, step 5) |- ( x = A → ( ( A ⊆ x → y ∈ x ) ↔ ( A ⊆ A → y ∈ A ) ) ) ;;
	step 7 : wff = rspcv (step 6) |- ( A ∈ B → ( ∀ x ∈ B ( A ⊆ x → y ∈ x ) → ( A ⊆ A → y ∈ A ) ) ) ;;
	step 8 : wff = mpii (step 3, step 7) |- ( A ∈ B → ( ∀ x ∈ B ( A ⊆ x → y ∈ x ) → y ∈ A ) ) ;;
	step 9 : wff = syl5bi (step 2, step 8) |- ( A ∈ B → ( y ∈ ⋂ { x ∈ B | A ⊆ x } → y ∈ A ) ) ;;
	step 10 : wff = ssrdv (step 9) |- ( A ∈ B → ⋂ { x ∈ B | A ⊆ x } ⊆ A ) ;;
	step 11 : wff = ssintub () |- A ⊆ ⋂ { x ∈ B | A ⊆ x } ;;
	step 12 : wff = a1i (step 11) |- ( A ∈ B → A ⊆ ⋂ { x ∈ B | A ⊆ x } ) ;;
	step 13 : wff = eqssd (step 10, step 12) |- ( A ∈ B → ⋂ { x ∈ B | A ⊆ x } = A ) ;;
	qed prop 1 = step 13 ;;
}

/* Intersection of subclasses.  (Contributed by NM, 14-Oct-1999.) */

theorem intss (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ⊆ B → ⋂ B ⊆ ⋂ A ) ;;
}

proof of intss {
	var x : set, y : set;;
	step 1 : wff = imim1 () |- ( ( y ∈ A → y ∈ B ) → ( ( y ∈ B → x ∈ y ) → ( y ∈ A → x ∈ y ) ) ) ;;
	step 2 : wff = al2imi (step 1) |- ( ∀ y ( y ∈ A → y ∈ B ) → ( ∀ y ( y ∈ B → x ∈ y ) → ∀ y ( y ∈ A → x ∈ y ) ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = elint (step 3) |- ( x ∈ ⋂ B ↔ ∀ y ( y ∈ B → x ∈ y ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = elint (step 5) |- ( x ∈ ⋂ A ↔ ∀ y ( y ∈ A → x ∈ y ) ) ;;
	step 7 : wff = 3imtr4g (step 2, step 4, step 6) |- ( ∀ y ( y ∈ A → y ∈ B ) → ( x ∈ ⋂ B → x ∈ ⋂ A ) ) ;;
	step 8 : wff = alrimiv (step 7) |- ( ∀ y ( y ∈ A → y ∈ B ) → ∀ x ( x ∈ ⋂ B → x ∈ ⋂ A ) ) ;;
	step 9 : wff = dfss2 () |- ( A ⊆ B ↔ ∀ y ( y ∈ A → y ∈ B ) ) ;;
	step 10 : wff = dfss2 () |- ( ⋂ B ⊆ ⋂ A ↔ ∀ x ( x ∈ ⋂ B → x ∈ ⋂ A ) ) ;;
	step 11 : wff = 3imtr4i (step 8, step 9, step 10) |- ( A ⊆ B → ⋂ B ⊆ ⋂ A ) ;;
	qed prop 1 = step 11 ;;
}

/* The intersection of a nonempty set is a subclass of its union.
       (Contributed by NM, 29-Jul-2006.) */

theorem intssuni (A : class) disjointed(x y A, x y) {
	prop 1 : wff = |- ( A ≠ ∅ → ⋂ A ⊆ ⋃ A ) ;;
}

proof of intssuni {
	var x : set, y : set;;
	step 1 : wff = r19.2z () |- ( ( A ≠ ∅ ∧ ∀ y ∈ A x ∈ y ) → ∃ y ∈ A x ∈ y ) ;;
	step 2 : wff = ex (step 1) |- ( A ≠ ∅ → ( ∀ y ∈ A x ∈ y → ∃ y ∈ A x ∈ y ) ) ;;
	step 3 : wff = vex () |- x ∈ _V ;;
	step 4 : wff = elint2 (step 3) |- ( x ∈ ⋂ A ↔ ∀ y ∈ A x ∈ y ) ;;
	step 5 : wff = eluni2 () |- ( x ∈ ⋃ A ↔ ∃ y ∈ A x ∈ y ) ;;
	step 6 : wff = 3imtr4g (step 2, step 4, step 5) |- ( A ≠ ∅ → ( x ∈ ⋂ A → x ∈ ⋃ A ) ) ;;
	step 7 : wff = ssrdv (step 6) |- ( A ≠ ∅ → ⋂ A ⊆ ⋃ A ) ;;
	qed prop 1 = step 7 ;;
}

/* Subclass of the intersection of a restricted class builder.
       (Contributed by NM, 30-Jan-2015.) */

theorem ssintrab (ph : wff, x : set, A : class, B : class) disjointed(x A) {
	prop 1 : wff = |- ( A ⊆ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → A ⊆ x ) ) ;;
}

proof of ssintrab {
	step 1 : wff = df-rab () |- { x ∈ B | ph } = { x | ( x ∈ B ∧ ph ) } ;;
	step 2 : wff = inteqi (step 1) |- ⋂ { x ∈ B | ph } = ⋂ { x | ( x ∈ B ∧ ph ) } ;;
	step 3 : wff = sseq2i (step 2) |- ( A ⊆ ⋂ { x ∈ B | ph } ↔ A ⊆ ⋂ { x | ( x ∈ B ∧ ph ) } ) ;;
	step 4 : wff = impexp () |- ( ( ( x ∈ B ∧ ph ) → A ⊆ x ) ↔ ( x ∈ B → ( ph → A ⊆ x ) ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ x ( ( x ∈ B ∧ ph ) → A ⊆ x ) ↔ ∀ x ( x ∈ B → ( ph → A ⊆ x ) ) ) ;;
	step 6 : wff = ssintab () |- ( A ⊆ ⋂ { x | ( x ∈ B ∧ ph ) } ↔ ∀ x ( ( x ∈ B ∧ ph ) → A ⊆ x ) ) ;;
	step 7 : wff = df-ral () |- ( ∀ x ∈ B ( ph → A ⊆ x ) ↔ ∀ x ( x ∈ B → ( ph → A ⊆ x ) ) ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( A ⊆ ⋂ { x | ( x ∈ B ∧ ph ) } ↔ ∀ x ∈ B ( ph → A ⊆ x ) ) ;;
	step 9 : wff = bitri (step 3, step 8) |- ( A ⊆ ⋂ { x ∈ B | ph } ↔ ∀ x ∈ B ( ph → A ⊆ x ) ) ;;
	qed prop 1 = step 9 ;;
}

/* If the union of a class is included in its intersection, the class is
     either the empty set or a singleton ( ~ uniintsn ).  (Contributed by NM,
     30-Oct-2010.)  (Proof shortened by Andrew Salmon, 25-Jul-2011.) */

theorem unissint (A : class)  {
	prop 1 : wff = |- ( ⋃ A ⊆ ⋂ A ↔ ( A = ∅ ∨ ⋃ A = ⋂ A ) ) ;;
}

proof of unissint {
	step 1 : wff = simpl () |- ( ( ⋃ A ⊆ ⋂ A ∧ ¬ A = ∅ ) → ⋃ A ⊆ ⋂ A ) ;;
	step 2 : wff = df-ne () |- ( A ≠ ∅ ↔ ¬ A = ∅ ) ;;
	step 3 : wff = intssuni () |- ( A ≠ ∅ → ⋂ A ⊆ ⋃ A ) ;;
	step 4 : wff = sylbir (step 2, step 3) |- ( ¬ A = ∅ → ⋂ A ⊆ ⋃ A ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ⋃ A ⊆ ⋂ A ∧ ¬ A = ∅ ) → ⋂ A ⊆ ⋃ A ) ;;
	step 6 : wff = eqssd (step 1, step 5) |- ( ( ⋃ A ⊆ ⋂ A ∧ ¬ A = ∅ ) → ⋃ A = ⋂ A ) ;;
	step 7 : wff = ex (step 6) |- ( ⋃ A ⊆ ⋂ A → ( ¬ A = ∅ → ⋃ A = ⋂ A ) ) ;;
	step 8 : wff = orrd (step 7) |- ( ⋃ A ⊆ ⋂ A → ( A = ∅ ∨ ⋃ A = ⋂ A ) ) ;;
	step 9 : wff = ssv () |- ⋃ A ⊆ _V ;;
	step 10 : wff = int0 () |- ⋂ ∅ = _V ;;
	step 11 : wff = sseqtr4i (step 9, step 10) |- ⋃ A ⊆ ⋂ ∅ ;;
	step 12 : wff = inteq () |- ( A = ∅ → ⋂ A = ⋂ ∅ ) ;;
	step 13 : wff = syl5sseqr (step 11, step 12) |- ( A = ∅ → ⋃ A ⊆ ⋂ A ) ;;
	step 14 : wff = eqimss () |- ( ⋃ A = ⋂ A → ⋃ A ⊆ ⋂ A ) ;;
	step 15 : wff = jaoi (step 13, step 14) |- ( ( A = ∅ ∨ ⋃ A = ⋂ A ) → ⋃ A ⊆ ⋂ A ) ;;
	step 16 : wff = impbii (step 8, step 15) |- ( ⋃ A ⊆ ⋂ A ↔ ( A = ∅ ∨ ⋃ A = ⋂ A ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Subclass relationship for intersection and union.  (Contributed by NM,
     29-Jul-2006.) */

theorem intssuni2 (A : class, B : class)  {
	prop 1 : wff = |- ( ( A ⊆ B ∧ A ≠ ∅ ) → ⋂ A ⊆ ⋃ B ) ;;
}

proof of intssuni2 {
	step 1 : wff = intssuni () |- ( A ≠ ∅ → ⋂ A ⊆ ⋃ A ) ;;
	step 2 : wff = uniss () |- ( A ⊆ B → ⋃ A ⊆ ⋃ B ) ;;
	step 3 : wff = sylan9ssr (step 1, step 2) |- ( ( A ⊆ B ∧ A ≠ ∅ ) → ⋂ A ⊆ ⋃ B ) ;;
	qed prop 1 = step 3 ;;
}

/* Under subset ordering, the intersection of a restricted class
       abstraction is less than or equal to any of its members.  (Contributed
       by NM, 7-Sep-2013.) */

theorem intminss (ph : wff, ps : wff, x : set, A : class, B : class) disjointed(x A, x B, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A ∈ B ∧ ps ) → ⋂ { x ∈ B | ph } ⊆ A ) ;;
}

proof of intminss {
	step 1 : wff = elrab (hyp 1) |- ( A ∈ { x ∈ B | ph } ↔ ( A ∈ B ∧ ps ) ) ;;
	step 2 : wff = intss1 () |- ( A ∈ { x ∈ B | ph } → ⋂ { x ∈ B | ph } ⊆ A ) ;;
	step 3 : wff = sylbir (step 1, step 2) |- ( ( A ∈ B ∧ ps ) → ⋂ { x ∈ B | ph } ⊆ A ) ;;
	qed prop 1 = step 3 ;;
}

/* Any set is the smallest of all sets that include it.  (Contributed by
       NM, 20-Sep-2003.) */

theorem intmin2 (x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ { x | A ⊆ x } = A ;;
}

proof of intmin2 {
	step 1 : wff = rabab () |- { x ∈ _V | A ⊆ x } = { x | A ⊆ x } ;;
	step 2 : wff = inteqi (step 1) |- ⋂ { x ∈ _V | A ⊆ x } = ⋂ { x | A ⊆ x } ;;
	step 3 : wff = intmin () |- ( A ∈ _V → ⋂ { x ∈ _V | A ⊆ x } = A ) ;;
	step 4 : wff = ax-mp (hyp 1, step 3) |- ⋂ { x ∈ _V | A ⊆ x } = A ;;
	step 5 : wff = eqtr3i (step 2, step 4) |- ⋂ { x | A ⊆ x } = A ;;
	qed prop 1 = step 5 ;;
}

/* Under subset ordering, the intersection of a class abstraction is less
       than or equal to any of its members.  (Contributed by NM,
       3-Jul-2005.) */

theorem intmin3 (ph : wff, ps : wff, x : set, A : class, V : class) disjointed(x A, x ps) {
	hyp 1 : wff = |- ( x = A → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ps ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ V → ⋂ { x | ph } ⊆ A ) ;;
}

proof of intmin3 {
	step 1 : wff = elabg (hyp 1) |- ( A ∈ V → ( A ∈ { x | ph } ↔ ps ) ) ;;
	step 2 : wff = mpbiri (hyp 2, step 1) |- ( A ∈ V → A ∈ { x | ph } ) ;;
	step 3 : wff = intss1 () |- ( A ∈ { x | ph } → ⋂ { x | ph } ⊆ A ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( A ∈ V → ⋂ { x | ph } ⊆ A ) ;;
	qed prop 1 = step 4 ;;
}

/* Elimination of a conjunct in a class intersection.  (Contributed by NM,
       31-Jul-2006.) */

theorem intmin4 (ph : wff, x : set, A : class) disjointed(x y A, y ph) {
	prop 1 : wff = |- ( A ⊆ ⋂ { x | ph } → ⋂ { x | ( A ⊆ x ∧ ph ) } = ⋂ { x | ph } ) ;;
}

proof of intmin4 {
	var y : set;;
	step 1 : wff = ssintab () |- ( A ⊆ ⋂ { x | ph } ↔ ∀ x ( ph → A ⊆ x ) ) ;;
	step 2 : wff = simpr () |- ( ( A ⊆ x ∧ ph ) → ph ) ;;
	step 3 : wff = ancr () |- ( ( ph → A ⊆ x ) → ( ph → ( A ⊆ x ∧ ph ) ) ) ;;
	step 4 : wff = impbid2 (step 2, step 3) |- ( ( ph → A ⊆ x ) → ( ( A ⊆ x ∧ ph ) ↔ ph ) ) ;;
	step 5 : wff = imbi1d (step 4) |- ( ( ph → A ⊆ x ) → ( ( ( A ⊆ x ∧ ph ) → y ∈ x ) ↔ ( ph → y ∈ x ) ) ) ;;
	step 6 : wff = alimi (step 5) |- ( ∀ x ( ph → A ⊆ x ) → ∀ x ( ( ( A ⊆ x ∧ ph ) → y ∈ x ) ↔ ( ph → y ∈ x ) ) ) ;;
	step 7 : wff = albi () |- ( ∀ x ( ( ( A ⊆ x ∧ ph ) → y ∈ x ) ↔ ( ph → y ∈ x ) ) → ( ∀ x ( ( A ⊆ x ∧ ph ) → y ∈ x ) ↔ ∀ x ( ph → y ∈ x ) ) ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ∀ x ( ph → A ⊆ x ) → ( ∀ x ( ( A ⊆ x ∧ ph ) → y ∈ x ) ↔ ∀ x ( ph → y ∈ x ) ) ) ;;
	step 9 : wff = sylbi (step 1, step 8) |- ( A ⊆ ⋂ { x | ph } → ( ∀ x ( ( A ⊆ x ∧ ph ) → y ∈ x ) ↔ ∀ x ( ph → y ∈ x ) ) ) ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = elintab (step 10) |- ( y ∈ ⋂ { x | ( A ⊆ x ∧ ph ) } ↔ ∀ x ( ( A ⊆ x ∧ ph ) → y ∈ x ) ) ;;
	step 12 : wff = vex () |- y ∈ _V ;;
	step 13 : wff = elintab (step 12) |- ( y ∈ ⋂ { x | ph } ↔ ∀ x ( ph → y ∈ x ) ) ;;
	step 14 : wff = 3bitr4g (step 9, step 11, step 13) |- ( A ⊆ ⋂ { x | ph } → ( y ∈ ⋂ { x | ( A ⊆ x ∧ ph ) } ↔ y ∈ ⋂ { x | ph } ) ) ;;
	step 15 : wff = eqrdv (step 14) |- ( A ⊆ ⋂ { x | ph } → ⋂ { x | ( A ⊆ x ∧ ph ) } = ⋂ { x | ph } ) ;;
	qed prop 1 = step 15 ;;
}

/* The intersection of a special case of a class abstraction. ` y ` may be
       free in ` ph ` and ` A ` , which can be thought of a ` ph ( y ) ` and
       ` A ( y ) ` .  Typically, ~ abrexex2 or ~ abexssex can be used to
       satisfy the second hypothesis.  (Contributed by NM, 28-Jul-2006.)
       (Proof shortened by Mario Carneiro, 14-Nov-2016.) */

theorem intab (ph : wff, x : set, y : set, A : class) disjointed(x z A, x z ph, x y z) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- { x | ∃ y ( ph ∧ x = A ) } ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ { x | ∀ y ( ph → A ∈ x ) } = { x | ∃ y ( ph ∧ x = A ) } ;;
}

proof of intab {
	var z : set;;
	step 1 : wff = eqeq1 () |- ( z = x → ( z = A ↔ x = A ) ) ;;
	step 2 : wff = anbi2d (step 1) |- ( z = x → ( ( ph ∧ z = A ) ↔ ( ph ∧ x = A ) ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( z = x → ( ∃ y ( ph ∧ z = A ) ↔ ∃ y ( ph ∧ x = A ) ) ) ;;
	step 4 : wff = cbvabv (step 3) |- { z | ∃ y ( ph ∧ z = A ) } = { x | ∃ y ( ph ∧ x = A ) } ;;
	step 5 : wff = eqeltri (step 4, hyp 2) |- { z | ∃ y ( ph ∧ z = A ) } ∈ _V ;;
	step 6 : wff = nfe1 () |- F/ y ∃ y ( ph ∧ z = A ) ;;
	step 7 : wff = nfab (step 6) |- F/_ y { z | ∃ y ( ph ∧ z = A ) } ;;
	step 8 : wff = nfeq2 (step 7) |- F/ y x = { z | ∃ y ( ph ∧ z = A ) } ;;
	step 9 : wff = eleq2 () |- ( x = { z | ∃ y ( ph ∧ z = A ) } → ( A ∈ x ↔ A ∈ { z | ∃ y ( ph ∧ z = A ) } ) ) ;;
	step 10 : wff = imbi2d (step 9) |- ( x = { z | ∃ y ( ph ∧ z = A ) } → ( ( ph → A ∈ x ) ↔ ( ph → A ∈ { z | ∃ y ( ph ∧ z = A ) } ) ) ) ;;
	step 11 : wff = albid (step 8, step 10) |- ( x = { z | ∃ y ( ph ∧ z = A ) } → ( ∀ y ( ph → A ∈ x ) ↔ ∀ y ( ph → A ∈ { z | ∃ y ( ph ∧ z = A ) } ) ) ) ;;
	step 12 : wff = elab (step 5, step 11) |- ( { z | ∃ y ( ph ∧ z = A ) } ∈ { x | ∀ y ( ph → A ∈ x ) } ↔ ∀ y ( ph → A ∈ { z | ∃ y ( ph ∧ z = A ) } ) ) ;;
	step 13 : wff = 19.8a () |- ( ( ph ∧ z = A ) → ∃ y ( ph ∧ z = A ) ) ;;
	step 14 : wff = ex (step 13) |- ( ph → ( z = A → ∃ y ( ph ∧ z = A ) ) ) ;;
	step 15 : wff = alrimiv (step 14) |- ( ph → ∀ z ( z = A → ∃ y ( ph ∧ z = A ) ) ) ;;
	step 16 : wff = sbc6 (hyp 1) |- ( [. A / z ]. ∃ y ( ph ∧ z = A ) ↔ ∀ z ( z = A → ∃ y ( ph ∧ z = A ) ) ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ph → [. A / z ]. ∃ y ( ph ∧ z = A ) ) ;;
	step 18 : wff = df-sbc () |- ( [. A / z ]. ∃ y ( ph ∧ z = A ) ↔ A ∈ { z | ∃ y ( ph ∧ z = A ) } ) ;;
	step 19 : wff = sylib (step 17, step 18) |- ( ph → A ∈ { z | ∃ y ( ph ∧ z = A ) } ) ;;
	step 20 : wff = mpgbir (step 12, step 19) |- { z | ∃ y ( ph ∧ z = A ) } ∈ { x | ∀ y ( ph → A ∈ x ) } ;;
	step 21 : wff = intss1 () |- ( { z | ∃ y ( ph ∧ z = A ) } ∈ { x | ∀ y ( ph → A ∈ x ) } → ⋂ { x | ∀ y ( ph → A ∈ x ) } ⊆ { z | ∃ y ( ph ∧ z = A ) } ) ;;
	step 22 : wff = ax-mp (step 20, step 21) |- ⋂ { x | ∀ y ( ph → A ∈ x ) } ⊆ { z | ∃ y ( ph ∧ z = A ) } ;;
	step 23 : wff = 19.29r () |- ( ( ∃ y ( ph ∧ z = A ) ∧ ∀ y ( ph → A ∈ x ) ) → ∃ y ( ( ph ∧ z = A ) ∧ ( ph → A ∈ x ) ) ) ;;
	step 24 : wff = simplr () |- ( ( ( ph ∧ z = A ) ∧ ( ph → A ∈ x ) ) → z = A ) ;;
	step 25 : wff = pm3.35 () |- ( ( ph ∧ ( ph → A ∈ x ) ) → A ∈ x ) ;;
	step 26 : wff = adantlr (step 25) |- ( ( ( ph ∧ z = A ) ∧ ( ph → A ∈ x ) ) → A ∈ x ) ;;
	step 27 : wff = eqeltrd (step 24, step 26) |- ( ( ( ph ∧ z = A ) ∧ ( ph → A ∈ x ) ) → z ∈ x ) ;;
	step 28 : wff = exlimiv (step 27) |- ( ∃ y ( ( ph ∧ z = A ) ∧ ( ph → A ∈ x ) ) → z ∈ x ) ;;
	step 29 : wff = syl (step 23, step 28) |- ( ( ∃ y ( ph ∧ z = A ) ∧ ∀ y ( ph → A ∈ x ) ) → z ∈ x ) ;;
	step 30 : wff = ex (step 29) |- ( ∃ y ( ph ∧ z = A ) → ( ∀ y ( ph → A ∈ x ) → z ∈ x ) ) ;;
	step 31 : wff = alrimiv (step 30) |- ( ∃ y ( ph ∧ z = A ) → ∀ x ( ∀ y ( ph → A ∈ x ) → z ∈ x ) ) ;;
	step 32 : wff = vex () |- z ∈ _V ;;
	step 33 : wff = elintab (step 32) |- ( z ∈ ⋂ { x | ∀ y ( ph → A ∈ x ) } ↔ ∀ x ( ∀ y ( ph → A ∈ x ) → z ∈ x ) ) ;;
	step 34 : wff = sylibr (step 31, step 33) |- ( ∃ y ( ph ∧ z = A ) → z ∈ ⋂ { x | ∀ y ( ph → A ∈ x ) } ) ;;
	step 35 : wff = abssi (step 34) |- { z | ∃ y ( ph ∧ z = A ) } ⊆ ⋂ { x | ∀ y ( ph → A ∈ x ) } ;;
	step 36 : wff = eqssi (step 22, step 35) |- ⋂ { x | ∀ y ( ph → A ∈ x ) } = { z | ∃ y ( ph ∧ z = A ) } ;;
	step 37 : wff = eqeq1 () |- ( z = x → ( z = A ↔ x = A ) ) ;;
	step 38 : wff = anbi2d (step 37) |- ( z = x → ( ( ph ∧ z = A ) ↔ ( ph ∧ x = A ) ) ) ;;
	step 39 : wff = exbidv (step 38) |- ( z = x → ( ∃ y ( ph ∧ z = A ) ↔ ∃ y ( ph ∧ x = A ) ) ) ;;
	step 40 : wff = cbvabv (step 39) |- { z | ∃ y ( ph ∧ z = A ) } = { x | ∃ y ( ph ∧ x = A ) } ;;
	step 41 : wff = eqtri (step 36, step 40) |- ⋂ { x | ∀ y ( ph → A ∈ x ) } = { x | ∃ y ( ph ∧ x = A ) } ;;
	qed prop 1 = step 41 ;;
}

/* The intersection of a class containing the empty set is empty.
     (Contributed by NM, 24-Apr-2004.) */

theorem int0el (A : class)  {
	prop 1 : wff = |- ( ∅ ∈ A → ⋂ A = ∅ ) ;;
}

proof of int0el {
	step 1 : wff = intss1 () |- ( ∅ ∈ A → ⋂ A ⊆ ∅ ) ;;
	step 2 : wff = 0ss () |- ∅ ⊆ ⋂ A ;;
	step 3 : wff = a1i (step 2) |- ( ∅ ∈ A → ∅ ⊆ ⋂ A ) ;;
	step 4 : wff = eqssd (step 1, step 3) |- ( ∅ ∈ A → ⋂ A = ∅ ) ;;
	qed prop 1 = step 4 ;;
}

/* The class intersection of the union of two classes.  Theorem 78 of
       [Suppes] p. 42.  (Contributed by NM, 22-Sep-2002.) */

theorem intun (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⋂ ( A ∪ B ) = ( ⋂ A ∩ ⋂ B ) ;;
}

proof of intun {
	var x : set, y : set;;
	step 1 : wff = 19.26 () |- ( ∀ y ( ( y ∈ A → x ∈ y ) ∧ ( y ∈ B → x ∈ y ) ) ↔ ( ∀ y ( y ∈ A → x ∈ y ) ∧ ∀ y ( y ∈ B → x ∈ y ) ) ) ;;
	step 2 : wff = elun () |- ( y ∈ ( A ∪ B ) ↔ ( y ∈ A ∨ y ∈ B ) ) ;;
	step 3 : wff = imbi1i (step 2) |- ( ( y ∈ ( A ∪ B ) → x ∈ y ) ↔ ( ( y ∈ A ∨ y ∈ B ) → x ∈ y ) ) ;;
	step 4 : wff = jaob () |- ( ( ( y ∈ A ∨ y ∈ B ) → x ∈ y ) ↔ ( ( y ∈ A → x ∈ y ) ∧ ( y ∈ B → x ∈ y ) ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ( y ∈ ( A ∪ B ) → x ∈ y ) ↔ ( ( y ∈ A → x ∈ y ) ∧ ( y ∈ B → x ∈ y ) ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ y ( y ∈ ( A ∪ B ) → x ∈ y ) ↔ ∀ y ( ( y ∈ A → x ∈ y ) ∧ ( y ∈ B → x ∈ y ) ) ) ;;
	step 7 : wff = vex () |- x ∈ _V ;;
	step 8 : wff = elint (step 7) |- ( x ∈ ⋂ A ↔ ∀ y ( y ∈ A → x ∈ y ) ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = elint (step 9) |- ( x ∈ ⋂ B ↔ ∀ y ( y ∈ B → x ∈ y ) ) ;;
	step 11 : wff = anbi12i (step 8, step 10) |- ( ( x ∈ ⋂ A ∧ x ∈ ⋂ B ) ↔ ( ∀ y ( y ∈ A → x ∈ y ) ∧ ∀ y ( y ∈ B → x ∈ y ) ) ) ;;
	step 12 : wff = 3bitr4i (step 1, step 6, step 11) |- ( ∀ y ( y ∈ ( A ∪ B ) → x ∈ y ) ↔ ( x ∈ ⋂ A ∧ x ∈ ⋂ B ) ) ;;
	step 13 : wff = vex () |- x ∈ _V ;;
	step 14 : wff = elint (step 13) |- ( x ∈ ⋂ ( A ∪ B ) ↔ ∀ y ( y ∈ ( A ∪ B ) → x ∈ y ) ) ;;
	step 15 : wff = elin () |- ( x ∈ ( ⋂ A ∩ ⋂ B ) ↔ ( x ∈ ⋂ A ∧ x ∈ ⋂ B ) ) ;;
	step 16 : wff = 3bitr4i (step 12, step 14, step 15) |- ( x ∈ ⋂ ( A ∪ B ) ↔ x ∈ ( ⋂ A ∩ ⋂ B ) ) ;;
	step 17 : wff = eqriv (step 16) |- ⋂ ( A ∪ B ) = ( ⋂ A ∩ ⋂ B ) ;;
	qed prop 1 = step 17 ;;
}

/* The intersection of a pair is the intersection of its members.  Theorem
       71 of [Suppes] p. 42.  (Contributed by NM, 14-Oct-1999.) */

theorem intpr (A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ { A , B } = ( A ∩ B ) ;;
}

proof of intpr {
	var x : set, y : set;;
	step 1 : wff = 19.26 () |- ( ∀ y ( ( y = A → x ∈ y ) ∧ ( y = B → x ∈ y ) ) ↔ ( ∀ y ( y = A → x ∈ y ) ∧ ∀ y ( y = B → x ∈ y ) ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = elpr (step 2) |- ( y ∈ { A , B } ↔ ( y = A ∨ y = B ) ) ;;
	step 4 : wff = imbi1i (step 3) |- ( ( y ∈ { A , B } → x ∈ y ) ↔ ( ( y = A ∨ y = B ) → x ∈ y ) ) ;;
	step 5 : wff = jaob () |- ( ( ( y = A ∨ y = B ) → x ∈ y ) ↔ ( ( y = A → x ∈ y ) ∧ ( y = B → x ∈ y ) ) ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( ( y ∈ { A , B } → x ∈ y ) ↔ ( ( y = A → x ∈ y ) ∧ ( y = B → x ∈ y ) ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ y ( y ∈ { A , B } → x ∈ y ) ↔ ∀ y ( ( y = A → x ∈ y ) ∧ ( y = B → x ∈ y ) ) ) ;;
	step 8 : wff = clel4 (hyp 1) |- ( x ∈ A ↔ ∀ y ( y = A → x ∈ y ) ) ;;
	step 9 : wff = clel4 (hyp 2) |- ( x ∈ B ↔ ∀ y ( y = B → x ∈ y ) ) ;;
	step 10 : wff = anbi12i (step 8, step 9) |- ( ( x ∈ A ∧ x ∈ B ) ↔ ( ∀ y ( y = A → x ∈ y ) ∧ ∀ y ( y = B → x ∈ y ) ) ) ;;
	step 11 : wff = 3bitr4i (step 1, step 7, step 10) |- ( ∀ y ( y ∈ { A , B } → x ∈ y ) ↔ ( x ∈ A ∧ x ∈ B ) ) ;;
	step 12 : wff = vex () |- x ∈ _V ;;
	step 13 : wff = elint (step 12) |- ( x ∈ ⋂ { A , B } ↔ ∀ y ( y ∈ { A , B } → x ∈ y ) ) ;;
	step 14 : wff = elin () |- ( x ∈ ( A ∩ B ) ↔ ( x ∈ A ∧ x ∈ B ) ) ;;
	step 15 : wff = 3bitr4i (step 11, step 13, step 14) |- ( x ∈ ⋂ { A , B } ↔ x ∈ ( A ∩ B ) ) ;;
	step 16 : wff = eqriv (step 15) |- ⋂ { A , B } = ( A ∩ B ) ;;
	qed prop 1 = step 16 ;;
}

/* The intersection of a pair is the intersection of its members.  Closed
       form of ~ intpr .  Theorem 71 of [Suppes] p. 42.  (Contributed by FL,
       27-Apr-2008.) */

theorem intprg (A : class, B : class, V : class, W : class) disjointed(x y A, y B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ⋂ { A , B } = ( A ∩ B ) ) ;;
}

proof of intprg {
	var x : set, y : set;;
	step 1 : wff = preq1 () |- ( x = A → { x , y } = { A , y } ) ;;
	step 2 : wff = inteqd (step 1) |- ( x = A → ⋂ { x , y } = ⋂ { A , y } ) ;;
	step 3 : wff = ineq1 () |- ( x = A → ( x ∩ y ) = ( A ∩ y ) ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( x = A → ( ⋂ { x , y } = ( x ∩ y ) ↔ ⋂ { A , y } = ( A ∩ y ) ) ) ;;
	step 5 : wff = preq2 () |- ( y = B → { A , y } = { A , B } ) ;;
	step 6 : wff = inteqd (step 5) |- ( y = B → ⋂ { A , y } = ⋂ { A , B } ) ;;
	step 7 : wff = ineq2 () |- ( y = B → ( A ∩ y ) = ( A ∩ B ) ) ;;
	step 8 : wff = eqeq12d (step 6, step 7) |- ( y = B → ( ⋂ { A , y } = ( A ∩ y ) ↔ ⋂ { A , B } = ( A ∩ B ) ) ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = intpr (step 9, step 10) |- ⋂ { x , y } = ( x ∩ y ) ;;
	step 12 : wff = vtocl2g (step 4, step 8, step 11) |- ( ( A ∈ V ∧ B ∈ W ) → ⋂ { A , B } = ( A ∩ B ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Intersection of a singleton.  (Contributed by Stefan O'Rear,
     22-Feb-2015.) */

theorem intsng (A : class, V : class)  {
	prop 1 : wff = |- ( A ∈ V → ⋂ { A } = A ) ;;
}

proof of intsng {
	step 1 : wff = dfsn2 () |- { A } = { A , A } ;;
	step 2 : wff = inteqi (step 1) |- ⋂ { A } = ⋂ { A , A } ;;
	step 3 : wff = intprg () |- ( ( A ∈ V ∧ A ∈ V ) → ⋂ { A , A } = ( A ∩ A ) ) ;;
	step 4 : wff = anidms (step 3) |- ( A ∈ V → ⋂ { A , A } = ( A ∩ A ) ) ;;
	step 5 : wff = inidm () |- ( A ∩ A ) = A ;;
	step 6 : wff = syl6eq (step 4, step 5) |- ( A ∈ V → ⋂ { A , A } = A ) ;;
	step 7 : wff = syl5eq (step 2, step 6) |- ( A ∈ V → ⋂ { A } = A ) ;;
	qed prop 1 = step 7 ;;
}

/* The intersection of a singleton is its member.  Theorem 70 of [Suppes]
       p. 41.  (Contributed by NM, 29-Sep-2002.) */

theorem intsn (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ { A } = A ;;
}

proof of intsn {
	step 1 : wff = intsng () |- ( A ∈ _V → ⋂ { A } = A ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ⋂ { A } = A ;;
	qed prop 1 = step 2 ;;
}

/* Two ways to express " ` A ` is a singleton."  See also ~ en1 , ~ en1b ,
       ~ card1 , and ~ eusn .  (Contributed by NM, 2-Aug-2010.) */

theorem uniintsn (x : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ( ⋃ A = ⋂ A ↔ ∃ x A = { x } ) ;;
}

proof of uniintsn {
	var y : set;;
	step 1 : wff = vn0 () |- _V ≠ ∅ ;;
	step 2 : wff = inteq () |- ( A = ∅ → ⋂ A = ⋂ ∅ ) ;;
	step 3 : wff = int0 () |- ⋂ ∅ = _V ;;
	step 4 : wff = syl6eq (step 2, step 3) |- ( A = ∅ → ⋂ A = _V ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ⋃ A = ⋂ A ∧ A = ∅ ) → ⋂ A = _V ) ;;
	step 6 : wff = unieq () |- ( A = ∅ → ⋃ A = ⋃ ∅ ) ;;
	step 7 : wff = uni0 () |- ⋃ ∅ = ∅ ;;
	step 8 : wff = syl6eq (step 6, step 7) |- ( A = ∅ → ⋃ A = ∅ ) ;;
	step 9 : wff = eqeq1 () |- ( ⋃ A = ⋂ A → ( ⋃ A = ∅ ↔ ⋂ A = ∅ ) ) ;;
	step 10 : wff = syl5ib (step 8, step 9) |- ( ⋃ A = ⋂ A → ( A = ∅ → ⋂ A = ∅ ) ) ;;
	step 11 : wff = imp (step 10) |- ( ( ⋃ A = ⋂ A ∧ A = ∅ ) → ⋂ A = ∅ ) ;;
	step 12 : wff = eqtr3d (step 5, step 11) |- ( ( ⋃ A = ⋂ A ∧ A = ∅ ) → _V = ∅ ) ;;
	step 13 : wff = ex (step 12) |- ( ⋃ A = ⋂ A → ( A = ∅ → _V = ∅ ) ) ;;
	step 14 : wff = necon3d (step 13) |- ( ⋃ A = ⋂ A → ( _V ≠ ∅ → A ≠ ∅ ) ) ;;
	step 15 : wff = mpi (step 1, step 14) |- ( ⋃ A = ⋂ A → A ≠ ∅ ) ;;
	step 16 : wff = n0 () |- ( A ≠ ∅ ↔ ∃ x x ∈ A ) ;;
	step 17 : wff = sylib (step 15, step 16) |- ( ⋃ A = ⋂ A → ∃ x x ∈ A ) ;;
	step 18 : wff = vex () |- x ∈ _V ;;
	step 19 : wff = vex () |- y ∈ _V ;;
	step 20 : wff = prss (step 18, step 19) |- ( ( x ∈ A ∧ y ∈ A ) ↔ { x , y } ⊆ A ) ;;
	step 21 : wff = uniss () |- ( { x , y } ⊆ A → ⋃ { x , y } ⊆ ⋃ A ) ;;
	step 22 : wff = adantl (step 21) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ⋃ { x , y } ⊆ ⋃ A ) ;;
	step 23 : wff = simpl () |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ⋃ A = ⋂ A ) ;;
	step 24 : wff = sseqtrd (step 22, step 23) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ⋃ { x , y } ⊆ ⋂ A ) ;;
	step 25 : wff = intss () |- ( { x , y } ⊆ A → ⋂ A ⊆ ⋂ { x , y } ) ;;
	step 26 : wff = adantl (step 25) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ⋂ A ⊆ ⋂ { x , y } ) ;;
	step 27 : wff = sstrd (step 24, step 26) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ⋃ { x , y } ⊆ ⋂ { x , y } ) ;;
	step 28 : wff = vex () |- x ∈ _V ;;
	step 29 : wff = vex () |- y ∈ _V ;;
	step 30 : wff = unipr (step 28, step 29) |- ⋃ { x , y } = ( x ∪ y ) ;;
	step 31 : wff = vex () |- x ∈ _V ;;
	step 32 : wff = vex () |- y ∈ _V ;;
	step 33 : wff = intpr (step 31, step 32) |- ⋂ { x , y } = ( x ∩ y ) ;;
	step 34 : wff = 3sstr3g (step 27, step 30, step 33) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ( x ∪ y ) ⊆ ( x ∩ y ) ) ;;
	step 35 : wff = inss1 () |- ( x ∩ y ) ⊆ x ;;
	step 36 : wff = ssun1 () |- x ⊆ ( x ∪ y ) ;;
	step 37 : wff = sstri (step 35, step 36) |- ( x ∩ y ) ⊆ ( x ∪ y ) ;;
	step 38 : wff = jctir (step 34, step 37) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → ( ( x ∪ y ) ⊆ ( x ∩ y ) ∧ ( x ∩ y ) ⊆ ( x ∪ y ) ) ) ;;
	step 39 : wff = eqss () |- ( ( x ∪ y ) = ( x ∩ y ) ↔ ( ( x ∪ y ) ⊆ ( x ∩ y ) ∧ ( x ∩ y ) ⊆ ( x ∪ y ) ) ) ;;
	step 40 : wff = uneqin () |- ( ( x ∪ y ) = ( x ∩ y ) ↔ x = y ) ;;
	step 41 : wff = bitr3i (step 39, step 40) |- ( ( ( x ∪ y ) ⊆ ( x ∩ y ) ∧ ( x ∩ y ) ⊆ ( x ∪ y ) ) ↔ x = y ) ;;
	step 42 : wff = sylib (step 38, step 41) |- ( ( ⋃ A = ⋂ A ∧ { x , y } ⊆ A ) → x = y ) ;;
	step 43 : wff = ex (step 42) |- ( ⋃ A = ⋂ A → ( { x , y } ⊆ A → x = y ) ) ;;
	step 44 : wff = syl5bi (step 20, step 43) |- ( ⋃ A = ⋂ A → ( ( x ∈ A ∧ y ∈ A ) → x = y ) ) ;;
	step 45 : wff = alrimivv (step 44) |- ( ⋃ A = ⋂ A → ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → x = y ) ) ;;
	step 46 : wff = jca (step 17, step 45) |- ( ⋃ A = ⋂ A → ( ∃ x x ∈ A ∧ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → x = y ) ) ) ;;
	step 47 : wff = euabsn () |- ( ∃! x x ∈ A ↔ ∃ x { x | x ∈ A } = { x } ) ;;
	step 48 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 49 : wff = eu4 (step 48) |- ( ∃! x x ∈ A ↔ ( ∃ x x ∈ A ∧ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → x = y ) ) ) ;;
	step 50 : wff = abid2 () |- { x | x ∈ A } = A ;;
	step 51 : wff = eqeq1i (step 50) |- ( { x | x ∈ A } = { x } ↔ A = { x } ) ;;
	step 52 : wff = exbii (step 51) |- ( ∃ x { x | x ∈ A } = { x } ↔ ∃ x A = { x } ) ;;
	step 53 : wff = 3bitr3i (step 47, step 49, step 52) |- ( ( ∃ x x ∈ A ∧ ∀ x ∀ y ( ( x ∈ A ∧ y ∈ A ) → x = y ) ) ↔ ∃ x A = { x } ) ;;
	step 54 : wff = sylib (step 46, step 53) |- ( ⋃ A = ⋂ A → ∃ x A = { x } ) ;;
	step 55 : wff = vex () |- x ∈ _V ;;
	step 56 : wff = unisn (step 55) |- ⋃ { x } = x ;;
	step 57 : wff = unieq () |- ( A = { x } → ⋃ A = ⋃ { x } ) ;;
	step 58 : wff = inteq () |- ( A = { x } → ⋂ A = ⋂ { x } ) ;;
	step 59 : wff = vex () |- x ∈ _V ;;
	step 60 : wff = intsn (step 59) |- ⋂ { x } = x ;;
	step 61 : wff = syl6eq (step 58, step 60) |- ( A = { x } → ⋂ A = x ) ;;
	step 62 : wff = 3eqtr4a (step 56, step 57, step 61) |- ( A = { x } → ⋃ A = ⋂ A ) ;;
	step 63 : wff = exlimiv (step 62) |- ( ∃ x A = { x } → ⋃ A = ⋂ A ) ;;
	step 64 : wff = impbii (step 54, step 63) |- ( ⋃ A = ⋂ A ↔ ∃ x A = { x } ) ;;
	qed prop 1 = step 64 ;;
}

/* The union and the intersection of a class abstraction are equal exactly
       when there is a unique satisfying value of ` ph ( x ) ` .  (Contributed
       by Mario Carneiro, 24-Dec-2016.) */

theorem uniintab (ph : wff, x : set) disjointed(x y, y ph) {
	prop 1 : wff = |- ( ∃! x ph ↔ ⋃ { x | ph } = ⋂ { x | ph } ) ;;
}

proof of uniintab {
	var y : set;;
	step 1 : wff = euabsn2 () |- ( ∃! x ph ↔ ∃ y { x | ph } = { y } ) ;;
	step 2 : wff = uniintsn () |- ( ⋃ { x | ph } = ⋂ { x | ph } ↔ ∃ y { x | ph } = { y } ) ;;
	step 3 : wff = bitr4i (step 1, step 2) |- ( ∃! x ph ↔ ⋃ { x | ph } = ⋂ { x | ph } ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem joining a singleton to an intersection.  (Contributed by NM,
       29-Sep-2002.) */

theorem intunsn (A : class, B : class)  {
	hyp 1 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋂ ( A ∪ { B } ) = ( ⋂ A ∩ B ) ;;
}

proof of intunsn {
	step 1 : wff = intun () |- ⋂ ( A ∪ { B } ) = ( ⋂ A ∩ ⋂ { B } ) ;;
	step 2 : wff = intsn (hyp 1) |- ⋂ { B } = B ;;
	step 3 : wff = ineq2i (step 2) |- ( ⋂ A ∩ ⋂ { B } ) = ( ⋂ A ∩ B ) ;;
	step 4 : wff = eqtri (step 1, step 3) |- ⋂ ( A ∪ { B } ) = ( ⋂ A ∩ B ) ;;
	qed prop 1 = step 4 ;;
}

/* Relative intersection of an empty set.  (Contributed by Stefan O'Rear,
     3-Apr-2015.) */

theorem rint0 (A : class, X : class)  {
	prop 1 : wff = |- ( X = ∅ → ( A ∩ ⋂ X ) = A ) ;;
}

proof of rint0 {
	step 1 : wff = inteq () |- ( X = ∅ → ⋂ X = ⋂ ∅ ) ;;
	step 2 : wff = ineq2d (step 1) |- ( X = ∅ → ( A ∩ ⋂ X ) = ( A ∩ ⋂ ∅ ) ) ;;
	step 3 : wff = int0 () |- ⋂ ∅ = _V ;;
	step 4 : wff = ineq2i (step 3) |- ( A ∩ ⋂ ∅ ) = ( A ∩ _V ) ;;
	step 5 : wff = inv1 () |- ( A ∩ _V ) = A ;;
	step 6 : wff = eqtri (step 4, step 5) |- ( A ∩ ⋂ ∅ ) = A ;;
	step 7 : wff = syl6eq (step 2, step 6) |- ( X = ∅ → ( A ∩ ⋂ X ) = A ) ;;
	qed prop 1 = step 7 ;;
}

/* Membership in a restricted intersection.  (Contributed by Stefan O'Rear,
       3-Apr-2015.) */

theorem elrint (y : set, A : class, B : class, X : class) disjointed(B y, X y) {
	prop 1 : wff = |- ( X ∈ ( A ∩ ⋂ B ) ↔ ( X ∈ A ∧ ∀ y ∈ B X ∈ y ) ) ;;
}

proof of elrint {
	step 1 : wff = elin () |- ( X ∈ ( A ∩ ⋂ B ) ↔ ( X ∈ A ∧ X ∈ ⋂ B ) ) ;;
	step 2 : wff = elintg () |- ( X ∈ A → ( X ∈ ⋂ B ↔ ∀ y ∈ B X ∈ y ) ) ;;
	step 3 : wff = pm5.32i (step 2) |- ( ( X ∈ A ∧ X ∈ ⋂ B ) ↔ ( X ∈ A ∧ ∀ y ∈ B X ∈ y ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( X ∈ ( A ∩ ⋂ B ) ↔ ( X ∈ A ∧ ∀ y ∈ B X ∈ y ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Membership in a restricted intersection.  (Contributed by Stefan O'Rear,
       3-Apr-2015.) */

theorem elrint2 (y : set, A : class, B : class, X : class) disjointed(B y, X y) {
	prop 1 : wff = |- ( X ∈ A → ( X ∈ ( A ∩ ⋂ B ) ↔ ∀ y ∈ B X ∈ y ) ) ;;
}

proof of elrint2 {
	step 1 : wff = elrint () |- ( X ∈ ( A ∩ ⋂ B ) ↔ ( X ∈ A ∧ ∀ y ∈ B X ∈ y ) ) ;;
	step 2 : wff = baib (step 1) |- ( X ∈ A → ( X ∈ ( A ∩ ⋂ B ) ↔ ∀ y ∈ B X ∈ y ) ) ;;
	qed prop 1 = step 2 ;;
}


