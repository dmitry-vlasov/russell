import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Class_abstractions_(a_k_a__class_builders).rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Class form not-free predicate

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

constant {
	symbol F/_ ;;
}

/* Underlined not-free symbol. */

/* Extend wff definition to include the not-free predicate for classes. */

rule wnfc (x : set, A : class) {
	term : wff = # F/_ x A ;;
}

/* Justification theorem for ~ df-nfc .  (Contributed by Mario Carneiro,
       13-Oct-2016.) */

theorem nfcjust (x : set, y : set, z : set, A : class) disjointed(x y z, y z A) {
	prop 1 : wff = |- ( ∀ y F/ x y ∈ A ↔ ∀ z F/ x z ∈ A ) ;;
}

proof of nfcjust {
	step 1 : wff = nfv () |- F/ x y = z ;;
	step 2 : wff = eleq1 () |- ( y = z → ( y ∈ A ↔ z ∈ A ) ) ;;
	step 3 : wff = nfbidf (step 1, step 2) |- ( y = z → ( F/ x y ∈ A ↔ F/ x z ∈ A ) ) ;;
	step 4 : wff = cbvalv (step 3) |- ( ∀ y F/ x y ∈ A ↔ ∀ z F/ x z ∈ A ) ;;
	qed prop 1 = step 4 ;;
}

/* Define the not-free predicate for classes.  This is read " ` x ` is not
       free in ` A ` ".  Not-free means that the value of ` x ` cannot affect
       the value of ` A ` , e.g., any occurrence of ` x ` in ` A ` is
       effectively bound by a "for all" or something that expands to one (such
       as "there exists").  It is defined in terms of the not-free predicate
       ~ df-nf for wffs; see that definition for more information.
       (Contributed by Mario Carneiro, 11-Aug-2016.) */

definition df-nfc (x : set, y : set, A : class) disjointed(x y, y A) {
	defiendum : wff = # F/_ x A ;;
	definiens : wff = # ∀ y F/ x y ∈ A ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/* Deduce that a class ` A ` does not have ` x ` free in it.
         (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfci (x : set, y : set, A : class) disjointed(x y, y A) {
	hyp 1 : wff = |- F/ x y ∈ A ;;
	-----------------------
	prop 1 : wff = |- F/_ x A ;;
}

proof of nfci {
	step 1 : wff = df-nfc () |- ( F/_ x A ↔ ∀ y F/ x y ∈ A ) ;;
	step 2 : wff = mpgbir (step 1, hyp 1) |- F/_ x A ;;
	qed prop 1 = step 2 ;;
}

/* Deduce that a class ` A ` does not have ` x ` free in it.
         (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfcii (x : set, y : set, A : class) disjointed(x y, y A) {
	hyp 1 : wff = |- ( y ∈ A → ∀ x y ∈ A ) ;;
	-----------------------
	prop 1 : wff = |- F/_ x A ;;
}

proof of nfcii {
	step 1 : wff = nfi (hyp 1) |- F/ x y ∈ A ;;
	step 2 : wff = nfci (step 1) |- F/_ x A ;;
	qed prop 1 = step 2 ;;
}

/* Consequence of the not-free predicate.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfcr (x : set, y : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( F/_ x A → F/ x y ∈ A ) ;;
}

proof of nfcr {
	step 1 : wff = df-nfc () |- ( F/_ x A ↔ ∀ y F/ x y ∈ A ) ;;
	step 2 : wff = sp () |- ( ∀ y F/ x y ∈ A → F/ x y ∈ A ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( F/_ x A → F/ x y ∈ A ) ;;
	qed prop 1 = step 3 ;;
}

/* Consequence of the not-free predicate.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfcrii (x : set, y : set, A : class) disjointed(x y z, z A) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- ( y ∈ A → ∀ x y ∈ A ) ;;
}

proof of nfcrii {
	var z : set;;
	step 1 : wff = nfcr () |- ( F/_ x A → F/ x z ∈ A ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- F/ x z ∈ A ;;
	step 3 : wff = nfri (step 2) |- ( z ∈ A → ∀ x z ∈ A ) ;;
	step 4 : wff = hblem (step 3) |- ( y ∈ A → ∀ x y ∈ A ) ;;
	qed prop 1 = step 4 ;;
}

/* Consequence of the not-free predicate.  (Note that unlike ~ nfcr , this
       does not require ` y ` and ` A ` to be disjoint.)  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem nfcri (x : set, y : set, A : class) disjointed(x y) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x y ∈ A ;;
}

proof of nfcri {
	step 1 : wff = nfcrii (hyp 1) |- ( y ∈ A → ∀ x y ∈ A ) ;;
	step 2 : wff = nfi (step 1) |- F/ x y ∈ A ;;
	qed prop 1 = step 2 ;;
}

/* Deduce that a class ` A ` does not have ` x ` free in it.  (Contributed
       by Mario Carneiro, 11-Aug-2016.) */

theorem nfcd (ph : wff, x : set, y : set, A : class) disjointed(x y, y A) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/ x y ∈ A ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x A ) ;;
}

proof of nfcd {
	step 1 : wff = alrimi (hyp 1, hyp 2) |- ( ph → ∀ y F/ x y ∈ A ) ;;
	step 2 : wff = df-nfc () |- ( F/_ x A ↔ ∀ y F/ x y ∈ A ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ph → F/_ x A ) ;;
	qed prop 1 = step 3 ;;
}

/* Equality theorem for class not-free.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfceqi (x : set, A : class, B : class) disjointed(x y, y A, y B) {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( F/_ x A ↔ F/_ x B ) ;;
}

proof of nfceqi {
	var y : set;;
	step 1 : wff = eleq2i (hyp 1) |- ( y ∈ A ↔ y ∈ B ) ;;
	step 2 : wff = nfbii (step 1) |- ( F/ x y ∈ A ↔ F/ x y ∈ B ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ y F/ x y ∈ A ↔ ∀ y F/ x y ∈ B ) ;;
	step 4 : wff = df-nfc () |- ( F/_ x A ↔ ∀ y F/ x y ∈ A ) ;;
	step 5 : wff = df-nfc () |- ( F/_ x B ↔ ∀ y F/ x y ∈ B ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( F/_ x A ↔ F/_ x B ) ;;
	qed prop 1 = step 6 ;;
}

/* A utility lemma to transfer a bound-variable hypothesis builder into a
         definition.  (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfcxfr (x : set, A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/_ x A ;;
}

proof of nfcxfr {
	step 1 : wff = nfceqi (hyp 1) |- ( F/_ x A ↔ F/_ x B ) ;;
	step 2 : wff = mpbir (hyp 2, step 1) |- F/_ x A ;;
	qed prop 1 = step 2 ;;
}

/* A utility lemma to transfer a bound-variable hypothesis builder into a
         definition.  (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfcxfrd (ph : wff, x : set, A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x A ) ;;
}

proof of nfcxfrd {
	step 1 : wff = nfceqi (hyp 1) |- ( F/_ x A ↔ F/_ x B ) ;;
	step 2 : wff = sylibr (hyp 2, step 1) |- ( ph → F/_ x A ) ;;
	qed prop 1 = step 2 ;;
}

/* An equality theorem for effectively not free.  (Contributed by Mario
       Carneiro, 14-Oct-2016.) */

theorem nfceqdf (ph : wff, x : set, A : class, B : class) disjointed(x y, A y, B y, ph y) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( F/_ x A ↔ F/_ x B ) ) ;;
}

proof of nfceqdf {
	var y : set;;
	step 1 : wff = eleq2d (hyp 2) |- ( ph → ( y ∈ A ↔ y ∈ B ) ) ;;
	step 2 : wff = nfbidf (hyp 1, step 1) |- ( ph → ( F/ x y ∈ A ↔ F/ x y ∈ B ) ) ;;
	step 3 : wff = albidv (step 2) |- ( ph → ( ∀ y F/ x y ∈ A ↔ ∀ y F/ x y ∈ B ) ) ;;
	step 4 : wff = df-nfc () |- ( F/_ x A ↔ ∀ y F/ x y ∈ A ) ;;
	step 5 : wff = df-nfc () |- ( F/_ x B ↔ ∀ y F/ x y ∈ B ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ph → ( F/_ x A ↔ F/_ x B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* If ` x ` is disjoint from ` A ` , then ` x ` is not free in ` A ` .
       (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfcv (x : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- F/_ x A ;;
}

proof of nfcv {
	var y : set;;
	step 1 : wff = nfv () |- F/ x y ∈ A ;;
	step 2 : wff = nfci (step 1) |- F/_ x A ;;
	qed prop 1 = step 2 ;;
}

/* If ` x ` is disjoint from ` A ` , then ` x ` is not free in ` A ` .
       (Contributed by Mario Carneiro, 7-Oct-2016.) */

theorem nfcvd (ph : wff, x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( ph → F/_ x A ) ;;
}

proof of nfcvd {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = a1i (step 1) |- ( ph → F/_ x A ) ;;
	qed prop 1 = step 2 ;;
}

/* Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 11-Aug-2016.) */

theorem nfab1 (ph : wff, x : set) disjointed(x y, y ph) {
	prop 1 : wff = |- F/_ x { x | ph } ;;
}

proof of nfab1 {
	var y : set;;
	step 1 : wff = nfsab1 () |- F/ x y ∈ { x | ph } ;;
	step 2 : wff = nfci (step 1) |- F/_ x { x | ph } ;;
	qed prop 1 = step 2 ;;
}

/* ` x ` is bound in ` F/_ x A ` .  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfnfc1 (x : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- F/ x F/_ x A ;;
}

proof of nfnfc1 {
	var y : set;;
	step 1 : wff = df-nfc () |- ( F/_ x A ↔ ∀ y F/ x y ∈ A ) ;;
	step 2 : wff = nfnf1 () |- F/ x F/ x y ∈ A ;;
	step 3 : wff = nfal (step 2) |- F/ x ∀ y F/ x y ∈ A ;;
	step 4 : wff = nfxfr (step 1, step 3) |- F/ x F/_ x A ;;
	qed prop 1 = step 4 ;;
}

/* Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 11-Aug-2016.) */

theorem nfab (ph : wff, x : set, y : set) disjointed(x z, y z, z ph) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/_ x { y | ph } ;;
}

proof of nfab {
	var z : set;;
	step 1 : wff = nfsab (hyp 1) |- F/ x z ∈ { y | ph } ;;
	step 2 : wff = nfci (step 1) |- F/_ x { y | ph } ;;
	qed prop 1 = step 2 ;;
}

/* Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 14-Oct-2016.) */

theorem nfaba1 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- F/_ x { y | ∀ x ph } ;;
}

proof of nfaba1 {
	step 1 : wff = nfa1 () |- F/ x ∀ x ph ;;
	step 2 : wff = nfab (step 1) |- F/_ x { y | ∀ x ph } ;;
	qed prop 1 = step 2 ;;
}

/* Hypothesis builder for ` F/_ y A ` .  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfnfc (x : set, y : set, A : class) disjointed(x z, y z, z A) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x F/_ y A ;;
}

proof of nfnfc {
	var z : set;;
	step 1 : wff = df-nfc () |- ( F/_ y A ↔ ∀ z F/ y z ∈ A ) ;;
	step 2 : wff = nfcri (hyp 1) |- F/ x z ∈ A ;;
	step 3 : wff = nfnf (step 2) |- F/ x F/ y z ∈ A ;;
	step 4 : wff = nfal (step 3) |- F/ x ∀ z F/ y z ∈ A ;;
	step 5 : wff = nfxfr (step 1, step 4) |- F/ x F/_ y A ;;
	qed prop 1 = step 5 ;;
}

/* Hypothesis builder for equality.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfeq (x : set, A : class, B : class) disjointed(x z, z A, z B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x A = B ;;
}

proof of nfeq {
	var z : set;;
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ z ( z ∈ A ↔ z ∈ B ) ) ;;
	step 2 : wff = nfcri (hyp 1) |- F/ x z ∈ A ;;
	step 3 : wff = nfcri (hyp 2) |- F/ x z ∈ B ;;
	step 4 : wff = nfbi (step 2, step 3) |- F/ x ( z ∈ A ↔ z ∈ B ) ;;
	step 5 : wff = nfal (step 4) |- F/ x ∀ z ( z ∈ A ↔ z ∈ B ) ;;
	step 6 : wff = nfxfr (step 1, step 5) |- F/ x A = B ;;
	qed prop 1 = step 6 ;;
}

/* Hypothesis builder for elementhood.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfel (x : set, A : class, B : class) disjointed(x z, z A, z B) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x A ∈ B ;;
}

proof of nfel {
	var z : set;;
	step 1 : wff = df-clel () |- ( A ∈ B ↔ ∃ z ( z = A ∧ z ∈ B ) ) ;;
	step 2 : wff = nfcv () |- F/_ x z ;;
	step 3 : wff = nfeq (step 2, hyp 1) |- F/ x z = A ;;
	step 4 : wff = nfcri (hyp 2) |- F/ x z ∈ B ;;
	step 5 : wff = nfan (step 3, step 4) |- F/ x ( z = A ∧ z ∈ B ) ;;
	step 6 : wff = nfex (step 5) |- F/ x ∃ z ( z = A ∧ z ∈ B ) ;;
	step 7 : wff = nfxfr (step 1, step 6) |- F/ x A ∈ B ;;
	qed prop 1 = step 7 ;;
}

/* Hypothesis builder for equality, special case.  (Contributed by Mario
       Carneiro, 10-Oct-2016.) */

theorem nfeq1 (x : set, A : class, B : class) disjointed(x B) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x A = B ;;
}

proof of nfeq1 {
	step 1 : wff = nfcv () |- F/_ x B ;;
	step 2 : wff = nfeq (hyp 1, step 1) |- F/ x A = B ;;
	qed prop 1 = step 2 ;;
}

/* Hypothesis builder for elementhood, special case.  (Contributed by Mario
       Carneiro, 10-Oct-2016.) */

theorem nfel1 (x : set, A : class, B : class) disjointed(x B) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/ x A ∈ B ;;
}

proof of nfel1 {
	step 1 : wff = nfcv () |- F/_ x B ;;
	step 2 : wff = nfel (hyp 1, step 1) |- F/ x A ∈ B ;;
	qed prop 1 = step 2 ;;
}

/* Hypothesis builder for equality, special case.  (Contributed by Mario
       Carneiro, 10-Oct-2016.) */

theorem nfeq2 (x : set, A : class, B : class) disjointed(x A) {
	hyp 1 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x A = B ;;
}

proof of nfeq2 {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfeq (step 1, hyp 1) |- F/ x A = B ;;
	qed prop 1 = step 2 ;;
}

/* Hypothesis builder for elementhood, special case.  (Contributed by Mario
       Carneiro, 10-Oct-2016.) */

theorem nfel2 (x : set, A : class, B : class) disjointed(x A) {
	hyp 1 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x A ∈ B ;;
}

proof of nfel2 {
	step 1 : wff = nfcv () |- F/_ x A ;;
	step 2 : wff = nfel (step 1, hyp 1) |- F/ x A ∈ B ;;
	qed prop 1 = step 2 ;;
}

/* Consequence of the not-free predicate.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfcrd (ph : wff, x : set, y : set, A : class) disjointed(x y, y A) {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x y ∈ A ) ;;
}

proof of nfcrd {
	step 1 : wff = nfcr () |- ( F/_ x A → F/ x y ∈ A ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → F/ x y ∈ A ) ;;
	qed prop 1 = step 2 ;;
}

/* Hypothesis builder for equality.  (Contributed by Mario Carneiro,
       7-Oct-2016.) */

theorem nfeqd (ph : wff, x : set, A : class, B : class) disjointed(x y, y A, y B, y ph) {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	hyp 2 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x A = B ) ;;
}

proof of nfeqd {
	var y : set;;
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = nfcrd (hyp 1) |- ( ph → F/ x y ∈ A ) ;;
	step 4 : wff = nfcrd (hyp 2) |- ( ph → F/ x y ∈ B ) ;;
	step 5 : wff = nfbid (step 3, step 4) |- ( ph → F/ x ( y ∈ A ↔ y ∈ B ) ) ;;
	step 6 : wff = nfald (step 2, step 5) |- ( ph → F/ x ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 7 : wff = nfxfrd (step 1, step 6) |- ( ph → F/ x A = B ) ;;
	qed prop 1 = step 7 ;;
}

/* Hypothesis builder for elementhood.  (Contributed by Mario Carneiro,
       7-Oct-2016.) */

theorem nfeld (ph : wff, x : set, A : class, B : class) disjointed(x y, y A, y B, y ph) {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	hyp 2 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x A ∈ B ) ;;
}

proof of nfeld {
	var y : set;;
	step 1 : wff = df-clel () |- ( A ∈ B ↔ ∃ y ( y = A ∧ y ∈ B ) ) ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = nfcvd () |- ( ph → F/_ x y ) ;;
	step 4 : wff = nfeqd (step 3, hyp 1) |- ( ph → F/ x y = A ) ;;
	step 5 : wff = nfcrd (hyp 2) |- ( ph → F/ x y ∈ B ) ;;
	step 6 : wff = nfand (step 4, step 5) |- ( ph → F/ x ( y = A ∧ y ∈ B ) ) ;;
	step 7 : wff = nfexd (step 2, step 6) |- ( ph → F/ x ∃ y ( y = A ∧ y ∈ B ) ) ;;
	step 8 : wff = nfxfrd (step 1, step 7) |- ( ph → F/ x A ∈ B ) ;;
	qed prop 1 = step 8 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       (Contributed by Mario Carneiro, 8-Oct-2016.) */

theorem drnfc1 (x : set, y : set, A : class, B : class) disjointed(w x, w y, w A, w B) {
	hyp 1 : wff = |- ( ∀ x x = y → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( F/_ x A ↔ F/_ y B ) ) ;;
}

proof of drnfc1 {
	var w : set;;
	step 1 : wff = eleq2d (hyp 1) |- ( ∀ x x = y → ( w ∈ A ↔ w ∈ B ) ) ;;
	step 2 : wff = drnf1 (step 1) |- ( ∀ x x = y → ( F/ x w ∈ A ↔ F/ y w ∈ B ) ) ;;
	step 3 : wff = dral2 (step 2) |- ( ∀ x x = y → ( ∀ w F/ x w ∈ A ↔ ∀ w F/ y w ∈ B ) ) ;;
	step 4 : wff = df-nfc () |- ( F/_ x A ↔ ∀ w F/ x w ∈ A ) ;;
	step 5 : wff = df-nfc () |- ( F/_ y B ↔ ∀ w F/ y w ∈ B ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ∀ x x = y → ( F/_ x A ↔ F/_ y B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       (Contributed by Mario Carneiro, 8-Oct-2016.) */

theorem drnfc2 (x : set, y : set, z : set, A : class, B : class) disjointed(w x, w y, w z, w A, w B) {
	hyp 1 : wff = |- ( ∀ x x = y → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( F/_ z A ↔ F/_ z B ) ) ;;
}

proof of drnfc2 {
	var w : set;;
	step 1 : wff = eleq2d (hyp 1) |- ( ∀ x x = y → ( w ∈ A ↔ w ∈ B ) ) ;;
	step 2 : wff = drnf2 (step 1) |- ( ∀ x x = y → ( F/ z w ∈ A ↔ F/ z w ∈ B ) ) ;;
	step 3 : wff = dral2 (step 2) |- ( ∀ x x = y → ( ∀ w F/ z w ∈ A ↔ ∀ w F/ z w ∈ B ) ) ;;
	step 4 : wff = df-nfc () |- ( F/_ z A ↔ ∀ w F/ z w ∈ A ) ;;
	step 5 : wff = df-nfc () |- ( F/_ z B ↔ ∀ w F/ z w ∈ B ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ∀ x x = y → ( F/_ z A ↔ F/_ z B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 8-Oct-2016.) */

theorem nfabd2 (ph : wff, ps : wff, x : set, y : set) disjointed(x z, y z, z ph, z ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x { y | ps } ) ;;
}

proof of nfabd2 {
	var z : set;;
	step 1 : wff = nfv () |- F/ z ( ph ∧ ¬ ∀ x x = y ) ;;
	step 2 : wff = df-clab () |- ( z ∈ { y | ps } ↔ [ z / y ] ps ) ;;
	step 3 : wff = nfnae () |- F/ y ¬ ∀ x x = y ;;
	step 4 : wff = nfan (hyp 1, step 3) |- F/ y ( ph ∧ ¬ ∀ x x = y ) ;;
	step 5 : wff = nfsbd (step 4, hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x [ z / y ] ps ) ;;
	step 6 : wff = nfxfrd (step 2, step 5) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x z ∈ { y | ps } ) ;;
	step 7 : wff = nfcd (step 1, step 6) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x { y | ps } ) ;;
	step 8 : wff = ex (step 7) |- ( ph → ( ¬ ∀ x x = y → F/_ x { y | ps } ) ) ;;
	step 9 : wff = nfab1 () |- F/_ y { y | ps } ;;
	step 10 : wff = eqidd () |- ( ∀ x x = y → { y | ps } = { y | ps } ) ;;
	step 11 : wff = drnfc1 (step 10) |- ( ∀ x x = y → ( F/_ x { y | ps } ↔ F/_ y { y | ps } ) ) ;;
	step 12 : wff = mpbiri (step 9, step 11) |- ( ∀ x x = y → F/_ x { y | ps } ) ;;
	step 13 : wff = pm2.61d2 (step 8, step 12) |- ( ph → F/_ x { y | ps } ) ;;
	qed prop 1 = step 13 ;;
}

/* Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 8-Oct-2016.) */

theorem nfabd (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x { y | ps } ) ;;
}

proof of nfabd {
	step 1 : wff = adantr (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 2 : wff = nfabd2 (hyp 1, step 1) |- ( ph → F/_ x { y | ps } ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction form of ~ dvelimc .  (Contributed by Mario Carneiro,
       8-Oct-2016.) */

theorem dvelimdc (ph : wff, x : set, y : set, z : set, A : class, B : class) disjointed(w x, w y, w z, w A, w B, w ph) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ z ph ;;
	hyp 3 : wff = |- ( ph → F/_ x A ) ;;
	hyp 4 : wff = |- ( ph → F/_ z B ) ;;
	hyp 5 : wff = |- ( ph → ( z = y → A = B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ¬ ∀ x x = y → F/_ x B ) ) ;;
}

proof of dvelimdc {
	var w : set;;
	step 1 : wff = nfv () |- F/ w ( ph ∧ ¬ ∀ x x = y ) ;;
	step 2 : wff = nfcrd (hyp 3) |- ( ph → F/ x w ∈ A ) ;;
	step 3 : wff = nfcrd (hyp 4) |- ( ph → F/ z w ∈ B ) ;;
	step 4 : wff = eleq2 () |- ( A = B → ( w ∈ A ↔ w ∈ B ) ) ;;
	step 5 : wff = syl6 (hyp 5, step 4) |- ( ph → ( z = y → ( w ∈ A ↔ w ∈ B ) ) ) ;;
	step 6 : wff = dvelimdf (hyp 1, hyp 2, step 2, step 3, step 5) |- ( ph → ( ¬ ∀ x x = y → F/ x w ∈ B ) ) ;;
	step 7 : wff = imp (step 6) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x w ∈ B ) ;;
	step 8 : wff = nfcd (step 1, step 7) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/_ x B ) ;;
	step 9 : wff = ex (step 8) |- ( ph → ( ¬ ∀ x x = y → F/_ x B ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Version of ~ dvelim for classes.  (Contributed by Mario Carneiro,
       8-Oct-2016.) */

theorem dvelimc (x : set, y : set, z : set, A : class, B : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ z B ;;
	hyp 3 : wff = |- ( z = y → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → F/_ x B ) ;;
}

proof of dvelimc {
	step 1 : wff = nftru () |- F/ x T. ;;
	step 2 : wff = nftru () |- F/ z T. ;;
	step 3 : wff = a1i (hyp 1) |- ( T. → F/_ x A ) ;;
	step 4 : wff = a1i (hyp 2) |- ( T. → F/_ z B ) ;;
	step 5 : wff = a1i (hyp 3) |- ( T. → ( z = y → A = B ) ) ;;
	step 6 : wff = dvelimdc (step 1, step 2, step 3, step 4, step 5) |- ( T. → ( ¬ ∀ x x = y → F/_ x B ) ) ;;
	step 7 : wff = trud (step 6) |- ( ¬ ∀ x x = y → F/_ x B ) ;;
	qed prop 1 = step 7 ;;
}

/* If ` x ` and ` y ` are distinct, then ` x ` is not free in ` y ` .
       (Contributed by Mario Carneiro, 8-Oct-2016.) */

theorem nfcvf (x : set, y : set) disjointed(x z, y z) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → F/_ x y ) ;;
}

proof of nfcvf {
	var z : set;;
	step 1 : wff = nfcv () |- F/_ x z ;;
	step 2 : wff = nfcv () |- F/_ z y ;;
	step 3 : wff = id () |- ( z = y → z = y ) ;;
	step 4 : wff = dvelimc (step 1, step 2, step 3) |- ( ¬ ∀ x x = y → F/_ x y ) ;;
	qed prop 1 = step 4 ;;
}

/* If ` x ` and ` y ` are distinct, then ` y ` is not free in ` x ` .
       (Contributed by Mario Carneiro, 5-Dec-2016.) */

theorem nfcvf2 (x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → F/_ y x ) ;;
}

proof of nfcvf2 {
	step 1 : wff = nfcvf () |- ( ¬ ∀ y y = x → F/_ y x ) ;;
	step 2 : wff = naecoms (step 1) |- ( ¬ ∀ x x = y → F/_ y x ) ;;
	qed prop 1 = step 2 ;;
}

/* Establish equality between classes, using bound-variable hypotheses
       instead of distinct variable conditions.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem cleqf (x : set, A : class, B : class) disjointed(y A, y B, x y) {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
}

proof of cleqf {
	var y : set;;
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 2 : wff = nfv () |- F/ y ( x ∈ A ↔ x ∈ B ) ;;
	step 3 : wff = nfcri (hyp 1) |- F/ x y ∈ A ;;
	step 4 : wff = nfcri (hyp 2) |- F/ x y ∈ B ;;
	step 5 : wff = nfbi (step 3, step 4) |- F/ x ( y ∈ A ↔ y ∈ B ) ;;
	step 6 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 7 : wff = eleq1 () |- ( x = y → ( x ∈ B ↔ y ∈ B ) ) ;;
	step 8 : wff = bibi12d (step 6, step 7) |- ( x = y → ( ( x ∈ A ↔ x ∈ B ) ↔ ( y ∈ A ↔ y ∈ B ) ) ) ;;
	step 9 : wff = cbval (step 2, step 5, step 8) |- ( ∀ x ( x ∈ A ↔ x ∈ B ) ↔ ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 10 : wff = bitr4i (step 1, step 9) |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	qed prop 1 = step 10 ;;
}

/* A simplification of class abstraction.  Theorem 5.2 of [Quine] p. 35.
       (Contributed by NM, 5-Sep-2011.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem abid2f (x : set, A : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- { x | x ∈ A } = A ;;
}

proof of abid2f {
	step 1 : wff = nfab1 () |- F/_ x { x | x ∈ A } ;;
	step 2 : wff = cleqf (hyp 1, step 1) |- ( A = { x | x ∈ A } ↔ ∀ x ( x ∈ A ↔ x ∈ { x | x ∈ A } ) ) ;;
	step 3 : wff = abid () |- ( x ∈ { x | x ∈ A } ↔ x ∈ A ) ;;
	step 4 : wff = bibi2i (step 3) |- ( ( x ∈ A ↔ x ∈ { x | x ∈ A } ) ↔ ( x ∈ A ↔ x ∈ A ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ x ( x ∈ A ↔ x ∈ { x | x ∈ A } ) ↔ ∀ x ( x ∈ A ↔ x ∈ A ) ) ;;
	step 6 : wff = bitri (step 2, step 5) |- ( A = { x | x ∈ A } ↔ ∀ x ( x ∈ A ↔ x ∈ A ) ) ;;
	step 7 : wff = biid () |- ( x ∈ A ↔ x ∈ A ) ;;
	step 8 : wff = mpgbir (step 6, step 7) |- A = { x | x ∈ A } ;;
	step 9 : wff = eqcomi (step 8) |- { x | x ∈ A } = A ;;
	qed prop 1 = step 9 ;;
}

/* Theorem to move a substitution in and out of a class abstraction.
       (Contributed by NM, 27-Sep-2003.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem sbabel (ph : wff, x : set, y : set, z : set, A : class) disjointed(v A, x z v, y z v, v ph) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] { z | ph } ∈ A ↔ { z | [ y / x ] ph } ∈ A ) ;;
}

proof of sbabel {
	var v : set;;
	step 1 : wff = sbex () |- ( [ y / x ] ∃ v ( v = { z | ph } ∧ v ∈ A ) ↔ ∃ v [ y / x ] ( v = { z | ph } ∧ v ∈ A ) ) ;;
	step 2 : wff = sban () |- ( [ y / x ] ( v = { z | ph } ∧ v ∈ A ) ↔ ( [ y / x ] v = { z | ph } ∧ [ y / x ] v ∈ A ) ) ;;
	step 3 : wff = nfv () |- F/ x z ∈ v ;;
	step 4 : wff = sbf (step 3) |- ( [ y / x ] z ∈ v ↔ z ∈ v ) ;;
	step 5 : wff = sbrbis (step 4) |- ( [ y / x ] ( z ∈ v ↔ ph ) ↔ ( z ∈ v ↔ [ y / x ] ph ) ) ;;
	step 6 : wff = sbalv (step 5) |- ( [ y / x ] ∀ z ( z ∈ v ↔ ph ) ↔ ∀ z ( z ∈ v ↔ [ y / x ] ph ) ) ;;
	step 7 : wff = abeq2 () |- ( v = { z | ph } ↔ ∀ z ( z ∈ v ↔ ph ) ) ;;
	step 8 : wff = sbbii (step 7) |- ( [ y / x ] v = { z | ph } ↔ [ y / x ] ∀ z ( z ∈ v ↔ ph ) ) ;;
	step 9 : wff = abeq2 () |- ( v = { z | [ y / x ] ph } ↔ ∀ z ( z ∈ v ↔ [ y / x ] ph ) ) ;;
	step 10 : wff = 3bitr4i (step 6, step 8, step 9) |- ( [ y / x ] v = { z | ph } ↔ v = { z | [ y / x ] ph } ) ;;
	step 11 : wff = nfcri (hyp 1) |- F/ x v ∈ A ;;
	step 12 : wff = sbf (step 11) |- ( [ y / x ] v ∈ A ↔ v ∈ A ) ;;
	step 13 : wff = anbi12i (step 10, step 12) |- ( ( [ y / x ] v = { z | ph } ∧ [ y / x ] v ∈ A ) ↔ ( v = { z | [ y / x ] ph } ∧ v ∈ A ) ) ;;
	step 14 : wff = bitri (step 2, step 13) |- ( [ y / x ] ( v = { z | ph } ∧ v ∈ A ) ↔ ( v = { z | [ y / x ] ph } ∧ v ∈ A ) ) ;;
	step 15 : wff = exbii (step 14) |- ( ∃ v [ y / x ] ( v = { z | ph } ∧ v ∈ A ) ↔ ∃ v ( v = { z | [ y / x ] ph } ∧ v ∈ A ) ) ;;
	step 16 : wff = bitri (step 1, step 15) |- ( [ y / x ] ∃ v ( v = { z | ph } ∧ v ∈ A ) ↔ ∃ v ( v = { z | [ y / x ] ph } ∧ v ∈ A ) ) ;;
	step 17 : wff = df-clel () |- ( { z | ph } ∈ A ↔ ∃ v ( v = { z | ph } ∧ v ∈ A ) ) ;;
	step 18 : wff = sbbii (step 17) |- ( [ y / x ] { z | ph } ∈ A ↔ [ y / x ] ∃ v ( v = { z | ph } ∧ v ∈ A ) ) ;;
	step 19 : wff = df-clel () |- ( { z | [ y / x ] ph } ∈ A ↔ ∃ v ( v = { z | [ y / x ] ph } ∧ v ∈ A ) ) ;;
	step 20 : wff = 3bitr4i (step 16, step 18, step 19) |- ( [ y / x ] { z | ph } ∈ A ↔ { z | [ y / x ] ph } ∈ A ) ;;
	qed prop 1 = step 20 ;;
}


