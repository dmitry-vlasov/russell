import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Unordered_and_ordered_pairs.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                       The union of a class

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Declare class union symbol. */

constant {
	symbol ⋃ ;;
	ascii U. ;;
	latex \bigcup ;;
}

/*Big cup */

/*Extend class notation to include the union of a class (read:  'union
     ` A ` ') */

rule cuni (A : class) {
	term : class = # ⋃ A ;;
}

/*Define the union of a class i.e. the collection of all members of the
       members of the class.  Definition 5.5 of [TakeutiZaring] p. 16.  For
       example, ` U. { { 1 , 3 } , { 1 , 8 } } = { 1 , 3 , 8 } ` ( ~ ex-uni ).
       This is similar to the union of two classes ~ df-un .  (Contributed by
       NM, 23-Aug-1993.) */

definition df-uni (x : set, y : set, A : class) disjointed(x y A) {
	defiendum : class = # ⋃ A ;;
	definiens : class = # { x | ∃ y ( x ∈ y ∧ y ∈ A ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/*Alternate definition of class union.  (Contributed by NM,
       28-Jun-1998.) */

theorem dfuni2 (x : set, y : set, A : class) disjointed(x y A) {
	prop 1 : wff = |- ⋃ A = { x | ∃ y ∈ A x ∈ y } ;;
}

proof of dfuni2 {
	step 1 : wff = df-uni () |- ⋃ A = { x | ∃ y ( x ∈ y ∧ y ∈ A ) } ;;
	step 2 : wff = exancom () |- ( ∃ y ( x ∈ y ∧ y ∈ A ) ↔ ∃ y ( y ∈ A ∧ x ∈ y ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ y ∈ A x ∈ y ↔ ∃ y ( y ∈ A ∧ x ∈ y ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( ∃ y ( x ∈ y ∧ y ∈ A ) ↔ ∃ y ∈ A x ∈ y ) ;;
	step 5 : wff = abbii (step 4) |- { x | ∃ y ( x ∈ y ∧ y ∈ A ) } = { x | ∃ y ∈ A x ∈ y } ;;
	step 6 : wff = eqtri (step 1, step 5) |- ⋃ A = { x | ∃ y ∈ A x ∈ y } ;;
	qed prop 1 = step 6 ;;
}

/*Membership in class union.  (Contributed by NM, 22-May-1994.) */

theorem eluni (x : set, A : class, B : class) disjointed(x A y, x B y) {
	prop 1 : wff = |- ( A ∈ ⋃ B ↔ ∃ x ( A ∈ x ∧ x ∈ B ) ) ;;
}

proof of eluni {
	var y : set;;
	step 1 : wff = elex () |- ( A ∈ ⋃ B → A ∈ _V ) ;;
	step 2 : wff = elex () |- ( A ∈ x → A ∈ _V ) ;;
	step 3 : wff = adantr (step 2) |- ( ( A ∈ x ∧ x ∈ B ) → A ∈ _V ) ;;
	step 4 : wff = exlimiv (step 3) |- ( ∃ x ( A ∈ x ∧ x ∈ B ) → A ∈ _V ) ;;
	step 5 : wff = eleq1 () |- ( y = A → ( y ∈ x ↔ A ∈ x ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( y = A → ( ( y ∈ x ∧ x ∈ B ) ↔ ( A ∈ x ∧ x ∈ B ) ) ) ;;
	step 7 : wff = exbidv (step 6) |- ( y = A → ( ∃ x ( y ∈ x ∧ x ∈ B ) ↔ ∃ x ( A ∈ x ∧ x ∈ B ) ) ) ;;
	step 8 : wff = df-uni () |- ⋃ B = { y | ∃ x ( y ∈ x ∧ x ∈ B ) } ;;
	step 9 : wff = elab2g (step 7, step 8) |- ( A ∈ _V → ( A ∈ ⋃ B ↔ ∃ x ( A ∈ x ∧ x ∈ B ) ) ) ;;
	step 10 : wff = pm5.21nii (step 1, step 4, step 9) |- ( A ∈ ⋃ B ↔ ∃ x ( A ∈ x ∧ x ∈ B ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Membership in class union.  Restricted quantifier version.  (Contributed
       by NM, 31-Aug-1999.) */

theorem eluni2 (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∈ ⋃ B ↔ ∃ x ∈ B A ∈ x ) ;;
}

proof of eluni2 {
	step 1 : wff = exancom () |- ( ∃ x ( A ∈ x ∧ x ∈ B ) ↔ ∃ x ( x ∈ B ∧ A ∈ x ) ) ;;
	step 2 : wff = eluni () |- ( A ∈ ⋃ B ↔ ∃ x ( A ∈ x ∧ x ∈ B ) ) ;;
	step 3 : wff = df-rex () |- ( ∃ x ∈ B A ∈ x ↔ ∃ x ( x ∈ B ∧ A ∈ x ) ) ;;
	step 4 : wff = 3bitr4i (step 1, step 2, step 3) |- ( A ∈ ⋃ B ↔ ∃ x ∈ B A ∈ x ) ;;
	qed prop 1 = step 4 ;;
}

/*Membership in class union.  (Contributed by NM, 24-Mar-1995.) */

theorem elunii (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( ( A ∈ B ∧ B ∈ C ) → A ∈ ⋃ C ) ;;
}

proof of elunii {
	var x : set;;
	step 1 : wff = eleq2 () |- ( x = B → ( A ∈ x ↔ A ∈ B ) ) ;;
	step 2 : wff = eleq1 () |- ( x = B → ( x ∈ C ↔ B ∈ C ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( x = B → ( ( A ∈ x ∧ x ∈ C ) ↔ ( A ∈ B ∧ B ∈ C ) ) ) ;;
	step 4 : wff = spcegv (step 3) |- ( B ∈ C → ( ( A ∈ B ∧ B ∈ C ) → ∃ x ( A ∈ x ∧ x ∈ C ) ) ) ;;
	step 5 : wff = anabsi7 (step 4) |- ( ( A ∈ B ∧ B ∈ C ) → ∃ x ( A ∈ x ∧ x ∈ C ) ) ;;
	step 6 : wff = eluni () |- ( A ∈ ⋃ C ↔ ∃ x ( A ∈ x ∧ x ∈ C ) ) ;;
	step 7 : wff = sylibr (step 5, step 6) |- ( ( A ∈ B ∧ B ∈ C ) → A ∈ ⋃ C ) ;;
	qed prop 1 = step 7 ;;
}

/*Bound-variable hypothesis builder for union.  (Contributed by NM,
       30-Dec-1996.)  (Proof shortened by Andrew Salmon, 27-Aug-2011.) */

theorem nfuni (x : set, A : class) disjointed(y z A, x y z) {
	hyp 1 : wff = |- F/_ x A ;;
	-----------------------
	prop 1 : wff = |- F/_ x ⋃ A ;;
}

proof of nfuni {
	var y : set, z : set;;
	step 1 : wff = dfuni2 () |- ⋃ A = { y | ∃ z ∈ A y ∈ z } ;;
	step 2 : wff = nfv () |- F/ x y ∈ z ;;
	step 3 : wff = nfrex (hyp 1, step 2) |- F/ x ∃ z ∈ A y ∈ z ;;
	step 4 : wff = nfab (step 3) |- F/_ x { y | ∃ z ∈ A y ∈ z } ;;
	step 5 : wff = nfcxfr (step 1, step 4) |- F/_ x ⋃ A ;;
	qed prop 1 = step 5 ;;
}

/*Deduction version of ~ nfuni .  (Contributed by NM, 18-Feb-2013.) */

theorem nfunid (ph : wff, x : set, A : class) disjointed(y z A, x y z, y z ph) {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/_ x ⋃ A ) ;;
}

proof of nfunid {
	var y : set, z : set;;
	step 1 : wff = dfuni2 () |- ⋃ A = { y | ∃ z ∈ A y ∈ z } ;;
	step 2 : wff = nfv () |- F/ y ph ;;
	step 3 : wff = nfv () |- F/ z ph ;;
	step 4 : wff = nfvd () |- ( ph → F/ x y ∈ z ) ;;
	step 5 : wff = nfrexd (step 3, hyp 1, step 4) |- ( ph → F/ x ∃ z ∈ A y ∈ z ) ;;
	step 6 : wff = nfabd (step 2, step 5) |- ( ph → F/_ x { y | ∃ z ∈ A y ∈ z } ) ;;
	step 7 : wff = nfcxfrd (step 1, step 6) |- ( ph → F/_ x ⋃ A ) ;;
	qed prop 1 = step 7 ;;
}

/*Distribute proper substitution through the union of a class.
       (Contributed by Alan Sare, 10-Nov-2012.) */

theorem csbunig (x : set, A : class, B : class, V : class) disjointed(A y z, B y z, V y z, x y z) {
	prop 1 : wff = |- ( A ∈ V → [_ A / x ]_ ⋃ B = ⋃ [_ A / x ]_ B ) ;;
}

proof of csbunig {
	var y : set, z : set;;
	step 1 : wff = csbabg () |- ( A ∈ V → [_ A / x ]_ { z | ∃ y ( z ∈ y ∧ y ∈ B ) } = { z | [. A / x ]. ∃ y ( z ∈ y ∧ y ∈ B ) } ) ;;
	step 2 : wff = sbcexg () |- ( A ∈ V → ( [. A / x ]. ∃ y ( z ∈ y ∧ y ∈ B ) ↔ ∃ y [. A / x ]. ( z ∈ y ∧ y ∈ B ) ) ) ;;
	step 3 : wff = sbcang () |- ( A ∈ V → ( [. A / x ]. ( z ∈ y ∧ y ∈ B ) ↔ ( [. A / x ]. z ∈ y ∧ [. A / x ]. y ∈ B ) ) ) ;;
	step 4 : wff = sbcg () |- ( A ∈ V → ( [. A / x ]. z ∈ y ↔ z ∈ y ) ) ;;
	step 5 : wff = sbcel2g () |- ( A ∈ V → ( [. A / x ]. y ∈ B ↔ y ∈ [_ A / x ]_ B ) ) ;;
	step 6 : wff = anbi12d (step 4, step 5) |- ( A ∈ V → ( ( [. A / x ]. z ∈ y ∧ [. A / x ]. y ∈ B ) ↔ ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) ) ) ;;
	step 7 : wff = bitrd (step 3, step 6) |- ( A ∈ V → ( [. A / x ]. ( z ∈ y ∧ y ∈ B ) ↔ ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) ) ) ;;
	step 8 : wff = exbidv (step 7) |- ( A ∈ V → ( ∃ y [. A / x ]. ( z ∈ y ∧ y ∈ B ) ↔ ∃ y ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) ) ) ;;
	step 9 : wff = bitrd (step 2, step 8) |- ( A ∈ V → ( [. A / x ]. ∃ y ( z ∈ y ∧ y ∈ B ) ↔ ∃ y ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) ) ) ;;
	step 10 : wff = abbidv (step 9) |- ( A ∈ V → { z | [. A / x ]. ∃ y ( z ∈ y ∧ y ∈ B ) } = { z | ∃ y ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) } ) ;;
	step 11 : wff = eqtrd (step 1, step 10) |- ( A ∈ V → [_ A / x ]_ { z | ∃ y ( z ∈ y ∧ y ∈ B ) } = { z | ∃ y ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) } ) ;;
	step 12 : wff = df-uni () |- ⋃ B = { z | ∃ y ( z ∈ y ∧ y ∈ B ) } ;;
	step 13 : wff = csbeq2i (step 12) |- [_ A / x ]_ ⋃ B = [_ A / x ]_ { z | ∃ y ( z ∈ y ∧ y ∈ B ) } ;;
	step 14 : wff = df-uni () |- ⋃ [_ A / x ]_ B = { z | ∃ y ( z ∈ y ∧ y ∈ [_ A / x ]_ B ) } ;;
	step 15 : wff = 3eqtr4g (step 11, step 13, step 14) |- ( A ∈ V → [_ A / x ]_ ⋃ B = ⋃ [_ A / x ]_ B ) ;;
	qed prop 1 = step 15 ;;
}

/*Equality theorem for class union.  Exercise 15 of [TakeutiZaring]
       p. 18.  (Contributed by NM, 10-Aug-1993.)  (Proof shortened by Andrew
       Salmon, 29-Jun-2011.) */

theorem unieq (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A = B → ⋃ A = ⋃ B ) ;;
}

proof of unieq {
	var x : set, y : set;;
	step 1 : wff = rexeq () |- ( A = B → ( ∃ x ∈ A y ∈ x ↔ ∃ x ∈ B y ∈ x ) ) ;;
	step 2 : wff = abbidv (step 1) |- ( A = B → { y | ∃ x ∈ A y ∈ x } = { y | ∃ x ∈ B y ∈ x } ) ;;
	step 3 : wff = dfuni2 () |- ⋃ A = { y | ∃ x ∈ A y ∈ x } ;;
	step 4 : wff = dfuni2 () |- ⋃ B = { y | ∃ x ∈ B y ∈ x } ;;
	step 5 : wff = 3eqtr4g (step 2, step 3, step 4) |- ( A = B → ⋃ A = ⋃ B ) ;;
	qed prop 1 = step 5 ;;
}

/*Inference of equality of two class unions.  (Contributed by NM,
       30-Aug-1993.) */

theorem unieqi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ⋃ A = ⋃ B ;;
}

proof of unieqi {
	step 1 : wff = unieq () |- ( A = B → ⋃ A = ⋃ B ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ⋃ A = ⋃ B ;;
	qed prop 1 = step 2 ;;
}

/*Deduction of equality of two class unions.  (Contributed by NM,
       21-Apr-1995.) */

theorem unieqd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ⋃ A = ⋃ B ) ;;
}

proof of unieqd {
	step 1 : wff = unieq () |- ( A = B → ⋃ A = ⋃ B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ⋃ A = ⋃ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Membership in union of a class abstraction.  (Contributed by NM,
       11-Aug-1994.)  (Revised by Mario Carneiro, 14-Nov-2016.) */

theorem eluniab (ph : wff, x : set, A : class) disjointed(x A y, ph y) {
	prop 1 : wff = |- ( A ∈ ⋃ { x | ph } ↔ ∃ x ( A ∈ x ∧ ph ) ) ;;
}

proof of eluniab {
	var y : set;;
	step 1 : wff = eluni () |- ( A ∈ ⋃ { x | ph } ↔ ∃ y ( A ∈ y ∧ y ∈ { x | ph } ) ) ;;
	step 2 : wff = nfv () |- F/ x A ∈ y ;;
	step 3 : wff = nfsab1 () |- F/ x y ∈ { x | ph } ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ x ( A ∈ y ∧ y ∈ { x | ph } ) ;;
	step 5 : wff = nfv () |- F/ y ( A ∈ x ∧ ph ) ;;
	step 6 : wff = eleq2 () |- ( y = x → ( A ∈ y ↔ A ∈ x ) ) ;;
	step 7 : wff = eleq1 () |- ( y = x → ( y ∈ { x | ph } ↔ x ∈ { x | ph } ) ) ;;
	step 8 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 9 : wff = syl6bb (step 7, step 8) |- ( y = x → ( y ∈ { x | ph } ↔ ph ) ) ;;
	step 10 : wff = anbi12d (step 6, step 9) |- ( y = x → ( ( A ∈ y ∧ y ∈ { x | ph } ) ↔ ( A ∈ x ∧ ph ) ) ) ;;
	step 11 : wff = cbvex (step 4, step 5, step 10) |- ( ∃ y ( A ∈ y ∧ y ∈ { x | ph } ) ↔ ∃ x ( A ∈ x ∧ ph ) ) ;;
	step 12 : wff = bitri (step 1, step 11) |- ( A ∈ ⋃ { x | ph } ↔ ∃ x ( A ∈ x ∧ ph ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Membership in union of a class abstraction.  (Contributed by NM,
       4-Oct-2006.) */

theorem elunirab (ph : wff, x : set, A : class, B : class) disjointed(x A, ph) {
	prop 1 : wff = |- ( A ∈ ⋃ { x ∈ B | ph } ↔ ∃ x ∈ B ( A ∈ x ∧ ph ) ) ;;
}

proof of elunirab {
	step 1 : wff = eluniab () |- ( A ∈ ⋃ { x | ( x ∈ B ∧ ph ) } ↔ ∃ x ( A ∈ x ∧ ( x ∈ B ∧ ph ) ) ) ;;
	step 2 : wff = df-rab () |- { x ∈ B | ph } = { x | ( x ∈ B ∧ ph ) } ;;
	step 3 : wff = unieqi (step 2) |- ⋃ { x ∈ B | ph } = ⋃ { x | ( x ∈ B ∧ ph ) } ;;
	step 4 : wff = eleq2i (step 3) |- ( A ∈ ⋃ { x ∈ B | ph } ↔ A ∈ ⋃ { x | ( x ∈ B ∧ ph ) } ) ;;
	step 5 : wff = df-rex () |- ( ∃ x ∈ B ( A ∈ x ∧ ph ) ↔ ∃ x ( x ∈ B ∧ ( A ∈ x ∧ ph ) ) ) ;;
	step 6 : wff = an12 () |- ( ( x ∈ B ∧ ( A ∈ x ∧ ph ) ) ↔ ( A ∈ x ∧ ( x ∈ B ∧ ph ) ) ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ x ( x ∈ B ∧ ( A ∈ x ∧ ph ) ) ↔ ∃ x ( A ∈ x ∧ ( x ∈ B ∧ ph ) ) ) ;;
	step 8 : wff = bitri (step 5, step 7) |- ( ∃ x ∈ B ( A ∈ x ∧ ph ) ↔ ∃ x ( A ∈ x ∧ ( x ∈ B ∧ ph ) ) ) ;;
	step 9 : wff = 3bitr4i (step 1, step 4, step 8) |- ( A ∈ ⋃ { x ∈ B | ph } ↔ ∃ x ∈ B ( A ∈ x ∧ ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/*The union of a pair is the union of its members.  Proposition 5.7 of
       [TakeutiZaring] p. 16.  (Contributed by NM, 23-Aug-1993.) */

theorem unipr (A : class, B : class) disjointed(x y A, x y B) {
	hyp 1 : wff = |- A ∈ _V ;;
	hyp 2 : wff = |- B ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋃ { A , B } = ( A ∪ B ) ;;
}

proof of unipr {
	var x : set, y : set;;
	step 1 : wff = 19.43 () |- ( ∃ y ( ( x ∈ y ∧ y = A ) ∨ ( x ∈ y ∧ y = B ) ) ↔ ( ∃ y ( x ∈ y ∧ y = A ) ∨ ∃ y ( x ∈ y ∧ y = B ) ) ) ;;
	step 2 : wff = vex () |- y ∈ _V ;;
	step 3 : wff = elpr (step 2) |- ( y ∈ { A , B } ↔ ( y = A ∨ y = B ) ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( x ∈ y ∧ y ∈ { A , B } ) ↔ ( x ∈ y ∧ ( y = A ∨ y = B ) ) ) ;;
	step 5 : wff = andi () |- ( ( x ∈ y ∧ ( y = A ∨ y = B ) ) ↔ ( ( x ∈ y ∧ y = A ) ∨ ( x ∈ y ∧ y = B ) ) ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( ( x ∈ y ∧ y ∈ { A , B } ) ↔ ( ( x ∈ y ∧ y = A ) ∨ ( x ∈ y ∧ y = B ) ) ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ y ( x ∈ y ∧ y ∈ { A , B } ) ↔ ∃ y ( ( x ∈ y ∧ y = A ) ∨ ( x ∈ y ∧ y = B ) ) ) ;;
	step 8 : wff = clel3 (hyp 1) |- ( x ∈ A ↔ ∃ y ( y = A ∧ x ∈ y ) ) ;;
	step 9 : wff = exancom () |- ( ∃ y ( y = A ∧ x ∈ y ) ↔ ∃ y ( x ∈ y ∧ y = A ) ) ;;
	step 10 : wff = bitri (step 8, step 9) |- ( x ∈ A ↔ ∃ y ( x ∈ y ∧ y = A ) ) ;;
	step 11 : wff = clel3 (hyp 2) |- ( x ∈ B ↔ ∃ y ( y = B ∧ x ∈ y ) ) ;;
	step 12 : wff = exancom () |- ( ∃ y ( y = B ∧ x ∈ y ) ↔ ∃ y ( x ∈ y ∧ y = B ) ) ;;
	step 13 : wff = bitri (step 11, step 12) |- ( x ∈ B ↔ ∃ y ( x ∈ y ∧ y = B ) ) ;;
	step 14 : wff = orbi12i (step 10, step 13) |- ( ( x ∈ A ∨ x ∈ B ) ↔ ( ∃ y ( x ∈ y ∧ y = A ) ∨ ∃ y ( x ∈ y ∧ y = B ) ) ) ;;
	step 15 : wff = 3bitr4ri (step 1, step 7, step 14) |- ( ( x ∈ A ∨ x ∈ B ) ↔ ∃ y ( x ∈ y ∧ y ∈ { A , B } ) ) ;;
	step 16 : wff = abbii (step 15) |- { x | ( x ∈ A ∨ x ∈ B ) } = { x | ∃ y ( x ∈ y ∧ y ∈ { A , B } ) } ;;
	step 17 : wff = df-un () |- ( A ∪ B ) = { x | ( x ∈ A ∨ x ∈ B ) } ;;
	step 18 : wff = df-uni () |- ⋃ { A , B } = { x | ∃ y ( x ∈ y ∧ y ∈ { A , B } ) } ;;
	step 19 : wff = 3eqtr4ri (step 16, step 17, step 18) |- ⋃ { A , B } = ( A ∪ B ) ;;
	qed prop 1 = step 19 ;;
}

/*The union of a pair is the union of its members.  Proposition 5.7 of
       [TakeutiZaring] p. 16.  (Contributed by NM, 25-Aug-2006.) */

theorem uniprg (A : class, B : class, V : class, W : class) disjointed(x y A, y B) {
	prop 1 : wff = |- ( ( A ∈ V ∧ B ∈ W ) → ⋃ { A , B } = ( A ∪ B ) ) ;;
}

proof of uniprg {
	var x : set, y : set;;
	step 1 : wff = preq1 () |- ( x = A → { x , y } = { A , y } ) ;;
	step 2 : wff = unieqd (step 1) |- ( x = A → ⋃ { x , y } = ⋃ { A , y } ) ;;
	step 3 : wff = uneq1 () |- ( x = A → ( x ∪ y ) = ( A ∪ y ) ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( x = A → ( ⋃ { x , y } = ( x ∪ y ) ↔ ⋃ { A , y } = ( A ∪ y ) ) ) ;;
	step 5 : wff = preq2 () |- ( y = B → { A , y } = { A , B } ) ;;
	step 6 : wff = unieqd (step 5) |- ( y = B → ⋃ { A , y } = ⋃ { A , B } ) ;;
	step 7 : wff = uneq2 () |- ( y = B → ( A ∪ y ) = ( A ∪ B ) ) ;;
	step 8 : wff = eqeq12d (step 6, step 7) |- ( y = B → ( ⋃ { A , y } = ( A ∪ y ) ↔ ⋃ { A , B } = ( A ∪ B ) ) ) ;;
	step 9 : wff = vex () |- x ∈ _V ;;
	step 10 : wff = vex () |- y ∈ _V ;;
	step 11 : wff = unipr (step 9, step 10) |- ⋃ { x , y } = ( x ∪ y ) ;;
	step 12 : wff = vtocl2g (step 4, step 8, step 11) |- ( ( A ∈ V ∧ B ∈ W ) → ⋃ { A , B } = ( A ∪ B ) ) ;;
	qed prop 1 = step 12 ;;
}

/*A set equals the union of its singleton.  Theorem 8.2 of [Quine] p. 53.
       (Contributed by NM, 30-Aug-1993.) */

theorem unisn (A : class)  {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ⋃ { A } = A ;;
}

proof of unisn {
	step 1 : wff = dfsn2 () |- { A } = { A , A } ;;
	step 2 : wff = unieqi (step 1) |- ⋃ { A } = ⋃ { A , A } ;;
	step 3 : wff = unipr (hyp 1, hyp 1) |- ⋃ { A , A } = ( A ∪ A ) ;;
	step 4 : wff = unidm () |- ( A ∪ A ) = A ;;
	step 5 : wff = 3eqtri (step 2, step 3, step 4) |- ⋃ { A } = A ;;
	qed prop 1 = step 5 ;;
}

/*A set equals the union of its singleton.  Theorem 8.2 of [Quine] p. 53.
       (Contributed by NM, 13-Aug-2002.) */

theorem unisng (A : class, V : class) disjointed(x A) {
	prop 1 : wff = |- ( A ∈ V → ⋃ { A } = A ) ;;
}

proof of unisng {
	var x : set;;
	step 1 : wff = sneq () |- ( x = A → { x } = { A } ) ;;
	step 2 : wff = unieqd (step 1) |- ( x = A → ⋃ { x } = ⋃ { A } ) ;;
	step 3 : wff = id () |- ( x = A → x = A ) ;;
	step 4 : wff = eqeq12d (step 2, step 3) |- ( x = A → ( ⋃ { x } = x ↔ ⋃ { A } = A ) ) ;;
	step 5 : wff = vex () |- x ∈ _V ;;
	step 6 : wff = unisn (step 5) |- ⋃ { x } = x ;;
	step 7 : wff = vtoclg (step 4, step 6) |- ( A ∈ V → ⋃ { A } = A ) ;;
	qed prop 1 = step 7 ;;
}

/*An alternative statement of the effective freeness of a class ` A ` ,
       when it is a set.  (Contributed by Mario Carneiro, 14-Oct-2016.) */

theorem dfnfc2 (x : set, y : set, A : class, V : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( ∀ x A ∈ V → ( F/_ x A ↔ ∀ y F/ x y = A ) ) ;;
}

proof of dfnfc2 {
	step 1 : wff = nfcvd () |- ( F/_ x A → F/_ x y ) ;;
	step 2 : wff = id () |- ( F/_ x A → F/_ x A ) ;;
	step 3 : wff = nfeqd (step 1, step 2) |- ( F/_ x A → F/ x y = A ) ;;
	step 4 : wff = alrimiv (step 3) |- ( F/_ x A → ∀ y F/ x y = A ) ;;
	step 5 : wff = simpr () |- ( ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) → ∀ y F/ x y = A ) ;;
	step 6 : wff = df-nfc () |- ( F/_ x { A } ↔ ∀ y F/ x y ∈ { A } ) ;;
	step 7 : wff = elsn () |- ( y ∈ { A } ↔ y = A ) ;;
	step 8 : wff = nfbii (step 7) |- ( F/ x y ∈ { A } ↔ F/ x y = A ) ;;
	step 9 : wff = albii (step 8) |- ( ∀ y F/ x y ∈ { A } ↔ ∀ y F/ x y = A ) ;;
	step 10 : wff = bitri (step 6, step 9) |- ( F/_ x { A } ↔ ∀ y F/ x y = A ) ;;
	step 11 : wff = sylibr (step 5, step 10) |- ( ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) → F/_ x { A } ) ;;
	step 12 : wff = nfunid (step 11) |- ( ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) → F/_ x ⋃ { A } ) ;;
	step 13 : wff = nfa1 () |- F/ x ∀ x A ∈ V ;;
	step 14 : wff = nfnf1 () |- F/ x F/ x y = A ;;
	step 15 : wff = nfal (step 14) |- F/ x ∀ y F/ x y = A ;;
	step 16 : wff = nfan (step 13, step 15) |- F/ x ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) ;;
	step 17 : wff = unisng () |- ( A ∈ V → ⋃ { A } = A ) ;;
	step 18 : wff = sps (step 17) |- ( ∀ x A ∈ V → ⋃ { A } = A ) ;;
	step 19 : wff = adantr (step 18) |- ( ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) → ⋃ { A } = A ) ;;
	step 20 : wff = nfceqdf (step 16, step 19) |- ( ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) → ( F/_ x ⋃ { A } ↔ F/_ x A ) ) ;;
	step 21 : wff = mpbid (step 12, step 20) |- ( ( ∀ x A ∈ V ∧ ∀ y F/ x y = A ) → F/_ x A ) ;;
	step 22 : wff = ex (step 21) |- ( ∀ x A ∈ V → ( ∀ y F/ x y = A → F/_ x A ) ) ;;
	step 23 : wff = impbid2 (step 4, step 22) |- ( ∀ x A ∈ V → ( F/_ x A ↔ ∀ y F/ x y = A ) ) ;;
	qed prop 1 = step 23 ;;
}

/*The class union of the union of two classes.  Theorem 8.3 of [Quine]
       p. 53.  (Contributed by NM, 20-Aug-1993.) */

theorem uniun (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⋃ ( A ∪ B ) = ( ⋃ A ∪ ⋃ B ) ;;
}

proof of uniun {
	var x : set, y : set;;
	step 1 : wff = 19.43 () |- ( ∃ y ( ( x ∈ y ∧ y ∈ A ) ∨ ( x ∈ y ∧ y ∈ B ) ) ↔ ( ∃ y ( x ∈ y ∧ y ∈ A ) ∨ ∃ y ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 2 : wff = elun () |- ( y ∈ ( A ∪ B ) ↔ ( y ∈ A ∨ y ∈ B ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( x ∈ y ∧ y ∈ ( A ∪ B ) ) ↔ ( x ∈ y ∧ ( y ∈ A ∨ y ∈ B ) ) ) ;;
	step 4 : wff = andi () |- ( ( x ∈ y ∧ ( y ∈ A ∨ y ∈ B ) ) ↔ ( ( x ∈ y ∧ y ∈ A ) ∨ ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ( x ∈ y ∧ y ∈ ( A ∪ B ) ) ↔ ( ( x ∈ y ∧ y ∈ A ) ∨ ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ( x ∈ y ∧ y ∈ ( A ∪ B ) ) ↔ ∃ y ( ( x ∈ y ∧ y ∈ A ) ∨ ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 7 : wff = eluni () |- ( x ∈ ⋃ A ↔ ∃ y ( x ∈ y ∧ y ∈ A ) ) ;;
	step 8 : wff = eluni () |- ( x ∈ ⋃ B ↔ ∃ y ( x ∈ y ∧ y ∈ B ) ) ;;
	step 9 : wff = orbi12i (step 7, step 8) |- ( ( x ∈ ⋃ A ∨ x ∈ ⋃ B ) ↔ ( ∃ y ( x ∈ y ∧ y ∈ A ) ∨ ∃ y ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 10 : wff = 3bitr4i (step 1, step 6, step 9) |- ( ∃ y ( x ∈ y ∧ y ∈ ( A ∪ B ) ) ↔ ( x ∈ ⋃ A ∨ x ∈ ⋃ B ) ) ;;
	step 11 : wff = eluni () |- ( x ∈ ⋃ ( A ∪ B ) ↔ ∃ y ( x ∈ y ∧ y ∈ ( A ∪ B ) ) ) ;;
	step 12 : wff = elun () |- ( x ∈ ( ⋃ A ∪ ⋃ B ) ↔ ( x ∈ ⋃ A ∨ x ∈ ⋃ B ) ) ;;
	step 13 : wff = 3bitr4i (step 10, step 11, step 12) |- ( x ∈ ⋃ ( A ∪ B ) ↔ x ∈ ( ⋃ A ∪ ⋃ B ) ) ;;
	step 14 : wff = eqriv (step 13) |- ⋃ ( A ∪ B ) = ( ⋃ A ∪ ⋃ B ) ;;
	qed prop 1 = step 14 ;;
}

/*The class union of the intersection of two classes.  Exercise 4.12(n) of
       [Mendelson] p. 235.  See ~ uninqs for a condition where equality holds.
       (Contributed by NM, 4-Dec-2003.)  (Proof shortened by Andrew Salmon,
       29-Jun-2011.) */

theorem uniin (A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ⋃ ( A ∩ B ) ⊆ ( ⋃ A ∩ ⋃ B ) ;;
}

proof of uniin {
	var x : set, y : set;;
	step 1 : wff = 19.40 () |- ( ∃ y ( ( x ∈ y ∧ y ∈ A ) ∧ ( x ∈ y ∧ y ∈ B ) ) → ( ∃ y ( x ∈ y ∧ y ∈ A ) ∧ ∃ y ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 2 : wff = elin () |- ( y ∈ ( A ∩ B ) ↔ ( y ∈ A ∧ y ∈ B ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( x ∈ y ∧ y ∈ ( A ∩ B ) ) ↔ ( x ∈ y ∧ ( y ∈ A ∧ y ∈ B ) ) ) ;;
	step 4 : wff = anandi () |- ( ( x ∈ y ∧ ( y ∈ A ∧ y ∈ B ) ) ↔ ( ( x ∈ y ∧ y ∈ A ) ∧ ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ( x ∈ y ∧ y ∈ ( A ∩ B ) ) ↔ ( ( x ∈ y ∧ y ∈ A ) ∧ ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ y ( x ∈ y ∧ y ∈ ( A ∩ B ) ) ↔ ∃ y ( ( x ∈ y ∧ y ∈ A ) ∧ ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 7 : wff = eluni () |- ( x ∈ ⋃ A ↔ ∃ y ( x ∈ y ∧ y ∈ A ) ) ;;
	step 8 : wff = eluni () |- ( x ∈ ⋃ B ↔ ∃ y ( x ∈ y ∧ y ∈ B ) ) ;;
	step 9 : wff = anbi12i (step 7, step 8) |- ( ( x ∈ ⋃ A ∧ x ∈ ⋃ B ) ↔ ( ∃ y ( x ∈ y ∧ y ∈ A ) ∧ ∃ y ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 10 : wff = 3imtr4i (step 1, step 6, step 9) |- ( ∃ y ( x ∈ y ∧ y ∈ ( A ∩ B ) ) → ( x ∈ ⋃ A ∧ x ∈ ⋃ B ) ) ;;
	step 11 : wff = eluni () |- ( x ∈ ⋃ ( A ∩ B ) ↔ ∃ y ( x ∈ y ∧ y ∈ ( A ∩ B ) ) ) ;;
	step 12 : wff = elin () |- ( x ∈ ( ⋃ A ∩ ⋃ B ) ↔ ( x ∈ ⋃ A ∧ x ∈ ⋃ B ) ) ;;
	step 13 : wff = 3imtr4i (step 10, step 11, step 12) |- ( x ∈ ⋃ ( A ∩ B ) → x ∈ ( ⋃ A ∩ ⋃ B ) ) ;;
	step 14 : wff = ssriv (step 13) |- ⋃ ( A ∩ B ) ⊆ ( ⋃ A ∩ ⋃ B ) ;;
	qed prop 1 = step 14 ;;
}

/*Subclass relationship for class union.  Theorem 61 of [Suppes] p. 39.
       (Contributed by NM, 22-Mar-1998.)  (Proof shortened by Andrew Salmon,
       29-Jun-2011.) */

theorem uniss (A : class, B : class) disjointed(x y A, x y B, x y) {
	prop 1 : wff = |- ( A ⊆ B → ⋃ A ⊆ ⋃ B ) ;;
}

proof of uniss {
	var x : set, y : set;;
	step 1 : wff = ssel () |- ( A ⊆ B → ( y ∈ A → y ∈ B ) ) ;;
	step 2 : wff = anim2d (step 1) |- ( A ⊆ B → ( ( x ∈ y ∧ y ∈ A ) → ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 3 : wff = eximdv (step 2) |- ( A ⊆ B → ( ∃ y ( x ∈ y ∧ y ∈ A ) → ∃ y ( x ∈ y ∧ y ∈ B ) ) ) ;;
	step 4 : wff = eluni () |- ( x ∈ ⋃ A ↔ ∃ y ( x ∈ y ∧ y ∈ A ) ) ;;
	step 5 : wff = eluni () |- ( x ∈ ⋃ B ↔ ∃ y ( x ∈ y ∧ y ∈ B ) ) ;;
	step 6 : wff = 3imtr4g (step 3, step 4, step 5) |- ( A ⊆ B → ( x ∈ ⋃ A → x ∈ ⋃ B ) ) ;;
	step 7 : wff = ssrdv (step 6) |- ( A ⊆ B → ⋃ A ⊆ ⋃ B ) ;;
	qed prop 1 = step 7 ;;
}

/*Subclass relationship for class union.  (Contributed by NM,
       24-May-1994.)  (Proof shortened by Andrew Salmon, 29-Jun-2011.) */

theorem ssuni (A : class, B : class, C : class) disjointed(x y A, x y B, x y C) {
	prop 1 : wff = |- ( ( A ⊆ B ∧ B ∈ C ) → A ⊆ ⋃ C ) ;;
}

proof of ssuni {
	var x : set, y : set;;
	step 1 : wff = eleq2 () |- ( x = B → ( y ∈ x ↔ y ∈ B ) ) ;;
	step 2 : wff = imbi1d (step 1) |- ( x = B → ( ( y ∈ x → y ∈ ⋃ C ) ↔ ( y ∈ B → y ∈ ⋃ C ) ) ) ;;
	step 3 : wff = elunii () |- ( ( y ∈ x ∧ x ∈ C ) → y ∈ ⋃ C ) ;;
	step 4 : wff = expcom (step 3) |- ( x ∈ C → ( y ∈ x → y ∈ ⋃ C ) ) ;;
	step 5 : wff = vtoclga (step 2, step 4) |- ( B ∈ C → ( y ∈ B → y ∈ ⋃ C ) ) ;;
	step 6 : wff = imim2d (step 5) |- ( B ∈ C → ( ( y ∈ A → y ∈ B ) → ( y ∈ A → y ∈ ⋃ C ) ) ) ;;
	step 7 : wff = alimdv (step 6) |- ( B ∈ C → ( ∀ y ( y ∈ A → y ∈ B ) → ∀ y ( y ∈ A → y ∈ ⋃ C ) ) ) ;;
	step 8 : wff = dfss2 () |- ( A ⊆ B ↔ ∀ y ( y ∈ A → y ∈ B ) ) ;;
	step 9 : wff = dfss2 () |- ( A ⊆ ⋃ C ↔ ∀ y ( y ∈ A → y ∈ ⋃ C ) ) ;;
	step 10 : wff = 3imtr4g (step 7, step 8, step 9) |- ( B ∈ C → ( A ⊆ B → A ⊆ ⋃ C ) ) ;;
	step 11 : wff = impcom (step 10) |- ( ( A ⊆ B ∧ B ∈ C ) → A ⊆ ⋃ C ) ;;
	qed prop 1 = step 11 ;;
}

/*Subclass relationship for subclass union.  Inference form of ~ uniss .
       (Contributed by David Moews, 1-May-2017.) */

theorem unissi (A : class, B : class)  {
	hyp 1 : wff = |- A ⊆ B ;;
	-----------------------
	prop 1 : wff = |- ⋃ A ⊆ ⋃ B ;;
}

proof of unissi {
	step 1 : wff = uniss () |- ( A ⊆ B → ⋃ A ⊆ ⋃ B ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ⋃ A ⊆ ⋃ B ;;
	qed prop 1 = step 2 ;;
}

/*Subclass relationship for subclass union.  Deduction form of ~ uniss .
       (Contributed by David Moews, 1-May-2017.) */

theorem unissd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A ⊆ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ⋃ A ⊆ ⋃ B ) ;;
}

proof of unissd {
	step 1 : wff = uniss () |- ( A ⊆ B → ⋃ A ⊆ ⋃ B ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ⋃ A ⊆ ⋃ B ) ;;
	qed prop 1 = step 2 ;;
}

/*The union of a set is empty iff the set is included in the singleton of
       the empty set.  (Contributed by NM, 12-Sep-2004.) */

theorem uni0b (A : class) disjointed(x y A) {
	prop 1 : wff = |- ( ⋃ A = ∅ ↔ A ⊆ { ∅ } ) ;;
}

proof of uni0b {
	var x : set, y : set;;
	step 1 : wff = elsn () |- ( x ∈ { ∅ } ↔ x = ∅ ) ;;
	step 2 : wff = ralbii (step 1) |- ( ∀ x ∈ A x ∈ { ∅ } ↔ ∀ x ∈ A x = ∅ ) ;;
	step 3 : wff = dfss3 () |- ( A ⊆ { ∅ } ↔ ∀ x ∈ A x ∈ { ∅ } ) ;;
	step 4 : wff = neq0 () |- ( ¬ ⋃ A = ∅ ↔ ∃ y y ∈ ⋃ A ) ;;
	step 5 : wff = rexcom4 () |- ( ∃ x ∈ A ∃ y y ∈ x ↔ ∃ y ∃ x ∈ A y ∈ x ) ;;
	step 6 : wff = neq0 () |- ( ¬ x = ∅ ↔ ∃ y y ∈ x ) ;;
	step 7 : wff = rexbii (step 6) |- ( ∃ x ∈ A ¬ x = ∅ ↔ ∃ x ∈ A ∃ y y ∈ x ) ;;
	step 8 : wff = eluni2 () |- ( y ∈ ⋃ A ↔ ∃ x ∈ A y ∈ x ) ;;
	step 9 : wff = exbii (step 8) |- ( ∃ y y ∈ ⋃ A ↔ ∃ y ∃ x ∈ A y ∈ x ) ;;
	step 10 : wff = 3bitr4ri (step 5, step 7, step 9) |- ( ∃ y y ∈ ⋃ A ↔ ∃ x ∈ A ¬ x = ∅ ) ;;
	step 11 : wff = rexnal () |- ( ∃ x ∈ A ¬ x = ∅ ↔ ¬ ∀ x ∈ A x = ∅ ) ;;
	step 12 : wff = 3bitri (step 4, step 10, step 11) |- ( ¬ ⋃ A = ∅ ↔ ¬ ∀ x ∈ A x = ∅ ) ;;
	step 13 : wff = con4bii (step 12) |- ( ⋃ A = ∅ ↔ ∀ x ∈ A x = ∅ ) ;;
	step 14 : wff = 3bitr4ri (step 2, step 3, step 13) |- ( ⋃ A = ∅ ↔ A ⊆ { ∅ } ) ;;
	qed prop 1 = step 14 ;;
}

/*The union of a set is empty iff all of its members are empty.
       (Contributed by NM, 16-Aug-2006.) */

theorem uni0c (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- ( ⋃ A = ∅ ↔ ∀ x ∈ A x = ∅ ) ;;
}

proof of uni0c {
	step 1 : wff = uni0b () |- ( ⋃ A = ∅ ↔ A ⊆ { ∅ } ) ;;
	step 2 : wff = dfss3 () |- ( A ⊆ { ∅ } ↔ ∀ x ∈ A x ∈ { ∅ } ) ;;
	step 3 : wff = elsn () |- ( x ∈ { ∅ } ↔ x = ∅ ) ;;
	step 4 : wff = ralbii (step 3) |- ( ∀ x ∈ A x ∈ { ∅ } ↔ ∀ x ∈ A x = ∅ ) ;;
	step 5 : wff = 3bitri (step 1, step 2, step 4) |- ( ⋃ A = ∅ ↔ ∀ x ∈ A x = ∅ ) ;;
	qed prop 1 = step 5 ;;
}

/*The union of the empty set is the empty set.  Theorem 8.7 of [Quine]
     p. 54.  (Reproved without relying on ~ ax-nul by Eric Schmidt.)
     (Contributed by NM, 16-Sep-1993.)  (Revised by Eric Schmidt,
     4-Apr-2007.) */

theorem uni0 ()  {
	prop 1 : wff = |- ⋃ ∅ = ∅ ;;
}

proof of uni0 {
	step 1 : wff = 0ss () |- ∅ ⊆ { ∅ } ;;
	step 2 : wff = uni0b () |- ( ⋃ ∅ = ∅ ↔ ∅ ⊆ { ∅ } ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- ⋃ ∅ = ∅ ;;
	qed prop 1 = step 3 ;;
}

/*An element of a class is a subclass of its union.  Theorem 8.6 of [Quine]
     p. 54.  Also the basis for Proposition 7.20 of [TakeutiZaring] p. 40.
     (Contributed by NM, 6-Jun-1994.) */

theorem elssuni (A : class, B : class)  {
	prop 1 : wff = |- ( A ∈ B → A ⊆ ⋃ B ) ;;
}

proof of elssuni {
	step 1 : wff = ssid () |- A ⊆ A ;;
	step 2 : wff = ssuni () |- ( ( A ⊆ A ∧ A ∈ B ) → A ⊆ ⋃ B ) ;;
	step 3 : wff = mpan (step 1, step 2) |- ( A ∈ B → A ⊆ ⋃ B ) ;;
	qed prop 1 = step 3 ;;
}

/*Condition turning a subclass relationship for union into an equality.
     (Contributed by NM, 18-Jul-2006.) */

theorem unissel (A : class, B : class)  {
	prop 1 : wff = |- ( ( ⋃ A ⊆ B ∧ B ∈ A ) → ⋃ A = B ) ;;
}

proof of unissel {
	step 1 : wff = simpl () |- ( ( ⋃ A ⊆ B ∧ B ∈ A ) → ⋃ A ⊆ B ) ;;
	step 2 : wff = elssuni () |- ( B ∈ A → B ⊆ ⋃ A ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ⋃ A ⊆ B ∧ B ∈ A ) → B ⊆ ⋃ A ) ;;
	step 4 : wff = eqssd (step 1, step 3) |- ( ( ⋃ A ⊆ B ∧ B ∈ A ) → ⋃ A = B ) ;;
	qed prop 1 = step 4 ;;
}

/*Relationship involving membership, subset, and union.  Exercise 5 of
       [Enderton] p. 26 and its converse.  (Contributed by NM, 20-Sep-2003.) */

theorem unissb (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ⋃ A ⊆ B ↔ ∀ x ∈ A x ⊆ B ) ;;
}

proof of unissb {
	var y : set;;
	step 1 : wff = eluni () |- ( y ∈ ⋃ A ↔ ∃ x ( y ∈ x ∧ x ∈ A ) ) ;;
	step 2 : wff = imbi1i (step 1) |- ( ( y ∈ ⋃ A → y ∈ B ) ↔ ( ∃ x ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ) ;;
	step 3 : wff = 19.23v () |- ( ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ( ∃ x ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( ( y ∈ ⋃ A → y ∈ B ) ↔ ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ y ( y ∈ ⋃ A → y ∈ B ) ↔ ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ) ;;
	step 6 : wff = alcom () |- ( ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ∀ x ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ) ;;
	step 7 : wff = 19.21v () |- ( ∀ y ( x ∈ A → ( y ∈ x → y ∈ B ) ) ↔ ( x ∈ A → ∀ y ( y ∈ x → y ∈ B ) ) ) ;;
	step 8 : wff = impexp () |- ( ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ( y ∈ x → ( x ∈ A → y ∈ B ) ) ) ;;
	step 9 : wff = bi2.04 () |- ( ( y ∈ x → ( x ∈ A → y ∈ B ) ) ↔ ( x ∈ A → ( y ∈ x → y ∈ B ) ) ) ;;
	step 10 : wff = bitri (step 8, step 9) |- ( ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ( x ∈ A → ( y ∈ x → y ∈ B ) ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ∀ y ( x ∈ A → ( y ∈ x → y ∈ B ) ) ) ;;
	step 12 : wff = dfss2 () |- ( x ⊆ B ↔ ∀ y ( y ∈ x → y ∈ B ) ) ;;
	step 13 : wff = imbi2i (step 12) |- ( ( x ∈ A → x ⊆ B ) ↔ ( x ∈ A → ∀ y ( y ∈ x → y ∈ B ) ) ) ;;
	step 14 : wff = 3bitr4i (step 7, step 11, step 13) |- ( ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ( x ∈ A → x ⊆ B ) ) ;;
	step 15 : wff = albii (step 14) |- ( ∀ x ∀ y ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ∀ x ( x ∈ A → x ⊆ B ) ) ;;
	step 16 : wff = bitri (step 6, step 15) |- ( ∀ y ∀ x ( ( y ∈ x ∧ x ∈ A ) → y ∈ B ) ↔ ∀ x ( x ∈ A → x ⊆ B ) ) ;;
	step 17 : wff = bitri (step 5, step 16) |- ( ∀ y ( y ∈ ⋃ A → y ∈ B ) ↔ ∀ x ( x ∈ A → x ⊆ B ) ) ;;
	step 18 : wff = dfss2 () |- ( ⋃ A ⊆ B ↔ ∀ y ( y ∈ ⋃ A → y ∈ B ) ) ;;
	step 19 : wff = df-ral () |- ( ∀ x ∈ A x ⊆ B ↔ ∀ x ( x ∈ A → x ⊆ B ) ) ;;
	step 20 : wff = 3bitr4i (step 17, step 18, step 19) |- ( ⋃ A ⊆ B ↔ ∀ x ∈ A x ⊆ B ) ;;
	qed prop 1 = step 20 ;;
}

/*A subclass condition on the members of two classes that implies a
       subclass relation on their unions.  Proposition 8.6 of [TakeutiZaring]
       p. 59.  See ~ iunss2 for a generalization to indexed unions.
       (Contributed by NM, 22-Mar-2004.) */

theorem uniss2 (x : set, y : set, A : class, B : class) disjointed(x A, x y B) {
	prop 1 : wff = |- ( ∀ x ∈ A ∃ y ∈ B x ⊆ y → ⋃ A ⊆ ⋃ B ) ;;
}

proof of uniss2 {
	step 1 : wff = ssuni () |- ( ( x ⊆ y ∧ y ∈ B ) → x ⊆ ⋃ B ) ;;
	step 2 : wff = expcom (step 1) |- ( y ∈ B → ( x ⊆ y → x ⊆ ⋃ B ) ) ;;
	step 3 : wff = rexlimiv (step 2) |- ( ∃ y ∈ B x ⊆ y → x ⊆ ⋃ B ) ;;
	step 4 : wff = ralimi (step 3) |- ( ∀ x ∈ A ∃ y ∈ B x ⊆ y → ∀ x ∈ A x ⊆ ⋃ B ) ;;
	step 5 : wff = unissb () |- ( ⋃ A ⊆ ⋃ B ↔ ∀ x ∈ A x ⊆ ⋃ B ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ∀ x ∈ A ∃ y ∈ B x ⊆ y → ⋃ A ⊆ ⋃ B ) ;;
	qed prop 1 = step 6 ;;
}

/*If the difference ` A \ B ` contains the largest members of ` A ` , then
       the union of the difference is the union of ` A ` .  (Contributed by NM,
       22-Mar-2004.) */

theorem unidif (x : set, y : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( ∀ x ∈ A ∃ y ∈ ( A ∖ B ) x ⊆ y → ⋃ ( A ∖ B ) = ⋃ A ) ;;
}

proof of unidif {
	step 1 : wff = uniss2 () |- ( ∀ x ∈ A ∃ y ∈ ( A ∖ B ) x ⊆ y → ⋃ A ⊆ ⋃ ( A ∖ B ) ) ;;
	step 2 : wff = difss () |- ( A ∖ B ) ⊆ A ;;
	step 3 : wff = uniss () |- ( ( A ∖ B ) ⊆ A → ⋃ ( A ∖ B ) ⊆ ⋃ A ) ;;
	step 4 : wff = ax-mp (step 2, step 3) |- ⋃ ( A ∖ B ) ⊆ ⋃ A ;;
	step 5 : wff = jctil (step 1, step 4) |- ( ∀ x ∈ A ∃ y ∈ ( A ∖ B ) x ⊆ y → ( ⋃ ( A ∖ B ) ⊆ ⋃ A ∧ ⋃ A ⊆ ⋃ ( A ∖ B ) ) ) ;;
	step 6 : wff = eqss () |- ( ⋃ ( A ∖ B ) = ⋃ A ↔ ( ⋃ ( A ∖ B ) ⊆ ⋃ A ∧ ⋃ A ⊆ ⋃ ( A ∖ B ) ) ) ;;
	step 7 : wff = sylibr (step 5, step 6) |- ( ∀ x ∈ A ∃ y ∈ ( A ∖ B ) x ⊆ y → ⋃ ( A ∖ B ) = ⋃ A ) ;;
	qed prop 1 = step 7 ;;
}

/*Relationship implying union.  (Contributed by NM, 10-Nov-1999.) */

theorem ssunieq (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( ( A ∈ B ∧ ∀ x ∈ B x ⊆ A ) → A = ⋃ B ) ;;
}

proof of ssunieq {
	step 1 : wff = elssuni () |- ( A ∈ B → A ⊆ ⋃ B ) ;;
	step 2 : wff = unissb () |- ( ⋃ B ⊆ A ↔ ∀ x ∈ B x ⊆ A ) ;;
	step 3 : wff = biimpri (step 2) |- ( ∀ x ∈ B x ⊆ A → ⋃ B ⊆ A ) ;;
	step 4 : wff = anim12i (step 1, step 3) |- ( ( A ∈ B ∧ ∀ x ∈ B x ⊆ A ) → ( A ⊆ ⋃ B ∧ ⋃ B ⊆ A ) ) ;;
	step 5 : wff = eqss () |- ( A = ⋃ B ↔ ( A ⊆ ⋃ B ∧ ⋃ B ⊆ A ) ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ( A ∈ B ∧ ∀ x ∈ B x ⊆ A ) → A = ⋃ B ) ;;
	qed prop 1 = step 6 ;;
}

/*Any member of a class is the largest of those members that it includes.
       (Contributed by NM, 13-Aug-2002.) */

theorem unimax (x : set, A : class, B : class) disjointed(x y A, x y B) {
	prop 1 : wff = |- ( A ∈ B → ⋃ { x ∈ B | x ⊆ A } = A ) ;;
}

proof of unimax {
	var y : set;;
	step 1 : wff = ssid () |- A ⊆ A ;;
	step 2 : wff = sseq1 () |- ( x = A → ( x ⊆ A ↔ A ⊆ A ) ) ;;
	step 3 : wff = elrab3 (step 2) |- ( A ∈ B → ( A ∈ { x ∈ B | x ⊆ A } ↔ A ⊆ A ) ) ;;
	step 4 : wff = mpbiri (step 1, step 3) |- ( A ∈ B → A ∈ { x ∈ B | x ⊆ A } ) ;;
	step 5 : wff = sseq1 () |- ( x = y → ( x ⊆ A ↔ y ⊆ A ) ) ;;
	step 6 : wff = elrab (step 5) |- ( y ∈ { x ∈ B | x ⊆ A } ↔ ( y ∈ B ∧ y ⊆ A ) ) ;;
	step 7 : wff = simprbi (step 6) |- ( y ∈ { x ∈ B | x ⊆ A } → y ⊆ A ) ;;
	step 8 : wff = rgen (step 7) |- ∀ y ∈ { x ∈ B | x ⊆ A } y ⊆ A ;;
	step 9 : wff = ssunieq () |- ( ( A ∈ { x ∈ B | x ⊆ A } ∧ ∀ y ∈ { x ∈ B | x ⊆ A } y ⊆ A ) → A = ⋃ { x ∈ B | x ⊆ A } ) ;;
	step 10 : wff = eqcomd (step 9) |- ( ( A ∈ { x ∈ B | x ⊆ A } ∧ ∀ y ∈ { x ∈ B | x ⊆ A } y ⊆ A ) → ⋃ { x ∈ B | x ⊆ A } = A ) ;;
	step 11 : wff = sylancl (step 4, step 8, step 10) |- ( A ∈ B → ⋃ { x ∈ B | x ⊆ A } = A ) ;;
	qed prop 1 = step 11 ;;
}


