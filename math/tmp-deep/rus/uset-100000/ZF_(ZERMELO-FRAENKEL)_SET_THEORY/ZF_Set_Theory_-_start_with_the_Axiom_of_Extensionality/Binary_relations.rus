import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Disjointness.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                     Binary relations

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Extend wff notation to include the general binary relation predicate.
     Note that the syntax is simply three class symbols in a row.  Since binary
     relations are the only possible wff expressions consisting of three class
     expressions in a row, the syntax is unambiguous.  (For an example of how
     syntax could become ambiguous if we are not careful, see the comment in
     ~ cneg .) */

rule wbr (A : class, B : class, R : class) {
	term : wff = # A R B ;;
}

/* Define a general binary relation.  Note that the syntax is simply three
     class symbols in a row.  Definition 6.18 of [TakeutiZaring] p. 29
     generalized to arbitrary classes.  Class ` R ` often denotes a relation
     such as " ` < ` " that compares two classes ` A ` and ` B ` , which might
     be numbers such as ` 1 ` and ` 2 ` (see ~ df-ltxr for the specific
     definition of ` < ` ).  As a wff, relations are true or false.  For
     example, ` ( R = { <. 2 , 6 >. , <. 3 , 9 >. } -> 3 R 9 ) ` ( ~ ex-br ).
     Often class ` R ` meets the ` Rel ` criteria to be defined in ~ df-rel ,
     and in particular ` R ` may be a function (see ~ df-fun ).  This
     definition of relations is well-defined, although not very meaningful,
     when classes ` A ` and/or ` B ` are proper classes (i.e. are not sets).
     On the other hand, we often find uses for this definition when ` R ` is a
     proper class.  (Contributed by NM, 31-Dec-1993.) */

definition df-br (A : class, B : class, R : class)  {
	defiendum : wff = # A R B ;;
	definiens : wff = # 〈 A , B 〉 ∈ R ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/* Equality theorem for binary relations.  (Contributed by NM,
     4-Jun-1995.) */

theorem breq (A : class, B : class, R : class, S : class)  {
	prop 1 : wff = |- ( R = S → ( A R B ↔ A S B ) ) ;;
}

proof of breq {
	step 1 : wff = eleq2 () |- ( R = S → ( 〈 A , B 〉 ∈ R ↔ 〈 A , B 〉 ∈ S ) ) ;;
	step 2 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 3 : wff = df-br () |- ( A S B ↔ 〈 A , B 〉 ∈ S ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( R = S → ( A R B ↔ A S B ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Equality theorem for a binary relation.  (Contributed by NM,
     31-Dec-1993.) */

theorem breq1 (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( A = B → ( A R C ↔ B R C ) ) ;;
}

proof of breq1 {
	step 1 : wff = opeq1 () |- ( A = B → 〈 A , C 〉 = 〈 B , C 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( A = B → ( 〈 A , C 〉 ∈ R ↔ 〈 B , C 〉 ∈ R ) ) ;;
	step 3 : wff = df-br () |- ( A R C ↔ 〈 A , C 〉 ∈ R ) ;;
	step 4 : wff = df-br () |- ( B R C ↔ 〈 B , C 〉 ∈ R ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( A R C ↔ B R C ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Equality theorem for a binary relation.  (Contributed by NM,
     31-Dec-1993.) */

theorem breq2 (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( A = B → ( C R A ↔ C R B ) ) ;;
}

proof of breq2 {
	step 1 : wff = opeq2 () |- ( A = B → 〈 C , A 〉 = 〈 C , B 〉 ) ;;
	step 2 : wff = eleq1d (step 1) |- ( A = B → ( 〈 C , A 〉 ∈ R ↔ 〈 C , B 〉 ∈ R ) ) ;;
	step 3 : wff = df-br () |- ( C R A ↔ 〈 C , A 〉 ∈ R ) ;;
	step 4 : wff = df-br () |- ( C R B ↔ 〈 C , B 〉 ∈ R ) ;;
	step 5 : wff = 3bitr4g (step 2, step 3, step 4) |- ( A = B → ( C R A ↔ C R B ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Equality theorem for a binary relation.  (Contributed by NM,
     8-Feb-1996.) */

theorem breq12 (A : class, B : class, C : class, D : class, R : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → ( A R C ↔ B R D ) ) ;;
}

proof of breq12 {
	step 1 : wff = breq1 () |- ( A = B → ( A R C ↔ B R C ) ) ;;
	step 2 : wff = breq2 () |- ( C = D → ( B R C ↔ B R D ) ) ;;
	step 3 : wff = sylan9bb (step 1, step 2) |- ( ( A = B ∧ C = D ) → ( A R C ↔ B R D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Equality inference for binary relations.  (Contributed by NM,
       19-Feb-2005.) */

theorem breqi (A : class, B : class, R : class, S : class)  {
	hyp 1 : wff = |- R = S ;;
	-----------------------
	prop 1 : wff = |- ( A R B ↔ A S B ) ;;
}

proof of breqi {
	step 1 : wff = breq () |- ( R = S → ( A R B ↔ A S B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A R B ↔ A S B ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for a binary relation.  (Contributed by NM,
       8-Feb-1996.) */

theorem breq1i (A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A R C ↔ B R C ) ;;
}

proof of breq1i {
	step 1 : wff = breq1 () |- ( A = B → ( A R C ↔ B R C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A R C ↔ B R C ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for a binary relation.  (Contributed by NM,
       8-Feb-1996.) */

theorem breq2i (A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C R A ↔ C R B ) ;;
}

proof of breq2i {
	step 1 : wff = breq2 () |- ( A = B → ( C R A ↔ C R B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C R A ↔ C R B ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality inference for a binary relation.  (Contributed by NM,
         8-Feb-1996.)  (Proof shortened by Eric Schmidt, 4-Apr-2007.) */

theorem breq12i (A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A R C ↔ B R D ) ;;
}

proof of breq12i {
	step 1 : wff = breq12 () |- ( ( A = B ∧ C = D ) → ( A R C ↔ B R D ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A R C ↔ B R D ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
       8-Feb-1996.) */

theorem breq1d (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A R C ↔ B R C ) ) ;;
}

proof of breq1d {
	step 1 : wff = breq1 () |- ( A = B → ( A R C ↔ B R C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A R C ↔ B R C ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
       29-Oct-2011.) */

theorem breqd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C A D ↔ C B D ) ) ;;
}

proof of breqd {
	step 1 : wff = breq () |- ( A = B → ( C A D ↔ C B D ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C A D ↔ C B D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
       8-Feb-1996.) */

theorem breq2d (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C R A ↔ C R B ) ) ;;
}

proof of breq2d {
	step 1 : wff = breq2 () |- ( A = B → ( C R A ↔ C R B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C R A ↔ C R B ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
         8-Feb-1996.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem breq12d (ph : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A R C ↔ B R D ) ) ;;
}

proof of breq12d {
	step 1 : wff = breq12 () |- ( ( A = B ∧ C = D ) → ( A R C ↔ B R D ) ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → ( A R C ↔ B R D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
         29-Oct-2011.) */

theorem breq123d (ph : wff, A : class, B : class, C : class, D : class, R : class, S : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → R = S ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A R C ↔ B S D ) ) ;;
}

proof of breq123d {
	step 1 : wff = breq12d (hyp 1, hyp 3) |- ( ph → ( A R C ↔ B R D ) ) ;;
	step 2 : wff = breqd (hyp 2) |- ( ph → ( B R D ↔ B S D ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( A R C ↔ B S D ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
         8-Feb-1996.) */

theorem breqan12d (ph : wff, ps : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → ( A R C ↔ B R D ) ) ;;
}

proof of breqan12d {
	step 1 : wff = breq12 () |- ( ( A = B ∧ C = D ) → ( A R C ↔ B R D ) ) ;;
	step 2 : wff = syl2an (hyp 1, hyp 2, step 1) |- ( ( ph ∧ ps ) → ( A R C ↔ B R D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Equality deduction for a binary relation.  (Contributed by NM,
         8-Feb-1996.) */

theorem breqan12rd (ph : wff, ps : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps ∧ ph ) → ( A R C ↔ B R D ) ) ;;
}

proof of breqan12rd {
	step 1 : wff = breqan12d (hyp 1, hyp 2) |- ( ( ph ∧ ps ) → ( A R C ↔ B R D ) ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( ps ∧ ph ) → ( A R C ↔ B R D ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Two classes are different if they don't have the same relationship to a
     third class.  (Contributed by NM, 3-Jun-2012.) */

theorem nbrne1 (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( A R B ∧ ¬ A R C ) → B ≠ C ) ;;
}

proof of nbrne1 {
	step 1 : wff = breq2 () |- ( B = C → ( A R B ↔ A R C ) ) ;;
	step 2 : wff = biimpcd (step 1) |- ( A R B → ( B = C → A R C ) ) ;;
	step 3 : wff = necon3bd (step 2) |- ( A R B → ( ¬ A R C → B ≠ C ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( A R B ∧ ¬ A R C ) → B ≠ C ) ;;
	qed prop 1 = step 4 ;;
}

/* Two classes are different if they don't have the same relationship to a
     third class.  (Contributed by NM, 3-Jun-2012.) */

theorem nbrne2 (A : class, B : class, C : class, R : class)  {
	prop 1 : wff = |- ( ( A R C ∧ ¬ B R C ) → A ≠ B ) ;;
}

proof of nbrne2 {
	step 1 : wff = breq1 () |- ( A = B → ( A R C ↔ B R C ) ) ;;
	step 2 : wff = biimpcd (step 1) |- ( A R C → ( A = B → B R C ) ) ;;
	step 3 : wff = necon3bd (step 2) |- ( A R C → ( ¬ B R C → A ≠ B ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( A R C ∧ ¬ B R C ) → A ≠ B ) ;;
	qed prop 1 = step 4 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eqbrtri (A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- B R C ;;
	-----------------------
	prop 1 : wff = |- A R C ;;
}

proof of eqbrtri {
	step 1 : wff = breq1i (hyp 1) |- ( A R C ↔ B R C ) ;;
	step 2 : wff = mpbir (hyp 2, step 1) |- A R C ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 8-Oct-1999.) */

theorem eqbrtrd (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → B R C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of eqbrtrd {
	step 1 : wff = breq1d (hyp 1) |- ( ph → ( A R C ↔ B R C ) ) ;;
	step 2 : wff = mpbird (hyp 2, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eqbrtrri (A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- A R C ;;
	-----------------------
	prop 1 : wff = |- B R C ;;
}

proof of eqbrtrri {
	step 1 : wff = eqcomi (hyp 1) |- B = A ;;
	step 2 : wff = eqbrtri (step 1, hyp 2) |- B R C ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 24-Oct-1999.) */

theorem eqbrtrrd (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → A R C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → B R C ) ;;
}

proof of eqbrtrrd {
	step 1 : wff = eqcomd (hyp 1) |- ( ph → B = A ) ;;
	step 2 : wff = eqbrtrd (step 1, hyp 2) |- ( ph → B R C ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem breqtri (A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A R B ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- A R C ;;
}

proof of breqtri {
	step 1 : wff = breq2i (hyp 2) |- ( A R B ↔ A R C ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- A R C ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 24-Oct-1999.) */

theorem breqtrd (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of breqtrd {
	step 1 : wff = breq2d (hyp 2) |- ( ph → ( A R B ↔ A R C ) ) ;;
	step 2 : wff = mpbid (hyp 1, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem breqtrri (A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A R B ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- A R C ;;
}

proof of breqtrri {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = breqtri (hyp 1, step 1) |- A R C ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equal classes into a binary relation.  (Contributed by
       NM, 24-Oct-1999.) */

theorem breqtrrd (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of breqtrrd {
	step 1 : wff = eqcomd (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = breqtrd (hyp 1, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equality into both sides of a binary relation.
       (Contributed by NM, 11-Aug-1999.) */

theorem 3brtr3i (A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- A R B ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- C R D ;;
}

proof of 3brtr3i {
	step 1 : wff = eqbrtrri (hyp 2, hyp 1) |- C R B ;;
	step 2 : wff = breqtri (step 1, hyp 3) |- C R D ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equality into both sides of a binary relation.
       (Contributed by NM, 11-Aug-1999.) */

theorem 3brtr4i (A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- A R B ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- C R D ;;
}

proof of 3brtr4i {
	step 1 : wff = eqbrtri (hyp 2, hyp 1) |- C R B ;;
	step 2 : wff = breqtrri (step 1, hyp 3) |- C R D ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equality into both sides of a binary relation.
       (Contributed by NM, 18-Oct-1999.) */

theorem 3brtr3d (ph : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	hyp 3 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C R D ) ;;
}

proof of 3brtr3d {
	step 1 : wff = breq12d (hyp 2, hyp 3) |- ( ph → ( A R B ↔ C R D ) ) ;;
	step 2 : wff = mpbid (hyp 1, step 1) |- ( ph → C R D ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equality into both sides of a binary relation.
       (Contributed by NM, 21-Feb-2005.) */

theorem 3brtr4d (ph : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- ( ph → C = A ) ;;
	hyp 3 : wff = |- ( ph → D = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C R D ) ;;
}

proof of 3brtr4d {
	step 1 : wff = breq12d (hyp 2, hyp 3) |- ( ph → ( C R D ↔ A R B ) ) ;;
	step 2 : wff = mpbird (hyp 1, step 1) |- ( ph → C R D ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equality into both sides of a binary relation.
       (Contributed by NM, 16-Jan-1997.) */

theorem 3brtr3g (ph : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- ( ph → C R D ) ;;
}

proof of 3brtr3g {
	step 1 : wff = breq12i (hyp 2, hyp 3) |- ( A R B ↔ C R D ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → C R D ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution of equality into both sides of a binary relation.
       (Contributed by NM, 16-Jan-1997.) */

theorem 3brtr4g (ph : wff, A : class, B : class, C : class, D : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → C R D ) ;;
}

proof of 3brtr4g {
	step 1 : wff = breq12i (hyp 2, hyp 3) |- ( C R D ↔ A R B ) ;;
	step 2 : wff = sylibr (hyp 1, step 1) |- ( ph → C R D ) ;;
	qed prop 1 = step 2 ;;
}

/* B chained equality inference for a binary relation.  (Contributed by NM,
       11-Oct-1999.) */

theorem syl5eqbr (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → B R C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl5eqbr {
	step 1 : wff = eqid () |- C = C ;;
	step 2 : wff = 3brtr4g (hyp 2, hyp 1, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* B chained equality inference for a binary relation.  (Contributed by NM,
       17-Sep-2004.) */

theorem syl5eqbrr (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- B = A ;;
	hyp 2 : wff = |- ( ph → B R C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl5eqbrr {
	step 1 : wff = eqid () |- C = C ;;
	step 2 : wff = 3brtr3g (hyp 2, hyp 1, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* B chained equality inference for a binary relation.  (Contributed by NM,
       11-Oct-1999.) */

theorem syl5breq (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A R B ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl5breq {
	step 1 : wff = a1i (hyp 1) |- ( ph → A R B ) ;;
	step 2 : wff = breqtrd (step 1, hyp 2) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* B chained equality inference for a binary relation.  (Contributed by NM,
       24-Apr-2005.) */

theorem syl5breqr (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- A R B ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl5breqr {
	step 1 : wff = eqcomd (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = syl5breq (hyp 1, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained equality inference for a binary relation.  (Contributed by NM,
       12-Oct-1999.) */

theorem syl6eqbr (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- B R C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl6eqbr {
	step 1 : wff = breq1d (hyp 1) |- ( ph → ( A R C ↔ B R C ) ) ;;
	step 2 : wff = mpbiri (hyp 2, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained equality inference for a binary relation.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl6eqbrr (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → B = A ) ;;
	hyp 2 : wff = |- B R C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl6eqbrr {
	step 1 : wff = eqcomd (hyp 1) |- ( ph → A = B ) ;;
	step 2 : wff = syl6eqbr (step 1, hyp 2) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained equality inference for a binary relation.  (Contributed by NM,
       11-Oct-1999.) */

theorem syl6breq (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl6breq {
	step 1 : wff = eqid () |- A = A ;;
	step 2 : wff = 3brtr3g (hyp 1, step 1, hyp 2) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained equality inference for a binary relation.  (Contributed by NM,
       24-Apr-2005.) */

theorem syl6breqr (ph : wff, A : class, B : class, C : class, R : class)  {
	hyp 1 : wff = |- ( ph → A R B ) ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → A R C ) ;;
}

proof of syl6breqr {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = syl6breq (hyp 1, step 1) |- ( ph → A R C ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from a subclass relationship of binary relations.
       (Contributed by NM, 30-Apr-2004.) */

theorem ssbrd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A ⊆ B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C A D → C B D ) ) ;;
}

proof of ssbrd {
	step 1 : wff = sseld (hyp 1) |- ( ph → ( 〈 C , D 〉 ∈ A → 〈 C , D 〉 ∈ B ) ) ;;
	step 2 : wff = df-br () |- ( C A D ↔ 〈 C , D 〉 ∈ A ) ;;
	step 3 : wff = df-br () |- ( C B D ↔ 〈 C , D 〉 ∈ B ) ;;
	step 4 : wff = 3imtr4g (step 1, step 2, step 3) |- ( ph → ( C A D → C B D ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Inference from a subclass relationship of binary relations.
       (Contributed by NM, 28-Mar-2007.)  (Revised by Mario Carneiro,
       8-Feb-2015.) */

theorem ssbri (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A ⊆ B ;;
	-----------------------
	prop 1 : wff = |- ( C A D → C B D ) ;;
}

proof of ssbri {
	step 1 : wff = a1i (hyp 1) |- ( T. → A ⊆ B ) ;;
	step 2 : wff = ssbrd (step 1) |- ( T. → ( C A D → C B D ) ) ;;
	step 3 : wff = trud (step 2) |- ( C A D → C B D ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction version of bound-variable hypothesis builder ~ nfbr .
       (Contributed by NM, 13-Dec-2005.)  (Revised by Mario Carneiro,
       14-Oct-2016.) */

theorem nfbrd (ph : wff, x : set, A : class, B : class, R : class)  {
	hyp 1 : wff = |- ( ph → F/_ x A ) ;;
	hyp 2 : wff = |- ( ph → F/_ x R ) ;;
	hyp 3 : wff = |- ( ph → F/_ x B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x A R B ) ;;
}

proof of nfbrd {
	step 1 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 2 : wff = nfopd (hyp 1, hyp 3) |- ( ph → F/_ x 〈 A , B 〉 ) ;;
	step 3 : wff = nfeld (step 2, hyp 2) |- ( ph → F/ x 〈 A , B 〉 ∈ R ) ;;
	step 4 : wff = nfxfrd (step 1, step 3) |- ( ph → F/ x A R B ) ;;
	qed prop 1 = step 4 ;;
}

/* Bound-variable hypothesis builder for binary relation.  (Contributed by
       NM, 1-Sep-1999.)  (Revised by Mario Carneiro, 14-Oct-2016.) */

theorem nfbr (x : set, A : class, B : class, R : class)  {
	hyp 1 : wff = |- F/_ x A ;;
	hyp 2 : wff = |- F/_ x R ;;
	hyp 3 : wff = |- F/_ x B ;;
	-----------------------
	prop 1 : wff = |- F/ x A R B ;;
}

proof of nfbr {
	step 1 : wff = a1i (hyp 1) |- ( T. → F/_ x A ) ;;
	step 2 : wff = a1i (hyp 2) |- ( T. → F/_ x R ) ;;
	step 3 : wff = a1i (hyp 3) |- ( T. → F/_ x B ) ;;
	step 4 : wff = nfbrd (step 1, step 2, step 3) |- ( T. → F/ x A R B ) ;;
	step 5 : wff = trud (step 4) |- F/ x A R B ;;
	qed prop 1 = step 5 ;;
}

/* Relationship between a binary relation and a class abstraction.
       (Contributed by Andrew Salmon, 8-Jul-2011.) */

theorem brab1 (x : set, z : set, A : class, R : class) disjointed(x y, y z A, y z R) {
	prop 1 : wff = |- ( x R A ↔ x ∈ { z | z R A } ) ;;
}

proof of brab1 {
	var y : set;;
	step 1 : wff = vex () |- x ∈ _V ;;
	step 2 : wff = breq1 () |- ( z = y → ( z R A ↔ y R A ) ) ;;
	step 3 : wff = breq1 () |- ( y = x → ( y R A ↔ x R A ) ) ;;
	step 4 : wff = sbcie2g (step 2, step 3) |- ( x ∈ _V → ( [. x / z ]. z R A ↔ x R A ) ) ;;
	step 5 : wff = ax-mp (step 1, step 4) |- ( [. x / z ]. z R A ↔ x R A ) ;;
	step 6 : wff = df-sbc () |- ( [. x / z ]. z R A ↔ x ∈ { z | z R A } ) ;;
	step 7 : wff = bitr3i (step 5, step 6) |- ( x R A ↔ x ∈ { z | z R A } ) ;;
	qed prop 1 = step 7 ;;
}

/* The union of two binary relations.  (Contributed by NM, 21-Dec-2008.) */

theorem brun (A : class, B : class, R : class, S : class)  {
	prop 1 : wff = |- ( A ( R ∪ S ) B ↔ ( A R B ∨ A S B ) ) ;;
}

proof of brun {
	step 1 : wff = elun () |- ( 〈 A , B 〉 ∈ ( R ∪ S ) ↔ ( 〈 A , B 〉 ∈ R ∨ 〈 A , B 〉 ∈ S ) ) ;;
	step 2 : wff = df-br () |- ( A ( R ∪ S ) B ↔ 〈 A , B 〉 ∈ ( R ∪ S ) ) ;;
	step 3 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 4 : wff = df-br () |- ( A S B ↔ 〈 A , B 〉 ∈ S ) ;;
	step 5 : wff = orbi12i (step 3, step 4) |- ( ( A R B ∨ A S B ) ↔ ( 〈 A , B 〉 ∈ R ∨ 〈 A , B 〉 ∈ S ) ) ;;
	step 6 : wff = 3bitr4i (step 1, step 2, step 5) |- ( A ( R ∪ S ) B ↔ ( A R B ∨ A S B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* The intersection of two relations.  (Contributed by FL, 7-Oct-2008.) */

theorem brin (A : class, B : class, R : class, S : class)  {
	prop 1 : wff = |- ( A ( R ∩ S ) B ↔ ( A R B ∧ A S B ) ) ;;
}

proof of brin {
	step 1 : wff = elin () |- ( 〈 A , B 〉 ∈ ( R ∩ S ) ↔ ( 〈 A , B 〉 ∈ R ∧ 〈 A , B 〉 ∈ S ) ) ;;
	step 2 : wff = df-br () |- ( A ( R ∩ S ) B ↔ 〈 A , B 〉 ∈ ( R ∩ S ) ) ;;
	step 3 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 4 : wff = df-br () |- ( A S B ↔ 〈 A , B 〉 ∈ S ) ;;
	step 5 : wff = anbi12i (step 3, step 4) |- ( ( A R B ∧ A S B ) ↔ ( 〈 A , B 〉 ∈ R ∧ 〈 A , B 〉 ∈ S ) ) ;;
	step 6 : wff = 3bitr4i (step 1, step 2, step 5) |- ( A ( R ∩ S ) B ↔ ( A R B ∧ A S B ) ) ;;
	qed prop 1 = step 6 ;;
}

/* The difference of two binary relations.  (Contributed by Scott Fenton,
     11-Apr-2011.) */

theorem brdif (A : class, B : class, R : class, S : class)  {
	prop 1 : wff = |- ( A ( R ∖ S ) B ↔ ( A R B ∧ ¬ A S B ) ) ;;
}

proof of brdif {
	step 1 : wff = eldif () |- ( 〈 A , B 〉 ∈ ( R ∖ S ) ↔ ( 〈 A , B 〉 ∈ R ∧ ¬ 〈 A , B 〉 ∈ S ) ) ;;
	step 2 : wff = df-br () |- ( A ( R ∖ S ) B ↔ 〈 A , B 〉 ∈ ( R ∖ S ) ) ;;
	step 3 : wff = df-br () |- ( A R B ↔ 〈 A , B 〉 ∈ R ) ;;
	step 4 : wff = df-br () |- ( A S B ↔ 〈 A , B 〉 ∈ S ) ;;
	step 5 : wff = notbii (step 4) |- ( ¬ A S B ↔ ¬ 〈 A , B 〉 ∈ S ) ;;
	step 6 : wff = anbi12i (step 3, step 5) |- ( ( A R B ∧ ¬ A S B ) ↔ ( 〈 A , B 〉 ∈ R ∧ ¬ 〈 A , B 〉 ∈ S ) ) ;;
	step 7 : wff = 3bitr4i (step 1, step 2, step 6) |- ( A ( R ∖ S ) B ↔ ( A R B ∧ ¬ A S B ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Move substitution in and out of a binary relation.  (Contributed by NM,
       13-Dec-2005.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem sbcbrg (x : set, A : class, B : class, C : class, D : class, R : class) disjointed(y A, y B, y C, y D, y R, x y) {
	prop 1 : wff = |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B [_ A / x ]_ R [_ A / x ]_ C ) ) ;;
}

proof of sbcbrg {
	var y : set;;
	step 1 : wff = dfsbcq2 () |- ( y = A → ( [ y / x ] B R C ↔ [. A / x ]. B R C ) ) ;;
	step 2 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ B = [_ A / x ]_ B ) ;;
	step 3 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ R = [_ A / x ]_ R ) ;;
	step 4 : wff = csbeq1 () |- ( y = A → [_ y / x ]_ C = [_ A / x ]_ C ) ;;
	step 5 : wff = breq123d (step 2, step 3, step 4) |- ( y = A → ( [_ y / x ]_ B [_ y / x ]_ R [_ y / x ]_ C ↔ [_ A / x ]_ B [_ A / x ]_ R [_ A / x ]_ C ) ) ;;
	step 6 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ B ;;
	step 7 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ R ;;
	step 8 : wff = nfcsb1v () |- F/_ x [_ y / x ]_ C ;;
	step 9 : wff = nfbr (step 6, step 7, step 8) |- F/ x [_ y / x ]_ B [_ y / x ]_ R [_ y / x ]_ C ;;
	step 10 : wff = csbeq1a () |- ( x = y → B = [_ y / x ]_ B ) ;;
	step 11 : wff = csbeq1a () |- ( x = y → R = [_ y / x ]_ R ) ;;
	step 12 : wff = csbeq1a () |- ( x = y → C = [_ y / x ]_ C ) ;;
	step 13 : wff = breq123d (step 10, step 11, step 12) |- ( x = y → ( B R C ↔ [_ y / x ]_ B [_ y / x ]_ R [_ y / x ]_ C ) ) ;;
	step 14 : wff = sbie (step 9, step 13) |- ( [ y / x ] B R C ↔ [_ y / x ]_ B [_ y / x ]_ R [_ y / x ]_ C ) ;;
	step 15 : wff = vtoclbg (step 1, step 5, step 14) |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B [_ A / x ]_ R [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Move substitution in and out of a binary relation.  (Contributed by NM,
       13-Dec-2005.) */

theorem sbcbr12g (x : set, A : class, B : class, C : class, D : class, R : class) disjointed(x R) {
	prop 1 : wff = |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B R [_ A / x ]_ C ) ) ;;
}

proof of sbcbr12g {
	step 1 : wff = sbcbrg () |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B [_ A / x ]_ R [_ A / x ]_ C ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ D → [_ A / x ]_ R = R ) ;;
	step 3 : wff = breqd (step 2) |- ( A ∈ D → ( [_ A / x ]_ B [_ A / x ]_ R [_ A / x ]_ C ↔ [_ A / x ]_ B R [_ A / x ]_ C ) ) ;;
	step 4 : wff = bitrd (step 1, step 3) |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B R [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Move substitution in and out of a binary relation.  (Contributed by NM,
       13-Dec-2005.) */

theorem sbcbr1g (x : set, A : class, B : class, C : class, D : class, R : class) disjointed(x C, x R) {
	prop 1 : wff = |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B R C ) ) ;;
}

proof of sbcbr1g {
	step 1 : wff = sbcbr12g () |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B R [_ A / x ]_ C ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ D → [_ A / x ]_ C = C ) ;;
	step 3 : wff = breq2d (step 2) |- ( A ∈ D → ( [_ A / x ]_ B R [_ A / x ]_ C ↔ [_ A / x ]_ B R C ) ) ;;
	step 4 : wff = bitrd (step 1, step 3) |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B R C ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Move substitution in and out of a binary relation.  (Contributed by NM,
       13-Dec-2005.) */

theorem sbcbr2g (x : set, A : class, B : class, C : class, D : class, R : class) disjointed(x B, x R) {
	prop 1 : wff = |- ( A ∈ D → ( [. A / x ]. B R C ↔ B R [_ A / x ]_ C ) ) ;;
}

proof of sbcbr2g {
	step 1 : wff = sbcbr12g () |- ( A ∈ D → ( [. A / x ]. B R C ↔ [_ A / x ]_ B R [_ A / x ]_ C ) ) ;;
	step 2 : wff = csbconstg () |- ( A ∈ D → [_ A / x ]_ B = B ) ;;
	step 3 : wff = breq1d (step 2) |- ( A ∈ D → ( [_ A / x ]_ B R [_ A / x ]_ C ↔ B R [_ A / x ]_ C ) ) ;;
	step 4 : wff = bitrd (step 1, step 3) |- ( A ∈ D → ( [. A / x ]. B R C ↔ B R [_ A / x ]_ C ) ) ;;
	qed prop 1 = step 4 ;;
}


