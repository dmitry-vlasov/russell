import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Proper_substitution_of_classes_for_sets_into_classes.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Define basic set operations and relations

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Declare new symbols. */

constant {
	symbol ∖ ;;
	ascii \ ;;
	latex \setminus ;;
}

/* Backslash (difference) */

constant {
	symbol ∪ ;;
	ascii u. ;;
	latex \cup ;;
}

/* Cup (union) */

constant {
	symbol ∩ ;;
	ascii i^i ;;
	latex \cap ;;
}

/* Cap (intersection) */

constant {
	symbol ⊆ ;;
	ascii C_ ;;
	latex \subseteq ;;
}

/* Subclass or subset symbol */

constant {
	symbol ⊂ ;;
	ascii C. ;;
	latex \subset ;;
}

/* Proper subclass or subset symbol */

/* Extend class notation to include class difference (read:  " ` A ` minus
     ` B ` "). */

rule cdif (A : class, B : class) {
	term : class = # ( A ∖ B ) ;;
}

/* Extend class notation to include union of two classes (read:  " ` A `
     union ` B ` "). */

rule cun (A : class, B : class) {
	term : class = # ( A ∪ B ) ;;
}

/* Extend class notation to include the intersection of two classes
     (read:  " ` A ` intersect ` B ` "). */

rule cin (A : class, B : class) {
	term : class = # ( A ∩ B ) ;;
}

/* Extend wff notation to include the subclass relation.  This is
     read " ` A ` is a subclass of ` B ` " or " ` B ` includes ` A ` ."  When
     ` A ` exists as a set, it is also read " ` A ` is a subset of ` B ` ." */

rule wss (A : class, B : class) {
	term : wff = # A ⊆ B ;;
}

/* Extend wff notation with proper subclass relation. */

rule wpss (A : class, B : class) {
	term : wff = # A ⊂ B ;;
}

/* Soundness justification theorem for ~ df-dif .  (Contributed by Rodolfo
       Medina, 27-Apr-2010.)  (Proof shortened by Andrew Salmon,
       9-Jul-2011.) */

theorem difjust (x : set, y : set, A : class, B : class) disjointed(x A, x B, y A, y B, z x, z y, z A, z B) {
	prop 1 : wff = |- { x | ( x ∈ A ∧ ¬ x ∈ B ) } = { y | ( y ∈ A ∧ ¬ y ∈ B ) } ;;
}

proof of difjust {
	var z : set;;
	step 1 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 2 : wff = eleq1 () |- ( x = z → ( x ∈ B ↔ z ∈ B ) ) ;;
	step 3 : wff = notbid (step 2) |- ( x = z → ( ¬ x ∈ B ↔ ¬ z ∈ B ) ) ;;
	step 4 : wff = anbi12d (step 1, step 3) |- ( x = z → ( ( x ∈ A ∧ ¬ x ∈ B ) ↔ ( z ∈ A ∧ ¬ z ∈ B ) ) ) ;;
	step 5 : wff = cbvabv (step 4) |- { x | ( x ∈ A ∧ ¬ x ∈ B ) } = { z | ( z ∈ A ∧ ¬ z ∈ B ) } ;;
	step 6 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 7 : wff = eleq1 () |- ( z = y → ( z ∈ B ↔ y ∈ B ) ) ;;
	step 8 : wff = notbid (step 7) |- ( z = y → ( ¬ z ∈ B ↔ ¬ y ∈ B ) ) ;;
	step 9 : wff = anbi12d (step 6, step 8) |- ( z = y → ( ( z ∈ A ∧ ¬ z ∈ B ) ↔ ( y ∈ A ∧ ¬ y ∈ B ) ) ) ;;
	step 10 : wff = cbvabv (step 9) |- { z | ( z ∈ A ∧ ¬ z ∈ B ) } = { y | ( y ∈ A ∧ ¬ y ∈ B ) } ;;
	step 11 : wff = eqtri (step 5, step 10) |- { x | ( x ∈ A ∧ ¬ x ∈ B ) } = { y | ( y ∈ A ∧ ¬ y ∈ B ) } ;;
	qed prop 1 = step 11 ;;
}

/* Define class difference, also called relative complement.  Definition
       5.12 of [TakeutiZaring] p. 20.  For example,
       ` ( { 1 , 3 } \ { 1 , 8 } ) = { 3 } ` ( ~ ex-dif ).  Contrast this
       operation with union ` ( A u. B ) ` ( ~ df-un ) and intersection
       ` ( A i^i B ) ` ( ~ df-in ).  Several notations are used in the
       literature; we chose the ` \ ` convention used in Definition 5.3 of
       [Eisenberg] p. 67 instead of the more common minus sign to reserve the
       latter for later use in, e.g., arithmetic.  We will use the
       terminology " ` A ` excludes ` B ` " to mean ` A \ B ` .  We will
       use " ` B ` is removed from ` A ` " to mean ` A \ { B } ` i.e. the
       removal of an element or equivalently the exclusion of a singleton.
       (Contributed by NM, 29-Apr-1994.) */

definition df-dif (x : set, A : class, B : class) disjointed(x A, x B) {
	defiendum : class = # ( A ∖ B ) ;;
	definiens : class = # { x | ( x ∈ A ∧ ¬ x ∈ B ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Soundness justification theorem for ~ df-un .  (Contributed by Rodolfo
       Medina, 28-Apr-2010.)  (Proof shortened by Andrew Salmon,
       9-Jul-2011.) */

theorem unjust (x : set, y : set, A : class, B : class) disjointed(x A, x B, y A, y B, z x, z y, z A, z B) {
	prop 1 : wff = |- { x | ( x ∈ A ∨ x ∈ B ) } = { y | ( y ∈ A ∨ y ∈ B ) } ;;
}

proof of unjust {
	var z : set;;
	step 1 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 2 : wff = eleq1 () |- ( x = z → ( x ∈ B ↔ z ∈ B ) ) ;;
	step 3 : wff = orbi12d (step 1, step 2) |- ( x = z → ( ( x ∈ A ∨ x ∈ B ) ↔ ( z ∈ A ∨ z ∈ B ) ) ) ;;
	step 4 : wff = cbvabv (step 3) |- { x | ( x ∈ A ∨ x ∈ B ) } = { z | ( z ∈ A ∨ z ∈ B ) } ;;
	step 5 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 6 : wff = eleq1 () |- ( z = y → ( z ∈ B ↔ y ∈ B ) ) ;;
	step 7 : wff = orbi12d (step 5, step 6) |- ( z = y → ( ( z ∈ A ∨ z ∈ B ) ↔ ( y ∈ A ∨ y ∈ B ) ) ) ;;
	step 8 : wff = cbvabv (step 7) |- { z | ( z ∈ A ∨ z ∈ B ) } = { y | ( y ∈ A ∨ y ∈ B ) } ;;
	step 9 : wff = eqtri (step 4, step 8) |- { x | ( x ∈ A ∨ x ∈ B ) } = { y | ( y ∈ A ∨ y ∈ B ) } ;;
	qed prop 1 = step 9 ;;
}

/* Define the union of two classes.  Definition 5.6 of [TakeutiZaring]
       p. 16.  For example, ` ( { 1 , 3 } u. { 1 , 8 } ) = { 1 , 3 , 8 } `
       ( ~ ex-un ).  Contrast this operation with difference ` ( A \ B ) `
       ( ~ df-dif ) and intersection ` ( A i^i B ) ` ( ~ df-in ).  For an
       alternate definition in terms of class difference, requiring no dummy
       variables, see ~ dfun2 .  For union defined in terms of intersection,
       see ~ dfun3 .  (Contributed by NM, 23-Aug-1993.) */

definition df-un (x : set, A : class, B : class) disjointed(x A, x B) {
	defiendum : class = # ( A ∪ B ) ;;
	definiens : class = # { x | ( x ∈ A ∨ x ∈ B ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Soundness justification theorem for ~ df-in .  (Contributed by Rodolfo
       Medina, 28-Apr-2010.)  (Proof shortened by Andrew Salmon,
       9-Jul-2011.) */

theorem injust (x : set, y : set, A : class, B : class) disjointed(x A, x B, y A, y B, z x, z y, z A, z B) {
	prop 1 : wff = |- { x | ( x ∈ A ∧ x ∈ B ) } = { y | ( y ∈ A ∧ y ∈ B ) } ;;
}

proof of injust {
	var z : set;;
	step 1 : wff = eleq1 () |- ( x = z → ( x ∈ A ↔ z ∈ A ) ) ;;
	step 2 : wff = eleq1 () |- ( x = z → ( x ∈ B ↔ z ∈ B ) ) ;;
	step 3 : wff = anbi12d (step 1, step 2) |- ( x = z → ( ( x ∈ A ∧ x ∈ B ) ↔ ( z ∈ A ∧ z ∈ B ) ) ) ;;
	step 4 : wff = cbvabv (step 3) |- { x | ( x ∈ A ∧ x ∈ B ) } = { z | ( z ∈ A ∧ z ∈ B ) } ;;
	step 5 : wff = eleq1 () |- ( z = y → ( z ∈ A ↔ y ∈ A ) ) ;;
	step 6 : wff = eleq1 () |- ( z = y → ( z ∈ B ↔ y ∈ B ) ) ;;
	step 7 : wff = anbi12d (step 5, step 6) |- ( z = y → ( ( z ∈ A ∧ z ∈ B ) ↔ ( y ∈ A ∧ y ∈ B ) ) ) ;;
	step 8 : wff = cbvabv (step 7) |- { z | ( z ∈ A ∧ z ∈ B ) } = { y | ( y ∈ A ∧ y ∈ B ) } ;;
	step 9 : wff = eqtri (step 4, step 8) |- { x | ( x ∈ A ∧ x ∈ B ) } = { y | ( y ∈ A ∧ y ∈ B ) } ;;
	qed prop 1 = step 9 ;;
}

/* Define the intersection of two classes.  Definition 5.6 of
       [TakeutiZaring] p. 16.  For example,
       ` ( { 1 , 3 } i^i { 1 , 8 } ) = { 1 } ` ( ~ ex-in ).  Contrast this
       operation with union ` ( A u. B ) ` ( ~ df-un ) and difference
       ` ( A \ B ) ` ( ~ df-dif ).  For alternate definitions in terms of class
       difference, requiring no dummy variables, see ~ dfin2 and ~ dfin4 .  For
       intersection defined in terms of union, see ~ dfin3 .  (Contributed by
       NM, 29-Apr-1994.) */

definition df-in (x : set, A : class, B : class) disjointed(x A, x B) {
	defiendum : class = # ( A ∩ B ) ;;
	definiens : class = # { x | ( x ∈ A ∧ x ∈ B ) } ;;
	-----------------------
	prop : wff = |- defiendum = definiens ;;
}

/* Alternate definition for the intersection of two classes.  (Contributed
       by NM, 6-Jul-2005.) */

theorem dfin5 (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∩ B ) = { x ∈ A | x ∈ B } ;;
}

proof of dfin5 {
	step 1 : wff = df-in () |- ( A ∩ B ) = { x | ( x ∈ A ∧ x ∈ B ) } ;;
	step 2 : wff = df-rab () |- { x ∈ A | x ∈ B } = { x | ( x ∈ A ∧ x ∈ B ) } ;;
	step 3 : wff = eqtr4i (step 1, step 2) |- ( A ∩ B ) = { x ∈ A | x ∈ B } ;;
	qed prop 1 = step 3 ;;
}

/* Alternate definition of class difference.  (Contributed by NM,
       25-Mar-2004.) */

theorem dfdif2 (x : set, A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A ∖ B ) = { x ∈ A | ¬ x ∈ B } ;;
}

proof of dfdif2 {
	step 1 : wff = df-dif () |- ( A ∖ B ) = { x | ( x ∈ A ∧ ¬ x ∈ B ) } ;;
	step 2 : wff = df-rab () |- { x ∈ A | ¬ x ∈ B } = { x | ( x ∈ A ∧ ¬ x ∈ B ) } ;;
	step 3 : wff = eqtr4i (step 1, step 2) |- ( A ∖ B ) = { x ∈ A | ¬ x ∈ B } ;;
	qed prop 1 = step 3 ;;
}

/* Expansion of membership in a class difference.  (Contributed by NM,
       29-Apr-1994.) */

theorem eldif (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( A ∈ ( B ∖ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
}

proof of eldif {
	var x : set;;
	step 1 : wff = elex () |- ( A ∈ ( B ∖ C ) → A ∈ _V ) ;;
	step 2 : wff = elex () |- ( A ∈ B → A ∈ _V ) ;;
	step 3 : wff = adantr (step 2) |- ( ( A ∈ B ∧ ¬ A ∈ C ) → A ∈ _V ) ;;
	step 4 : wff = eleq1 () |- ( x = A → ( x ∈ B ↔ A ∈ B ) ) ;;
	step 5 : wff = eleq1 () |- ( x = A → ( x ∈ C ↔ A ∈ C ) ) ;;
	step 6 : wff = notbid (step 5) |- ( x = A → ( ¬ x ∈ C ↔ ¬ A ∈ C ) ) ;;
	step 7 : wff = anbi12d (step 4, step 6) |- ( x = A → ( ( x ∈ B ∧ ¬ x ∈ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ) ;;
	step 8 : wff = df-dif () |- ( B ∖ C ) = { x | ( x ∈ B ∧ ¬ x ∈ C ) } ;;
	step 9 : wff = elab2g (step 7, step 8) |- ( A ∈ _V → ( A ∈ ( B ∖ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ) ;;
	step 10 : wff = pm5.21nii (step 1, step 3, step 9) |- ( A ∈ ( B ∖ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
	qed prop 1 = step 10 ;;
}

/* If a class is in one class and not another, it is also in their
       difference.  One-way deduction form of ~ eldif .  (Contributed by David
       Moews, 1-May-2017.) */

theorem eldifd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ph → ¬ A ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ ( B ∖ C ) ) ;;
}

proof of eldifd {
	step 1 : wff = eldif () |- ( A ∈ ( B ∖ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
	step 2 : wff = sylanbrc (hyp 1, hyp 2, step 1) |- ( ph → A ∈ ( B ∖ C ) ) ;;
	qed prop 1 = step 2 ;;
}

/* If a class is in the difference of two classes, it is also in the
       minuend.  One-way deduction form of ~ eldif .  (Contributed by David
       Moews, 1-May-2017.) */

theorem eldifad (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ ( B ∖ C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ B ) ;;
}

proof of eldifad {
	step 1 : wff = eldif () |- ( A ∈ ( B ∖ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
	step 3 : wff = simpld (step 2) |- ( ph → A ∈ B ) ;;
	qed prop 1 = step 3 ;;
}

/* If a class is in the difference of two classes, it is not in the
       subtrahend.  One-way deduction form of ~ eldif .  (Contributed by David
       Moews, 1-May-2017.) */

theorem eldifbd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ ( B ∖ C ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ A ∈ C ) ;;
}

proof of eldifbd {
	step 1 : wff = eldif () |- ( A ∈ ( B ∖ C ) ↔ ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → ( A ∈ B ∧ ¬ A ∈ C ) ) ;;
	step 3 : wff = simprd (step 2) |- ( ph → ¬ A ∈ C ) ;;
	qed prop 1 = step 3 ;;
}


