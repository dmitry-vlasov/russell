import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_start_with_the_Axiom_of_Extensionality/Introduce_the_Axiom_of_Extensionality.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                   Class abstractions (a.k.a. class builders)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Declare new constants use in class definition. */

constant {
	symbol { ;;
	ascii { ;;
	latex \{ ;;
}

/*Left brace */

constant {
	symbol | ;;
}

/*Vertical bar */

constant {
	symbol } ;;
	ascii } ;;
	latex \} ;;
}

/*Right brace */

/*--- Start of old code before overloading prevention patch. */

/*@c class @. @( Class variable type @)
  */

/*--- End of old code before overloading prevention patch. */

/*Declare symbols as variables */

/*Declare variable symbols that will be used to represent classes.  Note
     that later on ` R ` , ` S ` , ` F ` and ` G ` denote relations and
     functions, but these letters serve as mnemonics only and in fact behave
     no differently from the variables ` A ` through ` D ` . */

/*Introduce the class builder or class abstraction notation ("the class of
     sets ` x ` such that ` ph ` is true").  Our class variables ` A ` ,
     ` B ` , etc. range over class builders (implicitly in the case of defined
     class terms such as ~ df-nul ).  Note that a set variable can be expressed
     as a class builder per theorem ~ cvjust , justifying the assignment of set
     variables to class variables via the use of ~ cv . */

rule cab (ph : wff, x : set) {
	term : class = # { x | ph } ;;
}

/*--- Start of old code before overloading prevention patch. */

/*@( A set variable is a class expression.  The syntax " ` class x ` " can be
     viewed as an abbreviation for " ` class { y | y e. x } ` " (a special case
     of ~ cab ), where ` y ` is distinct from ` x ` .  See the discussion under
     the definition of class in [Jech] p. 4.  Note that ` { y | y e. x } = x `
     by ~ cvjust . @)
  cv @a class x @.
  */

/*--- End of old code before overloading prevention patch. */

/*$j primitive 'cv' 'wceq' 'wcel' 'cab'; */

/*Let ` A ` be a class variable. */

/*Let ` B ` be a class variable. */

/*Let ` C ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` D ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` P ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` Q ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` R ` be a class variable. */

/*Let ` S ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` T ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` U ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` e ` be an individual variable. */

/*Let ` f ` be an individual variable. */

/*Let ` g ` be an individual variable. */

/*Let ` h ` be an individual variable. */

/*Let ` i ` be an individual variable. */

/*Let ` j ` be an individual variable. */

/*Let ` k ` be an individual variable. */

/*Let ` m ` be an individual variable. */

/*Let ` n ` be an individual variable. */

/*Let ` o ` be an individual variable. */

/*Let ` E ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` F ` be a class variable. */

/*Let ` G ` be a class variable. */

/*Let ` H ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` I ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` J ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` K ` be a class variable. */

/*Let ` L ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` M ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` N ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` O ` be a class variable. */

/*Let ` V ` be a class variable. */

/*Let ` W ` be a class variable. */

/*Let ` X ` be a class variable. */

/*Let ` Y ` be a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Define a connective symbol for use as a class variable. */

/*Let ` Z ` be a class variable. */

/*Let ` s ` be an individual variable. */

/*Let ` r ` be an individual variable. */

/*Let ` q ` be an individual variable. */

/*Let ` p ` be an individual variable. */

/*Let ` a ` be an individual variable. */

/*Let ` b ` be an individual variable. */

/*Let ` c ` be an individual variable. */

/*Let ` d ` be an individual variable. */

/*Let ` l ` be an individual variable. */

/*--- Start of old code before overloading prevention patch. */

/*@( Extend wff definition to include class equality. @)
  wceq @a wff A = B @.
  */

/*--- End of old code before overloading prevention patch. */

/*--- Start of old code before overloading prevention patch. */

/*@( Extend wff definition to include the membership connective between
     classes. @)
  wcel @a wff A e. B @.
  */

/*--- End of old code before overloading prevention patch. */

/*Define class abstraction notation (so-called by Quine), also called a
     "class builder" in the literature. ` x ` and ` y ` need not be distinct.
     Definition 2.1 of [Quine] p. 16.  Typically, ` ph ` will have ` y ` as a
     free variable, and " ` { y | ph } ` " is read "the class of all sets ` y `
     such that ` ph ( y ) ` is true."  We do not define ` { y | ph } ` in
     isolation but only as part of an expression that extends or "overloads"
     the ` e. ` relationship.

     This is our first use of the ` e. ` symbol to connect classes instead of
     sets.  The syntax definition ~ wcel , which extends or "overloads" the
     ~ wel definition connecting set variables, requires that both sides of
     ` e. ` be a class.  In ~ df-cleq and ~ df-clel , we introduce a new kind
     of variable (class variable) that can substituted with expressions such as
     ` { y | ph } ` .  In the present definition, the ` x ` on the left-hand
     side is a set variable.  Syntax definition ~ cv allows us to substitute a
     set variable ` x ` for a class variable: all sets are classes by ~ cvjust
     (but not necessarily vice-versa).  For a full description of how classes
     are introduced and how to recover the primitive language, see the
     discussion in Quine (and under ~ abeq2 for a quick overview).

     Because class variables can be substituted with compound expressions and
     set variables cannot, it is often useful to convert a theorem containing a
     free set variable to a more general version with a class variable.  This
     is done with theorems such as ~ vtoclg which is used, for example, to
     convert ~ elirrv to ~ elirr .

     This is called the "axiom of class comprehension" by [Levy] p. 338, who
     treats the theory of classes as an extralogical extension to our logic and
     set theory axioms.  He calls the construction ` { y | ph } ` a "class
     term".

     For a general discussion of the theory of classes, see
     ~ http://us.metamath.org/mpeuni/mmset.html#class .  (Contributed by NM,
     5-Aug-1993.) */

definition df-clab (ph : wff, x : set, y : set)  {
	defiendum : wff = # x ∈ { y | ph } ;;
	definiens : wff = # [ x / y ] ph ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Simplification of class abstraction notation when the free and bound
     variables are identical.  (Contributed by NM, 5-Aug-1993.) */

theorem abid (ph : wff, x : set)  {
	prop 1 : wff = |- ( x ∈ { x | ph } ↔ ph ) ;;
}

proof of abid {
	step 1 : wff = df-clab () |- ( x ∈ { x | ph } ↔ [ x / x ] ph ) ;;
	step 2 : wff = sbid () |- ( [ x / x ] ph ↔ ph ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( x ∈ { x | ph } ↔ ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by NM, 5-Aug-1993.) */

theorem hbab1 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( y ∈ { x | ph } → ∀ x y ∈ { x | ph } ) ;;
}

proof of hbab1 {
	step 1 : wff = df-clab () |- ( y ∈ { x | ph } ↔ [ y / x ] ph ) ;;
	step 2 : wff = hbs1 () |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
	step 3 : wff = hbxfrbi (step 1, step 2) |- ( y ∈ { x | ph } → ∀ x y ∈ { x | ph } ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 11-Aug-2016.) */

theorem nfsab1 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- F/ x y ∈ { x | ph } ;;
}

proof of nfsab1 {
	step 1 : wff = hbab1 () |- ( y ∈ { x | ph } → ∀ x y ∈ { x | ph } ) ;;
	step 2 : wff = nfi (step 1) |- F/ x y ∈ { x | ph } ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by NM, 1-Mar-1995.) */

theorem hbab (ph : wff, x : set, y : set, z : set) disjointed(x z) {
	hyp 1 : wff = |- ( ph → ∀ x ph ) ;;
	-----------------------
	prop 1 : wff = |- ( z ∈ { y | ph } → ∀ x z ∈ { y | ph } ) ;;
}

proof of hbab {
	step 1 : wff = df-clab () |- ( z ∈ { y | ph } ↔ [ z / y ] ph ) ;;
	step 2 : wff = hbsb (hyp 1) |- ( [ z / y ] ph → ∀ x [ z / y ] ph ) ;;
	step 3 : wff = hbxfrbi (step 1, step 2) |- ( z ∈ { y | ph } → ∀ x z ∈ { y | ph } ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for a class abstraction.  (Contributed
       by Mario Carneiro, 11-Aug-2016.) */

theorem nfsab (ph : wff, x : set, y : set, z : set) disjointed(x z) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x z ∈ { y | ph } ;;
}

proof of nfsab {
	step 1 : wff = nfri (hyp 1) |- ( ph → ∀ x ph ) ;;
	step 2 : wff = hbab (step 1) |- ( z ∈ { y | ph } → ∀ x z ∈ { y | ph } ) ;;
	step 3 : wff = nfi (step 2) |- F/ x z ∈ { y | ph } ;;
	qed prop 1 = step 3 ;;
}

/*Define the equality connective between classes.  Definition 2.7 of
       [Quine] p. 18.  Also Definition 4.5 of [TakeutiZaring] p. 13; Chapter 4
       provides its justification and methods for eliminating it.  Note that
       its elimination will not necessarily result in a single wff in the
       original language but possibly a "scheme" of wffs.

       This is an example of a somewhat "risky" definition, meaning that it has
       a more complex than usual soundness justification (outside of Metamath),
       because it "overloads" or reuses the existing equality symbol rather
       than introducing a new symbol.  This allows us to make statements that
       may not hold for the original symbol.  For example, it permits us to
       deduce ` y = z <-> A. x ( x e. y <-> x e. z ) ` , which is not a theorem
       of logic but rather presupposes the Axiom of Extensionality (see theorem
       ~ axext4 ).  We therefore include this axiom as a hypothesis, so that
       the use of Extensionality is properly indicated.

       We could avoid this complication by introducing a new symbol, say =_2,
       in place of ` = ` .  This would also have the advantage of making
       elimination of the definition straightforward, so that we could
       eliminate Extensionality as a hypothesis.  We would then also have the
       advantage of being able to identify in various proofs exactly where
       Extensionality truly comes into play rather than just being an artifact
       of a definition.  One of our theorems would then be ` x ` =_2
       ` y <-> x = y ` by invoking Extensionality.

       However, to conform to literature usage, we retain this overloaded
       definition.  This also makes some proofs shorter and probably easier to
       read, without the constant switching between two kinds of equality.

       See also comments under ~ df-clab , ~ df-clel , and ~ abeq2 .

       In the form of ~ dfcleq , this is called the "axiom of extensionality"
       by [Levy] p. 338, who treats the theory of classes as an extralogical
       extension to our logic and set theory axioms.

       For a general discussion of the theory of classes, see
       ~ http://us.metamath.org/mpeuni/mmset.html#class .  (Contributed by NM,
       15-Sep-1993.) */

definition df-cleq (x : set, y : set, z : set, A : class, B : class) disjointed(x A, x B, x y z) {
	hyp 1 : wff = |- ( ∀ x ( x ∈ y ↔ x ∈ z ) → y = z ) ;;
	defiendum : wff = # A = B ;;
	definiens : wff = # ∀ x ( x ∈ A ↔ x ∈ B ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*The same as ~ df-cleq with the hypothesis removed using the Axiom of
       Extensionality ~ ax-ext .  (Contributed by NM, 15-Sep-1993.) */

theorem dfcleq (x : set, A : class, B : class) disjointed(x A, x B, x y z) {
	prop 1 : wff = |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
}

proof of dfcleq {
	var y : set, z : set;;
	step 1 : wff = ax-ext () |- ( ∀ x ( x ∈ y ↔ x ∈ z ) → y = z ) ;;
	step 2 : wff = df-cleq (step 1) |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Every set is a class.  Proposition 4.9 of [TakeutiZaring] p. 13.  This
       theorem shows that a set variable can be expressed as a class
       abstraction.  This provides a motivation for the class syntax
       construction ~ cv , which allows us to substitute a set variable for a
       class variable.  See also ~ cab and ~ df-clab .  Note that this is not a
       rigorous justification, because ~ cv is used as part of the proof of
       this theorem, but a careful argument can be made outside of the
       formalism of Metamath, for example as is done in Chapter 4 of Takeuti
       and Zaring.  See also the discussion under the definition of class in
       [Jech] p. 4 showing that "Every set can be considered to be a class."
       (Contributed by NM, 7-Nov-2006.) */

theorem cvjust (x : set, y : set) disjointed(x y z) {
	prop 1 : wff = |- x = { y | y ∈ x } ;;
}

proof of cvjust {
	var z : set;;
	step 1 : wff = dfcleq () |- ( x = { y | y ∈ x } ↔ ∀ z ( z ∈ x ↔ z ∈ { y | y ∈ x } ) ) ;;
	step 2 : wff = df-clab () |- ( z ∈ { y | y ∈ x } ↔ [ z / y ] y ∈ x ) ;;
	step 3 : wff = elsb3 () |- ( [ z / y ] y ∈ x ↔ z ∈ x ) ;;
	step 4 : wff = bitr2i (step 2, step 3) |- ( z ∈ x ↔ z ∈ { y | y ∈ x } ) ;;
	step 5 : wff = mpgbir (step 1, step 4) |- x = { y | y ∈ x } ;;
	qed prop 1 = step 5 ;;
}

/*Define the membership connective between classes.  Theorem 6.3 of
       [Quine] p. 41, or Proposition 4.6 of [TakeutiZaring] p. 13, which we
       adopt as a definition.  See these references for its metalogical
       justification.  Note that like ~ df-cleq it extends or "overloads" the
       use of the existing membership symbol, but unlike ~ df-cleq it does not
       strengthen the set of valid wffs of logic when the class variables are
       replaced with set variables (see ~ cleljust ), so we don't include any
       set theory axiom as a hypothesis.  See also comments about the syntax
       under ~ df-clab .  Alternate definitions of ` A e. B ` (but that require
       either ` A ` or ` B ` to be a set) are shown by ~ clel2 , ~ clel3 , and
       ~ clel4 .

       This is called the "axiom of membership" by [Levy] p. 338, who treats
       the theory of classes as an extralogical extension to our logic and set
       theory axioms.

       For a general discussion of the theory of classes, see
       ~ http://us.metamath.org/mpeuni/mmset.html#class .  (Contributed by NM,
       5-Aug-1993.) */

definition df-clel (x : set, A : class, B : class) disjointed(x A, x B) {
	defiendum : wff = # A ∈ B ;;
	definiens : wff = # ∃ x ( x = A ∧ x ∈ B ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Infer equality of classes from equivalence of membership.  (Contributed
       by NM, 5-Aug-1993.) */

theorem eqriv (x : set, A : class, B : class) disjointed(x A, x B) {
	hyp 1 : wff = |- ( x ∈ A ↔ x ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- A = B ;;
}

proof of eqriv {
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 2 : wff = mpgbir (step 1, hyp 1) |- A = B ;;
	qed prop 1 = step 2 ;;
}

/*Deduce equality of classes from equivalence of membership.  (Contributed
       by NM, 17-Mar-1996.) */

theorem eqrdv (ph : wff, x : set, A : class, B : class) disjointed(x A, x B, x ph) {
	hyp 1 : wff = |- ( ph → ( x ∈ A ↔ x ∈ B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = B ) ;;
}

proof of eqrdv {
	step 1 : wff = alrimiv (hyp 1) |- ( ph → ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 2 : wff = dfcleq () |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ph → A = B ) ;;
	qed prop 1 = step 3 ;;
}

/*Deduce equality of classes from an equivalence of membership that
       depends on the membership variable.  (Contributed by NM, 7-Nov-2008.) */

theorem eqrdav (ph : wff, x : set, A : class, B : class, C : class) disjointed(x A, x B, x ph) {
	hyp 1 : wff = |- ( ( ph ∧ x ∈ A ) → x ∈ C ) ;;
	hyp 2 : wff = |- ( ( ph ∧ x ∈ B ) → x ∈ C ) ;;
	hyp 3 : wff = |- ( ( ph ∧ x ∈ C ) → ( x ∈ A ↔ x ∈ B ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = B ) ;;
}

proof of eqrdav {
	step 1 : wff = biimpd (hyp 3) |- ( ( ph ∧ x ∈ C ) → ( x ∈ A → x ∈ B ) ) ;;
	step 2 : wff = impancom (step 1) |- ( ( ph ∧ x ∈ A ) → ( x ∈ C → x ∈ B ) ) ;;
	step 3 : wff = mpd (hyp 1, step 2) |- ( ( ph ∧ x ∈ A ) → x ∈ B ) ;;
	step 4 : wff = exbiri (hyp 3) |- ( ph → ( x ∈ C → ( x ∈ B → x ∈ A ) ) ) ;;
	step 5 : wff = com23 (step 4) |- ( ph → ( x ∈ B → ( x ∈ C → x ∈ A ) ) ) ;;
	step 6 : wff = imp (step 5) |- ( ( ph ∧ x ∈ B ) → ( x ∈ C → x ∈ A ) ) ;;
	step 7 : wff = mpd (hyp 2, step 6) |- ( ( ph ∧ x ∈ B ) → x ∈ A ) ;;
	step 8 : wff = impbida (step 3, step 7) |- ( ph → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 9 : wff = eqrdv (step 8) |- ( ph → A = B ) ;;
	qed prop 1 = step 9 ;;
}

/*Law of identity (reflexivity of class equality).  Theorem 6.4 of [Quine]
       p. 41.

       This law is thought to have originated with Aristotle (_Metaphysics_,
       Zeta, 17, 1041 a, 10-20:  "Therefore, inquiring why a thing is itself,
       it's inquiring nothing; ... saying that the thing is itself constitutes
       the sole reasoning and the sole cause, in every case, to the question of
       why the man is man or the musician musician.").  (Thanks to Stefan Allan
       and Beno&icirc;t Jubin for this information.)  (Contributed by NM,
       5-Aug-1993.)  (Revised by Beno&icirc;t Jubin, 14-Oct-2017.) */

theorem eqid (A : class) disjointed(x A) {
	prop 1 : wff = |- A = A ;;
}

proof of eqid {
	var x : set;;
	step 1 : wff = biid () |- ( x ∈ A ↔ x ∈ A ) ;;
	step 2 : wff = eqriv (step 1) |- A = A ;;
	qed prop 1 = step 2 ;;
}

/*Class identity law with antecedent.  (Contributed by NM, 21-Aug-2008.) */

theorem eqidd (ph : wff, A : class)  {
	prop 1 : wff = |- ( ph → A = A ) ;;
}

proof of eqidd {
	step 1 : wff = eqid () |- A = A ;;
	step 2 : wff = a1i (step 1) |- ( ph → A = A ) ;;
	qed prop 1 = step 2 ;;
}

/*Commutative law for class equality.  Theorem 6.5 of [Quine] p. 41.
       (Contributed by NM, 5-Aug-1993.) */

theorem eqcom (A : class, B : class) disjointed(x A, x B) {
	prop 1 : wff = |- ( A = B ↔ B = A ) ;;
}

proof of eqcom {
	var x : set;;
	step 1 : wff = bicom () |- ( ( x ∈ A ↔ x ∈ B ) ↔ ( x ∈ B ↔ x ∈ A ) ) ;;
	step 2 : wff = albii (step 1) |- ( ∀ x ( x ∈ A ↔ x ∈ B ) ↔ ∀ x ( x ∈ B ↔ x ∈ A ) ) ;;
	step 3 : wff = dfcleq () |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 4 : wff = dfcleq () |- ( B = A ↔ ∀ x ( x ∈ B ↔ x ∈ A ) ) ;;
	step 5 : wff = 3bitr4i (step 2, step 3, step 4) |- ( A = B ↔ B = A ) ;;
	qed prop 1 = step 5 ;;
}

/*Inference applying commutative law for class equality to an antecedent.
       (Contributed by NM, 5-Aug-1993.) */

theorem eqcoms (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( A = B → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( B = A → ph ) ;;
}

proof of eqcoms {
	step 1 : wff = eqcom () |- ( B = A ↔ A = B ) ;;
	step 2 : wff = sylbi (step 1, hyp 1) |- ( B = A → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from commutative law for class equality.  (Contributed by NM,
       5-Aug-1993.) */

theorem eqcomi (A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- B = A ;;
}

proof of eqcomi {
	step 1 : wff = eqcom () |- ( A = B ↔ B = A ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- B = A ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from commutative law for class equality.  (Contributed by NM,
       15-Aug-1994.) */

theorem eqcomd (ph : wff, A : class, B : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → B = A ) ;;
}

proof of eqcomd {
	step 1 : wff = eqcom () |- ( A = B ↔ B = A ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → B = A ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality implies equivalence of equalities.  (Contributed by NM,
       5-Aug-1993.) */

theorem eqeq1 (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( A = B → ( A = C ↔ B = C ) ) ;;
}

proof of eqeq1 {
	var x : set;;
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( A = B → ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = 19.21bi (step 2) |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 4 : wff = bibi1d (step 3) |- ( A = B → ( ( x ∈ A ↔ x ∈ C ) ↔ ( x ∈ B ↔ x ∈ C ) ) ) ;;
	step 5 : wff = albidv (step 4) |- ( A = B → ( ∀ x ( x ∈ A ↔ x ∈ C ) ↔ ∀ x ( x ∈ B ↔ x ∈ C ) ) ) ;;
	step 6 : wff = dfcleq () |- ( A = C ↔ ∀ x ( x ∈ A ↔ x ∈ C ) ) ;;
	step 7 : wff = dfcleq () |- ( B = C ↔ ∀ x ( x ∈ B ↔ x ∈ C ) ) ;;
	step 8 : wff = 3bitr4g (step 5, step 6, step 7) |- ( A = B → ( A = C ↔ B = C ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Inference from equality to equivalence of equalities.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eqeq1i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A = C ↔ B = C ) ;;
}

proof of eqeq1i {
	step 1 : wff = eqeq1 () |- ( A = B → ( A = C ↔ B = C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A = C ↔ B = C ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from equality to equivalence of equalities.  (Contributed by
       NM, 27-Dec-1993.) */

theorem eqeq1d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A = C ↔ B = C ) ) ;;
}

proof of eqeq1d {
	step 1 : wff = eqeq1 () |- ( A = B → ( A = C ↔ B = C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A = C ↔ B = C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality implies equivalence of equalities.  (Contributed by NM,
     5-Aug-1993.) */

theorem eqeq2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A = B → ( C = A ↔ C = B ) ) ;;
}

proof of eqeq2 {
	step 1 : wff = eqeq1 () |- ( A = B → ( A = C ↔ B = C ) ) ;;
	step 2 : wff = eqcom () |- ( C = A ↔ A = C ) ;;
	step 3 : wff = eqcom () |- ( C = B ↔ B = C ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( A = B → ( C = A ↔ C = B ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Inference from equality to equivalence of equalities.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eqeq2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C = A ↔ C = B ) ;;
}

proof of eqeq2i {
	step 1 : wff = eqeq2 () |- ( A = B → ( C = A ↔ C = B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C = A ↔ C = B ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from equality to equivalence of equalities.  (Contributed by
       NM, 27-Dec-1993.) */

theorem eqeq2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C = A ↔ C = B ) ) ;;
}

proof of eqeq2d {
	step 1 : wff = eqeq2 () |- ( A = B → ( C = A ↔ C = B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C = A ↔ C = B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Equality relationship among 4 classes.  (Contributed by NM,
     3-Aug-1994.) */

theorem eqeq12 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → ( A = C ↔ B = D ) ) ;;
}

proof of eqeq12 {
	step 1 : wff = eqeq1 () |- ( A = B → ( A = C ↔ B = C ) ) ;;
	step 2 : wff = eqeq2 () |- ( C = D → ( B = C ↔ B = D ) ) ;;
	step 3 : wff = sylan9bb (step 1, step 2) |- ( ( A = B ∧ C = D ) → ( A = C ↔ B = D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A useful inference for substituting definitions into an equality.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Andrew Salmon,
       25-May-2011.) */

theorem eqeq12i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A = C ↔ B = D ) ;;
}

proof of eqeq12i {
	step 1 : wff = eqeq12 () |- ( ( A = B ∧ C = D ) → ( A = C ↔ B = D ) ) ;;
	step 2 : wff = mp2an (hyp 1, hyp 2, step 1) |- ( A = C ↔ B = D ) ;;
	qed prop 1 = step 2 ;;
}

/*Theorem eqeq12i is the congruence law for equality. */

/*$j congruence 'eqeq12i'; */

/*A useful inference for substituting definitions into an equality.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Andrew Salmon,
       25-May-2011.) */

theorem eqeq12d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A = C ↔ B = D ) ) ;;
}

proof of eqeq12d {
	step 1 : wff = eqeq12 () |- ( ( A = B ∧ C = D ) → ( A = C ↔ B = D ) ) ;;
	step 2 : wff = syl2anc (hyp 1, hyp 2, step 1) |- ( ph → ( A = C ↔ B = D ) ) ;;
	qed prop 1 = step 2 ;;
}

/*A useful inference for substituting definitions into an equality.
       (Contributed by NM, 9-Aug-1994.)  (Proof shortened by Andrew Salmon,
       25-May-2011.) */

theorem eqeqan12d (ph : wff, ps : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → ( A = C ↔ B = D ) ) ;;
}

proof of eqeqan12d {
	step 1 : wff = eqeq12 () |- ( ( A = B ∧ C = D ) → ( A = C ↔ B = D ) ) ;;
	step 2 : wff = syl2an (hyp 1, hyp 2, step 1) |- ( ( ph ∧ ps ) → ( A = C ↔ B = D ) ) ;;
	qed prop 1 = step 2 ;;
}

/*A useful inference for substituting definitions into an equality.
       (Contributed by NM, 9-Aug-1994.) */

theorem eqeqan12rd (ph : wff, ps : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps ∧ ph ) → ( A = C ↔ B = D ) ) ;;
}

proof of eqeqan12rd {
	step 1 : wff = eqeqan12d (hyp 1, hyp 2) |- ( ( ph ∧ ps ) → ( A = C ↔ B = D ) ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( ps ∧ ph ) → ( A = C ↔ B = D ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Transitive law for class equality.  Proposition 4.7(3) of [TakeutiZaring]
     p. 13.  (Contributed by NM, 25-Jan-2004.) */

theorem eqtr (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A = B ∧ B = C ) → A = C ) ;;
}

proof of eqtr {
	step 1 : wff = eqeq1 () |- ( A = B → ( A = C ↔ B = C ) ) ;;
	step 2 : wff = biimpar (step 1) |- ( ( A = B ∧ B = C ) → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*A transitive law for class equality.  (Contributed by NM, 20-May-2005.)
     (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem eqtr2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A = B ∧ A = C ) → B = C ) ;;
}

proof of eqtr2 {
	step 1 : wff = eqcom () |- ( A = B ↔ B = A ) ;;
	step 2 : wff = eqtr () |- ( ( B = A ∧ A = C ) → B = C ) ;;
	step 3 : wff = sylanb (step 1, step 2) |- ( ( A = B ∧ A = C ) → B = C ) ;;
	qed prop 1 = step 3 ;;
}

/*A transitive law for class equality.  (Contributed by NM, 20-May-2005.) */

theorem eqtr3 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A = C ∧ B = C ) → A = B ) ;;
}

proof of eqtr3 {
	step 1 : wff = eqcom () |- ( B = C ↔ C = B ) ;;
	step 2 : wff = eqtr () |- ( ( A = C ∧ C = B ) → A = B ) ;;
	step 3 : wff = sylan2b (step 1, step 2) |- ( ( A = C ∧ B = C ) → A = B ) ;;
	qed prop 1 = step 3 ;;
}

/*An equality transitivity inference.  (Contributed by NM, 5-Aug-1993.) */

theorem eqtri (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- A = C ;;
}

proof of eqtri {
	step 1 : wff = eqeq2i (hyp 2) |- ( A = B ↔ A = C ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- A = C ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity inference.  (Contributed by NM,
       21-Feb-1995.) */

theorem eqtr2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- C = A ;;
}

proof of eqtr2i {
	step 1 : wff = eqtri (hyp 1, hyp 2) |- A = C ;;
	step 2 : wff = eqcomi (step 1) |- C = A ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity inference.  (Contributed by NM, 6-May-1994.) */

theorem eqtr3i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- A = C ;;
	-----------------------
	prop 1 : wff = |- B = C ;;
}

proof of eqtr3i {
	step 1 : wff = eqcomi (hyp 1) |- B = A ;;
	step 2 : wff = eqtri (step 1, hyp 2) |- B = C ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity inference.  (Contributed by NM, 5-Aug-1993.) */

theorem eqtr4i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- A = C ;;
}

proof of eqtr4i {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- A = C ;;
	qed prop 1 = step 2 ;;
}

/*Register '=' as an equality for its type (class). */

/*$j equality 'wceq' from 'eqid' 'eqcomi' 'eqtri'; */

/*An inference from three chained equalities.  (Contributed by NM,
       29-Aug-1993.) */

theorem 3eqtri (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- B = C ;;
	hyp 3 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- A = D ;;
}

proof of 3eqtri {
	step 1 : wff = eqtri (hyp 2, hyp 3) |- B = D ;;
	step 2 : wff = eqtri (hyp 1, step 1) |- A = D ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       3-Aug-2006.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtrri (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- B = C ;;
	hyp 3 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- D = A ;;
}

proof of 3eqtrri {
	step 1 : wff = eqtri (hyp 1, hyp 2) |- A = C ;;
	step 2 : wff = eqtr2i (step 1, hyp 3) |- D = A ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       3-Aug-2006.) */

theorem 3eqtr2i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = B ;;
	hyp 3 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- A = D ;;
}

proof of 3eqtr2i {
	step 1 : wff = eqtr4i (hyp 1, hyp 2) |- A = C ;;
	step 2 : wff = eqtri (step 1, hyp 3) |- A = D ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       3-Aug-2006.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtr2ri (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = B ;;
	hyp 3 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- D = A ;;
}

proof of 3eqtr2ri {
	step 1 : wff = eqtr4i (hyp 1, hyp 2) |- A = C ;;
	step 2 : wff = eqtr2i (step 1, hyp 3) |- D = A ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       6-May-1994.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtr3i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- C = D ;;
}

proof of 3eqtr3i {
	step 1 : wff = eqtr3i (hyp 1, hyp 2) |- B = C ;;
	step 2 : wff = eqtr3i (step 1, hyp 3) |- C = D ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       15-Aug-2004.) */

theorem 3eqtr3ri (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- D = C ;;
}

proof of 3eqtr3ri {
	step 1 : wff = eqtr3i (hyp 1, hyp 2) |- B = C ;;
	step 2 : wff = eqtr3i (hyp 3, step 1) |- D = C ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       5-Aug-1993.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtr4i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- C = D ;;
}

proof of 3eqtr4i {
	step 1 : wff = eqtr4i (hyp 3, hyp 1) |- D = A ;;
	step 2 : wff = eqtr4i (hyp 2, step 1) |- C = D ;;
	qed prop 1 = step 2 ;;
}

/*An inference from three chained equalities.  (Contributed by NM,
       2-Sep-1995.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtr4ri (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- D = C ;;
}

proof of 3eqtr4ri {
	step 1 : wff = eqtr4i (hyp 3, hyp 1) |- D = A ;;
	step 2 : wff = eqtr4i (step 1, hyp 2) |- D = C ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 5-Aug-1993.) */

theorem eqtrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = C ) ;;
}

proof of eqtrd {
	step 1 : wff = eqeq2d (hyp 2) |- ( ph → ( A = B ↔ A = C ) ) ;;
	step 2 : wff = mpbid (hyp 1, step 1) |- ( ph → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM,
       18-Oct-1999.) */

theorem eqtr2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = A ) ;;
}

proof of eqtr2d {
	step 1 : wff = eqtrd (hyp 1, hyp 2) |- ( ph → A = C ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → C = A ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity equality deduction.  (Contributed by NM,
       18-Jul-1995.) */

theorem eqtr3d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → B = C ) ;;
}

proof of eqtr3d {
	step 1 : wff = eqcomd (hyp 1) |- ( ph → B = A ) ;;
	step 2 : wff = eqtrd (step 1, hyp 2) |- ( ph → B = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity equality deduction.  (Contributed by NM,
       18-Jul-1995.) */

theorem eqtr4d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = C ) ;;
}

proof of eqtr4d {
	step 1 : wff = eqcomd (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = eqtrd (hyp 1, step 1) |- ( ph → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       29-Oct-1995.) */

theorem 3eqtrd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = D ) ;;
}

proof of 3eqtrd {
	step 1 : wff = eqtrd (hyp 2, hyp 3) |- ( ph → B = D ) ;;
	step 2 : wff = eqtrd (hyp 1, step 1) |- ( ph → A = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       4-Aug-2006.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtrrd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → D = A ) ;;
}

proof of 3eqtrrd {
	step 1 : wff = eqtrd (hyp 1, hyp 2) |- ( ph → A = C ) ;;
	step 2 : wff = eqtr2d (step 1, hyp 3) |- ( ph → D = A ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3eqtr2d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = D ) ;;
}

proof of 3eqtr2d {
	step 1 : wff = eqtr4d (hyp 1, hyp 2) |- ( ph → A = C ) ;;
	step 2 : wff = eqtrd (step 1, hyp 3) |- ( ph → A = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3eqtr2rd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	hyp 3 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → D = A ) ;;
}

proof of 3eqtr2rd {
	step 1 : wff = eqtr4d (hyp 1, hyp 2) |- ( ph → A = C ) ;;
	step 2 : wff = eqtr2d (step 1, hyp 3) |- ( ph → D = A ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       4-Aug-1995.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtr3d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	hyp 3 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = D ) ;;
}

proof of 3eqtr3d {
	step 1 : wff = eqtr3d (hyp 1, hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = eqtr3d (step 1, hyp 3) |- ( ph → C = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       14-Jan-2006.) */

theorem 3eqtr3rd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	hyp 3 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → D = C ) ;;
}

proof of 3eqtr3rd {
	step 1 : wff = eqtr3d (hyp 1, hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = eqtr3d (hyp 3, step 1) |- ( ph → D = C ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       4-Aug-1995.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem 3eqtr4d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = A ) ;;
	hyp 3 : wff = |- ( ph → D = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = D ) ;;
}

proof of 3eqtr4d {
	step 1 : wff = eqtr4d (hyp 3, hyp 1) |- ( ph → D = A ) ;;
	step 2 : wff = eqtr4d (hyp 2, step 1) |- ( ph → C = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction from three chained equalities.  (Contributed by NM,
       21-Sep-1995.) */

theorem 3eqtr4rd (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = A ) ;;
	hyp 3 : wff = |- ( ph → D = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → D = C ) ;;
}

proof of 3eqtr4rd {
	step 1 : wff = eqtr4d (hyp 3, hyp 1) |- ( ph → D = A ) ;;
	step 2 : wff = eqtr4d (step 1, hyp 2) |- ( ph → D = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 5-Aug-1993.) */

theorem syl5eq (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = C ) ;;
}

proof of syl5eq {
	step 1 : wff = a1i (hyp 1) |- ( ph → A = B ) ;;
	step 2 : wff = eqtrd (step 1, hyp 2) |- ( ph → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM,
       29-Mar-1998.) */

theorem syl5req (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = A ) ;;
}

proof of syl5req {
	step 1 : wff = syl5eq (hyp 1, hyp 2) |- ( ph → A = C ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → C = A ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 5-Aug-1993.) */

theorem syl5eqr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- B = A ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = C ) ;;
}

proof of syl5eqr {
	step 1 : wff = eqcomi (hyp 1) |- A = B ;;
	step 2 : wff = syl5eq (step 1, hyp 2) |- ( ph → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM,
       29-Mar-1998.) */

theorem syl5reqr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- B = A ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = A ) ;;
}

proof of syl5reqr {
	step 1 : wff = eqcomi (hyp 1) |- A = B ;;
	step 2 : wff = syl5req (step 1, hyp 2) |- ( ph → C = A ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 5-Aug-1993.) */

theorem syl6eq (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = C ) ;;
}

proof of syl6eq {
	step 1 : wff = a1i (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = eqtrd (hyp 1, step 1) |- ( ph → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM,
       29-Mar-1998.) */

theorem syl6req (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = A ) ;;
}

proof of syl6req {
	step 1 : wff = syl6eq (hyp 1, hyp 2) |- ( ph → A = C ) ;;
	step 2 : wff = eqcomd (step 1) |- ( ph → C = A ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 5-Aug-1993.) */

theorem syl6eqr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = C ) ;;
}

proof of syl6eqr {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = syl6eq (hyp 1, step 1) |- ( ph → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM,
       29-Mar-1998.) */

theorem syl6reqr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = A ) ;;
}

proof of syl6reqr {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = syl6req (hyp 1, step 1) |- ( ph → C = A ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 8-May-1994.)
       (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem sylan9eq (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → A = C ) ;;
}

proof of sylan9eq {
	step 1 : wff = eqtr () |- ( ( A = B ∧ B = C ) → A = C ) ;;
	step 2 : wff = syl2an (hyp 1, hyp 2, step 1) |- ( ( ph ∧ ps ) → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM,
       23-Jun-2007.) */

theorem sylan9req (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → B = A ) ;;
	hyp 2 : wff = |- ( ps → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ∧ ps ) → A = C ) ;;
}

proof of sylan9req {
	step 1 : wff = eqcomd (hyp 1) |- ( ph → A = B ) ;;
	step 2 : wff = sylan9eq (step 1, hyp 2) |- ( ( ph ∧ ps ) → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*An equality transitivity deduction.  (Contributed by NM, 8-May-1994.) */

theorem sylan9eqr (ph : wff, ps : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ps → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ps ∧ ph ) → A = C ) ;;
}

proof of sylan9eqr {
	step 1 : wff = sylan9eq (hyp 1, hyp 2) |- ( ( ph ∧ ps ) → A = C ) ;;
	step 2 : wff = ancoms (step 1) |- ( ( ps ∧ ph ) → A = C ) ;;
	qed prop 1 = step 2 ;;
}

/*A chained equality inference, useful for converting from definitions.
       (Contributed by NM, 15-Nov-1994.) */

theorem 3eqtr3g (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = D ) ;;
}

proof of 3eqtr3g {
	step 1 : wff = syl5eqr (hyp 2, hyp 1) |- ( ph → C = B ) ;;
	step 2 : wff = syl6eq (step 1, hyp 3) |- ( ph → C = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A chained equality inference, useful for converting from definitions.
       (Contributed by Mario Carneiro, 6-Nov-2015.) */

theorem 3eqtr3a (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	hyp 3 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = D ) ;;
}

proof of 3eqtr3a {
	step 1 : wff = syl5eq (hyp 1, hyp 3) |- ( ph → A = D ) ;;
	step 2 : wff = eqtr3d (hyp 2, step 1) |- ( ph → C = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A chained equality inference, useful for converting to definitions.
       (Contributed by NM, 5-Aug-1993.) */

theorem 3eqtr4g (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = D ) ;;
}

proof of 3eqtr4g {
	step 1 : wff = syl5eq (hyp 2, hyp 1) |- ( ph → C = B ) ;;
	step 2 : wff = syl6eqr (step 1, hyp 3) |- ( ph → C = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A chained equality inference, useful for converting to definitions.
       (Contributed by NM, 2-Feb-2007.)  (Proof shortened by Andrew Salmon,
       25-May-2011.) */

theorem 3eqtr4a (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → C = A ) ;;
	hyp 3 : wff = |- ( ph → D = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C = D ) ;;
}

proof of 3eqtr4a {
	step 1 : wff = syl6eq (hyp 2, hyp 1) |- ( ph → C = B ) ;;
	step 2 : wff = eqtr4d (step 1, hyp 3) |- ( ph → C = D ) ;;
	qed prop 1 = step 2 ;;
}

/*A compound transitive inference for class equality.  (Contributed by NM,
       22-Jan-2004.) */

theorem eq2tri (A : class, B : class, C : class, D : class, F : class, G : class)  {
	hyp 1 : wff = |- ( A = C → D = F ) ;;
	hyp 2 : wff = |- ( B = D → C = G ) ;;
	-----------------------
	prop 1 : wff = |- ( ( A = C ∧ B = F ) ↔ ( B = D ∧ A = G ) ) ;;
}

proof of eq2tri {
	step 1 : wff = ancom () |- ( ( A = C ∧ B = D ) ↔ ( B = D ∧ A = C ) ) ;;
	step 2 : wff = eqeq2d (hyp 1) |- ( A = C → ( B = D ↔ B = F ) ) ;;
	step 3 : wff = pm5.32i (step 2) |- ( ( A = C ∧ B = D ) ↔ ( A = C ∧ B = F ) ) ;;
	step 4 : wff = eqeq2d (hyp 2) |- ( B = D → ( A = C ↔ A = G ) ) ;;
	step 5 : wff = pm5.32i (step 4) |- ( ( B = D ∧ A = C ) ↔ ( B = D ∧ A = G ) ) ;;
	step 6 : wff = 3bitr3i (step 1, step 3, step 5) |- ( ( A = C ∧ B = F ) ↔ ( B = D ∧ A = G ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality implies equivalence of membership.  (Contributed by NM,
       5-Aug-1993.) */

theorem eleq1 (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( A = B → ( A ∈ C ↔ B ∈ C ) ) ;;
}

proof of eleq1 {
	var x : set;;
	step 1 : wff = eqeq2 () |- ( A = B → ( x = A ↔ x = B ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( A = B → ( ( x = A ∧ x ∈ C ) ↔ ( x = B ∧ x ∈ C ) ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( A = B → ( ∃ x ( x = A ∧ x ∈ C ) ↔ ∃ x ( x = B ∧ x ∈ C ) ) ) ;;
	step 4 : wff = df-clel () |- ( A ∈ C ↔ ∃ x ( x = A ∧ x ∈ C ) ) ;;
	step 5 : wff = df-clel () |- ( B ∈ C ↔ ∃ x ( x = B ∧ x ∈ C ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( A = B → ( A ∈ C ↔ B ∈ C ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Equality implies equivalence of membership.  (Contributed by NM,
       5-Aug-1993.) */

theorem eleq2 (A : class, B : class, C : class) disjointed(x A, x B, x C) {
	prop 1 : wff = |- ( A = B → ( C ∈ A ↔ C ∈ B ) ) ;;
}

proof of eleq2 {
	var x : set;;
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( A = B → ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = 19.21bi (step 2) |- ( A = B → ( x ∈ A ↔ x ∈ B ) ) ;;
	step 4 : wff = anbi2d (step 3) |- ( A = B → ( ( x = C ∧ x ∈ A ) ↔ ( x = C ∧ x ∈ B ) ) ) ;;
	step 5 : wff = exbidv (step 4) |- ( A = B → ( ∃ x ( x = C ∧ x ∈ A ) ↔ ∃ x ( x = C ∧ x ∈ B ) ) ) ;;
	step 6 : wff = df-clel () |- ( C ∈ A ↔ ∃ x ( x = C ∧ x ∈ A ) ) ;;
	step 7 : wff = df-clel () |- ( C ∈ B ↔ ∃ x ( x = C ∧ x ∈ B ) ) ;;
	step 8 : wff = 3bitr4g (step 5, step 6, step 7) |- ( A = B → ( C ∈ A ↔ C ∈ B ) ) ;;
	qed prop 1 = step 8 ;;
}

/*Equality implies equivalence of membership.  (Contributed by NM,
     31-May-1999.) */

theorem eleq12 (A : class, B : class, C : class, D : class)  {
	prop 1 : wff = |- ( ( A = B ∧ C = D ) → ( A ∈ C ↔ B ∈ D ) ) ;;
}

proof of eleq12 {
	step 1 : wff = eleq1 () |- ( A = B → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = eleq2 () |- ( C = D → ( B ∈ C ↔ B ∈ D ) ) ;;
	step 3 : wff = sylan9bb (step 1, step 2) |- ( ( A = B ∧ C = D ) → ( A ∈ C ↔ B ∈ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Inference from equality to equivalence of membership.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eleq1i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ C ↔ B ∈ C ) ;;
}

proof of eleq1i {
	step 1 : wff = eleq1 () |- ( A = B → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( A ∈ C ↔ B ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from equality to equivalence of membership.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eleq2i (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	-----------------------
	prop 1 : wff = |- ( C ∈ A ↔ C ∈ B ) ;;
}

proof of eleq2i {
	step 1 : wff = eleq2 () |- ( A = B → ( C ∈ A ↔ C ∈ B ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( C ∈ A ↔ C ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*Inference from equality to equivalence of membership.  (Contributed by
         NM, 31-May-1994.) */

theorem eleq12i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- C = D ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ C ↔ B ∈ D ) ;;
}

proof of eleq12i {
	step 1 : wff = eleq2i (hyp 2) |- ( A ∈ C ↔ A ∈ D ) ;;
	step 2 : wff = eleq1i (hyp 1) |- ( A ∈ D ↔ B ∈ D ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( A ∈ C ↔ B ∈ D ) ;;
	qed prop 1 = step 3 ;;
}

/*Theorem eleq12i is the congruence law for elementhood. */

/*$j congruence 'eleq12i'; */

/*Deduction from equality to equivalence of membership.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eleq1d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ∈ C ↔ B ∈ C ) ) ;;
}

proof of eleq1d {
	step 1 : wff = eleq1 () |- ( A = B → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( A ∈ C ↔ B ∈ C ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from equality to equivalence of membership.  (Contributed by
       NM, 27-Dec-1993.) */

theorem eleq2d (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( C ∈ A ↔ C ∈ B ) ) ;;
}

proof of eleq2d {
	step 1 : wff = eleq2 () |- ( A = B → ( C ∈ A ↔ C ∈ B ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( C ∈ A ↔ C ∈ B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction from equality to equivalence of membership.  (Contributed by
         NM, 31-May-1994.) */

theorem eleq12d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → C = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( A ∈ C ↔ B ∈ D ) ) ;;
}

proof of eleq12d {
	step 1 : wff = eleq2d (hyp 2) |- ( ph → ( A ∈ C ↔ A ∈ D ) ) ;;
	step 2 : wff = eleq1d (hyp 1) |- ( ph → ( A ∈ D ↔ B ∈ D ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( A ∈ C ↔ B ∈ D ) ) ;;
	qed prop 1 = step 3 ;;
}

/*A transitive-type law relating membership and equality.  (Contributed by
     NM, 9-Apr-1994.) */

theorem eleq1a (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( A ∈ B → ( C = A → C ∈ B ) ) ;;
}

proof of eleq1a {
	step 1 : wff = eleq1 () |- ( C = A → ( C ∈ B ↔ A ∈ B ) ) ;;
	step 2 : wff = biimprcd (step 1) |- ( A ∈ B → ( C = A → C ∈ B ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eqeltri (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- B ∈ C ;;
	-----------------------
	prop 1 : wff = |- A ∈ C ;;
}

proof of eqeltri {
	step 1 : wff = eleq1i (hyp 1) |- ( A ∈ C ↔ B ∈ C ) ;;
	step 2 : wff = mpbir (hyp 2, step 1) |- A ∈ C ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eqeltrri (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- A ∈ C ;;
	-----------------------
	prop 1 : wff = |- B ∈ C ;;
}

proof of eqeltrri {
	step 1 : wff = eqcomi (hyp 1) |- B = A ;;
	step 2 : wff = eqeltri (step 1, hyp 2) |- B ∈ C ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eleqtri (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- A ∈ C ;;
}

proof of eleqtri {
	step 1 : wff = eleq2i (hyp 2) |- ( A ∈ B ↔ A ∈ C ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- A ∈ C ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       NM, 5-Aug-1993.) */

theorem eleqtrri (A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- A ∈ C ;;
}

proof of eleqtrri {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = eleqtri (hyp 1, step 1) |- A ∈ C ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation, deduction form.
       (Contributed by Raph Levien, 10-Dec-2002.) */

theorem eqeltrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → B ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of eqeltrd {
	step 1 : wff = eleq1d (hyp 1) |- ( ph → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = mpbird (hyp 2, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction that substitutes equal classes into membership.  (Contributed
       by NM, 14-Dec-2004.) */

theorem eqeltrrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → A ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → B ∈ C ) ;;
}

proof of eqeltrrd {
	step 1 : wff = eqcomd (hyp 1) |- ( ph → B = A ) ;;
	step 2 : wff = eqeltrd (step 1, hyp 2) |- ( ph → B ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction that substitutes equal classes into membership.  (Contributed
       by NM, 14-Dec-2004.) */

theorem eleqtrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of eleqtrd {
	step 1 : wff = eleq2d (hyp 2) |- ( ph → ( A ∈ B ↔ A ∈ C ) ) ;;
	step 2 : wff = mpbid (hyp 1, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Deduction that substitutes equal classes into membership.  (Contributed
       by NM, 14-Dec-2004.) */

theorem eleqtrrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of eleqtrrd {
	step 1 : wff = eqcomd (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = eleqtrd (hyp 1, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       Mario Carneiro, 6-Jan-2017.) */

theorem 3eltr3i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- C ∈ D ;;
}

proof of 3eltr3i {
	step 1 : wff = eleqtri (hyp 1, hyp 3) |- A ∈ D ;;
	step 2 : wff = eqeltrri (hyp 2, step 1) |- C ∈ D ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       Mario Carneiro, 6-Jan-2017.) */

theorem 3eltr4i (A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- C ∈ D ;;
}

proof of 3eltr4i {
	step 1 : wff = eleqtrri (hyp 1, hyp 3) |- A ∈ D ;;
	step 2 : wff = eqeltri (hyp 2, step 1) |- C ∈ D ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       Mario Carneiro, 6-Jan-2017.) */

theorem 3eltr3d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ph → A = C ) ;;
	hyp 3 : wff = |- ( ph → B = D ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C ∈ D ) ;;
}

proof of 3eltr3d {
	step 1 : wff = eleqtrd (hyp 1, hyp 3) |- ( ph → A ∈ D ) ;;
	step 2 : wff = eqeltrrd (hyp 2, step 1) |- ( ph → C ∈ D ) ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       Mario Carneiro, 6-Jan-2017.) */

theorem 3eltr4d (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- ( ph → C = A ) ;;
	hyp 3 : wff = |- ( ph → D = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → C ∈ D ) ;;
}

proof of 3eltr4d {
	step 1 : wff = eleqtrrd (hyp 1, hyp 3) |- ( ph → A ∈ D ) ;;
	step 2 : wff = eqeltrd (hyp 2, step 1) |- ( ph → C ∈ D ) ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       Mario Carneiro, 6-Jan-2017.) */

theorem 3eltr3g (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- A = C ;;
	hyp 3 : wff = |- B = D ;;
	-----------------------
	prop 1 : wff = |- ( ph → C ∈ D ) ;;
}

proof of 3eltr3g {
	step 1 : wff = eleq12i (hyp 2, hyp 3) |- ( A ∈ B ↔ C ∈ D ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → C ∈ D ) ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into membership relation.  (Contributed by
       Mario Carneiro, 6-Jan-2017.) */

theorem 3eltr4g (ph : wff, A : class, B : class, C : class, D : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- C = A ;;
	hyp 3 : wff = |- D = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → C ∈ D ) ;;
}

proof of 3eltr4g {
	step 1 : wff = eleq12i (hyp 2, hyp 3) |- ( C ∈ D ↔ A ∈ B ) ;;
	step 2 : wff = sylibr (hyp 1, step 1) |- ( ph → C ∈ D ) ;;
	qed prop 1 = step 2 ;;
}

/*B membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl5eqel (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( ph → B ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl5eqel {
	step 1 : wff = a1i (hyp 1) |- ( ph → A = B ) ;;
	step 2 : wff = eqeltrd (step 1, hyp 2) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*B membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl5eqelr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- B = A ;;
	hyp 2 : wff = |- ( ph → B ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl5eqelr {
	step 1 : wff = eqcomi (hyp 1) |- A = B ;;
	step 2 : wff = syl5eqel (step 1, hyp 2) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*B membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl5eleq (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	hyp 2 : wff = |- ( ph → B = C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl5eleq {
	step 1 : wff = a1i (hyp 1) |- ( ph → A ∈ B ) ;;
	step 2 : wff = eleqtrd (step 1, hyp 2) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*B membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl5eleqr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- A ∈ B ;;
	hyp 2 : wff = |- ( ph → C = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl5eleqr {
	step 1 : wff = eqcomd (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = syl5eleq (hyp 1, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*A membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl6eqel (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- B ∈ C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl6eqel {
	step 1 : wff = a1i (hyp 2) |- ( ph → B ∈ C ) ;;
	step 2 : wff = eqeltrd (hyp 1, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*A membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl6eqelr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → B = A ) ;;
	hyp 2 : wff = |- B ∈ C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl6eqelr {
	step 1 : wff = eqcomd (hyp 1) |- ( ph → A = B ) ;;
	step 2 : wff = syl6eqel (step 1, hyp 2) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*A membership and equality inference.  (Contributed by NM,
       4-Jan-2006.) */

theorem syl6eleq (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- B = C ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl6eleq {
	step 1 : wff = a1i (hyp 2) |- ( ph → B = C ) ;;
	step 2 : wff = eleqtrd (hyp 1, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*A membership and equality inference.  (Contributed by NM,
       24-Apr-2005.) */

theorem syl6eleqr (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A ∈ B ) ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- ( ph → A ∈ C ) ;;
}

proof of syl6eleqr {
	step 1 : wff = eqcomi (hyp 2) |- B = C ;;
	step 2 : wff = syl6eleq (hyp 1, step 1) |- ( ph → A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*Substitution of equal classes into a membership antecedent.
       (Contributed by Jonathan Ben-Naim, 3-Jun-2011.) */

theorem eleq2s (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( A ∈ B → ph ) ;;
	hyp 2 : wff = |- C = B ;;
	-----------------------
	prop 1 : wff = |- ( A ∈ C → ph ) ;;
}

proof of eleq2s {
	step 1 : wff = eleq2i (hyp 2) |- ( A ∈ C ↔ A ∈ B ) ;;
	step 2 : wff = sylbi (step 1, hyp 1) |- ( A ∈ C → ph ) ;;
	qed prop 1 = step 2 ;;
}

/*If a class is not an element of another class, an equal class is also
       not an element.  Deduction form.  (Contributed by David Moews,
       1-May-2017.) */

theorem eqneltrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → ¬ B ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ A ∈ C ) ;;
}

proof of eqneltrd {
	step 1 : wff = eleq1d (hyp 1) |- ( ph → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = mtbird (hyp 2, step 1) |- ( ph → ¬ A ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*If a class is not an element of another class, an equal class is also
       not an element.  Deduction form.  (Contributed by David Moews,
       1-May-2017.) */

theorem eqneltrrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → A = B ) ;;
	hyp 2 : wff = |- ( ph → ¬ A ∈ C ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ B ∈ C ) ;;
}

proof of eqneltrrd {
	step 1 : wff = eleq1d (hyp 1) |- ( ph → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = mtbid (hyp 2, step 1) |- ( ph → ¬ B ∈ C ) ;;
	qed prop 1 = step 2 ;;
}

/*If a class is not an element of another class, it is also not an element
       of an equal class.  Deduction form.  (Contributed by David Moews,
       1-May-2017.) */

theorem neleqtrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → ¬ C ∈ A ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ C ∈ B ) ;;
}

proof of neleqtrd {
	step 1 : wff = eleq2d (hyp 2) |- ( ph → ( C ∈ A ↔ C ∈ B ) ) ;;
	step 2 : wff = mtbid (hyp 1, step 1) |- ( ph → ¬ C ∈ B ) ;;
	qed prop 1 = step 2 ;;
}

/*If a class is not an element of another class, it is also not an element
       of an equal class.  Deduction form.  (Contributed by David Moews,
       1-May-2017.) */

theorem neleqtrrd (ph : wff, A : class, B : class, C : class)  {
	hyp 1 : wff = |- ( ph → ¬ C ∈ B ) ;;
	hyp 2 : wff = |- ( ph → A = B ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ C ∈ A ) ;;
}

proof of neleqtrrd {
	step 1 : wff = eleq2d (hyp 2) |- ( ph → ( C ∈ A ↔ C ∈ B ) ) ;;
	step 2 : wff = mtbird (hyp 1, step 1) |- ( ph → ¬ C ∈ A ) ;;
	qed prop 1 = step 2 ;;
}

/*Establish equality between classes, using bound-variable hypotheses
       instead of distinct variable conditions.  (Contributed by NM,
       5-Aug-1993.) */

theorem cleqh (x : set, y : set, A : class, B : class) disjointed(y A, y B, x y) {
	hyp 1 : wff = |- ( y ∈ A → ∀ x y ∈ A ) ;;
	hyp 2 : wff = |- ( y ∈ B → ∀ x y ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
}

proof of cleqh {
	step 1 : wff = dfcleq () |- ( A = B ↔ ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 2 : wff = ax-17 () |- ( ( x ∈ A ↔ x ∈ B ) → ∀ y ( x ∈ A ↔ x ∈ B ) ) ;;
	step 3 : wff = dfbi2 () |- ( ( y ∈ A ↔ y ∈ B ) ↔ ( ( y ∈ A → y ∈ B ) ∧ ( y ∈ B → y ∈ A ) ) ) ;;
	step 4 : wff = hbim (hyp 1, hyp 2) |- ( ( y ∈ A → y ∈ B ) → ∀ x ( y ∈ A → y ∈ B ) ) ;;
	step 5 : wff = hbim (hyp 2, hyp 1) |- ( ( y ∈ B → y ∈ A ) → ∀ x ( y ∈ B → y ∈ A ) ) ;;
	step 6 : wff = hban (step 4, step 5) |- ( ( ( y ∈ A → y ∈ B ) ∧ ( y ∈ B → y ∈ A ) ) → ∀ x ( ( y ∈ A → y ∈ B ) ∧ ( y ∈ B → y ∈ A ) ) ) ;;
	step 7 : wff = hbxfrbi (step 3, step 6) |- ( ( y ∈ A ↔ y ∈ B ) → ∀ x ( y ∈ A ↔ y ∈ B ) ) ;;
	step 8 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 9 : wff = eleq1 () |- ( x = y → ( x ∈ B ↔ y ∈ B ) ) ;;
	step 10 : wff = bibi12d (step 8, step 9) |- ( x = y → ( ( x ∈ A ↔ x ∈ B ) ↔ ( y ∈ A ↔ y ∈ B ) ) ) ;;
	step 11 : wff = biimpd (step 10) |- ( x = y → ( ( x ∈ A ↔ x ∈ B ) → ( y ∈ A ↔ y ∈ B ) ) ) ;;
	step 12 : wff = cbv3h (step 2, step 7, step 11) |- ( ∀ x ( x ∈ A ↔ x ∈ B ) → ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 13 : wff = dfbi2 () |- ( ( y ∈ A ↔ y ∈ B ) ↔ ( ( y ∈ A → y ∈ B ) ∧ ( y ∈ B → y ∈ A ) ) ) ;;
	step 14 : wff = hbim (hyp 1, hyp 2) |- ( ( y ∈ A → y ∈ B ) → ∀ x ( y ∈ A → y ∈ B ) ) ;;
	step 15 : wff = hbim (hyp 2, hyp 1) |- ( ( y ∈ B → y ∈ A ) → ∀ x ( y ∈ B → y ∈ A ) ) ;;
	step 16 : wff = hban (step 14, step 15) |- ( ( ( y ∈ A → y ∈ B ) ∧ ( y ∈ B → y ∈ A ) ) → ∀ x ( ( y ∈ A → y ∈ B ) ∧ ( y ∈ B → y ∈ A ) ) ) ;;
	step 17 : wff = hbxfrbi (step 13, step 16) |- ( ( y ∈ A ↔ y ∈ B ) → ∀ x ( y ∈ A ↔ y ∈ B ) ) ;;
	step 18 : wff = ax-17 () |- ( ( x ∈ A ↔ x ∈ B ) → ∀ y ( x ∈ A ↔ x ∈ B ) ) ;;
	step 19 : wff = eleq1 () |- ( x = y → ( x ∈ A ↔ y ∈ A ) ) ;;
	step 20 : wff = eleq1 () |- ( x = y → ( x ∈ B ↔ y ∈ B ) ) ;;
	step 21 : wff = bibi12d (step 19, step 20) |- ( x = y → ( ( x ∈ A ↔ x ∈ B ) ↔ ( y ∈ A ↔ y ∈ B ) ) ) ;;
	step 22 : wff = equcoms (step 21) |- ( y = x → ( ( x ∈ A ↔ x ∈ B ) ↔ ( y ∈ A ↔ y ∈ B ) ) ) ;;
	step 23 : wff = biimprd (step 22) |- ( y = x → ( ( y ∈ A ↔ y ∈ B ) → ( x ∈ A ↔ x ∈ B ) ) ) ;;
	step 24 : wff = cbv3h (step 17, step 18, step 23) |- ( ∀ y ( y ∈ A ↔ y ∈ B ) → ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	step 25 : wff = impbii (step 12, step 24) |- ( ∀ x ( x ∈ A ↔ x ∈ B ) ↔ ∀ y ( y ∈ A ↔ y ∈ B ) ) ;;
	step 26 : wff = bitr4i (step 1, step 25) |- ( A = B ↔ ∀ x ( x ∈ A ↔ x ∈ B ) ) ;;
	qed prop 1 = step 26 ;;
}

/*A way of showing two classes are not equal.  (Contributed by NM,
     1-Apr-1997.) */

theorem nelneq (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∈ C ∧ ¬ B ∈ C ) → ¬ A = B ) ;;
}

proof of nelneq {
	step 1 : wff = eleq1 () |- ( A = B → ( A ∈ C ↔ B ∈ C ) ) ;;
	step 2 : wff = biimpcd (step 1) |- ( A ∈ C → ( A = B → B ∈ C ) ) ;;
	step 3 : wff = con3and (step 2) |- ( ( A ∈ C ∧ ¬ B ∈ C ) → ¬ A = B ) ;;
	qed prop 1 = step 3 ;;
}

/*A way of showing two classes are not equal.  (Contributed by NM,
     12-Jan-2002.) */

theorem nelneq2 (A : class, B : class, C : class)  {
	prop 1 : wff = |- ( ( A ∈ B ∧ ¬ A ∈ C ) → ¬ B = C ) ;;
}

proof of nelneq2 {
	step 1 : wff = eleq2 () |- ( B = C → ( A ∈ B ↔ A ∈ C ) ) ;;
	step 2 : wff = biimpcd (step 1) |- ( A ∈ B → ( B = C → A ∈ C ) ) ;;
	step 3 : wff = con3and (step 2) |- ( ( A ∈ B ∧ ¬ A ∈ C ) → ¬ B = C ) ;;
	qed prop 1 = step 3 ;;
}

/*Lemma for ~ eqsb3 .  (Contributed by Rodolfo Medina, 28-Apr-2010.)
       (Proof shortened by Andrew Salmon, 14-Jun-2011.) */

theorem eqsb3lem (x : set, y : set, A : class) disjointed(x y, y A) {
	prop 1 : wff = |- ( [ x / y ] y = A ↔ x = A ) ;;
}

proof of eqsb3lem {
	step 1 : wff = nfv () |- F/ y x = A ;;
	step 2 : wff = eqeq1 () |- ( y = x → ( y = A ↔ x = A ) ) ;;
	step 3 : wff = sbie (step 1, step 2) |- ( [ x / y ] y = A ↔ x = A ) ;;
	qed prop 1 = step 3 ;;
}

/*Substitution applied to an atomic wff (class version of ~ equsb3 ).
       (Contributed by Rodolfo Medina, 28-Apr-2010.) */

theorem eqsb3 (x : set, y : set, A : class) disjointed(y A, w y, w A, x w) {
	prop 1 : wff = |- ( [ x / y ] y = A ↔ x = A ) ;;
}

proof of eqsb3 {
	var w : set;;
	step 1 : wff = eqsb3lem () |- ( [ w / y ] y = A ↔ w = A ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ x / w ] [ w / y ] y = A ↔ [ x / w ] w = A ) ;;
	step 3 : wff = nfv () |- F/ w y = A ;;
	step 4 : wff = sbco2 (step 3) |- ( [ x / w ] [ w / y ] y = A ↔ [ x / y ] y = A ) ;;
	step 5 : wff = eqsb3lem () |- ( [ x / w ] w = A ↔ x = A ) ;;
	step 6 : wff = 3bitr3i (step 2, step 4, step 5) |- ( [ x / y ] y = A ↔ x = A ) ;;
	qed prop 1 = step 6 ;;
}

/*Substitution applied to an atomic wff (class version of ~ elsb3 ).
       (Contributed by Rodolfo Medina, 28-Apr-2010.)  (Proof shortened by
       Andrew Salmon, 14-Jun-2011.) */

theorem clelsb3 (x : set, y : set, A : class) disjointed(y A, w y, w A, w x) {
	prop 1 : wff = |- ( [ x / y ] y ∈ A ↔ x ∈ A ) ;;
}

proof of clelsb3 {
	var w : set;;
	step 1 : wff = nfv () |- F/ y w ∈ A ;;
	step 2 : wff = sbco2 (step 1) |- ( [ x / y ] [ y / w ] w ∈ A ↔ [ x / w ] w ∈ A ) ;;
	step 3 : wff = nfv () |- F/ w y ∈ A ;;
	step 4 : wff = eleq1 () |- ( w = y → ( w ∈ A ↔ y ∈ A ) ) ;;
	step 5 : wff = sbie (step 3, step 4) |- ( [ y / w ] w ∈ A ↔ y ∈ A ) ;;
	step 6 : wff = sbbii (step 5) |- ( [ x / y ] [ y / w ] w ∈ A ↔ [ x / y ] y ∈ A ) ;;
	step 7 : wff = nfv () |- F/ w x ∈ A ;;
	step 8 : wff = eleq1 () |- ( w = x → ( w ∈ A ↔ x ∈ A ) ) ;;
	step 9 : wff = sbie (step 7, step 8) |- ( [ x / w ] w ∈ A ↔ x ∈ A ) ;;
	step 10 : wff = 3bitr3i (step 2, step 6, step 9) |- ( [ x / y ] y ∈ A ↔ x ∈ A ) ;;
	qed prop 1 = step 10 ;;
}

/*A utility lemma to transfer a bound-variable hypothesis builder into a
       definition.  See ~ hbxfrbi for equivalence version.  (Contributed by NM,
       21-Aug-2007.) */

theorem hbxfreq (x : set, y : set, A : class, B : class)  {
	hyp 1 : wff = |- A = B ;;
	hyp 2 : wff = |- ( y ∈ B → ∀ x y ∈ B ) ;;
	-----------------------
	prop 1 : wff = |- ( y ∈ A → ∀ x y ∈ A ) ;;
}

proof of hbxfreq {
	step 1 : wff = eleq2i (hyp 1) |- ( y ∈ A ↔ y ∈ B ) ;;
	step 2 : wff = hbxfrbi (step 1, hyp 2) |- ( y ∈ A → ∀ x y ∈ A ) ;;
	qed prop 1 = step 2 ;;
}

/*Change the free variable of a hypothesis builder.  Lemma for ~ nfcrii .
       (Contributed by NM, 5-Aug-1993.)  (Revised by Andrew Salmon,
       11-Jul-2011.) */

theorem hblem (x : set, y : set, z : set, A : class) disjointed(y A, x z) {
	hyp 1 : wff = |- ( y ∈ A → ∀ x y ∈ A ) ;;
	-----------------------
	prop 1 : wff = |- ( z ∈ A → ∀ x z ∈ A ) ;;
}

proof of hblem {
	step 1 : wff = hbsb (hyp 1) |- ( [ z / y ] y ∈ A → ∀ x [ z / y ] y ∈ A ) ;;
	step 2 : wff = clelsb3 () |- ( [ z / y ] y ∈ A ↔ z ∈ A ) ;;
	step 3 : wff = clelsb3 () |- ( [ z / y ] y ∈ A ↔ z ∈ A ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x [ z / y ] y ∈ A ↔ ∀ x z ∈ A ) ;;
	step 5 : wff = 3imtr3i (step 1, step 2, step 4) |- ( z ∈ A → ∀ x z ∈ A ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality of a class variable and a class abstraction (also called a
       class builder).  Theorem 5.1 of [Quine] p. 34.  This theorem shows the
       relationship between expressions with class abstractions and expressions
       with class variables.  Note that ~ abbi and its relatives are among
       those useful for converting theorems with class variables to equivalent
       theorems with wff variables, by first substituting a class abstraction
       for each class variable.

       Class variables can always be eliminated from a theorem to result in an
       equivalent theorem with wff variables, and vice-versa.  The idea is
       roughly as follows.  To convert a theorem with a wff variable ` ph `
       (that has a free variable ` x ` ) to a theorem with a class variable
       ` A ` , we substitute ` x e. A ` for ` ph ` throughout and simplify,
       where ` A ` is a new class variable not already in the wff.  An example
       is the conversion of ~ zfauscl to ~ inex1 (look at the instance of
       ~ zfauscl that occurs in the proof of ~ inex1 ).  Conversely, to convert
       a theorem with a class variable ` A ` to one with ` ph ` , we substitute
       ` { x | ph } ` for ` A ` throughout and simplify, where ` x ` and ` ph `
       are new set and wff variables not already in the wff.  An example is
       ~ cp , which derives a formula containing wff variables from
       substitution instances of the class variables in its equivalent
       formulation ~ cplem2 .  For more information on class variables, see
       Quine pp. 15-21 and/or Takeuti and Zaring pp. 10-13.  (Contributed by
       NM, 5-Aug-1993.) */

theorem abeq2 (ph : wff, x : set, A : class) disjointed(x A y, ph y) {
	prop 1 : wff = |- ( A = { x | ph } ↔ ∀ x ( x ∈ A ↔ ph ) ) ;;
}

proof of abeq2 {
	var y : set;;
	step 1 : wff = ax-17 () |- ( y ∈ A → ∀ x y ∈ A ) ;;
	step 2 : wff = hbab1 () |- ( y ∈ { x | ph } → ∀ x y ∈ { x | ph } ) ;;
	step 3 : wff = cleqh (step 1, step 2) |- ( A = { x | ph } ↔ ∀ x ( x ∈ A ↔ x ∈ { x | ph } ) ) ;;
	step 4 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 5 : wff = bibi2i (step 4) |- ( ( x ∈ A ↔ x ∈ { x | ph } ) ↔ ( x ∈ A ↔ ph ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ x ( x ∈ A ↔ x ∈ { x | ph } ) ↔ ∀ x ( x ∈ A ↔ ph ) ) ;;
	step 7 : wff = bitri (step 3, step 6) |- ( A = { x | ph } ↔ ∀ x ( x ∈ A ↔ ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Equality of a class variable and a class abstraction.  (Contributed by
       NM, 20-Aug-1993.) */

theorem abeq1 (ph : wff, x : set, A : class) disjointed(x A, ph) {
	prop 1 : wff = |- ( { x | ph } = A ↔ ∀ x ( ph ↔ x ∈ A ) ) ;;
}

proof of abeq1 {
	step 1 : wff = abeq2 () |- ( A = { x | ph } ↔ ∀ x ( x ∈ A ↔ ph ) ) ;;
	step 2 : wff = eqcom () |- ( { x | ph } = A ↔ A = { x | ph } ) ;;
	step 3 : wff = bicom () |- ( ( ph ↔ x ∈ A ) ↔ ( x ∈ A ↔ ph ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x ( ph ↔ x ∈ A ) ↔ ∀ x ( x ∈ A ↔ ph ) ) ;;
	step 5 : wff = 3bitr4i (step 1, step 2, step 4) |- ( { x | ph } = A ↔ ∀ x ( ph ↔ x ∈ A ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Equality of a class variable and a class abstraction (inference rule).
       (Contributed by NM, 3-Apr-1996.) */

theorem abeq2i (ph : wff, x : set, A : class)  {
	hyp 1 : wff = |- A = { x | ph } ;;
	-----------------------
	prop 1 : wff = |- ( x ∈ A ↔ ph ) ;;
}

proof of abeq2i {
	step 1 : wff = eleq2i (hyp 1) |- ( x ∈ A ↔ x ∈ { x | ph } ) ;;
	step 2 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( x ∈ A ↔ ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality of a class variable and a class abstraction (inference rule).
       (Contributed by NM, 31-Jul-1994.) */

theorem abeq1i (ph : wff, x : set, A : class)  {
	hyp 1 : wff = |- { x | ph } = A ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ x ∈ A ) ;;
}

proof of abeq1i {
	step 1 : wff = abid () |- ( x ∈ { x | ph } ↔ ph ) ;;
	step 2 : wff = eleq2i (hyp 1) |- ( x ∈ { x | ph } ↔ x ∈ A ) ;;
	step 3 : wff = bitr3i (step 1, step 2) |- ( ph ↔ x ∈ A ) ;;
	qed prop 1 = step 3 ;;
}

/*Equality of a class variable and a class abstraction (deduction).
       (Contributed by NM, 16-Nov-1995.) */

theorem abeq2d (ph : wff, ps : wff, x : set, A : class)  {
	hyp 1 : wff = |- ( ph → A = { x | ps } ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( x ∈ A ↔ ps ) ) ;;
}

proof of abeq2d {
	step 1 : wff = eleq2d (hyp 1) |- ( ph → ( x ∈ A ↔ x ∈ { x | ps } ) ) ;;
	step 2 : wff = abid () |- ( x ∈ { x | ps } ↔ ps ) ;;
	step 3 : wff = syl6bb (step 1, step 2) |- ( ph → ( x ∈ A ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalent wff's correspond to equal class abstractions.  (Contributed
       by NM, 25-Nov-2013.)  (Revised by Mario Carneiro, 11-Aug-2016.) */

theorem abbi (ph : wff, ps : wff, x : set) disjointed(ph y, ps y, x y) {
	prop 1 : wff = |- ( ∀ x ( ph ↔ ps ) ↔ { x | ph } = { x | ps } ) ;;
}

proof of abbi {
	var y : set;;
	step 1 : wff = dfcleq () |- ( { x | ph } = { x | ps } ↔ ∀ y ( y ∈ { x | ph } ↔ y ∈ { x | ps } ) ) ;;
	step 2 : wff = nfsab1 () |- F/ x y ∈ { x | ph } ;;
	step 3 : wff = nfsab1 () |- F/ x y ∈ { x | ps } ;;
	step 4 : wff = nfbi (step 2, step 3) |- F/ x ( y ∈ { x | ph } ↔ y ∈ { x | ps } ) ;;
	step 5 : wff = nfv () |- F/ y ( ph ↔ ps ) ;;
	step 6 : wff = df-clab () |- ( y ∈ { x | ph } ↔ [ y / x ] ph ) ;;
	step 7 : wff = sbequ12r () |- ( y = x → ( [ y / x ] ph ↔ ph ) ) ;;
	step 8 : wff = syl5bb (step 6, step 7) |- ( y = x → ( y ∈ { x | ph } ↔ ph ) ) ;;
	step 9 : wff = df-clab () |- ( y ∈ { x | ps } ↔ [ y / x ] ps ) ;;
	step 10 : wff = sbequ12r () |- ( y = x → ( [ y / x ] ps ↔ ps ) ) ;;
	step 11 : wff = syl5bb (step 9, step 10) |- ( y = x → ( y ∈ { x | ps } ↔ ps ) ) ;;
	step 12 : wff = bibi12d (step 8, step 11) |- ( y = x → ( ( y ∈ { x | ph } ↔ y ∈ { x | ps } ) ↔ ( ph ↔ ps ) ) ) ;;
	step 13 : wff = cbval (step 4, step 5, step 12) |- ( ∀ y ( y ∈ { x | ph } ↔ y ∈ { x | ps } ) ↔ ∀ x ( ph ↔ ps ) ) ;;
	step 14 : wff = bitr2i (step 1, step 13) |- ( ∀ x ( ph ↔ ps ) ↔ { x | ph } = { x | ps } ) ;;
	qed prop 1 = step 14 ;;
}

/*Equality of a class variable and a class abstraction (inference rule).
       (Contributed by NM, 5-Aug-1993.) */

theorem abbi2i (ph : wff, x : set, A : class) disjointed(x A) {
	hyp 1 : wff = |- ( x ∈ A ↔ ph ) ;;
	-----------------------
	prop 1 : wff = |- A = { x | ph } ;;
}

proof of abbi2i {
	step 1 : wff = abeq2 () |- ( A = { x | ph } ↔ ∀ x ( x ∈ A ↔ ph ) ) ;;
	step 2 : wff = mpgbir (step 1, hyp 1) |- A = { x | ph } ;;
	qed prop 1 = step 2 ;;
}

/*Equivalent wff's yield equal class abstractions (inference rule).
       (Contributed by NM, 5-Aug-1993.) */

theorem abbii (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- { x | ph } = { x | ps } ;;
}

proof of abbii {
	step 1 : wff = abbi () |- ( ∀ x ( ph ↔ ps ) ↔ { x | ph } = { x | ps } ) ;;
	step 2 : wff = mpgbi (step 1, hyp 1) |- { x | ph } = { x | ps } ;;
	qed prop 1 = step 2 ;;
}

/*Theorem abbii is the congruence law for class abstraction. */

/*$j congruence 'abbii'; */

/*` y ` is a dummy var. */

/*Equivalent wff's yield equal class abstractions (deduction rule).
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem abbid (ph : wff, ps : wff, ch : wff, x : set) disjointed(x, ph, ps, ch) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x | ps } = { x | ch } ) ;;
}

proof of abbid {
	step 1 : wff = alrimi (hyp 1, hyp 2) |- ( ph → ∀ x ( ps ↔ ch ) ) ;;
	step 2 : wff = abbi () |- ( ∀ x ( ps ↔ ch ) ↔ { x | ps } = { x | ch } ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ph → { x | ps } = { x | ch } ) ;;
	qed prop 1 = step 3 ;;
}

/*Equivalent wff's yield equal class abstractions (deduction rule).
       (Contributed by NM, 10-Aug-1993.) */

theorem abbidv (ph : wff, ps : wff, ch : wff, x : set) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x | ps } = { x | ch } ) ;;
}

proof of abbidv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = abbid (step 1, hyp 1) |- ( ph → { x | ps } = { x | ch } ) ;;
	qed prop 1 = step 2 ;;
}

/*` y ` is a dummy var. */

/*Deduction from a wff to a class abstraction.  (Contributed by NM,
       9-Jul-1994.) */

theorem abbi2dv (ph : wff, ps : wff, x : set, A : class) disjointed(x A, ph x, ps) {
	hyp 1 : wff = |- ( ph → ( x ∈ A ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → A = { x | ps } ) ;;
}

proof of abbi2dv {
	step 1 : wff = alrimiv (hyp 1) |- ( ph → ∀ x ( x ∈ A ↔ ps ) ) ;;
	step 2 : wff = abeq2 () |- ( A = { x | ps } ↔ ∀ x ( x ∈ A ↔ ps ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ph → A = { x | ps } ) ;;
	qed prop 1 = step 3 ;;
}

/*` y ` is a dummy var. */

/*Deduction from a wff to a class abstraction.  (Contributed by NM,
       9-Jul-1994.) */

theorem abbi1dv (ph : wff, ps : wff, x : set, A : class) disjointed(x A, ph x, ps) {
	hyp 1 : wff = |- ( ph → ( ps ↔ x ∈ A ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → { x | ps } = A ) ;;
}

proof of abbi1dv {
	step 1 : wff = alrimiv (hyp 1) |- ( ph → ∀ x ( ps ↔ x ∈ A ) ) ;;
	step 2 : wff = abeq1 () |- ( { x | ps } = A ↔ ∀ x ( ps ↔ x ∈ A ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ph → { x | ps } = A ) ;;
	qed prop 1 = step 3 ;;
}

/*A simplification of class abstraction.  Theorem 5.2 of [Quine] p. 35.
       (Contributed by NM, 26-Dec-1993.) */

theorem abid2 (x : set, A : class) disjointed(x A) {
	prop 1 : wff = |- { x | x ∈ A } = A ;;
}

proof of abid2 {
	step 1 : wff = biid () |- ( x ∈ A ↔ x ∈ A ) ;;
	step 2 : wff = abbi2i (step 1) |- A = { x | x ∈ A } ;;
	step 3 : wff = eqcomi (step 2) |- { x | x ∈ A } = A ;;
	qed prop 1 = step 3 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by Andrew Salmon, 11-Jul-2011.) */

theorem cbvab (ph : wff, ps : wff, x : set, y : set) disjointed(x z, y z, ph z, ps z) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { x | ph } = { y | ps } ;;
}

proof of cbvab {
	var z : set;;
	step 1 : wff = nfsb (hyp 2) |- F/ x [ z / y ] ps ;;
	step 2 : wff = equcoms (hyp 3) |- ( y = x → ( ph ↔ ps ) ) ;;
	step 3 : wff = bicomd (step 2) |- ( y = x → ( ps ↔ ph ) ) ;;
	step 4 : wff = sbie (hyp 1, step 3) |- ( [ x / y ] ps ↔ ph ) ;;
	step 5 : wff = sbequ () |- ( x = z → ( [ x / y ] ps ↔ [ z / y ] ps ) ) ;;
	step 6 : wff = syl5bbr (step 4, step 5) |- ( x = z → ( ph ↔ [ z / y ] ps ) ) ;;
	step 7 : wff = sbie (step 1, step 6) |- ( [ z / x ] ph ↔ [ z / y ] ps ) ;;
	step 8 : wff = df-clab () |- ( z ∈ { x | ph } ↔ [ z / x ] ph ) ;;
	step 9 : wff = df-clab () |- ( z ∈ { y | ps } ↔ [ z / y ] ps ) ;;
	step 10 : wff = 3bitr4i (step 7, step 8, step 9) |- ( z ∈ { x | ph } ↔ z ∈ { y | ps } ) ;;
	step 11 : wff = eqriv (step 10) |- { x | ph } = { y | ps } ;;
	qed prop 1 = step 11 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 26-May-1999.) */

theorem cbvabv (ph : wff, ps : wff, x : set, y : set) disjointed(y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- { x | ph } = { y | ps } ;;
}

proof of cbvabv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbvab (step 1, step 2, hyp 1) |- { x | ph } = { y | ps } ;;
	qed prop 1 = step 3 ;;
}

/*Membership of a class variable in a class abstraction.  (Contributed by
       NM, 23-Dec-1993.) */

theorem clelab (ph : wff, x : set, A : class) disjointed(x A y, ph y) {
	prop 1 : wff = |- ( A ∈ { x | ph } ↔ ∃ x ( x = A ∧ ph ) ) ;;
}

proof of clelab {
	var y : set;;
	step 1 : wff = df-clab () |- ( y ∈ { x | ph } ↔ [ y / x ] ph ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( y = A ∧ y ∈ { x | ph } ) ↔ ( y = A ∧ [ y / x ] ph ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ y ( y = A ∧ y ∈ { x | ph } ) ↔ ∃ y ( y = A ∧ [ y / x ] ph ) ) ;;
	step 4 : wff = df-clel () |- ( A ∈ { x | ph } ↔ ∃ y ( y = A ∧ y ∈ { x | ph } ) ) ;;
	step 5 : wff = nfv () |- F/ y ( x = A ∧ ph ) ;;
	step 6 : wff = nfv () |- F/ x y = A ;;
	step 7 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 8 : wff = nfan (step 6, step 7) |- F/ x ( y = A ∧ [ y / x ] ph ) ;;
	step 9 : wff = eqeq1 () |- ( x = y → ( x = A ↔ y = A ) ) ;;
	step 10 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 11 : wff = anbi12d (step 9, step 10) |- ( x = y → ( ( x = A ∧ ph ) ↔ ( y = A ∧ [ y / x ] ph ) ) ) ;;
	step 12 : wff = cbvex (step 5, step 8, step 11) |- ( ∃ x ( x = A ∧ ph ) ↔ ∃ y ( y = A ∧ [ y / x ] ph ) ) ;;
	step 13 : wff = 3bitr4i (step 3, step 4, step 12) |- ( A ∈ { x | ph } ↔ ∃ x ( x = A ∧ ph ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Membership of a class abstraction in another class.  (Contributed by NM,
       17-Jan-2006.) */

theorem clabel (ph : wff, x : set, y : set, A : class) disjointed(y A, y ph, x y) {
	prop 1 : wff = |- ( { x | ph } ∈ A ↔ ∃ y ( y ∈ A ∧ ∀ x ( x ∈ y ↔ ph ) ) ) ;;
}

proof of clabel {
	step 1 : wff = df-clel () |- ( { x | ph } ∈ A ↔ ∃ y ( y = { x | ph } ∧ y ∈ A ) ) ;;
	step 2 : wff = abeq2 () |- ( y = { x | ph } ↔ ∀ x ( x ∈ y ↔ ph ) ) ;;
	step 3 : wff = anbi2ci (step 2) |- ( ( y = { x | ph } ∧ y ∈ A ) ↔ ( y ∈ A ∧ ∀ x ( x ∈ y ↔ ph ) ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ( y = { x | ph } ∧ y ∈ A ) ↔ ∃ y ( y ∈ A ∧ ∀ x ( x ∈ y ↔ ph ) ) ) ;;
	step 5 : wff = bitri (step 1, step 4) |- ( { x | ph } ∈ A ↔ ∃ y ( y ∈ A ∧ ∀ x ( x ∈ y ↔ ph ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/*The right-hand side of the second equality is a way of representing
       proper substitution of ` y ` for ` x ` into a class variable.
       (Contributed by NM, 14-Sep-2003.) */

theorem sbab (x : set, y : set, z : set, A : class) disjointed(z A, z x, z y) {
	prop 1 : wff = |- ( x = y → A = { z | [ y / x ] z ∈ A } ) ;;
}

proof of sbab {
	step 1 : wff = sbequ12 () |- ( x = y → ( z ∈ A ↔ [ y / x ] z ∈ A ) ) ;;
	step 2 : wff = abbi2dv (step 1) |- ( x = y → A = { z | [ y / x ] z ∈ A } ) ;;
	qed prop 1 = step 2 ;;
}


