import uset-100000/ZF_(ZERMELO-FRAENKEL)_SET_THEORY/ZF_Set_Theory_-_add_the_Axiom_of_Replacement/Introduce_the_Axiom_of_Replacement.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                    Derive the Axiom of Separation

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Separation Scheme, which is an axiom scheme of Zermelo's original
       theory.  Scheme Sep of [BellMachover] p. 463.  As we show here, it is
       redundant if we assume Replacement in the form of ~ ax-rep .  Some
       textbooks present Separation as a separate axiom scheme in order to show
       that much of set theory can be derived without the stronger
       Replacement.  The Separation Scheme is a weak form of Frege's Axiom of
       Comprehension, conditioning it (with ` x e. z ` ) so that it asserts the
       existence of a collection only if it is smaller than some other
       collection ` z ` that already exists.  This prevents Russell's paradox
       ~ ru .  In some texts, this scheme is called "Aussonderung" or the
       Subset Axiom.

       The variable ` x ` can appear free in the wff ` ph ` , which in
       textbooks is often written ` ph ( x ) ` .  To specify this in the
       Metamath language, we _omit_ the distinct variable requirement ($d) that
       ` x ` not appear in ` ph ` .

       For a version using a class variable, see ~ zfauscl , which requires the
       Axiom of Extensionality as well as Separation for its derivation.

       If we omit the requirement that ` y ` not occur in ` ph ` , we can
       derive a contradiction, as ~ notzfaus shows (contradicting ~ zfauscl ).
       However, as ~ axsep2 shows, we can eliminate the restriction that ` z `
       not occur in ` ph ` .

       Note: the distinct variable restriction that ` z ` not occur in ` ph `
       is actually redundant in this particular proof, but we keep it since its
       purpose is to demonstrate the derivation of the exact ~ ax-sep from
       ~ ax-rep .

       This theorem should not be referenced by any proof.  Instead, use
       ~ ax-sep below so that the uses of the Axiom of Separation can be more
       easily identified.  (Contributed by NM, 11-Sep-2006.)
       (New usage is discouraged.) */

theorem axsep (ph : wff, x : set, y : set, z : set) disjointed(x y z w, y z ph w) {
	prop 1 : wff = |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ;;
}

proof of axsep {
	var w : set;;
	step 1 : wff = nfv () |- F/ y ( w = x ∧ ph ) ;;
	step 2 : wff = axrep5 (step 1) |- ( ∀ w ( w ∈ z → ∃ y ∀ x ( ( w = x ∧ ph ) → x = y ) ) → ∃ y ∀ x ( x ∈ y ↔ ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ) ;;
	step 3 : wff = equtr () |- ( y = w → ( w = x → y = x ) ) ;;
	step 4 : wff = equcomi () |- ( y = x → x = y ) ;;
	step 5 : wff = syl6 (step 3, step 4) |- ( y = w → ( w = x → x = y ) ) ;;
	step 6 : wff = adantrd (step 5) |- ( y = w → ( ( w = x ∧ ph ) → x = y ) ) ;;
	step 7 : wff = alrimiv (step 6) |- ( y = w → ∀ x ( ( w = x ∧ ph ) → x = y ) ) ;;
	step 8 : wff = a1d (step 7) |- ( y = w → ( w ∈ z → ∀ x ( ( w = x ∧ ph ) → x = y ) ) ) ;;
	step 9 : wff = spimev (step 8) |- ( w ∈ z → ∃ y ∀ x ( ( w = x ∧ ph ) → x = y ) ) ;;
	step 10 : wff = mpg (step 2, step 9) |- ∃ y ∀ x ( x ∈ y ↔ ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ;;
	step 11 : wff = an12 () |- ( ( w = x ∧ ( w ∈ z ∧ ph ) ) ↔ ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ w ( w = x ∧ ( w ∈ z ∧ ph ) ) ↔ ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ;;
	step 13 : wff = nfv () |- F/ w ( x ∈ z ∧ ph ) ;;
	step 14 : wff = elequ1 () |- ( w = x → ( w ∈ z ↔ x ∈ z ) ) ;;
	step 15 : wff = anbi1d (step 14) |- ( w = x → ( ( w ∈ z ∧ ph ) ↔ ( x ∈ z ∧ ph ) ) ) ;;
	step 16 : wff = equsex (step 13, step 15) |- ( ∃ w ( w = x ∧ ( w ∈ z ∧ ph ) ) ↔ ( x ∈ z ∧ ph ) ) ;;
	step 17 : wff = bitr3i (step 12, step 16) |- ( ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ↔ ( x ∈ z ∧ ph ) ) ;;
	step 18 : wff = bibi2i (step 17) |- ( ( x ∈ y ↔ ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ↔ ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ) ;;
	step 19 : wff = albii (step 18) |- ( ∀ x ( x ∈ y ↔ ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ↔ ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ) ;;
	step 20 : wff = exbii (step 19) |- ( ∃ y ∀ x ( x ∈ y ↔ ∃ w ( w ∈ z ∧ ( w = x ∧ ph ) ) ) ↔ ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ) ;;
	step 21 : wff = mpbi (step 10, step 20) |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ;;
	qed prop 1 = step 21 ;;
}

/* The Axiom of Separation of ZF set theory.  See ~ axsep for more
       information.  It was derived as ~ axsep above and is therefore
       redundant, but we state it as a separate axiom here so that its uses can
       be identified more easily.  (Contributed by NM, 11-Sep-2006.) */

axiom ax-sep (ph : wff, x : set, y : set, z : set) disjointed(x y z, y z ph) {
	prop 1 : wff = |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ;;
}

/* A less restrictive version of the Separation Scheme ~ axsep , where
       variables ` x ` and ` z ` can both appear free in the wff ` ph ` , which
       can therefore be thought of as ` ph ( x , z ) ` .  This version was
       derived from the more restrictive ~ ax-sep with no additional set theory
       axioms.  (Contributed by NM, 10-Dec-2006.)  (Proof shortened by Mario
       Carneiro, 17-Nov-2016.) */

theorem axsep2 (ph : wff, x : set, y : set, z : set) disjointed(x y z w, y ph w, z w) {
	prop 1 : wff = |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ;;
}

proof of axsep2 {
	var w : set;;
	step 1 : wff = eleq2 () |- ( w = z → ( x ∈ w ↔ x ∈ z ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( w = z → ( ( x ∈ w ∧ ( x ∈ z ∧ ph ) ) ↔ ( x ∈ z ∧ ( x ∈ z ∧ ph ) ) ) ) ;;
	step 3 : wff = anabs5 () |- ( ( x ∈ z ∧ ( x ∈ z ∧ ph ) ) ↔ ( x ∈ z ∧ ph ) ) ;;
	step 4 : wff = syl6bb (step 2, step 3) |- ( w = z → ( ( x ∈ w ∧ ( x ∈ z ∧ ph ) ) ↔ ( x ∈ z ∧ ph ) ) ) ;;
	step 5 : wff = bibi2d (step 4) |- ( w = z → ( ( x ∈ y ↔ ( x ∈ w ∧ ( x ∈ z ∧ ph ) ) ) ↔ ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ) ) ;;
	step 6 : wff = albidv (step 5) |- ( w = z → ( ∀ x ( x ∈ y ↔ ( x ∈ w ∧ ( x ∈ z ∧ ph ) ) ) ↔ ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ) ) ;;
	step 7 : wff = exbidv (step 6) |- ( w = z → ( ∃ y ∀ x ( x ∈ y ↔ ( x ∈ w ∧ ( x ∈ z ∧ ph ) ) ) ↔ ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ) ) ;;
	step 8 : wff = ax-sep () |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ w ∧ ( x ∈ z ∧ ph ) ) ) ;;
	step 9 : wff = chvarv (step 7, step 8) |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Separation Scheme (Aussonderung) using a class variable.  To derive this
       from ~ ax-sep , we invoke the Axiom of Extensionality (indirectly via
       ~ vtocl ), which is needed for the justification of class variable
       notation.

       If we omit the requirement that ` y ` not occur in ` ph ` , we can
       derive a contradiction, as ~ notzfaus shows.  (Contributed by NM,
       5-Aug-1993.) */

theorem zfauscl (ph : wff, x : set, y : set, A : class) disjointed(x y A z, y ph z) {
	hyp 1 : wff = |- A ∈ _V ;;
	-----------------------
	prop 1 : wff = |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ A ∧ ph ) ) ;;
}

proof of zfauscl {
	var z : set;;
	step 1 : wff = eleq2 () |- ( z = A → ( x ∈ z ↔ x ∈ A ) ) ;;
	step 2 : wff = anbi1d (step 1) |- ( z = A → ( ( x ∈ z ∧ ph ) ↔ ( x ∈ A ∧ ph ) ) ) ;;
	step 3 : wff = bibi2d (step 2) |- ( z = A → ( ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ↔ ( x ∈ y ↔ ( x ∈ A ∧ ph ) ) ) ) ;;
	step 4 : wff = albidv (step 3) |- ( z = A → ( ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ↔ ∀ x ( x ∈ y ↔ ( x ∈ A ∧ ph ) ) ) ) ;;
	step 5 : wff = exbidv (step 4) |- ( z = A → ( ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ↔ ∃ y ∀ x ( x ∈ y ↔ ( x ∈ A ∧ ph ) ) ) ) ;;
	step 6 : wff = ax-sep () |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ z ∧ ph ) ) ;;
	step 7 : wff = vtocl (hyp 1, step 5, step 6) |- ∃ y ∀ x ( x ∈ y ↔ ( x ∈ A ∧ ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Convert implication to equivalence using the Separation Scheme
       (Aussonderung) ~ ax-sep .  Similar to Theorem 1.3ii of [BellMachover]
       p. 463.  (Contributed by NM, 5-Aug-1993.) */

theorem bm1.3ii (ph : wff, x : set, y : set) disjointed(x ph z, x y z) {
	hyp 1 : wff = |- ∃ x ∀ y ( ph → y ∈ x ) ;;
	-----------------------
	prop 1 : wff = |- ∃ x ∀ y ( y ∈ x ↔ ph ) ;;
}

proof of bm1.3ii {
	var z : set;;
	step 1 : wff = elequ2 () |- ( x = z → ( y ∈ x ↔ y ∈ z ) ) ;;
	step 2 : wff = imbi2d (step 1) |- ( x = z → ( ( ph → y ∈ x ) ↔ ( ph → y ∈ z ) ) ) ;;
	step 3 : wff = albidv (step 2) |- ( x = z → ( ∀ y ( ph → y ∈ x ) ↔ ∀ y ( ph → y ∈ z ) ) ) ;;
	step 4 : wff = cbvexv (step 3) |- ( ∃ x ∀ y ( ph → y ∈ x ) ↔ ∃ z ∀ y ( ph → y ∈ z ) ) ;;
	step 5 : wff = mpbi (hyp 1, step 4) |- ∃ z ∀ y ( ph → y ∈ z ) ;;
	step 6 : wff = ax-sep () |- ∃ x ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ;;
	step 7 : wff = pm3.2i (step 5, step 6) |- ( ∃ z ∀ y ( ph → y ∈ z ) ∧ ∃ x ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) ;;
	step 8 : wff = exan (step 7) |- ∃ z ( ∀ y ( ph → y ∈ z ) ∧ ∃ x ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) ;;
	step 9 : wff = 19.42v () |- ( ∃ x ( ∀ y ( ph → y ∈ z ) ∧ ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) ↔ ( ∀ y ( ph → y ∈ z ) ∧ ∃ x ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) ) ;;
	step 10 : wff = bimsc1 () |- ( ( ( ph → y ∈ z ) ∧ ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) → ( y ∈ x ↔ ph ) ) ;;
	step 11 : wff = alanimi (step 10) |- ( ( ∀ y ( ph → y ∈ z ) ∧ ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) → ∀ y ( y ∈ x ↔ ph ) ) ;;
	step 12 : wff = eximi (step 11) |- ( ∃ x ( ∀ y ( ph → y ∈ z ) ∧ ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) → ∃ x ∀ y ( y ∈ x ↔ ph ) ) ;;
	step 13 : wff = sylbir (step 9, step 12) |- ( ( ∀ y ( ph → y ∈ z ) ∧ ∃ x ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) → ∃ x ∀ y ( y ∈ x ↔ ph ) ) ;;
	step 14 : wff = exlimiv (step 13) |- ( ∃ z ( ∀ y ( ph → y ∈ z ) ∧ ∃ x ∀ y ( y ∈ x ↔ ( y ∈ z ∧ ph ) ) ) → ∃ x ∀ y ( y ∈ x ↔ ph ) ) ;;
	step 15 : wff = ax-mp (step 8, step 14) |- ∃ x ∀ y ( y ∈ x ↔ ph ) ;;
	qed prop 1 = step 15 ;;
}

/* Derive a weakened version of ~ ax9 ( i.e. ~ ax9v ), where ` x ` and
       ` y ` must be distinct, from Separation ~ ax-sep and Extensionality
       ~ ax-ext .  See ~ ax9 for the derivation of ~ ax9 from ~ ax9v .
       (Contributed by NM, 12-Nov-2013.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem ax9vsep (x : set, y : set) disjointed(x y z) {
	prop 1 : wff = |- ¬ ∀ x ¬ x = y ;;
}

proof of ax9vsep {
	var z : set;;
	step 1 : wff = ax-sep () |- ∃ x ∀ z ( z ∈ x ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) ;;
	step 2 : wff = id () |- ( z = z → z = z ) ;;
	step 3 : wff = biantru (step 2) |- ( z ∈ y ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) ;;
	step 4 : wff = bibi2i (step 3) |- ( ( z ∈ x ↔ z ∈ y ) ↔ ( z ∈ x ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) ) ;;
	step 5 : wff = biimpri (step 4) |- ( ( z ∈ x ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) → ( z ∈ x ↔ z ∈ y ) ) ;;
	step 6 : wff = alimi (step 5) |- ( ∀ z ( z ∈ x ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) → ∀ z ( z ∈ x ↔ z ∈ y ) ) ;;
	step 7 : wff = ax-ext () |- ( ∀ z ( z ∈ x ↔ z ∈ y ) → x = y ) ;;
	step 8 : wff = syl (step 6, step 7) |- ( ∀ z ( z ∈ x ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) → x = y ) ;;
	step 9 : wff = eximi (step 8) |- ( ∃ x ∀ z ( z ∈ x ↔ ( z ∈ y ∧ ( z = z → z = z ) ) ) → ∃ x x = y ) ;;
	step 10 : wff = ax-mp (step 1, step 9) |- ∃ x x = y ;;
	step 11 : wff = df-ex () |- ( ∃ x x = y ↔ ¬ ∀ x ¬ x = y ) ;;
	step 12 : wff = mpbi (step 10, step 11) |- ¬ ∀ x ¬ x = y ;;
	qed prop 1 = step 12 ;;
}


