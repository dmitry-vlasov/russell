import uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Propositional_calculus/Logical_negation.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Logical equivalence

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  The definition ~ df-bi in this section is our first definition, which
  introduces and defines the biconditional connective ` <-> ` . We define a wff
  of the form ` ( ph <-> ps ) ` as an abbreviation for
  ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` .

  Unlike most traditional developments, we have chosen not to have a separate
  symbol such as "Df." to mean "is defined as."  Instead, we will later use the
  biconditional connective for this purpose ( ~ df-or is its first use), as it
  allows us to use logic to manipulate definitions directly.  This greatly
  simplifies many proofs since it eliminates the need for a separate mechanism
  for introducing and eliminating definitions.
*/

/* Declare the biconditional connective. */

constant {
	symbol ↔ ;;
	ascii <-> ;;
	latex \leftrightarrow ;;
}

/* Double arrow (read:  'if and only if' or
               'is logically equivalent to') */

/* Extend our wff definition to include the biconditional connective. */

rule wb (ph : wff, ps : wff) {
	term : wff = # ( ph ↔ ps ) ;;
}

/* Define the biconditional (logical 'iff').

     The definition ~ df-bi in this section is our first definition, which
     introduces and defines the biconditional connective ` <-> ` .  We define a
     wff of the form ` ( ph <-> ps ) ` as an abbreviation for
     ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` .

     Unlike most traditional developments, we have chosen not to have a
     separate symbol such as "Df." to mean "is defined as."  Instead, we will
     later use the biconditional connective for this purpose ( ~ df-or is its
     first use), as it allows us to use logic to manipulate definitions
     directly.  This greatly simplifies many proofs since it eliminates the
     need for a separate mechanism for introducing and eliminating
     definitions.  Of course, we cannot use this mechanism to define the
     biconditional itself, since it hasn't been introduced yet.  Instead, we
     use a more general form of definition, described as follows.

     In its most general form, a definition is simply an assertion that
     introduces a new symbol (or a new combination of existing symbols, as in
     ~ df-3an ) that is eliminable and does not strengthen the existing
     language.  The latter requirement means that the set of provable
     statements not containing the new symbol (or new combination) should
     remain exactly the same after the definition is introduced.  Our
     definition of the biconditional may look unusual compared to most
     definitions, but it strictly satisfies these requirements.

     The justification for our definition is that if we mechanically replace
     ` ( ph <-> ps ) ` (the definiendum i.e. the thing being defined) with
     ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` (the definiens i.e. the
     defining expression) in the definition, the definition becomes the
     previously proved theorem ~ bijust .  It is impossible to use ~ df-bi to
     prove any statement expressed in the original language that can't be
     proved from the original axioms, because if we simply replace each
     instance of ~ df-bi in the proof with the corresponding ~ bijust instance,
     we will end up with a proof from the original axioms.

     Note that from Metamath's point of view, a definition is just another
     axiom - i.e. an assertion we claim to be true - but from our high level
     point of view, we are not strengthening the language.  To indicate this
     fact, we prefix definition labels with "df-" instead of "ax-".  (This
     prefixing is an informal convention that means nothing to the Metamath
     proof verifier; it is just a naming convention for human readability.)

     After we define the constant true ` T. ` ( ~ df-tru ) and the constant
     false ` F. ` ( ~ df-fal ), we will be able to prove these truth table
     values: ` ( ( T. <-> T. ) <-> T. ) ` ( ~ trubitru ),
     ` ( ( T. <-> F. ) <-> F. ) ` ( ~ trubifal ), ` ( ( F. <-> T. ) <-> F. ) `
     ( ~ falbitru ), and ` ( ( F. <-> F. ) <-> T. ) ` ( ~ falbifal ).

     See ~ dfbi1 , ~ dfbi2 , and ~ dfbi3 for theorems suggesting typical
     textbook definitions of ` <-> ` , showing that our definition has the
     properties we expect.  Theorem ~ dfbi1 is particularly useful if we want
     to eliminate ` <-> ` from an expression to convert it to primitives.
     Theorem ~ dfbi shows this definition rewritten in an abbreviated form
     after conjunction is introduced, for easier understanding.

     Contrast with ` \/ ` ( ~ df-or ), ` -> ` ( ~ wi ), ` -/\ ` ( ~ df-nan ),
     and ` \/_ ` ( ~ df-xor ) .  In some sense ` <-> ` returns true if two
     truth values are equal; ` = ` ( ~ df-cleq ) returns true if two classes
     are equal.  (Contributed by NM, 5-Aug-1993.) */

axiom df-bi (ph : wff, ps : wff)  {
	prop 1 : wff = |- ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ;;
}

/* $j justification 'bijust' for 'df-bi'; */

/* Property of the biconditional connective.  (Contributed by NM,
     11-May-1999.) */

theorem bi1 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
}

proof of bi1 {
	step 1 : wff = df-bi () |- ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ;;
	step 2 : wff = simplim () |- ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
	step 4 : wff = simplim () |- ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph → ps ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Property of the biconditional connective.  (Contributed by NM,
     11-May-1999.) */

theorem bi3 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ps ) → ( ( ps → ph ) → ( ph ↔ ps ) ) ) ;;
}

proof of bi3 {
	step 1 : wff = df-bi () |- ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ;;
	step 2 : wff = simprim () |- ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ;;
	step 4 : wff = expi (step 3) |- ( ( ph → ps ) → ( ( ps → ph ) → ( ph ↔ ps ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Infer an equivalence from an implication and its converse.  (Contributed
       by NM, 5-Aug-1993.) */

theorem impbii (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ps → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ps ) ;;
}

proof of impbii {
	step 1 : wff = bi3 () |- ( ( ph → ps ) → ( ( ps → ph ) → ( ph ↔ ps ) ) ) ;;
	step 2 : wff = mp2 (hyp 1, hyp 2, step 1) |- ( ph ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduce an equivalence from two implications.  (Contributed by Rodolfo
       Medina, 12-Oct-2010.) */

theorem impbidd (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ( ch → th ) ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps → ( th → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
}

proof of impbidd {
	step 1 : wff = bi3 () |- ( ( ch → th ) → ( ( th → ch ) → ( ch ↔ th ) ) ) ;;
	step 2 : wff = syl6c (hyp 1, hyp 2, step 1) |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduce an equivalence from two implications.  (Contributed by Wolf
       Lammen, 12-May-2013.) */

theorem impbid21d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ps → ( ch → th ) ) ;;
	hyp 2 : wff = |- ( ph → ( th → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
}

proof of impbid21d {
	step 1 : wff = a1i (hyp 1) |- ( ph → ( ps → ( ch → th ) ) ) ;;
	step 2 : wff = a1d (hyp 2) |- ( ph → ( ps → ( th → ch ) ) ) ;;
	step 3 : wff = impbidd (step 1, step 2) |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduce an equivalence from two implications.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Wolf Lammen, 3-Nov-2012.) */

theorem impbid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of impbid {
	step 1 : wff = impbid21d (hyp 1, hyp 2) |- ( ph → ( ph → ( ps ↔ ch ) ) ) ;;
	step 2 : wff = pm2.43i (step 1) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Relate the biconditional connective to primitive connectives.  See
     ~ dfbi1gb for an unusual version proved directly from axioms.
     (Contributed by NM, 5-Aug-1993.) */

theorem dfbi1 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
}

proof of dfbi1 {
	step 1 : wff = df-bi () |- ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ;;
	step 2 : wff = simplim () |- ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ;;
	step 3 : wff = ax-mp (step 1, step 2) |- ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
	step 4 : wff = bi3 () |- ( ( ph → ps ) → ( ( ps → ph ) → ( ph ↔ ps ) ) ) ;;
	step 5 : wff = impi (step 4) |- ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ;;
	step 6 : wff = impbii (step 3, step 5) |- ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* This proof of ~ dfbi1 , discovered by Gregory Bush on 8-Mar-2004, has
     several curious properties.  First, it has only 17 steps directly from the
     axioms and ~ df-bi , compared to over 800 steps were the proof of ~ dfbi1
     expanded into axioms.  Second, step 2 demands only the property of "true";
     any axiom (or theorem) could be used.  It might be thought, therefore,
     that it is in some sense redundant, but in fact no proof is shorter than
     this (measured by number of steps).  Third, it illustrates how
     intermediate steps can "blow up" in size even in short proofs.  Fourth,
     the compressed proof is only 182 bytes (or 17 bytes in D-proof notation),
     but the generated web page is over 200kB with intermediate steps that are
     essentially incomprehensible to humans (other than Gregory Bush).  If
     there were an obfuscated code contest for proofs, this would be a
     contender.  This "blowing up" and incomprehensibility of the intermediate
     steps vividly demonstrate the advantages of using many layered
     intermediate theorems, since each theorem is easier to understand.
     (Contributed by Gregory Bush, 10-Mar-2004.)  (New usage is discouraged.)
     (Proof modification is discouraged.) */

theorem dfbi1gb (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
}

proof of dfbi1gb {
	var ch : wff, th : wff;;
	step 1 : wff = df-bi () |- ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ;;
	step 2 : wff = ax-1 () |- ( ch → ( th → ch ) ) ;;
	step 3 : wff = ax-1 () |- ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) ;;
	step 4 : wff = df-bi () |- ¬ ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ;;
	step 5 : wff = ax-1 () |- ( ¬ ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ( ¬ ¬ ( ch → ( th → ch ) ) → ¬ ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) ) ;;
	step 6 : wff = ax-mp (step 4, step 5) |- ( ¬ ¬ ( ch → ( th → ch ) ) → ¬ ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) ;;
	step 7 : wff = ax-3 () |- ( ( ¬ ¬ ( ch → ( th → ch ) ) → ¬ ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) → ( ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ) ;;
	step 8 : wff = ax-mp (step 6, step 7) |- ( ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ;;
	step 9 : wff = ax-1 () |- ( ( ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) → ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ( ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ) ) ;;
	step 10 : wff = ax-mp (step 8, step 9) |- ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ( ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ) ;;
	step 11 : wff = ax-2 () |- ( ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ( ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ) → ( ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) → ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ) ) ;;
	step 12 : wff = ax-mp (step 10, step 11) |- ( ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ( ( ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) ) → ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) → ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ) ;;
	step 13 : wff = ax-mp (step 3, step 12) |- ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) ;;
	step 14 : wff = ax-3 () |- ( ( ¬ ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) → ¬ ( ch → ( th → ch ) ) ) → ( ( ch → ( th → ch ) ) → ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ) ;;
	step 15 : wff = ax-mp (step 13, step 14) |- ( ( ch → ( th → ch ) ) → ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ) ;;
	step 16 : wff = ax-mp (step 2, step 15) |- ( ¬ ( ( ( ph ↔ ps ) → ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) → ¬ ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ph ↔ ps ) ) ) → ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ) ;;
	step 17 : wff = ax-mp (step 1, step 16) |- ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Infer an implication from a logical equivalence.  (Contributed by NM,
       5-Aug-1993.) */

theorem biimpi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of biimpi {
	step 1 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a biconditional and an implication.
       Useful for substituting an antecedent with a definition.  (Contributed
       by NM, 5-Aug-1993.) */

theorem sylbi (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ps → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of sylbi {
	step 1 : wff = biimpi (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = syl (step 1, hyp 2) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from an implication and a biconditional.
       (Contributed by NM, 5-Aug-1993.) */

theorem sylib (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of sylib {
	step 1 : wff = biimpi (hyp 2) |- ( ps → ch ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* Property of the biconditional connective.  (Contributed by NM,
     11-May-1999.)  (Proof shortened by Wolf Lammen, 11-Nov-2012.) */

theorem bi2 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → ( ps → ph ) ) ;;
}

proof of bi2 {
	step 1 : wff = dfbi1 () |- ( ( ph ↔ ps ) ↔ ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) ) ;;
	step 2 : wff = simprim () |- ( ¬ ( ( ph → ps ) → ¬ ( ps → ph ) ) → ( ps → ph ) ) ;;
	step 3 : wff = sylbi (step 1, step 2) |- ( ( ph ↔ ps ) → ( ps → ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Commutative law for equivalence.  (Contributed by Wolf Lammen,
     10-Nov-2012.) */

theorem bicom1 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → ( ps ↔ ph ) ) ;;
}

proof of bicom1 {
	step 1 : wff = bi2 () |- ( ( ph ↔ ps ) → ( ps → ph ) ) ;;
	step 2 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 3 : wff = impbid (step 1, step 2) |- ( ( ph ↔ ps ) → ( ps ↔ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Commutative law for equivalence.  Theorem *4.21 of [WhiteheadRussell]
     p. 117.  (Contributed by NM, 5-Aug-1993.) */

theorem bicom (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) ↔ ( ps ↔ ph ) ) ;;
}

proof of bicom {
	step 1 : wff = bicom1 () |- ( ( ph ↔ ps ) → ( ps ↔ ph ) ) ;;
	step 2 : wff = bicom1 () |- ( ( ps ↔ ph ) → ( ph ↔ ps ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph ↔ ps ) ↔ ( ps ↔ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Commute two sides of a biconditional in a deduction.  (Contributed by
       NM, 5-Aug-1993.) */

theorem bicomd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch ↔ ps ) ) ;;
}

proof of bicomd {
	step 1 : wff = bicom () |- ( ( ps ↔ ch ) ↔ ( ch ↔ ps ) ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → ( ch ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference from commutative law for logical equivalence.  (Contributed by
       NM, 5-Aug-1993.) */

theorem bicomi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ps ↔ ph ) ;;
}

proof of bicomi {
	step 1 : wff = bicom1 () |- ( ( ph ↔ ps ) → ( ps ↔ ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ps ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Infer an equivalence from two implications.  (Contributed by NM,
       6-Mar-2007.) */

theorem impbid1 (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ch → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of impbid1 {
	step 1 : wff = a1i (hyp 2) |- ( ph → ( ch → ps ) ) ;;
	step 2 : wff = impbid (hyp 1, step 1) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Infer an equivalence from two implications.  (Contributed by NM,
       6-Mar-2007.)  (Proof shortened by Wolf Lammen, 27-Sep-2013.) */

theorem impbid2 (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ps → ch ) ;;
	hyp 2 : wff = |- ( ph → ( ch → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of impbid2 {
	step 1 : wff = impbid1 (hyp 2, hyp 1) |- ( ph → ( ch ↔ ps ) ) ;;
	step 2 : wff = bicomd (step 1) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A variation on ~ impbid with contraposition.  (Contributed by Jeff
       Hankins, 3-Jul-2009.) */

theorem impcon4bid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ¬ ps → ¬ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of impcon4bid {
	step 1 : wff = con4d (hyp 2) |- ( ph → ( ch → ps ) ) ;;
	step 2 : wff = impbid (hyp 1, step 1) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Infer a converse implication from a logical equivalence.  (Contributed
       by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen, 16-Sep-2013.) */

theorem biimpri (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ps → ph ) ;;
}

proof of biimpri {
	step 1 : wff = bicomi (hyp 1) |- ( ps ↔ ph ) ;;
	step 2 : wff = biimpi (step 1) |- ( ps → ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduce an implication from a logical equivalence.  (Contributed by NM,
       5-Aug-1993.) */

theorem biimpd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ch ) ) ;;
}

proof of biimpd {
	step 1 : wff = bi1 () |- ( ( ps ↔ ch ) → ( ps → ch ) ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ( ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a biconditional, related to modus ponens.
       (Contributed by NM, 5-Aug-1993.) */

theorem mpbi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ph ;;
	hyp 2 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of mpbi {
	step 1 : wff = biimpi (hyp 2) |- ( ph → ps ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ps ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a biconditional, related to modus ponens.
       (Contributed by NM, 5-Aug-1993.) */

theorem mpbir (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ps ;;
	hyp 2 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ph ;;
}

proof of mpbir {
	step 1 : wff = biimpri (hyp 2) |- ( ps → ph ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ph ;;
	qed prop 1 = step 2 ;;
}

/* A deduction from a biconditional, related to modus ponens.  (Contributed
       by NM, 5-Aug-1993.) */

theorem mpbid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of mpbid {
	step 1 : wff = biimpd (hyp 2) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = mpd (hyp 1, step 1) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a nested biconditional, related to modus ponens.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen,
       25-Oct-2012.) */

theorem mpbii (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ps ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of mpbii {
	step 1 : wff = a1i (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = mpbid (step 1, hyp 2) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from an implication and a biconditional.
       Useful for substituting a consequent with a definition.  (Contributed by
       NM, 5-Aug-1993.) */

theorem sylibr (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of sylibr {
	step 1 : wff = biimpri (hyp 2) |- ( ps → ch ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a biconditional and an implication.
       (Contributed by NM, 5-Aug-1993.) */

theorem sylbir (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ps ↔ ph ) ;;
	hyp 2 : wff = |- ( ps → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ch ) ;;
}

proof of sylbir {
	step 1 : wff = biimpri (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = syl (step 1, hyp 2) |- ( ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism deduction.  (Contributed by NM, 3-Aug-1994.) */

theorem sylibd (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of sylibd {
	step 1 : wff = biimpd (hyp 2) |- ( ph → ( ch → th ) ) ;;
	step 2 : wff = syld (hyp 1, step 1) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism deduction.  (Contributed by NM, 3-Aug-1994.) */

theorem sylbid (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of sylbid {
	step 1 : wff = biimpd (hyp 1) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = syld (step 1, hyp 2) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A deduction from a biconditional, related to modus ponens.  (Contributed
       by NM, 9-Aug-1994.) */

theorem mpbidi (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( th → ( ph → ps ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( th → ( ph → ch ) ) ;;
}

proof of mpbidi {
	step 1 : wff = biimpd (hyp 2) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = sylcom (hyp 1, step 1) |- ( th → ( ph → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a nested implication and a
       biconditional.  Useful for substituting an embedded antecedent with a
       definition.  (Contributed by NM, 5-Aug-1993.) */

theorem syl5bi (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch → ( ps → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph → th ) ) ;;
}

proof of syl5bi {
	step 1 : wff = biimpi (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = syl5 (step 1, hyp 2) |- ( ch → ( ph → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a nested implication and a
       biconditional.  (Contributed by NM, 5-Aug-1993.) */

theorem syl5bir (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ps ↔ ph ) ;;
	hyp 2 : wff = |- ( ch → ( ps → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph → th ) ) ;;
}

proof of syl5bir {
	step 1 : wff = biimpri (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = syl5 (step 1, hyp 2) |- ( ch → ( ph → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference.  (Contributed by NM, 5-Aug-1993.) */

theorem syl5ib (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph → th ) ) ;;
}

proof of syl5ib {
	step 1 : wff = biimpd (hyp 2) |- ( ch → ( ps → th ) ) ;;
	step 2 : wff = syl5 (hyp 1, step 1) |- ( ch → ( ph → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference.  (Contributed by NM, 19-Jun-2007.) */

theorem syl5ibcom (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → th ) ) ;;
}

proof of syl5ibcom {
	step 1 : wff = syl5ib (hyp 1, hyp 2) |- ( ch → ( ph → th ) ) ;;
	step 2 : wff = com12 (step 1) |- ( ph → ( ch → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference.  (Contributed by NM, 3-Apr-1994.) */

theorem syl5ibr (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → th ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph → ps ) ) ;;
}

proof of syl5ibr {
	step 1 : wff = bicomd (hyp 2) |- ( ch → ( th ↔ ps ) ) ;;
	step 2 : wff = syl5ib (hyp 1, step 1) |- ( ch → ( ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference.  (Contributed by NM, 20-Jun-2007.) */

theorem syl5ibrcom (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → th ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ps ) ) ;;
}

proof of syl5ibrcom {
	step 1 : wff = syl5ibr (hyp 1, hyp 2) |- ( ch → ( ph → ps ) ) ;;
	step 2 : wff = com12 (step 1) |- ( ph → ( ch → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduce a converse implication from a logical equivalence.  (Contributed
       by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen, 22-Sep-2013.) */

theorem biimprd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ps ) ) ;;
}

proof of biimprd {
	step 1 : wff = id () |- ( ch → ch ) ;;
	step 2 : wff = syl5ibr (step 1, hyp 1) |- ( ph → ( ch → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduce a commuted implication from a logical equivalence.  (Contributed
       by NM, 3-May-1994.)  (Proof shortened by Wolf Lammen, 22-Sep-2013.) */

theorem biimpcd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ps → ( ph → ch ) ) ;;
}

proof of biimpcd {
	step 1 : wff = id () |- ( ps → ps ) ;;
	step 2 : wff = syl5ibcom (step 1, hyp 1) |- ( ps → ( ph → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduce a converse commuted implication from a logical equivalence.
       (Contributed by NM, 3-May-1994.)  (Proof shortened by Wolf Lammen,
       20-Dec-2013.) */

theorem biimprcd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph → ps ) ) ;;
}

proof of biimprcd {
	step 1 : wff = id () |- ( ch → ch ) ;;
	step 2 : wff = syl5ibrcom (step 1, hyp 1) |- ( ch → ( ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a nested implication and a
       biconditional.  (Contributed by NM, 5-Aug-1993.) */

theorem syl6ib (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of syl6ib {
	step 1 : wff = biimpi (hyp 2) |- ( ch → th ) ;;
	step 2 : wff = syl6 (hyp 1, step 1) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a nested implication and a
       biconditional.  Useful for substituting an embedded consequent with a
       definition.  (Contributed by NM, 5-Aug-1993.) */

theorem syl6ibr (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( th ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of syl6ibr {
	step 1 : wff = biimpri (hyp 2) |- ( ch → th ) ;;
	step 2 : wff = syl6 (hyp 1, step 1) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference.  (Contributed by NM, 2-Jan-1994.) */

theorem syl6bi (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ch → th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of syl6bi {
	step 1 : wff = biimpd (hyp 1) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = syl6 (step 1, hyp 2) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference.  (Contributed by NM, 18-May-1994.) */

theorem syl6bir (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ch ↔ ps ) ) ;;
	hyp 2 : wff = |- ( ch → th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of syl6bir {
	step 1 : wff = biimprd (hyp 1) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = syl6 (step 1, hyp 2) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a doubly nested implication and a
       biconditional.  (Contributed by NM, 5-Aug-1993.) */

theorem syl7bi (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch → ( th → ( ps → ta ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( th → ( ph → ta ) ) ) ;;
}

proof of syl7bi {
	step 1 : wff = biimpi (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = syl7 (step 1, hyp 2) |- ( ch → ( th → ( ph → ta ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism rule of inference.  The second premise is used to replace
       the consequent of the first premise.  (Contributed by NM,
       1-Aug-1994.) */

theorem syl8ib (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ( ch → th ) ) ) ;;
	hyp 2 : wff = |- ( th ↔ ta ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ( ch → ta ) ) ) ;;
}

proof of syl8ib {
	step 1 : wff = biimpi (hyp 2) |- ( th → ta ) ;;
	step 2 : wff = syl8 (hyp 1, step 1) |- ( ph → ( ps → ( ch → ta ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A deduction from a biconditional, related to modus ponens.  (Contributed
       by NM, 5-Aug-1993.) */

theorem mpbird (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ch ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of mpbird {
	step 1 : wff = biimprd (hyp 2) |- ( ph → ( ch → ps ) ) ;;
	step 2 : wff = mpd (hyp 1, step 1) |- ( ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a nested biconditional, related to modus ponens.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen,
       25-Oct-2012.) */

theorem mpbiri (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ch ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of mpbiri {
	step 1 : wff = a1i (hyp 1) |- ( ph → ch ) ;;
	step 2 : wff = mpbird (step 1, hyp 2) |- ( ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism deduction.  (Contributed by NM, 3-Aug-1994.) */

theorem sylibrd (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of sylibrd {
	step 1 : wff = biimprd (hyp 2) |- ( ph → ( ch → th ) ) ;;
	step 2 : wff = syld (hyp 1, step 1) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism deduction.  (Contributed by NM, 3-Aug-1994.) */

theorem sylbird (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ch ↔ ps ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → th ) ) ;;
}

proof of sylbird {
	step 1 : wff = biimprd (hyp 1) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = syld (step 1, hyp 2) |- ( ph → ( ps → th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Principle of identity for logical equivalence.  Theorem *4.2 of
     [WhiteheadRussell] p. 117.  (Contributed by NM, 5-Aug-1993.) */

theorem biid (ph : wff)  {
	prop 1 : wff = |- ( ph ↔ ph ) ;;
}

proof of biid {
	step 1 : wff = id () |- ( ph → ph ) ;;
	step 2 : wff = id () |- ( ph → ph ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ph ↔ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Principle of identity with antecedent.  (Contributed by NM,
     25-Nov-1995.) */

theorem biidd (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ph → ( ps ↔ ps ) ) ;;
}

proof of biidd {
	step 1 : wff = biid () |- ( ps ↔ ps ) ;;
	step 2 : wff = a1i (step 1) |- ( ph → ( ps ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Two propositions are equivalent if they are both true.  Closed form of
     ~ 2th .  Equivalent to a ~ bi1 -like version of the xor-connective.  This
     theorem stays true, no matter how you permute its operands.  This is
     evident from its sharper version
     ` ( ph <-> ( ps <-> ( ph <-> ps ) ) ) ` .  (Contributed by Wolf Lammen,
     12-May-2013.) */

theorem pm5.1im (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ph → ( ps → ( ph ↔ ps ) ) ) ;;
}

proof of pm5.1im {
	step 1 : wff = ax-1 () |- ( ps → ( ph → ps ) ) ;;
	step 2 : wff = ax-1 () |- ( ph → ( ps → ph ) ) ;;
	step 3 : wff = impbid21d (step 1, step 2) |- ( ph → ( ps → ( ph ↔ ps ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Two truths are equivalent.  (Contributed by NM, 18-Aug-1993.) */

theorem 2th (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ph ;;
	hyp 2 : wff = |- ps ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ps ) ;;
}

proof of 2th {
	step 1 : wff = a1i (hyp 2) |- ( ph → ps ) ;;
	step 2 : wff = a1i (hyp 1) |- ( ps → ph ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ph ↔ ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Two truths are equivalent (deduction rule).  (Contributed by NM,
       3-Jun-2012.) */

theorem 2thd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ph → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of 2thd {
	step 1 : wff = pm5.1im () |- ( ps → ( ch → ( ps ↔ ch ) ) ) ;;
	step 2 : wff = sylc (hyp 1, hyp 2, step 1) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference that converts a biconditional implied by one of its arguments,
       into an implication.  (Contributed by NM, 17-Oct-2003.) */

theorem ibi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of ibi {
	step 1 : wff = biimpd (hyp 1) |- ( ph → ( ph → ps ) ) ;;
	step 2 : wff = pm2.43i (step 1) |- ( ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference that converts a biconditional implied by one of its arguments,
       into an implication.  (Contributed by NM, 22-Jul-2004.) */

theorem ibir (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ph ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ps ) ;;
}

proof of ibir {
	step 1 : wff = bicomd (hyp 1) |- ( ph → ( ph ↔ ps ) ) ;;
	step 2 : wff = ibi (step 1) |- ( ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction that converts a biconditional implied by one of its arguments,
       into an implication.  (Contributed by NM, 26-Jun-2004.) */

theorem ibd (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ch ) ) ;;
}

proof of ibd {
	step 1 : wff = bi1 () |- ( ( ps ↔ ch ) → ( ps → ch ) ) ;;
	step 2 : wff = syli (hyp 1, step 1) |- ( ph → ( ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Distribution of implication over biconditional.  Theorem *5.74 of
     [WhiteheadRussell] p. 126.  (Contributed by NM, 1-Aug-1994.)  (Proof
     shortened by Wolf Lammen, 11-Apr-2013.) */

theorem pm5.74 (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph → ( ps ↔ ch ) ) ↔ ( ( ph → ps ) ↔ ( ph → ch ) ) ) ;;
}

proof of pm5.74 {
	step 1 : wff = bi1 () |- ( ( ps ↔ ch ) → ( ps → ch ) ) ;;
	step 2 : wff = imim3i (step 1) |- ( ( ph → ( ps ↔ ch ) ) → ( ( ph → ps ) → ( ph → ch ) ) ) ;;
	step 3 : wff = bi2 () |- ( ( ps ↔ ch ) → ( ch → ps ) ) ;;
	step 4 : wff = imim3i (step 3) |- ( ( ph → ( ps ↔ ch ) ) → ( ( ph → ch ) → ( ph → ps ) ) ) ;;
	step 5 : wff = impbid (step 2, step 4) |- ( ( ph → ( ps ↔ ch ) ) → ( ( ph → ps ) ↔ ( ph → ch ) ) ) ;;
	step 6 : wff = bi1 () |- ( ( ( ph → ps ) ↔ ( ph → ch ) ) → ( ( ph → ps ) → ( ph → ch ) ) ) ;;
	step 7 : wff = pm2.86d (step 6) |- ( ( ( ph → ps ) ↔ ( ph → ch ) ) → ( ph → ( ps → ch ) ) ) ;;
	step 8 : wff = bi2 () |- ( ( ( ph → ps ) ↔ ( ph → ch ) ) → ( ( ph → ch ) → ( ph → ps ) ) ) ;;
	step 9 : wff = pm2.86d (step 8) |- ( ( ( ph → ps ) ↔ ( ph → ch ) ) → ( ph → ( ch → ps ) ) ) ;;
	step 10 : wff = impbidd (step 7, step 9) |- ( ( ( ph → ps ) ↔ ( ph → ch ) ) → ( ph → ( ps ↔ ch ) ) ) ;;
	step 11 : wff = impbii (step 5, step 10) |- ( ( ph → ( ps ↔ ch ) ) ↔ ( ( ph → ps ) ↔ ( ph → ch ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Distribution of implication over biconditional (inference rule).
       (Contributed by NM, 1-Aug-1994.) */

theorem pm5.74i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph → ps ) ↔ ( ph → ch ) ) ;;
}

proof of pm5.74i {
	step 1 : wff = pm5.74 () |- ( ( ph → ( ps ↔ ch ) ) ↔ ( ( ph → ps ) ↔ ( ph → ch ) ) ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- ( ( ph → ps ) ↔ ( ph → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Distribution of implication over biconditional (reverse inference
       rule).  (Contributed by NM, 1-Aug-1994.) */

theorem pm5.74ri (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ( ph → ps ) ↔ ( ph → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of pm5.74ri {
	step 1 : wff = pm5.74 () |- ( ( ph → ( ps ↔ ch ) ) ↔ ( ( ph → ps ) ↔ ( ph → ch ) ) ) ;;
	step 2 : wff = mpbir (hyp 1, step 1) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Distribution of implication over biconditional (deduction rule).
       (Contributed by NM, 21-Mar-1996.) */

theorem pm5.74d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( ps → ch ) ↔ ( ps → th ) ) ) ;;
}

proof of pm5.74d {
	step 1 : wff = pm5.74 () |- ( ( ps → ( ch ↔ th ) ) ↔ ( ( ps → ch ) ↔ ( ps → th ) ) ) ;;
	step 2 : wff = sylib (hyp 1, step 1) |- ( ph → ( ( ps → ch ) ↔ ( ps → th ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Distribution of implication over biconditional (deduction rule).
       (Contributed by NM, 19-Mar-1997.) */

theorem pm5.74rd (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ( ps → ch ) ↔ ( ps → th ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
}

proof of pm5.74rd {
	step 1 : wff = pm5.74 () |- ( ( ps → ( ch ↔ th ) ) ↔ ( ( ps → ch ) ↔ ( ps → th ) ) ) ;;
	step 2 : wff = sylibr (hyp 1, step 1) |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from transitive law for logical equivalence.  (Contributed
       by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen, 13-Oct-2012.) */

theorem bitri (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ch ) ;;
}

proof of bitri {
	step 1 : wff = biimpi (hyp 1) |- ( ph → ps ) ;;
	step 2 : wff = sylib (step 1, hyp 2) |- ( ph → ch ) ;;
	step 3 : wff = biimpri (hyp 2) |- ( ch → ps ) ;;
	step 4 : wff = sylibr (step 3, hyp 1) |- ( ch → ph ) ;;
	step 5 : wff = impbii (step 2, step 4) |- ( ph ↔ ch ) ;;
	qed prop 1 = step 5 ;;
}

/* An inference from transitive law for logical equivalence.  (Contributed
       by NM, 5-Aug-1993.) */

theorem bitr2i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ch ↔ ph ) ;;
}

proof of bitr2i {
	step 1 : wff = bitri (hyp 1, hyp 2) |- ( ph ↔ ch ) ;;
	step 2 : wff = bicomi (step 1) |- ( ch ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from transitive law for logical equivalence.  (Contributed
       by NM, 5-Aug-1993.) */

theorem bitr3i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ps ↔ ph ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ch ) ;;
}

proof of bitr3i {
	step 1 : wff = bicomi (hyp 1) |- ( ph ↔ ps ) ;;
	step 2 : wff = bitri (step 1, hyp 2) |- ( ph ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from transitive law for logical equivalence.  (Contributed
       by NM, 5-Aug-1993.) */

theorem bitr4i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ch ) ;;
}

proof of bitr4i {
	step 1 : wff = bicomi (hyp 2) |- ( ps ↔ ch ) ;;
	step 2 : wff = bitri (hyp 1, step 1) |- ( ph ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* Register '<->' as an equality for its type (wff). */

/* $j
    equality 'wb' from 'biid' 'bicomi' 'bitri';
    definition 'dfbi1' for 'wb';
  */

/* Deduction form of ~ bitri .  (Contributed by NM, 5-Aug-1993.)  (Proof
       shortened by Wolf Lammen, 14-Apr-2013.) */

theorem bitrd (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ th ) ) ;;
}

proof of bitrd {
	step 1 : wff = pm5.74i (hyp 1) |- ( ( ph → ps ) ↔ ( ph → ch ) ) ;;
	step 2 : wff = pm5.74i (hyp 2) |- ( ( ph → ch ) ↔ ( ph → th ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ( ph → ps ) ↔ ( ph → th ) ) ;;
	step 4 : wff = pm5.74ri (step 3) |- ( ph → ( ps ↔ th ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Deduction form of ~ bitr2i .  (Contributed by NM, 9-Jun-2004.) */

theorem bitr2d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ps ) ) ;;
}

proof of bitr2d {
	step 1 : wff = bitrd (hyp 1, hyp 2) |- ( ph → ( ps ↔ th ) ) ;;
	step 2 : wff = bicomd (step 1) |- ( ph → ( th ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction form of ~ bitr3i .  (Contributed by NM, 5-Aug-1993.) */

theorem bitr3d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch ↔ th ) ) ;;
}

proof of bitr3d {
	step 1 : wff = bicomd (hyp 1) |- ( ph → ( ch ↔ ps ) ) ;;
	step 2 : wff = bitrd (step 1, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction form of ~ bitr4i .  (Contributed by NM, 5-Aug-1993.) */

theorem bitr4d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ th ) ) ;;
}

proof of bitr4d {
	step 1 : wff = bicomd (hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 2 : wff = bitrd (hyp 1, step 1) |- ( ph → ( ps ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       5-Aug-1993.) */

theorem syl5bb (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph ↔ th ) ) ;;
}

proof of syl5bb {
	step 1 : wff = a1i (hyp 1) |- ( ch → ( ph ↔ ps ) ) ;;
	step 2 : wff = bitrd (step 1, hyp 2) |- ( ch → ( ph ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       5-Aug-1993.) */

theorem syl5rbb (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( th ↔ ph ) ) ;;
}

proof of syl5rbb {
	step 1 : wff = syl5bb (hyp 1, hyp 2) |- ( ch → ( ph ↔ th ) ) ;;
	step 2 : wff = bicomd (step 1) |- ( ch → ( th ↔ ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       5-Aug-1993.) */

theorem syl5bbr (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ps ↔ ph ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph ↔ th ) ) ;;
}

proof of syl5bbr {
	step 1 : wff = bicomi (hyp 1) |- ( ph ↔ ps ) ;;
	step 2 : wff = syl5bb (step 1, hyp 2) |- ( ch → ( ph ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       25-Nov-1994.) */

theorem syl5rbbr (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ps ↔ ph ) ;;
	hyp 2 : wff = |- ( ch → ( ps ↔ th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( th ↔ ph ) ) ;;
}

proof of syl5rbbr {
	step 1 : wff = bicomi (hyp 1) |- ( ph ↔ ps ) ;;
	step 2 : wff = syl5rbb (step 1, hyp 2) |- ( ch → ( th ↔ ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       5-Aug-1993.) */

theorem syl6bb (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ th ) ) ;;
}

proof of syl6bb {
	step 1 : wff = a1i (hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 2 : wff = bitrd (hyp 1, step 1) |- ( ph → ( ps ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       5-Aug-1993.) */

theorem syl6rbb (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ps ) ) ;;
}

proof of syl6rbb {
	step 1 : wff = syl6bb (hyp 1, hyp 2) |- ( ph → ( ps ↔ th ) ) ;;
	step 2 : wff = bicomd (step 1) |- ( ph → ( th ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       5-Aug-1993.) */

theorem syl6bbr (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( th ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ th ) ) ;;
}

proof of syl6bbr {
	step 1 : wff = bicomi (hyp 2) |- ( ch ↔ th ) ;;
	step 2 : wff = syl6bb (hyp 1, step 1) |- ( ph → ( ps ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A syllogism inference from two biconditionals.  (Contributed by NM,
       25-Nov-1994.) */

theorem syl6rbbr (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( th ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ps ) ) ;;
}

proof of syl6rbbr {
	step 1 : wff = bicomi (hyp 2) |- ( ch ↔ th ) ;;
	step 2 : wff = syl6rbb (hyp 1, step 1) |- ( ph → ( th ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference, useful for removing a definition from both
       sides of an implication.  (Contributed by NM, 10-Aug-1994.) */

theorem 3imtr3i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ph ↔ ch ) ;;
	hyp 3 : wff = |- ( ps ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → th ) ;;
}

proof of 3imtr3i {
	step 1 : wff = sylbir (hyp 2, hyp 1) |- ( ch → ps ) ;;
	step 2 : wff = sylib (step 1, hyp 3) |- ( ch → th ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference, useful for applying a definition to both
       sides of an implication.  (Contributed by NM, 5-Aug-1993.) */

theorem 3imtr4i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ph ) ;;
	hyp 3 : wff = |- ( th ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → th ) ;;
}

proof of 3imtr4i {
	step 1 : wff = sylbi (hyp 2, hyp 1) |- ( ch → ps ) ;;
	step 2 : wff = sylibr (step 1, hyp 3) |- ( ch → th ) ;;
	qed prop 1 = step 2 ;;
}

/* More general version of ~ 3imtr3i .  Useful for converting conditional
       definitions in a formula.  (Contributed by NM, 8-Apr-1996.) */

theorem 3imtr3d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ th ) ) ;;
	hyp 3 : wff = |- ( ph → ( ch ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th → ta ) ) ;;
}

proof of 3imtr3d {
	step 1 : wff = sylibd (hyp 1, hyp 3) |- ( ph → ( ps → ta ) ) ;;
	step 2 : wff = sylbird (hyp 2, step 1) |- ( ph → ( th → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* More general version of ~ 3imtr4i .  Useful for converting conditional
       definitions in a formula.  (Contributed by NM, 26-Oct-1995.) */

theorem 3imtr4d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ps ) ) ;;
	hyp 3 : wff = |- ( ph → ( ta ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th → ta ) ) ;;
}

proof of 3imtr4d {
	step 1 : wff = sylibrd (hyp 1, hyp 3) |- ( ph → ( ps → ta ) ) ;;
	step 2 : wff = sylbid (hyp 2, step 1) |- ( ph → ( th → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* More general version of ~ 3imtr3i .  Useful for converting definitions
       in a formula.  (Contributed by NM, 20-May-1996.)  (Proof shortened by
       Wolf Lammen, 20-Dec-2013.) */

theorem 3imtr3g (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ps ↔ th ) ;;
	hyp 3 : wff = |- ( ch ↔ ta ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th → ta ) ) ;;
}

proof of 3imtr3g {
	step 1 : wff = syl5bir (hyp 2, hyp 1) |- ( ph → ( th → ch ) ) ;;
	step 2 : wff = syl6ib (step 1, hyp 3) |- ( ph → ( th → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* More general version of ~ 3imtr4i .  Useful for converting definitions
       in a formula.  (Contributed by NM, 20-May-1996.)  (Proof shortened by
       Wolf Lammen, 20-Dec-2013.) */

theorem 3imtr4g (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( th ↔ ps ) ;;
	hyp 3 : wff = |- ( ta ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th → ta ) ) ;;
}

proof of 3imtr4g {
	step 1 : wff = syl5bi (hyp 2, hyp 1) |- ( ph → ( th → ch ) ) ;;
	step 2 : wff = syl6ibr (step 1, hyp 3) |- ( ph → ( th → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 5-Aug-1993.) */

theorem 3bitri (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	hyp 3 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ th ) ;;
}

proof of 3bitri {
	step 1 : wff = bitri (hyp 2, hyp 3) |- ( ps ↔ th ) ;;
	step 2 : wff = bitri (hyp 1, step 1) |- ( ph ↔ th ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 4-Aug-2006.) */

theorem 3bitrri (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	hyp 3 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( th ↔ ph ) ;;
}

proof of 3bitrri {
	step 1 : wff = bitr2i (hyp 1, hyp 2) |- ( ch ↔ ph ) ;;
	step 2 : wff = bitr3i (hyp 3, step 1) |- ( th ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 4-Aug-2006.) */

theorem 3bitr2i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ps ) ;;
	hyp 3 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ th ) ;;
}

proof of 3bitr2i {
	step 1 : wff = bitr4i (hyp 1, hyp 2) |- ( ph ↔ ch ) ;;
	step 2 : wff = bitri (step 1, hyp 3) |- ( ph ↔ th ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 4-Aug-2006.) */

theorem 3bitr2ri (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ps ) ;;
	hyp 3 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( th ↔ ph ) ;;
}

proof of 3bitr2ri {
	step 1 : wff = bitr4i (hyp 1, hyp 2) |- ( ph ↔ ch ) ;;
	step 2 : wff = bitr2i (step 1, hyp 3) |- ( th ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 19-Aug-1993.) */

theorem 3bitr3i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ph ↔ ch ) ;;
	hyp 3 : wff = |- ( ps ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ch ↔ th ) ;;
}

proof of 3bitr3i {
	step 1 : wff = bitr3i (hyp 2, hyp 1) |- ( ch ↔ ps ) ;;
	step 2 : wff = bitri (step 1, hyp 3) |- ( ch ↔ th ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 5-Aug-1993.) */

theorem 3bitr3ri (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ph ↔ ch ) ;;
	hyp 3 : wff = |- ( ps ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( th ↔ ch ) ;;
}

proof of 3bitr3ri {
	step 1 : wff = bitr3i (hyp 1, hyp 2) |- ( ps ↔ ch ) ;;
	step 2 : wff = bitr3i (hyp 3, step 1) |- ( th ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.  This
       inference is frequently used to apply a definition to both sides of a
       logical equivalence.  (Contributed by NM, 5-Aug-1993.) */

theorem 3bitr4i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ph ) ;;
	hyp 3 : wff = |- ( th ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ch ↔ th ) ;;
}

proof of 3bitr4i {
	step 1 : wff = bitr4i (hyp 1, hyp 3) |- ( ph ↔ th ) ;;
	step 2 : wff = bitri (hyp 2, step 1) |- ( ch ↔ th ) ;;
	qed prop 1 = step 2 ;;
}

/* A chained inference from transitive law for logical equivalence.
       (Contributed by NM, 2-Sep-1995.) */

theorem 3bitr4ri (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ph ) ;;
	hyp 3 : wff = |- ( th ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( th ↔ ch ) ;;
}

proof of 3bitr4ri {
	step 1 : wff = bitr4i (hyp 1, hyp 3) |- ( ph ↔ th ) ;;
	step 2 : wff = bitr2i (hyp 2, step 1) |- ( th ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  (Contributed by NM,
       13-Aug-1999.) */

theorem 3bitrd (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( ph → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ta ) ) ;;
}

proof of 3bitrd {
	step 1 : wff = bitrd (hyp 1, hyp 2) |- ( ph → ( ps ↔ th ) ) ;;
	step 2 : wff = bitrd (step 1, hyp 3) |- ( ph → ( ps ↔ ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3bitrrd (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch ↔ th ) ) ;;
	hyp 3 : wff = |- ( ph → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ta ↔ ps ) ) ;;
}

proof of 3bitrrd {
	step 1 : wff = bitr2d (hyp 1, hyp 2) |- ( ph → ( th ↔ ps ) ) ;;
	step 2 : wff = bitr3d (hyp 3, step 1) |- ( ph → ( ta ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3bitr2d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ch ) ) ;;
	hyp 3 : wff = |- ( ph → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ta ) ) ;;
}

proof of 3bitr2d {
	step 1 : wff = bitr4d (hyp 1, hyp 2) |- ( ph → ( ps ↔ th ) ) ;;
	step 2 : wff = bitrd (step 1, hyp 3) |- ( ph → ( ps ↔ ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3bitr2rd (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ch ) ) ;;
	hyp 3 : wff = |- ( ph → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ta ↔ ps ) ) ;;
}

proof of 3bitr2rd {
	step 1 : wff = bitr4d (hyp 1, hyp 2) |- ( ph → ( ps ↔ th ) ) ;;
	step 2 : wff = bitr2d (step 1, hyp 3) |- ( ph → ( ta ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  Useful for converting
       conditional definitions in a formula.  (Contributed by NM,
       24-Apr-1996.) */

theorem 3bitr3d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ th ) ) ;;
	hyp 3 : wff = |- ( ph → ( ch ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ta ) ) ;;
}

proof of 3bitr3d {
	step 1 : wff = bitr3d (hyp 2, hyp 1) |- ( ph → ( th ↔ ch ) ) ;;
	step 2 : wff = bitrd (step 1, hyp 3) |- ( ph → ( th ↔ ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3bitr3rd (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ th ) ) ;;
	hyp 3 : wff = |- ( ph → ( ch ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ta ↔ th ) ) ;;
}

proof of 3bitr3rd {
	step 1 : wff = bitr3d (hyp 1, hyp 2) |- ( ph → ( ch ↔ th ) ) ;;
	step 2 : wff = bitr3d (hyp 3, step 1) |- ( ph → ( ta ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  Useful for converting
       conditional definitions in a formula.  (Contributed by NM,
       18-Oct-1995.) */

theorem 3bitr4d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ps ) ) ;;
	hyp 3 : wff = |- ( ph → ( ta ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ta ) ) ;;
}

proof of 3bitr4d {
	step 1 : wff = bitr4d (hyp 1, hyp 3) |- ( ph → ( ps ↔ ta ) ) ;;
	step 2 : wff = bitrd (hyp 2, step 1) |- ( ph → ( th ↔ ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction from transitivity of biconditional.  (Contributed by NM,
       4-Aug-2006.) */

theorem 3bitr4rd (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ps ) ) ;;
	hyp 3 : wff = |- ( ph → ( ta ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ta ↔ th ) ) ;;
}

proof of 3bitr4rd {
	step 1 : wff = bitr4d (hyp 3, hyp 1) |- ( ph → ( ta ↔ ps ) ) ;;
	step 2 : wff = bitr4d (step 1, hyp 2) |- ( ph → ( ta ↔ th ) ) ;;
	qed prop 1 = step 2 ;;
}

/* More general version of ~ 3bitr3i .  Useful for converting definitions
       in a formula.  (Contributed by NM, 4-Jun-1995.) */

theorem 3bitr3g (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ps ↔ th ) ;;
	hyp 3 : wff = |- ( ch ↔ ta ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ta ) ) ;;
}

proof of 3bitr3g {
	step 1 : wff = syl5bbr (hyp 2, hyp 1) |- ( ph → ( th ↔ ch ) ) ;;
	step 2 : wff = syl6bb (step 1, hyp 3) |- ( ph → ( th ↔ ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* More general version of ~ 3bitr4i .  Useful for converting definitions
       in a formula.  (Contributed by NM, 5-Aug-1993.) */

theorem 3bitr4g (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( th ↔ ps ) ;;
	hyp 3 : wff = |- ( ta ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( th ↔ ta ) ) ;;
}

proof of 3bitr4g {
	step 1 : wff = syl5bb (hyp 2, hyp 1) |- ( ph → ( th ↔ ch ) ) ;;
	step 2 : wff = syl6bbr (step 1, hyp 3) |- ( ph → ( th ↔ ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Construct a bi-conditional in antecedent position.  (Contributed by Wolf
       Lammen, 14-May-2013.) */

theorem bi3ant (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ( th → ta ) → ph ) → ( ( ( ta → th ) → ps ) → ( ( th ↔ ta ) → ch ) ) ) ;;
}

proof of bi3ant {
	step 1 : wff = bi1 () |- ( ( th ↔ ta ) → ( th → ta ) ) ;;
	step 2 : wff = imim1i (step 1) |- ( ( ( th → ta ) → ph ) → ( ( th ↔ ta ) → ph ) ) ;;
	step 3 : wff = bi2 () |- ( ( th ↔ ta ) → ( ta → th ) ) ;;
	step 4 : wff = imim1i (step 3) |- ( ( ( ta → th ) → ps ) → ( ( th ↔ ta ) → ps ) ) ;;
	step 5 : wff = imim3i (hyp 1) |- ( ( ( th ↔ ta ) → ph ) → ( ( ( th ↔ ta ) → ps ) → ( ( th ↔ ta ) → ch ) ) ) ;;
	step 6 : wff = syl2im (step 2, step 4, step 5) |- ( ( ( th → ta ) → ph ) → ( ( ( ta → th ) → ps ) → ( ( th ↔ ta ) → ch ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Express symmetries of theorems in terms of biconditionals.  (Contributed
     by Wolf Lammen, 14-May-2013.) */

theorem bisym (ph : wff, ps : wff, ch : wff, th : wff)  {
	prop 1 : wff = |- ( ( ( ph → ps ) → ( ch → th ) ) → ( ( ( ps → ph ) → ( th → ch ) ) → ( ( ph ↔ ps ) → ( ch ↔ th ) ) ) ) ;;
}

proof of bisym {
	step 1 : wff = bi3 () |- ( ( ch → th ) → ( ( th → ch ) → ( ch ↔ th ) ) ) ;;
	step 2 : wff = bi3ant (step 1) |- ( ( ( ph → ps ) → ( ch → th ) ) → ( ( ( ps → ph ) → ( th → ch ) ) → ( ( ph ↔ ps ) → ( ch ↔ th ) ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Double negation.  Theorem *4.13 of [WhiteheadRussell] p. 117.
     (Contributed by NM, 5-Aug-1993.) */

theorem notnot (ph : wff)  {
	prop 1 : wff = |- ( ph ↔ ¬ ¬ ph ) ;;
}

proof of notnot {
	step 1 : wff = notnot1 () |- ( ph → ¬ ¬ ph ) ;;
	step 2 : wff = notnot2 () |- ( ¬ ¬ ph → ph ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ph ↔ ¬ ¬ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Contraposition.  Theorem *4.1 of [WhiteheadRussell] p. 116.  (Contributed
     by NM, 5-Aug-1993.) */

theorem con34b (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ps ) ↔ ( ¬ ps → ¬ ph ) ) ;;
}

proof of con34b {
	step 1 : wff = con3 () |- ( ( ph → ps ) → ( ¬ ps → ¬ ph ) ) ;;
	step 2 : wff = ax-3 () |- ( ( ¬ ps → ¬ ph ) → ( ph → ps ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph → ps ) ↔ ( ¬ ps → ¬ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* A contraposition deduction.  (Contributed by NM, 21-May-1994.) */

theorem con4bid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ¬ ps ↔ ¬ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of con4bid {
	step 1 : wff = biimprd (hyp 1) |- ( ph → ( ¬ ch → ¬ ps ) ) ;;
	step 2 : wff = con4d (step 1) |- ( ph → ( ps → ch ) ) ;;
	step 3 : wff = biimpd (hyp 1) |- ( ph → ( ¬ ps → ¬ ch ) ) ;;
	step 4 : wff = impcon4bid (step 2, step 3) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Deduction negating both sides of a logical equivalence.  (Contributed by
       NM, 21-May-1994.) */

theorem notbid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ¬ ps ↔ ¬ ch ) ) ;;
}

proof of notbid {
	step 1 : wff = notnot () |- ( ps ↔ ¬ ¬ ps ) ;;
	step 2 : wff = notnot () |- ( ch ↔ ¬ ¬ ch ) ;;
	step 3 : wff = 3bitr3g (hyp 1, step 1, step 2) |- ( ph → ( ¬ ¬ ps ↔ ¬ ¬ ch ) ) ;;
	step 4 : wff = con4bid (step 3) |- ( ph → ( ¬ ps ↔ ¬ ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Contraposition.  Theorem *4.11 of [WhiteheadRussell] p. 117.  (Contributed
     by NM, 21-May-1994.)  (Proof shortened by Wolf Lammen, 12-Jun-2013.) */

theorem notbi (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) ↔ ( ¬ ph ↔ ¬ ps ) ) ;;
}

proof of notbi {
	step 1 : wff = id () |- ( ( ph ↔ ps ) → ( ph ↔ ps ) ) ;;
	step 2 : wff = notbid (step 1) |- ( ( ph ↔ ps ) → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 3 : wff = id () |- ( ( ¬ ph ↔ ¬ ps ) → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 4 : wff = con4bid (step 3) |- ( ( ¬ ph ↔ ¬ ps ) → ( ph ↔ ps ) ) ;;
	step 5 : wff = impbii (step 2, step 4) |- ( ( ph ↔ ps ) ↔ ( ¬ ph ↔ ¬ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Negate both sides of a logical equivalence.  (Contributed by NM,
       5-Aug-1993.)  (Proof shortened by Wolf Lammen, 19-May-2013.) */

theorem notbii (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ph ↔ ¬ ps ) ;;
}

proof of notbii {
	step 1 : wff = notbi () |- ( ( ph ↔ ps ) ↔ ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = mpbi (hyp 1, step 1) |- ( ¬ ph ↔ ¬ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Theorem notbii is the congruence law for negation. */

/* $j congruence 'notbii'; */

/* A contraposition inference.  (Contributed by NM, 21-May-1994.) */

theorem con4bii (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ¬ ph ↔ ¬ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ps ) ;;
}

proof of con4bii {
	step 1 : wff = notbi () |- ( ( ph ↔ ps ) ↔ ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = mpbir (hyp 1, step 1) |- ( ph ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a biconditional, related to modus tollens.
       (Contributed by NM, 15-Nov-1994.)  (Proof shortened by Wolf Lammen,
       25-Oct-2012.) */

theorem mtbi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ¬ ph ;;
	hyp 2 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ¬ ps ;;
}

proof of mtbi {
	step 1 : wff = biimpri (hyp 2) |- ( ps → ph ) ;;
	step 2 : wff = mto (hyp 1, step 1) |- ¬ ps ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a biconditional, related to modus tollens.
       (Contributed by NM, 15-Nov-1994.)  (Proof shortened by Wolf Lammen,
       14-Oct-2012.) */

theorem mtbir (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ¬ ps ;;
	hyp 2 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ¬ ph ;;
}

proof of mtbir {
	step 1 : wff = bicomi (hyp 2) |- ( ps ↔ ph ) ;;
	step 2 : wff = mtbi (hyp 1, step 1) |- ¬ ph ;;
	qed prop 1 = step 2 ;;
}

/* A deduction from a biconditional, similar to modus tollens.
       (Contributed by NM, 26-Nov-1995.) */

theorem mtbid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ¬ ps ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ch ) ;;
}

proof of mtbid {
	step 1 : wff = biimprd (hyp 2) |- ( ph → ( ch → ps ) ) ;;
	step 2 : wff = mtod (hyp 1, step 1) |- ( ph → ¬ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A deduction from a biconditional, similar to modus tollens.
       (Contributed by NM, 10-May-1994.) */

theorem mtbird (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ¬ ch ) ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ps ) ;;
}

proof of mtbird {
	step 1 : wff = biimpd (hyp 2) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = mtod (hyp 1, step 1) |- ( ph → ¬ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a biconditional, similar to modus tollens.
       (Contributed by NM, 27-Nov-1995.) */

theorem mtbii (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ¬ ps ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ch ) ;;
}

proof of mtbii {
	step 1 : wff = biimprd (hyp 2) |- ( ph → ( ch → ps ) ) ;;
	step 2 : wff = mtoi (hyp 1, step 1) |- ( ph → ¬ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* An inference from a biconditional, similar to modus tollens.
       (Contributed by NM, 24-Aug-1995.) */

theorem mtbiri (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ¬ ch ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ps ) ;;
}

proof of mtbiri {
	step 1 : wff = biimpd (hyp 2) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = mtoi (hyp 1, step 1) |- ( ph → ¬ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from an implication and a biconditional.
       (Contributed by Wolf Lammen, 16-Dec-2013.) */

theorem sylnib (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ¬ ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ch ) ;;
}

proof of sylnib {
	step 1 : wff = a1i (hyp 2) |- ( ph → ( ps ↔ ch ) ) ;;
	step 2 : wff = mtbid (hyp 1, step 1) |- ( ph → ¬ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from an implication and a biconditional.
       Useful for substituting a consequent with a definition.  (Contributed by
       Wolf Lammen, 16-Dec-2013.) */

theorem sylnibr (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ¬ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ¬ ch ) ;;
}

proof of sylnibr {
	step 1 : wff = bicomi (hyp 2) |- ( ps ↔ ch ) ;;
	step 2 : wff = sylnib (hyp 1, step 1) |- ( ph → ¬ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a biconditional and an implication.
       Useful for substituting an antecedent with a definition.  (Contributed
       by Wolf Lammen, 16-Dec-2013.) */

theorem sylnbi (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ¬ ps → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ph → ch ) ;;
}

proof of sylnbi {
	step 1 : wff = notbii (hyp 1) |- ( ¬ ph ↔ ¬ ps ) ;;
	step 2 : wff = sylbi (step 1, hyp 2) |- ( ¬ ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* A mixed syllogism inference from a biconditional and an implication.
       (Contributed by Wolf Lammen, 16-Dec-2013.) */

theorem sylnbir (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ps ↔ ph ) ;;
	hyp 2 : wff = |- ( ¬ ps → ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ph → ch ) ;;
}

proof of sylnbir {
	step 1 : wff = bicomi (hyp 1) |- ( ph ↔ ps ) ;;
	step 2 : wff = sylnbi (step 1, hyp 2) |- ( ¬ ph → ch ) ;;
	qed prop 1 = step 2 ;;
}

/* Replacement of a subexpression by an equivalent one.  (Contributed by
       Wolf Lammen, 27-Sep-2014.) */

theorem xchnxbi (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ¬ ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ph ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ch ↔ ps ) ;;
}

proof of xchnxbi {
	step 1 : wff = notbii (hyp 2) |- ( ¬ ph ↔ ¬ ch ) ;;
	step 2 : wff = bitr3i (step 1, hyp 1) |- ( ¬ ch ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Replacement of a subexpression by an equivalent one.  (Contributed by
       Wolf Lammen, 27-Sep-2014.) */

theorem xchnxbir (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ¬ ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ch ↔ ps ) ;;
}

proof of xchnxbir {
	step 1 : wff = bicomi (hyp 2) |- ( ph ↔ ch ) ;;
	step 2 : wff = xchnxbi (hyp 1, step 1) |- ( ¬ ch ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Replacement of a subexpression by an equivalent one.  (Contributed by
       Wolf Lammen, 27-Sep-2014.) */

theorem xchbinx (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ¬ ps ) ;;
	hyp 2 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ¬ ch ) ;;
}

proof of xchbinx {
	step 1 : wff = notbii (hyp 2) |- ( ¬ ps ↔ ¬ ch ) ;;
	step 2 : wff = bitri (hyp 1, step 1) |- ( ph ↔ ¬ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* Replacement of a subexpression by an equivalent one.  (Contributed by
       Wolf Lammen, 27-Sep-2014.) */

theorem xchbinxr (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ¬ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ¬ ch ) ;;
}

proof of xchbinxr {
	step 1 : wff = bicomi (hyp 2) |- ( ps ↔ ch ) ;;
	step 2 : wff = xchbinx (hyp 1, step 1) |- ( ph ↔ ¬ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* The next three rules are useful for building up wff's around a
     definition, in order to make use of the definition. */

/* Introduce an antecedent to both sides of a logical equivalence.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen,
       6-Feb-2013.) */

theorem imbi2i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ch → ph ) ↔ ( ch → ps ) ) ;;
}

proof of imbi2i {
	step 1 : wff = a1i (hyp 1) |- ( ch → ( ph ↔ ps ) ) ;;
	step 2 : wff = pm5.74i (step 1) |- ( ( ch → ph ) ↔ ( ch → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference adding a biconditional to the left in an equivalence.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Andrew Salmon,
       7-May-2011.)  (Proof shortened by Wolf Lammen, 16-May-2013.) */

theorem bibi2i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ch ↔ ph ) ↔ ( ch ↔ ps ) ) ;;
}

proof of bibi2i {
	step 1 : wff = id () |- ( ( ch ↔ ph ) → ( ch ↔ ph ) ) ;;
	step 2 : wff = syl6bb (step 1, hyp 1) |- ( ( ch ↔ ph ) → ( ch ↔ ps ) ) ;;
	step 3 : wff = id () |- ( ( ch ↔ ps ) → ( ch ↔ ps ) ) ;;
	step 4 : wff = syl6bbr (step 3, hyp 1) |- ( ( ch ↔ ps ) → ( ch ↔ ph ) ) ;;
	step 5 : wff = impbii (step 2, step 4) |- ( ( ch ↔ ph ) ↔ ( ch ↔ ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Inference adding a biconditional to the right in an equivalence.
       (Contributed by NM, 5-Aug-1993.) */

theorem bibi1i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ↔ ch ) ↔ ( ps ↔ ch ) ) ;;
}

proof of bibi1i {
	step 1 : wff = bicom () |- ( ( ph ↔ ch ) ↔ ( ch ↔ ph ) ) ;;
	step 2 : wff = bibi2i (hyp 1) |- ( ( ch ↔ ph ) ↔ ( ch ↔ ps ) ) ;;
	step 3 : wff = bicom () |- ( ( ch ↔ ps ) ↔ ( ps ↔ ch ) ) ;;
	step 4 : wff = 3bitri (step 1, step 2, step 3) |- ( ( ph ↔ ch ) ↔ ( ps ↔ ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* The equivalence of two equivalences.  (Contributed by NM,
         5-Aug-1993.) */

theorem bibi12i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ↔ ch ) ↔ ( ps ↔ th ) ) ;;
}

proof of bibi12i {
	step 1 : wff = bibi2i (hyp 2) |- ( ( ph ↔ ch ) ↔ ( ph ↔ th ) ) ;;
	step 2 : wff = bibi1i (hyp 1) |- ( ( ph ↔ th ) ↔ ( ps ↔ th ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ( ph ↔ ch ) ↔ ( ps ↔ th ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction adding an antecedent to both sides of a logical equivalence.
       (Contributed by NM, 5-Aug-1993.) */

theorem imbi2d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( th → ps ) ↔ ( th → ch ) ) ) ;;
}

proof of imbi2d {
	step 1 : wff = a1d (hyp 1) |- ( ph → ( th → ( ps ↔ ch ) ) ) ;;
	step 2 : wff = pm5.74d (step 1) |- ( ph → ( ( th → ps ) ↔ ( th → ch ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction adding a consequent to both sides of a logical equivalence.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen,
       17-Sep-2013.) */

theorem imbi1d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( ps → th ) ↔ ( ch → th ) ) ) ;;
}

proof of imbi1d {
	step 1 : wff = biimprd (hyp 1) |- ( ph → ( ch → ps ) ) ;;
	step 2 : wff = imim1d (step 1) |- ( ph → ( ( ps → th ) → ( ch → th ) ) ) ;;
	step 3 : wff = biimpd (hyp 1) |- ( ph → ( ps → ch ) ) ;;
	step 4 : wff = imim1d (step 3) |- ( ph → ( ( ch → th ) → ( ps → th ) ) ) ;;
	step 5 : wff = impbid (step 2, step 4) |- ( ph → ( ( ps → th ) ↔ ( ch → th ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Deduction adding a biconditional to the left in an equivalence.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen,
       19-May-2013.) */

theorem bibi2d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( th ↔ ps ) ↔ ( th ↔ ch ) ) ) ;;
}

proof of bibi2d {
	step 1 : wff = pm5.74i (hyp 1) |- ( ( ph → ps ) ↔ ( ph → ch ) ) ;;
	step 2 : wff = bibi2i (step 1) |- ( ( ( ph → th ) ↔ ( ph → ps ) ) ↔ ( ( ph → th ) ↔ ( ph → ch ) ) ) ;;
	step 3 : wff = pm5.74 () |- ( ( ph → ( th ↔ ps ) ) ↔ ( ( ph → th ) ↔ ( ph → ps ) ) ) ;;
	step 4 : wff = pm5.74 () |- ( ( ph → ( th ↔ ch ) ) ↔ ( ( ph → th ) ↔ ( ph → ch ) ) ) ;;
	step 5 : wff = 3bitr4i (step 2, step 3, step 4) |- ( ( ph → ( th ↔ ps ) ) ↔ ( ph → ( th ↔ ch ) ) ) ;;
	step 6 : wff = pm5.74ri (step 5) |- ( ph → ( ( th ↔ ps ) ↔ ( th ↔ ch ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Deduction adding a biconditional to the right in an equivalence.
       (Contributed by NM, 5-Aug-1993.) */

theorem bibi1d (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( ps ↔ th ) ↔ ( ch ↔ th ) ) ) ;;
}

proof of bibi1d {
	step 1 : wff = bibi2d (hyp 1) |- ( ph → ( ( th ↔ ps ) ↔ ( th ↔ ch ) ) ) ;;
	step 2 : wff = bicom () |- ( ( ps ↔ th ) ↔ ( th ↔ ps ) ) ;;
	step 3 : wff = bicom () |- ( ( ch ↔ th ) ↔ ( th ↔ ch ) ) ;;
	step 4 : wff = 3bitr4g (step 1, step 2, step 3) |- ( ph → ( ( ps ↔ th ) ↔ ( ch ↔ th ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Deduction joining two equivalences to form equivalence of implications.
       (Contributed by NM, 5-Aug-1993.) */

theorem imbi12d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( ps → th ) ↔ ( ch → ta ) ) ) ;;
}

proof of imbi12d {
	step 1 : wff = imbi1d (hyp 1) |- ( ph → ( ( ps → th ) ↔ ( ch → th ) ) ) ;;
	step 2 : wff = imbi2d (hyp 2) |- ( ph → ( ( ch → th ) ↔ ( ch → ta ) ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( ( ps → th ) ↔ ( ch → ta ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction joining two equivalences to form equivalence of
       biconditionals.  (Contributed by NM, 5-Aug-1993.) */

theorem bibi12d (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ( ps ↔ th ) ↔ ( ch ↔ ta ) ) ) ;;
}

proof of bibi12d {
	step 1 : wff = bibi1d (hyp 1) |- ( ph → ( ( ps ↔ th ) ↔ ( ch ↔ th ) ) ) ;;
	step 2 : wff = bibi2d (hyp 2) |- ( ph → ( ( ch ↔ th ) ↔ ( ch ↔ ta ) ) ) ;;
	step 3 : wff = bitrd (step 1, step 2) |- ( ph → ( ( ps ↔ th ) ↔ ( ch ↔ ta ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem *4.84 of [WhiteheadRussell] p. 122.  (Contributed by NM,
     3-Jan-2005.) */

theorem imbi1 (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → ( ( ph → ch ) ↔ ( ps → ch ) ) ) ;;
}

proof of imbi1 {
	step 1 : wff = id () |- ( ( ph ↔ ps ) → ( ph ↔ ps ) ) ;;
	step 2 : wff = imbi1d (step 1) |- ( ( ph ↔ ps ) → ( ( ph → ch ) ↔ ( ps → ch ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Theorem *4.85 of [WhiteheadRussell] p. 122.  (Contributed by NM,
     3-Jan-2005.)  (Proof shortened by Wolf Lammen, 19-May-2013.) */

theorem imbi2 (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → ( ( ch → ph ) ↔ ( ch → ps ) ) ) ;;
}

proof of imbi2 {
	step 1 : wff = id () |- ( ( ph ↔ ps ) → ( ph ↔ ps ) ) ;;
	step 2 : wff = imbi2d (step 1) |- ( ( ph ↔ ps ) → ( ( ch → ph ) ↔ ( ch → ps ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Introduce a consequent to both sides of a logical equivalence.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen,
       17-Sep-2013.) */

theorem imbi1i (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph → ch ) ↔ ( ps → ch ) ) ;;
}

proof of imbi1i {
	step 1 : wff = imbi1 () |- ( ( ph ↔ ps ) → ( ( ph → ch ) ↔ ( ps → ch ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ( ph → ch ) ↔ ( ps → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Join two logical equivalences to form equivalence of implications.
       (Contributed by NM, 5-Aug-1993.) */

theorem imbi12i (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	hyp 2 : wff = |- ( ch ↔ th ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph → ch ) ↔ ( ps → th ) ) ;;
}

proof of imbi12i {
	step 1 : wff = imbi2i (hyp 2) |- ( ( ph → ch ) ↔ ( ph → th ) ) ;;
	step 2 : wff = imbi1i (hyp 1) |- ( ( ph → th ) ↔ ( ps → th ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ( ph → ch ) ↔ ( ps → th ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem imbi12i is the congruence law for implication. */

/* $j congruence 'imbi12i'; */

/* Theorem *4.86 of [WhiteheadRussell] p. 122.  (Contributed by NM,
     3-Jan-2005.) */

theorem bibi1 (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) → ( ( ph ↔ ch ) ↔ ( ps ↔ ch ) ) ) ;;
}

proof of bibi1 {
	step 1 : wff = id () |- ( ( ph ↔ ps ) → ( ph ↔ ps ) ) ;;
	step 2 : wff = bibi1d (step 1) |- ( ( ph ↔ ps ) → ( ( ph ↔ ch ) ↔ ( ps ↔ ch ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Contraposition.  Theorem *4.12 of [WhiteheadRussell] p. 117.  (Contributed
     by NM, 15-Apr-1995.)  (Proof shortened by Wolf Lammen, 3-Jan-2013.) */

theorem con2bi (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ¬ ps ) ↔ ( ps ↔ ¬ ph ) ) ;;
}

proof of con2bi {
	step 1 : wff = notbi () |- ( ( ph ↔ ¬ ps ) ↔ ( ¬ ph ↔ ¬ ¬ ps ) ) ;;
	step 2 : wff = notnot () |- ( ps ↔ ¬ ¬ ps ) ;;
	step 3 : wff = bibi2i (step 2) |- ( ( ¬ ph ↔ ps ) ↔ ( ¬ ph ↔ ¬ ¬ ps ) ) ;;
	step 4 : wff = bicom () |- ( ( ¬ ph ↔ ps ) ↔ ( ps ↔ ¬ ph ) ) ;;
	step 5 : wff = 3bitr2i (step 1, step 3, step 4) |- ( ( ph ↔ ¬ ps ) ↔ ( ps ↔ ¬ ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/* A contraposition deduction.  (Contributed by NM, 15-Apr-1995.) */

theorem con2bid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps ↔ ¬ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch ↔ ¬ ps ) ) ;;
}

proof of con2bid {
	step 1 : wff = con2bi () |- ( ( ch ↔ ¬ ps ) ↔ ( ps ↔ ¬ ch ) ) ;;
	step 2 : wff = sylibr (hyp 1, step 1) |- ( ph → ( ch ↔ ¬ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A contraposition deduction.  (Contributed by NM, 9-Oct-1999.) */

theorem con1bid (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ¬ ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ¬ ch ↔ ps ) ) ;;
}

proof of con1bid {
	step 1 : wff = bicomd (hyp 1) |- ( ph → ( ch ↔ ¬ ps ) ) ;;
	step 2 : wff = con2bid (step 1) |- ( ph → ( ps ↔ ¬ ch ) ) ;;
	step 3 : wff = bicomd (step 2) |- ( ph → ( ¬ ch ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* A contraposition inference.  (Contributed by NM, 5-Aug-1993.)  (Proof
       shortened by Wolf Lammen, 13-Oct-2012.) */

theorem con1bii (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ¬ ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ps ↔ ph ) ;;
}

proof of con1bii {
	step 1 : wff = notnot () |- ( ph ↔ ¬ ¬ ph ) ;;
	step 2 : wff = xchbinx (step 1, hyp 1) |- ( ph ↔ ¬ ps ) ;;
	step 3 : wff = bicomi (step 2) |- ( ¬ ps ↔ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* A contraposition inference.  (Contributed by NM, 5-Aug-1993.) */

theorem con2bii (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ( ph ↔ ¬ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ps ↔ ¬ ph ) ;;
}

proof of con2bii {
	step 1 : wff = bicomi (hyp 1) |- ( ¬ ps ↔ ph ) ;;
	step 2 : wff = con1bii (step 1) |- ( ¬ ph ↔ ps ) ;;
	step 3 : wff = bicomi (step 2) |- ( ps ↔ ¬ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Contraposition.  Bidirectional version of ~ con1 .  (Contributed by NM,
     5-Aug-1993.) */

theorem con1b (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ¬ ph → ps ) ↔ ( ¬ ps → ph ) ) ;;
}

proof of con1b {
	step 1 : wff = con1 () |- ( ( ¬ ph → ps ) → ( ¬ ps → ph ) ) ;;
	step 2 : wff = con1 () |- ( ( ¬ ps → ph ) → ( ¬ ph → ps ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ¬ ph → ps ) ↔ ( ¬ ps → ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Contraposition.  Bidirectional version of ~ con2 .  (Contributed by NM,
     5-Aug-1993.) */

theorem con2b (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ¬ ps ) ↔ ( ps → ¬ ph ) ) ;;
}

proof of con2b {
	step 1 : wff = con2 () |- ( ( ph → ¬ ps ) → ( ps → ¬ ph ) ) ;;
	step 2 : wff = con2 () |- ( ( ps → ¬ ph ) → ( ph → ¬ ps ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph → ¬ ps ) ↔ ( ps → ¬ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* A wff is equivalent to itself with true antecedent.  (Contributed by NM,
     28-Jan-1996.) */

theorem biimt (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ph → ( ps ↔ ( ph → ps ) ) ) ;;
}

proof of biimt {
	step 1 : wff = ax-1 () |- ( ps → ( ph → ps ) ) ;;
	step 2 : wff = pm2.27 () |- ( ph → ( ( ph → ps ) → ps ) ) ;;
	step 3 : wff = impbid2 (step 1, step 2) |- ( ph → ( ps ↔ ( ph → ps ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem *5.5 of [WhiteheadRussell] p. 125.  (Contributed by NM,
     3-Jan-2005.) */

theorem pm5.5 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ph → ( ( ph → ps ) ↔ ps ) ) ;;
}

proof of pm5.5 {
	step 1 : wff = biimt () |- ( ph → ( ps ↔ ( ph → ps ) ) ) ;;
	step 2 : wff = bicomd (step 1) |- ( ph → ( ( ph → ps ) ↔ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference rule introducing a theorem as an antecedent.  (Contributed by
       NM, 5-Aug-1993.)  (Proof shortened by Wolf Lammen, 11-Nov-2012.) */

theorem a1bi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ps ↔ ( ph → ps ) ) ;;
}

proof of a1bi {
	step 1 : wff = biimt () |- ( ph → ( ps ↔ ( ph → ps ) ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ps ↔ ( ph → ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A false consequent falsifies an antecedent.  (Contributed by NM,
       19-Aug-1993.)  (Proof shortened by Wolf Lammen, 12-Nov-2012.) */

theorem mt2bi (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ps ↔ ( ps → ¬ ph ) ) ;;
}

proof of mt2bi {
	step 1 : wff = a1bi (hyp 1) |- ( ¬ ps ↔ ( ph → ¬ ps ) ) ;;
	step 2 : wff = con2b () |- ( ( ph → ¬ ps ) ↔ ( ps → ¬ ph ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ¬ ps ↔ ( ps → ¬ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Modus-tollens-like theorem.  (Contributed by NM, 7-Apr-2001.)  (Proof
     shortened by Wolf Lammen, 12-Nov-2012.) */

theorem mtt (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ¬ ph → ( ¬ ps ↔ ( ps → ph ) ) ) ;;
}

proof of mtt {
	step 1 : wff = biimt () |- ( ¬ ph → ( ¬ ps ↔ ( ¬ ph → ¬ ps ) ) ) ;;
	step 2 : wff = con34b () |- ( ( ps → ph ) ↔ ( ¬ ph → ¬ ps ) ) ;;
	step 3 : wff = syl6bbr (step 1, step 2) |- ( ¬ ph → ( ¬ ps ↔ ( ps → ph ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem *5.501 of [WhiteheadRussell] p. 125.  (Contributed by NM,
     3-Jan-2005.) */

theorem pm5.501 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ph → ( ps ↔ ( ph ↔ ps ) ) ) ;;
}

proof of pm5.501 {
	step 1 : wff = pm5.1im () |- ( ph → ( ps → ( ph ↔ ps ) ) ) ;;
	step 2 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 3 : wff = com12 (step 2) |- ( ph → ( ( ph ↔ ps ) → ps ) ) ;;
	step 4 : wff = impbid (step 1, step 3) |- ( ph → ( ps ↔ ( ph ↔ ps ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Implication in terms of implication and biconditional.  (Contributed by
     NM, 31-Mar-1994.)  (Proof shortened by Wolf Lammen, 24-Jan-2013.) */

theorem ibib (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ps ) ↔ ( ph → ( ph ↔ ps ) ) ) ;;
}

proof of ibib {
	step 1 : wff = pm5.501 () |- ( ph → ( ps ↔ ( ph ↔ ps ) ) ) ;;
	step 2 : wff = pm5.74i (step 1) |- ( ( ph → ps ) ↔ ( ph → ( ph ↔ ps ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Implication in terms of implication and biconditional.  (Contributed by
     NM, 29-Apr-2005.)  (Proof shortened by Wolf Lammen, 21-Dec-2013.) */

theorem ibibr (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ps ) ↔ ( ph → ( ps ↔ ph ) ) ) ;;
}

proof of ibibr {
	step 1 : wff = pm5.501 () |- ( ph → ( ps ↔ ( ph ↔ ps ) ) ) ;;
	step 2 : wff = bicom () |- ( ( ph ↔ ps ) ↔ ( ps ↔ ph ) ) ;;
	step 3 : wff = syl6bb (step 1, step 2) |- ( ph → ( ps ↔ ( ps ↔ ph ) ) ) ;;
	step 4 : wff = pm5.74i (step 3) |- ( ( ph → ps ) ↔ ( ph → ( ps ↔ ph ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/* A wff is equivalent to its equivalence with truth.  (Contributed by NM,
       18-Aug-1993.)  (Proof shortened by Andrew Salmon, 13-May-2011.) */

theorem tbt (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ps ↔ ( ps ↔ ph ) ) ;;
}

proof of tbt {
	step 1 : wff = ibibr () |- ( ( ph → ps ) ↔ ( ph → ( ps ↔ ph ) ) ) ;;
	step 2 : wff = pm5.74ri (step 1) |- ( ph → ( ps ↔ ( ps ↔ ph ) ) ) ;;
	step 3 : wff = ax-mp (hyp 1, step 2) |- ( ps ↔ ( ps ↔ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* The negation of a wff is equivalent to the wff's equivalence to
     falsehood.  (Contributed by Juha Arpiainen, 19-Jan-2006.)  (Proof
     shortened by Wolf Lammen, 28-Jan-2013.) */

theorem nbn2 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ¬ ph → ( ¬ ps ↔ ( ph ↔ ps ) ) ) ;;
}

proof of nbn2 {
	step 1 : wff = pm5.501 () |- ( ¬ ph → ( ¬ ps ↔ ( ¬ ph ↔ ¬ ps ) ) ) ;;
	step 2 : wff = notbi () |- ( ( ph ↔ ps ) ↔ ( ¬ ph ↔ ¬ ps ) ) ;;
	step 3 : wff = syl6bbr (step 1, step 2) |- ( ¬ ph → ( ¬ ps ↔ ( ph ↔ ps ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Transfer negation via an equivalence.  (Contributed by NM, 3-Oct-2007.)
     (Proof shortened by Wolf Lammen, 28-Jan-2013.) */

theorem bibif (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ¬ ps → ( ( ph ↔ ps ) ↔ ¬ ph ) ) ;;
}

proof of bibif {
	step 1 : wff = nbn2 () |- ( ¬ ps → ( ¬ ph ↔ ( ps ↔ ph ) ) ) ;;
	step 2 : wff = bicom () |- ( ( ps ↔ ph ) ↔ ( ph ↔ ps ) ) ;;
	step 3 : wff = syl6rbb (step 1, step 2) |- ( ¬ ps → ( ( ph ↔ ps ) ↔ ¬ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* The negation of a wff is equivalent to the wff's equivalence to
       falsehood.  (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Wolf
       Lammen, 3-Oct-2013.) */

theorem nbn (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ¬ ph ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ps ↔ ( ps ↔ ph ) ) ;;
}

proof of nbn {
	step 1 : wff = bibif () |- ( ¬ ph → ( ( ps ↔ ph ) ↔ ¬ ps ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( ( ps ↔ ph ) ↔ ¬ ps ) ;;
	step 3 : wff = bicomi (step 2) |- ( ¬ ps ↔ ( ps ↔ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Transfer falsehood via equivalence.  (Contributed by NM,
       11-Sep-2006.) */

theorem nbn3 (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ps ↔ ( ps ↔ ¬ ph ) ) ;;
}

proof of nbn3 {
	step 1 : wff = notnoti (hyp 1) |- ¬ ¬ ph ;;
	step 2 : wff = nbn (step 1) |- ( ¬ ps ↔ ( ps ↔ ¬ ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Two propositions are equivalent if they are both false.  Closed form of
     ~ 2false .  Equivalent to a ~ bi2 -like version of the xor-connective.
     (Contributed by Wolf Lammen, 13-May-2013.) */

theorem pm5.21im (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ¬ ph → ( ¬ ps → ( ph ↔ ps ) ) ) ;;
}

proof of pm5.21im {
	step 1 : wff = nbn2 () |- ( ¬ ph → ( ¬ ps ↔ ( ph ↔ ps ) ) ) ;;
	step 2 : wff = biimpd (step 1) |- ( ¬ ph → ( ¬ ps → ( ph ↔ ps ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Two falsehoods are equivalent.  (Contributed by NM, 4-Apr-2005.)  (Proof
       shortened by Wolf Lammen, 19-May-2013.) */

theorem 2false (ph : wff, ps : wff)  {
	hyp 1 : wff = |- ¬ ph ;;
	hyp 2 : wff = |- ¬ ps ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ps ) ;;
}

proof of 2false {
	step 1 : wff = 2th (hyp 1, hyp 2) |- ( ¬ ph ↔ ¬ ps ) ;;
	step 2 : wff = con4bii (step 1) |- ( ph ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Two falsehoods are equivalent (deduction rule).  (Contributed by NM,
       11-Oct-2013.) */

theorem 2falsed (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ¬ ps ) ;;
	hyp 2 : wff = |- ( ph → ¬ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
}

proof of 2falsed {
	step 1 : wff = pm2.21d (hyp 1) |- ( ph → ( ps → ch ) ) ;;
	step 2 : wff = pm2.21d (hyp 2) |- ( ph → ( ch → ps ) ) ;;
	step 3 : wff = impbid (step 1, step 2) |- ( ph → ( ps ↔ ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Two propositions implying a false one are equivalent.  (Contributed by
       NM, 16-Feb-1996.)  (Proof shortened by Wolf Lammen, 19-May-2013.) */

theorem pm5.21ni (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ch → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ps → ( ph ↔ ch ) ) ;;
}

proof of pm5.21ni {
	step 1 : wff = con3i (hyp 1) |- ( ¬ ps → ¬ ph ) ;;
	step 2 : wff = con3i (hyp 2) |- ( ¬ ps → ¬ ch ) ;;
	step 3 : wff = 2falsed (step 1, step 2) |- ( ¬ ps → ( ph ↔ ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Eliminate an antecedent implied by each side of a biconditional.
         (Contributed by NM, 21-May-1999.) */

theorem pm5.21nii (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ch → ps ) ;;
	hyp 3 : wff = |- ( ps → ( ph ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ch ) ;;
}

proof of pm5.21nii {
	step 1 : wff = pm5.21ni (hyp 1, hyp 2) |- ( ¬ ps → ( ph ↔ ch ) ) ;;
	step 2 : wff = pm2.61i (hyp 3, step 1) |- ( ph ↔ ch ) ;;
	qed prop 1 = step 2 ;;
}

/* Eliminate an antecedent implied by each side of a biconditional,
       deduction version.  (Contributed by Paul Chapman, 21-Nov-2012.)  (Proof
       shortened by Wolf Lammen, 6-Oct-2013.) */

theorem pm5.21ndd (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ch → ps ) ) ;;
	hyp 2 : wff = |- ( ph → ( th → ps ) ) ;;
	hyp 3 : wff = |- ( ph → ( ps → ( ch ↔ th ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch ↔ th ) ) ;;
}

proof of pm5.21ndd {
	step 1 : wff = con3d (hyp 1) |- ( ph → ( ¬ ps → ¬ ch ) ) ;;
	step 2 : wff = con3d (hyp 2) |- ( ph → ( ¬ ps → ¬ th ) ) ;;
	step 3 : wff = pm5.21im () |- ( ¬ ch → ( ¬ th → ( ch ↔ th ) ) ) ;;
	step 4 : wff = syl6c (step 1, step 2, step 3) |- ( ph → ( ¬ ps → ( ch ↔ th ) ) ) ;;
	step 5 : wff = pm2.61d (hyp 3, step 4) |- ( ph → ( ch ↔ th ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Combine antecedents into a single bi-conditional.  This inference,
       reminiscent of ~ ja , is reversible:  The hypotheses can be deduced from
       the conclusion alone (see ~ pm5.1im and ~ pm5.21im ).  (Contributed by
       Wolf Lammen, 13-May-2013.) */

theorem bija (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ¬ ph → ( ¬ ps → ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ( ph ↔ ps ) → ch ) ;;
}

proof of bija {
	step 1 : wff = bi2 () |- ( ( ph ↔ ps ) → ( ps → ph ) ) ;;
	step 2 : wff = syli (step 1, hyp 1) |- ( ( ph ↔ ps ) → ( ps → ch ) ) ;;
	step 3 : wff = bi1 () |- ( ( ph ↔ ps ) → ( ph → ps ) ) ;;
	step 4 : wff = con3d (step 3) |- ( ( ph ↔ ps ) → ( ¬ ps → ¬ ph ) ) ;;
	step 5 : wff = syli (step 4, hyp 2) |- ( ( ph ↔ ps ) → ( ¬ ps → ch ) ) ;;
	step 6 : wff = pm2.61d (step 2, step 5) |- ( ( ph ↔ ps ) → ch ) ;;
	qed prop 1 = step 6 ;;
}

/* Theorem *5.18 of [WhiteheadRussell] p. 124.  This theorem says that
     logical equivalence is the same as negated "exclusive-or."  (Contributed
     by NM, 28-Jun-2002.)  (Proof shortened by Andrew Salmon, 20-Jun-2011.)
     (Proof shortened by Wolf Lammen, 15-Oct-2013.) */

theorem pm5.18 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) ↔ ¬ ( ph ↔ ¬ ps ) ) ;;
}

proof of pm5.18 {
	step 1 : wff = pm5.501 () |- ( ph → ( ¬ ps ↔ ( ph ↔ ¬ ps ) ) ) ;;
	step 2 : wff = con1bid (step 1) |- ( ph → ( ¬ ( ph ↔ ¬ ps ) ↔ ps ) ) ;;
	step 3 : wff = pm5.501 () |- ( ph → ( ps ↔ ( ph ↔ ps ) ) ) ;;
	step 4 : wff = bitr2d (step 2, step 3) |- ( ph → ( ( ph ↔ ps ) ↔ ¬ ( ph ↔ ¬ ps ) ) ) ;;
	step 5 : wff = nbn2 () |- ( ¬ ph → ( ¬ ¬ ps ↔ ( ph ↔ ¬ ps ) ) ) ;;
	step 6 : wff = con1bid (step 5) |- ( ¬ ph → ( ¬ ( ph ↔ ¬ ps ) ↔ ¬ ps ) ) ;;
	step 7 : wff = nbn2 () |- ( ¬ ph → ( ¬ ps ↔ ( ph ↔ ps ) ) ) ;;
	step 8 : wff = bitr2d (step 6, step 7) |- ( ¬ ph → ( ( ph ↔ ps ) ↔ ¬ ( ph ↔ ¬ ps ) ) ) ;;
	step 9 : wff = pm2.61i (step 4, step 8) |- ( ( ph ↔ ps ) ↔ ¬ ( ph ↔ ¬ ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Two ways to express "exclusive or."  (Contributed by NM, 1-Jan-2006.) */

theorem xor3 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ¬ ( ph ↔ ps ) ↔ ( ph ↔ ¬ ps ) ) ;;
}

proof of xor3 {
	step 1 : wff = pm5.18 () |- ( ( ph ↔ ps ) ↔ ¬ ( ph ↔ ¬ ps ) ) ;;
	step 2 : wff = con2bii (step 1) |- ( ( ph ↔ ¬ ps ) ↔ ¬ ( ph ↔ ps ) ) ;;
	step 3 : wff = bicomi (step 2) |- ( ¬ ( ph ↔ ps ) ↔ ( ph ↔ ¬ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Move negation outside of biconditional.  Compare Theorem *5.18 of
     [WhiteheadRussell] p. 124.  (Contributed by NM, 27-Jun-2002.)  (Proof
     shortened by Wolf Lammen, 20-Sep-2013.) */

theorem nbbn (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ¬ ph ↔ ps ) ↔ ¬ ( ph ↔ ps ) ) ;;
}

proof of nbbn {
	step 1 : wff = xor3 () |- ( ¬ ( ph ↔ ps ) ↔ ( ph ↔ ¬ ps ) ) ;;
	step 2 : wff = con2bi () |- ( ( ph ↔ ¬ ps ) ↔ ( ps ↔ ¬ ph ) ) ;;
	step 3 : wff = bicom () |- ( ( ps ↔ ¬ ph ) ↔ ( ¬ ph ↔ ps ) ) ;;
	step 4 : wff = 3bitrri (step 1, step 2, step 3) |- ( ( ¬ ph ↔ ps ) ↔ ¬ ( ph ↔ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Associative law for the biconditional.  An axiom of system DS in Vladimir
     Lifschitz, "On calculational proofs", Annals of Pure and Applied Logic,
     113:207-224, 2002,
     ~ http://www.cs.utexas.edu/users/ai-lab/pub-view.php?PubID=26805 .
     Interestingly, this law was not included in _Principia Mathematica_ but
     was apparently first noted by Jan Lukasiewicz circa 1923.  (Contributed by
     NM, 8-Jan-2005.)  (Proof shortened by Juha Arpiainen, 19-Jan-2006.)
     (Proof shortened by Wolf Lammen, 21-Sep-2013.) */

theorem biass (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ( ph ↔ ps ) ↔ ch ) ↔ ( ph ↔ ( ps ↔ ch ) ) ) ;;
}

proof of biass {
	step 1 : wff = pm5.501 () |- ( ph → ( ps ↔ ( ph ↔ ps ) ) ) ;;
	step 2 : wff = bibi1d (step 1) |- ( ph → ( ( ps ↔ ch ) ↔ ( ( ph ↔ ps ) ↔ ch ) ) ) ;;
	step 3 : wff = pm5.501 () |- ( ph → ( ( ps ↔ ch ) ↔ ( ph ↔ ( ps ↔ ch ) ) ) ) ;;
	step 4 : wff = bitr3d (step 2, step 3) |- ( ph → ( ( ( ph ↔ ps ) ↔ ch ) ↔ ( ph ↔ ( ps ↔ ch ) ) ) ) ;;
	step 5 : wff = nbbn () |- ( ( ¬ ps ↔ ch ) ↔ ¬ ( ps ↔ ch ) ) ;;
	step 6 : wff = nbn2 () |- ( ¬ ph → ( ¬ ps ↔ ( ph ↔ ps ) ) ) ;;
	step 7 : wff = bibi1d (step 6) |- ( ¬ ph → ( ( ¬ ps ↔ ch ) ↔ ( ( ph ↔ ps ) ↔ ch ) ) ) ;;
	step 8 : wff = syl5bbr (step 5, step 7) |- ( ¬ ph → ( ¬ ( ps ↔ ch ) ↔ ( ( ph ↔ ps ) ↔ ch ) ) ) ;;
	step 9 : wff = nbn2 () |- ( ¬ ph → ( ¬ ( ps ↔ ch ) ↔ ( ph ↔ ( ps ↔ ch ) ) ) ) ;;
	step 10 : wff = bitr3d (step 8, step 9) |- ( ¬ ph → ( ( ( ph ↔ ps ) ↔ ch ) ↔ ( ph ↔ ( ps ↔ ch ) ) ) ) ;;
	step 11 : wff = pm2.61i (step 4, step 10) |- ( ( ( ph ↔ ps ) ↔ ch ) ↔ ( ph ↔ ( ps ↔ ch ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Theorem *5.19 of [WhiteheadRussell] p. 124.  (Contributed by NM,
     3-Jan-2005.) */

theorem pm5.19 (ph : wff)  {
	prop 1 : wff = |- ¬ ( ph ↔ ¬ ph ) ;;
}

proof of pm5.19 {
	step 1 : wff = biid () |- ( ph ↔ ph ) ;;
	step 2 : wff = pm5.18 () |- ( ( ph ↔ ph ) ↔ ¬ ( ph ↔ ¬ ph ) ) ;;
	step 3 : wff = mpbi (step 1, step 2) |- ¬ ( ph ↔ ¬ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Logical equivalence of commuted antecedents.  Part of Theorem *4.87 of
     [WhiteheadRussell] p. 122.  (Contributed by NM, 5-Aug-1993.) */

theorem bi2.04 (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph → ( ps → ch ) ) ↔ ( ps → ( ph → ch ) ) ) ;;
}

proof of bi2.04 {
	step 1 : wff = pm2.04 () |- ( ( ph → ( ps → ch ) ) → ( ps → ( ph → ch ) ) ) ;;
	step 2 : wff = pm2.04 () |- ( ( ps → ( ph → ch ) ) → ( ph → ( ps → ch ) ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph → ( ps → ch ) ) ↔ ( ps → ( ph → ch ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Antecedent absorption implication.  Theorem *5.4 of [WhiteheadRussell]
     p. 125.  (Contributed by NM, 5-Aug-1993.) */

theorem pm5.4 (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ( ph → ps ) ) ↔ ( ph → ps ) ) ;;
}

proof of pm5.4 {
	step 1 : wff = pm2.43 () |- ( ( ph → ( ph → ps ) ) → ( ph → ps ) ) ;;
	step 2 : wff = ax-1 () |- ( ( ph → ps ) → ( ph → ( ph → ps ) ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph → ( ph → ps ) ) ↔ ( ph → ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Distributive law for implication.  Compare Theorem *5.41 of
     [WhiteheadRussell] p. 125.  (Contributed by NM, 5-Aug-1993.) */

theorem imdi (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph → ( ps → ch ) ) ↔ ( ( ph → ps ) → ( ph → ch ) ) ) ;;
}

proof of imdi {
	step 1 : wff = ax-2 () |- ( ( ph → ( ps → ch ) ) → ( ( ph → ps ) → ( ph → ch ) ) ) ;;
	step 2 : wff = pm2.86 () |- ( ( ( ph → ps ) → ( ph → ch ) ) → ( ph → ( ps → ch ) ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph → ( ps → ch ) ) ↔ ( ( ph → ps ) → ( ph → ch ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem *5.41 of [WhiteheadRussell] p. 125.  (Contributed by NM,
     3-Jan-2005.)  (Proof shortened by Wolf Lammen, 12-Oct-2012.) */

theorem pm5.41 (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ( ph → ps ) → ( ph → ch ) ) ↔ ( ph → ( ps → ch ) ) ) ;;
}

proof of pm5.41 {
	step 1 : wff = imdi () |- ( ( ph → ( ps → ch ) ) ↔ ( ( ph → ps ) → ( ph → ch ) ) ) ;;
	step 2 : wff = bicomi (step 1) |- ( ( ( ph → ps ) → ( ph → ch ) ) ↔ ( ph → ( ps → ch ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Theorem *4.8 of [WhiteheadRussell] p. 122.  (Contributed by NM,
     3-Jan-2005.) */

theorem pm4.8 (ph : wff)  {
	prop 1 : wff = |- ( ( ph → ¬ ph ) ↔ ¬ ph ) ;;
}

proof of pm4.8 {
	step 1 : wff = pm2.01 () |- ( ( ph → ¬ ph ) → ¬ ph ) ;;
	step 2 : wff = ax-1 () |- ( ¬ ph → ( ph → ¬ ph ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ph → ¬ ph ) ↔ ¬ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem *4.81 of [WhiteheadRussell] p. 122.  (Contributed by NM,
     3-Jan-2005.) */

theorem pm4.81 (ph : wff)  {
	prop 1 : wff = |- ( ( ¬ ph → ph ) ↔ ph ) ;;
}

proof of pm4.81 {
	step 1 : wff = pm2.18 () |- ( ( ¬ ph → ph ) → ph ) ;;
	step 2 : wff = pm2.24 () |- ( ph → ( ¬ ph → ph ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ( ¬ ph → ph ) ↔ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Simplify an implication between two implications when the antecedent of
     the first is a consequence of the antecedent of the second.  The reverse
     form is useful in producing the successor step in induction proofs.
     (Contributed by Paul Chapman, 22-Jun-2011.)  (Proof shortened by Wolf
     Lammen, 14-Sep-2013.) */

theorem imim21b (ph : wff, ps : wff, ch : wff, th : wff)  {
	prop 1 : wff = |- ( ( ps → ph ) → ( ( ( ph → ch ) → ( ps → th ) ) ↔ ( ps → ( ch → th ) ) ) ) ;;
}

proof of imim21b {
	step 1 : wff = bi2.04 () |- ( ( ( ph → ch ) → ( ps → th ) ) ↔ ( ps → ( ( ph → ch ) → th ) ) ) ;;
	step 2 : wff = pm5.5 () |- ( ph → ( ( ph → ch ) ↔ ch ) ) ;;
	step 3 : wff = imbi1d (step 2) |- ( ph → ( ( ( ph → ch ) → th ) ↔ ( ch → th ) ) ) ;;
	step 4 : wff = imim2i (step 3) |- ( ( ps → ph ) → ( ps → ( ( ( ph → ch ) → th ) ↔ ( ch → th ) ) ) ) ;;
	step 5 : wff = pm5.74d (step 4) |- ( ( ps → ph ) → ( ( ps → ( ( ph → ch ) → th ) ) ↔ ( ps → ( ch → th ) ) ) ) ;;
	step 6 : wff = syl5bb (step 1, step 5) |- ( ( ps → ph ) → ( ( ( ph → ch ) → ( ps → th ) ) ↔ ( ps → ( ch → th ) ) ) ) ;;
	qed prop 1 = step 6 ;;
}


