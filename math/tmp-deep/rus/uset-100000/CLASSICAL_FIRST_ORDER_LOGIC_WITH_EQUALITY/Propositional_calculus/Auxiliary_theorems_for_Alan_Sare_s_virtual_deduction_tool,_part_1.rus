import uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Propositional_calculus/Truth_tables.rus;;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
       Auxiliary theorems for Alan Sare's virtual deduction tool, part 1

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/*Virtual deduction rule ~ e22 without virtual deduction connectives.
       Special theorem needed for Alan Sare's virtual deduction translation
       tool.  (Contributed by Alan Sare, 2-May-2011.)
       (New usage is discouraged.)  TODO: decide if this is worth keeping. */

theorem ee22 (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps → th ) ) ;;
	hyp 3 : wff = |- ( ch → ( th → ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ta ) ) ;;
}

proof of ee22 {
	step 1 : wff = syl6c (hyp 1, hyp 2, hyp 3) |- ( ph → ( ps → ta ) ) ;;
	qed prop 1 = step 1 ;;
}

/*~ e12an without virtual deduction connectives.  Special theorem needed
       for Alan Sare's virtual deduction translation tool.  (Contributed by
       Alan Sare, 28-Oct-2011.)  TODO: this is frequently used; come up with
       better label. */

theorem ee12an (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ( ph → ( ch → th ) ) ;;
	hyp 3 : wff = |- ( ( ps ∧ th ) → ta ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ta ) ) ;;
}

proof of ee12an {
	step 1 : wff = jctild (hyp 2, hyp 1) |- ( ph → ( ch → ( ps ∧ th ) ) ) ;;
	step 2 : wff = syl6 (step 1, hyp 3) |- ( ph → ( ch → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/*~ e23 without virtual deductions.  (Contributed by Alan Sare,
       17-Jul-2011.)  (New usage is discouraged.)  TODO: decide if this is
       worth keeping. */

theorem ee23 (ph : wff, ps : wff, ch : wff, th : wff, ta : wff, et : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → ( ps → ( th → ta ) ) ) ;;
	hyp 3 : wff = |- ( ch → ( ta → et ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ( th → et ) ) ) ;;
}

proof of ee23 {
	step 1 : wff = syl6 (hyp 1, hyp 3) |- ( ph → ( ps → ( ta → et ) ) ) ;;
	step 2 : wff = syldd (hyp 2, step 1) |- ( ph → ( ps → ( th → et ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Exportation implication also converting head from biconditional to
     conditional.  This proof is ~ exbirVD automatically translated and
     minimized.  (Contributed by Alan Sare, 31-Dec-2011.)
     (New usage is discouraged.)  TODO: decide if this is worth keeping. */

theorem exbir (ph : wff, ps : wff, ch : wff, th : wff)  {
	prop 1 : wff = |- ( ( ( ph ∧ ps ) → ( ch ↔ th ) ) → ( ph → ( ps → ( th → ch ) ) ) ) ;;
}

proof of exbir {
	step 1 : wff = bi2 () |- ( ( ch ↔ th ) → ( th → ch ) ) ;;
	step 2 : wff = imim2i (step 1) |- ( ( ( ph ∧ ps ) → ( ch ↔ th ) ) → ( ( ph ∧ ps ) → ( th → ch ) ) ) ;;
	step 3 : wff = exp3a (step 2) |- ( ( ( ph ∧ ps ) → ( ch ↔ th ) ) → ( ph → ( ps → ( th → ch ) ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/*~ impexp with a 3-conjunct antecedent.  (Contributed by Alan Sare,
     31-Dec-2011.) */

theorem 3impexp (ph : wff, ps : wff, ch : wff, th : wff)  {
	prop 1 : wff = |- ( ( ( ph ∧ ps ∧ ch ) → th ) ↔ ( ph → ( ps → ( ch → th ) ) ) ) ;;
}

proof of 3impexp {
	step 1 : wff = id () |- ( ( ( ph ∧ ps ∧ ch ) → th ) → ( ( ph ∧ ps ∧ ch ) → th ) ) ;;
	step 2 : wff = 3expd (step 1) |- ( ( ( ph ∧ ps ∧ ch ) → th ) → ( ph → ( ps → ( ch → th ) ) ) ) ;;
	step 3 : wff = id () |- ( ( ph → ( ps → ( ch → th ) ) ) → ( ph → ( ps → ( ch → th ) ) ) ) ;;
	step 4 : wff = 3impd (step 3) |- ( ( ph → ( ps → ( ch → th ) ) ) → ( ( ph ∧ ps ∧ ch ) → th ) ) ;;
	step 5 : wff = impbii (step 2, step 4) |- ( ( ( ph ∧ ps ∧ ch ) → th ) ↔ ( ph → ( ps → ( ch → th ) ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/*~ 3impexp with biconditional consequent of antecedent that is commuted in
     consequent.  Derived automatically from ~ 3impexpVD .  (Contributed by
     Alan Sare, 31-Dec-2011.)  (New usage is discouraged.)  TODO: decide if
     this is worth keeping. */

theorem 3impexpbicom (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	prop 1 : wff = |- ( ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) ↔ ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) ) ;;
}

proof of 3impexpbicom {
	step 1 : wff = bicom () |- ( ( th ↔ ta ) ↔ ( ta ↔ th ) ) ;;
	step 2 : wff = imbi2 () |- ( ( ( th ↔ ta ) ↔ ( ta ↔ th ) ) → ( ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) ↔ ( ( ph ∧ ps ∧ ch ) → ( ta ↔ th ) ) ) ) ;;
	step 3 : wff = biimpcd (step 2) |- ( ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) → ( ( ( th ↔ ta ) ↔ ( ta ↔ th ) ) → ( ( ph ∧ ps ∧ ch ) → ( ta ↔ th ) ) ) ) ;;
	step 4 : wff = mpi (step 1, step 3) |- ( ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) → ( ( ph ∧ ps ∧ ch ) → ( ta ↔ th ) ) ) ;;
	step 5 : wff = 3expd (step 4) |- ( ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) → ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) ) ;;
	step 6 : wff = 3impexp () |- ( ( ( ph ∧ ps ∧ ch ) → ( ta ↔ th ) ) ↔ ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) ) ;;
	step 7 : wff = biimpri (step 6) |- ( ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) → ( ( ph ∧ ps ∧ ch ) → ( ta ↔ th ) ) ) ;;
	step 8 : wff = bicom () |- ( ( th ↔ ta ) ↔ ( ta ↔ th ) ) ;;
	step 9 : wff = syl6ibr (step 7, step 8) |- ( ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) → ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) ) ;;
	step 10 : wff = impbii (step 5, step 9) |- ( ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) ↔ ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Deduction form of ~ 3impexpbicom .  Derived automatically from
       ~ 3impexpbicomiVD .  (Contributed by Alan Sare, 31-Dec-2011.)
       (New usage is discouraged.)  TODO: decide if this is worth keeping. */

theorem 3impexpbicomi (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ( ph ∧ ps ∧ ch ) → ( th ↔ ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) ;;
}

proof of 3impexpbicomi {
	step 1 : wff = bicomd (hyp 1) |- ( ( ph ∧ ps ∧ ch ) → ( ta ↔ th ) ) ;;
	step 2 : wff = 3exp (step 1) |- ( ph → ( ps → ( ch → ( ta ↔ th ) ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Closed form of ~ ancoms .  Derived automatically from ~ ancomsimpVD .
     (Contributed by Alan Sare, 31-Dec-2011.) */

theorem ancomsimp (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ( ph ∧ ps ) → ch ) ↔ ( ( ps ∧ ph ) → ch ) ) ;;
}

proof of ancomsimp {
	step 1 : wff = ancom () |- ( ( ph ∧ ps ) ↔ ( ps ∧ ph ) ) ;;
	step 2 : wff = imbi1i (step 1) |- ( ( ( ph ∧ ps ) → ch ) ↔ ( ( ps ∧ ph ) → ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Export and commute antecedents.  (Contributed by Alan Sare,
       18-Mar-2012.) */

theorem exp3acom3r (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ( ps ∧ ch ) → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ps → ( ch → ( ph → th ) ) ) ;;
}

proof of exp3acom3r {
	step 1 : wff = exp3a (hyp 1) |- ( ph → ( ps → ( ch → th ) ) ) ;;
	step 2 : wff = com3l (step 1) |- ( ps → ( ch → ( ph → th ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Implication form of ~ exp3acom23 .  (Contributed by Alan Sare,
     22-Jul-2012.)  (New usage is discouraged.)  TODO: decide if this is worth
     keeping. */

theorem exp3acom23g (ph : wff, ps : wff, ch : wff, th : wff)  {
	prop 1 : wff = |- ( ( ph → ( ( ps ∧ ch ) → th ) ) ↔ ( ph → ( ch → ( ps → th ) ) ) ) ;;
}

proof of exp3acom23g {
	step 1 : wff = ancomsimp () |- ( ( ( ps ∧ ch ) → th ) ↔ ( ( ch ∧ ps ) → th ) ) ;;
	step 2 : wff = impexp () |- ( ( ( ch ∧ ps ) → th ) ↔ ( ch → ( ps → th ) ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ( ( ps ∧ ch ) → th ) ↔ ( ch → ( ps → th ) ) ) ;;
	step 4 : wff = imbi2i (step 3) |- ( ( ph → ( ( ps ∧ ch ) → th ) ) ↔ ( ph → ( ch → ( ps → th ) ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*The exportation deduction ~ exp3a with commutation of the conjoined
       wwfs.  (Contributed by Alan Sare, 22-Jul-2012.) */

theorem exp3acom23 (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ( ( ps ∧ ch ) → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ch → ( ps → th ) ) ) ;;
}

proof of exp3acom23 {
	step 1 : wff = exp3a (hyp 1) |- ( ph → ( ps → ( ch → th ) ) ) ;;
	step 2 : wff = com23 (step 1) |- ( ph → ( ch → ( ps → th ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Implication form of ~ simplbi2com .  (Contributed by Alan Sare,
     22-Jul-2012.)  (New usage is discouraged.)  TODO: decide if this is worth
     keeping. */

theorem simplbi2comg (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ( ps ∧ ch ) ) → ( ch → ( ps → ph ) ) ) ;;
}

proof of simplbi2comg {
	step 1 : wff = bi2 () |- ( ( ph ↔ ( ps ∧ ch ) ) → ( ( ps ∧ ch ) → ph ) ) ;;
	step 2 : wff = exp3acom23 (step 1) |- ( ( ph ↔ ( ps ∧ ch ) ) → ( ch → ( ps → ph ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/*A deduction eliminating a conjunct, similar to ~ simplbi2 .
       (Contributed by Alan Sare, 22-Jul-2012.)  (Proof shortened by Wolf
       Lammen, 10-Nov-2012.) */

theorem simplbi2com (ph : wff, ps : wff, ch : wff)  {
	hyp 1 : wff = |- ( ph ↔ ( ps ∧ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ps → ph ) ) ;;
}

proof of simplbi2com {
	step 1 : wff = simplbi2 (hyp 1) |- ( ps → ( ch → ph ) ) ;;
	step 2 : wff = com12 (step 1) |- ( ch → ( ps → ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*~ e21 without virtual deductions.  (Contributed by Alan Sare,
       18-Mar-2012.)  (New usage is discouraged.)  TODO: decide if this is
       worth keeping. */

theorem ee21 (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ( ph → ( ps → ch ) ) ;;
	hyp 2 : wff = |- ( ph → th ) ;;
	hyp 3 : wff = |- ( ch → ( th → ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ps → ta ) ) ;;
}

proof of ee21 {
	step 1 : wff = a1d (hyp 2) |- ( ph → ( ps → th ) ) ;;
	step 2 : wff = ee22 (hyp 1, step 1, hyp 3) |- ( ph → ( ps → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/*~ e10 without virtual deductions.  (Contributed by Alan Sare,
       25-Jul-2011.)  TODO: this is frequently used; come up with better
       label. */

theorem ee10 (ph : wff, ps : wff, ch : wff, th : wff)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	hyp 2 : wff = |- ch ;;
	hyp 3 : wff = |- ( ps → ( ch → th ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → th ) ;;
}

proof of ee10 {
	step 1 : wff = mpi (hyp 2, hyp 3) |- ( ps → th ) ;;
	step 2 : wff = syl (hyp 1, step 1) |- ( ph → th ) ;;
	qed prop 1 = step 2 ;;
}

/*~ e02 without virtual deductions.  (Contributed by Alan Sare,
       22-Jul-2012.)  (New usage is discouraged.)  TODO: decide if this is
       worth keeping. */

theorem ee02 (ph : wff, ps : wff, ch : wff, th : wff, ta : wff)  {
	hyp 1 : wff = |- ph ;;
	hyp 2 : wff = |- ( ps → ( ch → th ) ) ;;
	hyp 3 : wff = |- ( ph → ( th → ta ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ps → ( ch → ta ) ) ;;
}

proof of ee02 {
	step 1 : wff = a1i (hyp 1) |- ( ps → ph ) ;;
	step 2 : wff = sylsyld (step 1, hyp 2, hyp 3) |- ( ps → ( ch → ta ) ) ;;
	qed prop 1 = step 2 ;;
}

/*End of auxiliary theorems for Alan Sare's virtual deduction tool, part 1 */


