import uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Propositional_calculus/Abbreviated_conjunction_and_disjunction_of_three_wff_s.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Logical 'nand' (Sheffer stroke)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Declare connective for alternative denial ('nand'). */

constant {
	symbol ⊼ ;;
	ascii -/\ ;;
	latex \bar{\wedge} ;;
}

/* Overlined 'wedge' (read:  'nand') */

/* Extend wff definition to include alternative denial ('nand'). */

rule wnan (ph : wff, ps : wff) {
	term : wff = # ( ph ⊼ ps ) ;;
}

/* Define incompatibility, or alternative denial ('not-and' or 'nand').  This
     is also called the Sheffer stroke, represented by a vertical bar, but we
     use a different symbol to avoid ambiguity with other uses of the vertical
     bar.  In the second edition of Principia Mathematica (1927), Russell and
     Whitehead used the Sheffer stroke and suggested it as a replacement for
     the "or" and "not" operations of the first edition.  However, in practice,
     "or" and "not" are more widely used.  After we define the constant true
     ` T. ` ( ~ df-tru ) and the constant false ` F. ` ( ~ df-fal ), we will be
     able to prove these truth table values: ` ( ( T. -/\ T. ) <-> F. ) `
     ( ~ trunantru ), ` ( ( T. -/\ F. ) <-> T. ) ` ( ~ trunanfal ),
     ` ( ( F. -/\ T. ) <-> T. ) ` ( ~ falnantru ), and
     ` ( ( F. -/\ F. ) <-> T. ) ` ( ~ falnanfal ).  Contrast with ` /\ `
     ( ~ df-an ), ` \/ ` ( ~ df-or ), ` -> ` ( ~ wi ), and ` \/_ `
     ( ~ df-xor ) .  (Contributed by Jeff Hoffman, 19-Nov-2007.) */

definition df-nan (ph : wff, ps : wff)  {
	defiendum : wff = # ( ph ⊼ ps ) ;;
	definiens : wff = # ¬ ( ph ∧ ps ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/* Write 'and' in terms of 'nand'.  (Contributed by Mario Carneiro,
     9-May-2015.) */

theorem nanan (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ∧ ps ) ↔ ¬ ( ph ⊼ ps ) ) ;;
}

proof of nanan {
	step 1 : wff = df-nan () |- ( ( ph ⊼ ps ) ↔ ¬ ( ph ∧ ps ) ) ;;
	step 2 : wff = con2bii (step 1) |- ( ( ph ∧ ps ) ↔ ¬ ( ph ⊼ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* The 'nand' operator commutes.  (Contributed by Mario Carneiro,
     9-May-2015.) */

theorem nancom (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ⊼ ps ) ↔ ( ps ⊼ ph ) ) ;;
}

proof of nancom {
	step 1 : wff = ancom () |- ( ( ph ∧ ps ) ↔ ( ps ∧ ph ) ) ;;
	step 2 : wff = notbii (step 1) |- ( ¬ ( ph ∧ ps ) ↔ ¬ ( ps ∧ ph ) ) ;;
	step 3 : wff = df-nan () |- ( ( ph ⊼ ps ) ↔ ¬ ( ph ∧ ps ) ) ;;
	step 4 : wff = df-nan () |- ( ( ps ⊼ ph ) ↔ ¬ ( ps ∧ ph ) ) ;;
	step 5 : wff = 3bitr4i (step 2, step 3, step 4) |- ( ( ph ⊼ ps ) ↔ ( ps ⊼ ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Lemma for handling nested 'nand's.  (Contributed by Jeff Hoffman,
     19-Nov-2007.) */

theorem nannan (ph : wff, ps : wff, ch : wff)  {
	prop 1 : wff = |- ( ( ph ⊼ ( ch ⊼ ps ) ) ↔ ( ph → ( ch ∧ ps ) ) ) ;;
}

proof of nannan {
	step 1 : wff = df-nan () |- ( ( ph ⊼ ( ch ⊼ ps ) ) ↔ ¬ ( ph ∧ ( ch ⊼ ps ) ) ) ;;
	step 2 : wff = df-nan () |- ( ( ch ⊼ ps ) ↔ ¬ ( ch ∧ ps ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( ph ∧ ( ch ⊼ ps ) ) ↔ ( ph ∧ ¬ ( ch ∧ ps ) ) ) ;;
	step 4 : wff = xchbinx (step 1, step 3) |- ( ( ph ⊼ ( ch ⊼ ps ) ) ↔ ¬ ( ph ∧ ¬ ( ch ∧ ps ) ) ) ;;
	step 5 : wff = iman () |- ( ( ph → ( ch ∧ ps ) ) ↔ ¬ ( ph ∧ ¬ ( ch ∧ ps ) ) ) ;;
	step 6 : wff = bitr4i (step 4, step 5) |- ( ( ph ⊼ ( ch ⊼ ps ) ) ↔ ( ph → ( ch ∧ ps ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Show equivalence between implication and the Nicod version.  To derive
     ~ nic-dfim , apply ~ nanbi .  (Contributed by Jeff Hoffman,
     19-Nov-2007.) */

theorem nanim (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph → ps ) ↔ ( ph ⊼ ( ps ⊼ ps ) ) ) ;;
}

proof of nanim {
	step 1 : wff = nannan () |- ( ( ph ⊼ ( ps ⊼ ps ) ) ↔ ( ph → ( ps ∧ ps ) ) ) ;;
	step 2 : wff = anidmdbi () |- ( ( ph → ( ps ∧ ps ) ) ↔ ( ph → ps ) ) ;;
	step 3 : wff = bitr2i (step 1, step 2) |- ( ( ph → ps ) ↔ ( ph ⊼ ( ps ⊼ ps ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Show equivalence between negation and the Nicod version.  To derive
     ~ nic-dfneg , apply ~ nanbi .  (Contributed by Jeff Hoffman,
     19-Nov-2007.) */

theorem nannot (ps : wff)  {
	prop 1 : wff = |- ( ¬ ps ↔ ( ps ⊼ ps ) ) ;;
}

proof of nannot {
	step 1 : wff = df-nan () |- ( ( ps ⊼ ps ) ↔ ¬ ( ps ∧ ps ) ) ;;
	step 2 : wff = anidm () |- ( ( ps ∧ ps ) ↔ ps ) ;;
	step 3 : wff = xchbinx (step 1, step 2) |- ( ( ps ⊼ ps ) ↔ ¬ ps ) ;;
	step 4 : wff = bicomi (step 3) |- ( ¬ ps ↔ ( ps ⊼ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Show equivalence between the bidirectional and the Nicod version.
     (Contributed by Jeff Hoffman, 19-Nov-2007.) */

theorem nanbi (ph : wff, ps : wff)  {
	prop 1 : wff = |- ( ( ph ↔ ps ) ↔ ( ( ph ⊼ ps ) ⊼ ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ) ) ;;
}

proof of nanbi {
	step 1 : wff = pm4.57 () |- ( ¬ ( ¬ ( ph ∧ ps ) ∧ ¬ ( ¬ ph ∧ ¬ ps ) ) ↔ ( ( ph ∧ ps ) ∨ ( ¬ ph ∧ ¬ ps ) ) ) ;;
	step 2 : wff = df-nan () |- ( ( ( ph ⊼ ps ) ⊼ ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ) ↔ ¬ ( ( ph ⊼ ps ) ∧ ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ) ) ;;
	step 3 : wff = df-nan () |- ( ( ph ⊼ ps ) ↔ ¬ ( ph ∧ ps ) ) ;;
	step 4 : wff = df-nan () |- ( ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ↔ ¬ ( ( ph ⊼ ph ) ∧ ( ps ⊼ ps ) ) ) ;;
	step 5 : wff = nannot () |- ( ¬ ph ↔ ( ph ⊼ ph ) ) ;;
	step 6 : wff = nannot () |- ( ¬ ps ↔ ( ps ⊼ ps ) ) ;;
	step 7 : wff = anbi12i (step 5, step 6) |- ( ( ¬ ph ∧ ¬ ps ) ↔ ( ( ph ⊼ ph ) ∧ ( ps ⊼ ps ) ) ) ;;
	step 8 : wff = xchbinxr (step 4, step 7) |- ( ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ↔ ¬ ( ¬ ph ∧ ¬ ps ) ) ;;
	step 9 : wff = anbi12i (step 3, step 8) |- ( ( ( ph ⊼ ps ) ∧ ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ) ↔ ( ¬ ( ph ∧ ps ) ∧ ¬ ( ¬ ph ∧ ¬ ps ) ) ) ;;
	step 10 : wff = xchbinx (step 2, step 9) |- ( ( ( ph ⊼ ps ) ⊼ ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ) ↔ ¬ ( ¬ ( ph ∧ ps ) ∧ ¬ ( ¬ ph ∧ ¬ ps ) ) ) ;;
	step 11 : wff = dfbi3 () |- ( ( ph ↔ ps ) ↔ ( ( ph ∧ ps ) ∨ ( ¬ ph ∧ ¬ ps ) ) ) ;;
	step 12 : wff = 3bitr4ri (step 1, step 10, step 11) |- ( ( ph ↔ ps ) ↔ ( ( ph ⊼ ps ) ⊼ ( ( ph ⊼ ph ) ⊼ ( ps ⊼ ps ) ) ) ) ;;
	qed prop 1 = step 12 ;;
}


