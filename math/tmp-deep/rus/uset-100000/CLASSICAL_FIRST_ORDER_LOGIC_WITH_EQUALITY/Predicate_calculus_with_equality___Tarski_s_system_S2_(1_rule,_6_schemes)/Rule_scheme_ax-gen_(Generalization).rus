import uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Predicate_calculus_with_equality___Tarski_s_system_S2_(1_rule,_6_schemes)/Universal_quantifier__define__exists__and__not_free_.rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
       Rule scheme ax-gen (Generalization)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Rule of Generalization.  The postulated inference rule of pure predicate
       calculus.  See e.g.  Rule 2 of [Hamilton] p. 74.  This rule says that if
       something is unconditionally true, then it is true for all values of a
       variable.  For example, if we have proved ` x = x ` , we can conclude
       ` A. x x = x ` or even ` A. y x = x ` .  Theorem ~ allt shows the
       special case ` A. x T. ` .  Theorem ~ spi shows we can go the other way
       also: in other words we can add or remove universal quantifiers from the
       beginning of any theorem as required.  (Contributed by NM,
       5-Aug-1993.) */

axiom ax-gen (ph : wff, x : set)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ∀ x ph ;;
}

/* Generalization applied twice.  (Contributed by NM, 30-Apr-1998.) */

theorem gen2 (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ∀ x ∀ y ph ;;
}

proof of gen2 {
	step 1 : wff = ax-gen (hyp 1) |- ∀ y ph ;;
	step 2 : wff = ax-gen (step 1) |- ∀ x ∀ y ph ;;
	qed prop 1 = step 2 ;;
}

/* Modus ponens combined with generalization.  (Contributed by NM,
       24-May-1994.) */

theorem mpg (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ( ∀ x ph → ps ) ;;
	hyp 2 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of mpg {
	step 1 : wff = ax-gen (hyp 2) |- ∀ x ph ;;
	step 2 : wff = ax-mp (step 1, hyp 1) |- ps ;;
	qed prop 1 = step 2 ;;
}

/* Modus ponens on biconditional combined with generalization.
       (Contributed by NM, 24-May-1994.)  (Proof shortened by Stefan Allan,
       28-Oct-2008.) */

theorem mpgbi (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ( ∀ x ph ↔ ps ) ;;
	hyp 2 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of mpgbi {
	step 1 : wff = ax-gen (hyp 2) |- ∀ x ph ;;
	step 2 : wff = mpbi (step 1, hyp 1) |- ps ;;
	qed prop 1 = step 2 ;;
}

/* Modus ponens on biconditional combined with generalization.
       (Contributed by NM, 24-May-1994.)  (Proof shortened by Stefan Allan,
       28-Oct-2008.) */

theorem mpgbir (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ( ph ↔ ∀ x ps ) ;;
	hyp 2 : wff = |- ps ;;
	-----------------------
	prop 1 : wff = |- ph ;;
}

proof of mpgbir {
	step 1 : wff = ax-gen (hyp 2) |- ∀ x ps ;;
	step 2 : wff = mpbir (step 1, hyp 1) |- ph ;;
	qed prop 1 = step 2 ;;
}

/* Deduce that ` x ` is not free in ` ph ` from the definition.
       (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfi (ph : wff, x : set)  {
	hyp 1 : wff = |- ( ph → ∀ x ph ) ;;
	-----------------------
	prop 1 : wff = |- F/ x ph ;;
}

proof of nfi {
	step 1 : wff = df-nf () |- ( F/ x ph ↔ ∀ x ( ph → ∀ x ph ) ) ;;
	step 2 : wff = mpgbir (step 1, hyp 1) |- F/ x ph ;;
	qed prop 1 = step 2 ;;
}

/* No variable is (effectively) free in a theorem.

       This and later "hypothesis-building" lemmas, with labels starting
       "hb...", allow us to construct proofs of formulas of the form
       ` |- ( ph -> A. x ph ) ` from smaller formulas of this form.  These are
       useful for constructing hypotheses that state " ` x ` is (effectively)
       not free in ` ph ` ."  (Contributed by NM, 5-Aug-1993.) */

theorem hbth (ph : wff, x : set)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∀ x ph ) ;;
}

proof of hbth {
	step 1 : wff = ax-gen (hyp 1) |- ∀ x ph ;;
	step 2 : wff = a1i (step 1) |- ( ph → ∀ x ph ) ;;
	qed prop 1 = step 2 ;;
}

/* No variable is (effectively) free in a theorem.  (Contributed by Mario
       Carneiro, 11-Aug-2016.) */

theorem nfth (ph : wff, x : set)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ph ;;
}

proof of nfth {
	step 1 : wff = hbth (hyp 1) |- ( ph → ∀ x ph ) ;;
	step 2 : wff = nfi (step 1) |- F/ x ph ;;
	qed prop 1 = step 2 ;;
}

/* The true constant has no free variables.  (This can also be proven in one
     step with ~ nfv , but this proof does not use ~ ax-17 .)  (Contributed by
     Mario Carneiro, 6-Oct-2016.) */

theorem nftru (x : set)  {
	prop 1 : wff = |- F/ x T. ;;
}

proof of nftru {
	step 1 : wff = tru () |- T. ;;
	step 2 : wff = nfth (step 1) |- F/ x T. ;;
	qed prop 1 = step 2 ;;
}

/* Generalization rule for negated wff.  (Contributed by NM,
       18-May-1994.) */

theorem nex (ph : wff, x : set)  {
	hyp 1 : wff = |- ¬ ph ;;
	-----------------------
	prop 1 : wff = |- ¬ ∃ x ph ;;
}

proof of nex {
	step 1 : wff = alnex () |- ( ∀ x ¬ ph ↔ ¬ ∃ x ph ) ;;
	step 2 : wff = mpgbi (step 1, hyp 1) |- ¬ ∃ x ph ;;
	qed prop 1 = step 2 ;;
}

/* No variable is (effectively) free in a non-theorem.  (Contributed by
       Mario Carneiro, 6-Dec-2016.) */

theorem nfnth (ph : wff, x : set)  {
	hyp 1 : wff = |- ¬ ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ph ;;
}

proof of nfnth {
	step 1 : wff = pm2.21i (hyp 1) |- ( ph → ∀ x ph ) ;;
	step 2 : wff = nfi (step 1) |- F/ x ph ;;
	qed prop 1 = step 2 ;;
}


