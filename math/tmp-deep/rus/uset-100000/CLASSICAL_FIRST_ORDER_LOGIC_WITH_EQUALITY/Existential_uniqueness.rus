import uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Predicate_calculus_with_equality___Older_axiomatization_(1_rule,_14_schemes).rus;;

/*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
               Existential uniqueness

#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
*/

/*Declare new symbols needed for uniqueness notation. */

constant {
	symbol ∃! ;;
	ascii E! ;;
	latex \exists{!} ;;
}

/*Backwards E exclamation point. */

constant {
	symbol ∃* ;;
	ascii E* ;;
	latex \exists^{\ast} ;;
}

/*Backwards E superscript *. */

/*Extend wff definition to include existential uniqueness ("there exists a
     unique ` x ` such that ` ph ` "). */

rule weu (ph : wff, x : set) {
	term : wff = # ∃! x ph ;;
}

/*Extend wff definition to include uniqueness ("there exists at most one
     ` x ` such that ` ph ` "). */

rule wmo (ph : wff, x : set) {
	term : wff = # ∃* x ph ;;
}

/*A soundness justification theorem for ~ df-eu , showing that the
       definition is equivalent to itself with its dummy variable renamed.
       Note that ` y ` and ` z ` needn't be distinct variables.  See
       ~ eujustALT for a proof that provides an example of how it can be
       achieved through the use of ~ dvelim .  (Contributed by NM,
       11-Mar-2010.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem eujust (ph : wff, x : set, y : set, z : set) disjointed(w x y, x z, y ph, w z ph) {
	prop 1 : wff = |- ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
}

proof of eujust {
	var w : set;;
	step 1 : wff = equequ2 () |- ( y = w → ( x = y ↔ x = w ) ) ;;
	step 2 : wff = bibi2d (step 1) |- ( y = w → ( ( ph ↔ x = y ) ↔ ( ph ↔ x = w ) ) ) ;;
	step 3 : wff = albidv (step 2) |- ( y = w → ( ∀ x ( ph ↔ x = y ) ↔ ∀ x ( ph ↔ x = w ) ) ) ;;
	step 4 : wff = cbvexv (step 3) |- ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ w ∀ x ( ph ↔ x = w ) ) ;;
	step 5 : wff = equequ2 () |- ( w = z → ( x = w ↔ x = z ) ) ;;
	step 6 : wff = bibi2d (step 5) |- ( w = z → ( ( ph ↔ x = w ) ↔ ( ph ↔ x = z ) ) ) ;;
	step 7 : wff = albidv (step 6) |- ( w = z → ( ∀ x ( ph ↔ x = w ) ↔ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 8 : wff = cbvexv (step 7) |- ( ∃ w ∀ x ( ph ↔ x = w ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
	step 9 : wff = bitri (step 4, step 8) |- ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
	qed prop 1 = step 9 ;;
}

/*A soundness justification theorem for ~ df-eu , showing that the
       definition is equivalent to itself with its dummy variable renamed.
       Note that ` y ` and ` z ` needn't be distinct variables.  While this
       isn't strictly necessary for soundness, the proof provides an example of
       how it can be achieved through the use of ~ dvelim .  (Contributed by
       NM, 11-Mar-2010.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem eujustALT (ph : wff, x : set, y : set, z : set) disjointed(w x y, x z, y ph, w z ph) {
	prop 1 : wff = |- ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
}

proof of eujustALT {
	var w : set;;
	step 1 : wff = equequ2 () |- ( y = z → ( x = y ↔ x = z ) ) ;;
	step 2 : wff = bibi2d (step 1) |- ( y = z → ( ( ph ↔ x = y ) ↔ ( ph ↔ x = z ) ) ) ;;
	step 3 : wff = albidv (step 2) |- ( y = z → ( ∀ x ( ph ↔ x = y ) ↔ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 4 : wff = sps (step 3) |- ( ∀ y y = z → ( ∀ x ( ph ↔ x = y ) ↔ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 5 : wff = drex1 (step 4) |- ( ∀ y y = z → ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ) ;;
	step 6 : wff = hbnae () |- ( ¬ ∀ y y = z → ∀ y ¬ ∀ y y = z ) ;;
	step 7 : wff = hbnae () |- ( ¬ ∀ y y = z → ∀ z ¬ ∀ y y = z ) ;;
	step 8 : wff = alrimih (step 6, step 7) |- ( ¬ ∀ y y = z → ∀ y ∀ z ¬ ∀ y y = z ) ;;
	step 9 : wff = ax-17 () |- ( ¬ ∀ x ( ph ↔ x = w ) → ∀ z ¬ ∀ x ( ph ↔ x = w ) ) ;;
	step 10 : wff = equequ2 () |- ( w = y → ( x = w ↔ x = y ) ) ;;
	step 11 : wff = bibi2d (step 10) |- ( w = y → ( ( ph ↔ x = w ) ↔ ( ph ↔ x = y ) ) ) ;;
	step 12 : wff = albidv (step 11) |- ( w = y → ( ∀ x ( ph ↔ x = w ) ↔ ∀ x ( ph ↔ x = y ) ) ) ;;
	step 13 : wff = notbid (step 12) |- ( w = y → ( ¬ ∀ x ( ph ↔ x = w ) ↔ ¬ ∀ x ( ph ↔ x = y ) ) ) ;;
	step 14 : wff = dvelim (step 9, step 13) |- ( ¬ ∀ z z = y → ( ¬ ∀ x ( ph ↔ x = y ) → ∀ z ¬ ∀ x ( ph ↔ x = y ) ) ) ;;
	step 15 : wff = naecoms (step 14) |- ( ¬ ∀ y y = z → ( ¬ ∀ x ( ph ↔ x = y ) → ∀ z ¬ ∀ x ( ph ↔ x = y ) ) ) ;;
	step 16 : wff = ax-17 () |- ( ¬ ∀ x ( ph ↔ x = w ) → ∀ y ¬ ∀ x ( ph ↔ x = w ) ) ;;
	step 17 : wff = equequ2 () |- ( w = z → ( x = w ↔ x = z ) ) ;;
	step 18 : wff = bibi2d (step 17) |- ( w = z → ( ( ph ↔ x = w ) ↔ ( ph ↔ x = z ) ) ) ;;
	step 19 : wff = albidv (step 18) |- ( w = z → ( ∀ x ( ph ↔ x = w ) ↔ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 20 : wff = notbid (step 19) |- ( w = z → ( ¬ ∀ x ( ph ↔ x = w ) ↔ ¬ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 21 : wff = dvelim (step 16, step 20) |- ( ¬ ∀ y y = z → ( ¬ ∀ x ( ph ↔ x = z ) → ∀ y ¬ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 22 : wff = equequ2 () |- ( y = z → ( x = y ↔ x = z ) ) ;;
	step 23 : wff = bibi2d (step 22) |- ( y = z → ( ( ph ↔ x = y ) ↔ ( ph ↔ x = z ) ) ) ;;
	step 24 : wff = albidv (step 23) |- ( y = z → ( ∀ x ( ph ↔ x = y ) ↔ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 25 : wff = notbid (step 24) |- ( y = z → ( ¬ ∀ x ( ph ↔ x = y ) ↔ ¬ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 26 : wff = a1i (step 25) |- ( ¬ ∀ y y = z → ( y = z → ( ¬ ∀ x ( ph ↔ x = y ) ↔ ¬ ∀ x ( ph ↔ x = z ) ) ) ) ;;
	step 27 : wff = cbv2h (step 15, step 21, step 26) |- ( ∀ y ∀ z ¬ ∀ y y = z → ( ∀ y ¬ ∀ x ( ph ↔ x = y ) ↔ ∀ z ¬ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 28 : wff = syl (step 8, step 27) |- ( ¬ ∀ y y = z → ( ∀ y ¬ ∀ x ( ph ↔ x = y ) ↔ ∀ z ¬ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 29 : wff = notbid (step 28) |- ( ¬ ∀ y y = z → ( ¬ ∀ y ¬ ∀ x ( ph ↔ x = y ) ↔ ¬ ∀ z ¬ ∀ x ( ph ↔ x = z ) ) ) ;;
	step 30 : wff = df-ex () |- ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ¬ ∀ y ¬ ∀ x ( ph ↔ x = y ) ) ;;
	step 31 : wff = df-ex () |- ( ∃ z ∀ x ( ph ↔ x = z ) ↔ ¬ ∀ z ¬ ∀ x ( ph ↔ x = z ) ) ;;
	step 32 : wff = 3bitr4g (step 29, step 30, step 31) |- ( ¬ ∀ y y = z → ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ) ;;
	step 33 : wff = pm2.61i (step 5, step 32) |- ( ∃ y ∀ x ( ph ↔ x = y ) ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
	qed prop 1 = step 33 ;;
}

/*Define existential uniqueness, i.e.  "there exists exactly one ` x `
       such that ` ph ` ."  Definition 10.1 of [BellMachover] p. 97; also
       Definition *14.02 of [WhiteheadRussell] p. 175.  Other possible
       definitions are given by ~ eu1 , ~ eu2 , ~ eu3 , and ~ eu5 (which in
       some cases we show with a hypothesis ` ph -> A. y ph ` in place of a
       distinct variable condition on ` y ` and ` ph ` ).  Double uniqueness is
       tricky: ` E! x E! y ph ` does not mean "exactly one ` x ` and one
       ` y ` " (see ~ 2eu4 ).  (Contributed by NM, 12-Aug-1993.) */

definition df-eu (ph : wff, x : set, y : set) disjointed(x y, y ph) {
	defiendum : wff = # ∃! x ph ;;
	definiens : wff = # ∃ y ∀ x ( ph ↔ x = y ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*Define "there exists at most one ` x ` such that ` ph ` ."  Here we define
     it in terms of existential uniqueness.  Notation of [BellMachover] p. 460,
     whose definition we show as ~ mo3 .  For other possible definitions see
     ~ mo2 and ~ mo4 .  (Contributed by NM, 8-Mar-1995.) */

definition df-mo (ph : wff, x : set)  {
	defiendum : wff = # ∃* x ph ;;
	definiens : wff = # ( ∃ x ph → ∃! x ph ) ;;
	-----------------------
	prop : wff = |- ( defiendum ↔ definiens ) ;;
}

/*A version of the existential uniqueness definition with a hypothesis
       instead of a distinct variable condition.  (Contributed by NM,
       12-Aug-1993.) */

theorem euf (ph : wff, x : set, y : set) disjointed(x y z, ph z) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ∃ y ∀ x ( ph ↔ x = y ) ) ;;
}

proof of euf {
	var z : set;;
	step 1 : wff = df-eu () |- ( ∃! x ph ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
	step 2 : wff = nfv () |- F/ y x = z ;;
	step 3 : wff = nfbi (hyp 1, step 2) |- F/ y ( ph ↔ x = z ) ;;
	step 4 : wff = nfal (step 3) |- F/ y ∀ x ( ph ↔ x = z ) ;;
	step 5 : wff = nfv () |- F/ z ph ;;
	step 6 : wff = nfv () |- F/ z x = y ;;
	step 7 : wff = nfbi (step 5, step 6) |- F/ z ( ph ↔ x = y ) ;;
	step 8 : wff = nfal (step 7) |- F/ z ∀ x ( ph ↔ x = y ) ;;
	step 9 : wff = equequ2 () |- ( z = y → ( x = z ↔ x = y ) ) ;;
	step 10 : wff = bibi2d (step 9) |- ( z = y → ( ( ph ↔ x = z ) ↔ ( ph ↔ x = y ) ) ) ;;
	step 11 : wff = albidv (step 10) |- ( z = y → ( ∀ x ( ph ↔ x = z ) ↔ ∀ x ( ph ↔ x = y ) ) ) ;;
	step 12 : wff = cbvex (step 4, step 8, step 11) |- ( ∃ z ∀ x ( ph ↔ x = z ) ↔ ∃ y ∀ x ( ph ↔ x = y ) ) ;;
	step 13 : wff = bitri (step 1, step 12) |- ( ∃! x ph ↔ ∃ y ∀ x ( ph ↔ x = y ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Formula-building rule for uniqueness quantifier (deduction rule).
       (Contributed by NM, 9-Jul-1994.) */

theorem eubid (ph : wff, ps : wff, ch : wff, x : set) disjointed(x y, y ph, y ps, y ch) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃! x ps ↔ ∃! x ch ) ) ;;
}

proof of eubid {
	var y : set;;
	step 1 : wff = bibi1d (hyp 2) |- ( ph → ( ( ps ↔ x = y ) ↔ ( ch ↔ x = y ) ) ) ;;
	step 2 : wff = albid (hyp 1, step 1) |- ( ph → ( ∀ x ( ps ↔ x = y ) ↔ ∀ x ( ch ↔ x = y ) ) ) ;;
	step 3 : wff = exbidv (step 2) |- ( ph → ( ∃ y ∀ x ( ps ↔ x = y ) ↔ ∃ y ∀ x ( ch ↔ x = y ) ) ) ;;
	step 4 : wff = df-eu () |- ( ∃! x ps ↔ ∃ y ∀ x ( ps ↔ x = y ) ) ;;
	step 5 : wff = df-eu () |- ( ∃! x ch ↔ ∃ y ∀ x ( ch ↔ x = y ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ph → ( ∃! x ps ↔ ∃! x ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Formula-building rule for uniqueness quantifier (deduction rule).
       (Contributed by NM, 9-Jul-1994.) */

theorem eubidv (ph : wff, ps : wff, ch : wff, x : set) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃! x ps ↔ ∃! x ch ) ) ;;
}

proof of eubidv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = eubid (step 1, hyp 1) |- ( ph → ( ∃! x ps ↔ ∃! x ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Introduce uniqueness quantifier to both sides of an equivalence.
       (Contributed by NM, 9-Jul-1994.)  (Revised by Mario Carneiro,
       6-Oct-2016.) */

theorem eubii (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ( ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ∃! x ps ) ;;
}

proof of eubii {
	step 1 : wff = a1i (hyp 1) |- ( T. → ( ph ↔ ps ) ) ;;
	step 2 : wff = eubidv (step 1) |- ( T. → ( ∃! x ph ↔ ∃! x ps ) ) ;;
	step 3 : wff = trud (step 2) |- ( ∃! x ph ↔ ∃! x ps ) ;;
	qed prop 1 = step 3 ;;
}

/*Bound-variable hypothesis builder for uniqueness.  (Contributed by NM,
       9-Jul-1994.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem nfeu1 (ph : wff, x : set) disjointed(x y, y ph) {
	prop 1 : wff = |- F/ x ∃! x ph ;;
}

proof of nfeu1 {
	var y : set;;
	step 1 : wff = df-eu () |- ( ∃! x ph ↔ ∃ y ∀ x ( ph ↔ x = y ) ) ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ( ph ↔ x = y ) ;;
	step 3 : wff = nfex (step 2) |- F/ x ∃ y ∀ x ( ph ↔ x = y ) ;;
	step 4 : wff = nfxfr (step 1, step 3) |- F/ x ∃! x ph ;;
	qed prop 1 = step 4 ;;
}

/*Bound-variable hypothesis builder for "at most one."  (Contributed by NM,
     8-Mar-1995.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem nfmo1 (ph : wff, x : set)  {
	prop 1 : wff = |- F/ x ∃* x ph ;;
}

proof of nfmo1 {
	step 1 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 2 : wff = nfe1 () |- F/ x ∃ x ph ;;
	step 3 : wff = nfeu1 () |- F/ x ∃! x ph ;;
	step 4 : wff = nfim (step 2, step 3) |- F/ x ( ∃ x ph → ∃! x ph ) ;;
	step 5 : wff = nfxfr (step 1, step 4) |- F/ x ∃* x ph ;;
	qed prop 1 = step 5 ;;
}

/*Bound-variable hypothesis builder for uniqueness.  (Contributed by Mario
       Carneiro, 14-Nov-2016.) */

theorem nfeud2 (ph : wff, ps : wff, x : set, y : set) disjointed(y z, z ph, z ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃! y ps ) ;;
}

proof of nfeud2 {
	var z : set;;
	step 1 : wff = df-eu () |- ( ∃! y ps ↔ ∃ z ∀ y ( ps ↔ y = z ) ) ;;
	step 2 : wff = nfv () |- F/ z ph ;;
	step 3 : wff = nfnae () |- F/ y ¬ ∀ x x = z ;;
	step 4 : wff = nfan (hyp 1, step 3) |- F/ y ( ph ∧ ¬ ∀ x x = z ) ;;
	step 5 : wff = adantlr (hyp 2) |- ( ( ( ph ∧ ¬ ∀ x x = z ) ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 6 : wff = nfeqf () |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ x x = z ) → F/ x y = z ) ;;
	step 7 : wff = ancoms (step 6) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → F/ x y = z ) ;;
	step 8 : wff = adantll (step 7) |- ( ( ( ph ∧ ¬ ∀ x x = z ) ∧ ¬ ∀ x x = y ) → F/ x y = z ) ;;
	step 9 : wff = nfbid (step 5, step 8) |- ( ( ( ph ∧ ¬ ∀ x x = z ) ∧ ¬ ∀ x x = y ) → F/ x ( ps ↔ y = z ) ) ;;
	step 10 : wff = nfald2 (step 4, step 9) |- ( ( ph ∧ ¬ ∀ x x = z ) → F/ x ∀ y ( ps ↔ y = z ) ) ;;
	step 11 : wff = nfexd2 (step 2, step 10) |- ( ph → F/ x ∃ z ∀ y ( ps ↔ y = z ) ) ;;
	step 12 : wff = nfxfrd (step 1, step 11) |- ( ph → F/ x ∃! y ps ) ;;
	qed prop 1 = step 12 ;;
}

/*Bound-variable hypothesis builder for uniqueness.  (Contributed by Mario
       Carneiro, 14-Nov-2016.) */

theorem nfmod2 (ph : wff, ps : wff, x : set, y : set) disjointed(y, ph, ps) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃* y ps ) ;;
}

proof of nfmod2 {
	step 1 : wff = df-mo () |- ( ∃* y ps ↔ ( ∃ y ps → ∃! y ps ) ) ;;
	step 2 : wff = nfexd2 (hyp 1, hyp 2) |- ( ph → F/ x ∃ y ps ) ;;
	step 3 : wff = nfeud2 (hyp 1, hyp 2) |- ( ph → F/ x ∃! y ps ) ;;
	step 4 : wff = nfimd (step 2, step 3) |- ( ph → F/ x ( ∃ y ps → ∃! y ps ) ) ;;
	step 5 : wff = nfxfrd (step 1, step 4) |- ( ph → F/ x ∃* y ps ) ;;
	qed prop 1 = step 5 ;;
}

/*Deduction version of ~ nfeu .  (Contributed by NM, 15-Feb-2013.)
       (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem nfeud (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃! y ps ) ;;
}

proof of nfeud {
	step 1 : wff = adantr (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 2 : wff = nfeud2 (hyp 1, step 1) |- ( ph → F/ x ∃! y ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for "at most one."  (Contributed by
       Mario Carneiro, 14-Nov-2016.) */

theorem nfmod (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃* y ps ) ;;
}

proof of nfmod {
	step 1 : wff = adantr (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	step 2 : wff = nfmod2 (hyp 1, step 1) |- ( ph → F/ x ∃* y ps ) ;;
	qed prop 1 = step 2 ;;
}

/*Bound-variable hypothesis builder for "at most one."  Note that ` x `
       and ` y ` needn't be distinct (this makes the proof more difficult).
       (Contributed by NM, 8-Mar-1995.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem nfeu (ph : wff, x : set, y : set) disjointed(y, x, ph) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ∃! y ph ;;
}

proof of nfeu {
	step 1 : wff = nftru () |- F/ y T. ;;
	step 2 : wff = a1i (hyp 1) |- ( T. → F/ x ph ) ;;
	step 3 : wff = nfeud (step 1, step 2) |- ( T. → F/ x ∃! y ph ) ;;
	step 4 : wff = trud (step 3) |- F/ x ∃! y ph ;;
	qed prop 1 = step 4 ;;
}

/*Bound-variable hypothesis builder for "at most one."  (Contributed by
       NM, 9-Mar-1995.) */

theorem nfmo (ph : wff, x : set, y : set) disjointed(y, x, ph) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x ∃* y ph ;;
}

proof of nfmo {
	step 1 : wff = nftru () |- F/ y T. ;;
	step 2 : wff = a1i (hyp 1) |- ( T. → F/ x ph ) ;;
	step 3 : wff = nfmod (step 1, step 2) |- ( T. → F/ x ∃* y ph ) ;;
	step 4 : wff = trud (step 3) |- F/ x ∃* y ph ;;
	qed prop 1 = step 4 ;;
}

/*Variable substitution in uniqueness quantifier.  (Contributed by NM,
       7-Aug-1994.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem sb8eu (ph : wff, x : set, y : set) disjointed(w y z, ph z w, w x z) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ∃! y [ y / x ] ph ) ;;
}

proof of sb8eu {
	var z : set, w : set;;
	step 1 : wff = nfv () |- F/ w ( ph ↔ x = z ) ;;
	step 2 : wff = sb8 (step 1) |- ( ∀ x ( ph ↔ x = z ) ↔ ∀ w [ w / x ] ( ph ↔ x = z ) ) ;;
	step 3 : wff = sbbi () |- ( [ w / x ] ( ph ↔ x = z ) ↔ ( [ w / x ] ph ↔ [ w / x ] x = z ) ) ;;
	step 4 : wff = nfsb (hyp 1) |- F/ y [ w / x ] ph ;;
	step 5 : wff = equsb3 () |- ( [ w / x ] x = z ↔ w = z ) ;;
	step 6 : wff = nfv () |- F/ y w = z ;;
	step 7 : wff = nfxfr (step 5, step 6) |- F/ y [ w / x ] x = z ;;
	step 8 : wff = nfbi (step 4, step 7) |- F/ y ( [ w / x ] ph ↔ [ w / x ] x = z ) ;;
	step 9 : wff = nfxfr (step 3, step 8) |- F/ y [ w / x ] ( ph ↔ x = z ) ;;
	step 10 : wff = nfv () |- F/ w [ y / x ] ( ph ↔ x = z ) ;;
	step 11 : wff = sbequ () |- ( w = y → ( [ w / x ] ( ph ↔ x = z ) ↔ [ y / x ] ( ph ↔ x = z ) ) ) ;;
	step 12 : wff = cbval (step 9, step 10, step 11) |- ( ∀ w [ w / x ] ( ph ↔ x = z ) ↔ ∀ y [ y / x ] ( ph ↔ x = z ) ) ;;
	step 13 : wff = equsb3 () |- ( [ y / x ] x = z ↔ y = z ) ;;
	step 14 : wff = sblbis (step 13) |- ( [ y / x ] ( ph ↔ x = z ) ↔ ( [ y / x ] ph ↔ y = z ) ) ;;
	step 15 : wff = albii (step 14) |- ( ∀ y [ y / x ] ( ph ↔ x = z ) ↔ ∀ y ( [ y / x ] ph ↔ y = z ) ) ;;
	step 16 : wff = 3bitri (step 2, step 12, step 15) |- ( ∀ x ( ph ↔ x = z ) ↔ ∀ y ( [ y / x ] ph ↔ y = z ) ) ;;
	step 17 : wff = exbii (step 16) |- ( ∃ z ∀ x ( ph ↔ x = z ) ↔ ∃ z ∀ y ( [ y / x ] ph ↔ y = z ) ) ;;
	step 18 : wff = df-eu () |- ( ∃! x ph ↔ ∃ z ∀ x ( ph ↔ x = z ) ) ;;
	step 19 : wff = df-eu () |- ( ∃! y [ y / x ] ph ↔ ∃ z ∀ y ( [ y / x ] ph ↔ y = z ) ) ;;
	step 20 : wff = 3bitr4i (step 17, step 18, step 19) |- ( ∃! x ph ↔ ∃! y [ y / x ] ph ) ;;
	qed prop 1 = step 20 ;;
}

/*Variable substitution in uniqueness quantifier.  (Contributed by
       Alexander van der Vekens, 17-Jun-2017.) */

theorem sb8mo (ph : wff, x : set, y : set) disjointed(y, ph, x) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ph ↔ ∃* y [ y / x ] ph ) ;;
}

proof of sb8mo {
	step 1 : wff = sb8e (hyp 1) |- ( ∃ x ph ↔ ∃ y [ y / x ] ph ) ;;
	step 2 : wff = sb8eu (hyp 1) |- ( ∃! x ph ↔ ∃! y [ y / x ] ph ) ;;
	step 3 : wff = imbi12i (step 1, step 2) |- ( ( ∃ x ph → ∃! x ph ) ↔ ( ∃ y [ y / x ] ph → ∃! y [ y / x ] ph ) ) ;;
	step 4 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 5 : wff = df-mo () |- ( ∃* y [ y / x ] ph ↔ ( ∃ y [ y / x ] ph → ∃! y [ y / x ] ph ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( ∃* x ph ↔ ∃* y [ y / x ] ph ) ;;
	qed prop 1 = step 6 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 25-Nov-1994.)  (Revised by Mario Carneiro,
       7-Oct-2016.) */

theorem cbveu (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ∃! y ps ) ;;
}

proof of cbveu {
	step 1 : wff = sb8eu (hyp 1) |- ( ∃! x ph ↔ ∃! y [ y / x ] ph ) ;;
	step 2 : wff = sbie (hyp 2, hyp 3) |- ( [ y / x ] ph ↔ ps ) ;;
	step 3 : wff = eubii (step 2) |- ( ∃! y [ y / x ] ph ↔ ∃! y ps ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( ∃! x ph ↔ ∃! y ps ) ;;
	qed prop 1 = step 4 ;;
}

/*An alternate way to express uniqueness used by some authors.  Exercise
       2(b) of [Margaris] p. 110.  (Contributed by NM, 20-Aug-1993.)  (Revised
       by Mario Carneiro, 7-Oct-2016.) */

theorem eu1 (ph : wff, x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
}

proof of eu1 {
	step 1 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 2 : wff = euf (step 1) |- ( ∃! y [ y / x ] ph ↔ ∃ x ∀ y ( [ y / x ] ph ↔ y = x ) ) ;;
	step 3 : wff = sb8eu (hyp 1) |- ( ∃! x ph ↔ ∃! y [ y / x ] ph ) ;;
	step 4 : wff = equcom () |- ( x = y ↔ y = x ) ;;
	step 5 : wff = imbi2i (step 4) |- ( ( [ y / x ] ph → x = y ) ↔ ( [ y / x ] ph → y = x ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ y ( [ y / x ] ph → x = y ) ↔ ∀ y ( [ y / x ] ph → y = x ) ) ;;
	step 7 : wff = sb6rf (hyp 1) |- ( ph ↔ ∀ y ( y = x → [ y / x ] ph ) ) ;;
	step 8 : wff = anbi12i (step 6, step 7) |- ( ( ∀ y ( [ y / x ] ph → x = y ) ∧ ph ) ↔ ( ∀ y ( [ y / x ] ph → y = x ) ∧ ∀ y ( y = x → [ y / x ] ph ) ) ) ;;
	step 9 : wff = ancom () |- ( ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ↔ ( ∀ y ( [ y / x ] ph → x = y ) ∧ ph ) ) ;;
	step 10 : wff = albiim () |- ( ∀ y ( [ y / x ] ph ↔ y = x ) ↔ ( ∀ y ( [ y / x ] ph → y = x ) ∧ ∀ y ( y = x → [ y / x ] ph ) ) ) ;;
	step 11 : wff = 3bitr4i (step 8, step 9, step 10) |- ( ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ↔ ∀ y ( [ y / x ] ph ↔ y = x ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ↔ ∃ x ∀ y ( [ y / x ] ph ↔ y = x ) ) ;;
	step 13 : wff = 3bitr4i (step 2, step 3, step 12) |- ( ∃! x ph ↔ ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Equivalent definitions of "there exists at most one."  (Contributed by
       NM, 7-Aug-1994.)  (Revised by Mario Carneiro, 7-Oct-2016.) */

theorem mo (ph : wff, x : set, y : set) disjointed(x y z, ph z) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃ y ∀ x ( ph → x = y ) ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
}

proof of mo {
	var z : set;;
	step 1 : wff = nfv () |- F/ y x = z ;;
	step 2 : wff = nfim (hyp 1, step 1) |- F/ y ( ph → x = z ) ;;
	step 3 : wff = nfal (step 2) |- F/ y ∀ x ( ph → x = z ) ;;
	step 4 : wff = nfv () |- F/ z ∀ x ( ph → x = y ) ;;
	step 5 : wff = equequ2 () |- ( z = y → ( x = z ↔ x = y ) ) ;;
	step 6 : wff = imbi2d (step 5) |- ( z = y → ( ( ph → x = z ) ↔ ( ph → x = y ) ) ) ;;
	step 7 : wff = albidv (step 6) |- ( z = y → ( ∀ x ( ph → x = z ) ↔ ∀ x ( ph → x = y ) ) ) ;;
	step 8 : wff = cbvex (step 3, step 4, step 7) |- ( ∃ z ∀ x ( ph → x = z ) ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 9 : wff = nfv () |- F/ y x = z ;;
	step 10 : wff = nfim (hyp 1, step 9) |- F/ y ( ph → x = z ) ;;
	step 11 : wff = nfs1 (hyp 1) |- F/ x [ y / x ] ph ;;
	step 12 : wff = nfv () |- F/ x y = z ;;
	step 13 : wff = nfim (step 11, step 12) |- F/ x ( [ y / x ] ph → y = z ) ;;
	step 14 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ph → ph ) ) ;;
	step 15 : wff = ax-8 () |- ( x = y → ( x = z → y = z ) ) ;;
	step 16 : wff = imim12d (step 14, step 15) |- ( x = y → ( ( ph → x = z ) → ( [ y / x ] ph → y = z ) ) ) ;;
	step 17 : wff = cbv3 (step 10, step 13, step 16) |- ( ∀ x ( ph → x = z ) → ∀ y ( [ y / x ] ph → y = z ) ) ;;
	step 18 : wff = ancli (step 17) |- ( ∀ x ( ph → x = z ) → ( ∀ x ( ph → x = z ) ∧ ∀ y ( [ y / x ] ph → y = z ) ) ) ;;
	step 19 : wff = nfv () |- F/ y x = z ;;
	step 20 : wff = nfim (hyp 1, step 19) |- F/ y ( ph → x = z ) ;;
	step 21 : wff = nfs1 (hyp 1) |- F/ x [ y / x ] ph ;;
	step 22 : wff = nfv () |- F/ x y = z ;;
	step 23 : wff = nfim (step 21, step 22) |- F/ x ( [ y / x ] ph → y = z ) ;;
	step 24 : wff = aaan (step 20, step 23) |- ( ∀ x ∀ y ( ( ph → x = z ) ∧ ( [ y / x ] ph → y = z ) ) ↔ ( ∀ x ( ph → x = z ) ∧ ∀ y ( [ y / x ] ph → y = z ) ) ) ;;
	step 25 : wff = sylibr (step 18, step 24) |- ( ∀ x ( ph → x = z ) → ∀ x ∀ y ( ( ph → x = z ) ∧ ( [ y / x ] ph → y = z ) ) ) ;;
	step 26 : wff = prth () |- ( ( ( ph → x = z ) ∧ ( [ y / x ] ph → y = z ) ) → ( ( ph ∧ [ y / x ] ph ) → ( x = z ∧ y = z ) ) ) ;;
	step 27 : wff = equtr2 () |- ( ( x = z ∧ y = z ) → x = y ) ;;
	step 28 : wff = syl6 (step 26, step 27) |- ( ( ( ph → x = z ) ∧ ( [ y / x ] ph → y = z ) ) → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 29 : wff = 2alimi (step 28) |- ( ∀ x ∀ y ( ( ph → x = z ) ∧ ( [ y / x ] ph → y = z ) ) → ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 30 : wff = syl (step 25, step 29) |- ( ∀ x ( ph → x = z ) → ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 31 : wff = exlimiv (step 30) |- ( ∃ z ∀ x ( ph → x = z ) → ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 32 : wff = sylbir (step 8, step 31) |- ( ∃ y ∀ x ( ph → x = y ) → ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 33 : wff = nfa2 () |- F/ y ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ;;
	step 34 : wff = nfs1 (hyp 1) |- F/ x [ y / x ] ph ;;
	step 35 : wff = sp () |- ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 36 : wff = exp3a (step 35) |- ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ph → ( [ y / x ] ph → x = y ) ) ) ;;
	step 37 : wff = com3r (step 36) |- ( [ y / x ] ph → ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ph → x = y ) ) ) ;;
	step 38 : wff = alimd (step 34, step 37) |- ( [ y / x ] ph → ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ∀ x ( ph → x = y ) ) ) ;;
	step 39 : wff = com12 (step 38) |- ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( [ y / x ] ph → ∀ x ( ph → x = y ) ) ) ;;
	step 40 : wff = eximd (step 33, step 39) |- ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ∃ y [ y / x ] ph → ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 41 : wff = alnex () |- ( ∀ y ¬ [ y / x ] ph ↔ ¬ ∃ y [ y / x ] ph ) ;;
	step 42 : wff = nfs1 (hyp 1) |- F/ x [ y / x ] ph ;;
	step 43 : wff = nfn (step 42) |- F/ x ¬ [ y / x ] ph ;;
	step 44 : wff = nfn (hyp 1) |- F/ y ¬ ph ;;
	step 45 : wff = sbequ1 () |- ( x = y → ( ph → [ y / x ] ph ) ) ;;
	step 46 : wff = equcoms (step 45) |- ( y = x → ( ph → [ y / x ] ph ) ) ;;
	step 47 : wff = con3d (step 46) |- ( y = x → ( ¬ [ y / x ] ph → ¬ ph ) ) ;;
	step 48 : wff = cbv3 (step 43, step 44, step 47) |- ( ∀ y ¬ [ y / x ] ph → ∀ x ¬ ph ) ;;
	step 49 : wff = pm2.21 () |- ( ¬ ph → ( ph → x = y ) ) ;;
	step 50 : wff = alimi (step 49) |- ( ∀ x ¬ ph → ∀ x ( ph → x = y ) ) ;;
	step 51 : wff = 19.8a () |- ( ∀ x ( ph → x = y ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 52 : wff = 3syl (step 48, step 50, step 51) |- ( ∀ y ¬ [ y / x ] ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 53 : wff = sylbir (step 41, step 52) |- ( ¬ ∃ y [ y / x ] ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 54 : wff = pm2.61d1 (step 40, step 53) |- ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 55 : wff = impbii (step 32, step 54) |- ( ∃ y ∀ x ( ph → x = y ) ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	qed prop 1 = step 55 ;;
}

/*Existential uniqueness implies existence.  (Contributed by NM,
       15-Sep-1993.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem euex (ph : wff, x : set) disjointed(x y, ph y) {
	prop 1 : wff = |- ( ∃! x ph → ∃ x ph ) ;;
}

proof of euex {
	var y : set;;
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = eu1 (step 1) |- ( ∃! x ph ↔ ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 3 : wff = exsimpl () |- ( ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) → ∃ x ph ) ;;
	step 4 : wff = sylbi (step 2, step 3) |- ( ∃! x ph → ∃ x ph ) ;;
	qed prop 1 = step 4 ;;
}

/*Existential uniqueness implies "at most one."  (Contributed by NM,
       8-Jul-1994.) */

theorem eumo0 (ph : wff, x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph → ∃ y ∀ x ( ph → x = y ) ) ;;
}

proof of eumo0 {
	step 1 : wff = euf (hyp 1) |- ( ∃! x ph ↔ ∃ y ∀ x ( ph ↔ x = y ) ) ;;
	step 2 : wff = bi1 () |- ( ( ph ↔ x = y ) → ( ph → x = y ) ) ;;
	step 3 : wff = alimi (step 2) |- ( ∀ x ( ph ↔ x = y ) → ∀ x ( ph → x = y ) ) ;;
	step 4 : wff = eximi (step 3) |- ( ∃ y ∀ x ( ph ↔ x = y ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 5 : wff = sylbi (step 1, step 4) |- ( ∃! x ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	qed prop 1 = step 5 ;;
}

/*An alternate way of defining existential uniqueness.  Definition 6.10 of
       [TakeutiZaring] p. 26.  (Contributed by NM, 8-Jul-1994.) */

theorem eu2 (ph : wff, x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
}

proof of eu2 {
	step 1 : wff = euex () |- ( ∃! x ph → ∃ x ph ) ;;
	step 2 : wff = eumo0 (hyp 1) |- ( ∃! x ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 3 : wff = mo (hyp 1) |- ( ∃ y ∀ x ( ph → x = y ) ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 4 : wff = sylib (step 2, step 3) |- ( ∃! x ph → ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 5 : wff = jca (step 1, step 4) |- ( ∃! x ph → ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 6 : wff = 19.29r () |- ( ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) → ∃ x ( ph ∧ ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 7 : wff = impexp () |- ( ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ( ph → ( [ y / x ] ph → x = y ) ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ∀ y ( ph → ( [ y / x ] ph → x = y ) ) ) ;;
	step 9 : wff = 19.21 (hyp 1) |- ( ∀ y ( ph → ( [ y / x ] ph → x = y ) ) ↔ ( ph → ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 10 : wff = bitri (step 8, step 9) |- ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ( ph → ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 11 : wff = anbi2i (step 10) |- ( ( ph ∧ ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ↔ ( ph ∧ ( ph → ∀ y ( [ y / x ] ph → x = y ) ) ) ) ;;
	step 12 : wff = abai () |- ( ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ↔ ( ph ∧ ( ph → ∀ y ( [ y / x ] ph → x = y ) ) ) ) ;;
	step 13 : wff = bitr4i (step 11, step 12) |- ( ( ph ∧ ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ↔ ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 14 : wff = exbii (step 13) |- ( ∃ x ( ph ∧ ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ↔ ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 15 : wff = sylib (step 6, step 14) |- ( ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) → ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 16 : wff = eu1 (hyp 1) |- ( ∃! x ph ↔ ∃ x ( ph ∧ ∀ y ( [ y / x ] ph → x = y ) ) ) ;;
	step 17 : wff = sylibr (step 15, step 16) |- ( ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) → ∃! x ph ) ;;
	step 18 : wff = impbii (step 5, step 17) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	qed prop 1 = step 18 ;;
}

/*An alternate way to express existential uniqueness.  (Contributed by NM,
       8-Jul-1994.) */

theorem eu3 (ph : wff, x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
}

proof of eu3 {
	step 1 : wff = eu2 (hyp 1) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 2 : wff = mo (hyp 1) |- ( ∃ y ∀ x ( ph → x = y ) ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Introduce a disjunct into a uniqueness quantifier.  (Contributed by NM,
       21-Oct-2005.) */

theorem euor (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( ( ¬ ph ∧ ∃! x ps ) → ∃! x ( ph ∨ ps ) ) ;;
}

proof of euor {
	step 1 : wff = nfn (hyp 1) |- F/ x ¬ ph ;;
	step 2 : wff = biorf () |- ( ¬ ph → ( ps ↔ ( ph ∨ ps ) ) ) ;;
	step 3 : wff = eubid (step 1, step 2) |- ( ¬ ph → ( ∃! x ps ↔ ∃! x ( ph ∨ ps ) ) ) ;;
	step 4 : wff = biimpa (step 3) |- ( ( ¬ ph ∧ ∃! x ps ) → ∃! x ( ph ∨ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Introduce a disjunct into a uniqueness quantifier.  (Contributed by NM,
       23-Mar-1995.) */

theorem euorv (ph : wff, ps : wff, x : set) disjointed(x ph) {
	prop 1 : wff = |- ( ( ¬ ph ∧ ∃! x ps ) → ∃! x ( ph ∨ ps ) ) ;;
}

proof of euorv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = euor (step 1) |- ( ( ¬ ph ∧ ∃! x ps ) → ∃! x ( ph ∨ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Alternate definition of "at most one."  (Contributed by NM,
       8-Mar-1995.) */

theorem mo2 (ph : wff, x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
}

proof of mo2 {
	step 1 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 2 : wff = alnex () |- ( ∀ x ¬ ph ↔ ¬ ∃ x ph ) ;;
	step 3 : wff = pm2.21 () |- ( ¬ ph → ( ph → x = y ) ) ;;
	step 4 : wff = alimi (step 3) |- ( ∀ x ¬ ph → ∀ x ( ph → x = y ) ) ;;
	step 5 : wff = 19.8a () |- ( ∀ x ( ph → x = y ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ∀ x ¬ ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 7 : wff = sylbir (step 2, step 6) |- ( ¬ ∃ x ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 8 : wff = eumo0 (hyp 1) |- ( ∃! x ph → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 9 : wff = ja (step 7, step 8) |- ( ( ∃ x ph → ∃! x ph ) → ∃ y ∀ x ( ph → x = y ) ) ;;
	step 10 : wff = eu3 (hyp 1) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 11 : wff = simplbi2com (step 10) |- ( ∃ y ∀ x ( ph → x = y ) → ( ∃ x ph → ∃! x ph ) ) ;;
	step 12 : wff = impbii (step 9, step 11) |- ( ( ∃ x ph → ∃! x ph ) ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 13 : wff = bitri (step 1, step 12) |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Substitution into "at most one".  (Contributed by Jeff Madsen,
       2-Sep-2009.) */

theorem sbmo (ph : wff, x : set, y : set, z : set) disjointed(w x z, w y z, w ph) {
	prop 1 : wff = |- ( [ y / x ] ∃* z ph ↔ ∃* z [ y / x ] ph ) ;;
}

proof of sbmo {
	var w : set;;
	step 1 : wff = sbex () |- ( [ y / x ] ∃ w ∀ z ( ph → z = w ) ↔ ∃ w [ y / x ] ∀ z ( ph → z = w ) ) ;;
	step 2 : wff = nfv () |- F/ x z = w ;;
	step 3 : wff = sblim (step 2) |- ( [ y / x ] ( ph → z = w ) ↔ ( [ y / x ] ph → z = w ) ) ;;
	step 4 : wff = sbalv (step 3) |- ( [ y / x ] ∀ z ( ph → z = w ) ↔ ∀ z ( [ y / x ] ph → z = w ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ w [ y / x ] ∀ z ( ph → z = w ) ↔ ∃ w ∀ z ( [ y / x ] ph → z = w ) ) ;;
	step 6 : wff = bitri (step 1, step 5) |- ( [ y / x ] ∃ w ∀ z ( ph → z = w ) ↔ ∃ w ∀ z ( [ y / x ] ph → z = w ) ) ;;
	step 7 : wff = nfv () |- F/ w ph ;;
	step 8 : wff = mo2 (step 7) |- ( ∃* z ph ↔ ∃ w ∀ z ( ph → z = w ) ) ;;
	step 9 : wff = sbbii (step 8) |- ( [ y / x ] ∃* z ph ↔ [ y / x ] ∃ w ∀ z ( ph → z = w ) ) ;;
	step 10 : wff = nfv () |- F/ w [ y / x ] ph ;;
	step 11 : wff = mo2 (step 10) |- ( ∃* z [ y / x ] ph ↔ ∃ w ∀ z ( [ y / x ] ph → z = w ) ) ;;
	step 12 : wff = 3bitr4i (step 6, step 9, step 11) |- ( [ y / x ] ∃* z ph ↔ ∃* z [ y / x ] ph ) ;;
	qed prop 1 = step 12 ;;
}

/*Alternate definition of "at most one."  Definition of [BellMachover]
       p. 460, except that definition has the side condition that ` y ` not
       occur in ` ph ` in place of our hypothesis.  (Contributed by NM,
       8-Mar-1995.) */

theorem mo3 (ph : wff, x : set, y : set) disjointed(x y) {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
}

proof of mo3 {
	step 1 : wff = mo2 (hyp 1) |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 2 : wff = mo (hyp 1) |- ( ∃ y ∀ x ( ph → x = y ) ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	qed prop 1 = step 3 ;;
}

/*"At most one" expressed using implicit substitution.  (Contributed by
       NM, 10-Apr-2004.) */

theorem mo4f (ph : wff, ps : wff, x : set, y : set) disjointed(x y, y ph) {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ;;
}

proof of mo4f {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = mo3 (step 1) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 3 : wff = sbie (hyp 1, hyp 2) |- ( [ y / x ] ph ↔ ps ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( ph ∧ [ y / x ] ph ) ↔ ( ph ∧ ps ) ) ;;
	step 5 : wff = imbi1i (step 4) |- ( ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ( ( ph ∧ ps ) → x = y ) ) ;;
	step 6 : wff = 2albii (step 5) |- ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ↔ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ;;
	step 7 : wff = bitri (step 2, step 6) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ;;
	qed prop 1 = step 7 ;;
}

/*"At most one" expressed using implicit substitution.  (Contributed by
       NM, 26-Jul-1995.) */

theorem mo4 (ph : wff, ps : wff, x : set, y : set) disjointed(x y, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ;;
}

proof of mo4 {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = mo4f (step 1, hyp 1) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for "at most one" quantifier (deduction rule).
       (Contributed by NM, 8-Mar-1995.) */

theorem mobid (ph : wff, ps : wff, ch : wff, x : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃* x ps ↔ ∃* x ch ) ) ;;
}

proof of mobid {
	step 1 : wff = exbid (hyp 1, hyp 2) |- ( ph → ( ∃ x ps ↔ ∃ x ch ) ) ;;
	step 2 : wff = eubid (hyp 1, hyp 2) |- ( ph → ( ∃! x ps ↔ ∃! x ch ) ) ;;
	step 3 : wff = imbi12d (step 1, step 2) |- ( ph → ( ( ∃ x ps → ∃! x ps ) ↔ ( ∃ x ch → ∃! x ch ) ) ) ;;
	step 4 : wff = df-mo () |- ( ∃* x ps ↔ ( ∃ x ps → ∃! x ps ) ) ;;
	step 5 : wff = df-mo () |- ( ∃* x ch ↔ ( ∃ x ch → ∃! x ch ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ph → ( ∃* x ps ↔ ∃* x ch ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Formula-building rule for "at most one" quantifier (deduction rule).
       (Contributed by Mario Carneiro, 7-Oct-2016.) */

theorem mobidv (ph : wff, ps : wff, ch : wff, x : set) disjointed(x ph) {
	hyp 1 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃* x ps ↔ ∃* x ch ) ) ;;
}

proof of mobidv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = mobid (step 1, hyp 1) |- ( ph → ( ∃* x ps ↔ ∃* x ch ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Formula-building rule for "at most one" quantifier (inference rule).
       (Contributed by NM, 9-Mar-1995.)  (Revised by Mario Carneiro,
       17-Oct-2016.) */

theorem mobii (ps : wff, ch : wff, x : set)  {
	hyp 1 : wff = |- ( ps ↔ ch ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ps ↔ ∃* x ch ) ;;
}

proof of mobii {
	step 1 : wff = a1i (hyp 1) |- ( T. → ( ps ↔ ch ) ) ;;
	step 2 : wff = mobidv (step 1) |- ( T. → ( ∃* x ps ↔ ∃* x ch ) ) ;;
	step 3 : wff = trud (step 2) |- ( ∃* x ps ↔ ∃* x ch ) ;;
	qed prop 1 = step 3 ;;
}

/*Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 9-Mar-1995.)  (Revised by Andrew Salmon,
       8-Jun-2011.) */

theorem cbvmo (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ph ↔ ∃* y ps ) ;;
}

proof of cbvmo {
	step 1 : wff = cbvex (hyp 1, hyp 2, hyp 3) |- ( ∃ x ph ↔ ∃ y ps ) ;;
	step 2 : wff = cbveu (hyp 1, hyp 2, hyp 3) |- ( ∃! x ph ↔ ∃! y ps ) ;;
	step 3 : wff = imbi12i (step 1, step 2) |- ( ( ∃ x ph → ∃! x ph ) ↔ ( ∃ y ps → ∃! y ps ) ) ;;
	step 4 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 5 : wff = df-mo () |- ( ∃* y ps ↔ ( ∃ y ps → ∃! y ps ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( ∃* x ph ↔ ∃* y ps ) ;;
	qed prop 1 = step 6 ;;
}

/*Uniqueness in terms of "at most one."  (Contributed by NM,
       23-Mar-1995.) */

theorem eu5 (ph : wff, x : set) disjointed(x y, y ph) {
	prop 1 : wff = |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃* x ph ) ) ;;
}

proof of eu5 {
	var y : set;;
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = eu3 (step 1) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 3 : wff = nfv () |- F/ y ph ;;
	step 4 : wff = mo2 (step 3) |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 5 : wff = anbi2i (step 4) |- ( ( ∃ x ph ∧ ∃* x ph ) ↔ ( ∃ x ph ∧ ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 6 : wff = bitr4i (step 2, step 5) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃* x ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/*Uniqueness using implicit substitution.  (Contributed by NM,
       26-Jul-1995.) */

theorem eu4 (ph : wff, ps : wff, x : set, y : set) disjointed(x y, y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ) ;;
}

proof of eu4 {
	step 1 : wff = eu5 () |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃* x ph ) ) ;;
	step 2 : wff = mo4 (hyp 1) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ;;
	step 3 : wff = anbi2i (step 2) |- ( ( ∃ x ph ∧ ∃* x ph ) ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∀ x ∀ y ( ( ph ∧ ps ) → x = y ) ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Existential uniqueness implies "at most one."  (Contributed by NM,
     23-Mar-1995.) */

theorem eumo (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃! x ph → ∃* x ph ) ;;
}

proof of eumo {
	step 1 : wff = eu5 () |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃* x ph ) ) ;;
	step 2 : wff = simprbi (step 1) |- ( ∃! x ph → ∃* x ph ) ;;
	qed prop 1 = step 2 ;;
}

/*"At most one" inferred from existential uniqueness.  (Contributed by NM,
       5-Apr-1995.) */

theorem eumoi (ph : wff, x : set)  {
	hyp 1 : wff = |- ∃! x ph ;;
	-----------------------
	prop 1 : wff = |- ∃* x ph ;;
}

proof of eumoi {
	step 1 : wff = eumo () |- ( ∃! x ph → ∃* x ph ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ∃* x ph ;;
	qed prop 1 = step 2 ;;
}

/*Existence in terms of "at most one" and uniqueness.  (Contributed by NM,
     5-Apr-2004.) */

theorem exmoeu (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃ x ph ↔ ( ∃* x ph → ∃! x ph ) ) ;;
}

proof of exmoeu {
	step 1 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 2 : wff = biimpi (step 1) |- ( ∃* x ph → ( ∃ x ph → ∃! x ph ) ) ;;
	step 3 : wff = com12 (step 2) |- ( ∃ x ph → ( ∃* x ph → ∃! x ph ) ) ;;
	step 4 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 5 : wff = biimpri (step 4) |- ( ( ∃ x ph → ∃! x ph ) → ∃* x ph ) ;;
	step 6 : wff = euex () |- ( ∃! x ph → ∃ x ph ) ;;
	step 7 : wff = imim12i (step 5, step 6) |- ( ( ∃* x ph → ∃! x ph ) → ( ( ∃ x ph → ∃! x ph ) → ∃ x ph ) ) ;;
	step 8 : wff = peirce () |- ( ( ( ∃ x ph → ∃! x ph ) → ∃ x ph ) → ∃ x ph ) ;;
	step 9 : wff = syl (step 7, step 8) |- ( ( ∃* x ph → ∃! x ph ) → ∃ x ph ) ;;
	step 10 : wff = impbii (step 3, step 9) |- ( ∃ x ph ↔ ( ∃* x ph → ∃! x ph ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Existence implies "at most one" is equivalent to uniqueness.  (Contributed
     by NM, 5-Apr-2004.) */

theorem exmoeu2 (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃ x ph → ( ∃* x ph ↔ ∃! x ph ) ) ;;
}

proof of exmoeu2 {
	step 1 : wff = eu5 () |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃* x ph ) ) ;;
	step 2 : wff = baibr (step 1) |- ( ∃ x ph → ( ∃* x ph ↔ ∃! x ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Absorption of existence condition by "at most one."  (Contributed by NM,
     4-Nov-2002.) */

theorem moabs (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃* x ph ↔ ( ∃ x ph → ∃* x ph ) ) ;;
}

proof of moabs {
	step 1 : wff = pm5.4 () |- ( ( ∃ x ph → ( ∃ x ph → ∃! x ph ) ) ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 2 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 3 : wff = imbi2i (step 2) |- ( ( ∃ x ph → ∃* x ph ) ↔ ( ∃ x ph → ( ∃ x ph → ∃! x ph ) ) ) ;;
	step 4 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 5 : wff = 3bitr4ri (step 1, step 3, step 4) |- ( ∃* x ph ↔ ( ∃ x ph → ∃* x ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Something exists or at most one exists.  (Contributed by NM,
     8-Mar-1995.) */

theorem exmo (ph : wff, x : set)  {
	prop 1 : wff = |- ( ∃ x ph ∨ ∃* x ph ) ;;
}

proof of exmo {
	step 1 : wff = pm2.21 () |- ( ¬ ∃ x ph → ( ∃ x ph → ∃! x ph ) ) ;;
	step 2 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 3 : wff = sylibr (step 1, step 2) |- ( ¬ ∃ x ph → ∃* x ph ) ;;
	step 4 : wff = orri (step 3) |- ( ∃ x ph ∨ ∃* x ph ) ;;
	qed prop 1 = step 4 ;;
}

/*"At most one" is preserved through implication (notice wff reversal).
       (Contributed by NM, 22-Apr-1995.) */

theorem moim (ph : wff, ps : wff, x : set) disjointed(x y, y ph, y ps) {
	prop 1 : wff = |- ( ∀ x ( ph → ps ) → ( ∃* x ps → ∃* x ph ) ) ;;
}

proof of moim {
	var y : set;;
	step 1 : wff = imim1 () |- ( ( ph → ps ) → ( ( ps → x = y ) → ( ph → x = y ) ) ) ;;
	step 2 : wff = al2imi (step 1) |- ( ∀ x ( ph → ps ) → ( ∀ x ( ps → x = y ) → ∀ x ( ph → x = y ) ) ) ;;
	step 3 : wff = eximdv (step 2) |- ( ∀ x ( ph → ps ) → ( ∃ y ∀ x ( ps → x = y ) → ∃ y ∀ x ( ph → x = y ) ) ) ;;
	step 4 : wff = nfv () |- F/ y ps ;;
	step 5 : wff = mo2 (step 4) |- ( ∃* x ps ↔ ∃ y ∀ x ( ps → x = y ) ) ;;
	step 6 : wff = nfv () |- F/ y ph ;;
	step 7 : wff = mo2 (step 6) |- ( ∃* x ph ↔ ∃ y ∀ x ( ph → x = y ) ) ;;
	step 8 : wff = 3imtr4g (step 3, step 5, step 7) |- ( ∀ x ( ph → ps ) → ( ∃* x ps → ∃* x ph ) ) ;;
	qed prop 1 = step 8 ;;
}

/*"At most one" is preserved through implication (notice wff reversal).
       (Contributed by NM, 15-Feb-2006.) */

theorem moimi (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ( ph → ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ps → ∃* x ph ) ;;
}

proof of moimi {
	step 1 : wff = moim () |- ( ∀ x ( ph → ps ) → ( ∃* x ps → ∃* x ph ) ) ;;
	step 2 : wff = mpg (step 1, hyp 1) |- ( ∃* x ps → ∃* x ph ) ;;
	qed prop 1 = step 2 ;;
}

/*Move antecedent outside of "at most one."  (Contributed by NM,
       28-Jul-1995.) */

theorem morimv (ph : wff, ps : wff, x : set) disjointed(x y, x y ph, y ps) {
	prop 1 : wff = |- ( ∃* x ( ph → ps ) → ( ph → ∃* x ps ) ) ;;
}

proof of morimv {
	var y : set;;
	step 1 : wff = ax-1 () |- ( ps → ( ph → ps ) ) ;;
	step 2 : wff = a1i (step 1) |- ( ph → ( ps → ( ph → ps ) ) ) ;;
	step 3 : wff = imim1d (step 2) |- ( ph → ( ( ( ph → ps ) → x = y ) → ( ps → x = y ) ) ) ;;
	step 4 : wff = alimdv (step 3) |- ( ph → ( ∀ x ( ( ph → ps ) → x = y ) → ∀ x ( ps → x = y ) ) ) ;;
	step 5 : wff = eximdv (step 4) |- ( ph → ( ∃ y ∀ x ( ( ph → ps ) → x = y ) → ∃ y ∀ x ( ps → x = y ) ) ) ;;
	step 6 : wff = nfv () |- F/ y ( ph → ps ) ;;
	step 7 : wff = mo2 (step 6) |- ( ∃* x ( ph → ps ) ↔ ∃ y ∀ x ( ( ph → ps ) → x = y ) ) ;;
	step 8 : wff = nfv () |- F/ y ps ;;
	step 9 : wff = mo2 (step 8) |- ( ∃* x ps ↔ ∃ y ∀ x ( ps → x = y ) ) ;;
	step 10 : wff = 3imtr4g (step 5, step 7, step 9) |- ( ph → ( ∃* x ( ph → ps ) → ∃* x ps ) ) ;;
	step 11 : wff = com12 (step 10) |- ( ∃* x ( ph → ps ) → ( ph → ∃* x ps ) ) ;;
	qed prop 1 = step 11 ;;
}

/*Uniqueness implies "at most one" through implication.  (Contributed by NM,
     22-Apr-1995.) */

theorem euimmo (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ∀ x ( ph → ps ) → ( ∃! x ps → ∃* x ph ) ) ;;
}

proof of euimmo {
	step 1 : wff = eumo () |- ( ∃! x ps → ∃* x ps ) ;;
	step 2 : wff = moim () |- ( ∀ x ( ph → ps ) → ( ∃* x ps → ∃* x ph ) ) ;;
	step 3 : wff = syl5 (step 1, step 2) |- ( ∀ x ( ph → ps ) → ( ∃! x ps → ∃* x ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Add existential uniqueness quantifiers to an implication.  Note the
     reversed implication in the antecedent.  (Contributed by NM,
     19-Oct-2005.)  (Proof shortened by Andrew Salmon, 14-Jun-2011.) */

theorem euim (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ( ∃ x ph ∧ ∀ x ( ph → ps ) ) → ( ∃! x ps → ∃! x ph ) ) ;;
}

proof of euim {
	step 1 : wff = ax-1 () |- ( ∃ x ph → ( ∃! x ps → ∃ x ph ) ) ;;
	step 2 : wff = euimmo () |- ( ∀ x ( ph → ps ) → ( ∃! x ps → ∃* x ph ) ) ;;
	step 3 : wff = anim12ii (step 1, step 2) |- ( ( ∃ x ph ∧ ∀ x ( ph → ps ) ) → ( ∃! x ps → ( ∃ x ph ∧ ∃* x ph ) ) ) ;;
	step 4 : wff = eu5 () |- ( ∃! x ph ↔ ( ∃ x ph ∧ ∃* x ph ) ) ;;
	step 5 : wff = syl6ibr (step 3, step 4) |- ( ( ∃ x ph ∧ ∀ x ( ph → ps ) ) → ( ∃! x ps → ∃! x ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/*"At most one" is still the case when a conjunct is added.  (Contributed by
     NM, 22-Apr-1995.) */

theorem moan (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ∃* x ph → ∃* x ( ps ∧ ph ) ) ;;
}

proof of moan {
	step 1 : wff = simpr () |- ( ( ps ∧ ph ) → ph ) ;;
	step 2 : wff = moimi (step 1) |- ( ∃* x ph → ∃* x ( ps ∧ ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/*"At most one" is still true when a conjunct is added.  (Contributed by
       NM, 9-Mar-1995.) */

theorem moani (ph : wff, ps : wff, x : set)  {
	hyp 1 : wff = |- ∃* x ph ;;
	-----------------------
	prop 1 : wff = |- ∃* x ( ps ∧ ph ) ;;
}

proof of moani {
	step 1 : wff = moan () |- ( ∃* x ph → ∃* x ( ps ∧ ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ∃* x ( ps ∧ ph ) ;;
	qed prop 1 = step 2 ;;
}

/*"At most one" is still the case when a disjunct is removed.  (Contributed
     by NM, 5-Apr-2004.) */

theorem moor (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ∃* x ( ph ∨ ps ) → ∃* x ph ) ;;
}

proof of moor {
	step 1 : wff = orc () |- ( ph → ( ph ∨ ps ) ) ;;
	step 2 : wff = moimi (step 1) |- ( ∃* x ( ph ∨ ps ) → ∃* x ph ) ;;
	qed prop 1 = step 2 ;;
}

/*"At most one" imports disjunction to conjunction.  (Contributed by NM,
     5-Apr-2004.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem mooran1 (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ( ∃* x ph ∨ ∃* x ps ) → ∃* x ( ph ∧ ps ) ) ;;
}

proof of mooran1 {
	step 1 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 2 : wff = moimi (step 1) |- ( ∃* x ph → ∃* x ( ph ∧ ps ) ) ;;
	step 3 : wff = moan () |- ( ∃* x ps → ∃* x ( ph ∧ ps ) ) ;;
	step 4 : wff = jaoi (step 2, step 3) |- ( ( ∃* x ph ∨ ∃* x ps ) → ∃* x ( ph ∧ ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*"At most one" exports disjunction to conjunction.  (Contributed by NM,
     5-Apr-2004.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem mooran2 (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ∃* x ( ph ∨ ps ) → ( ∃* x ph ∧ ∃* x ps ) ) ;;
}

proof of mooran2 {
	step 1 : wff = moor () |- ( ∃* x ( ph ∨ ps ) → ∃* x ph ) ;;
	step 2 : wff = olc () |- ( ps → ( ph ∨ ps ) ) ;;
	step 3 : wff = moimi (step 2) |- ( ∃* x ( ph ∨ ps ) → ∃* x ps ) ;;
	step 4 : wff = jca (step 1, step 3) |- ( ∃* x ( ph ∨ ps ) → ( ∃* x ph ∧ ∃* x ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/*Introduction of a conjunct into "at most one" quantifier.  (Contributed
       by NM, 3-Dec-2001.) */

theorem moanim (ph : wff, ps : wff, x : set) disjointed(x y, y ph, y ps) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃* x ( ph ∧ ps ) ↔ ( ph → ∃* x ps ) ) ;;
}

proof of moanim {
	var y : set;;
	step 1 : wff = impexp () |- ( ( ( ph ∧ ps ) → x = y ) ↔ ( ph → ( ps → x = y ) ) ) ;;
	step 2 : wff = albii (step 1) |- ( ∀ x ( ( ph ∧ ps ) → x = y ) ↔ ∀ x ( ph → ( ps → x = y ) ) ) ;;
	step 3 : wff = 19.21 (hyp 1) |- ( ∀ x ( ph → ( ps → x = y ) ) ↔ ( ph → ∀ x ( ps → x = y ) ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∀ x ( ( ph ∧ ps ) → x = y ) ↔ ( ph → ∀ x ( ps → x = y ) ) ) ;;
	step 5 : wff = exbii (step 4) |- ( ∃ y ∀ x ( ( ph ∧ ps ) → x = y ) ↔ ∃ y ( ph → ∀ x ( ps → x = y ) ) ) ;;
	step 6 : wff = nfv () |- F/ y ( ph ∧ ps ) ;;
	step 7 : wff = mo2 (step 6) |- ( ∃* x ( ph ∧ ps ) ↔ ∃ y ∀ x ( ( ph ∧ ps ) → x = y ) ) ;;
	step 8 : wff = nfv () |- F/ y ps ;;
	step 9 : wff = mo2 (step 8) |- ( ∃* x ps ↔ ∃ y ∀ x ( ps → x = y ) ) ;;
	step 10 : wff = imbi2i (step 9) |- ( ( ph → ∃* x ps ) ↔ ( ph → ∃ y ∀ x ( ps → x = y ) ) ) ;;
	step 11 : wff = 19.37v () |- ( ∃ y ( ph → ∀ x ( ps → x = y ) ) ↔ ( ph → ∃ y ∀ x ( ps → x = y ) ) ) ;;
	step 12 : wff = bitr4i (step 10, step 11) |- ( ( ph → ∃* x ps ) ↔ ∃ y ( ph → ∀ x ( ps → x = y ) ) ) ;;
	step 13 : wff = 3bitr4i (step 5, step 7, step 12) |- ( ∃* x ( ph ∧ ps ) ↔ ( ph → ∃* x ps ) ) ;;
	qed prop 1 = step 13 ;;
}

/*Introduction of a conjunct into uniqueness quantifier.  (Contributed by
       NM, 19-Feb-2005.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem euan (ph : wff, ps : wff, x : set) disjointed(x, ph, ps) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃! x ( ph ∧ ps ) ↔ ( ph ∧ ∃! x ps ) ) ;;
}

proof of euan {
	step 1 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 2 : wff = exlimi (hyp 1, step 1) |- ( ∃ x ( ph ∧ ps ) → ph ) ;;
	step 3 : wff = adantr (step 2) |- ( ( ∃ x ( ph ∧ ps ) ∧ ∃* x ( ph ∧ ps ) ) → ph ) ;;
	step 4 : wff = simpr () |- ( ( ph ∧ ps ) → ps ) ;;
	step 5 : wff = eximi (step 4) |- ( ∃ x ( ph ∧ ps ) → ∃ x ps ) ;;
	step 6 : wff = adantr (step 5) |- ( ( ∃ x ( ph ∧ ps ) ∧ ∃* x ( ph ∧ ps ) ) → ∃ x ps ) ;;
	step 7 : wff = nfe1 () |- F/ x ∃ x ( ph ∧ ps ) ;;
	step 8 : wff = simpr () |- ( ( ph ∧ ps ) → ps ) ;;
	step 9 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 10 : wff = exlimi (hyp 1, step 9) |- ( ∃ x ( ph ∧ ps ) → ph ) ;;
	step 11 : wff = a1d (step 10) |- ( ∃ x ( ph ∧ ps ) → ( ps → ph ) ) ;;
	step 12 : wff = ancrd (step 11) |- ( ∃ x ( ph ∧ ps ) → ( ps → ( ph ∧ ps ) ) ) ;;
	step 13 : wff = impbid2 (step 8, step 12) |- ( ∃ x ( ph ∧ ps ) → ( ( ph ∧ ps ) ↔ ps ) ) ;;
	step 14 : wff = mobid (step 7, step 13) |- ( ∃ x ( ph ∧ ps ) → ( ∃* x ( ph ∧ ps ) ↔ ∃* x ps ) ) ;;
	step 15 : wff = biimpa (step 14) |- ( ( ∃ x ( ph ∧ ps ) ∧ ∃* x ( ph ∧ ps ) ) → ∃* x ps ) ;;
	step 16 : wff = jca32 (step 3, step 6, step 15) |- ( ( ∃ x ( ph ∧ ps ) ∧ ∃* x ( ph ∧ ps ) ) → ( ph ∧ ( ∃ x ps ∧ ∃* x ps ) ) ) ;;
	step 17 : wff = eu5 () |- ( ∃! x ( ph ∧ ps ) ↔ ( ∃ x ( ph ∧ ps ) ∧ ∃* x ( ph ∧ ps ) ) ) ;;
	step 18 : wff = eu5 () |- ( ∃! x ps ↔ ( ∃ x ps ∧ ∃* x ps ) ) ;;
	step 19 : wff = anbi2i (step 18) |- ( ( ph ∧ ∃! x ps ) ↔ ( ph ∧ ( ∃ x ps ∧ ∃* x ps ) ) ) ;;
	step 20 : wff = 3imtr4i (step 16, step 17, step 19) |- ( ∃! x ( ph ∧ ps ) → ( ph ∧ ∃! x ps ) ) ;;
	step 21 : wff = ibar () |- ( ph → ( ps ↔ ( ph ∧ ps ) ) ) ;;
	step 22 : wff = eubid (hyp 1, step 21) |- ( ph → ( ∃! x ps ↔ ∃! x ( ph ∧ ps ) ) ) ;;
	step 23 : wff = biimpa (step 22) |- ( ( ph ∧ ∃! x ps ) → ∃! x ( ph ∧ ps ) ) ;;
	step 24 : wff = impbii (step 20, step 23) |- ( ∃! x ( ph ∧ ps ) ↔ ( ph ∧ ∃! x ps ) ) ;;
	qed prop 1 = step 24 ;;
}

/*Introduction of a conjunct into "at most one" quantifier.  (Contributed
       by NM, 23-Mar-1995.) */

theorem moanimv (ph : wff, ps : wff, x : set) disjointed(x ph, ps) {
	prop 1 : wff = |- ( ∃* x ( ph ∧ ps ) ↔ ( ph → ∃* x ps ) ) ;;
}

proof of moanimv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = moanim (step 1) |- ( ∃* x ( ph ∧ ps ) ↔ ( ph → ∃* x ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Nested "at most one" and uniqueness quantifiers.  (Contributed by NM,
     25-Jan-2006.) */

theorem moaneu (ph : wff, x : set)  {
	prop 1 : wff = |- ∃* x ( ph ∧ ∃! x ph ) ;;
}

proof of moaneu {
	step 1 : wff = eumo () |- ( ∃! x ph → ∃* x ph ) ;;
	step 2 : wff = nfeu1 () |- F/ x ∃! x ph ;;
	step 3 : wff = moanim (step 2) |- ( ∃* x ( ∃! x ph ∧ ph ) ↔ ( ∃! x ph → ∃* x ph ) ) ;;
	step 4 : wff = mpbir (step 1, step 3) |- ∃* x ( ∃! x ph ∧ ph ) ;;
	step 5 : wff = ancom () |- ( ( ph ∧ ∃! x ph ) ↔ ( ∃! x ph ∧ ph ) ) ;;
	step 6 : wff = mobii (step 5) |- ( ∃* x ( ph ∧ ∃! x ph ) ↔ ∃* x ( ∃! x ph ∧ ph ) ) ;;
	step 7 : wff = mpbir (step 4, step 6) |- ∃* x ( ph ∧ ∃! x ph ) ;;
	qed prop 1 = step 7 ;;
}

/*Nested "at most one" quantifiers.  (Contributed by NM, 25-Jan-2006.) */

theorem moanmo (ph : wff, x : set)  {
	prop 1 : wff = |- ∃* x ( ph ∧ ∃* x ph ) ;;
}

proof of moanmo {
	step 1 : wff = id () |- ( ∃* x ph → ∃* x ph ) ;;
	step 2 : wff = nfmo1 () |- F/ x ∃* x ph ;;
	step 3 : wff = moanim (step 2) |- ( ∃* x ( ∃* x ph ∧ ph ) ↔ ( ∃* x ph → ∃* x ph ) ) ;;
	step 4 : wff = mpbir (step 1, step 3) |- ∃* x ( ∃* x ph ∧ ph ) ;;
	step 5 : wff = ancom () |- ( ( ph ∧ ∃* x ph ) ↔ ( ∃* x ph ∧ ph ) ) ;;
	step 6 : wff = mobii (step 5) |- ( ∃* x ( ph ∧ ∃* x ph ) ↔ ∃* x ( ∃* x ph ∧ ph ) ) ;;
	step 7 : wff = mpbir (step 4, step 6) |- ∃* x ( ph ∧ ∃* x ph ) ;;
	qed prop 1 = step 7 ;;
}

/*Introduction of a conjunct into uniqueness quantifier.  (Contributed by
       NM, 23-Mar-1995.) */

theorem euanv (ph : wff, ps : wff, x : set) disjointed(x ph) {
	prop 1 : wff = |- ( ∃! x ( ph ∧ ps ) ↔ ( ph ∧ ∃! x ps ) ) ;;
}

proof of euanv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = euan (step 1) |- ( ∃! x ( ph ∧ ps ) ↔ ( ph ∧ ∃! x ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*"At most one" picks a variable value, eliminating an existential
       quantifier.  (Contributed by NM, 27-Jan-1997.) */

theorem mopick (ph : wff, ps : wff, x : set) disjointed(x y, y ph, y ps) {
	prop 1 : wff = |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
}

proof of mopick {
	var y : set;;
	step 1 : wff = nfv () |- F/ y ( ph ∧ ps ) ;;
	step 2 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 3 : wff = nfs1v () |- F/ x [ y / x ] ps ;;
	step 4 : wff = nfan (step 2, step 3) |- F/ x ( [ y / x ] ph ∧ [ y / x ] ps ) ;;
	step 5 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 6 : wff = sbequ12 () |- ( x = y → ( ps ↔ [ y / x ] ps ) ) ;;
	step 7 : wff = anbi12d (step 5, step 6) |- ( x = y → ( ( ph ∧ ps ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ) ) ) ;;
	step 8 : wff = cbvex (step 1, step 4, step 7) |- ( ∃ x ( ph ∧ ps ) ↔ ∃ y ( [ y / x ] ph ∧ [ y / x ] ps ) ) ;;
	step 9 : wff = nfv () |- F/ y ph ;;
	step 10 : wff = mo3 (step 9) |- ( ∃* x ph ↔ ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 11 : wff = sp () |- ( ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 12 : wff = sps (step 11) |- ( ∀ x ∀ y ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 13 : wff = sylbi (step 10, step 12) |- ( ∃* x ph → ( ( ph ∧ [ y / x ] ph ) → x = y ) ) ;;
	step 14 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ps → ps ) ) ;;
	step 15 : wff = imim2i (step 14) |- ( ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ( ph ∧ [ y / x ] ph ) → ( [ y / x ] ps → ps ) ) ) ;;
	step 16 : wff = exp3a (step 15) |- ( ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ph → ( [ y / x ] ph → ( [ y / x ] ps → ps ) ) ) ) ;;
	step 17 : wff = com4t (step 16) |- ( [ y / x ] ph → ( [ y / x ] ps → ( ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ph → ps ) ) ) ) ;;
	step 18 : wff = imp (step 17) |- ( ( [ y / x ] ph ∧ [ y / x ] ps ) → ( ( ( ph ∧ [ y / x ] ph ) → x = y ) → ( ph → ps ) ) ) ;;
	step 19 : wff = syl5 (step 13, step 18) |- ( ( [ y / x ] ph ∧ [ y / x ] ps ) → ( ∃* x ph → ( ph → ps ) ) ) ;;
	step 20 : wff = exlimiv (step 19) |- ( ∃ y ( [ y / x ] ph ∧ [ y / x ] ps ) → ( ∃* x ph → ( ph → ps ) ) ) ;;
	step 21 : wff = sylbi (step 8, step 20) |- ( ∃ x ( ph ∧ ps ) → ( ∃* x ph → ( ph → ps ) ) ) ;;
	step 22 : wff = impcom (step 21) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	qed prop 1 = step 22 ;;
}

/*Existential uniqueness "picks" a variable value for which another wff is
     true.  If there is only one thing ` x ` such that ` ph ` is true, and
     there is also an ` x ` (actually the same one) such that ` ph ` and ` ps `
     are both true, then ` ph ` implies ` ps ` regardless of ` x ` .  This
     theorem can be useful for eliminating existential quantifiers in a
     hypothesis.  Compare Theorem *14.26 in [WhiteheadRussell] p. 192.
     (Contributed by NM, 10-Jul-1994.) */

theorem eupick (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
}

proof of eupick {
	step 1 : wff = eumo () |- ( ∃! x ph → ∃* x ph ) ;;
	step 2 : wff = mopick () |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	step 3 : wff = sylan (step 1, step 2) |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/*Version of ~ eupick with closed formulas.  (Contributed by NM,
     6-Sep-2008.) */

theorem eupicka (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ∀ x ( ph → ps ) ) ;;
}

proof of eupicka {
	step 1 : wff = nfeu1 () |- F/ x ∃! x ph ;;
	step 2 : wff = nfe1 () |- F/ x ∃ x ( ph ∧ ps ) ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ x ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) ;;
	step 4 : wff = eupick () |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	step 5 : wff = alrimi (step 3, step 4) |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ∀ x ( ph → ps ) ) ;;
	qed prop 1 = step 5 ;;
}

/*Existential uniqueness "pick" showing wff equivalence.  (Contributed by
     NM, 25-Nov-1994.) */

theorem eupickb (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ( ∃! x ph ∧ ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) → ( ph ↔ ps ) ) ;;
}

proof of eupickb {
	step 1 : wff = eupick () |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	step 2 : wff = 3adant2 (step 1) |- ( ( ∃! x ph ∧ ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	step 3 : wff = 3simpc () |- ( ( ∃! x ph ∧ ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) → ( ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) ) ;;
	step 4 : wff = pm3.22 () |- ( ( ph ∧ ps ) → ( ps ∧ ph ) ) ;;
	step 5 : wff = eximi (step 4) |- ( ∃ x ( ph ∧ ps ) → ∃ x ( ps ∧ ph ) ) ;;
	step 6 : wff = anim2i (step 5) |- ( ( ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) → ( ∃! x ps ∧ ∃ x ( ps ∧ ph ) ) ) ;;
	step 7 : wff = eupick () |- ( ( ∃! x ps ∧ ∃ x ( ps ∧ ph ) ) → ( ps → ph ) ) ;;
	step 8 : wff = 3syl (step 3, step 6, step 7) |- ( ( ∃! x ph ∧ ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) → ( ps → ph ) ) ;;
	step 9 : wff = impbid (step 2, step 8) |- ( ( ∃! x ph ∧ ∃! x ps ∧ ∃ x ( ph ∧ ps ) ) → ( ph ↔ ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Theorem *14.26 in [WhiteheadRussell] p. 192.  (Contributed by Andrew
     Salmon, 11-Jul-2011.) */

theorem eupickbi (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ∃! x ph → ( ∃ x ( ph ∧ ps ) ↔ ∀ x ( ph → ps ) ) ) ;;
}

proof of eupickbi {
	step 1 : wff = eupicka () |- ( ( ∃! x ph ∧ ∃ x ( ph ∧ ps ) ) → ∀ x ( ph → ps ) ) ;;
	step 2 : wff = ex (step 1) |- ( ∃! x ph → ( ∃ x ( ph ∧ ps ) → ∀ x ( ph → ps ) ) ) ;;
	step 3 : wff = nfa1 () |- F/ x ∀ x ( ph → ps ) ;;
	step 4 : wff = ancl () |- ( ( ph → ps ) → ( ph → ( ph ∧ ps ) ) ) ;;
	step 5 : wff = simpl () |- ( ( ph ∧ ps ) → ph ) ;;
	step 6 : wff = impbid1 (step 4, step 5) |- ( ( ph → ps ) → ( ph ↔ ( ph ∧ ps ) ) ) ;;
	step 7 : wff = sps (step 6) |- ( ∀ x ( ph → ps ) → ( ph ↔ ( ph ∧ ps ) ) ) ;;
	step 8 : wff = eubid (step 3, step 7) |- ( ∀ x ( ph → ps ) → ( ∃! x ph ↔ ∃! x ( ph ∧ ps ) ) ) ;;
	step 9 : wff = euex () |- ( ∃! x ( ph ∧ ps ) → ∃ x ( ph ∧ ps ) ) ;;
	step 10 : wff = syl6bi (step 8, step 9) |- ( ∀ x ( ph → ps ) → ( ∃! x ph → ∃ x ( ph ∧ ps ) ) ) ;;
	step 11 : wff = com12 (step 10) |- ( ∃! x ph → ( ∀ x ( ph → ps ) → ∃ x ( ph ∧ ps ) ) ) ;;
	step 12 : wff = impbid (step 2, step 11) |- ( ∃! x ph → ( ∃ x ( ph ∧ ps ) ↔ ∀ x ( ph → ps ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/*"At most one" can show the existence of a common value.  In this case we
     can infer existence of conjunction from a conjunction of existence, and it
     is one way to achieve the converse of ~ 19.40 .  (Contributed by NM,
     5-Apr-2004.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem mopick2 (ph : wff, ps : wff, ch : wff, x : set)  {
	prop 1 : wff = |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ∧ ∃ x ( ph ∧ ch ) ) → ∃ x ( ph ∧ ps ∧ ch ) ) ;;
}

proof of mopick2 {
	step 1 : wff = nfmo1 () |- F/ x ∃* x ph ;;
	step 2 : wff = nfe1 () |- F/ x ∃ x ( ph ∧ ps ) ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ x ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) ;;
	step 4 : wff = mopick () |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	step 5 : wff = ancld (step 4) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ( ph ∧ ps ) ) ) ;;
	step 6 : wff = anim1d (step 5) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ( ph ∧ ch ) → ( ( ph ∧ ps ) ∧ ch ) ) ) ;;
	step 7 : wff = df-3an () |- ( ( ph ∧ ps ∧ ch ) ↔ ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 8 : wff = syl6ibr (step 6, step 7) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ( ph ∧ ch ) → ( ph ∧ ps ∧ ch ) ) ) ;;
	step 9 : wff = eximd (step 3, step 8) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ∃ x ( ph ∧ ch ) → ∃ x ( ph ∧ ps ∧ ch ) ) ) ;;
	step 10 : wff = 3impia (step 9) |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ∧ ∃ x ( ph ∧ ch ) ) → ∃ x ( ph ∧ ps ∧ ch ) ) ;;
	qed prop 1 = step 10 ;;
}

/*Introduce or eliminate a disjunct in a uniqueness quantifier.
     (Contributed by NM, 21-Oct-2005.)  (Proof shortened by Andrew Salmon,
     9-Jul-2011.) */

theorem euor2 (ph : wff, ps : wff, x : set)  {
	prop 1 : wff = |- ( ¬ ∃ x ph → ( ∃! x ( ph ∨ ps ) ↔ ∃! x ps ) ) ;;
}

proof of euor2 {
	step 1 : wff = nfe1 () |- F/ x ∃ x ph ;;
	step 2 : wff = nfn (step 1) |- F/ x ¬ ∃ x ph ;;
	step 3 : wff = 19.8a () |- ( ph → ∃ x ph ) ;;
	step 4 : wff = con3i (step 3) |- ( ¬ ∃ x ph → ¬ ph ) ;;
	step 5 : wff = orel1 () |- ( ¬ ph → ( ( ph ∨ ps ) → ps ) ) ;;
	step 6 : wff = olc () |- ( ps → ( ph ∨ ps ) ) ;;
	step 7 : wff = impbid1 (step 5, step 6) |- ( ¬ ph → ( ( ph ∨ ps ) ↔ ps ) ) ;;
	step 8 : wff = syl (step 4, step 7) |- ( ¬ ∃ x ph → ( ( ph ∨ ps ) ↔ ps ) ) ;;
	step 9 : wff = eubid (step 2, step 8) |- ( ¬ ∃ x ph → ( ∃! x ( ph ∨ ps ) ↔ ∃! x ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/*"At most one" double quantification.  (Contributed by NM,
       3-Dec-2001.) */

theorem moexex (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ( ∃* x ph ∧ ∀ x ∃* y ps ) → ∃* y ∃ x ( ph ∧ ps ) ) ;;
}

proof of moexex {
	step 1 : wff = nfmo1 () |- F/ x ∃* x ph ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ∃* y ps ;;
	step 3 : wff = nfe1 () |- F/ x ∃ x ( ph ∧ ps ) ;;
	step 4 : wff = nfmo (step 3) |- F/ x ∃* y ∃ x ( ph ∧ ps ) ;;
	step 5 : wff = nfim (step 2, step 4) |- F/ x ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ;;
	step 6 : wff = nfim (step 1, step 5) |- F/ x ( ∃* x ph → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ;;
	step 7 : wff = nfmo (hyp 1) |- F/ y ∃* x ph ;;
	step 8 : wff = mopick () |- ( ( ∃* x ph ∧ ∃ x ( ph ∧ ps ) ) → ( ph → ps ) ) ;;
	step 9 : wff = ex (step 8) |- ( ∃* x ph → ( ∃ x ( ph ∧ ps ) → ( ph → ps ) ) ) ;;
	step 10 : wff = com3r (step 9) |- ( ph → ( ∃* x ph → ( ∃ x ( ph ∧ ps ) → ps ) ) ) ;;
	step 11 : wff = alrimd (hyp 1, step 7, step 10) |- ( ph → ( ∃* x ph → ∀ y ( ∃ x ( ph ∧ ps ) → ps ) ) ) ;;
	step 12 : wff = moim () |- ( ∀ y ( ∃ x ( ph ∧ ps ) → ps ) → ( ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ;;
	step 13 : wff = spsd (step 12) |- ( ∀ y ( ∃ x ( ph ∧ ps ) → ps ) → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ;;
	step 14 : wff = syl6 (step 11, step 13) |- ( ph → ( ∃* x ph → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ) ;;
	step 15 : wff = exlimi (step 6, step 14) |- ( ∃ x ph → ( ∃* x ph → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ) ;;
	step 16 : wff = nfex (hyp 1) |- F/ y ∃ x ph ;;
	step 17 : wff = exsimpl () |- ( ∃ x ( ph ∧ ps ) → ∃ x ph ) ;;
	step 18 : wff = exlimi (step 16, step 17) |- ( ∃ y ∃ x ( ph ∧ ps ) → ∃ x ph ) ;;
	step 19 : wff = con3i (step 18) |- ( ¬ ∃ x ph → ¬ ∃ y ∃ x ( ph ∧ ps ) ) ;;
	step 20 : wff = exmo () |- ( ∃ y ∃ x ( ph ∧ ps ) ∨ ∃* y ∃ x ( ph ∧ ps ) ) ;;
	step 21 : wff = ori (step 20) |- ( ¬ ∃ y ∃ x ( ph ∧ ps ) → ∃* y ∃ x ( ph ∧ ps ) ) ;;
	step 22 : wff = syl (step 19, step 21) |- ( ¬ ∃ x ph → ∃* y ∃ x ( ph ∧ ps ) ) ;;
	step 23 : wff = a1d (step 22) |- ( ¬ ∃ x ph → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ;;
	step 24 : wff = a1d (step 23) |- ( ¬ ∃ x ph → ( ∃* x ph → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ) ;;
	step 25 : wff = pm2.61i (step 15, step 24) |- ( ∃* x ph → ( ∀ x ∃* y ps → ∃* y ∃ x ( ph ∧ ps ) ) ) ;;
	step 26 : wff = imp (step 25) |- ( ( ∃* x ph ∧ ∀ x ∃* y ps ) → ∃* y ∃ x ( ph ∧ ps ) ) ;;
	qed prop 1 = step 26 ;;
}

/*"At most one" double quantification.  (Contributed by NM,
       26-Jan-1997.) */

theorem moexexv (ph : wff, ps : wff, x : set, y : set) disjointed(y ph) {
	prop 1 : wff = |- ( ( ∃* x ph ∧ ∀ x ∃* y ps ) → ∃* y ∃ x ( ph ∧ ps ) ) ;;
}

proof of moexexv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = moexex (step 1) |- ( ( ∃* x ph ∧ ∀ x ∃* y ps ) → ∃* y ∃ x ( ph ∧ ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/*Double quantification with "at most one."  (Contributed by NM,
     3-Dec-2001.) */

theorem 2moex (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∃* x ∃ y ph → ∀ y ∃* x ph ) ;;
}

proof of 2moex {
	step 1 : wff = nfe1 () |- F/ y ∃ y ph ;;
	step 2 : wff = nfmo (step 1) |- F/ y ∃* x ∃ y ph ;;
	step 3 : wff = 19.8a () |- ( ph → ∃ y ph ) ;;
	step 4 : wff = moimi (step 3) |- ( ∃* x ∃ y ph → ∃* x ph ) ;;
	step 5 : wff = alrimi (step 2, step 4) |- ( ∃* x ∃ y ph → ∀ y ∃* x ph ) ;;
	qed prop 1 = step 5 ;;
}

/*Double quantification with existential uniqueness.  (Contributed by NM,
     3-Dec-2001.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem 2euex (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∃! x ∃ y ph → ∃ y ∃! x ph ) ;;
}

proof of 2euex {
	step 1 : wff = eu5 () |- ( ∃! x ∃ y ph ↔ ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) ) ;;
	step 2 : wff = excom () |- ( ∃ x ∃ y ph ↔ ∃ y ∃ x ph ) ;;
	step 3 : wff = nfe1 () |- F/ y ∃ y ph ;;
	step 4 : wff = nfmo (step 3) |- F/ y ∃* x ∃ y ph ;;
	step 5 : wff = 19.8a () |- ( ph → ∃ y ph ) ;;
	step 6 : wff = moimi (step 5) |- ( ∃* x ∃ y ph → ∃* x ph ) ;;
	step 7 : wff = df-mo () |- ( ∃* x ph ↔ ( ∃ x ph → ∃! x ph ) ) ;;
	step 8 : wff = sylib (step 6, step 7) |- ( ∃* x ∃ y ph → ( ∃ x ph → ∃! x ph ) ) ;;
	step 9 : wff = eximd (step 4, step 8) |- ( ∃* x ∃ y ph → ( ∃ y ∃ x ph → ∃ y ∃! x ph ) ) ;;
	step 10 : wff = syl5bi (step 2, step 9) |- ( ∃* x ∃ y ph → ( ∃ x ∃ y ph → ∃ y ∃! x ph ) ) ;;
	step 11 : wff = impcom (step 10) |- ( ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) → ∃ y ∃! x ph ) ;;
	step 12 : wff = sylbi (step 1, step 11) |- ( ∃! x ∃ y ph → ∃ y ∃! x ph ) ;;
	qed prop 1 = step 12 ;;
}

/*Double quantification with existential uniqueness and "at most one."
     (Contributed by NM, 3-Dec-2001.) */

theorem 2eumo (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∃! x ∃* y ph → ∃* x ∃! y ph ) ;;
}

proof of 2eumo {
	step 1 : wff = euimmo () |- ( ∀ x ( ∃! y ph → ∃* y ph ) → ( ∃! x ∃* y ph → ∃* x ∃! y ph ) ) ;;
	step 2 : wff = eumo () |- ( ∃! y ph → ∃* y ph ) ;;
	step 3 : wff = mpg (step 1, step 2) |- ( ∃! x ∃* y ph → ∃* x ∃! y ph ) ;;
	qed prop 1 = step 3 ;;
}

/*Double existential uniqueness.  (Contributed by NM, 3-Dec-2001.) */

theorem 2eu2ex (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∃! x ∃! y ph → ∃ x ∃ y ph ) ;;
}

proof of 2eu2ex {
	step 1 : wff = euex () |- ( ∃! x ∃! y ph → ∃ x ∃! y ph ) ;;
	step 2 : wff = euex () |- ( ∃! y ph → ∃ y ph ) ;;
	step 3 : wff = eximi (step 2) |- ( ∃ x ∃! y ph → ∃ x ∃ y ph ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( ∃! x ∃! y ph → ∃ x ∃ y ph ) ;;
	qed prop 1 = step 4 ;;
}

/*A condition allowing swap of "at most one" and existential quantifiers.
     (Contributed by NM, 10-Apr-2004.) */

theorem 2moswap (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ∃* y ph → ( ∃* x ∃ y ph → ∃* y ∃ x ph ) ) ;;
}

proof of 2moswap {
	step 1 : wff = nfe1 () |- F/ y ∃ y ph ;;
	step 2 : wff = moexex (step 1) |- ( ( ∃* x ∃ y ph ∧ ∀ x ∃* y ph ) → ∃* y ∃ x ( ∃ y ph ∧ ph ) ) ;;
	step 3 : wff = expcom (step 2) |- ( ∀ x ∃* y ph → ( ∃* x ∃ y ph → ∃* y ∃ x ( ∃ y ph ∧ ph ) ) ) ;;
	step 4 : wff = 19.8a () |- ( ph → ∃ y ph ) ;;
	step 5 : wff = pm4.71ri (step 4) |- ( ph ↔ ( ∃ y ph ∧ ph ) ) ;;
	step 6 : wff = exbii (step 5) |- ( ∃ x ph ↔ ∃ x ( ∃ y ph ∧ ph ) ) ;;
	step 7 : wff = mobii (step 6) |- ( ∃* y ∃ x ph ↔ ∃* y ∃ x ( ∃ y ph ∧ ph ) ) ;;
	step 8 : wff = syl6ibr (step 3, step 7) |- ( ∀ x ∃* y ph → ( ∃* x ∃ y ph → ∃* y ∃ x ph ) ) ;;
	qed prop 1 = step 8 ;;
}

/*A condition allowing swap of uniqueness and existential quantifiers.
     (Contributed by NM, 10-Apr-2004.) */

theorem 2euswap (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ∃* y ph → ( ∃! x ∃ y ph → ∃! y ∃ x ph ) ) ;;
}

proof of 2euswap {
	step 1 : wff = excomim () |- ( ∃ x ∃ y ph → ∃ y ∃ x ph ) ;;
	step 2 : wff = a1i (step 1) |- ( ∀ x ∃* y ph → ( ∃ x ∃ y ph → ∃ y ∃ x ph ) ) ;;
	step 3 : wff = 2moswap () |- ( ∀ x ∃* y ph → ( ∃* x ∃ y ph → ∃* y ∃ x ph ) ) ;;
	step 4 : wff = anim12d (step 2, step 3) |- ( ∀ x ∃* y ph → ( ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) → ( ∃ y ∃ x ph ∧ ∃* y ∃ x ph ) ) ) ;;
	step 5 : wff = eu5 () |- ( ∃! x ∃ y ph ↔ ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) ) ;;
	step 6 : wff = eu5 () |- ( ∃! y ∃ x ph ↔ ( ∃ y ∃ x ph ∧ ∃* y ∃ x ph ) ) ;;
	step 7 : wff = 3imtr4g (step 4, step 5, step 6) |- ( ∀ x ∃* y ph → ( ∃! x ∃ y ph → ∃! y ∃ x ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/*Double existential uniqueness implies double uniqueness quantification.
     (Contributed by NM, 3-Dec-2001.)  (Proof shortened by Mario Carneiro,
     22-Dec-2016.) */

theorem 2exeu (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! x ∃! y ph ) ;;
}

proof of 2exeu {
	step 1 : wff = eumo () |- ( ∃! x ∃ y ph → ∃* x ∃ y ph ) ;;
	step 2 : wff = euex () |- ( ∃! y ph → ∃ y ph ) ;;
	step 3 : wff = moimi (step 2) |- ( ∃* x ∃ y ph → ∃* x ∃! y ph ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( ∃! x ∃ y ph → ∃* x ∃! y ph ) ;;
	step 5 : wff = 2euex () |- ( ∃! y ∃ x ph → ∃ x ∃! y ph ) ;;
	step 6 : wff = anim12ci (step 4, step 5) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ( ∃ x ∃! y ph ∧ ∃* x ∃! y ph ) ) ;;
	step 7 : wff = eu5 () |- ( ∃! x ∃! y ph ↔ ( ∃ x ∃! y ph ∧ ∃* x ∃! y ph ) ) ;;
	step 8 : wff = sylibr (step 6, step 7) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! x ∃! y ph ) ;;
	qed prop 1 = step 8 ;;
}

/*Two equivalent expressions for double "at most one."  (Contributed by
       NM, 2-Feb-2005.)  (Revised by Mario Carneiro, 17-Oct-2016.) */

theorem 2mo (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z w v u, z w v u ph) {
	prop 1 : wff = |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
}

proof of 2mo {
	var v : set, u : set;;
	step 1 : wff = equequ2 () |- ( v = z → ( x = v ↔ x = z ) ) ;;
	step 2 : wff = equequ2 () |- ( u = w → ( y = u ↔ y = w ) ) ;;
	step 3 : wff = bi2anan9 (step 1, step 2) |- ( ( v = z ∧ u = w ) → ( ( x = v ∧ y = u ) ↔ ( x = z ∧ y = w ) ) ) ;;
	step 4 : wff = imbi2d (step 3) |- ( ( v = z ∧ u = w ) → ( ( ph → ( x = v ∧ y = u ) ) ↔ ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 5 : wff = 2albidv (step 4) |- ( ( v = z ∧ u = w ) → ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ↔ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 6 : wff = cbvex2v (step 5) |- ( ∃ v ∃ u ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ↔ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 7 : wff = nfv () |- F/ z ( ph → ( x = v ∧ y = u ) ) ;;
	step 8 : wff = nfv () |- F/ w ( ph → ( x = v ∧ y = u ) ) ;;
	step 9 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 10 : wff = nfv () |- F/ x ( z = v ∧ w = u ) ;;
	step 11 : wff = nfim (step 9, step 10) |- F/ x ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 12 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 13 : wff = nfsb (step 12) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 14 : wff = nfv () |- F/ y ( z = v ∧ w = u ) ;;
	step 15 : wff = nfim (step 13, step 14) |- F/ y ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 16 : wff = sbequ12 () |- ( y = w → ( ph ↔ [ w / y ] ph ) ) ;;
	step 17 : wff = sbequ12 () |- ( x = z → ( [ w / y ] ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 18 : wff = sylan9bbr (step 16, step 17) |- ( ( x = z ∧ y = w ) → ( ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 19 : wff = equequ1 () |- ( x = z → ( x = v ↔ z = v ) ) ;;
	step 20 : wff = equequ1 () |- ( y = w → ( y = u ↔ w = u ) ) ;;
	step 21 : wff = bi2anan9 (step 19, step 20) |- ( ( x = z ∧ y = w ) → ( ( x = v ∧ y = u ) ↔ ( z = v ∧ w = u ) ) ) ;;
	step 22 : wff = imbi12d (step 18, step 21) |- ( ( x = z ∧ y = w ) → ( ( ph → ( x = v ∧ y = u ) ) ↔ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 23 : wff = cbval2 (step 7, step 8, step 11, step 15, step 22) |- ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ↔ ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ;;
	step 24 : wff = biimpi (step 23) |- ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) → ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ;;
	step 25 : wff = ancli (step 24) |- ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) → ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 26 : wff = alcom () |- ( ∀ y ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ∀ z ∀ y ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 27 : wff = nfv () |- F/ w ( ph → ( x = v ∧ y = u ) ) ;;
	step 28 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 29 : wff = nfsb (step 28) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 30 : wff = nfv () |- F/ y ( z = v ∧ w = u ) ;;
	step 31 : wff = nfim (step 29, step 30) |- F/ y ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 32 : wff = aaan (step 27, step 31) |- ( ∀ y ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ( ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 33 : wff = albii (step 32) |- ( ∀ z ∀ y ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ∀ z ( ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 34 : wff = bitri (step 26, step 33) |- ( ∀ y ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ∀ z ( ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 35 : wff = albii (step 34) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ∀ x ∀ z ( ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 36 : wff = nfv () |- F/ z ∀ y ( ph → ( x = v ∧ y = u ) ) ;;
	step 37 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 38 : wff = nfv () |- F/ x ( z = v ∧ w = u ) ;;
	step 39 : wff = nfim (step 37, step 38) |- F/ x ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 40 : wff = nfal (step 39) |- F/ x ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 41 : wff = aaan (step 36, step 40) |- ( ∀ x ∀ z ( ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 42 : wff = bitri (step 35, step 41) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ↔ ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ∧ ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 43 : wff = sylibr (step 25, step 42) |- ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) → ∀ x ∀ y ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 44 : wff = prth () |- ( ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) → ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( ( x = v ∧ y = u ) ∧ ( z = v ∧ w = u ) ) ) ) ;;
	step 45 : wff = equtr2 () |- ( ( x = v ∧ z = v ) → x = z ) ;;
	step 46 : wff = equtr2 () |- ( ( y = u ∧ w = u ) → y = w ) ;;
	step 47 : wff = anim12i (step 45, step 46) |- ( ( ( x = v ∧ z = v ) ∧ ( y = u ∧ w = u ) ) → ( x = z ∧ y = w ) ) ;;
	step 48 : wff = an4s (step 47) |- ( ( ( x = v ∧ y = u ) ∧ ( z = v ∧ w = u ) ) → ( x = z ∧ y = w ) ) ;;
	step 49 : wff = syl6 (step 44, step 48) |- ( ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) → ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 50 : wff = 2alimi (step 49) |- ( ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) → ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 51 : wff = 2alimi (step 50) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph → ( x = v ∧ y = u ) ) ∧ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) → ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 52 : wff = syl (step 43, step 51) |- ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) → ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 53 : wff = exlimivv (step 52) |- ( ∃ v ∃ u ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) → ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 54 : wff = sylbir (step 6, step 53) |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) → ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 55 : wff = alrot4 () |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ↔ ∀ z ∀ w ∀ x ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 56 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 57 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 58 : wff = nfsb (step 57) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 59 : wff = pm3.21 () |- ( [ z / x ] [ w / y ] ph → ( ph → ( ph ∧ [ z / x ] [ w / y ] ph ) ) ) ;;
	step 60 : wff = imim1d (step 59) |- ( [ z / x ] [ w / y ] ph → ( ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 61 : wff = alimd (step 58, step 60) |- ( [ z / x ] [ w / y ] ph → ( ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 62 : wff = alimd (step 56, step 61) |- ( [ z / x ] [ w / y ] ph → ( ∀ x ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 63 : wff = com12 (step 62) |- ( ∀ x ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 64 : wff = alimi (step 63) |- ( ∀ w ∀ x ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ∀ w ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 65 : wff = exim () |- ( ∀ w ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) → ( ∃ w [ z / x ] [ w / y ] ph → ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 66 : wff = syl (step 64, step 65) |- ( ∀ w ∀ x ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ( ∃ w [ z / x ] [ w / y ] ph → ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 67 : wff = alimi (step 66) |- ( ∀ z ∀ w ∀ x ∀ y ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ∀ z ( ∃ w [ z / x ] [ w / y ] ph → ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 68 : wff = sylbi (step 55, step 67) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ∀ z ( ∃ w [ z / x ] [ w / y ] ph → ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 69 : wff = exim () |- ( ∀ z ( ∃ w [ z / x ] [ w / y ] ph → ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) → ( ∃ z ∃ w [ z / x ] [ w / y ] ph → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 70 : wff = syl (step 68, step 69) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ( ∃ z ∃ w [ z / x ] [ w / y ] ph → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 71 : wff = alnex () |- ( ∀ w ¬ [ z / x ] [ w / y ] ph ↔ ¬ ∃ w [ z / x ] [ w / y ] ph ) ;;
	step 72 : wff = albii (step 71) |- ( ∀ z ∀ w ¬ [ z / x ] [ w / y ] ph ↔ ∀ z ¬ ∃ w [ z / x ] [ w / y ] ph ) ;;
	step 73 : wff = alnex () |- ( ∀ z ¬ ∃ w [ z / x ] [ w / y ] ph ↔ ¬ ∃ z ∃ w [ z / x ] [ w / y ] ph ) ;;
	step 74 : wff = bitri (step 72, step 73) |- ( ∀ z ∀ w ¬ [ z / x ] [ w / y ] ph ↔ ¬ ∃ z ∃ w [ z / x ] [ w / y ] ph ) ;;
	step 75 : wff = nfv () |- F/ z ¬ ph ;;
	step 76 : wff = nfv () |- F/ w ¬ ph ;;
	step 77 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 78 : wff = nfn (step 77) |- F/ x ¬ [ z / x ] [ w / y ] ph ;;
	step 79 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 80 : wff = nfsb (step 79) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 81 : wff = nfn (step 80) |- F/ y ¬ [ z / x ] [ w / y ] ph ;;
	step 82 : wff = sbequ12 () |- ( y = w → ( ph ↔ [ w / y ] ph ) ) ;;
	step 83 : wff = sbequ12 () |- ( x = z → ( [ w / y ] ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 84 : wff = sylan9bbr (step 82, step 83) |- ( ( x = z ∧ y = w ) → ( ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 85 : wff = notbid (step 84) |- ( ( x = z ∧ y = w ) → ( ¬ ph ↔ ¬ [ z / x ] [ w / y ] ph ) ) ;;
	step 86 : wff = cbval2 (step 75, step 76, step 78, step 81, step 85) |- ( ∀ x ∀ y ¬ ph ↔ ∀ z ∀ w ¬ [ z / x ] [ w / y ] ph ) ;;
	step 87 : wff = pm2.21 () |- ( ¬ ph → ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 88 : wff = 2alimi (step 87) |- ( ∀ x ∀ y ¬ ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 89 : wff = sylbir (step 86, step 88) |- ( ∀ z ∀ w ¬ [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 90 : wff = 19.8a () |- ( ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 91 : wff = 19.23bi (step 90) |- ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 92 : wff = syl (step 89, step 91) |- ( ∀ z ∀ w ¬ [ z / x ] [ w / y ] ph → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 93 : wff = sylbir (step 74, step 92) |- ( ¬ ∃ z ∃ w [ z / x ] [ w / y ] ph → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 94 : wff = pm2.61d1 (step 70, step 93) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 95 : wff = impbii (step 54, step 94) |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	qed prop 1 = step 95 ;;
}

/*Double "exists at most one", using implicit substitution.  (Contributed
       by NM, 10-Feb-2005.) */

theorem 2mos (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(z w ph, x y ps, x y z w) {
	hyp 1 : wff = |- ( ( x = z ∧ y = w ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ ps ) → ( x = z ∧ y = w ) ) ) ;;
}

proof of 2mos {
	step 1 : wff = 2mo () |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = nfv () |- F/ y x = z ;;
	step 4 : wff = sbrim (step 3) |- ( [ w / y ] ( x = z → ph ) ↔ ( x = z → [ w / y ] ph ) ) ;;
	step 5 : wff = nfv () |- F/ y ( x = z → ps ) ;;
	step 6 : wff = expcom (hyp 1) |- ( y = w → ( x = z → ( ph ↔ ps ) ) ) ;;
	step 7 : wff = pm5.74d (step 6) |- ( y = w → ( ( x = z → ph ) ↔ ( x = z → ps ) ) ) ;;
	step 8 : wff = sbie (step 5, step 7) |- ( [ w / y ] ( x = z → ph ) ↔ ( x = z → ps ) ) ;;
	step 9 : wff = bitr3i (step 4, step 8) |- ( ( x = z → [ w / y ] ph ) ↔ ( x = z → ps ) ) ;;
	step 10 : wff = pm5.74ri (step 9) |- ( x = z → ( [ w / y ] ph ↔ ps ) ) ;;
	step 11 : wff = sbie (step 2, step 10) |- ( [ z / x ] [ w / y ] ph ↔ ps ) ;;
	step 12 : wff = anbi2i (step 11) |- ( ( ph ∧ [ z / x ] [ w / y ] ph ) ↔ ( ph ∧ ps ) ) ;;
	step 13 : wff = imbi1i (step 12) |- ( ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ↔ ( ( ph ∧ ps ) → ( x = z ∧ y = w ) ) ) ;;
	step 14 : wff = 2albii (step 13) |- ( ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ↔ ∀ z ∀ w ( ( ph ∧ ps ) → ( x = z ∧ y = w ) ) ) ;;
	step 15 : wff = 2albii (step 14) |- ( ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ [ z / x ] [ w / y ] ph ) → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ ps ) → ( x = z ∧ y = w ) ) ) ;;
	step 16 : wff = bitri (step 1, step 15) |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ∀ z ∀ w ( ( ph ∧ ps ) → ( x = z ∧ y = w ) ) ) ;;
	qed prop 1 = step 16 ;;
}

/*Double existential uniqueness.  This theorem shows a condition under which
     a "naive" definition matches the correct one.  (Contributed by NM,
     3-Dec-2001.) */

theorem 2eu1 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
}

proof of 2eu1 {
	step 1 : wff = eu5 () |- ( ∃! x ∃! y ph ↔ ( ∃ x ∃! y ph ∧ ∃* x ∃! y ph ) ) ;;
	step 2 : wff = eu5 () |- ( ∃! y ph ↔ ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x ∃! y ph ↔ ∃ x ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 4 : wff = eu5 () |- ( ∃! y ph ↔ ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 5 : wff = mobii (step 4) |- ( ∃* x ∃! y ph ↔ ∃* x ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 6 : wff = anbi12i (step 3, step 5) |- ( ( ∃ x ∃! y ph ∧ ∃* x ∃! y ph ) ↔ ( ∃ x ( ∃ y ph ∧ ∃* y ph ) ∧ ∃* x ( ∃ y ph ∧ ∃* y ph ) ) ) ;;
	step 7 : wff = bitri (step 1, step 6) |- ( ∃! x ∃! y ph ↔ ( ∃ x ( ∃ y ph ∧ ∃* y ph ) ∧ ∃* x ( ∃ y ph ∧ ∃* y ph ) ) ) ;;
	step 8 : wff = simprbi (step 7) |- ( ∃! x ∃! y ph → ∃* x ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 9 : wff = sp () |- ( ∀ x ∃* y ph → ∃* y ph ) ;;
	step 10 : wff = anim2i (step 9) |- ( ( ∃ y ph ∧ ∀ x ∃* y ph ) → ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 11 : wff = ancoms (step 10) |- ( ( ∀ x ∃* y ph ∧ ∃ y ph ) → ( ∃ y ph ∧ ∃* y ph ) ) ;;
	step 12 : wff = moimi (step 11) |- ( ∃* x ( ∃ y ph ∧ ∃* y ph ) → ∃* x ( ∀ x ∃* y ph ∧ ∃ y ph ) ) ;;
	step 13 : wff = nfa1 () |- F/ x ∀ x ∃* y ph ;;
	step 14 : wff = moanim (step 13) |- ( ∃* x ( ∀ x ∃* y ph ∧ ∃ y ph ) ↔ ( ∀ x ∃* y ph → ∃* x ∃ y ph ) ) ;;
	step 15 : wff = sylib (step 12, step 14) |- ( ∃* x ( ∃ y ph ∧ ∃* y ph ) → ( ∀ x ∃* y ph → ∃* x ∃ y ph ) ) ;;
	step 16 : wff = ancrd (step 15) |- ( ∃* x ( ∃ y ph ∧ ∃* y ph ) → ( ∀ x ∃* y ph → ( ∃* x ∃ y ph ∧ ∀ x ∃* y ph ) ) ) ;;
	step 17 : wff = 2moswap () |- ( ∀ x ∃* y ph → ( ∃* x ∃ y ph → ∃* y ∃ x ph ) ) ;;
	step 18 : wff = com12 (step 17) |- ( ∃* x ∃ y ph → ( ∀ x ∃* y ph → ∃* y ∃ x ph ) ) ;;
	step 19 : wff = imdistani (step 18) |- ( ( ∃* x ∃ y ph ∧ ∀ x ∃* y ph ) → ( ∃* x ∃ y ph ∧ ∃* y ∃ x ph ) ) ;;
	step 20 : wff = syl6 (step 16, step 19) |- ( ∃* x ( ∃ y ph ∧ ∃* y ph ) → ( ∀ x ∃* y ph → ( ∃* x ∃ y ph ∧ ∃* y ∃ x ph ) ) ) ;;
	step 21 : wff = syl (step 8, step 20) |- ( ∃! x ∃! y ph → ( ∀ x ∃* y ph → ( ∃* x ∃ y ph ∧ ∃* y ∃ x ph ) ) ) ;;
	step 22 : wff = 2eu2ex () |- ( ∃! x ∃! y ph → ∃ x ∃ y ph ) ;;
	step 23 : wff = 2eu2ex () |- ( ∃! x ∃! y ph → ∃ x ∃ y ph ) ;;
	step 24 : wff = excom () |- ( ∃ x ∃ y ph ↔ ∃ y ∃ x ph ) ;;
	step 25 : wff = sylib (step 23, step 24) |- ( ∃! x ∃! y ph → ∃ y ∃ x ph ) ;;
	step 26 : wff = jca (step 22, step 25) |- ( ∃! x ∃! y ph → ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ) ;;
	step 27 : wff = jctild (step 21, step 26) |- ( ∃! x ∃! y ph → ( ∀ x ∃* y ph → ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ∧ ( ∃* x ∃ y ph ∧ ∃* y ∃ x ph ) ) ) ) ;;
	step 28 : wff = eu5 () |- ( ∃! x ∃ y ph ↔ ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) ) ;;
	step 29 : wff = eu5 () |- ( ∃! y ∃ x ph ↔ ( ∃ y ∃ x ph ∧ ∃* y ∃ x ph ) ) ;;
	step 30 : wff = anbi12i (step 28, step 29) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) ∧ ( ∃ y ∃ x ph ∧ ∃* y ∃ x ph ) ) ) ;;
	step 31 : wff = an4 () |- ( ( ( ∃ x ∃ y ph ∧ ∃* x ∃ y ph ) ∧ ( ∃ y ∃ x ph ∧ ∃* y ∃ x ph ) ) ↔ ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ∧ ( ∃* x ∃ y ph ∧ ∃* y ∃ x ph ) ) ) ;;
	step 32 : wff = bitri (step 30, step 31) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ∧ ( ∃* x ∃ y ph ∧ ∃* y ∃ x ph ) ) ) ;;
	step 33 : wff = syl6ibr (step 27, step 32) |- ( ∃! x ∃! y ph → ( ∀ x ∃* y ph → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 34 : wff = com12 (step 33) |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 35 : wff = 2exeu () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! x ∃! y ph ) ;;
	step 36 : wff = impbid1 (step 34, step 35) |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	qed prop 1 = step 36 ;;
}

/*Double existential uniqueness.  (Contributed by NM, 3-Dec-2001.) */

theorem 2eu2 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∃! y ∃ x ph → ( ∃! x ∃! y ph ↔ ∃! x ∃ y ph ) ) ;;
}

proof of 2eu2 {
	step 1 : wff = eumo () |- ( ∃! y ∃ x ph → ∃* y ∃ x ph ) ;;
	step 2 : wff = 2moex () |- ( ∃* y ∃ x ph → ∀ x ∃* y ph ) ;;
	step 3 : wff = 2eu1 () |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 4 : wff = simpl () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! x ∃ y ph ) ;;
	step 5 : wff = syl6bi (step 3, step 4) |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph → ∃! x ∃ y ph ) ) ;;
	step 6 : wff = 3syl (step 1, step 2, step 5) |- ( ∃! y ∃ x ph → ( ∃! x ∃! y ph → ∃! x ∃ y ph ) ) ;;
	step 7 : wff = 2exeu () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! x ∃! y ph ) ;;
	step 8 : wff = expcom (step 7) |- ( ∃! y ∃ x ph → ( ∃! x ∃ y ph → ∃! x ∃! y ph ) ) ;;
	step 9 : wff = impbid (step 6, step 8) |- ( ∃! y ∃ x ph → ( ∃! x ∃! y ph ↔ ∃! x ∃ y ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Double existential uniqueness.  (Contributed by NM, 3-Dec-2001.) */

theorem 2eu3 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ∀ y ( ∃* x ph ∨ ∃* y ph ) → ( ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
}

proof of 2eu3 {
	step 1 : wff = nfmo1 () |- F/ y ∃* y ph ;;
	step 2 : wff = 19.31 (step 1) |- ( ∀ y ( ∃* x ph ∨ ∃* y ph ) ↔ ( ∀ y ∃* x ph ∨ ∃* y ph ) ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ x ∀ y ( ∃* x ph ∨ ∃* y ph ) ↔ ∀ x ( ∀ y ∃* x ph ∨ ∃* y ph ) ) ;;
	step 4 : wff = nfmo1 () |- F/ x ∃* x ph ;;
	step 5 : wff = nfal (step 4) |- F/ x ∀ y ∃* x ph ;;
	step 6 : wff = 19.32 (step 5) |- ( ∀ x ( ∀ y ∃* x ph ∨ ∃* y ph ) ↔ ( ∀ y ∃* x ph ∨ ∀ x ∃* y ph ) ) ;;
	step 7 : wff = bitri (step 3, step 6) |- ( ∀ x ∀ y ( ∃* x ph ∨ ∃* y ph ) ↔ ( ∀ y ∃* x ph ∨ ∀ x ∃* y ph ) ) ;;
	step 8 : wff = 2eu1 () |- ( ∀ y ∃* x ph → ( ∃! y ∃! x ph ↔ ( ∃! y ∃ x ph ∧ ∃! x ∃ y ph ) ) ) ;;
	step 9 : wff = biimpd (step 8) |- ( ∀ y ∃* x ph → ( ∃! y ∃! x ph → ( ∃! y ∃ x ph ∧ ∃! x ∃ y ph ) ) ) ;;
	step 10 : wff = ancom () |- ( ( ∃! y ∃ x ph ∧ ∃! x ∃ y ph ) ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ;;
	step 11 : wff = syl6ib (step 9, step 10) |- ( ∀ y ∃* x ph → ( ∃! y ∃! x ph → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 12 : wff = adantld (step 11) |- ( ∀ y ∃* x ph → ( ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 13 : wff = 2eu1 () |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 14 : wff = biimpd (step 13) |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 15 : wff = adantrd (step 14) |- ( ∀ x ∃* y ph → ( ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 16 : wff = jaoi (step 12, step 15) |- ( ( ∀ y ∃* x ph ∨ ∀ x ∃* y ph ) → ( ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) → ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 17 : wff = 2exeu () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! x ∃! y ph ) ;;
	step 18 : wff = 2exeu () |- ( ( ∃! y ∃ x ph ∧ ∃! x ∃ y ph ) → ∃! y ∃! x ph ) ;;
	step 19 : wff = ancoms (step 18) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃! y ∃! x ph ) ;;
	step 20 : wff = jca (step 17, step 19) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) ) ;;
	step 21 : wff = impbid1 (step 16, step 20) |- ( ( ∀ y ∃* x ph ∨ ∀ x ∃* y ph ) → ( ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 22 : wff = sylbi (step 7, step 21) |- ( ∀ x ∀ y ( ∃* x ph ∨ ∃* y ph ) → ( ( ∃! x ∃! y ph ∧ ∃! y ∃! x ph ) ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	qed prop 1 = step 22 ;;
}

/*This theorem provides us with a definition of double existential
       uniqueness ("exactly one ` x ` and exactly one ` y ` ").  Naively one
       might think (incorrectly) that it could be defined by
       ` E! x E! y ph ` .  See ~ 2eu1 for a condition under which the naive
       definition holds and ~ 2exeu for a one-way implication.  See ~ 2eu5 and
       ~ 2eu8 for alternate definitions.  (Contributed by NM, 3-Dec-2001.) */

theorem 2eu4 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z w, z w ph) {
	prop 1 : wff = |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
}

proof of 2eu4 {
	step 1 : wff = nfv () |- F/ z ∃ y ph ;;
	step 2 : wff = eu3 (step 1) |- ( ∃! x ∃ y ph ↔ ( ∃ x ∃ y ph ∧ ∃ z ∀ x ( ∃ y ph → x = z ) ) ) ;;
	step 3 : wff = nfv () |- F/ w ∃ x ph ;;
	step 4 : wff = eu3 (step 3) |- ( ∃! y ∃ x ph ↔ ( ∃ y ∃ x ph ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ) ;;
	step 5 : wff = anbi12i (step 2, step 4) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ( ∃ x ∃ y ph ∧ ∃ z ∀ x ( ∃ y ph → x = z ) ) ∧ ( ∃ y ∃ x ph ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ) ) ;;
	step 6 : wff = an4 () |- ( ( ( ∃ x ∃ y ph ∧ ∃ z ∀ x ( ∃ y ph → x = z ) ) ∧ ( ∃ y ∃ x ph ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ) ↔ ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ∧ ( ∃ z ∀ x ( ∃ y ph → x = z ) ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ) ) ;;
	step 7 : wff = excom () |- ( ∃ y ∃ x ph ↔ ∃ x ∃ y ph ) ;;
	step 8 : wff = anbi2i (step 7) |- ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ x ∃ y ph ) ) ;;
	step 9 : wff = anidm () |- ( ( ∃ x ∃ y ph ∧ ∃ x ∃ y ph ) ↔ ∃ x ∃ y ph ) ;;
	step 10 : wff = bitri (step 8, step 9) |- ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ↔ ∃ x ∃ y ph ) ;;
	step 11 : wff = 19.26 () |- ( ∀ x ( ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ↔ ( ∀ x ∀ y ( ph → x = z ) ∧ ∀ x ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 12 : wff = nfa1 () |- F/ x ∀ x ∀ y ( ph → y = w ) ;;
	step 13 : wff = 19.3 (step 12) |- ( ∀ x ∀ x ∀ y ( ph → y = w ) ↔ ∀ x ∀ y ( ph → y = w ) ) ;;
	step 14 : wff = anbi2i (step 13) |- ( ( ∀ x ∀ y ( ph → x = z ) ∧ ∀ x ∀ x ∀ y ( ph → y = w ) ) ↔ ( ∀ x ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 15 : wff = jcab () |- ( ( ph → ( x = z ∧ y = w ) ) ↔ ( ( ph → x = z ) ∧ ( ph → y = w ) ) ) ;;
	step 16 : wff = albii (step 15) |- ( ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ y ( ( ph → x = z ) ∧ ( ph → y = w ) ) ) ;;
	step 17 : wff = 19.26 () |- ( ∀ y ( ( ph → x = z ) ∧ ( ph → y = w ) ) ↔ ( ∀ y ( ph → x = z ) ∧ ∀ y ( ph → y = w ) ) ) ;;
	step 18 : wff = bitri (step 16, step 17) |- ( ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ( ∀ y ( ph → x = z ) ∧ ∀ y ( ph → y = w ) ) ) ;;
	step 19 : wff = albii (step 18) |- ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ( ∀ y ( ph → x = z ) ∧ ∀ y ( ph → y = w ) ) ) ;;
	step 20 : wff = 19.26 () |- ( ∀ x ( ∀ y ( ph → x = z ) ∧ ∀ y ( ph → y = w ) ) ↔ ( ∀ x ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 21 : wff = bitri (step 19, step 20) |- ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ( ∀ x ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 22 : wff = bitr4i (step 14, step 21) |- ( ( ∀ x ∀ y ( ph → x = z ) ∧ ∀ x ∀ x ∀ y ( ph → y = w ) ) ↔ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 23 : wff = bitr2i (step 11, step 22) |- ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ( ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 24 : wff = 19.26 () |- ( ∀ y ( ∀ y ( ph → x = z ) ∧ ∀ x ( ph → y = w ) ) ↔ ( ∀ y ∀ y ( ph → x = z ) ∧ ∀ y ∀ x ( ph → y = w ) ) ) ;;
	step 25 : wff = nfa1 () |- F/ y ∀ y ( ph → x = z ) ;;
	step 26 : wff = 19.3 (step 25) |- ( ∀ y ∀ y ( ph → x = z ) ↔ ∀ y ( ph → x = z ) ) ;;
	step 27 : wff = alcom () |- ( ∀ y ∀ x ( ph → y = w ) ↔ ∀ x ∀ y ( ph → y = w ) ) ;;
	step 28 : wff = anbi12i (step 26, step 27) |- ( ( ∀ y ∀ y ( ph → x = z ) ∧ ∀ y ∀ x ( ph → y = w ) ) ↔ ( ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 29 : wff = bitri (step 24, step 28) |- ( ∀ y ( ∀ y ( ph → x = z ) ∧ ∀ x ( ph → y = w ) ) ↔ ( ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 30 : wff = albii (step 29) |- ( ∀ x ∀ y ( ∀ y ( ph → x = z ) ∧ ∀ x ( ph → y = w ) ) ↔ ∀ x ( ∀ y ( ph → x = z ) ∧ ∀ x ∀ y ( ph → y = w ) ) ) ;;
	step 31 : wff = bitr4i (step 23, step 30) |- ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ( ∀ y ( ph → x = z ) ∧ ∀ x ( ph → y = w ) ) ) ;;
	step 32 : wff = 19.23v () |- ( ∀ y ( ph → x = z ) ↔ ( ∃ y ph → x = z ) ) ;;
	step 33 : wff = 19.23v () |- ( ∀ x ( ph → y = w ) ↔ ( ∃ x ph → y = w ) ) ;;
	step 34 : wff = anbi12i (step 32, step 33) |- ( ( ∀ y ( ph → x = z ) ∧ ∀ x ( ph → y = w ) ) ↔ ( ( ∃ y ph → x = z ) ∧ ( ∃ x ph → y = w ) ) ) ;;
	step 35 : wff = 2albii (step 34) |- ( ∀ x ∀ y ( ∀ y ( ph → x = z ) ∧ ∀ x ( ph → y = w ) ) ↔ ∀ x ∀ y ( ( ∃ y ph → x = z ) ∧ ( ∃ x ph → y = w ) ) ) ;;
	step 36 : wff = nfe1 () |- F/ y ∃ y ph ;;
	step 37 : wff = nfv () |- F/ y x = z ;;
	step 38 : wff = nfim (step 36, step 37) |- F/ y ( ∃ y ph → x = z ) ;;
	step 39 : wff = nfe1 () |- F/ x ∃ x ph ;;
	step 40 : wff = nfv () |- F/ x y = w ;;
	step 41 : wff = nfim (step 39, step 40) |- F/ x ( ∃ x ph → y = w ) ;;
	step 42 : wff = aaan (step 38, step 41) |- ( ∀ x ∀ y ( ( ∃ y ph → x = z ) ∧ ( ∃ x ph → y = w ) ) ↔ ( ∀ x ( ∃ y ph → x = z ) ∧ ∀ y ( ∃ x ph → y = w ) ) ) ;;
	step 43 : wff = 3bitri (step 31, step 35, step 42) |- ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ( ∀ x ( ∃ y ph → x = z ) ∧ ∀ y ( ∃ x ph → y = w ) ) ) ;;
	step 44 : wff = 2exbii (step 43) |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∃ z ∃ w ( ∀ x ( ∃ y ph → x = z ) ∧ ∀ y ( ∃ x ph → y = w ) ) ) ;;
	step 45 : wff = eeanv () |- ( ∃ z ∃ w ( ∀ x ( ∃ y ph → x = z ) ∧ ∀ y ( ∃ x ph → y = w ) ) ↔ ( ∃ z ∀ x ( ∃ y ph → x = z ) ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ) ;;
	step 46 : wff = bitr2i (step 44, step 45) |- ( ( ∃ z ∀ x ( ∃ y ph → x = z ) ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ↔ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 47 : wff = anbi12i (step 10, step 46) |- ( ( ( ∃ x ∃ y ph ∧ ∃ y ∃ x ph ) ∧ ( ∃ z ∀ x ( ∃ y ph → x = z ) ∧ ∃ w ∀ y ( ∃ x ph → y = w ) ) ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 48 : wff = 3bitri (step 5, step 6, step 47) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	qed prop 1 = step 48 ;;
}

/*An alternate definition of double existential uniqueness (see ~ 2eu4 ).
       A mistake sometimes made in the literature is to use ` E! x E! y ` to
       mean "exactly one ` x ` and exactly one ` y ` ."  (For example, see
       Proposition 7.53 of [TakeutiZaring] p. 53.)  It turns out that this is
       actually a weaker assertion, as can be seen by expanding out the formal
       definitions.  This theorem shows that the erroneous definition can be
       repaired by conjoining ` A. x E* y ph ` as an additional condition.  The
       correct definition apparently has never been published.  ( ` E* ` means
       "exists at most one.") (Contributed by NM, 26-Oct-2003.) */

theorem 2eu5 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z w, z w ph) {
	prop 1 : wff = |- ( ( ∃! x ∃! y ph ∧ ∀ x ∃* y ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
}

proof of 2eu5 {
	step 1 : wff = 2eu1 () |- ( ∀ x ∃* y ph → ( ∃! x ∃! y ph ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ) ;;
	step 2 : wff = pm5.32ri (step 1) |- ( ( ∃! x ∃! y ph ∧ ∀ x ∃* y ph ) ↔ ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ∧ ∀ x ∃* y ph ) ) ;;
	step 3 : wff = eumo () |- ( ∃! y ∃ x ph → ∃* y ∃ x ph ) ;;
	step 4 : wff = adantl (step 3) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∃* y ∃ x ph ) ;;
	step 5 : wff = 2moex () |- ( ∃* y ∃ x ph → ∀ x ∃* y ph ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) → ∀ x ∃* y ph ) ;;
	step 7 : wff = pm4.71i (step 6) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ∧ ∀ x ∃* y ph ) ) ;;
	step 8 : wff = 2eu4 () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 9 : wff = 3bitr2i (step 2, step 7, step 8) |- ( ( ∃! x ∃! y ph ∧ ∀ x ∃* y ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	qed prop 1 = step 9 ;;
}

/*Two equivalent expressions for double existential uniqueness.
       (Contributed by NM, 2-Feb-2005.)  (Revised by Mario Carneiro,
       17-Oct-2016.) */

theorem 2eu6 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z w v u, z w v u ph) {
	prop 1 : wff = |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ) ;;
}

proof of 2eu6 {
	var v : set, u : set;;
	step 1 : wff = 2eu4 () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 2 : wff = nfv () |- F/ z ph ;;
	step 3 : wff = nfv () |- F/ w ph ;;
	step 4 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 5 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 6 : wff = nfsb (step 5) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 7 : wff = sbequ12 () |- ( y = w → ( ph ↔ [ w / y ] ph ) ) ;;
	step 8 : wff = sbequ12 () |- ( x = z → ( [ w / y ] ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 9 : wff = sylan9bbr (step 7, step 8) |- ( ( x = z ∧ y = w ) → ( ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 10 : wff = cbvex2 (step 2, step 3, step 4, step 6, step 9) |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w [ z / x ] [ w / y ] ph ) ;;
	step 11 : wff = equequ2 () |- ( z = v → ( x = z ↔ x = v ) ) ;;
	step 12 : wff = equequ2 () |- ( w = u → ( y = w ↔ y = u ) ) ;;
	step 13 : wff = bi2anan9 (step 11, step 12) |- ( ( z = v ∧ w = u ) → ( ( x = z ∧ y = w ) ↔ ( x = v ∧ y = u ) ) ) ;;
	step 14 : wff = imbi2d (step 13) |- ( ( z = v ∧ w = u ) → ( ( ph → ( x = z ∧ y = w ) ) ↔ ( ph → ( x = v ∧ y = u ) ) ) ) ;;
	step 15 : wff = 2albidv (step 14) |- ( ( z = v ∧ w = u ) → ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ) ) ;;
	step 16 : wff = cbvex2v (step 15) |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∃ v ∃ u ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ) ;;
	step 17 : wff = nfv () |- F/ z ( ph → ( x = v ∧ y = u ) ) ;;
	step 18 : wff = nfv () |- F/ w ( ph → ( x = v ∧ y = u ) ) ;;
	step 19 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 20 : wff = nfv () |- F/ x ( z = v ∧ w = u ) ;;
	step 21 : wff = nfim (step 19, step 20) |- F/ x ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 22 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 23 : wff = nfsb (step 22) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 24 : wff = nfv () |- F/ y ( z = v ∧ w = u ) ;;
	step 25 : wff = nfim (step 23, step 24) |- F/ y ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ;;
	step 26 : wff = sbequ12 () |- ( y = w → ( ph ↔ [ w / y ] ph ) ) ;;
	step 27 : wff = sbequ12 () |- ( x = z → ( [ w / y ] ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 28 : wff = sylan9bbr (step 26, step 27) |- ( ( x = z ∧ y = w ) → ( ph ↔ [ z / x ] [ w / y ] ph ) ) ;;
	step 29 : wff = equequ1 () |- ( x = z → ( x = v ↔ z = v ) ) ;;
	step 30 : wff = equequ1 () |- ( y = w → ( y = u ↔ w = u ) ) ;;
	step 31 : wff = bi2anan9 (step 29, step 30) |- ( ( x = z ∧ y = w ) → ( ( x = v ∧ y = u ) ↔ ( z = v ∧ w = u ) ) ) ;;
	step 32 : wff = imbi12d (step 28, step 31) |- ( ( x = z ∧ y = w ) → ( ( ph → ( x = v ∧ y = u ) ) ↔ ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ) ;;
	step 33 : wff = cbval2 (step 17, step 18, step 21, step 25, step 32) |- ( ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ↔ ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ;;
	step 34 : wff = 2exbii (step 33) |- ( ∃ v ∃ u ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ↔ ∃ v ∃ u ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ) ;;
	step 35 : wff = 2mo () |- ( ∃ v ∃ u ∀ z ∀ w ( [ z / x ] [ w / y ] ph → ( z = v ∧ w = u ) ) ↔ ∀ z ∀ w ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ;;
	step 36 : wff = bitri (step 34, step 35) |- ( ∃ v ∃ u ∀ x ∀ y ( ph → ( x = v ∧ y = u ) ) ↔ ∀ z ∀ w ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ;;
	step 37 : wff = bitri (step 16, step 36) |- ( ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ↔ ∀ z ∀ w ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ;;
	step 38 : wff = 19.29r2 () |- ( ( ∃ z ∃ w [ z / x ] [ w / y ] ph ∧ ∀ z ∀ w ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) → ∃ z ∃ w ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ) ;;
	step 39 : wff = syl2anb (step 10, step 37, step 38) |- ( ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) → ∃ z ∃ w ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ) ;;
	step 40 : wff = 2albiim () |- ( ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ↔ ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ∧ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ) ;;
	step 41 : wff = ancom () |- ( ( ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ∧ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ↔ ( ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 42 : wff = bitri (step 40, step 41) |- ( ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ↔ ( ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 43 : wff = 2exbii (step 42) |- ( ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ↔ ∃ z ∃ w ( ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 44 : wff = nfv () |- F/ v ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ;;
	step 45 : wff = nfv () |- F/ u ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ;;
	step 46 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 47 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 48 : wff = nfsb (step 47) |- F/ x [ u / w ] [ z / x ] [ w / y ] ph ;;
	step 49 : wff = nfsb (step 48) |- F/ x [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ;;
	step 50 : wff = nfan (step 46, step 49) |- F/ x ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ;;
	step 51 : wff = nfv () |- F/ x ( z = v ∧ w = u ) ;;
	step 52 : wff = nfim (step 50, step 51) |- F/ x ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ;;
	step 53 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 54 : wff = nfsb (step 53) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 55 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 56 : wff = nfsb (step 55) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 57 : wff = nfsb (step 56) |- F/ y [ u / w ] [ z / x ] [ w / y ] ph ;;
	step 58 : wff = nfsb (step 57) |- F/ y [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ;;
	step 59 : wff = nfan (step 54, step 58) |- F/ y ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ;;
	step 60 : wff = nfv () |- F/ y ( z = v ∧ w = u ) ;;
	step 61 : wff = nfim (step 59, step 60) |- F/ y ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ;;
	step 62 : wff = sbequ12 () |- ( y = u → ( ph ↔ [ u / y ] ph ) ) ;;
	step 63 : wff = sbequ12 () |- ( x = v → ( [ u / y ] ph ↔ [ v / x ] [ u / y ] ph ) ) ;;
	step 64 : wff = sylan9bbr (step 62, step 63) |- ( ( x = v ∧ y = u ) → ( ph ↔ [ v / x ] [ u / y ] ph ) ) ;;
	step 65 : wff = nfv () |- F/ w ph ;;
	step 66 : wff = sbco2 (step 65) |- ( [ u / w ] [ w / y ] ph ↔ [ u / y ] ph ) ;;
	step 67 : wff = sbbii (step 66) |- ( [ v / x ] [ u / w ] [ w / y ] ph ↔ [ v / x ] [ u / y ] ph ) ;;
	step 68 : wff = nfv () |- F/ z [ u / w ] [ w / y ] ph ;;
	step 69 : wff = sbco2 (step 68) |- ( [ v / z ] [ z / x ] [ u / w ] [ w / y ] ph ↔ [ v / x ] [ u / w ] [ w / y ] ph ) ;;
	step 70 : wff = sbcom2 () |- ( [ z / x ] [ u / w ] [ w / y ] ph ↔ [ u / w ] [ z / x ] [ w / y ] ph ) ;;
	step 71 : wff = sbbii (step 70) |- ( [ v / z ] [ z / x ] [ u / w ] [ w / y ] ph ↔ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ;;
	step 72 : wff = bitr3i (step 69, step 71) |- ( [ v / x ] [ u / w ] [ w / y ] ph ↔ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ;;
	step 73 : wff = bitr3i (step 67, step 72) |- ( [ v / x ] [ u / y ] ph ↔ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ;;
	step 74 : wff = syl6bb (step 64, step 73) |- ( ( x = v ∧ y = u ) → ( ph ↔ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ) ;;
	step 75 : wff = anbi2d (step 74) |- ( ( x = v ∧ y = u ) → ( ( [ z / x ] [ w / y ] ph ∧ ph ) ↔ ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) ) ) ;;
	step 76 : wff = equequ2 () |- ( x = v → ( z = x ↔ z = v ) ) ;;
	step 77 : wff = equequ2 () |- ( y = u → ( w = y ↔ w = u ) ) ;;
	step 78 : wff = bi2anan9 (step 76, step 77) |- ( ( x = v ∧ y = u ) → ( ( z = x ∧ w = y ) ↔ ( z = v ∧ w = u ) ) ) ;;
	step 79 : wff = imbi12d (step 75, step 78) |- ( ( x = v ∧ y = u ) → ( ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ↔ ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ) ;;
	step 80 : wff = cbval2 (step 44, step 45, step 52, step 61, step 79) |- ( ∀ x ∀ y ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ↔ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ;;
	step 81 : wff = equcom () |- ( z = x ↔ x = z ) ;;
	step 82 : wff = equcom () |- ( w = y ↔ y = w ) ;;
	step 83 : wff = anbi12i (step 81, step 82) |- ( ( z = x ∧ w = y ) ↔ ( x = z ∧ y = w ) ) ;;
	step 84 : wff = imbi2i (step 83) |- ( ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ↔ ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( x = z ∧ y = w ) ) ) ;;
	step 85 : wff = impexp () |- ( ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( x = z ∧ y = w ) ) ↔ ( [ z / x ] [ w / y ] ph → ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 86 : wff = bitri (step 84, step 85) |- ( ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ↔ ( [ z / x ] [ w / y ] ph → ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 87 : wff = 2albii (step 86) |- ( ∀ x ∀ y ( ( [ z / x ] [ w / y ] ph ∧ ph ) → ( z = x ∧ w = y ) ) ↔ ∀ x ∀ y ( [ z / x ] [ w / y ] ph → ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 88 : wff = bitr3i (step 80, step 87) |- ( ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ↔ ∀ x ∀ y ( [ z / x ] [ w / y ] ph → ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 89 : wff = nfs1v () |- F/ x [ z / x ] [ w / y ] ph ;;
	step 90 : wff = nfs1v () |- F/ y [ w / y ] ph ;;
	step 91 : wff = nfsb (step 90) |- F/ y [ z / x ] [ w / y ] ph ;;
	step 92 : wff = 19.21-2 (step 89, step 91) |- ( ∀ x ∀ y ( [ z / x ] [ w / y ] ph → ( ph → ( x = z ∧ y = w ) ) ) ↔ ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 93 : wff = bitri (step 88, step 92) |- ( ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ↔ ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 94 : wff = anbi2i (step 93) |- ( ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ↔ ( [ z / x ] [ w / y ] ph ∧ ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 95 : wff = abai () |- ( ( [ z / x ] [ w / y ] ph ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ↔ ( [ z / x ] [ w / y ] ph ∧ ( [ z / x ] [ w / y ] ph → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ) ;;
	step 96 : wff = bitr4i (step 94, step 95) |- ( ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ↔ ( [ z / x ] [ w / y ] ph ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 97 : wff = 2sb6 () |- ( [ z / x ] [ w / y ] ph ↔ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 98 : wff = anbi1i (step 97) |- ( ( [ z / x ] [ w / y ] ph ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ↔ ( ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 99 : wff = bitri (step 96, step 98) |- ( ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ↔ ( ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 100 : wff = 2exbii (step 99) |- ( ∃ z ∃ w ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ↔ ∃ z ∃ w ( ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ∧ ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 101 : wff = bitr4i (step 43, step 100) |- ( ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ↔ ∃ z ∃ w ( [ z / x ] [ w / y ] ph ∧ ∀ v ∀ u ( ( [ z / x ] [ w / y ] ph ∧ [ v / z ] [ u / w ] [ z / x ] [ w / y ] ph ) → ( z = v ∧ w = u ) ) ) ) ;;
	step 102 : wff = sylibr (step 39, step 101) |- ( ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) → ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ) ;;
	step 103 : wff = bi2 () |- ( ( ph ↔ ( x = z ∧ y = w ) ) → ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 104 : wff = 2alimi (step 103) |- ( ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) → ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 105 : wff = 2eximi (step 104) |- ( ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) → ∃ z ∃ w ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 106 : wff = 2exsb () |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 107 : wff = sylibr (step 105, step 106) |- ( ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) → ∃ x ∃ y ph ) ;;
	step 108 : wff = bi1 () |- ( ( ph ↔ ( x = z ∧ y = w ) ) → ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 109 : wff = 2alimi (step 108) |- ( ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) → ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 110 : wff = 2eximi (step 109) |- ( ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) → ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ;;
	step 111 : wff = jca (step 107, step 110) |- ( ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) → ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ) ;;
	step 112 : wff = impbii (step 102, step 111) |- ( ( ∃ x ∃ y ph ∧ ∃ z ∃ w ∀ x ∀ y ( ph → ( x = z ∧ y = w ) ) ) ↔ ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ) ;;
	step 113 : wff = bitri (step 1, step 112) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ∃ z ∃ w ∀ x ∀ y ( ph ↔ ( x = z ∧ y = w ) ) ) ;;
	qed prop 1 = step 113 ;;
}

/*Two equivalent expressions for double existential uniqueness.
     (Contributed by NM, 19-Feb-2005.) */

theorem 2eu7 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ∃! x ∃! y ( ∃ x ph ∧ ∃ y ph ) ) ;;
}

proof of 2eu7 {
	step 1 : wff = nfe1 () |- F/ x ∃ x ph ;;
	step 2 : wff = nfeu (step 1) |- F/ x ∃! y ∃ x ph ;;
	step 3 : wff = euan (step 2) |- ( ∃! x ( ∃! y ∃ x ph ∧ ∃ y ph ) ↔ ( ∃! y ∃ x ph ∧ ∃! x ∃ y ph ) ) ;;
	step 4 : wff = ancom () |- ( ( ∃ x ph ∧ ∃ y ph ) ↔ ( ∃ y ph ∧ ∃ x ph ) ) ;;
	step 5 : wff = eubii (step 4) |- ( ∃! y ( ∃ x ph ∧ ∃ y ph ) ↔ ∃! y ( ∃ y ph ∧ ∃ x ph ) ) ;;
	step 6 : wff = nfe1 () |- F/ y ∃ y ph ;;
	step 7 : wff = euan (step 6) |- ( ∃! y ( ∃ y ph ∧ ∃ x ph ) ↔ ( ∃ y ph ∧ ∃! y ∃ x ph ) ) ;;
	step 8 : wff = ancom () |- ( ( ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ∃! y ∃ x ph ∧ ∃ y ph ) ) ;;
	step 9 : wff = 3bitri (step 5, step 7, step 8) |- ( ∃! y ( ∃ x ph ∧ ∃ y ph ) ↔ ( ∃! y ∃ x ph ∧ ∃ y ph ) ) ;;
	step 10 : wff = eubii (step 9) |- ( ∃! x ∃! y ( ∃ x ph ∧ ∃ y ph ) ↔ ∃! x ( ∃! y ∃ x ph ∧ ∃ y ph ) ) ;;
	step 11 : wff = ancom () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ( ∃! y ∃ x ph ∧ ∃! x ∃ y ph ) ) ;;
	step 12 : wff = 3bitr4ri (step 3, step 10, step 11) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ∃! x ∃! y ( ∃ x ph ∧ ∃ y ph ) ) ;;
	qed prop 1 = step 12 ;;
}

/*Two equivalent expressions for double existential uniqueness.  Curiously,
     we can put ` E! ` on either of the internal conjuncts but not both.  We
     can also commute ` E! x E! y ` using ~ 2eu7 .  (Contributed by NM,
     20-Feb-2005.) */

theorem 2eu8 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∃! x ∃! y ( ∃ x ph ∧ ∃ y ph ) ↔ ∃! x ∃! y ( ∃! x ph ∧ ∃ y ph ) ) ;;
}

proof of 2eu8 {
	step 1 : wff = 2eu2 () |- ( ∃! x ∃ y ph → ( ∃! y ∃! x ph ↔ ∃! y ∃ x ph ) ) ;;
	step 2 : wff = pm5.32i (step 1) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃! x ph ) ↔ ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ) ;;
	step 3 : wff = nfeu1 () |- F/ x ∃! x ph ;;
	step 4 : wff = nfeu (step 3) |- F/ x ∃! y ∃! x ph ;;
	step 5 : wff = euan (step 4) |- ( ∃! x ( ∃! y ∃! x ph ∧ ∃ y ph ) ↔ ( ∃! y ∃! x ph ∧ ∃! x ∃ y ph ) ) ;;
	step 6 : wff = ancom () |- ( ( ∃! x ph ∧ ∃ y ph ) ↔ ( ∃ y ph ∧ ∃! x ph ) ) ;;
	step 7 : wff = eubii (step 6) |- ( ∃! y ( ∃! x ph ∧ ∃ y ph ) ↔ ∃! y ( ∃ y ph ∧ ∃! x ph ) ) ;;
	step 8 : wff = nfe1 () |- F/ y ∃ y ph ;;
	step 9 : wff = euan (step 8) |- ( ∃! y ( ∃ y ph ∧ ∃! x ph ) ↔ ( ∃ y ph ∧ ∃! y ∃! x ph ) ) ;;
	step 10 : wff = ancom () |- ( ( ∃ y ph ∧ ∃! y ∃! x ph ) ↔ ( ∃! y ∃! x ph ∧ ∃ y ph ) ) ;;
	step 11 : wff = 3bitri (step 7, step 9, step 10) |- ( ∃! y ( ∃! x ph ∧ ∃ y ph ) ↔ ( ∃! y ∃! x ph ∧ ∃ y ph ) ) ;;
	step 12 : wff = eubii (step 11) |- ( ∃! x ∃! y ( ∃! x ph ∧ ∃ y ph ) ↔ ∃! x ( ∃! y ∃! x ph ∧ ∃ y ph ) ) ;;
	step 13 : wff = ancom () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃! x ph ) ↔ ( ∃! y ∃! x ph ∧ ∃! x ∃ y ph ) ) ;;
	step 14 : wff = 3bitr4ri (step 5, step 12, step 13) |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃! x ph ) ↔ ∃! x ∃! y ( ∃! x ph ∧ ∃ y ph ) ) ;;
	step 15 : wff = 2eu7 () |- ( ( ∃! x ∃ y ph ∧ ∃! y ∃ x ph ) ↔ ∃! x ∃! y ( ∃ x ph ∧ ∃ y ph ) ) ;;
	step 16 : wff = 3bitr3ri (step 2, step 14, step 15) |- ( ∃! x ∃! y ( ∃ x ph ∧ ∃ y ph ) ↔ ∃! x ∃! y ( ∃! x ph ∧ ∃ y ph ) ) ;;
	qed prop 1 = step 16 ;;
}

/*Equality has existential uniqueness.  Special case of ~ eueq1 proved
       using only predicate calculus.  (Contributed by Stefan Allan,
       4-Dec-2008.) */

theorem euequ1 (x : set, y : set) disjointed(x y z) {
	prop 1 : wff = |- ∃! x x = y ;;
}

proof of euequ1 {
	var z : set;;
	step 1 : wff = a9ev () |- ∃ x x = y ;;
	step 2 : wff = equtr2 () |- ( ( x = y ∧ z = y ) → x = z ) ;;
	step 3 : wff = gen2 (step 2) |- ∀ x ∀ z ( ( x = y ∧ z = y ) → x = z ) ;;
	step 4 : wff = equequ1 () |- ( x = z → ( x = y ↔ z = y ) ) ;;
	step 5 : wff = eu4 (step 4) |- ( ∃! x x = y ↔ ( ∃ x x = y ∧ ∀ x ∀ z ( ( x = y ∧ z = y ) → x = z ) ) ) ;;
	step 6 : wff = mpbir2an (step 1, step 3, step 5) |- ∃! x x = y ;;
	qed prop 1 = step 6 ;;
}

/*Two ways to express "only one thing exists."  The left-hand side
       requires only one variable to express this.  Both sides are false in set
       theory; see theorem ~ dtru .  (Contributed by NM, 5-Apr-2004.) */

theorem exists1 (x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( ∃! x x = x ↔ ∀ x x = y ) ;;
}

proof of exists1 {
	step 1 : wff = df-eu () |- ( ∃! x x = x ↔ ∃ y ∀ x ( x = x ↔ x = y ) ) ;;
	step 2 : wff = equid () |- x = x ;;
	step 3 : wff = tbt (step 2) |- ( x = y ↔ ( x = y ↔ x = x ) ) ;;
	step 4 : wff = bicom () |- ( ( x = y ↔ x = x ) ↔ ( x = x ↔ x = y ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( x = y ↔ ( x = x ↔ x = y ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ x x = y ↔ ∀ x ( x = x ↔ x = y ) ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ y ∀ x x = y ↔ ∃ y ∀ x ( x = x ↔ x = y ) ) ;;
	step 8 : wff = nfae () |- F/ y ∀ x x = y ;;
	step 9 : wff = 19.9 (step 8) |- ( ∃ y ∀ x x = y ↔ ∀ x x = y ) ;;
	step 10 : wff = 3bitr2i (step 1, step 7, step 9) |- ( ∃! x x = x ↔ ∀ x x = y ) ;;
	qed prop 1 = step 10 ;;
}

/*A condition implying that at least two things exist.  (Contributed by
       NM, 10-Apr-2004.)  (Proof shortened by Andrew Salmon, 9-Jul-2011.) */

theorem exists2 (ph : wff, x : set) disjointed(x y) {
	prop 1 : wff = |- ( ( ∃ x ph ∧ ∃ x ¬ ph ) → ¬ ∃! x x = x ) ;;
}

proof of exists2 {
	var y : set;;
	step 1 : wff = nfeu1 () |- F/ x ∃! x x = x ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ph ;;
	step 3 : wff = exists1 () |- ( ∃! x x = x ↔ ∀ x x = y ) ;;
	step 4 : wff = ax16 () |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	step 5 : wff = sylbi (step 3, step 4) |- ( ∃! x x = x → ( ph → ∀ x ph ) ) ;;
	step 6 : wff = exlimd (step 1, step 2, step 5) |- ( ∃! x x = x → ( ∃ x ph → ∀ x ph ) ) ;;
	step 7 : wff = com12 (step 6) |- ( ∃ x ph → ( ∃! x x = x → ∀ x ph ) ) ;;
	step 8 : wff = alex () |- ( ∀ x ph ↔ ¬ ∃ x ¬ ph ) ;;
	step 9 : wff = syl6ib (step 7, step 8) |- ( ∃ x ph → ( ∃! x x = x → ¬ ∃ x ¬ ph ) ) ;;
	step 10 : wff = con2d (step 9) |- ( ∃ x ph → ( ∃ x ¬ ph → ¬ ∃! x x = x ) ) ;;
	step 11 : wff = imp (step 10) |- ( ( ∃ x ph ∧ ∃ x ¬ ph ) → ¬ ∃! x x = x ) ;;
	qed prop 1 = step 11 ;;
}


