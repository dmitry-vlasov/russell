import uset-100000/CLASSICAL_FIRST_ORDER_LOGIC_WITH_EQUALITY/Predicate_calculus_with_equality___Auxiliary_axiom_schemes_(4_schemes)/Axiom_scheme_ax-11_(Substitution).rus;;

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          Axiom scheme ax-12 (Quantified Equality)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*/

/* Axiom of Quantified Equality.  One of the equality and substitution axioms
     of predicate calculus with equality.

     An equivalent way to express this axiom that may be easier to understand
     is ` ( -. x = y -> ( -. x = z -> ( y = z -> A. x y = z ) ) ) ` (see
     ~ ax12b ).  Recall that in the intended interpretation, our variables are
     metavariables ranging over the variables of predicate calculus (the object
     language).  In order for the first antecedent ` -. x = y ` to hold, ` x `
     and ` y ` must have different values and thus cannot be the same
     object-language variable.  Similarly, ` x ` and ` z ` cannot be the same
     object-language variable.  Therefore, ` x ` will not occur in the wff
     ` y = z ` when the first two antecedents hold, so analogous to ~ ax-17 ,
     the conclusion ` ( y = z -> A. x y = z ) ` follows.

     The original version of this axiom was ~ ax-12o and was replaced with this
     shorter ~ ax-12 in December 2015.  The old axiom is proved from this one
     as theorem ~ ax12o .  Conversely, this axiom is proved from ~ ax-12o as
     theorem ~ ax12 .

     The primary purpose of this axiom is to provide a way to introduce the
     quantifier ` A. x ` on ` y = z ` even when ` x ` and ` y ` are substituted
     with the same variable.  In this case, the first antecedent becomes
     ` -. x = x ` and the axiom still holds.

     Although this version is shorter, the original version ~ ax12o may be more
     practical to work with because of the "distinctor" form of its
     antecedents.  A typical application of ~ ax12o is in ~ dvelimh which
     converts a distinct variable pair to the distinctor antecendent
     ` -. A. x x = y ` .

     This axiom can be weakened if desired by adding distinct variable
     restrictions on pairs ` x , z ` and ` y , z ` .  To show that, we add
     these restrictions to theorem ~ ax12v and use only ~ ax12v for further
     derivations.  Thus, ~ ax12v should be the only theorem referencing this
     axiom.  Other theorems can reference either ~ ax12v or ~ ax12o .

     This axiom scheme is logically redundant (see ~ ax12w ) but is used as an
     auxiliary axiom to achieve metalogical completeness.  (Contributed by NM,
     21-Dec-2015.)  (New usage is discouraged.) */

axiom ax-12 (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ¬ x = y → ( y = z → ∀ x y = z ) ) ;;
}

/* A weaker version of ~ ax-12 with distinct variable restrictions on pairs
       ` x , z ` and ` y , z ` .  In order to show that this weakening is
       adequate, this should be the only theorem referencing ~ ax-12 directly.
       (Contributed by NM, 30-Jun-2016.) */

theorem ax12v (x : set, y : set, z : set) disjointed(x z, y z) {
	prop 1 : wff = |- ( ¬ x = y → ( y = z → ∀ x y = z ) ) ;;
}

proof of ax12v {
	step 1 : wff = ax-12 () |- ( ¬ x = y → ( y = z → ∀ x y = z ) ) ;;
	qed prop 1 = step 1 ;;
}

/* Lemma for ~ ax12o .  Similar to ~ equvin but with a negated equality.
       (Contributed by NM, 24-Dec-2015.) */

theorem ax12olem1 (y : set, z : set, w : set) disjointed(w y, w z) {
	prop 1 : wff = |- ( ∃ w ( y = w ∧ ¬ z = w ) ↔ ¬ y = z ) ;;
}

proof of ax12olem1 {
	step 1 : wff = ax-8 () |- ( y = w → ( y = z → w = z ) ) ;;
	step 2 : wff = equcomi () |- ( w = z → z = w ) ;;
	step 3 : wff = syl6 (step 1, step 2) |- ( y = w → ( y = z → z = w ) ) ;;
	step 4 : wff = con3and (step 3) |- ( ( y = w ∧ ¬ z = w ) → ¬ y = z ) ;;
	step 5 : wff = exlimiv (step 4) |- ( ∃ w ( y = w ∧ ¬ z = w ) → ¬ y = z ) ;;
	step 6 : wff = ax-17 () |- ( ¬ y = z → ∀ w ¬ y = z ) ;;
	step 7 : wff = ax-8 () |- ( w = z → ( w = y → z = y ) ) ;;
	step 8 : wff = equcomi () |- ( z = y → y = z ) ;;
	step 9 : wff = syl6 (step 7, step 8) |- ( w = z → ( w = y → y = z ) ) ;;
	step 10 : wff = equcoms (step 9) |- ( z = w → ( w = y → y = z ) ) ;;
	step 11 : wff = com12 (step 10) |- ( w = y → ( z = w → y = z ) ) ;;
	step 12 : wff = con3d (step 11) |- ( w = y → ( ¬ y = z → ¬ z = w ) ) ;;
	step 13 : wff = equcomi () |- ( w = y → y = w ) ;;
	step 14 : wff = jctild (step 12, step 13) |- ( w = y → ( ¬ y = z → ( y = w ∧ ¬ z = w ) ) ) ;;
	step 15 : wff = spimeh (step 6, step 14) |- ( ¬ y = z → ∃ w ( y = w ∧ ¬ z = w ) ) ;;
	step 16 : wff = impbii (step 5, step 15) |- ( ∃ w ( y = w ∧ ¬ z = w ) ↔ ¬ y = z ) ;;
	qed prop 1 = step 16 ;;
}

/* Lemma for ~ ax12o .  Negate the equalities in ~ ax-12 , shown as the
       hypothesis.  (Contributed by NM, 24-Dec-2015.) */

theorem ax12olem2 (x : set, y : set, z : set, w : set) disjointed(w x z, w y) {
	hyp 1 : wff = |- ( ¬ x = y → ( y = w → ∀ x y = w ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ;;
}

proof of ax12olem2 {
	step 1 : wff = anim1d (hyp 1) |- ( ¬ x = y → ( ( y = w ∧ ¬ z = w ) → ( ∀ x y = w ∧ ¬ z = w ) ) ) ;;
	step 2 : wff = ax-17 () |- ( ¬ z = w → ∀ x ¬ z = w ) ;;
	step 3 : wff = anim2i (step 2) |- ( ( ∀ x y = w ∧ ¬ z = w ) → ( ∀ x y = w ∧ ∀ x ¬ z = w ) ) ;;
	step 4 : wff = 19.26 () |- ( ∀ x ( y = w ∧ ¬ z = w ) ↔ ( ∀ x y = w ∧ ∀ x ¬ z = w ) ) ;;
	step 5 : wff = sylibr (step 3, step 4) |- ( ( ∀ x y = w ∧ ¬ z = w ) → ∀ x ( y = w ∧ ¬ z = w ) ) ;;
	step 6 : wff = syl6 (step 1, step 5) |- ( ¬ x = y → ( ( y = w ∧ ¬ z = w ) → ∀ x ( y = w ∧ ¬ z = w ) ) ) ;;
	step 7 : wff = eximdv (step 6) |- ( ¬ x = y → ( ∃ w ( y = w ∧ ¬ z = w ) → ∃ w ∀ x ( y = w ∧ ¬ z = w ) ) ) ;;
	step 8 : wff = 19.12 () |- ( ∃ w ∀ x ( y = w ∧ ¬ z = w ) → ∀ x ∃ w ( y = w ∧ ¬ z = w ) ) ;;
	step 9 : wff = syl6 (step 7, step 8) |- ( ¬ x = y → ( ∃ w ( y = w ∧ ¬ z = w ) → ∀ x ∃ w ( y = w ∧ ¬ z = w ) ) ) ;;
	step 10 : wff = ax12olem1 () |- ( ∃ w ( y = w ∧ ¬ z = w ) ↔ ¬ y = z ) ;;
	step 11 : wff = ax12olem1 () |- ( ∃ w ( y = w ∧ ¬ z = w ) ↔ ¬ y = z ) ;;
	step 12 : wff = albii (step 11) |- ( ∀ x ∃ w ( y = w ∧ ¬ z = w ) ↔ ∀ x ¬ y = z ) ;;
	step 13 : wff = 3imtr3g (step 9, step 10, step 12) |- ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Lemma for ~ ax12o .  Show the equivalence of an intermediate equivalent to
     ~ ax12o with the conjunction of ~ ax-12 and a variant with negated
     equalities.  (Contributed by NM, 24-Dec-2015.) */

theorem ax12olem3 (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ↔ ( ( ¬ x = y → ( y = z → ∀ x y = z ) ) ∧ ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ) ) ;;
}

proof of ax12olem3 {
	step 1 : wff = sp () |- ( ∀ x ¬ y = z → ¬ y = z ) ;;
	step 2 : wff = con2i (step 1) |- ( y = z → ¬ ∀ x ¬ y = z ) ;;
	step 3 : wff = imim1i (step 2) |- ( ( ¬ ∀ x ¬ y = z → ∀ x y = z ) → ( y = z → ∀ x y = z ) ) ;;
	step 4 : wff = imim2i (step 3) |- ( ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) → ( ¬ x = y → ( y = z → ∀ x y = z ) ) ) ;;
	step 5 : wff = sp () |- ( ∀ x y = z → y = z ) ;;
	step 6 : wff = imim2i (step 5) |- ( ( ¬ ∀ x ¬ y = z → ∀ x y = z ) → ( ¬ ∀ x ¬ y = z → y = z ) ) ;;
	step 7 : wff = con1d (step 6) |- ( ( ¬ ∀ x ¬ y = z → ∀ x y = z ) → ( ¬ y = z → ∀ x ¬ y = z ) ) ;;
	step 8 : wff = imim2i (step 7) |- ( ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) → ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ) ;;
	step 9 : wff = jca (step 4, step 8) |- ( ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) → ( ( ¬ x = y → ( y = z → ∀ x y = z ) ) ∧ ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ) ) ;;
	step 10 : wff = con1 () |- ( ( ¬ y = z → ∀ x ¬ y = z ) → ( ¬ ∀ x ¬ y = z → y = z ) ) ;;
	step 11 : wff = imim1d (step 10) |- ( ( ¬ y = z → ∀ x ¬ y = z ) → ( ( y = z → ∀ x y = z ) → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ) ;;
	step 12 : wff = com12 (step 11) |- ( ( y = z → ∀ x y = z ) → ( ( ¬ y = z → ∀ x ¬ y = z ) → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ) ;;
	step 13 : wff = imim3i (step 12) |- ( ( ¬ x = y → ( y = z → ∀ x y = z ) ) → ( ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) → ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ) ) ;;
	step 14 : wff = imp (step 13) |- ( ( ( ¬ x = y → ( y = z → ∀ x y = z ) ) ∧ ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ) → ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ) ;;
	step 15 : wff = impbii (step 9, step 14) |- ( ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ↔ ( ( ¬ x = y → ( y = z → ∀ x y = z ) ) ∧ ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Lemma for ~ ax12o .  Construct an intermediate equivalent to ~ ax-12
       from two instances of ~ ax-12 .  (Contributed by NM, 24-Dec-2015.) */

theorem ax12olem4 (x : set, y : set, z : set, w : set) disjointed(w x z, w y z) {
	hyp 1 : wff = |- ( ¬ x = y → ( y = z → ∀ x y = z ) ) ;;
	hyp 2 : wff = |- ( ¬ x = y → ( y = w → ∀ x y = w ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ;;
}

proof of ax12olem4 {
	step 1 : wff = ax12olem2 (hyp 2) |- ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ;;
	step 2 : wff = ax12olem3 () |- ( ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ↔ ( ( ¬ x = y → ( y = z → ∀ x y = z ) ) ∧ ( ¬ x = y → ( ¬ y = z → ∀ x ¬ y = z ) ) ) ) ;;
	step 3 : wff = mpbir2an (hyp 1, step 1, step 2) |- ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Lemma for ~ ax12o .  See ~ ax12olem6 for derivation of ~ ax12o from the
       conclusion.  (Contributed by NM, 24-Dec-2015.) */

theorem ax12olem5 (x : set, y : set, z : set)  {
	hyp 1 : wff = |- ( ¬ x = y → ( ¬ ∀ x ¬ y = z → ∀ x y = z ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( y = z → ∀ x y = z ) ) ;;
}

proof of ax12olem5 {
	step 1 : wff = exnal () |- ( ∃ x ¬ x = y ↔ ¬ ∀ x x = y ) ;;
	step 2 : wff = 19.8a () |- ( y = z → ∃ x y = z ) ;;
	step 3 : wff = hbe1 () |- ( ∃ x y = z → ∀ x ∃ x y = z ) ;;
	step 4 : wff = hba1 () |- ( ∀ x y = z → ∀ x ∀ x y = z ) ;;
	step 5 : wff = hbim (step 3, step 4) |- ( ( ∃ x y = z → ∀ x y = z ) → ∀ x ( ∃ x y = z → ∀ x y = z ) ) ;;
	step 6 : wff = df-ex () |- ( ∃ x y = z ↔ ¬ ∀ x ¬ y = z ) ;;
	step 7 : wff = syl5bi (step 6, hyp 1) |- ( ¬ x = y → ( ∃ x y = z → ∀ x y = z ) ) ;;
	step 8 : wff = exlimih (step 5, step 7) |- ( ∃ x ¬ x = y → ( ∃ x y = z → ∀ x y = z ) ) ;;
	step 9 : wff = syl5 (step 2, step 8) |- ( ∃ x ¬ x = y → ( y = z → ∀ x y = z ) ) ;;
	step 10 : wff = sylbir (step 1, step 9) |- ( ¬ ∀ x x = y → ( y = z → ∀ x y = z ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Lemma for ~ ax12o .  Derivation of ~ ax12o from the hypotheses, without
       using ~ ax12o .  (Contributed by Andrew Salmon, 21-Jul-2011.)  (Revised
       by NM, 24-Dec-2015.) */

theorem ax12olem6 (x : set, y : set, z : set, w : set) disjointed(w x, w y, w z) {
	hyp 1 : wff = |- ( ¬ ∀ x x = z → ( z = w → ∀ x z = w ) ) ;;
	hyp 2 : wff = |- ( ¬ ∀ x x = y → ( y = w → ∀ x y = w ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ¬ ∀ x x = z → ( y = z → ∀ x y = z ) ) ) ;;
}

proof of ax12olem6 {
	step 1 : wff = hbn1 () |- ( ¬ ∀ x x = z → ∀ x ¬ ∀ x x = z ) ;;
	step 2 : wff = hbim1 (step 1, hyp 1) |- ( ( ¬ ∀ x x = z → z = w ) → ∀ x ( ¬ ∀ x x = z → z = w ) ) ;;
	step 3 : wff = ax-17 () |- ( ( ¬ ∀ x x = z → y = z ) → ∀ w ( ¬ ∀ x x = z → y = z ) ) ;;
	step 4 : wff = equcom () |- ( z = w ↔ w = z ) ;;
	step 5 : wff = equequ1 () |- ( w = y → ( w = z ↔ y = z ) ) ;;
	step 6 : wff = syl5bb (step 4, step 5) |- ( w = y → ( z = w ↔ y = z ) ) ;;
	step 7 : wff = imbi2d (step 6) |- ( w = y → ( ( ¬ ∀ x x = z → z = w ) ↔ ( ¬ ∀ x x = z → y = z ) ) ) ;;
	step 8 : wff = dvelimhw (step 2, step 3, step 7, hyp 2) |- ( ¬ ∀ x x = y → ( ( ¬ ∀ x x = z → y = z ) → ∀ x ( ¬ ∀ x x = z → y = z ) ) ) ;;
	step 9 : wff = hbn1 () |- ( ¬ ∀ x x = z → ∀ x ¬ ∀ x x = z ) ;;
	step 10 : wff = 19.21h (step 9) |- ( ∀ x ( ¬ ∀ x x = z → y = z ) ↔ ( ¬ ∀ x x = z → ∀ x y = z ) ) ;;
	step 11 : wff = syl6ib (step 8, step 10) |- ( ¬ ∀ x x = y → ( ( ¬ ∀ x x = z → y = z ) → ( ¬ ∀ x x = z → ∀ x y = z ) ) ) ;;
	step 12 : wff = pm2.86d (step 11) |- ( ¬ ∀ x x = y → ( ¬ ∀ x x = z → ( y = z → ∀ x y = z ) ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Lemma for ~ ax12o .  Derivation of ~ ax12o from the hypotheses, without
       using ~ ax12o .  (Contributed by NM, 24-Dec-2015.) */

theorem ax12olem7 (x : set, y : set, z : set, w : set) disjointed(w x, w y, w z) {
	hyp 1 : wff = |- ( ¬ x = z → ( ¬ ∀ x ¬ z = w → ∀ x z = w ) ) ;;
	hyp 2 : wff = |- ( ¬ x = y → ( ¬ ∀ x ¬ y = w → ∀ x y = w ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ¬ ∀ x x = z → ( y = z → ∀ x y = z ) ) ) ;;
}

proof of ax12olem7 {
	step 1 : wff = ax12olem5 (hyp 1) |- ( ¬ ∀ x x = z → ( z = w → ∀ x z = w ) ) ;;
	step 2 : wff = ax12olem5 (hyp 2) |- ( ¬ ∀ x x = y → ( y = w → ∀ x y = w ) ) ;;
	step 3 : wff = ax12olem6 (step 1, step 2) |- ( ¬ ∀ x x = y → ( ¬ ∀ x x = z → ( y = z → ∀ x y = z ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Derive set.mm's original ~ ax-12o from the shorter ~ ax-12 .
       (Contributed by NM, 29-Nov-2015.)  (Revised by NM, 24-Dec-2015.) */

theorem ax12o (x : set, y : set, z : set) disjointed(x w v, y w v, z w v) {
	prop 1 : wff = |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x = y → ∀ z x = y ) ) ) ;;
}

proof of ax12o {
	var w : set, v : set;;
	step 1 : wff = ax12v () |- ( ¬ z = y → ( y = w → ∀ z y = w ) ) ;;
	step 2 : wff = ax12v () |- ( ¬ z = y → ( y = v → ∀ z y = v ) ) ;;
	step 3 : wff = ax12olem4 (step 1, step 2) |- ( ¬ z = y → ( ¬ ∀ z ¬ y = w → ∀ z y = w ) ) ;;
	step 4 : wff = ax12v () |- ( ¬ z = x → ( x = w → ∀ z x = w ) ) ;;
	step 5 : wff = ax12v () |- ( ¬ z = x → ( x = v → ∀ z x = v ) ) ;;
	step 6 : wff = ax12olem4 (step 4, step 5) |- ( ¬ z = x → ( ¬ ∀ z ¬ x = w → ∀ z x = w ) ) ;;
	step 7 : wff = ax12olem7 (step 3, step 6) |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x = y → ∀ z x = y ) ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Lemma for ~ ax10 .  Change bound variable.  (Contributed by NM,
       22-Jul-2015.) */

theorem ax10lem1 (x : set, y : set, w : set) disjointed(x v w, y v w) {
	prop 1 : wff = |- ( ∀ x x = w → ∀ y y = w ) ;;
}

proof of ax10lem1 {
	var v : set;;
	step 1 : wff = ax-8 () |- ( x = v → ( x = w → v = w ) ) ;;
	step 2 : wff = cbvalivw (step 1) |- ( ∀ x x = w → ∀ v v = w ) ;;
	step 3 : wff = ax-8 () |- ( v = y → ( v = w → y = w ) ) ;;
	step 4 : wff = cbvalivw (step 3) |- ( ∀ v v = w → ∀ y y = w ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( ∀ x x = w → ∀ y y = w ) ;;
	qed prop 1 = step 5 ;;
}

/* Lemma for ~ ax10 .  Change free variable.  (Contributed by NM,
       25-Jul-2015.) */

theorem ax10lem2 (x : set, y : set, z : set) disjointed(x y, x z) {
	prop 1 : wff = |- ( ∀ x x = y → ∀ x x = z ) ;;
}

proof of ax10lem2 {
	step 1 : wff = hbe1 () |- ( ∃ x ¬ x = y → ∀ x ∃ x ¬ x = y ) ;;
	step 2 : wff = equequ2 () |- ( z = y → ( x = z ↔ x = y ) ) ;;
	step 3 : wff = biimprd (step 2) |- ( z = y → ( x = y → x = z ) ) ;;
	step 4 : wff = con3rr3 (step 3) |- ( ¬ x = z → ( z = y → ¬ x = y ) ) ;;
	step 5 : wff = 19.8a () |- ( ¬ x = y → ∃ x ¬ x = y ) ;;
	step 6 : wff = syl6 (step 4, step 5) |- ( ¬ x = z → ( z = y → ∃ x ¬ x = y ) ) ;;
	step 7 : wff = ax-17 () |- ( ¬ z = y → ∀ x ¬ z = y ) ;;
	step 8 : wff = equequ1 () |- ( x = z → ( x = y ↔ z = y ) ) ;;
	step 9 : wff = notbid (step 8) |- ( x = z → ( ¬ x = y ↔ ¬ z = y ) ) ;;
	step 10 : wff = biimprd (step 9) |- ( x = z → ( ¬ z = y → ¬ x = y ) ) ;;
	step 11 : wff = spimeh (step 7, step 10) |- ( ¬ z = y → ∃ x ¬ x = y ) ;;
	step 12 : wff = pm2.61d1 (step 6, step 11) |- ( ¬ x = z → ∃ x ¬ x = y ) ;;
	step 13 : wff = exlimih (step 1, step 12) |- ( ∃ x ¬ x = z → ∃ x ¬ x = y ) ;;
	step 14 : wff = exnal () |- ( ∃ x ¬ x = z ↔ ¬ ∀ x x = z ) ;;
	step 15 : wff = exnal () |- ( ∃ x ¬ x = y ↔ ¬ ∀ x x = y ) ;;
	step 16 : wff = 3imtr3i (step 13, step 14, step 15) |- ( ¬ ∀ x x = z → ¬ ∀ x x = y ) ;;
	step 17 : wff = con4i (step 16) |- ( ∀ x x = y → ∀ x x = z ) ;;
	qed prop 1 = step 17 ;;
}

/* Lemma for ~ ax10 .  Similar to ~ ax-10 but with distinct variables.
       (Contributed by NM, 25-Jul-2015.) */

theorem ax10lem3 (x : set, y : set) disjointed(w x y, w x z) {
	prop 1 : wff = |- ( ∀ x x = y → ∀ y y = x ) ;;
}

proof of ax10lem3 {
	var z : set, w : set;;
	step 1 : wff = ax10lem2 () |- ( ∀ x x = y → ∀ x x = z ) ;;
	step 2 : wff = ax10lem1 () |- ( ∀ x x = z → ∀ w w = z ) ;;
	step 3 : wff = ax10lem2 () |- ( ∀ w w = z → ∀ w w = x ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ∀ x x = z → ∀ w w = x ) ;;
	step 5 : wff = ax10lem1 () |- ( ∀ w w = x → ∀ y y = x ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ∀ x x = z → ∀ y y = x ) ;;
	step 7 : wff = syl (step 1, step 6) |- ( ∀ x x = y → ∀ y y = x ) ;;
	qed prop 1 = step 7 ;;
}

/* Similar to ~ dvelim with first hypothesis replaced by distinct variable
       condition.  (Contributed by NM, 25-Jul-2015.) */

theorem dvelimv (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x z, y z, z ps, x ph) {
	hyp 1 : wff = |- ( z = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
}

proof of dvelimv {
	step 1 : wff = ax-17 () |- ( ps → ∀ z ps ) ;;
	step 2 : wff = ax-17 () |- ( ps → ∀ z ps ) ;;
	step 3 : wff = a1d (step 2) |- ( ps → ( z = y → ∀ z ps ) ) ;;
	step 4 : wff = alrimih (step 1, step 3) |- ( ps → ∀ z ( z = y → ∀ z ps ) ) ;;
	step 5 : wff = sp () |- ( ∀ z ps → ps ) ;;
	step 6 : wff = syl5ibr (step 5, hyp 1) |- ( z = y → ( ∀ z ps → ph ) ) ;;
	step 7 : wff = a2i (step 6) |- ( ( z = y → ∀ z ps ) → ( z = y → ph ) ) ;;
	step 8 : wff = alimi (step 7) |- ( ∀ z ( z = y → ∀ z ps ) → ∀ z ( z = y → ph ) ) ;;
	step 9 : wff = syl (step 4, step 8) |- ( ps → ∀ z ( z = y → ph ) ) ;;
	step 10 : wff = ax10lem3 () |- ( ∀ z z = x → ∀ x x = z ) ;;
	step 11 : wff = con3i (step 10) |- ( ¬ ∀ x x = z → ¬ ∀ z z = x ) ;;
	step 12 : wff = hbn1 () |- ( ¬ ∀ z z = x → ∀ z ¬ ∀ z z = x ) ;;
	step 13 : wff = ax10lem3 () |- ( ∀ x x = z → ∀ z z = x ) ;;
	step 14 : wff = con3i (step 13) |- ( ¬ ∀ z z = x → ¬ ∀ x x = z ) ;;
	step 15 : wff = alrimih (step 12, step 14) |- ( ¬ ∀ z z = x → ∀ z ¬ ∀ x x = z ) ;;
	step 16 : wff = syl (step 11, step 15) |- ( ¬ ∀ x x = z → ∀ z ¬ ∀ x x = z ) ;;
	step 17 : wff = ax-17 () |- ( ¬ ∀ x x = y → ∀ z ¬ ∀ x x = y ) ;;
	step 18 : wff = hban (step 16, step 17) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ∀ z ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) ) ;;
	step 19 : wff = hbn1 () |- ( ¬ ∀ x x = z → ∀ x ¬ ∀ x x = z ) ;;
	step 20 : wff = hbn1 () |- ( ¬ ∀ x x = y → ∀ x ¬ ∀ x x = y ) ;;
	step 21 : wff = hban (step 19, step 20) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ∀ x ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) ) ;;
	step 22 : wff = ax12o () |- ( ¬ ∀ x x = z → ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ) ;;
	step 23 : wff = imp (step 22) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( z = y → ∀ x z = y ) ) ;;
	step 24 : wff = a17d () |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ph → ∀ x ph ) ) ;;
	step 25 : wff = hbimd (step 21, step 23, step 24) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ;;
	step 26 : wff = hbald (step 18, step 25) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 27 : wff = biimpd (hyp 1) |- ( z = y → ( ph → ps ) ) ;;
	step 28 : wff = a2i (step 27) |- ( ( z = y → ph ) → ( z = y → ps ) ) ;;
	step 29 : wff = alimi (step 28) |- ( ∀ z ( z = y → ph ) → ∀ z ( z = y → ps ) ) ;;
	step 30 : wff = ax9v () |- ¬ ∀ z ¬ z = y ;;
	step 31 : wff = con3 () |- ( ( z = y → ps ) → ( ¬ ps → ¬ z = y ) ) ;;
	step 32 : wff = al2imi (step 31) |- ( ∀ z ( z = y → ps ) → ( ∀ z ¬ ps → ∀ z ¬ z = y ) ) ;;
	step 33 : wff = mtoi (step 30, step 32) |- ( ∀ z ( z = y → ps ) → ¬ ∀ z ¬ ps ) ;;
	step 34 : wff = syl (step 29, step 33) |- ( ∀ z ( z = y → ph ) → ¬ ∀ z ¬ ps ) ;;
	step 35 : wff = ax-17 () |- ( ¬ ps → ∀ z ¬ ps ) ;;
	step 36 : wff = nsyl2 (step 34, step 35) |- ( ∀ z ( z = y → ph ) → ps ) ;;
	step 37 : wff = alimi (step 36) |- ( ∀ x ∀ z ( z = y → ph ) → ∀ x ps ) ;;
	step 38 : wff = syl56 (step 9, step 26, step 37) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ps → ∀ x ps ) ) ;;
	step 39 : wff = expcom (step 38) |- ( ¬ ∀ x x = y → ( ¬ ∀ x x = z → ( ps → ∀ x ps ) ) ) ;;
	step 40 : wff = sp () |- ( ∀ x x = z → x = z ) ;;
	step 41 : wff = ax-17 () |- ( ps → ∀ z ps ) ;;
	step 42 : wff = ax-11 () |- ( x = z → ( ∀ z ps → ∀ x ( x = z → ps ) ) ) ;;
	step 43 : wff = syl2im (step 40, step 41, step 42) |- ( ∀ x x = z → ( ps → ∀ x ( x = z → ps ) ) ) ;;
	step 44 : wff = pm2.27 () |- ( x = z → ( ( x = z → ps ) → ps ) ) ;;
	step 45 : wff = al2imi (step 44) |- ( ∀ x x = z → ( ∀ x ( x = z → ps ) → ∀ x ps ) ) ;;
	step 46 : wff = syld (step 43, step 45) |- ( ∀ x x = z → ( ps → ∀ x ps ) ) ;;
	step 47 : wff = pm2.61d2 (step 39, step 46) |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
	qed prop 1 = step 47 ;;
}

/* Quantifier introduction when one pair of variables is distinct.
       (Contributed by NM, 2-Jan-2002.)  (Revised by NM, 20-Jul-2015.) */

theorem dveeq2 (x : set, y : set, z : set) disjointed(w z x, w y) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ;;
}

proof of dveeq2 {
	var w : set;;
	step 1 : wff = equequ2 () |- ( w = y → ( z = w ↔ z = y ) ) ;;
	step 2 : wff = dvelimv (step 1) |- ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Lemma for ~ ax10 .  Change bound variable.  (Contributed by NM,
       8-Jul-2016.) */

theorem ax10lem4 (x : set, y : set, w : set) disjointed(w z x, w z y) {
	prop 1 : wff = |- ( ∀ x x = w → ∀ y y = x ) ;;
}

proof of ax10lem4 {
	var z : set;;
	step 1 : wff = ax10lem1 () |- ( ∀ x x = w → ∀ y y = w ) ;;
	step 2 : wff = equequ1 () |- ( z = x → ( z = w ↔ x = w ) ) ;;
	step 3 : wff = dvelimv (step 2) |- ( ¬ ∀ y y = x → ( x = w → ∀ y x = w ) ) ;;
	step 4 : wff = hba1 () |- ( ∀ y x = w → ∀ y ∀ y x = w ) ;;
	step 5 : wff = equequ2 () |- ( x = w → ( y = x ↔ y = w ) ) ;;
	step 6 : wff = sps (step 5) |- ( ∀ y x = w → ( y = x ↔ y = w ) ) ;;
	step 7 : wff = albidh (step 4, step 6) |- ( ∀ y x = w → ( ∀ y y = x ↔ ∀ y y = w ) ) ;;
	step 8 : wff = biimprd (step 7) |- ( ∀ y x = w → ( ∀ y y = w → ∀ y y = x ) ) ;;
	step 9 : wff = syl6 (step 3, step 8) |- ( ¬ ∀ y y = x → ( x = w → ( ∀ y y = w → ∀ y y = x ) ) ) ;;
	step 10 : wff = syl7 (step 1, step 9) |- ( ¬ ∀ y y = x → ( x = w → ( ∀ x x = w → ∀ y y = x ) ) ) ;;
	step 11 : wff = spsd (step 10) |- ( ¬ ∀ y y = x → ( ∀ x x = w → ( ∀ x x = w → ∀ y y = x ) ) ) ;;
	step 12 : wff = pm2.43d (step 11) |- ( ¬ ∀ y y = x → ( ∀ x x = w → ∀ y y = x ) ) ;;
	step 13 : wff = com12 (step 12) |- ( ∀ x x = w → ( ¬ ∀ y y = x → ∀ y y = x ) ) ;;
	step 14 : wff = pm2.18d (step 13) |- ( ∀ x x = w → ∀ y y = x ) ;;
	qed prop 1 = step 14 ;;
}

/* Lemma for ~ ax10 .  Change free and bound variables.  (Contributed by
       NM, 22-Jul-2015.) */

theorem ax10lem5 (x : set, y : set, z : set, w : set) disjointed(w z, u v w, v x, v y) {
	prop 1 : wff = |- ( ∀ z z = w → ∀ y y = x ) ;;
}

proof of ax10lem5 {
	var v : set, u : set;;
	step 1 : wff = ax10lem1 () |- ( ∀ z z = w → ∀ v v = w ) ;;
	step 2 : wff = ax10lem4 () |- ( ∀ v v = w → ∀ u u = v ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ∀ z z = w → ∀ u u = v ) ;;
	step 4 : wff = ax10lem1 () |- ( ∀ u u = v → ∀ x x = v ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ∀ z z = w → ∀ x x = v ) ;;
	step 6 : wff = ax10lem4 () |- ( ∀ x x = v → ∀ y y = x ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ∀ z z = w → ∀ y y = x ) ;;
	qed prop 1 = step 7 ;;
}

/* Lemma for ~ ax10 .  Similar to ~ ax10o but with reversed antecedent.
     (Contributed by NM, 25-Jul-2015.) */

theorem ax10lem6 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ y y = x → ( ∀ x ph → ∀ y ph ) ) ;;
}

proof of ax10lem6 {
	step 1 : wff = ax-11 () |- ( y = x → ( ∀ x ph → ∀ y ( y = x → ph ) ) ) ;;
	step 2 : wff = sps (step 1) |- ( ∀ y y = x → ( ∀ x ph → ∀ y ( y = x → ph ) ) ) ;;
	step 3 : wff = pm2.27 () |- ( y = x → ( ( y = x → ph ) → ph ) ) ;;
	step 4 : wff = al2imi (step 3) |- ( ∀ y y = x → ( ∀ y ( y = x → ph ) → ∀ y ph ) ) ;;
	step 5 : wff = syld (step 2, step 4) |- ( ∀ y y = x → ( ∀ x ph → ∀ y ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Derive set.mm's original ~ ax-10 from others.  (Contributed by NM,
       25-Jul-2015.)  (Revised by NM, 7-Nov-2015.) */

theorem ax10 (x : set, y : set) disjointed(x z, y z) {
	prop 1 : wff = |- ( ∀ x x = y → ∀ y y = x ) ;;
}

proof of ax10 {
	var z : set;;
	step 1 : wff = ax9v () |- ¬ ∀ z ¬ z = x ;;
	step 2 : wff = df-ex () |- ( ∃ z z = x ↔ ¬ ∀ z ¬ z = x ) ;;
	step 3 : wff = dveeq2 () |- ( ¬ ∀ y y = x → ( z = x → ∀ y z = x ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( ¬ ∀ y y = x ∧ z = x ) → ∀ y z = x ) ;;
	step 5 : wff = ax10lem6 () |- ( ∀ x x = y → ( ∀ y z = x → ∀ x z = x ) ) ;;
	step 6 : wff = equcomi () |- ( z = x → x = z ) ;;
	step 7 : wff = alimi (step 6) |- ( ∀ x z = x → ∀ x x = z ) ;;
	step 8 : wff = syl6 (step 5, step 7) |- ( ∀ x x = y → ( ∀ y z = x → ∀ x x = z ) ) ;;
	step 9 : wff = ax10lem5 () |- ( ∀ x x = z → ∀ y y = x ) ;;
	step 10 : wff = syl56 (step 4, step 8, step 9) |- ( ∀ x x = y → ( ( ¬ ∀ y y = x ∧ z = x ) → ∀ y y = x ) ) ;;
	step 11 : wff = exp3acom23 (step 10) |- ( ∀ x x = y → ( z = x → ( ¬ ∀ y y = x → ∀ y y = x ) ) ) ;;
	step 12 : wff = pm2.18 () |- ( ( ¬ ∀ y y = x → ∀ y y = x ) → ∀ y y = x ) ;;
	step 13 : wff = syl6 (step 11, step 12) |- ( ∀ x x = y → ( z = x → ∀ y y = x ) ) ;;
	step 14 : wff = exlimdv (step 13) |- ( ∀ x x = y → ( ∃ z z = x → ∀ y y = x ) ) ;;
	step 15 : wff = syl5bir (step 2, step 14) |- ( ∀ x x = y → ( ¬ ∀ z ¬ z = x → ∀ y y = x ) ) ;;
	step 16 : wff = mpi (step 1, step 15) |- ( ∀ x x = y → ∀ y y = x ) ;;
	qed prop 1 = step 16 ;;
}

/* Generalization of ~ ax16 .  (Contributed by NM, 25-Jul-2015.) */

theorem a16g (ph : wff, x : set, y : set, z : set) disjointed(x y, w ph, w z) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ z ph ) ) ;;
}

proof of a16g {
	var w : set;;
	step 1 : wff = a9ev () |- ∃ w w = z ;;
	step 2 : wff = ax10lem5 () |- ( ∀ x x = y → ∀ w w = z ) ;;
	step 3 : wff = hbn1 () |- ( ¬ ∀ w w = z → ∀ w ¬ ∀ w w = z ) ;;
	step 4 : wff = pm2.21 () |- ( ¬ ∀ w w = z → ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 5 : wff = alrimih (step 3, step 4) |- ( ¬ ∀ w w = z → ∀ w ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 6 : wff = ax-17 () |- ( ( ph → ∀ z ph ) → ∀ w ( ph → ∀ z ph ) ) ;;
	step 7 : wff = ax-1 () |- ( ( ph → ∀ z ph ) → ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 8 : wff = alrimih (step 6, step 7) |- ( ( ph → ∀ z ph ) → ∀ w ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 9 : wff = ja (step 5, step 8) |- ( ( ∀ w w = z → ( ph → ∀ z ph ) ) → ∀ w ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 10 : wff = ax10lem5 () |- ( ∀ w w = z → ∀ z z = w ) ;;
	step 11 : wff = equcomi () |- ( w = z → z = w ) ;;
	step 12 : wff = ax-17 () |- ( ph → ∀ w ph ) ;;
	step 13 : wff = ax-11 () |- ( z = w → ( ∀ w ph → ∀ z ( z = w → ph ) ) ) ;;
	step 14 : wff = syl2im (step 11, step 12, step 13) |- ( w = z → ( ph → ∀ z ( z = w → ph ) ) ) ;;
	step 15 : wff = ax-5 () |- ( ∀ z ( z = w → ph ) → ( ∀ z z = w → ∀ z ph ) ) ;;
	step 16 : wff = syl6 (step 14, step 15) |- ( w = z → ( ph → ( ∀ z z = w → ∀ z ph ) ) ) ;;
	step 17 : wff = com23 (step 16) |- ( w = z → ( ∀ z z = w → ( ph → ∀ z ph ) ) ) ;;
	step 18 : wff = syl5 (step 10, step 17) |- ( w = z → ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 19 : wff = exlimih (step 9, step 18) |- ( ∃ w w = z → ( ∀ w w = z → ( ph → ∀ z ph ) ) ) ;;
	step 20 : wff = mpsyl (step 1, step 2, step 19) |- ( ∀ x x = y → ( ph → ∀ z ph ) ) ;;
	qed prop 1 = step 20 ;;
}

/* Commutation law for identical variable specifiers.  The antecedent and
     consequent are true when ` x ` and ` y ` are substituted with the same
     variable.  Lemma L12 in [Megill] p. 445 (p. 12 of the preprint).
     (Contributed by NM, 5-Aug-1993.) */

theorem aecom (x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x x = y → ∀ y y = x ) ;;
}

proof of aecom {
	step 1 : wff = ax10 () |- ( ∀ x x = y → ∀ y y = x ) ;;
	qed prop 1 = step 1 ;;
}

/* A commutation rule for identical variable specifiers.  (Contributed by
       NM, 5-Aug-1993.) */

theorem aecoms (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ y y = x → ph ) ;;
}

proof of aecoms {
	step 1 : wff = aecom () |- ( ∀ y y = x → ∀ x x = y ) ;;
	step 2 : wff = syl (step 1, hyp 1) |- ( ∀ y y = x → ph ) ;;
	qed prop 1 = step 2 ;;
}

/* A commutation rule for distinct variable specifiers.  (Contributed by
       NM, 2-Jan-2002.) */

theorem naecoms (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ¬ ∀ x x = y → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ y y = x → ph ) ;;
}

proof of naecoms {
	step 1 : wff = aecom () |- ( ∀ x x = y → ∀ y y = x ) ;;
	step 2 : wff = nsyl4 (step 1, hyp 1) |- ( ¬ ph → ∀ y y = x ) ;;
	step 3 : wff = con1i (step 2) |- ( ¬ ∀ y y = x → ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Theorem showing that ~ ax-9 follows from the weaker version ~ ax9v .
       (Even though this theorem depends on ~ ax-9 , all references of ~ ax-9
       are made via ~ ax9v .  An earlier version stated ~ ax9v as a separate
       axiom, but having two axioms caused some confusion.)

       This theorem should be referenced in place of ~ ax-9 so that all proofs
       can be traced back to ~ ax9v .  (Contributed by NM, 12-Nov-2013.)
       (Revised by NM, 25-Jul-2015.) */

theorem ax9 (x : set, y : set) disjointed(x v, y v) {
	prop 1 : wff = |- ¬ ∀ x ¬ x = y ;;
}

proof of ax9 {
	var v : set;;
	step 1 : wff = sp () |- ( ∀ x ¬ x = y → ¬ x = y ) ;;
	step 2 : wff = sp () |- ( ∀ x x = y → x = y ) ;;
	step 3 : wff = nsyl3 (step 1, step 2) |- ( ∀ x x = y → ¬ ∀ x ¬ x = y ) ;;
	step 4 : wff = ax9v () |- ¬ ∀ v ¬ v = y ;;
	step 5 : wff = dveeq2 () |- ( ¬ ∀ x x = y → ( v = y → ∀ x v = y ) ) ;;
	step 6 : wff = ax9v () |- ¬ ∀ x ¬ x = v ;;
	step 7 : wff = hba1 () |- ( ∀ x v = y → ∀ x ∀ x v = y ) ;;
	step 8 : wff = sp () |- ( ∀ x v = y → v = y ) ;;
	step 9 : wff = equequ2 () |- ( v = y → ( x = v ↔ x = y ) ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( ∀ x v = y → ( x = v ↔ x = y ) ) ;;
	step 11 : wff = notbid (step 10) |- ( ∀ x v = y → ( ¬ x = v ↔ ¬ x = y ) ) ;;
	step 12 : wff = albidh (step 7, step 11) |- ( ∀ x v = y → ( ∀ x ¬ x = v ↔ ∀ x ¬ x = y ) ) ;;
	step 13 : wff = mtbii (step 6, step 12) |- ( ∀ x v = y → ¬ ∀ x ¬ x = y ) ;;
	step 14 : wff = syl6com (step 5, step 13) |- ( v = y → ( ¬ ∀ x x = y → ¬ ∀ x ¬ x = y ) ) ;;
	step 15 : wff = con3i (step 14) |- ( ¬ ( ¬ ∀ x x = y → ¬ ∀ x ¬ x = y ) → ¬ v = y ) ;;
	step 16 : wff = alrimiv (step 15) |- ( ¬ ( ¬ ∀ x x = y → ¬ ∀ x ¬ x = y ) → ∀ v ¬ v = y ) ;;
	step 17 : wff = mt3 (step 4, step 16) |- ( ¬ ∀ x x = y → ¬ ∀ x ¬ x = y ) ;;
	step 18 : wff = pm2.61i (step 3, step 17) |- ¬ ∀ x ¬ x = y ;;
	qed prop 1 = step 18 ;;
}

/* Show that the original axiom ~ ax-9o can be derived from ~ ax9 and
     others.  See ~ ax9from9o for the rederivation of ~ ax9 from ~ ax-9o .

     Normally, ~ ax9o should be used rather than ~ ax-9o , except by theorems
     specifically studying the latter's properties.  (Contributed by NM,
     5-Aug-1993.)  (Proof modification is discouraged.) */

theorem ax9o (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ( x = y → ∀ x ph ) → ph ) ;;
}

proof of ax9o {
	step 1 : wff = ax9 () |- ¬ ∀ x ¬ x = y ;;
	step 2 : wff = con3 () |- ( ( x = y → ∀ x ph ) → ( ¬ ∀ x ph → ¬ x = y ) ) ;;
	step 3 : wff = al2imi (step 2) |- ( ∀ x ( x = y → ∀ x ph ) → ( ∀ x ¬ ∀ x ph → ∀ x ¬ x = y ) ) ;;
	step 4 : wff = mtoi (step 1, step 3) |- ( ∀ x ( x = y → ∀ x ph ) → ¬ ∀ x ¬ ∀ x ph ) ;;
	step 5 : wff = ax6o () |- ( ¬ ∀ x ¬ ∀ x ph → ph ) ;;
	step 6 : wff = syl (step 4, step 5) |- ( ∀ x ( x = y → ∀ x ph ) → ph ) ;;
	qed prop 1 = step 6 ;;
}

/* At least one individual exists.  This is not a theorem of free logic,
     which is sound in empty domains.  For such a logic, we would add this
     theorem as an axiom of set theory (Axiom 0 of [Kunen] p. 10).  In the
     system consisting of ~ ax-5 through ~ ax-14 and ~ ax-17 , all axioms other
     than ~ ax9 are believed to be theorems of free logic, although the system
     without ~ ax9 is probably not complete in free logic.  (Contributed by NM,
     5-Aug-1993.) */

theorem a9e (x : set, y : set)  {
	prop 1 : wff = |- ∃ x x = y ;;
}

proof of a9e {
	step 1 : wff = ax9 () |- ¬ ∀ x ¬ x = y ;;
	step 2 : wff = df-ex () |- ( ∃ x x = y ↔ ¬ ∀ x ¬ x = y ) ;;
	step 3 : wff = mpbir (step 1, step 2) |- ∃ x x = y ;;
	qed prop 1 = step 3 ;;
}

/* Show that ~ ax-10o can be derived from ~ ax-10 in the form of ~ ax10 .
     Normally, ~ ax10o should be used rather than ~ ax-10o , except by theorems
     specifically studying the latter's properties.  (Contributed by NM,
     16-May-2008.)  (Proof modification is discouraged.) */

theorem ax10o (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x x = y → ( ∀ x ph → ∀ y ph ) ) ;;
}

proof of ax10o {
	step 1 : wff = ax10 () |- ( ∀ x x = y → ∀ y y = x ) ;;
	step 2 : wff = ax-11 () |- ( y = x → ( ∀ x ph → ∀ y ( y = x → ph ) ) ) ;;
	step 3 : wff = equcoms (step 2) |- ( x = y → ( ∀ x ph → ∀ y ( y = x → ph ) ) ) ;;
	step 4 : wff = sps (step 3) |- ( ∀ x x = y → ( ∀ x ph → ∀ y ( y = x → ph ) ) ) ;;
	step 5 : wff = pm2.27 () |- ( y = x → ( ( y = x → ph ) → ph ) ) ;;
	step 6 : wff = al2imi (step 5) |- ( ∀ y y = x → ( ∀ y ( y = x → ph ) → ∀ y ph ) ) ;;
	step 7 : wff = sylsyld (step 1, step 4, step 6) |- ( ∀ x x = y → ( ∀ x ph → ∀ y ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* All variables are effectively bound in an identical variable specifier.
     (Contributed by NM, 5-Aug-1993.) */

theorem hbae (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
}

proof of hbae {
	step 1 : wff = sp () |- ( ∀ x x = y → x = y ) ;;
	step 2 : wff = ax12o () |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x = y → ∀ z x = y ) ) ) ;;
	step 3 : wff = syl7 (step 1, step 2) |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( ∀ x x = y → ∀ z x = y ) ) ) ;;
	step 4 : wff = ax10o () |- ( ∀ x x = z → ( ∀ x x = y → ∀ z x = y ) ) ;;
	step 5 : wff = aecoms (step 4) |- ( ∀ z z = x → ( ∀ x x = y → ∀ z x = y ) ) ;;
	step 6 : wff = ax10o () |- ( ∀ x x = y → ( ∀ x x = y → ∀ y x = y ) ) ;;
	step 7 : wff = pm2.43i (step 6) |- ( ∀ x x = y → ∀ y x = y ) ;;
	step 8 : wff = ax10o () |- ( ∀ y y = z → ( ∀ y x = y → ∀ z x = y ) ) ;;
	step 9 : wff = syl5 (step 7, step 8) |- ( ∀ y y = z → ( ∀ x x = y → ∀ z x = y ) ) ;;
	step 10 : wff = aecoms (step 9) |- ( ∀ z z = y → ( ∀ x x = y → ∀ z x = y ) ) ;;
	step 11 : wff = pm2.61ii (step 3, step 5, step 10) |- ( ∀ x x = y → ∀ z x = y ) ;;
	step 12 : wff = a5i (step 11) |- ( ∀ x x = y → ∀ x ∀ z x = y ) ;;
	step 13 : wff = ax-7 () |- ( ∀ x ∀ z x = y → ∀ z ∀ x x = y ) ;;
	step 14 : wff = syl (step 12, step 13) |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
	qed prop 1 = step 14 ;;
}

/* All variables are effectively bound in an identical variable specifier.
     (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfae (x : set, y : set, z : set)  {
	prop 1 : wff = |- F/ z ∀ x x = y ;;
}

proof of nfae {
	step 1 : wff = hbae () |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
	step 2 : wff = nfi (step 1) |- F/ z ∀ x x = y ;;
	qed prop 1 = step 2 ;;
}

/* All variables are effectively bound in a distinct variable specifier.
     Lemma L19 in [Megill] p. 446 (p. 14 of the preprint).  (Contributed by NM,
     5-Aug-1993.) */

theorem hbnae (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ∀ z ¬ ∀ x x = y ) ;;
}

proof of hbnae {
	step 1 : wff = hbae () |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
	step 2 : wff = hbn (step 1) |- ( ¬ ∀ x x = y → ∀ z ¬ ∀ x x = y ) ;;
	qed prop 1 = step 2 ;;
}

/* All variables are effectively bound in a distinct variable specifier.
     (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfnae (x : set, y : set, z : set)  {
	prop 1 : wff = |- F/ z ¬ ∀ x x = y ;;
}

proof of nfnae {
	step 1 : wff = nfae () |- F/ z ∀ x x = y ;;
	step 2 : wff = nfn (step 1) |- F/ z ¬ ∀ x x = y ;;
	qed prop 1 = step 2 ;;
}

/* Rule that applies ~ hbnae to antecedent.  (Contributed by NM,
       5-Aug-1993.) */

theorem hbnaes (ph : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- ( ∀ z ¬ ∀ x x = y → ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ph ) ;;
}

proof of hbnaes {
	step 1 : wff = hbnae () |- ( ¬ ∀ x x = y → ∀ z ¬ ∀ x x = y ) ;;
	step 2 : wff = syl (step 1, hyp 1) |- ( ¬ ∀ x x = y → ph ) ;;
	qed prop 1 = step 2 ;;
}

/* A variable is effectively not free in an equality if it is not either of
     the involved variables. ` F/ ` version of ~ ax-12o .  (Contributed by
     Mario Carneiro, 6-Oct-2016.) */

theorem nfeqf (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
}

proof of nfeqf {
	step 1 : wff = nfnae () |- F/ z ¬ ∀ z z = x ;;
	step 2 : wff = nfnae () |- F/ z ¬ ∀ z z = y ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ z ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ;;
	step 4 : wff = ax12o () |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x = y → ∀ z x = y ) ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → ( x = y → ∀ z x = y ) ) ;;
	step 6 : wff = nfd (step 3, step 5) |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
	qed prop 1 = step 6 ;;
}

/* Lemma used in proofs of substitution properties.  (Contributed by NM,
     5-Aug-1993.)  (Proof shortened by Mario Carneiro, 20-May-2014.) */

theorem equs4 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ( x = y → ph ) → ∃ x ( x = y ∧ ph ) ) ;;
}

proof of equs4 {
	step 1 : wff = a9e () |- ∃ x x = y ;;
	step 2 : wff = 19.29 () |- ( ( ∀ x ( x = y → ph ) ∧ ∃ x x = y ) → ∃ x ( ( x = y → ph ) ∧ x = y ) ) ;;
	step 3 : wff = mpan2 (step 1, step 2) |- ( ∀ x ( x = y → ph ) → ∃ x ( ( x = y → ph ) ∧ x = y ) ) ;;
	step 4 : wff = ancl () |- ( ( x = y → ph ) → ( x = y → ( x = y ∧ ph ) ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( ( x = y → ph ) ∧ x = y ) → ( x = y ∧ ph ) ) ;;
	step 6 : wff = eximi (step 5) |- ( ∃ x ( ( x = y → ph ) ∧ x = y ) → ∃ x ( x = y ∧ ph ) ) ;;
	step 7 : wff = syl (step 3, step 6) |- ( ∀ x ( x = y → ph ) → ∃ x ( x = y ∧ ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* A useful equivalence related to substitution.  (Contributed by NM,
       5-Aug-1993.)  (Proof shortened by Andrew Salmon, 12-Aug-2011.)  (Revised
       by Mario Carneiro, 3-Oct-2016.) */

theorem equsal (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = y → ph ) ↔ ps ) ;;
}

proof of equsal {
	step 1 : wff = 19.3 (hyp 1) |- ( ∀ x ps ↔ ps ) ;;
	step 2 : wff = syl6bbr (hyp 2, step 1) |- ( x = y → ( ph ↔ ∀ x ps ) ) ;;
	step 3 : wff = pm5.74i (step 2) |- ( ( x = y → ph ) ↔ ( x = y → ∀ x ps ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x ( x = y → ph ) ↔ ∀ x ( x = y → ∀ x ps ) ) ;;
	step 5 : wff = nfri (hyp 1) |- ( ps → ∀ x ps ) ;;
	step 6 : wff = a1d (step 5) |- ( ps → ( x = y → ∀ x ps ) ) ;;
	step 7 : wff = alrimi (hyp 1, step 6) |- ( ps → ∀ x ( x = y → ∀ x ps ) ) ;;
	step 8 : wff = ax9o () |- ( ∀ x ( x = y → ∀ x ps ) → ps ) ;;
	step 9 : wff = impbii (step 7, step 8) |- ( ps ↔ ∀ x ( x = y → ∀ x ps ) ) ;;
	step 10 : wff = bitr4i (step 4, step 9) |- ( ∀ x ( x = y → ph ) ↔ ps ) ;;
	qed prop 1 = step 10 ;;
}

/* A useful equivalence related to substitution.  (Contributed by NM,
       5-Aug-1993.) */

theorem equsalh (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ps → ∀ x ps ) ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ( x = y → ph ) ↔ ps ) ;;
}

proof of equsalh {
	step 1 : wff = nfi (hyp 1) |- F/ x ps ;;
	step 2 : wff = equsal (step 1, hyp 2) |- ( ∀ x ( x = y → ph ) ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A useful equivalence related to substitution.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Mario Carneiro, 3-Oct-2016.) */

theorem equsex (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( x = y ∧ ph ) ↔ ps ) ;;
}

proof of equsex {
	step 1 : wff = exnal () |- ( ∃ x ¬ ( x = y → ¬ ph ) ↔ ¬ ∀ x ( x = y → ¬ ph ) ) ;;
	step 2 : wff = df-an () |- ( ( x = y ∧ ph ) ↔ ¬ ( x = y → ¬ ph ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x ( x = y ∧ ph ) ↔ ∃ x ¬ ( x = y → ¬ ph ) ) ;;
	step 4 : wff = nfn (hyp 1) |- F/ x ¬ ps ;;
	step 5 : wff = notbid (hyp 2) |- ( x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 6 : wff = equsal (step 4, step 5) |- ( ∀ x ( x = y → ¬ ph ) ↔ ¬ ps ) ;;
	step 7 : wff = con2bii (step 6) |- ( ps ↔ ¬ ∀ x ( x = y → ¬ ph ) ) ;;
	step 8 : wff = 3bitr4i (step 1, step 3, step 7) |- ( ∃ x ( x = y ∧ ph ) ↔ ps ) ;;
	qed prop 1 = step 8 ;;
}

/* A useful equivalence related to substitution.  (Contributed by NM,
       5-Aug-1993.) */

theorem equsexh (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ps → ∀ x ps ) ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( x = y ∧ ph ) ↔ ps ) ;;
}

proof of equsexh {
	step 1 : wff = nfi (hyp 1) |- F/ x ps ;;
	step 2 : wff = equsex (step 1, hyp 2) |- ( ∃ x ( x = y ∧ ph ) ↔ ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Version of ~ dvelim without any variable restrictions.  (Contributed by
       NM, 1-Oct-2002.) */

theorem dvelimh (ph : wff, ps : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- ( ph → ∀ x ph ) ;;
	hyp 2 : wff = |- ( ps → ∀ z ps ) ;;
	hyp 3 : wff = |- ( z = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
}

proof of dvelimh {
	step 1 : wff = hba1 () |- ( ∀ z ( z = y → ph ) → ∀ z ∀ z ( z = y → ph ) ) ;;
	step 2 : wff = ax10o () |- ( ∀ z z = x → ( ∀ z ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 3 : wff = aecoms (step 2) |- ( ∀ x x = z → ( ∀ z ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 4 : wff = syl5 (step 1, step 3) |- ( ∀ x x = z → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 5 : wff = a1d (step 4) |- ( ∀ x x = z → ( ¬ ∀ x x = y → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ) ;;
	step 6 : wff = hbnae () |- ( ¬ ∀ x x = z → ∀ z ¬ ∀ x x = z ) ;;
	step 7 : wff = hbnae () |- ( ¬ ∀ x x = y → ∀ z ¬ ∀ x x = y ) ;;
	step 8 : wff = hban (step 6, step 7) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ∀ z ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) ) ;;
	step 9 : wff = hbnae () |- ( ¬ ∀ x x = z → ∀ x ¬ ∀ x x = z ) ;;
	step 10 : wff = hbnae () |- ( ¬ ∀ x x = y → ∀ x ¬ ∀ x x = y ) ;;
	step 11 : wff = hban (step 9, step 10) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ∀ x ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) ) ;;
	step 12 : wff = ax12o () |- ( ¬ ∀ x x = z → ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ) ;;
	step 13 : wff = imp (step 12) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( z = y → ∀ x z = y ) ) ;;
	step 14 : wff = a1i (hyp 1) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ph → ∀ x ph ) ) ;;
	step 15 : wff = hbimd (step 11, step 13, step 14) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ;;
	step 16 : wff = hbald (step 8, step 15) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 17 : wff = ex (step 16) |- ( ¬ ∀ x x = z → ( ¬ ∀ x x = y → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ) ;;
	step 18 : wff = pm2.61i (step 5, step 17) |- ( ¬ ∀ x x = y → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 19 : wff = equsalh (hyp 2, hyp 3) |- ( ∀ z ( z = y → ph ) ↔ ps ) ;;
	step 20 : wff = equsalh (hyp 2, hyp 3) |- ( ∀ z ( z = y → ph ) ↔ ps ) ;;
	step 21 : wff = albii (step 20) |- ( ∀ x ∀ z ( z = y → ph ) ↔ ∀ x ps ) ;;
	step 22 : wff = 3imtr3g (step 18, step 19, step 21) |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
	qed prop 1 = step 22 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       Part of Theorem 9.4 of [Megill] p. 448 (p. 16 of preprint).
       (Contributed by NM, 24-Nov-1994.) */

theorem dral1 (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( ∀ x ph ↔ ∀ y ps ) ) ;;
}

proof of dral1 {
	step 1 : wff = hbae () |- ( ∀ x x = y → ∀ x ∀ x x = y ) ;;
	step 2 : wff = biimpd (hyp 1) |- ( ∀ x x = y → ( ph → ps ) ) ;;
	step 3 : wff = alimdh (step 1, step 2) |- ( ∀ x x = y → ( ∀ x ph → ∀ x ps ) ) ;;
	step 4 : wff = ax10o () |- ( ∀ x x = y → ( ∀ x ps → ∀ y ps ) ) ;;
	step 5 : wff = syld (step 3, step 4) |- ( ∀ x x = y → ( ∀ x ph → ∀ y ps ) ) ;;
	step 6 : wff = hbae () |- ( ∀ x x = y → ∀ y ∀ x x = y ) ;;
	step 7 : wff = biimprd (hyp 1) |- ( ∀ x x = y → ( ps → ph ) ) ;;
	step 8 : wff = alimdh (step 6, step 7) |- ( ∀ x x = y → ( ∀ y ps → ∀ y ph ) ) ;;
	step 9 : wff = ax10o () |- ( ∀ y y = x → ( ∀ y ph → ∀ x ph ) ) ;;
	step 10 : wff = aecoms (step 9) |- ( ∀ x x = y → ( ∀ y ph → ∀ x ph ) ) ;;
	step 11 : wff = syld (step 8, step 10) |- ( ∀ x x = y → ( ∀ y ps → ∀ x ph ) ) ;;
	step 12 : wff = impbid (step 5, step 11) |- ( ∀ x x = y → ( ∀ x ph ↔ ∀ y ps ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       Part of Theorem 9.4 of [Megill] p. 448 (p. 16 of preprint).
       (Contributed by NM, 27-Feb-2005.) */

theorem dral2 (ph : wff, ps : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( ∀ z ph ↔ ∀ z ps ) ) ;;
}

proof of dral2 {
	step 1 : wff = hbae () |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
	step 2 : wff = albidh (step 1, hyp 1) |- ( ∀ x x = y → ( ∀ z ph ↔ ∀ z ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       Part of Theorem 9.4 of [Megill] p. 448 (p. 16 of preprint).
       (Contributed by NM, 27-Feb-2005.) */

theorem drex1 (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( ∃ x ph ↔ ∃ y ps ) ) ;;
}

proof of drex1 {
	step 1 : wff = notbid (hyp 1) |- ( ∀ x x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 2 : wff = dral1 (step 1) |- ( ∀ x x = y → ( ∀ x ¬ ph ↔ ∀ y ¬ ps ) ) ;;
	step 3 : wff = notbid (step 2) |- ( ∀ x x = y → ( ¬ ∀ x ¬ ph ↔ ¬ ∀ y ¬ ps ) ) ;;
	step 4 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 5 : wff = df-ex () |- ( ∃ y ps ↔ ¬ ∀ y ¬ ps ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ∀ x x = y → ( ∃ x ph ↔ ∃ y ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       Part of Theorem 9.4 of [Megill] p. 448 (p. 16 of preprint).
       (Contributed by NM, 27-Feb-2005.) */

theorem drex2 (ph : wff, ps : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( ∃ z ph ↔ ∃ z ps ) ) ;;
}

proof of drex2 {
	step 1 : wff = hbae () |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
	step 2 : wff = exbidh (step 1, hyp 1) |- ( ∀ x x = y → ( ∃ z ph ↔ ∃ z ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       (Contributed by Mario Carneiro, 4-Oct-2016.) */

theorem drnf1 (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( F/ x ph ↔ F/ y ps ) ) ;;
}

proof of drnf1 {
	step 1 : wff = dral1 (hyp 1) |- ( ∀ x x = y → ( ∀ x ph ↔ ∀ y ps ) ) ;;
	step 2 : wff = imbi12d (hyp 1, step 1) |- ( ∀ x x = y → ( ( ph → ∀ x ph ) ↔ ( ps → ∀ y ps ) ) ) ;;
	step 3 : wff = dral1 (step 2) |- ( ∀ x x = y → ( ∀ x ( ph → ∀ x ph ) ↔ ∀ y ( ps → ∀ y ps ) ) ) ;;
	step 4 : wff = df-nf () |- ( F/ x ph ↔ ∀ x ( ph → ∀ x ph ) ) ;;
	step 5 : wff = df-nf () |- ( F/ y ps ↔ ∀ y ( ps → ∀ y ps ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ∀ x x = y → ( F/ x ph ↔ F/ y ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
       (Contributed by Mario Carneiro, 4-Oct-2016.) */

theorem drnf2 (ph : wff, ps : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- ( ∀ x x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( F/ z ph ↔ F/ z ps ) ) ;;
}

proof of drnf2 {
	step 1 : wff = dral2 (hyp 1) |- ( ∀ x x = y → ( ∀ z ph ↔ ∀ z ps ) ) ;;
	step 2 : wff = imbi12d (hyp 1, step 1) |- ( ∀ x x = y → ( ( ph → ∀ z ph ) ↔ ( ps → ∀ z ps ) ) ) ;;
	step 3 : wff = dral2 (step 2) |- ( ∀ x x = y → ( ∀ z ( ph → ∀ z ph ) ↔ ∀ z ( ps → ∀ z ps ) ) ) ;;
	step 4 : wff = df-nf () |- ( F/ z ph ↔ ∀ z ( ph → ∀ z ph ) ) ;;
	step 5 : wff = df-nf () |- ( F/ z ps ↔ ∀ z ( ps → ∀ z ps ) ) ;;
	step 6 : wff = 3bitr4g (step 3, step 4, step 5) |- ( ∀ x x = y → ( F/ z ph ↔ F/ z ps ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Distribution of existential quantifiers, with a bound-variable
       hypothesis saying that ` y ` is not free in ` ph ` , but ` x ` can be
       free in ` ph ` (and there is no distinct variable condition on ` x ` and
       ` y ` ).  (Contributed by Mario Carneiro, 20-Mar-2013.) */

theorem exdistrf (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ¬ ∀ x x = y → F/ y ph ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ( ph ∧ ps ) → ∃ x ( ph ∧ ∃ y ps ) ) ;;
}

proof of exdistrf {
	step 1 : wff = biidd () |- ( ∀ x x = y → ( ( ph ∧ ps ) ↔ ( ph ∧ ps ) ) ) ;;
	step 2 : wff = drex1 (step 1) |- ( ∀ x x = y → ( ∃ x ( ph ∧ ps ) ↔ ∃ y ( ph ∧ ps ) ) ) ;;
	step 3 : wff = drex2 (step 2) |- ( ∀ x x = y → ( ∃ x ∃ x ( ph ∧ ps ) ↔ ∃ x ∃ y ( ph ∧ ps ) ) ) ;;
	step 4 : wff = nfe1 () |- F/ x ∃ x ( ph ∧ ps ) ;;
	step 5 : wff = 19.9 (step 4) |- ( ∃ x ∃ x ( ph ∧ ps ) ↔ ∃ x ( ph ∧ ps ) ) ;;
	step 6 : wff = 19.8a () |- ( ps → ∃ y ps ) ;;
	step 7 : wff = anim2i (step 6) |- ( ( ph ∧ ps ) → ( ph ∧ ∃ y ps ) ) ;;
	step 8 : wff = eximi (step 7) |- ( ∃ x ( ph ∧ ps ) → ∃ x ( ph ∧ ∃ y ps ) ) ;;
	step 9 : wff = sylbi (step 5, step 8) |- ( ∃ x ∃ x ( ph ∧ ps ) → ∃ x ( ph ∧ ∃ y ps ) ) ;;
	step 10 : wff = syl6bir (step 3, step 9) |- ( ∀ x x = y → ( ∃ x ∃ y ( ph ∧ ps ) → ∃ x ( ph ∧ ∃ y ps ) ) ) ;;
	step 11 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 12 : wff = 19.40 () |- ( ∃ y ( ph ∧ ps ) → ( ∃ y ph ∧ ∃ y ps ) ) ;;
	step 13 : wff = 19.9d (hyp 1) |- ( ¬ ∀ x x = y → ( ∃ y ph → ph ) ) ;;
	step 14 : wff = anim1d (step 13) |- ( ¬ ∀ x x = y → ( ( ∃ y ph ∧ ∃ y ps ) → ( ph ∧ ∃ y ps ) ) ) ;;
	step 15 : wff = syl5 (step 12, step 14) |- ( ¬ ∀ x x = y → ( ∃ y ( ph ∧ ps ) → ( ph ∧ ∃ y ps ) ) ) ;;
	step 16 : wff = eximd (step 11, step 15) |- ( ¬ ∀ x x = y → ( ∃ x ∃ y ( ph ∧ ps ) → ∃ x ( ph ∧ ∃ y ps ) ) ) ;;
	step 17 : wff = pm2.61i (step 10, step 16) |- ( ∃ x ∃ y ( ph ∧ ps ) → ∃ x ( ph ∧ ∃ y ps ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Variation on ~ nfald which adds the hypothesis that ` x ` and ` y ` are
       distinct in the inner subproof.  (Contributed by Mario Carneiro,
       8-Oct-2016.) */

theorem nfald2 (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∀ y ps ) ;;
}

proof of nfald2 {
	step 1 : wff = nfnae () |- F/ y ¬ ∀ x x = y ;;
	step 2 : wff = nfan (hyp 1, step 1) |- F/ y ( ph ∧ ¬ ∀ x x = y ) ;;
	step 3 : wff = nfald (step 2, hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ∀ y ps ) ;;
	step 4 : wff = ex (step 3) |- ( ph → ( ¬ ∀ x x = y → F/ x ∀ y ps ) ) ;;
	step 5 : wff = nfa1 () |- F/ y ∀ y ps ;;
	step 6 : wff = biidd () |- ( ∀ x x = y → ( ∀ y ps ↔ ∀ y ps ) ) ;;
	step 7 : wff = drnf1 (step 6) |- ( ∀ x x = y → ( F/ x ∀ y ps ↔ F/ y ∀ y ps ) ) ;;
	step 8 : wff = mpbiri (step 5, step 7) |- ( ∀ x x = y → F/ x ∀ y ps ) ;;
	step 9 : wff = pm2.61d2 (step 4, step 8) |- ( ph → F/ x ∀ y ps ) ;;
	qed prop 1 = step 9 ;;
}

/* Variation on ~ nfexd which adds the hypothesis that ` x ` and ` y ` are
       distinct in the inner subproof.  (Contributed by Mario Carneiro,
       8-Oct-2016.) */

theorem nfexd2 (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ x ∃ y ps ) ;;
}

proof of nfexd2 {
	step 1 : wff = df-ex () |- ( ∃ y ps ↔ ¬ ∀ y ¬ ps ) ;;
	step 2 : wff = nfnd (hyp 2) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ¬ ps ) ;;
	step 3 : wff = nfald2 (hyp 1, step 2) |- ( ph → F/ x ∀ y ¬ ps ) ;;
	step 4 : wff = nfnd (step 3) |- ( ph → F/ x ¬ ∀ y ¬ ps ) ;;
	step 5 : wff = nfxfrd (step 1, step 4) |- ( ph → F/ x ∃ y ps ) ;;
	qed prop 1 = step 5 ;;
}

/* Closed theorem form of ~ spim .  (Contributed by NM, 15-Jan-2008.)
     (Revised by Mario Carneiro, 17-Oct-2016.) */

theorem spimt (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ( F/ x ps ∧ ∀ x ( x = y → ( ph → ps ) ) ) → ( ∀ x ph → ps ) ) ;;
}

proof of spimt {
	step 1 : wff = nfnf1 () |- F/ x F/ x ps ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ph ;;
	step 3 : wff = nfan (step 1, step 2) |- F/ x ( F/ x ps ∧ ∀ x ph ) ;;
	step 4 : wff = sp () |- ( ∀ x ph → ph ) ;;
	step 5 : wff = adantl (step 4) |- ( ( F/ x ps ∧ ∀ x ph ) → ph ) ;;
	step 6 : wff = nfr () |- ( F/ x ps → ( ps → ∀ x ps ) ) ;;
	step 7 : wff = adantr (step 6) |- ( ( F/ x ps ∧ ∀ x ph ) → ( ps → ∀ x ps ) ) ;;
	step 8 : wff = embantd (step 5, step 7) |- ( ( F/ x ps ∧ ∀ x ph ) → ( ( ph → ps ) → ∀ x ps ) ) ;;
	step 9 : wff = imim2d (step 8) |- ( ( F/ x ps ∧ ∀ x ph ) → ( ( x = y → ( ph → ps ) ) → ( x = y → ∀ x ps ) ) ) ;;
	step 10 : wff = alimd (step 3, step 9) |- ( ( F/ x ps ∧ ∀ x ph ) → ( ∀ x ( x = y → ( ph → ps ) ) → ∀ x ( x = y → ∀ x ps ) ) ) ;;
	step 11 : wff = impancom (step 10) |- ( ( F/ x ps ∧ ∀ x ( x = y → ( ph → ps ) ) ) → ( ∀ x ph → ∀ x ( x = y → ∀ x ps ) ) ) ;;
	step 12 : wff = ax9o () |- ( ∀ x ( x = y → ∀ x ps ) → ps ) ;;
	step 13 : wff = syl6 (step 11, step 12) |- ( ( F/ x ps ∧ ∀ x ( x = y → ( ph → ps ) ) ) → ( ∀ x ph → ps ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Specialization, using implicit substitution.  Compare Lemma 14 of
       [Tarski] p. 70.  The ~ spim series of theorems requires that only one
       direction of the substitution hypothesis hold.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Mario Carneiro, 3-Oct-2016.) */

theorem spim (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph → ps ) ;;
}

proof of spim {
	step 1 : wff = ax-gen (hyp 2) |- ∀ x ( x = y → ( ph → ps ) ) ;;
	step 2 : wff = spimt () |- ( ( F/ x ps ∧ ∀ x ( x = y → ( ph → ps ) ) ) → ( ∀ x ph → ps ) ) ;;
	step 3 : wff = mp2an (hyp 1, step 1, step 2) |- ( ∀ x ph → ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Existential introduction, using implicit substitution.  Compare Lemma 14
       of [Tarski] p. 70.  (Contributed by NM, 7-Aug-1994.)  (Revised by Mario
       Carneiro, 3-Oct-2016.) */

theorem spime (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∃ x ps ) ;;
}

proof of spime {
	step 1 : wff = nfn (hyp 1) |- F/ x ¬ ph ;;
	step 2 : wff = con3d (hyp 2) |- ( x = y → ( ¬ ps → ¬ ph ) ) ;;
	step 3 : wff = spim (step 1, step 2) |- ( ∀ x ¬ ps → ¬ ph ) ;;
	step 4 : wff = con2i (step 3) |- ( ph → ¬ ∀ x ¬ ps ) ;;
	step 5 : wff = df-ex () |- ( ∃ x ps ↔ ¬ ∀ x ¬ ps ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( ph → ∃ x ps ) ;;
	qed prop 1 = step 6 ;;
}

/* Deduction version of ~ spime .  (Contributed by NM, 5-Aug-1993.)
       (Revised by Mario Carneiro, 3-Oct-2016.) */

theorem spimed (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ch → F/ x ph ) ;;
	hyp 2 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ch → ( ph → ∃ x ps ) ) ;;
}

proof of spimed {
	step 1 : wff = nfnf1 () |- F/ x F/ x ph ;;
	step 2 : wff = id () |- ( F/ x ph → F/ x ph ) ;;
	step 3 : wff = nfan1 (step 1, step 2) |- F/ x ( F/ x ph ∧ ph ) ;;
	step 4 : wff = adantld (hyp 2) |- ( x = y → ( ( F/ x ph ∧ ph ) → ps ) ) ;;
	step 5 : wff = spime (step 3, step 4) |- ( ( F/ x ph ∧ ph ) → ∃ x ps ) ;;
	step 6 : wff = ex (step 5) |- ( F/ x ph → ( ph → ∃ x ps ) ) ;;
	step 7 : wff = syl (hyp 1, step 6) |- ( ch → ( ph → ∃ x ps ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.) */

theorem cbv1h (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → ( ps → ∀ y ps ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch → ∀ x ch ) ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ y ch ) ) ;;
}

proof of cbv1h {
	step 1 : wff = sps (hyp 1) |- ( ∀ y ph → ( ps → ∀ y ps ) ) ;;
	step 2 : wff = al2imi (step 1) |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ x ∀ y ps ) ) ;;
	step 3 : wff = ax-7 () |- ( ∀ x ∀ y ps → ∀ y ∀ x ps ) ;;
	step 4 : wff = syl6 (step 2, step 3) |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ y ∀ x ps ) ) ;;
	step 5 : wff = com23 (hyp 3) |- ( ph → ( ps → ( x = y → ch ) ) ) ;;
	step 6 : wff = syl6d (step 5, hyp 2) |- ( ph → ( ps → ( x = y → ∀ x ch ) ) ) ;;
	step 7 : wff = al2imi (step 6) |- ( ∀ x ph → ( ∀ x ps → ∀ x ( x = y → ∀ x ch ) ) ) ;;
	step 8 : wff = ax9o () |- ( ∀ x ( x = y → ∀ x ch ) → ch ) ;;
	step 9 : wff = syl6 (step 7, step 8) |- ( ∀ x ph → ( ∀ x ps → ch ) ) ;;
	step 10 : wff = al2imi (step 9) |- ( ∀ y ∀ x ph → ( ∀ y ∀ x ps → ∀ y ch ) ) ;;
	step 11 : wff = a7s (step 10) |- ( ∀ x ∀ y ph → ( ∀ y ∀ x ps → ∀ y ch ) ) ;;
	step 12 : wff = syld (step 4, step 11) |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ y ch ) ) ;;
	qed prop 1 = step 12 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       3-Oct-2016.) */

theorem cbv1 (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → F/ y ps ) ;;
	hyp 2 : wff = |- ( ph → F/ x ch ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps → ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ y ch ) ) ;;
}

proof of cbv1 {
	step 1 : wff = nfrd (hyp 1) |- ( ph → ( ps → ∀ y ps ) ) ;;
	step 2 : wff = nfrd (hyp 2) |- ( ph → ( ch → ∀ x ch ) ) ;;
	step 3 : wff = cbv1h (step 1, step 2, hyp 3) |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ y ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.) */

theorem cbv2h (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → ( ps → ∀ y ps ) ) ;;
	hyp 2 : wff = |- ( ph → ( ch → ∀ x ch ) ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∀ y ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
}

proof of cbv2h {
	step 1 : wff = bi1 () |- ( ( ps ↔ ch ) → ( ps → ch ) ) ;;
	step 2 : wff = syl6 (hyp 3, step 1) |- ( ph → ( x = y → ( ps → ch ) ) ) ;;
	step 3 : wff = cbv1h (hyp 1, hyp 2, step 2) |- ( ∀ x ∀ y ph → ( ∀ x ps → ∀ y ch ) ) ;;
	step 4 : wff = equcomi () |- ( y = x → x = y ) ;;
	step 5 : wff = bi2 () |- ( ( ps ↔ ch ) → ( ch → ps ) ) ;;
	step 6 : wff = syl56 (step 4, hyp 3, step 5) |- ( ph → ( y = x → ( ch → ps ) ) ) ;;
	step 7 : wff = cbv1h (hyp 2, hyp 1, step 6) |- ( ∀ y ∀ x ph → ( ∀ y ch → ∀ x ps ) ) ;;
	step 8 : wff = a7s (step 7) |- ( ∀ x ∀ y ph → ( ∀ y ch → ∀ x ps ) ) ;;
	step 9 : wff = impbid (step 3, step 8) |- ( ∀ x ∀ y ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       3-Oct-2016.) */

theorem cbv2 (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → F/ y ps ) ;;
	hyp 2 : wff = |- ( ph → F/ x ch ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∀ y ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
}

proof of cbv2 {
	step 1 : wff = nfrd (hyp 1) |- ( ph → ( ps → ∀ y ps ) ) ;;
	step 2 : wff = nfrd (hyp 2) |- ( ph → ( ch → ∀ x ch ) ) ;;
	step 3 : wff = cbv2h (step 1, step 2, hyp 3) |- ( ∀ x ∀ y ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Rule used to change bound variables, using implicit substitution, that
       does not use ~ ax-12o .  (Contributed by NM, 5-Aug-1993.) */

theorem cbv3 (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph → ∀ y ps ) ;;
}

proof of cbv3 {
	step 1 : wff = a1i (hyp 1) |- ( T. → F/ y ph ) ;;
	step 2 : wff = a1i (hyp 2) |- ( T. → F/ x ps ) ;;
	step 3 : wff = a1i (hyp 3) |- ( T. → ( x = y → ( ph → ps ) ) ) ;;
	step 4 : wff = cbv1 (step 1, step 2, step 3) |- ( ∀ x ∀ y T. → ( ∀ x ph → ∀ y ps ) ) ;;
	step 5 : wff = tru () |- T. ;;
	step 6 : wff = ax-gen (step 5) |- ∀ y T. ;;
	step 7 : wff = mpg (step 4, step 6) |- ( ∀ x ph → ∀ y ps ) ;;
	qed prop 1 = step 7 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Andrew Salmon,
       25-May-2011.)  (Proof modification is discouraged.) */

theorem cbv3h (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → ∀ y ph ) ;;
	hyp 2 : wff = |- ( ps → ∀ x ps ) ;;
	hyp 3 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph → ∀ y ps ) ;;
}

proof of cbv3h {
	step 1 : wff = a1i (hyp 1) |- ( y = y → ( ph → ∀ y ph ) ) ;;
	step 2 : wff = a1i (hyp 2) |- ( y = y → ( ps → ∀ x ps ) ) ;;
	step 3 : wff = a1i (hyp 3) |- ( y = y → ( x = y → ( ph → ps ) ) ) ;;
	step 4 : wff = cbv1h (step 1, step 2, step 3) |- ( ∀ x ∀ y y = y → ( ∀ x ph → ∀ y ps ) ) ;;
	step 5 : wff = stdpc6 () |- ∀ y y = y ;;
	step 6 : wff = mpg (step 4, step 5) |- ( ∀ x ph → ∀ y ps ) ;;
	qed prop 1 = step 6 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       3-Oct-2016.) */

theorem cbval (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph ↔ ∀ y ps ) ;;
}

proof of cbval {
	step 1 : wff = biimpd (hyp 3) |- ( x = y → ( ph → ps ) ) ;;
	step 2 : wff = cbv3 (hyp 1, hyp 2, step 1) |- ( ∀ x ph → ∀ y ps ) ;;
	step 3 : wff = biimprd (hyp 3) |- ( x = y → ( ps → ph ) ) ;;
	step 4 : wff = equcoms (step 3) |- ( y = x → ( ps → ph ) ) ;;
	step 5 : wff = cbv3 (hyp 2, hyp 1, step 4) |- ( ∀ y ps → ∀ x ph ) ;;
	step 6 : wff = impbii (step 2, step 5) |- ( ∀ x ph ↔ ∀ y ps ) ;;
	qed prop 1 = step 6 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.) */

theorem cbvex (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- F/ x ps ;;
	hyp 3 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ph ↔ ∃ y ps ) ;;
}

proof of cbvex {
	step 1 : wff = nfn (hyp 1) |- F/ y ¬ ph ;;
	step 2 : wff = nfn (hyp 2) |- F/ x ¬ ps ;;
	step 3 : wff = notbid (hyp 3) |- ( x = y → ( ¬ ph ↔ ¬ ps ) ) ;;
	step 4 : wff = cbval (step 1, step 2, step 3) |- ( ∀ x ¬ ph ↔ ∀ y ¬ ps ) ;;
	step 5 : wff = notbii (step 4) |- ( ¬ ∀ x ¬ ph ↔ ¬ ∀ y ¬ ps ) ;;
	step 6 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 7 : wff = df-ex () |- ( ∃ y ps ↔ ¬ ∀ y ¬ ps ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( ∃ x ph ↔ ∃ y ps ) ;;
	qed prop 1 = step 8 ;;
}

/* Implicit substitution of ` y ` for ` x ` into a theorem.  (Contributed
       by Raph Levien, 9-Jul-2003.)  (Revised by Mario Carneiro,
       3-Oct-2016.) */

theorem chvar (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	hyp 3 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of chvar {
	step 1 : wff = biimpd (hyp 2) |- ( x = y → ( ph → ps ) ) ;;
	step 2 : wff = spim (hyp 1, step 1) |- ( ∀ x ph → ps ) ;;
	step 3 : wff = mpg (step 2, hyp 3) |- ps ;;
	qed prop 1 = step 3 ;;
}

/* A variable introduction law for equality.  Lemma 15 of [Monk2] p. 109,
     however we do not require ` z ` to be distinct from ` x ` and ` y `
     (making the proof longer).  (Contributed by NM, 5-Aug-1993.)  (Proof
     shortened by Andrew Salmon, 25-May-2011.) */

theorem equvini (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( x = y → ∃ z ( x = z ∧ z = y ) ) ;;
}

proof of equvini {
	step 1 : wff = equcomi () |- ( z = x → x = z ) ;;
	step 2 : wff = alimi (step 1) |- ( ∀ z z = x → ∀ z x = z ) ;;
	step 3 : wff = a9e () |- ∃ z z = y ;;
	step 4 : wff = jctir (step 2, step 3) |- ( ∀ z z = x → ( ∀ z x = z ∧ ∃ z z = y ) ) ;;
	step 5 : wff = a1d (step 4) |- ( ∀ z z = x → ( x = y → ( ∀ z x = z ∧ ∃ z z = y ) ) ) ;;
	step 6 : wff = 19.29 () |- ( ( ∀ z x = z ∧ ∃ z z = y ) → ∃ z ( x = z ∧ z = y ) ) ;;
	step 7 : wff = syl6 (step 5, step 6) |- ( ∀ z z = x → ( x = y → ∃ z ( x = z ∧ z = y ) ) ) ;;
	step 8 : wff = a9e () |- ∃ z z = x ;;
	step 9 : wff = equcomi () |- ( z = x → x = z ) ;;
	step 10 : wff = eximi (step 9) |- ( ∃ z z = x → ∃ z x = z ) ;;
	step 11 : wff = ax-mp (step 8, step 10) |- ∃ z x = z ;;
	step 12 : wff = a1ii (step 11) |- ( ∀ z z = y → ( x = y → ∃ z x = z ) ) ;;
	step 13 : wff = anc2ri (step 12) |- ( ∀ z z = y → ( x = y → ( ∃ z x = z ∧ ∀ z z = y ) ) ) ;;
	step 14 : wff = 19.29r () |- ( ( ∃ z x = z ∧ ∀ z z = y ) → ∃ z ( x = z ∧ z = y ) ) ;;
	step 15 : wff = syl6 (step 13, step 14) |- ( ∀ z z = y → ( x = y → ∃ z ( x = z ∧ z = y ) ) ) ;;
	step 16 : wff = ioran () |- ( ¬ ( ∀ z z = x ∨ ∀ z z = y ) ↔ ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ) ;;
	step 17 : wff = nfeqf () |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
	step 18 : wff = ax-8 () |- ( x = z → ( x = y → z = y ) ) ;;
	step 19 : wff = anc2li (step 18) |- ( x = z → ( x = y → ( x = z ∧ z = y ) ) ) ;;
	step 20 : wff = equcoms (step 19) |- ( z = x → ( x = y → ( x = z ∧ z = y ) ) ) ;;
	step 21 : wff = spimed (step 17, step 20) |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → ( x = y → ∃ z ( x = z ∧ z = y ) ) ) ;;
	step 22 : wff = sylbi (step 16, step 21) |- ( ¬ ( ∀ z z = x ∨ ∀ z z = y ) → ( x = y → ∃ z ( x = z ∧ z = y ) ) ) ;;
	step 23 : wff = ecase3 (step 7, step 15, step 22) |- ( x = y → ∃ z ( x = z ∧ z = y ) ) ;;
	qed prop 1 = step 23 ;;
}

/* A variable elimination law for equality with no distinct variable
     requirements.  (Compare ~ equvini .)  (Contributed by NM, 1-Mar-2013.)
     (Proof shortened by Mario Carneiro, 17-Oct-2016.) */

theorem equveli (x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ∀ z ( z = x ↔ z = y ) → x = y ) ;;
}

proof of equveli {
	step 1 : wff = albiim () |- ( ∀ z ( z = x ↔ z = y ) ↔ ( ∀ z ( z = x → z = y ) ∧ ∀ z ( z = y → z = x ) ) ) ;;
	step 2 : wff = equequ1 () |- ( z = y → ( z = y ↔ y = y ) ) ;;
	step 3 : wff = equequ1 () |- ( z = y → ( z = x ↔ y = x ) ) ;;
	step 4 : wff = imbi12d (step 2, step 3) |- ( z = y → ( ( z = y → z = x ) ↔ ( y = y → y = x ) ) ) ;;
	step 5 : wff = sps (step 4) |- ( ∀ z z = y → ( ( z = y → z = x ) ↔ ( y = y → y = x ) ) ) ;;
	step 6 : wff = dral1 (step 5) |- ( ∀ z z = y → ( ∀ z ( z = y → z = x ) ↔ ∀ y ( y = y → y = x ) ) ) ;;
	step 7 : wff = equid () |- y = y ;;
	step 8 : wff = sp () |- ( ∀ y ( y = y → y = x ) → ( y = y → y = x ) ) ;;
	step 9 : wff = mpi (step 7, step 8) |- ( ∀ y ( y = y → y = x ) → y = x ) ;;
	step 10 : wff = equcomi () |- ( y = x → x = y ) ;;
	step 11 : wff = syl (step 9, step 10) |- ( ∀ y ( y = y → y = x ) → x = y ) ;;
	step 12 : wff = syl6bi (step 6, step 11) |- ( ∀ z z = y → ( ∀ z ( z = y → z = x ) → x = y ) ) ;;
	step 13 : wff = adantld (step 12) |- ( ∀ z z = y → ( ( ∀ z ( z = x → z = y ) ∧ ∀ z ( z = y → z = x ) ) → x = y ) ) ;;
	step 14 : wff = equequ1 () |- ( z = x → ( z = x ↔ x = x ) ) ;;
	step 15 : wff = equequ1 () |- ( z = x → ( z = y ↔ x = y ) ) ;;
	step 16 : wff = imbi12d (step 14, step 15) |- ( z = x → ( ( z = x → z = y ) ↔ ( x = x → x = y ) ) ) ;;
	step 17 : wff = sps (step 16) |- ( ∀ z z = x → ( ( z = x → z = y ) ↔ ( x = x → x = y ) ) ) ;;
	step 18 : wff = dral2 (step 17) |- ( ∀ z z = x → ( ∀ z ( z = x → z = y ) ↔ ∀ z ( x = x → x = y ) ) ) ;;
	step 19 : wff = equid () |- x = x ;;
	step 20 : wff = a1bi (step 19) |- ( x = y ↔ ( x = x → x = y ) ) ;;
	step 21 : wff = biimpri (step 20) |- ( ( x = x → x = y ) → x = y ) ;;
	step 22 : wff = sps (step 21) |- ( ∀ z ( x = x → x = y ) → x = y ) ;;
	step 23 : wff = syl6bi (step 18, step 22) |- ( ∀ z z = x → ( ∀ z ( z = x → z = y ) → x = y ) ) ;;
	step 24 : wff = a1d (step 23) |- ( ∀ z z = x → ( ¬ ∀ z z = y → ( ∀ z ( z = x → z = y ) → x = y ) ) ) ;;
	step 25 : wff = nfeqf () |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
	step 26 : wff = equid () |- x = x ;;
	step 27 : wff = equtr () |- ( z = x → ( x = x → z = x ) ) ;;
	step 28 : wff = ax-8 () |- ( z = x → ( z = y → x = y ) ) ;;
	step 29 : wff = imim12d (step 27, step 28) |- ( z = x → ( ( z = x → z = y ) → ( x = x → x = y ) ) ) ;;
	step 30 : wff = mpii (step 26, step 29) |- ( z = x → ( ( z = x → z = y ) → x = y ) ) ;;
	step 31 : wff = ax-gen (step 30) |- ∀ z ( z = x → ( ( z = x → z = y ) → x = y ) ) ;;
	step 32 : wff = spimt () |- ( ( F/ z x = y ∧ ∀ z ( z = x → ( ( z = x → z = y ) → x = y ) ) ) → ( ∀ z ( z = x → z = y ) → x = y ) ) ;;
	step 33 : wff = sylancl (step 25, step 31, step 32) |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → ( ∀ z ( z = x → z = y ) → x = y ) ) ;;
	step 34 : wff = ex (step 33) |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( ∀ z ( z = x → z = y ) → x = y ) ) ) ;;
	step 35 : wff = pm2.61i (step 24, step 34) |- ( ¬ ∀ z z = y → ( ∀ z ( z = x → z = y ) → x = y ) ) ;;
	step 36 : wff = adantrd (step 35) |- ( ¬ ∀ z z = y → ( ( ∀ z ( z = x → z = y ) ∧ ∀ z ( z = y → z = x ) ) → x = y ) ) ;;
	step 37 : wff = pm2.61i (step 13, step 36) |- ( ( ∀ z ( z = x → z = y ) ∧ ∀ z ( z = y → z = x ) ) → x = y ) ;;
	step 38 : wff = sylbi (step 1, step 37) |- ( ∀ z ( z = x ↔ z = y ) → x = y ) ;;
	qed prop 1 = step 38 ;;
}

/* Two ways of expressing substitution when ` y ` is not free in ` ph ` .
       (Contributed by NM, 25-Apr-2008.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem equs45f (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
}

proof of equs45f {
	step 1 : wff = nfri (hyp 1) |- ( ph → ∀ y ph ) ;;
	step 2 : wff = anim2i (step 1) |- ( ( x = y ∧ ph ) → ( x = y ∧ ∀ y ph ) ) ;;
	step 3 : wff = eximi (step 2) |- ( ∃ x ( x = y ∧ ph ) → ∃ x ( x = y ∧ ∀ y ph ) ) ;;
	step 4 : wff = equs5a () |- ( ∃ x ( x = y ∧ ∀ y ph ) → ∀ x ( x = y → ph ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ∃ x ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ;;
	step 6 : wff = equs4 () |- ( ∀ x ( x = y → ph ) → ∃ x ( x = y ∧ ph ) ) ;;
	step 7 : wff = impbii (step 5, step 6) |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* A version of ~ spim with a distinct variable requirement instead of a
       bound variable hypothesis.  (Contributed by NM, 5-Aug-1993.) */

theorem spimv (ph : wff, ps : wff, x : set, y : set) disjointed(x ps) {
	hyp 1 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph → ps ) ;;
}

proof of spimv {
	step 1 : wff = nfv () |- F/ x ps ;;
	step 2 : wff = spim (step 1, hyp 1) |- ( ∀ x ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* A "distinctor elimination" lemma with no restrictions on variables in
       the consequent.  (Contributed by NM, 8-Nov-2006.) */

theorem aev (x : set, y : set, z : set, w : set, v : set) disjointed(u v, u x y, u w) {
	prop 1 : wff = |- ( ∀ x x = y → ∀ z w = v ) ;;
}

proof of aev {
	var u : set;;
	step 1 : wff = hbae () |- ( ∀ x x = y → ∀ z ∀ x x = y ) ;;
	step 2 : wff = ax10lem5 () |- ( ∀ x x = y → ∀ u u = v ) ;;
	step 3 : wff = ax-8 () |- ( u = w → ( u = v → w = v ) ) ;;
	step 4 : wff = spimv (step 3) |- ( ∀ u u = v → w = v ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( ∀ x x = y → w = v ) ;;
	step 6 : wff = alrimih (step 1, step 5) |- ( ∀ x x = y → ∀ z w = v ) ;;
	qed prop 1 = step 6 ;;
}

/* Recovery of ~ ax-11o from ~ ax11v .  This proof uses ~ ax-10 and
       ~ ax-11 .  TODO: figure out if this is useful, or if it should be
       simplified or eliminated.  (Contributed by NM, 2-Feb-2007.) */

theorem ax11v2 (ph : wff, x : set, y : set, z : set) disjointed(x z, y z, z ph) {
	hyp 1 : wff = |- ( x = z → ( ph → ∀ x ( x = z → ph ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
}

proof of ax11v2 {
	step 1 : wff = a9ev () |- ∃ z z = y ;;
	step 2 : wff = equequ2 () |- ( z = y → ( x = z ↔ x = y ) ) ;;
	step 3 : wff = adantl (step 2) |- ( ( ¬ ∀ x x = y ∧ z = y ) → ( x = z ↔ x = y ) ) ;;
	step 4 : wff = dveeq2 () |- ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( ¬ ∀ x x = y ∧ z = y ) → ∀ x z = y ) ;;
	step 6 : wff = nfa1 () |- F/ x ∀ x z = y ;;
	step 7 : wff = equequ2 () |- ( z = y → ( x = z ↔ x = y ) ) ;;
	step 8 : wff = imbi1d (step 7) |- ( z = y → ( ( x = z → ph ) ↔ ( x = y → ph ) ) ) ;;
	step 9 : wff = sps (step 8) |- ( ∀ x z = y → ( ( x = z → ph ) ↔ ( x = y → ph ) ) ) ;;
	step 10 : wff = albid (step 6, step 9) |- ( ∀ x z = y → ( ∀ x ( x = z → ph ) ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 11 : wff = syl (step 5, step 10) |- ( ( ¬ ∀ x x = y ∧ z = y ) → ( ∀ x ( x = z → ph ) ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 12 : wff = imbi2d (step 11) |- ( ( ¬ ∀ x x = y ∧ z = y ) → ( ( ph → ∀ x ( x = z → ph ) ) ↔ ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	step 13 : wff = imbi12d (step 3, step 12) |- ( ( ¬ ∀ x x = y ∧ z = y ) → ( ( x = z → ( ph → ∀ x ( x = z → ph ) ) ) ↔ ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ) ;;
	step 14 : wff = mpbii (hyp 1, step 13) |- ( ( ¬ ∀ x x = y ∧ z = y ) → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	step 15 : wff = ex (step 14) |- ( ¬ ∀ x x = y → ( z = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ) ;;
	step 16 : wff = exlimdv (step 15) |- ( ¬ ∀ x x = y → ( ∃ z z = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ) ;;
	step 17 : wff = mpi (step 1, step 16) |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Derive ~ ax-11o from a hypothesis in the form of ~ ax-11 . ~ ax-10 and
       ~ ax-11 are used by the proof, but not ~ ax-10o or ~ ax-11o .  TODO:
       figure out if this is useful, or if it should be simplified or
       eliminated.  (Contributed by NM, 2-Feb-2007.) */

theorem ax11a2 (ph : wff, x : set, y : set, z : set) disjointed(x z, y z, z ph) {
	hyp 1 : wff = |- ( x = z → ( ∀ z ph → ∀ x ( x = z → ph ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
}

proof of ax11a2 {
	step 1 : wff = ax-17 () |- ( ph → ∀ z ph ) ;;
	step 2 : wff = syl5 (step 1, hyp 1) |- ( x = z → ( ph → ∀ x ( x = z → ph ) ) ) ;;
	step 3 : wff = ax11v2 (step 2) |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Derivation of set.mm's original ~ ax-11o from ~ ax-10 and the shorter
       ~ ax-11 that has replaced it.

       An open problem is whether this theorem can be proved without relying on
       ~ ax-16 or ~ ax-17 (given all of the original and new versions of ~ sp
       through ~ ax-15 ).

       Another open problem is whether this theorem can be proved without
       relying on ~ ax12o .

       Theorem ~ ax11 shows the reverse derivation of ~ ax-11 from ~ ax-11o .

       Normally, ~ ax11o should be used rather than ~ ax-11o , except by
       theorems specifically studying the latter's properties.  (Contributed by
       NM, 3-Feb-2007.) */

theorem ax11o (ph : wff, x : set, y : set) disjointed(x z, y z, z ph) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
}

proof of ax11o {
	var z : set;;
	step 1 : wff = ax-11 () |- ( x = z → ( ∀ z ph → ∀ x ( x = z → ph ) ) ) ;;
	step 2 : wff = ax11a2 (step 1) |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* A bidirectional version of ~ ax11o .  (Contributed by NM, 30-Jun-2006.) */

theorem ax11b (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ( ¬ ∀ x x = y ∧ x = y ) → ( ph ↔ ∀ x ( x = y → ph ) ) ) ;;
}

proof of ax11b {
	step 1 : wff = ax11o () |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	step 2 : wff = imp (step 1) |- ( ( ¬ ∀ x x = y ∧ x = y ) → ( ph → ∀ x ( x = y → ph ) ) ) ;;
	step 3 : wff = sp () |- ( ∀ x ( x = y → ph ) → ( x = y → ph ) ) ;;
	step 4 : wff = com12 (step 3) |- ( x = y → ( ∀ x ( x = y → ph ) → ph ) ) ;;
	step 5 : wff = adantl (step 4) |- ( ( ¬ ∀ x x = y ∧ x = y ) → ( ∀ x ( x = y → ph ) → ph ) ) ;;
	step 6 : wff = impbid (step 2, step 5) |- ( ( ¬ ∀ x x = y ∧ x = y ) → ( ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Lemma used in proofs of substitution properties.  (Contributed by NM,
     5-Aug-1993.) */

theorem equs5 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ∃ x ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
}

proof of equs5 {
	step 1 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ( x = y → ph ) ;;
	step 3 : wff = ax11o () |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	step 4 : wff = imp3a (step 3) |- ( ¬ ∀ x x = y → ( ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	step 5 : wff = exlimd (step 1, step 2, step 4) |- ( ¬ ∀ x x = y → ( ∃ x ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Version of ~ dvelimv without any variable restrictions.  (Contributed by
       NM, 1-Oct-2002.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem dvelimf (ph : wff, ps : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ z ps ;;
	hyp 3 : wff = |- ( z = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → F/ x ps ) ;;
}

proof of dvelimf {
	step 1 : wff = equsal (hyp 2, hyp 3) |- ( ∀ z ( z = y → ph ) ↔ ps ) ;;
	step 2 : wff = bicomi (step 1) |- ( ps ↔ ∀ z ( z = y → ph ) ) ;;
	step 3 : wff = nfnae () |- F/ z ¬ ∀ x x = y ;;
	step 4 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 5 : wff = nfnae () |- F/ x ¬ ∀ x x = z ;;
	step 6 : wff = nfan (step 4, step 5) |- F/ x ( ¬ ∀ x x = y ∧ ¬ ∀ x x = z ) ;;
	step 7 : wff = ax12o () |- ( ¬ ∀ x x = z → ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ) ;;
	step 8 : wff = impcom (step 7) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ x x = z ) → ( z = y → ∀ x z = y ) ) ;;
	step 9 : wff = nfd (step 6, step 8) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ x x = z ) → F/ x z = y ) ;;
	step 10 : wff = a1i (hyp 1) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ x x = z ) → F/ x ph ) ;;
	step 11 : wff = nfimd (step 9, step 10) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ x x = z ) → F/ x ( z = y → ph ) ) ;;
	step 12 : wff = nfald2 (step 3, step 11) |- ( ¬ ∀ x x = y → F/ x ∀ z ( z = y → ph ) ) ;;
	step 13 : wff = nfxfrd (step 2, step 12) |- ( ¬ ∀ x x = y → F/ x ps ) ;;
	qed prop 1 = step 13 ;;
}

/* Specialization, using implicit substitution.  (Contributed by NM,
       30-Aug-1993.) */

theorem spv (ph : wff, ps : wff, x : set, y : set) disjointed(x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph → ps ) ;;
}

proof of spv {
	step 1 : wff = biimpd (hyp 1) |- ( x = y → ( ph → ps ) ) ;;
	step 2 : wff = spimv (step 1) |- ( ∀ x ph → ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Distinct-variable version of ~ spime .  (Contributed by NM,
       5-Aug-1993.) */

theorem spimev (ph : wff, ps : wff, x : set, y : set) disjointed(x ph) {
	hyp 1 : wff = |- ( x = y → ( ph → ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ∃ x ps ) ;;
}

proof of spimev {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = spime (step 1, hyp 1) |- ( ph → ∃ x ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Inference from existential specialization, using implicit substitution.
       (Contributed by NM, 19-Aug-1993.) */

theorem speiv (ph : wff, ps : wff, x : set, y : set) disjointed(x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ps ;;
	-----------------------
	prop 1 : wff = |- ∃ x ph ;;
}

proof of speiv {
	step 1 : wff = biimprd (hyp 1) |- ( x = y → ( ps → ph ) ) ;;
	step 2 : wff = spimev (step 1) |- ( ps → ∃ x ph ) ;;
	step 3 : wff = ax-mp (hyp 2, step 2) |- ∃ x ph ;;
	qed prop 1 = step 3 ;;
}

/* A variable introduction law for equality.  Lemma 15 of [Monk2] p. 109.
       (Contributed by NM, 5-Aug-1993.) */

theorem equvin (x : set, y : set, z : set) disjointed(x z, y z) {
	prop 1 : wff = |- ( x = y ↔ ∃ z ( x = z ∧ z = y ) ) ;;
}

proof of equvin {
	step 1 : wff = equvini () |- ( x = y → ∃ z ( x = z ∧ z = y ) ) ;;
	step 2 : wff = equtr () |- ( x = z → ( z = y → x = y ) ) ;;
	step 3 : wff = imp (step 2) |- ( ( x = z ∧ z = y ) → x = y ) ;;
	step 4 : wff = exlimiv (step 3) |- ( ∃ z ( x = z ∧ z = y ) → x = y ) ;;
	step 5 : wff = impbii (step 1, step 4) |- ( x = y ↔ ∃ z ( x = z ∧ z = y ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.) */

theorem cbvalv (ph : wff, ps : wff, x : set, y : set) disjointed(y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph ↔ ∀ y ps ) ;;
}

proof of cbvalv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbval (step 1, step 2, hyp 1) |- ( ∀ x ph ↔ ∀ y ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 5-Aug-1993.) */

theorem cbvexv (ph : wff, ps : wff, x : set, y : set) disjointed(y ph, x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ph ↔ ∃ y ps ) ;;
}

proof of cbvexv {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfv () |- F/ x ps ;;
	step 3 : wff = cbvex (step 1, step 2, hyp 1) |- ( ∃ x ph ↔ ∃ y ps ) ;;
	qed prop 1 = step 3 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 22-Dec-2003.)  (Revised by Mario Carneiro,
       6-Oct-2016.) */

theorem cbval2 (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(y x, y z, w x, w z) {
	hyp 1 : wff = |- F/ z ph ;;
	hyp 2 : wff = |- F/ w ph ;;
	hyp 3 : wff = |- F/ x ps ;;
	hyp 4 : wff = |- F/ y ps ;;
	hyp 5 : wff = |- ( ( x = z ∧ y = w ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∀ y ph ↔ ∀ z ∀ w ps ) ;;
}

proof of cbval2 {
	step 1 : wff = nfal (hyp 1) |- F/ z ∀ y ph ;;
	step 2 : wff = nfal (hyp 3) |- F/ x ∀ w ps ;;
	step 3 : wff = nfv () |- F/ w x = z ;;
	step 4 : wff = nfan (step 3, hyp 2) |- F/ w ( x = z ∧ ph ) ;;
	step 5 : wff = nfv () |- F/ y x = z ;;
	step 6 : wff = nfan (step 5, hyp 4) |- F/ y ( x = z ∧ ps ) ;;
	step 7 : wff = expcom (hyp 5) |- ( y = w → ( x = z → ( ph ↔ ps ) ) ) ;;
	step 8 : wff = pm5.32d (step 7) |- ( y = w → ( ( x = z ∧ ph ) ↔ ( x = z ∧ ps ) ) ) ;;
	step 9 : wff = cbval (step 4, step 6, step 8) |- ( ∀ y ( x = z ∧ ph ) ↔ ∀ w ( x = z ∧ ps ) ) ;;
	step 10 : wff = 19.28v () |- ( ∀ y ( x = z ∧ ph ) ↔ ( x = z ∧ ∀ y ph ) ) ;;
	step 11 : wff = 19.28v () |- ( ∀ w ( x = z ∧ ps ) ↔ ( x = z ∧ ∀ w ps ) ) ;;
	step 12 : wff = 3bitr3i (step 9, step 10, step 11) |- ( ( x = z ∧ ∀ y ph ) ↔ ( x = z ∧ ∀ w ps ) ) ;;
	step 13 : wff = pm5.32 () |- ( ( x = z → ( ∀ y ph ↔ ∀ w ps ) ) ↔ ( ( x = z ∧ ∀ y ph ) ↔ ( x = z ∧ ∀ w ps ) ) ) ;;
	step 14 : wff = mpbir (step 12, step 13) |- ( x = z → ( ∀ y ph ↔ ∀ w ps ) ) ;;
	step 15 : wff = cbval (step 1, step 2, step 14) |- ( ∀ x ∀ y ph ↔ ∀ z ∀ w ps ) ;;
	qed prop 1 = step 15 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 14-Sep-2003.)  (Revised by Mario Carneiro,
       6-Oct-2016.) */

theorem cbvex2 (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(y x, y z, w x, w z) {
	hyp 1 : wff = |- F/ z ph ;;
	hyp 2 : wff = |- F/ w ph ;;
	hyp 3 : wff = |- F/ x ps ;;
	hyp 4 : wff = |- F/ y ps ;;
	hyp 5 : wff = |- ( ( x = z ∧ y = w ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ps ) ;;
}

proof of cbvex2 {
	step 1 : wff = nfex (hyp 1) |- F/ z ∃ y ph ;;
	step 2 : wff = nfex (hyp 3) |- F/ x ∃ w ps ;;
	step 3 : wff = nfv () |- F/ w x = z ;;
	step 4 : wff = nfan (step 3, hyp 2) |- F/ w ( x = z ∧ ph ) ;;
	step 5 : wff = nfv () |- F/ y x = z ;;
	step 6 : wff = nfan (step 5, hyp 4) |- F/ y ( x = z ∧ ps ) ;;
	step 7 : wff = expcom (hyp 5) |- ( y = w → ( x = z → ( ph ↔ ps ) ) ) ;;
	step 8 : wff = pm5.32d (step 7) |- ( y = w → ( ( x = z ∧ ph ) ↔ ( x = z ∧ ps ) ) ) ;;
	step 9 : wff = cbvex (step 4, step 6, step 8) |- ( ∃ y ( x = z ∧ ph ) ↔ ∃ w ( x = z ∧ ps ) ) ;;
	step 10 : wff = 19.42v () |- ( ∃ y ( x = z ∧ ph ) ↔ ( x = z ∧ ∃ y ph ) ) ;;
	step 11 : wff = 19.42v () |- ( ∃ w ( x = z ∧ ps ) ↔ ( x = z ∧ ∃ w ps ) ) ;;
	step 12 : wff = 3bitr3i (step 9, step 10, step 11) |- ( ( x = z ∧ ∃ y ph ) ↔ ( x = z ∧ ∃ w ps ) ) ;;
	step 13 : wff = pm5.32 () |- ( ( x = z → ( ∃ y ph ↔ ∃ w ps ) ) ↔ ( ( x = z ∧ ∃ y ph ) ↔ ( x = z ∧ ∃ w ps ) ) ) ;;
	step 14 : wff = mpbir (step 12, step 13) |- ( x = z → ( ∃ y ph ↔ ∃ w ps ) ) ;;
	step 15 : wff = cbvex (step 1, step 2, step 14) |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ps ) ;;
	qed prop 1 = step 15 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 4-Feb-2005.) */

theorem cbval2v (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(z w ph, x y ps, x w, z y) {
	hyp 1 : wff = |- ( ( x = z ∧ y = w ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ∀ y ph ↔ ∀ z ∀ w ps ) ;;
}

proof of cbval2v {
	step 1 : wff = nfv () |- F/ z ph ;;
	step 2 : wff = nfv () |- F/ w ph ;;
	step 3 : wff = nfv () |- F/ x ps ;;
	step 4 : wff = nfv () |- F/ y ps ;;
	step 5 : wff = cbval2 (step 1, step 2, step 3, step 4, hyp 1) |- ( ∀ x ∀ y ph ↔ ∀ z ∀ w ps ) ;;
	qed prop 1 = step 5 ;;
}

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 26-Jul-1995.) */

theorem cbvex2v (ph : wff, ps : wff, x : set, y : set, z : set, w : set) disjointed(z w ph, x y ps, x w, z y) {
	hyp 1 : wff = |- ( ( x = z ∧ y = w ) → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ps ) ;;
}

proof of cbvex2v {
	step 1 : wff = nfv () |- F/ z ph ;;
	step 2 : wff = nfv () |- F/ w ph ;;
	step 3 : wff = nfv () |- F/ x ps ;;
	step 4 : wff = nfv () |- F/ y ps ;;
	step 5 : wff = cbvex2 (step 1, step 2, step 3, step 4, hyp 1) |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ps ) ;;
	qed prop 1 = step 5 ;;
}

/* Deduction used to change bound variables, using implicit substitution,
       particularly useful in conjunction with ~ dvelim .  (Contributed by NM,
       2-Jan-2002.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem cbvald (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x ph, x ch) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/ y ps ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
}

proof of cbvald {
	step 1 : wff = nfri (hyp 1) |- ( ph → ∀ y ph ) ;;
	step 2 : wff = alrimiv (step 1) |- ( ph → ∀ x ∀ y ph ) ;;
	step 3 : wff = nfvd () |- ( ph → F/ x ch ) ;;
	step 4 : wff = cbv2 (hyp 2, step 3, hyp 3) |- ( ∀ x ∀ y ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
	step 5 : wff = syl (step 2, step 4) |- ( ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Deduction used to change bound variables, using implicit substitution,
       particularly useful in conjunction with ~ dvelim .  (Contributed by NM,
       2-Jan-2002.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem cbvexd (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x ph, x ch) {
	hyp 1 : wff = |- F/ y ph ;;
	hyp 2 : wff = |- ( ph → F/ y ps ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ps ↔ ∃ y ch ) ) ;;
}

proof of cbvexd {
	step 1 : wff = nfnd (hyp 2) |- ( ph → F/ y ¬ ps ) ;;
	step 2 : wff = notbi () |- ( ( ps ↔ ch ) ↔ ( ¬ ps ↔ ¬ ch ) ) ;;
	step 3 : wff = syl6ib (hyp 3, step 2) |- ( ph → ( x = y → ( ¬ ps ↔ ¬ ch ) ) ) ;;
	step 4 : wff = cbvald (hyp 1, step 1, step 3) |- ( ph → ( ∀ x ¬ ps ↔ ∀ y ¬ ch ) ) ;;
	step 5 : wff = notbid (step 4) |- ( ph → ( ¬ ∀ x ¬ ps ↔ ¬ ∀ y ¬ ch ) ) ;;
	step 6 : wff = df-ex () |- ( ∃ x ps ↔ ¬ ∀ x ¬ ps ) ;;
	step 7 : wff = df-ex () |- ( ∃ y ch ↔ ¬ ∀ y ¬ ch ) ;;
	step 8 : wff = 3bitr4g (step 5, step 6, step 7) |- ( ph → ( ∃ x ps ↔ ∃ y ch ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Rule used to change the bound variable in a universal quantifier with
       implicit substitution.  Deduction form.  (Contributed by David Moews,
       1-May-2017.) */

theorem cbvaldva (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(ps y, ch x, ph x, ph y) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
}

proof of cbvaldva {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfvd () |- ( ph → F/ y ps ) ;;
	step 3 : wff = ex (hyp 1) |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	step 4 : wff = cbvald (step 1, step 2, step 3) |- ( ph → ( ∀ x ps ↔ ∀ y ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Rule used to change the bound variable in an existential quantifier with
       implicit substitution.  Deduction form.  (Contributed by David Moews,
       1-May-2017.) */

theorem cbvexdva (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(ps y, ch x, ph x, ph y) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ∃ x ps ↔ ∃ y ch ) ) ;;
}

proof of cbvexdva {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfvd () |- ( ph → F/ y ps ) ;;
	step 3 : wff = ex (hyp 1) |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	step 4 : wff = cbvexd (step 1, step 2, step 3) |- ( ph → ( ∃ x ps ↔ ∃ y ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Define temporary individual variables. */

/* Rule used to change bound variables, using implicit substitution.
       (Contributed by NM, 26-Jul-1995.) */

theorem cbvex4v (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set, w : set, v : set, u : set, f : set, g : set) disjointed(w z ch, u v ph, x y ps, f g ps, f w, g z, u v w x y z) {
	hyp 1 : wff = |- ( ( x = v ∧ y = u ) → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( ( z = f ∧ w = g ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ∃ y ∃ z ∃ w ph ↔ ∃ v ∃ u ∃ f ∃ g ch ) ;;
}

proof of cbvex4v {
	step 1 : wff = 2exbidv (hyp 1) |- ( ( x = v ∧ y = u ) → ( ∃ z ∃ w ph ↔ ∃ z ∃ w ps ) ) ;;
	step 2 : wff = cbvex2v (step 1) |- ( ∃ x ∃ y ∃ z ∃ w ph ↔ ∃ v ∃ u ∃ z ∃ w ps ) ;;
	step 3 : wff = cbvex2v (hyp 2) |- ( ∃ z ∃ w ps ↔ ∃ f ∃ g ch ) ;;
	step 4 : wff = 2exbii (step 3) |- ( ∃ v ∃ u ∃ z ∃ w ps ↔ ∃ v ∃ u ∃ f ∃ g ch ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∃ x ∃ y ∃ z ∃ w ph ↔ ∃ v ∃ u ∃ f ∃ g ch ) ;;
	qed prop 1 = step 5 ;;
}

/* Implicit substitution of ` y ` for ` x ` into a theorem.  (Contributed
       by NM, 20-Apr-1994.) */

theorem chvarv (ph : wff, ps : wff, x : set, y : set) disjointed(x ps) {
	hyp 1 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- ps ;;
}

proof of chvarv {
	step 1 : wff = spv (hyp 1) |- ( ∀ x ph → ps ) ;;
	step 2 : wff = mpg (step 1, hyp 2) |- ps ;;
	qed prop 1 = step 2 ;;
}

/* When the class variables in definition ~ df-clel are replaced with set
       variables, this theorem of predicate calculus is the result.  This
       theorem provides part of the justification for the consistency of that
       definition, which "overloads" the set variables in ~ wel with the class
       variables in ~ wcel .  Note:  This proof is referenced on the Metamath
       Proof Explorer Home Page and shouldn't be changed.  (Contributed by NM,
       28-Jan-2004.)  (Proof modification is discouraged.) */

theorem cleljust (x : set, y : set, z : set) disjointed(x z, y z) {
	prop 1 : wff = |- ( x ∈ y ↔ ∃ z ( z = x ∧ z ∈ y ) ) ;;
}

proof of cleljust {
	step 1 : wff = ax-17 () |- ( x ∈ y → ∀ z x ∈ y ) ;;
	step 2 : wff = elequ1 () |- ( z = x → ( z ∈ y ↔ x ∈ y ) ) ;;
	step 3 : wff = equsexh (step 1, step 2) |- ( ∃ z ( z = x ∧ z ∈ y ) ↔ x ∈ y ) ;;
	step 4 : wff = bicomi (step 3) |- ( x ∈ y ↔ ∃ z ( z = x ∧ z ∈ y ) ) ;;
	qed prop 1 = step 4 ;;
}

/* When the class variables in definition ~ df-clel are replaced with set
       variables, this theorem of predicate calculus is the result.  This
       theorem provides part of the justification for the consistency of that
       definition, which "overloads" the set variables in ~ wel with the class
       variables in ~ wcel .  (Contributed by NM, 28-Jan-2004.)  (Revised by
       Mario Carneiro, 21-Dec-2016.) */

theorem cleljustALT (x : set, y : set, z : set) disjointed(x z, y z) {
	prop 1 : wff = |- ( x ∈ y ↔ ∃ z ( z = x ∧ z ∈ y ) ) ;;
}

proof of cleljustALT {
	step 1 : wff = nfv () |- F/ z x ∈ y ;;
	step 2 : wff = elequ1 () |- ( z = x → ( z ∈ y ↔ x ∈ y ) ) ;;
	step 3 : wff = equsex (step 1, step 2) |- ( ∃ z ( z = x ∧ z ∈ y ) ↔ x ∈ y ) ;;
	step 4 : wff = bicomi (step 3) |- ( x ∈ y ↔ ∃ z ( z = x ∧ z ∈ y ) ) ;;
	qed prop 1 = step 4 ;;
}

/* This theorem can be used to eliminate a distinct variable restriction on
       ` x ` and ` z ` and replace it with the "distinctor" ` -. A. x x = y `
       as an antecedent. ` ph ` normally has ` z ` free and can be read
       ` ph ( z ) ` , and ` ps ` substitutes ` y ` for ` z ` and can be read
       ` ph ( y ) ` .  We don't require that ` x ` and ` y ` be distinct: if
       they aren't, the distinctor will become false (in multiple-element
       domains of discourse) and "protect" the consequent.

       To obtain a closed-theorem form of this inference, prefix the hypotheses
       with ` A. x A. z ` , conjoin them, and apply ~ dvelimdf .

       Other variants of this theorem are ~ dvelimh (with no distinct variable
       restrictions), ~ dvelimhw (that avoids ~ ax-12 ), and ~ dvelimALT (that
       avoids ~ ax-10 ).  (Contributed by NM, 23-Nov-1994.) */

theorem dvelim (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(z ps) {
	hyp 1 : wff = |- ( ph → ∀ x ph ) ;;
	hyp 2 : wff = |- ( z = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
}

proof of dvelim {
	step 1 : wff = ax-17 () |- ( ps → ∀ z ps ) ;;
	step 2 : wff = dvelimh (hyp 1, step 1, hyp 2) |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Version of ~ dvelim using "not free" notation.  (Contributed by Mario
       Carneiro, 9-Oct-2016.) */

theorem dvelimnf (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(z ps) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( z = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → F/ x ps ) ;;
}

proof of dvelimnf {
	step 1 : wff = nfv () |- F/ z ps ;;
	step 2 : wff = dvelimf (hyp 1, step 1, hyp 2) |- ( ¬ ∀ x x = y → F/ x ps ) ;;
	qed prop 1 = step 2 ;;
}

/* Quantifier introduction when one pair of variables is distinct.
       (Contributed by NM, 2-Jan-2002.) */

theorem dveeq1 (x : set, y : set, z : set) disjointed(w z x, w y) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( y = z → ∀ x y = z ) ) ;;
}

proof of dveeq1 {
	var w : set;;
	step 1 : wff = equequ1 () |- ( w = y → ( w = z ↔ y = z ) ) ;;
	step 2 : wff = dvelimv (step 1) |- ( ¬ ∀ x x = y → ( y = z → ∀ x y = z ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Quantifier introduction when one pair of variables is distinct.
       (Contributed by NM, 2-Jan-2002.) */

theorem dveel1 (x : set, y : set, z : set) disjointed(w z x, w y) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( y ∈ z → ∀ x y ∈ z ) ) ;;
}

proof of dveel1 {
	var w : set;;
	step 1 : wff = elequ1 () |- ( w = y → ( w ∈ z ↔ y ∈ z ) ) ;;
	step 2 : wff = dvelimv (step 1) |- ( ¬ ∀ x x = y → ( y ∈ z → ∀ x y ∈ z ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Quantifier introduction when one pair of variables is distinct.
       (Contributed by NM, 2-Jan-2002.) */

theorem dveel2 (x : set, y : set, z : set) disjointed(w z x, w y) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( z ∈ y → ∀ x z ∈ y ) ) ;;
}

proof of dveel2 {
	var w : set;;
	step 1 : wff = elequ2 () |- ( w = y → ( z ∈ w ↔ z ∈ y ) ) ;;
	step 2 : wff = dvelimv (step 1) |- ( ¬ ∀ x x = y → ( z ∈ y → ∀ x z ∈ y ) ) ;;
	qed prop 1 = step 2 ;;
}

/* ` w ` is dummy. */

/* Axiom ~ ax-15 is redundant if we assume ~ ax-17 .  Remark 9.6 in
       [Megill] p. 448 (p. 16 of the preprint), regarding axiom scheme C14'.

       Note that ` w ` is a dummy variable introduced in the proof.  On the web
       page, it is implicitly assumed to be distinct from all other variables.
       (This is made explicit in the database file set.mm).  Its purpose is to
       satisfy the distinct variable requirements of ~ dveel2 and ~ ax-17 .  By
       the end of the proof it has vanished, and the final theorem has no
       distinct variable requirements.  (Contributed by NM, 29-Jun-1995.)
       (Proof modification is discouraged.) */

theorem ax15 (x : set, y : set, z : set) disjointed(w y, w z, w x) {
	prop 1 : wff = |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x ∈ y → ∀ z x ∈ y ) ) ) ;;
}

proof of ax15 {
	var w : set;;
	step 1 : wff = hbn1 () |- ( ¬ ∀ z z = y → ∀ z ¬ ∀ z z = y ) ;;
	step 2 : wff = dveel2 () |- ( ¬ ∀ z z = y → ( w ∈ y → ∀ z w ∈ y ) ) ;;
	step 3 : wff = hbim1 (step 1, step 2) |- ( ( ¬ ∀ z z = y → w ∈ y ) → ∀ z ( ¬ ∀ z z = y → w ∈ y ) ) ;;
	step 4 : wff = elequ1 () |- ( w = x → ( w ∈ y ↔ x ∈ y ) ) ;;
	step 5 : wff = imbi2d (step 4) |- ( w = x → ( ( ¬ ∀ z z = y → w ∈ y ) ↔ ( ¬ ∀ z z = y → x ∈ y ) ) ) ;;
	step 6 : wff = dvelim (step 3, step 5) |- ( ¬ ∀ z z = x → ( ( ¬ ∀ z z = y → x ∈ y ) → ∀ z ( ¬ ∀ z z = y → x ∈ y ) ) ) ;;
	step 7 : wff = nfa1 () |- F/ z ∀ z z = y ;;
	step 8 : wff = nfn (step 7) |- F/ z ¬ ∀ z z = y ;;
	step 9 : wff = 19.21 (step 8) |- ( ∀ z ( ¬ ∀ z z = y → x ∈ y ) ↔ ( ¬ ∀ z z = y → ∀ z x ∈ y ) ) ;;
	step 10 : wff = syl6ib (step 6, step 9) |- ( ¬ ∀ z z = x → ( ( ¬ ∀ z z = y → x ∈ y ) → ( ¬ ∀ z z = y → ∀ z x ∈ y ) ) ) ;;
	step 11 : wff = pm2.86d (step 10) |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x ∈ y → ∀ z x ∈ y ) ) ) ;;
	qed prop 1 = step 11 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
     Part of Theorem 9.4 of [Megill] p. 448 (p. 16 of preprint).  (Contributed
     by NM, 5-Aug-1993.) */

theorem drsb1 (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ∀ x x = y → ( [ z / x ] ph ↔ [ z / y ] ph ) ) ;;
}

proof of drsb1 {
	step 1 : wff = equequ1 () |- ( x = y → ( x = z ↔ y = z ) ) ;;
	step 2 : wff = sps (step 1) |- ( ∀ x x = y → ( x = z ↔ y = z ) ) ;;
	step 3 : wff = imbi1d (step 2) |- ( ∀ x x = y → ( ( x = z → ph ) ↔ ( y = z → ph ) ) ) ;;
	step 4 : wff = equequ1 () |- ( x = y → ( x = z ↔ y = z ) ) ;;
	step 5 : wff = sps (step 4) |- ( ∀ x x = y → ( x = z ↔ y = z ) ) ;;
	step 6 : wff = anbi1d (step 5) |- ( ∀ x x = y → ( ( x = z ∧ ph ) ↔ ( y = z ∧ ph ) ) ) ;;
	step 7 : wff = drex1 (step 6) |- ( ∀ x x = y → ( ∃ x ( x = z ∧ ph ) ↔ ∃ y ( y = z ∧ ph ) ) ) ;;
	step 8 : wff = anbi12d (step 3, step 7) |- ( ∀ x x = y → ( ( ( x = z → ph ) ∧ ∃ x ( x = z ∧ ph ) ) ↔ ( ( y = z → ph ) ∧ ∃ y ( y = z ∧ ph ) ) ) ) ;;
	step 9 : wff = df-sb () |- ( [ z / x ] ph ↔ ( ( x = z → ph ) ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
	step 10 : wff = df-sb () |- ( [ z / y ] ph ↔ ( ( y = z → ph ) ∧ ∃ y ( y = z ∧ ph ) ) ) ;;
	step 11 : wff = 3bitr4g (step 8, step 9, step 10) |- ( ∀ x x = y → ( [ z / x ] ph ↔ [ z / y ] ph ) ) ;;
	qed prop 1 = step 11 ;;
}

/* One direction of a simplified definition of substitution.  (Contributed by
     NM, 5-Aug-1993.) */

theorem sb2 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
}

proof of sb2 {
	step 1 : wff = sp () |- ( ∀ x ( x = y → ph ) → ( x = y → ph ) ) ;;
	step 2 : wff = equs4 () |- ( ∀ x ( x = y → ph ) → ∃ x ( x = y ∧ ph ) ) ;;
	step 3 : wff = df-sb () |- ( [ y / x ] ph ↔ ( ( x = y → ph ) ∧ ∃ x ( x = y ∧ ph ) ) ) ;;
	step 4 : wff = sylanbrc (step 1, step 2, step 3) |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	qed prop 1 = step 4 ;;
}

/* The specialization axiom of standard predicate calculus.  It states that
     if a statement ` ph ` holds for all ` x ` , then it also holds for the
     specific case of ` y ` (properly) substituted for ` x ` .  Translated to
     traditional notation, it can be read:  " ` A. x ph ( x ) -> ph ( y ) ` ,
     provided that ` y ` is free for ` x ` in ` ph ( x ) ` ."  Axiom 4 of
     [Mendelson] p. 69.  See also ~ spsbc and ~ rspsbc .  (Contributed by NM,
     5-Aug-1993.) */

theorem stdpc4 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ph → [ y / x ] ph ) ;;
}

proof of stdpc4 {
	step 1 : wff = ax-1 () |- ( ph → ( x = y → ph ) ) ;;
	step 2 : wff = alimi (step 1) |- ( ∀ x ph → ∀ x ( x = y → ph ) ) ;;
	step 3 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( ∀ x ph → [ y / x ] ph ) ;;
	qed prop 1 = step 4 ;;
}

/* Substitution has no effect on a non-free variable.  (Contributed by NM,
     30-May-2009.)  (Revised by Mario Carneiro, 12-Oct-2016.) */

theorem sbft (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( F/ x ph → ( [ y / x ] ph ↔ ph ) ) ;;
}

proof of sbft {
	step 1 : wff = sb1 () |- ( [ y / x ] ph → ∃ x ( x = y ∧ ph ) ) ;;
	step 2 : wff = simpr () |- ( ( x = y ∧ ph ) → ph ) ;;
	step 3 : wff = ax-gen (step 2) |- ∀ x ( ( x = y ∧ ph ) → ph ) ;;
	step 4 : wff = 19.23t () |- ( F/ x ph → ( ∀ x ( ( x = y ∧ ph ) → ph ) ↔ ( ∃ x ( x = y ∧ ph ) → ph ) ) ) ;;
	step 5 : wff = mpbii (step 3, step 4) |- ( F/ x ph → ( ∃ x ( x = y ∧ ph ) → ph ) ) ;;
	step 6 : wff = syl5 (step 1, step 5) |- ( F/ x ph → ( [ y / x ] ph → ph ) ) ;;
	step 7 : wff = nfr () |- ( F/ x ph → ( ph → ∀ x ph ) ) ;;
	step 8 : wff = stdpc4 () |- ( ∀ x ph → [ y / x ] ph ) ;;
	step 9 : wff = syl6 (step 7, step 8) |- ( F/ x ph → ( ph → [ y / x ] ph ) ) ;;
	step 10 : wff = impbid (step 6, step 9) |- ( F/ x ph → ( [ y / x ] ph ↔ ph ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Substitution for a variable not free in a wff does not affect it.
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem sbf (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ph ) ;;
}

proof of sbf {
	step 1 : wff = sbft () |- ( F/ x ph → ( [ y / x ] ph ↔ ph ) ) ;;
	step 2 : wff = ax-mp (hyp 1, step 1) |- ( [ y / x ] ph ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution for a variable not free in a wff does not affect it.
       (Contributed by NM, 5-Aug-1993.) */

theorem sbh (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → ∀ x ph ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ph ) ;;
}

proof of sbh {
	step 1 : wff = nfi (hyp 1) |- F/ x ph ;;
	step 2 : wff = sbf (step 1) |- ( [ y / x ] ph ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution has no effect on a bound variable.  (Contributed by NM,
     1-Jul-2005.) */

theorem sbf2 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ∀ x ph ↔ ∀ x ph ) ;;
}

proof of sbf2 {
	step 1 : wff = nfa1 () |- F/ x ∀ x ph ;;
	step 2 : wff = sbf (step 1) |- ( [ y / x ] ∀ x ph ↔ ∀ x ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Equivalence involving substitution for a variable not free.
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem sb6x (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
}

proof of sb6x {
	step 1 : wff = sbf (hyp 1) |- ( [ y / x ] ph ↔ ph ) ;;
	step 2 : wff = biidd () |- ( x = y → ( ph ↔ ph ) ) ;;
	step 3 : wff = equsal (hyp 1, step 2) |- ( ∀ x ( x = y → ph ) ↔ ph ) ;;
	step 4 : wff = bitr4i (step 1, step 3) |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/* If ` x ` is not free in ` ph ` , it is not free in ` [ y / x ] ph ` .
       (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfs1f (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- F/ x [ y / x ] ph ;;
}

proof of nfs1f {
	step 1 : wff = sbf (hyp 1) |- ( [ y / x ] ph ↔ ph ) ;;
	step 2 : wff = nfxfr (step 1, hyp 1) |- F/ x [ y / x ] ph ;;
	qed prop 1 = step 2 ;;
}

/* Substitution does not change an identical variable specifier.
     (Contributed by NM, 5-Aug-1993.) */

theorem sbequ5 (x : set, y : set, z : set, w : set)  {
	prop 1 : wff = |- ( [ w / z ] ∀ x x = y ↔ ∀ x x = y ) ;;
}

proof of sbequ5 {
	step 1 : wff = nfae () |- F/ z ∀ x x = y ;;
	step 2 : wff = sbf (step 1) |- ( [ w / z ] ∀ x x = y ↔ ∀ x x = y ) ;;
	qed prop 1 = step 2 ;;
}

/* Substitution does not change a distinctor.  (Contributed by NM,
     5-Aug-1993.) */

theorem sbequ6 (x : set, y : set, z : set, w : set)  {
	prop 1 : wff = |- ( [ w / z ] ¬ ∀ x x = y ↔ ¬ ∀ x x = y ) ;;
}

proof of sbequ6 {
	step 1 : wff = nfnae () |- F/ z ¬ ∀ x x = y ;;
	step 2 : wff = sbf (step 1) |- ( [ w / z ] ¬ ∀ x x = y ↔ ¬ ∀ x x = y ) ;;
	qed prop 1 = step 2 ;;
}

/* A substitution into a theorem remains true.  (See ~ chvar and ~ chvarv
       for versions using implicit substitution.)  (Contributed by NM,
       21-Jan-2004.)  (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem sbt (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ph ;;
	-----------------------
	prop 1 : wff = |- [ y / x ] ph ;;
}

proof of sbt {
	step 1 : wff = nfth (hyp 1) |- F/ x ph ;;
	step 2 : wff = sbf (step 1) |- ( [ y / x ] ph ↔ ph ) ;;
	step 3 : wff = mpbir (hyp 1, step 2) |- [ y / x ] ph ;;
	qed prop 1 = step 3 ;;
}

/* Substitution applied to an atomic wff.  (Contributed by NM,
     5-Aug-1993.) */

theorem equsb1 (x : set, y : set)  {
	prop 1 : wff = |- [ y / x ] x = y ;;
}

proof of equsb1 {
	step 1 : wff = sb2 () |- ( ∀ x ( x = y → x = y ) → [ y / x ] x = y ) ;;
	step 2 : wff = id () |- ( x = y → x = y ) ;;
	step 3 : wff = mpg (step 1, step 2) |- [ y / x ] x = y ;;
	qed prop 1 = step 3 ;;
}

/* Substitution applied to an atomic wff.  (Contributed by NM,
     5-Aug-1993.) */

theorem equsb2 (x : set, y : set)  {
	prop 1 : wff = |- [ y / x ] y = x ;;
}

proof of equsb2 {
	step 1 : wff = sb2 () |- ( ∀ x ( x = y → y = x ) → [ y / x ] y = x ) ;;
	step 2 : wff = equcomi () |- ( x = y → y = x ) ;;
	step 3 : wff = mpg (step 1, step 2) |- [ y / x ] y = x ;;
	qed prop 1 = step 3 ;;
}

/* Conversion of implicit substitution to explicit substitution (deduction
       version of ~ sbie ).  (Contributed by NM, 30-Jun-1994.)  (Revised by
       Mario Carneiro, 4-Oct-2016.) */

theorem sbied (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → F/ x ch ) ;;
	hyp 3 : wff = |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( [ y / x ] ps ↔ ch ) ) ;;
}

proof of sbied {
	step 1 : wff = sb1 () |- ( [ y / x ] ps → ∃ x ( x = y ∧ ps ) ) ;;
	step 2 : wff = bi1 () |- ( ( ps ↔ ch ) → ( ps → ch ) ) ;;
	step 3 : wff = syl6 (hyp 3, step 2) |- ( ph → ( x = y → ( ps → ch ) ) ) ;;
	step 4 : wff = imp3a (step 3) |- ( ph → ( ( x = y ∧ ps ) → ch ) ) ;;
	step 5 : wff = eximd (hyp 1, step 4) |- ( ph → ( ∃ x ( x = y ∧ ps ) → ∃ x ch ) ) ;;
	step 6 : wff = syl5 (step 1, step 5) |- ( ph → ( [ y / x ] ps → ∃ x ch ) ) ;;
	step 7 : wff = 19.9d (hyp 2) |- ( ph → ( ∃ x ch → ch ) ) ;;
	step 8 : wff = syld (step 6, step 7) |- ( ph → ( [ y / x ] ps → ch ) ) ;;
	step 9 : wff = nfrd (hyp 2) |- ( ph → ( ch → ∀ x ch ) ) ;;
	step 10 : wff = bi2 () |- ( ( ps ↔ ch ) → ( ch → ps ) ) ;;
	step 11 : wff = syl6 (hyp 3, step 10) |- ( ph → ( x = y → ( ch → ps ) ) ) ;;
	step 12 : wff = com23 (step 11) |- ( ph → ( ch → ( x = y → ps ) ) ) ;;
	step 13 : wff = alimd (hyp 1, step 12) |- ( ph → ( ∀ x ch → ∀ x ( x = y → ps ) ) ) ;;
	step 14 : wff = sb2 () |- ( ∀ x ( x = y → ps ) → [ y / x ] ps ) ;;
	step 15 : wff = syl6 (step 13, step 14) |- ( ph → ( ∀ x ch → [ y / x ] ps ) ) ;;
	step 16 : wff = syld (step 9, step 15) |- ( ph → ( ch → [ y / x ] ps ) ) ;;
	step 17 : wff = impbid (step 8, step 16) |- ( ph → ( [ y / x ] ps ↔ ch ) ) ;;
	qed prop 1 = step 17 ;;
}

/* Conversion of implicit substitution to explicit substitution (deduction
       version of ~ sbie ).  (Contributed by NM, 7-Jan-2017.) */

theorem sbiedv (ph : wff, ps : wff, ch : wff, x : set, y : set) disjointed(x ph, x ch) {
	hyp 1 : wff = |- ( ( ph ∧ x = y ) → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( [ y / x ] ps ↔ ch ) ) ;;
}

proof of sbiedv {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = nfvd () |- ( ph → F/ x ch ) ;;
	step 3 : wff = ex (hyp 1) |- ( ph → ( x = y → ( ps ↔ ch ) ) ) ;;
	step 4 : wff = sbied (step 1, step 2, step 3) |- ( ph → ( [ y / x ] ps ↔ ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Conversion of implicit substitution to explicit substitution.
       (Contributed by NM, 30-Jun-1994.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem sbie (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ps ;;
	hyp 2 : wff = |- ( x = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ps ) ;;
}

proof of sbie {
	step 1 : wff = nftru () |- F/ x T. ;;
	step 2 : wff = a1i (hyp 1) |- ( T. → F/ x ps ) ;;
	step 3 : wff = a1i (hyp 2) |- ( T. → ( x = y → ( ph ↔ ps ) ) ) ;;
	step 4 : wff = sbied (step 1, step 2, step 3) |- ( T. → ( [ y / x ] ph ↔ ps ) ) ;;
	step 5 : wff = trud (step 4) |- ( [ y / x ] ph ↔ ps ) ;;
	qed prop 1 = step 5 ;;
}

/* Equivalence for substitution when ` y ` is not free in ` ph ` .
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem sb6f (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
}

proof of sb6f {
	step 1 : wff = nfri (hyp 1) |- ( ph → ∀ y ph ) ;;
	step 2 : wff = sbimi (step 1) |- ( [ y / x ] ph → [ y / x ] ∀ y ph ) ;;
	step 3 : wff = sb4a () |- ( [ y / x ] ∀ y ph → ∀ x ( x = y → ph ) ) ;;
	step 4 : wff = syl (step 2, step 3) |- ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ;;
	step 5 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 6 : wff = impbii (step 4, step 5) |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Equivalence for substitution when ` y ` is not free in ` ph ` .
       (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem sb5f (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∃ x ( x = y ∧ ph ) ) ;;
}

proof of sb5f {
	step 1 : wff = sb6f (hyp 1) |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	step 2 : wff = equs45f (hyp 1) |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
	step 3 : wff = bitr4i (step 1, step 2) |- ( [ y / x ] ph ↔ ∃ x ( x = y ∧ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Special case of a bound-variable hypothesis builder for substitution.
     (Contributed by NM, 2-Feb-2007.) */

theorem hbsb2a (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ∀ y ph → ∀ x [ y / x ] ph ) ;;
}

proof of hbsb2a {
	step 1 : wff = sb4a () |- ( [ y / x ] ∀ y ph → ∀ x ( x = y → ph ) ) ;;
	step 2 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 3 : wff = a5i (step 2) |- ( ∀ x ( x = y → ph ) → ∀ x [ y / x ] ph ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( [ y / x ] ∀ y ph → ∀ x [ y / x ] ph ) ;;
	qed prop 1 = step 4 ;;
}

/* Special case of a bound-variable hypothesis builder for substitution.
     (Contributed by NM, 2-Feb-2007.) */

theorem hbsb2e (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ph → ∀ x [ y / x ] ∃ y ph ) ;;
}

proof of hbsb2e {
	step 1 : wff = sb4e () |- ( [ y / x ] ph → ∀ x ( x = y → ∃ y ph ) ) ;;
	step 2 : wff = sb2 () |- ( ∀ x ( x = y → ∃ y ph ) → [ y / x ] ∃ y ph ) ;;
	step 3 : wff = a5i (step 2) |- ( ∀ x ( x = y → ∃ y ph ) → ∀ x [ y / x ] ∃ y ph ) ;;
	step 4 : wff = syl (step 1, step 3) |- ( [ y / x ] ph → ∀ x [ y / x ] ∃ y ph ) ;;
	qed prop 1 = step 4 ;;
}

/* If ` y ` is not free in ` ph ` , ` x ` is not free in
       ` [ y / x ] ph ` .  (Contributed by NM, 5-Aug-1993.) */

theorem hbsb3 (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( ph → ∀ y ph ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
}

proof of hbsb3 {
	step 1 : wff = sbimi (hyp 1) |- ( [ y / x ] ph → [ y / x ] ∀ y ph ) ;;
	step 2 : wff = hbsb2a () |- ( [ y / x ] ∀ y ph → ∀ x [ y / x ] ph ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
	qed prop 1 = step 3 ;;
}

/* If ` y ` is not free in ` ph ` , ` x ` is not free in
       ` [ y / x ] ph ` .  (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfs1 (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- F/ x [ y / x ] ph ;;
}

proof of nfs1 {
	step 1 : wff = nfri (hyp 1) |- ( ph → ∀ y ph ) ;;
	step 2 : wff = hbsb3 (step 1) |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
	step 3 : wff = nfi (step 2) |- F/ x [ y / x ] ph ;;
	qed prop 1 = step 3 ;;
}

/* Proof of older axiom ~ ax-16 .  (Contributed by NM, 8-Nov-2006.)
       (Revised by NM, 22-Sep-2017.) */

theorem ax16 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
}

proof of ax16 {
	step 1 : wff = a16g () |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	qed prop 1 = step 1 ;;
}

/* Inference with ~ ax16 as its conclusion.  (Contributed by NM,
       20-May-2008.)  (Proof modification is discouraged.) */

theorem ax16i (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x y z, z ph) {
	hyp 1 : wff = |- ( x = z → ( ph ↔ ps ) ) ;;
	hyp 2 : wff = |- ( ps → ∀ x ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
}

proof of ax16i {
	step 1 : wff = nfv () |- F/ z x = y ;;
	step 2 : wff = nfv () |- F/ x z = y ;;
	step 3 : wff = ax-8 () |- ( x = z → ( x = y → z = y ) ) ;;
	step 4 : wff = cbv3 (step 1, step 2, step 3) |- ( ∀ x x = y → ∀ z z = y ) ;;
	step 5 : wff = ax-8 () |- ( z = x → ( z = y → x = y ) ) ;;
	step 6 : wff = spimv (step 5) |- ( ∀ z z = y → x = y ) ;;
	step 7 : wff = equcomi () |- ( x = y → y = x ) ;;
	step 8 : wff = equcomi () |- ( z = y → y = z ) ;;
	step 9 : wff = ax-8 () |- ( y = z → ( y = x → z = x ) ) ;;
	step 10 : wff = syl (step 8, step 9) |- ( z = y → ( y = x → z = x ) ) ;;
	step 11 : wff = syl5com (step 7, step 10) |- ( x = y → ( z = y → z = x ) ) ;;
	step 12 : wff = alimdv (step 11) |- ( x = y → ( ∀ z z = y → ∀ z z = x ) ) ;;
	step 13 : wff = mpcom (step 6, step 12) |- ( ∀ z z = y → ∀ z z = x ) ;;
	step 14 : wff = equcomi () |- ( z = x → x = z ) ;;
	step 15 : wff = alimi (step 14) |- ( ∀ z z = x → ∀ z x = z ) ;;
	step 16 : wff = syl (step 13, step 15) |- ( ∀ z z = y → ∀ z x = z ) ;;
	step 17 : wff = biimpcd (hyp 1) |- ( ph → ( x = z → ps ) ) ;;
	step 18 : wff = alimdv (step 17) |- ( ph → ( ∀ z x = z → ∀ z ps ) ) ;;
	step 19 : wff = nfi (hyp 2) |- F/ x ps ;;
	step 20 : wff = nfv () |- F/ z ph ;;
	step 21 : wff = equcomi () |- ( z = x → x = z ) ;;
	step 22 : wff = biimprd (hyp 1) |- ( x = z → ( ps → ph ) ) ;;
	step 23 : wff = syl (step 21, step 22) |- ( z = x → ( ps → ph ) ) ;;
	step 24 : wff = cbv3 (step 19, step 20, step 23) |- ( ∀ z ps → ∀ x ph ) ;;
	step 25 : wff = syl6com (step 18, step 24) |- ( ∀ z x = z → ( ph → ∀ x ph ) ) ;;
	step 26 : wff = 3syl (step 4, step 16, step 25) |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	qed prop 1 = step 26 ;;
}

/* Alternate proof of ~ ax16 .  (Contributed by NM, 17-May-2008.)
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem ax16ALT (ph : wff, x : set, y : set) disjointed(x y z, z ph) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
}

proof of ax16ALT {
	var z : set;;
	step 1 : wff = sbequ12 () |- ( x = z → ( ph ↔ [ z / x ] ph ) ) ;;
	step 2 : wff = ax-17 () |- ( ph → ∀ z ph ) ;;
	step 3 : wff = hbsb3 (step 2) |- ( [ z / x ] ph → ∀ x [ z / x ] ph ) ;;
	step 4 : wff = ax16i (step 1, step 3) |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Alternate proof of ~ ax16 .  (Contributed by NM, 8-Nov-2006.)
       (Proof modification is discouraged.)  (New usage is discouraged.) */

theorem ax16ALT2 (ph : wff, x : set, y : set) disjointed(x y, z ph) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
}

proof of ax16ALT2 {
	var z : set;;
	step 1 : wff = aev () |- ( ∀ x x = y → ∀ z x = z ) ;;
	step 2 : wff = sbequ12 () |- ( x = z → ( ph ↔ [ z / x ] ph ) ) ;;
	step 3 : wff = biimpcd (step 2) |- ( ph → ( x = z → [ z / x ] ph ) ) ;;
	step 4 : wff = alimdv (step 3) |- ( ph → ( ∀ z x = z → ∀ z [ z / x ] ph ) ) ;;
	step 5 : wff = nfv () |- F/ z ph ;;
	step 6 : wff = nfs1 (step 5) |- F/ x [ z / x ] ph ;;
	step 7 : wff = nfv () |- F/ z ph ;;
	step 8 : wff = stdpc7 () |- ( z = x → ( [ z / x ] ph → ph ) ) ;;
	step 9 : wff = cbv3 (step 6, step 7, step 8) |- ( ∀ z [ z / x ] ph → ∀ x ph ) ;;
	step 10 : wff = syl6com (step 4, step 9) |- ( ∀ z x = z → ( ph → ∀ x ph ) ) ;;
	step 11 : wff = syl (step 1, step 10) |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	qed prop 1 = step 11 ;;
}

/* A generalization of axiom ~ ax-16 .  Alternate proof of ~ a16g that uses
       ~ df-sb .  (Contributed by NM, 5-Aug-1993.)  (Proof shortened by Andrew
       Salmon, 25-May-2011.)  (Proof modification is discouraged.)
       (New usage is discouraged.) */

theorem a16gALT (ph : wff, x : set, y : set, z : set) disjointed(x y) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph → ∀ z ph ) ) ;;
}

proof of a16gALT {
	step 1 : wff = aev () |- ( ∀ x x = y → ∀ z z = x ) ;;
	step 2 : wff = ax16ALT2 () |- ( ∀ x x = y → ( ph → ∀ x ph ) ) ;;
	step 3 : wff = biidd () |- ( ∀ z z = x → ( ph ↔ ph ) ) ;;
	step 4 : wff = dral1 (step 3) |- ( ∀ z z = x → ( ∀ z ph ↔ ∀ x ph ) ) ;;
	step 5 : wff = biimprd (step 4) |- ( ∀ z z = x → ( ∀ x ph → ∀ z ph ) ) ;;
	step 6 : wff = sylsyld (step 1, step 2, step 5) |- ( ∀ x x = y → ( ph → ∀ z ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* A generalization of axiom ~ ax-16 .  (Contributed by NM, 5-Aug-1993.) */

theorem a16gb (ph : wff, x : set, y : set, z : set) disjointed(x y) {
	prop 1 : wff = |- ( ∀ x x = y → ( ph ↔ ∀ z ph ) ) ;;
}

proof of a16gb {
	step 1 : wff = a16g () |- ( ∀ x x = y → ( ph → ∀ z ph ) ) ;;
	step 2 : wff = sp () |- ( ∀ z ph → ph ) ;;
	step 3 : wff = impbid1 (step 1, step 2) |- ( ∀ x x = y → ( ph ↔ ∀ z ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* If ~ dtru is false, then there is only one element in the universe, so
       everything satisfies ` F/ ` .  (Contributed by Mario Carneiro,
       7-Oct-2016.) */

theorem a16nf (ph : wff, x : set, y : set, z : set) disjointed(x y) {
	prop 1 : wff = |- ( ∀ x x = y → F/ z ph ) ;;
}

proof of a16nf {
	step 1 : wff = nfae () |- F/ z ∀ x x = y ;;
	step 2 : wff = a16g () |- ( ∀ x x = y → ( ph → ∀ z ph ) ) ;;
	step 3 : wff = nfd (step 1, step 2) |- ( ∀ x x = y → F/ z ph ) ;;
	qed prop 1 = step 3 ;;
}

/* One direction of a simplified definition of substitution when variables
     are distinct.  (Contributed by NM, 5-Aug-1993.) */

theorem sb3 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ∃ x ( x = y ∧ ph ) → [ y / x ] ph ) ) ;;
}

proof of sb3 {
	step 1 : wff = equs5 () |- ( ¬ ∀ x x = y → ( ∃ x ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	step 2 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 3 : wff = syl6 (step 1, step 2) |- ( ¬ ∀ x x = y → ( ∃ x ( x = y ∧ ph ) → [ y / x ] ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* One direction of a simplified definition of substitution when variables
     are distinct.  (Contributed by NM, 5-Aug-1993.) */

theorem sb4 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ) ;;
}

proof of sb4 {
	step 1 : wff = sb1 () |- ( [ y / x ] ph → ∃ x ( x = y ∧ ph ) ) ;;
	step 2 : wff = equs5 () |- ( ¬ ∀ x x = y → ( ∃ x ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	step 3 : wff = syl5 (step 1, step 2) |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Simplified definition of substitution when variables are distinct.
     (Contributed by NM, 27-May-1997.) */

theorem sb4b (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ) ;;
}

proof of sb4b {
	step 1 : wff = sb4 () |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ) ;;
	step 2 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 3 : wff = impbid1 (step 1, step 2) |- ( ¬ ∀ x x = y → ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 3 ;;
}

/* An alternate definition of proper substitution that, like ~ df-sb , mixes
     free and bound variables to avoid distinct variable requirements.
     (Contributed by NM, 17-Feb-2005.) */

theorem dfsb2 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ph ↔ ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ;;
}

proof of dfsb2 {
	step 1 : wff = sp () |- ( ∀ x x = y → x = y ) ;;
	step 2 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ph → ph ) ) ;;
	step 3 : wff = sps (step 2) |- ( ∀ x x = y → ( [ y / x ] ph → ph ) ) ;;
	step 4 : wff = orc () |- ( ( x = y ∧ ph ) → ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ;;
	step 5 : wff = ee12an (step 1, step 3, step 4) |- ( ∀ x x = y → ( [ y / x ] ph → ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ) ;;
	step 6 : wff = sb4 () |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ) ;;
	step 7 : wff = olc () |- ( ∀ x ( x = y → ph ) → ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ;;
	step 8 : wff = syl6 (step 6, step 7) |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ) ;;
	step 9 : wff = pm2.61i (step 5, step 8) |- ( [ y / x ] ph → ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ;;
	step 10 : wff = sbequ1 () |- ( x = y → ( ph → [ y / x ] ph ) ) ;;
	step 11 : wff = imp (step 10) |- ( ( x = y ∧ ph ) → [ y / x ] ph ) ;;
	step 12 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 13 : wff = jaoi (step 11, step 12) |- ( ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) → [ y / x ] ph ) ;;
	step 14 : wff = impbii (step 9, step 13) |- ( [ y / x ] ph ↔ ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 14 ;;
}

/* An alternate definition of proper substitution ~ df-sb that uses only
     primitive connectives (no defined terms) on the right-hand side.
     (Contributed by NM, 6-Mar-2007.) */

theorem dfsb3 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ph ↔ ( ( x = y → ¬ ph ) → ∀ x ( x = y → ph ) ) ) ;;
}

proof of dfsb3 {
	step 1 : wff = df-or () |- ( ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ↔ ( ¬ ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	step 2 : wff = dfsb2 () |- ( [ y / x ] ph ↔ ( ( x = y ∧ ph ) ∨ ∀ x ( x = y → ph ) ) ) ;;
	step 3 : wff = imnan () |- ( ( x = y → ¬ ph ) ↔ ¬ ( x = y ∧ ph ) ) ;;
	step 4 : wff = imbi1i (step 3) |- ( ( ( x = y → ¬ ph ) → ∀ x ( x = y → ph ) ) ↔ ( ¬ ( x = y ∧ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	step 5 : wff = 3bitr4i (step 1, step 2, step 4) |- ( [ y / x ] ph ↔ ( ( x = y → ¬ ph ) → ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Bound-variable hypothesis builder for substitution.  (Contributed by NM,
     5-Aug-1993.) */

theorem hbsb2 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x [ y / x ] ph ) ) ;;
}

proof of hbsb2 {
	step 1 : wff = sb4 () |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ) ;;
	step 2 : wff = sb2 () |- ( ∀ x ( x = y → ph ) → [ y / x ] ph ) ;;
	step 3 : wff = a5i (step 2) |- ( ∀ x ( x = y → ph ) → ∀ x [ y / x ] ph ) ;;
	step 4 : wff = syl6 (step 1, step 3) |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x [ y / x ] ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Bound-variable hypothesis builder for substitution.  (Contributed by Mario
     Carneiro, 4-Oct-2016.) */

theorem nfsb2 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ¬ ∀ x x = y → F/ x [ y / x ] ph ) ;;
}

proof of nfsb2 {
	step 1 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 2 : wff = hbsb2 () |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x [ y / x ] ph ) ) ;;
	step 3 : wff = nfd (step 1, step 2) |- ( ¬ ∀ x x = y → F/ x [ y / x ] ph ) ;;
	qed prop 1 = step 3 ;;
}

/* An equality theorem for substitution.  (Contributed by NM, 5-Aug-1993.) */

theorem sbequi (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( x = y → ( [ x / z ] ph → [ y / z ] ph ) ) ;;
}

proof of sbequi {
	step 1 : wff = hbsb2 () |- ( ¬ ∀ z z = x → ( [ x / z ] ph → ∀ z [ x / z ] ph ) ) ;;
	step 2 : wff = equvini () |- ( x = y → ∃ z ( x = z ∧ z = y ) ) ;;
	step 3 : wff = stdpc7 () |- ( x = z → ( [ x / z ] ph → ph ) ) ;;
	step 4 : wff = sbequ1 () |- ( z = y → ( ph → [ y / z ] ph ) ) ;;
	step 5 : wff = sylan9 (step 3, step 4) |- ( ( x = z ∧ z = y ) → ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	step 6 : wff = eximi (step 5) |- ( ∃ z ( x = z ∧ z = y ) → ∃ z ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	step 7 : wff = syl (step 2, step 6) |- ( x = y → ∃ z ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	step 8 : wff = 19.35 () |- ( ∃ z ( [ x / z ] ph → [ y / z ] ph ) ↔ ( ∀ z [ x / z ] ph → ∃ z [ y / z ] ph ) ) ;;
	step 9 : wff = sylib (step 7, step 8) |- ( x = y → ( ∀ z [ x / z ] ph → ∃ z [ y / z ] ph ) ) ;;
	step 10 : wff = sylan9 (step 1, step 9) |- ( ( ¬ ∀ z z = x ∧ x = y ) → ( [ x / z ] ph → ∃ z [ y / z ] ph ) ) ;;
	step 11 : wff = nfsb2 () |- ( ¬ ∀ z z = y → F/ z [ y / z ] ph ) ;;
	step 12 : wff = 19.9d (step 11) |- ( ¬ ∀ z z = y → ( ∃ z [ y / z ] ph → [ y / z ] ph ) ) ;;
	step 13 : wff = syl9 (step 10, step 12) |- ( ( ¬ ∀ z z = x ∧ x = y ) → ( ¬ ∀ z z = y → ( [ x / z ] ph → [ y / z ] ph ) ) ) ;;
	step 14 : wff = ex (step 13) |- ( ¬ ∀ z z = x → ( x = y → ( ¬ ∀ z z = y → ( [ x / z ] ph → [ y / z ] ph ) ) ) ) ;;
	step 15 : wff = com23 (step 14) |- ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → ( x = y → ( [ x / z ] ph → [ y / z ] ph ) ) ) ) ;;
	step 16 : wff = sbequ2 () |- ( z = x → ( [ x / z ] ph → ph ) ) ;;
	step 17 : wff = sps (step 16) |- ( ∀ z z = x → ( [ x / z ] ph → ph ) ) ;;
	step 18 : wff = adantr (step 17) |- ( ( ∀ z z = x ∧ x = y ) → ( [ x / z ] ph → ph ) ) ;;
	step 19 : wff = sbequ1 () |- ( x = y → ( ph → [ y / x ] ph ) ) ;;
	step 20 : wff = drsb1 () |- ( ∀ z z = x → ( [ y / z ] ph ↔ [ y / x ] ph ) ) ;;
	step 21 : wff = biimprd (step 20) |- ( ∀ z z = x → ( [ y / x ] ph → [ y / z ] ph ) ) ;;
	step 22 : wff = sylan9r (step 19, step 21) |- ( ( ∀ z z = x ∧ x = y ) → ( ph → [ y / z ] ph ) ) ;;
	step 23 : wff = syld (step 18, step 22) |- ( ( ∀ z z = x ∧ x = y ) → ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	step 24 : wff = ex (step 23) |- ( ∀ z z = x → ( x = y → ( [ x / z ] ph → [ y / z ] ph ) ) ) ;;
	step 25 : wff = drsb1 () |- ( ∀ z z = y → ( [ x / z ] ph ↔ [ x / y ] ph ) ) ;;
	step 26 : wff = biimpd (step 25) |- ( ∀ z z = y → ( [ x / z ] ph → [ x / y ] ph ) ) ;;
	step 27 : wff = stdpc7 () |- ( x = y → ( [ x / y ] ph → ph ) ) ;;
	step 28 : wff = sylan9 (step 26, step 27) |- ( ( ∀ z z = y ∧ x = y ) → ( [ x / z ] ph → ph ) ) ;;
	step 29 : wff = sbequ1 () |- ( z = y → ( ph → [ y / z ] ph ) ) ;;
	step 30 : wff = sps (step 29) |- ( ∀ z z = y → ( ph → [ y / z ] ph ) ) ;;
	step 31 : wff = adantr (step 30) |- ( ( ∀ z z = y ∧ x = y ) → ( ph → [ y / z ] ph ) ) ;;
	step 32 : wff = syld (step 28, step 31) |- ( ( ∀ z z = y ∧ x = y ) → ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	step 33 : wff = ex (step 32) |- ( ∀ z z = y → ( x = y → ( [ x / z ] ph → [ y / z ] ph ) ) ) ;;
	step 34 : wff = pm2.61ii (step 15, step 24, step 33) |- ( x = y → ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	qed prop 1 = step 34 ;;
}

/* An equality theorem for substitution.  Used in proof of Theorem 9.7 in
     [Megill] p. 449 (p. 16 of the preprint).  (Contributed by NM,
     5-Aug-1993.) */

theorem sbequ (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( x = y → ( [ x / z ] ph ↔ [ y / z ] ph ) ) ;;
}

proof of sbequ {
	step 1 : wff = sbequi () |- ( x = y → ( [ x / z ] ph → [ y / z ] ph ) ) ;;
	step 2 : wff = sbequi () |- ( y = x → ( [ y / z ] ph → [ x / z ] ph ) ) ;;
	step 3 : wff = equcoms (step 2) |- ( x = y → ( [ y / z ] ph → [ x / z ] ph ) ) ;;
	step 4 : wff = impbid (step 1, step 3) |- ( x = y → ( [ x / z ] ph ↔ [ y / z ] ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Formula-building lemma for use with the Distinctor Reduction Theorem.
     Part of Theorem 9.4 of [Megill] p. 448 (p. 16 of preprint).  (Contributed
     by NM, 27-Feb-2005.) */

theorem drsb2 (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ∀ x x = y → ( [ x / z ] ph ↔ [ y / z ] ph ) ) ;;
}

proof of drsb2 {
	step 1 : wff = sbequ () |- ( x = y → ( [ x / z ] ph ↔ [ y / z ] ph ) ) ;;
	step 2 : wff = sps (step 1) |- ( ∀ x x = y → ( [ x / z ] ph ↔ [ y / z ] ph ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Negation inside and outside of substitution are equivalent.  (Contributed
     by NM, 5-Aug-1993.) */

theorem sbn (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ¬ ph ↔ ¬ [ y / x ] ph ) ;;
}

proof of sbn {
	step 1 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ¬ ph → ¬ ph ) ) ;;
	step 2 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ph → ph ) ) ;;
	step 3 : wff = nsyld (step 1, step 2) |- ( x = y → ( [ y / x ] ¬ ph → ¬ [ y / x ] ph ) ) ;;
	step 4 : wff = sps (step 3) |- ( ∀ x x = y → ( [ y / x ] ¬ ph → ¬ [ y / x ] ph ) ) ;;
	step 5 : wff = sb4 () |- ( ¬ ∀ x x = y → ( [ y / x ] ¬ ph → ∀ x ( x = y → ¬ ph ) ) ) ;;
	step 6 : wff = sb1 () |- ( [ y / x ] ph → ∃ x ( x = y ∧ ph ) ) ;;
	step 7 : wff = equs3 () |- ( ∃ x ( x = y ∧ ph ) ↔ ¬ ∀ x ( x = y → ¬ ph ) ) ;;
	step 8 : wff = sylib (step 6, step 7) |- ( [ y / x ] ph → ¬ ∀ x ( x = y → ¬ ph ) ) ;;
	step 9 : wff = con2i (step 8) |- ( ∀ x ( x = y → ¬ ph ) → ¬ [ y / x ] ph ) ;;
	step 10 : wff = syl6 (step 5, step 9) |- ( ¬ ∀ x x = y → ( [ y / x ] ¬ ph → ¬ [ y / x ] ph ) ) ;;
	step 11 : wff = pm2.61i (step 4, step 10) |- ( [ y / x ] ¬ ph → ¬ [ y / x ] ph ) ;;
	step 12 : wff = sbequ1 () |- ( x = y → ( ph → [ y / x ] ph ) ) ;;
	step 13 : wff = con3rr3 (step 12) |- ( ¬ [ y / x ] ph → ( x = y → ¬ ph ) ) ;;
	step 14 : wff = sb2 () |- ( ∀ x ( x = y → ¬ ¬ ph ) → [ y / x ] ¬ ¬ ph ) ;;
	step 15 : wff = notnot () |- ( ph ↔ ¬ ¬ ph ) ;;
	step 16 : wff = sbbii (step 15) |- ( [ y / x ] ph ↔ [ y / x ] ¬ ¬ ph ) ;;
	step 17 : wff = sylibr (step 14, step 16) |- ( ∀ x ( x = y → ¬ ¬ ph ) → [ y / x ] ph ) ;;
	step 18 : wff = con3i (step 17) |- ( ¬ [ y / x ] ph → ¬ ∀ x ( x = y → ¬ ¬ ph ) ) ;;
	step 19 : wff = equs3 () |- ( ∃ x ( x = y ∧ ¬ ph ) ↔ ¬ ∀ x ( x = y → ¬ ¬ ph ) ) ;;
	step 20 : wff = sylibr (step 18, step 19) |- ( ¬ [ y / x ] ph → ∃ x ( x = y ∧ ¬ ph ) ) ;;
	step 21 : wff = df-sb () |- ( [ y / x ] ¬ ph ↔ ( ( x = y → ¬ ph ) ∧ ∃ x ( x = y ∧ ¬ ph ) ) ) ;;
	step 22 : wff = sylanbrc (step 13, step 20, step 21) |- ( ¬ [ y / x ] ph → [ y / x ] ¬ ph ) ;;
	step 23 : wff = impbii (step 11, step 22) |- ( [ y / x ] ¬ ph ↔ ¬ [ y / x ] ph ) ;;
	qed prop 1 = step 23 ;;
}

/* Removal of implication from substitution.  (Contributed by NM,
     5-Aug-1993.) */

theorem sbi1 (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ;;
}

proof of sbi1 {
	step 1 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ph → ph ) ) ;;
	step 2 : wff = sbequ2 () |- ( x = y → ( [ y / x ] ( ph → ps ) → ( ph → ps ) ) ) ;;
	step 3 : wff = syl5d (step 1, step 2) |- ( x = y → ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → ps ) ) ) ;;
	step 4 : wff = sbequ1 () |- ( x = y → ( ps → [ y / x ] ps ) ) ;;
	step 5 : wff = syl6d (step 3, step 4) |- ( x = y → ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ) ;;
	step 6 : wff = sps (step 5) |- ( ∀ x x = y → ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ) ;;
	step 7 : wff = sb4 () |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x ( x = y → ph ) ) ) ;;
	step 8 : wff = sb4 () |- ( ¬ ∀ x x = y → ( [ y / x ] ( ph → ps ) → ∀ x ( x = y → ( ph → ps ) ) ) ) ;;
	step 9 : wff = ax-2 () |- ( ( x = y → ( ph → ps ) ) → ( ( x = y → ph ) → ( x = y → ps ) ) ) ;;
	step 10 : wff = al2imi (step 9) |- ( ∀ x ( x = y → ( ph → ps ) ) → ( ∀ x ( x = y → ph ) → ∀ x ( x = y → ps ) ) ) ;;
	step 11 : wff = sb2 () |- ( ∀ x ( x = y → ps ) → [ y / x ] ps ) ;;
	step 12 : wff = syl6 (step 10, step 11) |- ( ∀ x ( x = y → ( ph → ps ) ) → ( ∀ x ( x = y → ph ) → [ y / x ] ps ) ) ;;
	step 13 : wff = syl6 (step 8, step 12) |- ( ¬ ∀ x x = y → ( [ y / x ] ( ph → ps ) → ( ∀ x ( x = y → ph ) → [ y / x ] ps ) ) ) ;;
	step 14 : wff = syl5d (step 7, step 13) |- ( ¬ ∀ x x = y → ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ) ;;
	step 15 : wff = pm2.61i (step 6, step 14) |- ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	qed prop 1 = step 15 ;;
}

/* Introduction of implication into substitution.  (Contributed by NM,
     5-Aug-1993.) */

theorem sbi2 (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ( [ y / x ] ph → [ y / x ] ps ) → [ y / x ] ( ph → ps ) ) ;;
}

proof of sbi2 {
	step 1 : wff = sbn () |- ( [ y / x ] ¬ ph ↔ ¬ [ y / x ] ph ) ;;
	step 2 : wff = pm2.21 () |- ( ¬ ph → ( ph → ps ) ) ;;
	step 3 : wff = sbimi (step 2) |- ( [ y / x ] ¬ ph → [ y / x ] ( ph → ps ) ) ;;
	step 4 : wff = sylbir (step 1, step 3) |- ( ¬ [ y / x ] ph → [ y / x ] ( ph → ps ) ) ;;
	step 5 : wff = ax-1 () |- ( ps → ( ph → ps ) ) ;;
	step 6 : wff = sbimi (step 5) |- ( [ y / x ] ps → [ y / x ] ( ph → ps ) ) ;;
	step 7 : wff = ja (step 4, step 6) |- ( ( [ y / x ] ph → [ y / x ] ps ) → [ y / x ] ( ph → ps ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Implication inside and outside of substitution are equivalent.
     (Contributed by NM, 5-Aug-1993.) */

theorem sbim (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → [ y / x ] ps ) ) ;;
}

proof of sbim {
	step 1 : wff = sbi1 () |- ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 2 : wff = sbi2 () |- ( ( [ y / x ] ph → [ y / x ] ps ) → [ y / x ] ( ph → ps ) ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Logical OR inside and outside of substitution are equivalent.
     (Contributed by NM, 29-Sep-2002.) */

theorem sbor (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ( ph ∨ ps ) ↔ ( [ y / x ] ph ∨ [ y / x ] ps ) ) ;;
}

proof of sbor {
	step 1 : wff = sbim () |- ( [ y / x ] ( ¬ ph → ps ) ↔ ( [ y / x ] ¬ ph → [ y / x ] ps ) ) ;;
	step 2 : wff = sbn () |- ( [ y / x ] ¬ ph ↔ ¬ [ y / x ] ph ) ;;
	step 3 : wff = imbi1i (step 2) |- ( ( [ y / x ] ¬ ph → [ y / x ] ps ) ↔ ( ¬ [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( [ y / x ] ( ¬ ph → ps ) ↔ ( ¬ [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 5 : wff = df-or () |- ( ( ph ∨ ps ) ↔ ( ¬ ph → ps ) ) ;;
	step 6 : wff = sbbii (step 5) |- ( [ y / x ] ( ph ∨ ps ) ↔ [ y / x ] ( ¬ ph → ps ) ) ;;
	step 7 : wff = df-or () |- ( ( [ y / x ] ph ∨ [ y / x ] ps ) ↔ ( ¬ [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 8 : wff = 3bitr4i (step 4, step 6, step 7) |- ( [ y / x ] ( ph ∨ ps ) ↔ ( [ y / x ] ph ∨ [ y / x ] ps ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Substitution with a variable not free in antecedent affects only the
       consequent.  (Contributed by NM, 5-Aug-1993.)  (Revised by Mario
       Carneiro, 4-Oct-2016.) */

theorem sbrim (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ( ph → ps ) ↔ ( ph → [ y / x ] ps ) ) ;;
}

proof of sbrim {
	step 1 : wff = sbim () |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 2 : wff = sbf (hyp 1) |- ( [ y / x ] ph ↔ ph ) ;;
	step 3 : wff = imbi1i (step 2) |- ( ( [ y / x ] ph → [ y / x ] ps ) ↔ ( ph → [ y / x ] ps ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( [ y / x ] ( ph → ps ) ↔ ( ph → [ y / x ] ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Substitution with a variable not free in consequent affects only the
       antecedent.  (Contributed by NM, 14-Nov-2013.)  (Revised by Mario
       Carneiro, 4-Oct-2016.) */

theorem sblim (ph : wff, ps : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ps ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → ps ) ) ;;
}

proof of sblim {
	step 1 : wff = sbim () |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 2 : wff = sbf (hyp 1) |- ( [ y / x ] ps ↔ ps ) ;;
	step 3 : wff = imbi2i (step 2) |- ( ( [ y / x ] ph → [ y / x ] ps ) ↔ ( [ y / x ] ph → ps ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → ps ) ) ;;
	qed prop 1 = step 4 ;;
}

/* Conjunction inside and outside of a substitution are equivalent.
     (Contributed by NM, 5-Aug-1993.) */

theorem sban (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ( ph ∧ ps ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ) ) ;;
}

proof of sban {
	step 1 : wff = sbn () |- ( [ y / x ] ¬ ( ph → ¬ ps ) ↔ ¬ [ y / x ] ( ph → ¬ ps ) ) ;;
	step 2 : wff = sbim () |- ( [ y / x ] ( ph → ¬ ps ) ↔ ( [ y / x ] ph → [ y / x ] ¬ ps ) ) ;;
	step 3 : wff = sbn () |- ( [ y / x ] ¬ ps ↔ ¬ [ y / x ] ps ) ;;
	step 4 : wff = imbi2i (step 3) |- ( ( [ y / x ] ph → [ y / x ] ¬ ps ) ↔ ( [ y / x ] ph → ¬ [ y / x ] ps ) ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( [ y / x ] ( ph → ¬ ps ) ↔ ( [ y / x ] ph → ¬ [ y / x ] ps ) ) ;;
	step 6 : wff = xchbinx (step 1, step 5) |- ( [ y / x ] ¬ ( ph → ¬ ps ) ↔ ¬ ( [ y / x ] ph → ¬ [ y / x ] ps ) ) ;;
	step 7 : wff = df-an () |- ( ( ph ∧ ps ) ↔ ¬ ( ph → ¬ ps ) ) ;;
	step 8 : wff = sbbii (step 7) |- ( [ y / x ] ( ph ∧ ps ) ↔ [ y / x ] ¬ ( ph → ¬ ps ) ) ;;
	step 9 : wff = df-an () |- ( ( [ y / x ] ph ∧ [ y / x ] ps ) ↔ ¬ ( [ y / x ] ph → ¬ [ y / x ] ps ) ) ;;
	step 10 : wff = 3bitr4i (step 6, step 8, step 9) |- ( [ y / x ] ( ph ∧ ps ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ) ) ;;
	qed prop 1 = step 10 ;;
}

/* Conjunction inside and outside of a substitution are equivalent.
     (Contributed by NM, 14-Dec-2006.) */

theorem sb3an (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ( ph ∧ ps ∧ ch ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ∧ [ y / x ] ch ) ) ;;
}

proof of sb3an {
	step 1 : wff = df-3an () |- ( ( ph ∧ ps ∧ ch ) ↔ ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ y / x ] ( ph ∧ ps ∧ ch ) ↔ [ y / x ] ( ( ph ∧ ps ) ∧ ch ) ) ;;
	step 3 : wff = sban () |- ( [ y / x ] ( ( ph ∧ ps ) ∧ ch ) ↔ ( [ y / x ] ( ph ∧ ps ) ∧ [ y / x ] ch ) ) ;;
	step 4 : wff = sban () |- ( [ y / x ] ( ph ∧ ps ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ) ) ;;
	step 5 : wff = anbi1i (step 4) |- ( ( [ y / x ] ( ph ∧ ps ) ∧ [ y / x ] ch ) ↔ ( ( [ y / x ] ph ∧ [ y / x ] ps ) ∧ [ y / x ] ch ) ) ;;
	step 6 : wff = df-3an () |- ( ( [ y / x ] ph ∧ [ y / x ] ps ∧ [ y / x ] ch ) ↔ ( ( [ y / x ] ph ∧ [ y / x ] ps ) ∧ [ y / x ] ch ) ) ;;
	step 7 : wff = bitr4i (step 5, step 6) |- ( ( [ y / x ] ( ph ∧ ps ) ∧ [ y / x ] ch ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ∧ [ y / x ] ch ) ) ;;
	step 8 : wff = 3bitri (step 2, step 3, step 7) |- ( [ y / x ] ( ph ∧ ps ∧ ch ) ↔ ( [ y / x ] ph ∧ [ y / x ] ps ∧ [ y / x ] ch ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Equivalence inside and outside of a substitution are equivalent.
     (Contributed by NM, 5-Aug-1993.) */

theorem sbbi (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ( ph ↔ ps ) ↔ ( [ y / x ] ph ↔ [ y / x ] ps ) ) ;;
}

proof of sbbi {
	step 1 : wff = dfbi2 () |- ( ( ph ↔ ps ) ↔ ( ( ph → ps ) ∧ ( ps → ph ) ) ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ y / x ] ( ph ↔ ps ) ↔ [ y / x ] ( ( ph → ps ) ∧ ( ps → ph ) ) ) ;;
	step 3 : wff = sbim () |- ( [ y / x ] ( ph → ps ) ↔ ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 4 : wff = sbim () |- ( [ y / x ] ( ps → ph ) ↔ ( [ y / x ] ps → [ y / x ] ph ) ) ;;
	step 5 : wff = anbi12i (step 3, step 4) |- ( ( [ y / x ] ( ph → ps ) ∧ [ y / x ] ( ps → ph ) ) ↔ ( ( [ y / x ] ph → [ y / x ] ps ) ∧ ( [ y / x ] ps → [ y / x ] ph ) ) ) ;;
	step 6 : wff = sban () |- ( [ y / x ] ( ( ph → ps ) ∧ ( ps → ph ) ) ↔ ( [ y / x ] ( ph → ps ) ∧ [ y / x ] ( ps → ph ) ) ) ;;
	step 7 : wff = dfbi2 () |- ( ( [ y / x ] ph ↔ [ y / x ] ps ) ↔ ( ( [ y / x ] ph → [ y / x ] ps ) ∧ ( [ y / x ] ps → [ y / x ] ph ) ) ) ;;
	step 8 : wff = 3bitr4i (step 5, step 6, step 7) |- ( [ y / x ] ( ( ph → ps ) ∧ ( ps → ph ) ) ↔ ( [ y / x ] ph ↔ [ y / x ] ps ) ) ;;
	step 9 : wff = bitri (step 2, step 8) |- ( [ y / x ] ( ph ↔ ps ) ↔ ( [ y / x ] ph ↔ [ y / x ] ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Introduce left biconditional inside of a substitution.  (Contributed by
       NM, 19-Aug-1993.) */

theorem sblbis (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( [ y / x ] ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ( ch ↔ ph ) ↔ ( [ y / x ] ch ↔ ps ) ) ;;
}

proof of sblbis {
	step 1 : wff = sbbi () |- ( [ y / x ] ( ch ↔ ph ) ↔ ( [ y / x ] ch ↔ [ y / x ] ph ) ) ;;
	step 2 : wff = bibi2i (hyp 1) |- ( ( [ y / x ] ch ↔ [ y / x ] ph ) ↔ ( [ y / x ] ch ↔ ps ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( [ y / x ] ( ch ↔ ph ) ↔ ( [ y / x ] ch ↔ ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Introduce right biconditional inside of a substitution.  (Contributed by
       NM, 18-Aug-1993.) */

theorem sbrbis (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- ( [ y / x ] ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ( ph ↔ ch ) ↔ ( ps ↔ [ y / x ] ch ) ) ;;
}

proof of sbrbis {
	step 1 : wff = sbbi () |- ( [ y / x ] ( ph ↔ ch ) ↔ ( [ y / x ] ph ↔ [ y / x ] ch ) ) ;;
	step 2 : wff = bibi1i (hyp 1) |- ( ( [ y / x ] ph ↔ [ y / x ] ch ) ↔ ( ps ↔ [ y / x ] ch ) ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( [ y / x ] ( ph ↔ ch ) ↔ ( ps ↔ [ y / x ] ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Introduce right biconditional inside of a substitution.  (Contributed by
       NM, 18-Aug-1993.)  (Revised by Mario Carneiro, 4-Oct-2016.) */

theorem sbrbif (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ch ;;
	hyp 2 : wff = |- ( [ y / x ] ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ( ph ↔ ch ) ↔ ( ps ↔ ch ) ) ;;
}

proof of sbrbif {
	step 1 : wff = sbrbis (hyp 2) |- ( [ y / x ] ( ph ↔ ch ) ↔ ( ps ↔ [ y / x ] ch ) ) ;;
	step 2 : wff = sbf (hyp 1) |- ( [ y / x ] ch ↔ ch ) ;;
	step 3 : wff = bibi2i (step 2) |- ( ( ps ↔ [ y / x ] ch ) ↔ ( ps ↔ ch ) ) ;;
	step 4 : wff = bitri (step 1, step 3) |- ( [ y / x ] ( ph ↔ ch ) ↔ ( ps ↔ ch ) ) ;;
	qed prop 1 = step 4 ;;
}

/* A specialization theorem.  (Contributed by NM, 5-Aug-1993.) */

theorem spsbe (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ph → ∃ x ph ) ;;
}

proof of spsbe {
	step 1 : wff = stdpc4 () |- ( ∀ x ¬ ph → [ y / x ] ¬ ph ) ;;
	step 2 : wff = sbn () |- ( [ y / x ] ¬ ph ↔ ¬ [ y / x ] ph ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ∀ x ¬ ph → ¬ [ y / x ] ph ) ;;
	step 4 : wff = con2i (step 3) |- ( [ y / x ] ph → ¬ ∀ x ¬ ph ) ;;
	step 5 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 6 : wff = sylibr (step 4, step 5) |- ( [ y / x ] ph → ∃ x ph ) ;;
	qed prop 1 = step 6 ;;
}

/* Specialization of implication.  (Contributed by NM, 5-Aug-1993.)  (Proof
     shortened by Andrew Salmon, 25-May-2011.) */

theorem spsbim (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ;;
}

proof of spsbim {
	step 1 : wff = stdpc4 () |- ( ∀ x ( ph → ps ) → [ y / x ] ( ph → ps ) ) ;;
	step 2 : wff = sbi1 () |- ( [ y / x ] ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ∀ x ( ph → ps ) → ( [ y / x ] ph → [ y / x ] ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Specialization of biconditional.  (Contributed by NM, 5-Aug-1993.) */

theorem spsbbi (ph : wff, ps : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x ( ph ↔ ps ) → ( [ y / x ] ph ↔ [ y / x ] ps ) ) ;;
}

proof of spsbbi {
	step 1 : wff = stdpc4 () |- ( ∀ x ( ph ↔ ps ) → [ y / x ] ( ph ↔ ps ) ) ;;
	step 2 : wff = sbbi () |- ( [ y / x ] ( ph ↔ ps ) ↔ ( [ y / x ] ph ↔ [ y / x ] ps ) ) ;;
	step 3 : wff = sylib (step 1, step 2) |- ( ∀ x ( ph ↔ ps ) → ( [ y / x ] ph ↔ [ y / x ] ps ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction substituting both sides of a biconditional.  (Contributed by
       NM, 5-Aug-1993.) */

theorem sbbid (ph : wff, ps : wff, ch : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → ( ps ↔ ch ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( [ y / x ] ps ↔ [ y / x ] ch ) ) ;;
}

proof of sbbid {
	step 1 : wff = alrimi (hyp 1, hyp 2) |- ( ph → ∀ x ( ps ↔ ch ) ) ;;
	step 2 : wff = spsbbi () |- ( ∀ x ( ps ↔ ch ) → ( [ y / x ] ps ↔ [ y / x ] ch ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → ( [ y / x ] ps ↔ [ y / x ] ch ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Elimination of equality from antecedent after substitution.  (Contributed
     by NM, 5-Aug-1993.) */

theorem sbequ8 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] ph ↔ [ y / x ] ( x = y → ph ) ) ;;
}

proof of sbequ8 {
	step 1 : wff = equsb1 () |- [ y / x ] x = y ;;
	step 2 : wff = a1bi (step 1) |- ( [ y / x ] ph ↔ ( [ y / x ] x = y → [ y / x ] ph ) ) ;;
	step 3 : wff = sbim () |- ( [ y / x ] ( x = y → ph ) ↔ ( [ y / x ] x = y → [ y / x ] ph ) ) ;;
	step 4 : wff = bitr4i (step 2, step 3) |- ( [ y / x ] ph ↔ [ y / x ] ( x = y → ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/* A variable not free remains so after substitution with a distinct variable
     (closed form of ~ nfsb4 ).  (Contributed by NM, 7-Apr-2004.)  (Revised by
     Mario Carneiro, 4-Oct-2016.) */

theorem nfsb4t (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( ∀ x F/ z ph → ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ) ;;
}

proof of nfsb4t {
	step 1 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 2 : wff = sps (step 1) |- ( ∀ x x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 3 : wff = drnf2 (step 2) |- ( ∀ x x = y → ( F/ z ph ↔ F/ z [ y / x ] ph ) ) ;;
	step 4 : wff = biimpcd (step 3) |- ( F/ z ph → ( ∀ x x = y → F/ z [ y / x ] ph ) ) ;;
	step 5 : wff = sps (step 4) |- ( ∀ x F/ z ph → ( ∀ x x = y → F/ z [ y / x ] ph ) ) ;;
	step 6 : wff = a1dd (step 5) |- ( ∀ x F/ z ph → ( ∀ x x = y → ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z [ y / x ] ph ) ) ) ;;
	step 7 : wff = nfa1 () |- F/ x ∀ x F/ z ph ;;
	step 8 : wff = nfnae () |- F/ x ¬ ∀ z z = x ;;
	step 9 : wff = nfnae () |- F/ x ¬ ∀ z z = y ;;
	step 10 : wff = nfan (step 8, step 9) |- F/ x ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ;;
	step 11 : wff = nfan (step 7, step 10) |- F/ x ( ∀ x F/ z ph ∧ ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ) ;;
	step 12 : wff = nfeqf () |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
	step 13 : wff = adantl (step 12) |- ( ( ∀ x F/ z ph ∧ ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ) → F/ z x = y ) ;;
	step 14 : wff = sp () |- ( ∀ x F/ z ph → F/ z ph ) ;;
	step 15 : wff = adantr (step 14) |- ( ( ∀ x F/ z ph ∧ ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ) → F/ z ph ) ;;
	step 16 : wff = nfimd (step 13, step 15) |- ( ( ∀ x F/ z ph ∧ ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ) → F/ z ( x = y → ph ) ) ;;
	step 17 : wff = nfald (step 11, step 16) |- ( ( ∀ x F/ z ph ∧ ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) ) → F/ z ∀ x ( x = y → ph ) ) ;;
	step 18 : wff = ex (step 17) |- ( ∀ x F/ z ph → ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z ∀ x ( x = y → ph ) ) ) ;;
	step 19 : wff = nfnae () |- F/ z ¬ ∀ x x = y ;;
	step 20 : wff = sb4b () |- ( ¬ ∀ x x = y → ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 21 : wff = nfbidf (step 19, step 20) |- ( ¬ ∀ x x = y → ( F/ z [ y / x ] ph ↔ F/ z ∀ x ( x = y → ph ) ) ) ;;
	step 22 : wff = imbi2d (step 21) |- ( ¬ ∀ x x = y → ( ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z [ y / x ] ph ) ↔ ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z ∀ x ( x = y → ph ) ) ) ) ;;
	step 23 : wff = syl5ibrcom (step 18, step 22) |- ( ∀ x F/ z ph → ( ¬ ∀ x x = y → ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z [ y / x ] ph ) ) ) ;;
	step 24 : wff = pm2.61d (step 6, step 23) |- ( ∀ x F/ z ph → ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z [ y / x ] ph ) ) ;;
	step 25 : wff = exp3a (step 24) |- ( ∀ x F/ z ph → ( ¬ ∀ z z = x → ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ) ) ;;
	step 26 : wff = nfsb2 () |- ( ¬ ∀ z z = y → F/ z [ y / z ] ph ) ;;
	step 27 : wff = drsb1 () |- ( ∀ z z = x → ( [ y / z ] ph ↔ [ y / x ] ph ) ) ;;
	step 28 : wff = drnf2 (step 27) |- ( ∀ z z = x → ( F/ z [ y / z ] ph ↔ F/ z [ y / x ] ph ) ) ;;
	step 29 : wff = syl5ib (step 26, step 28) |- ( ∀ z z = x → ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ) ;;
	step 30 : wff = pm2.61d2 (step 25, step 29) |- ( ∀ x F/ z ph → ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ) ;;
	qed prop 1 = step 30 ;;
}

/* A variable not free remains so after substitution with a distinct
       variable.  (Contributed by NM, 5-Aug-1993.)  (Revised by Mario Carneiro,
       4-Oct-2016.) */

theorem nfsb4 (ph : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- F/ z ph ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ;;
}

proof of nfsb4 {
	step 1 : wff = nfsb4t () |- ( ∀ x F/ z ph → ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ) ;;
	step 2 : wff = mpg (step 1, hyp 1) |- ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Deduction form of ~ dvelimf .  This version may be useful if we want to
       avoid ~ ax-17 and use ~ ax-16 instead.  (Contributed by NM,
       7-Apr-2004.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem dvelimdf (ph : wff, ps : wff, ch : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ z ph ;;
	hyp 3 : wff = |- ( ph → F/ x ps ) ;;
	hyp 4 : wff = |- ( ph → F/ z ch ) ;;
	hyp 5 : wff = |- ( ph → ( z = y → ( ps ↔ ch ) ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( ¬ ∀ x x = y → F/ x ch ) ) ;;
}

proof of dvelimdf {
	step 1 : wff = alrimi (hyp 2, hyp 3) |- ( ph → ∀ z F/ x ps ) ;;
	step 2 : wff = nfsb4t () |- ( ∀ z F/ x ps → ( ¬ ∀ x x = y → F/ x [ y / z ] ps ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → ( ¬ ∀ x x = y → F/ x [ y / z ] ps ) ) ;;
	step 4 : wff = imp (step 3) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x [ y / z ] ps ) ;;
	step 5 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 6 : wff = nfan (hyp 1, step 5) |- F/ x ( ph ∧ ¬ ∀ x x = y ) ;;
	step 7 : wff = sbied (hyp 2, hyp 4, hyp 5) |- ( ph → ( [ y / z ] ps ↔ ch ) ) ;;
	step 8 : wff = adantr (step 7) |- ( ( ph ∧ ¬ ∀ x x = y ) → ( [ y / z ] ps ↔ ch ) ) ;;
	step 9 : wff = nfbidf (step 6, step 8) |- ( ( ph ∧ ¬ ∀ x x = y ) → ( F/ x [ y / z ] ps ↔ F/ x ch ) ) ;;
	step 10 : wff = mpbid (step 4, step 9) |- ( ( ph ∧ ¬ ∀ x x = y ) → F/ x ch ) ;;
	step 11 : wff = ex (step 10) |- ( ph → ( ¬ ∀ x x = y → F/ x ch ) ) ;;
	qed prop 1 = step 11 ;;
}

/* A composition law for substitution.  (Contributed by NM, 5-Aug-1993.) */

theorem sbco (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] [ x / y ] ph ↔ [ y / x ] ph ) ;;
}

proof of sbco {
	step 1 : wff = equsb2 () |- [ y / x ] y = x ;;
	step 2 : wff = sbequ12 () |- ( y = x → ( ph ↔ [ x / y ] ph ) ) ;;
	step 3 : wff = bicomd (step 2) |- ( y = x → ( [ x / y ] ph ↔ ph ) ) ;;
	step 4 : wff = sbimi (step 3) |- ( [ y / x ] y = x → [ y / x ] ( [ x / y ] ph ↔ ph ) ) ;;
	step 5 : wff = ax-mp (step 1, step 4) |- [ y / x ] ( [ x / y ] ph ↔ ph ) ;;
	step 6 : wff = sbbi () |- ( [ y / x ] ( [ x / y ] ph ↔ ph ) ↔ ( [ y / x ] [ x / y ] ph ↔ [ y / x ] ph ) ) ;;
	step 7 : wff = mpbi (step 5, step 6) |- ( [ y / x ] [ x / y ] ph ↔ [ y / x ] ph ) ;;
	qed prop 1 = step 7 ;;
}

/* An identity law for substitution.  (Contributed by NM, 5-Aug-1993.)
       (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sbid2 (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] [ x / y ] ph ↔ ph ) ;;
}

proof of sbid2 {
	step 1 : wff = sbco () |- ( [ y / x ] [ x / y ] ph ↔ [ y / x ] ph ) ;;
	step 2 : wff = sbf (hyp 1) |- ( [ y / x ] ph ↔ ph ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( [ y / x ] [ x / y ] ph ↔ ph ) ;;
	qed prop 1 = step 3 ;;
}

/* An idempotent law for substitution.  (Contributed by NM, 30-Jun-1994.)
     (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem sbidm (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( [ y / x ] [ y / x ] ph ↔ [ y / x ] ph ) ;;
}

proof of sbidm {
	step 1 : wff = equsb2 () |- [ y / x ] y = x ;;
	step 2 : wff = sbequ12r () |- ( y = x → ( [ y / x ] ph ↔ ph ) ) ;;
	step 3 : wff = sbimi (step 2) |- ( [ y / x ] y = x → [ y / x ] ( [ y / x ] ph ↔ ph ) ) ;;
	step 4 : wff = ax-mp (step 1, step 3) |- [ y / x ] ( [ y / x ] ph ↔ ph ) ;;
	step 5 : wff = sbbi () |- ( [ y / x ] ( [ y / x ] ph ↔ ph ) ↔ ( [ y / x ] [ y / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 6 : wff = mpbi (step 4, step 5) |- ( [ y / x ] [ y / x ] ph ↔ [ y / x ] ph ) ;;
	qed prop 1 = step 6 ;;
}

/* A composition law for substitution.  (Contributed by NM, 30-Jun-1994.)
       (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sbco2 (ph : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- F/ z ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ;;
}

proof of sbco2 {
	step 1 : wff = sbid2 (hyp 1) |- ( [ x / z ] [ z / x ] ph ↔ ph ) ;;
	step 2 : wff = sbequ () |- ( x = y → ( [ x / z ] [ z / x ] ph ↔ [ y / z ] [ z / x ] ph ) ) ;;
	step 3 : wff = syl5bbr (step 1, step 2) |- ( x = y → ( ph ↔ [ y / z ] [ z / x ] ph ) ) ;;
	step 4 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 5 : wff = bitr3d (step 3, step 4) |- ( x = y → ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 6 : wff = sps (step 5) |- ( ∀ x x = y → ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 7 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 8 : wff = nfs1 (hyp 1) |- F/ x [ z / x ] ph ;;
	step 9 : wff = nfsb4 (step 8) |- ( ¬ ∀ x x = y → F/ x [ y / z ] [ z / x ] ph ) ;;
	step 10 : wff = sbid2 (hyp 1) |- ( [ x / z ] [ z / x ] ph ↔ ph ) ;;
	step 11 : wff = sbequ () |- ( x = y → ( [ x / z ] [ z / x ] ph ↔ [ y / z ] [ z / x ] ph ) ) ;;
	step 12 : wff = syl5bbr (step 10, step 11) |- ( x = y → ( ph ↔ [ y / z ] [ z / x ] ph ) ) ;;
	step 13 : wff = a1i (step 12) |- ( ¬ ∀ x x = y → ( x = y → ( ph ↔ [ y / z ] [ z / x ] ph ) ) ) ;;
	step 14 : wff = sbied (step 7, step 9, step 13) |- ( ¬ ∀ x x = y → ( [ y / x ] ph ↔ [ y / z ] [ z / x ] ph ) ) ;;
	step 15 : wff = bicomd (step 14) |- ( ¬ ∀ x x = y → ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ) ;;
	step 16 : wff = pm2.61i (step 6, step 15) |- ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ;;
	qed prop 1 = step 16 ;;
}

/* A composition law for substitution.  (Contributed by NM, 5-Aug-1993.)
       (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sbco2d (ph : wff, ps : wff, x : set, y : set, z : set)  {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- F/ z ph ;;
	hyp 3 : wff = |- ( ph → F/ z ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → ( [ y / z ] [ z / x ] ps ↔ [ y / x ] ps ) ) ;;
}

proof of sbco2d {
	step 1 : wff = nfim1 (hyp 2, hyp 3) |- F/ z ( ph → ps ) ;;
	step 2 : wff = sbco2 (step 1) |- ( [ y / z ] [ z / x ] ( ph → ps ) ↔ [ y / x ] ( ph → ps ) ) ;;
	step 3 : wff = sbrim (hyp 1) |- ( [ z / x ] ( ph → ps ) ↔ ( ph → [ z / x ] ps ) ) ;;
	step 4 : wff = sbbii (step 3) |- ( [ y / z ] [ z / x ] ( ph → ps ) ↔ [ y / z ] ( ph → [ z / x ] ps ) ) ;;
	step 5 : wff = sbrim (hyp 2) |- ( [ y / z ] ( ph → [ z / x ] ps ) ↔ ( ph → [ y / z ] [ z / x ] ps ) ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( [ y / z ] [ z / x ] ( ph → ps ) ↔ ( ph → [ y / z ] [ z / x ] ps ) ) ;;
	step 7 : wff = sbrim (hyp 1) |- ( [ y / x ] ( ph → ps ) ↔ ( ph → [ y / x ] ps ) ) ;;
	step 8 : wff = 3bitr3i (step 2, step 6, step 7) |- ( ( ph → [ y / z ] [ z / x ] ps ) ↔ ( ph → [ y / x ] ps ) ) ;;
	step 9 : wff = pm5.74ri (step 8) |- ( ph → ( [ y / z ] [ z / x ] ps ↔ [ y / x ] ps ) ) ;;
	qed prop 1 = step 9 ;;
}

/* A composition law for substitution.  (Contributed by NM, 5-Aug-1993.) */

theorem sbco3 (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( [ z / y ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ;;
}

proof of sbco3 {
	step 1 : wff = drsb1 () |- ( ∀ x x = y → ( [ z / x ] [ y / x ] ph ↔ [ z / y ] [ y / x ] ph ) ) ;;
	step 2 : wff = sbequ12a () |- ( x = y → ( [ y / x ] ph ↔ [ x / y ] ph ) ) ;;
	step 3 : wff = alimi (step 2) |- ( ∀ x x = y → ∀ x ( [ y / x ] ph ↔ [ x / y ] ph ) ) ;;
	step 4 : wff = spsbbi () |- ( ∀ x ( [ y / x ] ph ↔ [ x / y ] ph ) → ( [ z / x ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ) ;;
	step 5 : wff = syl (step 3, step 4) |- ( ∀ x x = y → ( [ z / x ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ) ;;
	step 6 : wff = bitr3d (step 1, step 5) |- ( ∀ x x = y → ( [ z / y ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ) ;;
	step 7 : wff = sbco () |- ( [ x / y ] [ y / x ] ph ↔ [ x / y ] ph ) ;;
	step 8 : wff = sbbii (step 7) |- ( [ z / x ] [ x / y ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ;;
	step 9 : wff = nfnae () |- F/ y ¬ ∀ x x = y ;;
	step 10 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 11 : wff = nfsb2 () |- ( ¬ ∀ x x = y → F/ x [ y / x ] ph ) ;;
	step 12 : wff = sbco2d (step 9, step 10, step 11) |- ( ¬ ∀ x x = y → ( [ z / x ] [ x / y ] [ y / x ] ph ↔ [ z / y ] [ y / x ] ph ) ) ;;
	step 13 : wff = syl5rbbr (step 8, step 12) |- ( ¬ ∀ x x = y → ( [ z / y ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ) ;;
	step 14 : wff = pm2.61i (step 6, step 13) |- ( [ z / y ] [ y / x ] ph ↔ [ z / x ] [ x / y ] ph ) ;;
	qed prop 1 = step 14 ;;
}

/* A commutativity law for substitution.  (Contributed by NM,
     27-May-1997.) */

theorem sbcom (ph : wff, x : set, y : set, z : set)  {
	prop 1 : wff = |- ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ;;
}

proof of sbcom {
	step 1 : wff = drsb1 () |- ( ∀ x x = z → ( [ y / x ] [ y / x ] ph ↔ [ y / z ] [ y / x ] ph ) ) ;;
	step 2 : wff = nfae () |- F/ x ∀ x x = z ;;
	step 3 : wff = drsb1 () |- ( ∀ x x = z → ( [ y / x ] ph ↔ [ y / z ] ph ) ) ;;
	step 4 : wff = sbbid (step 2, step 3) |- ( ∀ x x = z → ( [ y / x ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 5 : wff = bitr3d (step 1, step 4) |- ( ∀ x x = z → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 6 : wff = adantr (step 5) |- ( ( ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 7 : wff = nfnae () |- F/ z ¬ ∀ x x = z ;;
	step 8 : wff = nfnae () |- F/ z ¬ ∀ x x = y ;;
	step 9 : wff = nfan (step 7, step 8) |- F/ z ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) ;;
	step 10 : wff = nfeqf () |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → F/ x z = y ) ;;
	step 11 : wff = 19.21t () |- ( F/ x z = y → ( ∀ x ( z = y → ( x = y → ph ) ) ↔ ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 12 : wff = syl (step 10, step 11) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ∀ x ( z = y → ( x = y → ph ) ) ↔ ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 13 : wff = albid (step 9, step 12) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ∀ z ∀ x ( z = y → ( x = y → ph ) ) ↔ ∀ z ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 14 : wff = adantrr (step 13) |- ( ( ¬ ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( ∀ z ∀ x ( z = y → ( x = y → ph ) ) ↔ ∀ z ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 15 : wff = alcom () |- ( ∀ z ∀ x ( z = y → ( x = y → ph ) ) ↔ ∀ x ∀ z ( z = y → ( x = y → ph ) ) ) ;;
	step 16 : wff = nfnae () |- F/ x ¬ ∀ x x = z ;;
	step 17 : wff = nfnae () |- F/ x ¬ ∀ z z = y ;;
	step 18 : wff = nfan (step 16, step 17) |- F/ x ( ¬ ∀ x x = z ∧ ¬ ∀ z z = y ) ;;
	step 19 : wff = bi2.04 () |- ( ( z = y → ( x = y → ph ) ) ↔ ( x = y → ( z = y → ph ) ) ) ;;
	step 20 : wff = albii (step 19) |- ( ∀ z ( z = y → ( x = y → ph ) ) ↔ ∀ z ( x = y → ( z = y → ph ) ) ) ;;
	step 21 : wff = aecom () |- ( ∀ z z = x → ∀ x x = z ) ;;
	step 22 : wff = con3i (step 21) |- ( ¬ ∀ x x = z → ¬ ∀ z z = x ) ;;
	step 23 : wff = nfeqf () |- ( ( ¬ ∀ z z = x ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
	step 24 : wff = sylan (step 22, step 23) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ z z = y ) → F/ z x = y ) ;;
	step 25 : wff = 19.21t () |- ( F/ z x = y → ( ∀ z ( x = y → ( z = y → ph ) ) ↔ ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 26 : wff = syl (step 24, step 25) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ z z = y ) → ( ∀ z ( x = y → ( z = y → ph ) ) ↔ ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 27 : wff = syl5bb (step 20, step 26) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ z z = y ) → ( ∀ z ( z = y → ( x = y → ph ) ) ↔ ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 28 : wff = albid (step 18, step 27) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ z z = y ) → ( ∀ x ∀ z ( z = y → ( x = y → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 29 : wff = syl5bb (step 15, step 28) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ z z = y ) → ( ∀ z ∀ x ( z = y → ( x = y → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 30 : wff = adantrl (step 29) |- ( ( ¬ ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( ∀ z ∀ x ( z = y → ( x = y → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 31 : wff = bitr3d (step 14, step 30) |- ( ( ¬ ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( ∀ z ( z = y → ∀ x ( x = y → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 32 : wff = sb4b () |- ( ¬ ∀ z z = y → ( [ y / z ] [ y / x ] ph ↔ ∀ z ( z = y → [ y / x ] ph ) ) ) ;;
	step 33 : wff = nfnae () |- F/ z ¬ ∀ x x = y ;;
	step 34 : wff = sb4b () |- ( ¬ ∀ x x = y → ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 35 : wff = imbi2d (step 34) |- ( ¬ ∀ x x = y → ( ( z = y → [ y / x ] ph ) ↔ ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 36 : wff = albid (step 33, step 35) |- ( ¬ ∀ x x = y → ( ∀ z ( z = y → [ y / x ] ph ) ↔ ∀ z ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 37 : wff = sylan9bbr (step 32, step 36) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) → ( [ y / z ] [ y / x ] ph ↔ ∀ z ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 38 : wff = adantl (step 37) |- ( ( ¬ ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( [ y / z ] [ y / x ] ph ↔ ∀ z ( z = y → ∀ x ( x = y → ph ) ) ) ) ;;
	step 39 : wff = sb4b () |- ( ¬ ∀ x x = y → ( [ y / x ] [ y / z ] ph ↔ ∀ x ( x = y → [ y / z ] ph ) ) ) ;;
	step 40 : wff = nfnae () |- F/ x ¬ ∀ z z = y ;;
	step 41 : wff = sb4b () |- ( ¬ ∀ z z = y → ( [ y / z ] ph ↔ ∀ z ( z = y → ph ) ) ) ;;
	step 42 : wff = imbi2d (step 41) |- ( ¬ ∀ z z = y → ( ( x = y → [ y / z ] ph ) ↔ ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 43 : wff = albid (step 40, step 42) |- ( ¬ ∀ z z = y → ( ∀ x ( x = y → [ y / z ] ph ) ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 44 : wff = sylan9bb (step 39, step 43) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) → ( [ y / x ] [ y / z ] ph ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 45 : wff = adantl (step 44) |- ( ( ¬ ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( [ y / x ] [ y / z ] ph ↔ ∀ x ( x = y → ∀ z ( z = y → ph ) ) ) ) ;;
	step 46 : wff = 3bitr4d (step 31, step 38, step 45) |- ( ( ¬ ∀ x x = z ∧ ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) ) → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 47 : wff = pm2.61ian (step 6, step 46) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = y ) → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 48 : wff = ex (step 47) |- ( ¬ ∀ x x = y → ( ¬ ∀ z z = y → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ) ;;
	step 49 : wff = nfae () |- F/ z ∀ x x = y ;;
	step 50 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 51 : wff = sps (step 50) |- ( ∀ x x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 52 : wff = sbbid (step 49, step 51) |- ( ∀ x x = y → ( [ y / z ] ph ↔ [ y / z ] [ y / x ] ph ) ) ;;
	step 53 : wff = sbequ12 () |- ( x = y → ( [ y / z ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 54 : wff = sps (step 53) |- ( ∀ x x = y → ( [ y / z ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 55 : wff = bitr3d (step 52, step 54) |- ( ∀ x x = y → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 56 : wff = sbequ12 () |- ( z = y → ( [ y / x ] ph ↔ [ y / z ] [ y / x ] ph ) ) ;;
	step 57 : wff = sps (step 56) |- ( ∀ z z = y → ( [ y / x ] ph ↔ [ y / z ] [ y / x ] ph ) ) ;;
	step 58 : wff = nfae () |- F/ x ∀ z z = y ;;
	step 59 : wff = sbequ12 () |- ( z = y → ( ph ↔ [ y / z ] ph ) ) ;;
	step 60 : wff = sps (step 59) |- ( ∀ z z = y → ( ph ↔ [ y / z ] ph ) ) ;;
	step 61 : wff = sbbid (step 58, step 60) |- ( ∀ z z = y → ( [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 62 : wff = bitr3d (step 57, step 61) |- ( ∀ z z = y → ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ) ;;
	step 63 : wff = pm2.61ii (step 48, step 55, step 62) |- ( [ y / z ] [ y / x ] ph ↔ [ y / x ] [ y / z ] ph ) ;;
	qed prop 1 = step 63 ;;
}

/* Reversed substitution.  (Contributed by NM, 3-Feb-2005.)  (Revised by
       Mario Carneiro, 6-Oct-2016.) */

theorem sb5rf (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ∃ y ( y = x ∧ [ y / x ] ph ) ) ;;
}

proof of sb5rf {
	step 1 : wff = sbid2 (hyp 1) |- ( [ x / y ] [ y / x ] ph ↔ ph ) ;;
	step 2 : wff = sb1 () |- ( [ x / y ] [ y / x ] ph → ∃ y ( y = x ∧ [ y / x ] ph ) ) ;;
	step 3 : wff = sylbir (step 1, step 2) |- ( ph → ∃ y ( y = x ∧ [ y / x ] ph ) ) ;;
	step 4 : wff = stdpc7 () |- ( y = x → ( [ y / x ] ph → ph ) ) ;;
	step 5 : wff = imp (step 4) |- ( ( y = x ∧ [ y / x ] ph ) → ph ) ;;
	step 6 : wff = exlimi (hyp 1, step 5) |- ( ∃ y ( y = x ∧ [ y / x ] ph ) → ph ) ;;
	step 7 : wff = impbii (step 3, step 6) |- ( ph ↔ ∃ y ( y = x ∧ [ y / x ] ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* Reversed substitution.  (Contributed by NM, 5-Aug-1993.)  (Revised by
       Mario Carneiro, 6-Oct-2016.) */

theorem sb6rf (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ∀ y ( y = x → [ y / x ] ph ) ) ;;
}

proof of sb6rf {
	step 1 : wff = sbequ1 () |- ( x = y → ( ph → [ y / x ] ph ) ) ;;
	step 2 : wff = equcoms (step 1) |- ( y = x → ( ph → [ y / x ] ph ) ) ;;
	step 3 : wff = com12 (step 2) |- ( ph → ( y = x → [ y / x ] ph ) ) ;;
	step 4 : wff = alrimi (hyp 1, step 3) |- ( ph → ∀ y ( y = x → [ y / x ] ph ) ) ;;
	step 5 : wff = sb2 () |- ( ∀ y ( y = x → [ y / x ] ph ) → [ x / y ] [ y / x ] ph ) ;;
	step 6 : wff = sbid2 (hyp 1) |- ( [ x / y ] [ y / x ] ph ↔ ph ) ;;
	step 7 : wff = sylib (step 5, step 6) |- ( ∀ y ( y = x → [ y / x ] ph ) → ph ) ;;
	step 8 : wff = impbii (step 4, step 7) |- ( ph ↔ ∀ y ( y = x → [ y / x ] ph ) ) ;;
	qed prop 1 = step 8 ;;
}

/* Substitution of variable in universal quantifier.  (Contributed by NM,
       5-Aug-1993.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sb8 (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∀ x ph ↔ ∀ y [ y / x ] ph ) ;;
}

proof of sb8 {
	step 1 : wff = nfal (hyp 1) |- F/ y ∀ x ph ;;
	step 2 : wff = stdpc4 () |- ( ∀ x ph → [ y / x ] ph ) ;;
	step 3 : wff = alrimi (step 1, step 2) |- ( ∀ x ph → ∀ y [ y / x ] ph ) ;;
	step 4 : wff = nfs1 (hyp 1) |- F/ x [ y / x ] ph ;;
	step 5 : wff = stdpc7 () |- ( y = x → ( [ y / x ] ph → ph ) ) ;;
	step 6 : wff = cbv3 (step 4, hyp 1, step 5) |- ( ∀ y [ y / x ] ph → ∀ x ph ) ;;
	step 7 : wff = impbii (step 3, step 6) |- ( ∀ x ph ↔ ∀ y [ y / x ] ph ) ;;
	qed prop 1 = step 7 ;;
}

/* Substitution of variable in existential quantifier.  (Contributed by NM,
       12-Aug-1993.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sb8e (ph : wff, x : set, y : set)  {
	hyp 1 : wff = |- F/ y ph ;;
	-----------------------
	prop 1 : wff = |- ( ∃ x ph ↔ ∃ y [ y / x ] ph ) ;;
}

proof of sb8e {
	step 1 : wff = nfn (hyp 1) |- F/ y ¬ ph ;;
	step 2 : wff = sb8 (step 1) |- ( ∀ x ¬ ph ↔ ∀ y [ y / x ] ¬ ph ) ;;
	step 3 : wff = sbn () |- ( [ y / x ] ¬ ph ↔ ¬ [ y / x ] ph ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ y [ y / x ] ¬ ph ↔ ∀ y ¬ [ y / x ] ph ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∀ x ¬ ph ↔ ∀ y ¬ [ y / x ] ph ) ;;
	step 6 : wff = notbii (step 5) |- ( ¬ ∀ x ¬ ph ↔ ¬ ∀ y ¬ [ y / x ] ph ) ;;
	step 7 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 8 : wff = df-ex () |- ( ∃ y [ y / x ] ph ↔ ¬ ∀ y ¬ [ y / x ] ph ) ;;
	step 9 : wff = 3bitr4i (step 6, step 7, step 8) |- ( ∃ x ph ↔ ∃ y [ y / x ] ph ) ;;
	qed prop 1 = step 9 ;;
}

/* Commutation of quantification and substitution variables.  (Contributed by
     NM, 5-Aug-1993.) */

theorem sb9i (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x [ x / y ] ph → ∀ y [ y / x ] ph ) ;;
}

proof of sb9i {
	step 1 : wff = drsb1 () |- ( ∀ y y = x → ( [ y / y ] ph ↔ [ y / x ] ph ) ) ;;
	step 2 : wff = drsb2 () |- ( ∀ y y = x → ( [ y / y ] ph ↔ [ x / y ] ph ) ) ;;
	step 3 : wff = bitr3d (step 1, step 2) |- ( ∀ y y = x → ( [ y / x ] ph ↔ [ x / y ] ph ) ) ;;
	step 4 : wff = dral1 (step 3) |- ( ∀ y y = x → ( ∀ y [ y / x ] ph ↔ ∀ x [ x / y ] ph ) ) ;;
	step 5 : wff = biimprd (step 4) |- ( ∀ y y = x → ( ∀ x [ x / y ] ph → ∀ y [ y / x ] ph ) ) ;;
	step 6 : wff = nfnae () |- F/ x ¬ ∀ y y = x ;;
	step 7 : wff = hbsb2 () |- ( ¬ ∀ y y = x → ( [ x / y ] ph → ∀ y [ x / y ] ph ) ) ;;
	step 8 : wff = alimd (step 6, step 7) |- ( ¬ ∀ y y = x → ( ∀ x [ x / y ] ph → ∀ x ∀ y [ x / y ] ph ) ) ;;
	step 9 : wff = stdpc4 () |- ( ∀ x [ x / y ] ph → [ y / x ] [ x / y ] ph ) ;;
	step 10 : wff = sbco () |- ( [ y / x ] [ x / y ] ph ↔ [ y / x ] ph ) ;;
	step 11 : wff = sylib (step 9, step 10) |- ( ∀ x [ x / y ] ph → [ y / x ] ph ) ;;
	step 12 : wff = alimi (step 11) |- ( ∀ y ∀ x [ x / y ] ph → ∀ y [ y / x ] ph ) ;;
	step 13 : wff = a7s (step 12) |- ( ∀ x ∀ y [ x / y ] ph → ∀ y [ y / x ] ph ) ;;
	step 14 : wff = syl6 (step 8, step 13) |- ( ¬ ∀ y y = x → ( ∀ x [ x / y ] ph → ∀ y [ y / x ] ph ) ) ;;
	step 15 : wff = pm2.61i (step 5, step 14) |- ( ∀ x [ x / y ] ph → ∀ y [ y / x ] ph ) ;;
	qed prop 1 = step 15 ;;
}

/* Commutation of quantification and substitution variables.  (Contributed by
     NM, 5-Aug-1993.) */

theorem sb9 (ph : wff, x : set, y : set)  {
	prop 1 : wff = |- ( ∀ x [ x / y ] ph ↔ ∀ y [ y / x ] ph ) ;;
}

proof of sb9 {
	step 1 : wff = sb9i () |- ( ∀ x [ x / y ] ph → ∀ y [ y / x ] ph ) ;;
	step 2 : wff = sb9i () |- ( ∀ y [ y / x ] ph → ∀ x [ x / y ] ph ) ;;
	step 3 : wff = impbii (step 1, step 2) |- ( ∀ x [ x / y ] ph ↔ ∀ y [ y / x ] ph ) ;;
	qed prop 1 = step 3 ;;
}

/* This is a version of ~ ax-11o when the variables are distinct.  Axiom
       (C8) of [Monk2] p. 105.  See theorem ~ ax11v2 for the rederivation of
       ~ ax-11o from this theorem.  (Contributed by NM, 5-Aug-1993.) */

theorem ax11v (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ;;
}

proof of ax11v {
	step 1 : wff = ax-1 () |- ( ph → ( x = y → ph ) ) ;;
	step 2 : wff = ax16 () |- ( ∀ x x = y → ( ( x = y → ph ) → ∀ x ( x = y → ph ) ) ) ;;
	step 3 : wff = syl5 (step 1, step 2) |- ( ∀ x x = y → ( ph → ∀ x ( x = y → ph ) ) ) ;;
	step 4 : wff = a1d (step 3) |- ( ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	step 5 : wff = ax11o () |- ( ¬ ∀ x x = y → ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ) ;;
	step 6 : wff = pm2.61i (step 4, step 5) |- ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Two equivalent ways of expressing the proper substitution of ` y ` for
       ` x ` in ` ph ` , when ` x ` and ` y ` are distinct.  Theorem 6.2 of
       [Quine] p. 40.  The proof does not involve ~ df-sb .  (Contributed by
       NM, 14-Apr-2008.) */

theorem sb56 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
}

proof of sb56 {
	step 1 : wff = nfa1 () |- F/ x ∀ x ( x = y → ph ) ;;
	step 2 : wff = ax11v () |- ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ;;
	step 3 : wff = sp () |- ( ∀ x ( x = y → ph ) → ( x = y → ph ) ) ;;
	step 4 : wff = com12 (step 3) |- ( x = y → ( ∀ x ( x = y → ph ) → ph ) ) ;;
	step 5 : wff = impbid (step 2, step 4) |- ( x = y → ( ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 6 : wff = equsex (step 1, step 5) |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Equivalence for substitution.  Compare Theorem 6.2 of [Quine] p. 40.
       Also proved as Lemmas 16 and 17 of [Tarski] p. 70.  (Contributed by NM,
       18-Aug-1993.) */

theorem sb6 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
}

proof of sb6 {
	step 1 : wff = sb56 () |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( ( x = y → ph ) ∧ ∃ x ( x = y ∧ ph ) ) ↔ ( ( x = y → ph ) ∧ ∀ x ( x = y → ph ) ) ) ;;
	step 3 : wff = df-sb () |- ( [ y / x ] ph ↔ ( ( x = y → ph ) ∧ ∃ x ( x = y ∧ ph ) ) ) ;;
	step 4 : wff = sp () |- ( ∀ x ( x = y → ph ) → ( x = y → ph ) ) ;;
	step 5 : wff = pm4.71ri (step 4) |- ( ∀ x ( x = y → ph ) ↔ ( ( x = y → ph ) ∧ ∀ x ( x = y → ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 2, step 3, step 5) |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Equivalence for substitution.  Similar to Theorem 6.1 of [Quine] p. 40.
       (Contributed by NM, 18-Aug-1993.) */

theorem sb5 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∃ x ( x = y ∧ ph ) ) ;;
}

proof of sb5 {
	step 1 : wff = sb6 () |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	step 2 : wff = sb56 () |- ( ∃ x ( x = y ∧ ph ) ↔ ∀ x ( x = y → ph ) ) ;;
	step 3 : wff = bitr4i (step 1, step 2) |- ( [ y / x ] ph ↔ ∃ x ( x = y ∧ ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Lemma for ~ equsb3 .  (Contributed by Raph Levien and FL, 4-Dec-2005.)
       (Proof shortened by Andrew Salmon, 14-Jun-2011.) */

theorem equsb3lem (x : set, y : set, z : set) disjointed(y z, x y) {
	prop 1 : wff = |- ( [ x / y ] y = z ↔ x = z ) ;;
}

proof of equsb3lem {
	step 1 : wff = nfv () |- F/ y x = z ;;
	step 2 : wff = equequ1 () |- ( y = x → ( y = z ↔ x = z ) ) ;;
	step 3 : wff = sbie (step 1, step 2) |- ( [ x / y ] y = z ↔ x = z ) ;;
	qed prop 1 = step 3 ;;
}

/* Substitution applied to an atomic wff.  (Contributed by Raph Levien and
       FL, 4-Dec-2005.) */

theorem equsb3 (x : set, y : set, z : set) disjointed(w y z, w x) {
	prop 1 : wff = |- ( [ x / y ] y = z ↔ x = z ) ;;
}

proof of equsb3 {
	var w : set;;
	step 1 : wff = equsb3lem () |- ( [ w / y ] y = z ↔ w = z ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ x / w ] [ w / y ] y = z ↔ [ x / w ] w = z ) ;;
	step 3 : wff = nfv () |- F/ w y = z ;;
	step 4 : wff = sbco2 (step 3) |- ( [ x / w ] [ w / y ] y = z ↔ [ x / y ] y = z ) ;;
	step 5 : wff = equsb3lem () |- ( [ x / w ] w = z ↔ x = z ) ;;
	step 6 : wff = 3bitr3i (step 2, step 4, step 5) |- ( [ x / y ] y = z ↔ x = z ) ;;
	qed prop 1 = step 6 ;;
}

/* Substitution applied to an atomic membership wff.  (Contributed by NM,
       7-Nov-2006.)  (Proof shortened by Andrew Salmon, 14-Jun-2011.) */

theorem elsb3 (x : set, y : set, z : set) disjointed(w y z, w x) {
	prop 1 : wff = |- ( [ x / y ] y ∈ z ↔ x ∈ z ) ;;
}

proof of elsb3 {
	var w : set;;
	step 1 : wff = nfv () |- F/ y w ∈ z ;;
	step 2 : wff = sbco2 (step 1) |- ( [ x / y ] [ y / w ] w ∈ z ↔ [ x / w ] w ∈ z ) ;;
	step 3 : wff = nfv () |- F/ w y ∈ z ;;
	step 4 : wff = elequ1 () |- ( w = y → ( w ∈ z ↔ y ∈ z ) ) ;;
	step 5 : wff = sbie (step 3, step 4) |- ( [ y / w ] w ∈ z ↔ y ∈ z ) ;;
	step 6 : wff = sbbii (step 5) |- ( [ x / y ] [ y / w ] w ∈ z ↔ [ x / y ] y ∈ z ) ;;
	step 7 : wff = nfv () |- F/ w x ∈ z ;;
	step 8 : wff = elequ1 () |- ( w = x → ( w ∈ z ↔ x ∈ z ) ) ;;
	step 9 : wff = sbie (step 7, step 8) |- ( [ x / w ] w ∈ z ↔ x ∈ z ) ;;
	step 10 : wff = 3bitr3i (step 2, step 6, step 9) |- ( [ x / y ] y ∈ z ↔ x ∈ z ) ;;
	qed prop 1 = step 10 ;;
}

/* Substitution applied to an atomic membership wff.  (Contributed by
       Rodolfo Medina, 3-Apr-2010.)  (Proof shortened by Andrew Salmon,
       14-Jun-2011.) */

theorem elsb4 (x : set, y : set, z : set) disjointed(w y z, w x) {
	prop 1 : wff = |- ( [ x / y ] z ∈ y ↔ z ∈ x ) ;;
}

proof of elsb4 {
	var w : set;;
	step 1 : wff = nfv () |- F/ y z ∈ w ;;
	step 2 : wff = sbco2 (step 1) |- ( [ x / y ] [ y / w ] z ∈ w ↔ [ x / w ] z ∈ w ) ;;
	step 3 : wff = nfv () |- F/ w z ∈ y ;;
	step 4 : wff = elequ2 () |- ( w = y → ( z ∈ w ↔ z ∈ y ) ) ;;
	step 5 : wff = sbie (step 3, step 4) |- ( [ y / w ] z ∈ w ↔ z ∈ y ) ;;
	step 6 : wff = sbbii (step 5) |- ( [ x / y ] [ y / w ] z ∈ w ↔ [ x / y ] z ∈ y ) ;;
	step 7 : wff = nfv () |- F/ w z ∈ x ;;
	step 8 : wff = elequ2 () |- ( w = x → ( z ∈ w ↔ z ∈ x ) ) ;;
	step 9 : wff = sbie (step 7, step 8) |- ( [ x / w ] z ∈ w ↔ z ∈ x ) ;;
	step 10 : wff = 3bitr3i (step 2, step 6, step 9) |- ( [ x / y ] z ∈ y ↔ z ∈ x ) ;;
	qed prop 1 = step 10 ;;
}

/* ` x ` is not free in ` [ y / x ] ph ` when ` x ` and ` y ` are
       distinct.  (Contributed by NM, 5-Aug-1993.) */

theorem hbs1 (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
}

proof of hbs1 {
	step 1 : wff = ax16 () |- ( ∀ x x = y → ( [ y / x ] ph → ∀ x [ y / x ] ph ) ) ;;
	step 2 : wff = hbsb2 () |- ( ¬ ∀ x x = y → ( [ y / x ] ph → ∀ x [ y / x ] ph ) ) ;;
	step 3 : wff = pm2.61i (step 1, step 2) |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
	qed prop 1 = step 3 ;;
}

/* ` x ` is not free in ` [ y / x ] ph ` when ` x ` and ` y ` are
       distinct.  (Contributed by Mario Carneiro, 11-Aug-2016.) */

theorem nfs1v (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- F/ x [ y / x ] ph ;;
}

proof of nfs1v {
	step 1 : wff = hbs1 () |- ( [ y / x ] ph → ∀ x [ y / x ] ph ) ;;
	step 2 : wff = nfi (step 1) |- F/ x [ y / x ] ph ;;
	qed prop 1 = step 2 ;;
}

/* Two ways of expressing " ` x ` is (effectively) not free in ` ph ` ."
       (Contributed by NM, 29-May-2009.) */

theorem sbhb (ph : wff, x : set, y : set) disjointed(y ph) {
	prop 1 : wff = |- ( ( ph → ∀ x ph ) ↔ ∀ y ( ph → [ y / x ] ph ) ) ;;
}

proof of sbhb {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = sb8 (step 1) |- ( ∀ x ph ↔ ∀ y [ y / x ] ph ) ;;
	step 3 : wff = imbi2i (step 2) |- ( ( ph → ∀ x ph ) ↔ ( ph → ∀ y [ y / x ] ph ) ) ;;
	step 4 : wff = 19.21v () |- ( ∀ y ( ph → [ y / x ] ph ) ↔ ( ph → ∀ y [ y / x ] ph ) ) ;;
	step 5 : wff = bitr4i (step 3, step 4) |- ( ( ph → ∀ x ph ) ↔ ∀ y ( ph → [ y / x ] ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/* Two ways of expressing " ` x ` is (effectively) not free in ` ph ` ."
       (Contributed by G&eacute;rard Lang, 14-Nov-2013.)  (Revised by Mario
       Carneiro, 6-Oct-2016.) */

theorem sbnf2 (ph : wff, x : set, y : set, z : set) disjointed(x y z, y z ph) {
	prop 1 : wff = |- ( F/ x ph ↔ ∀ y ∀ z ( [ y / x ] ph ↔ [ z / x ] ph ) ) ;;
}

proof of sbnf2 {
	step 1 : wff = 2albiim () |- ( ∀ y ∀ z ( [ y / x ] ph ↔ [ z / x ] ph ) ↔ ( ∀ y ∀ z ( [ y / x ] ph → [ z / x ] ph ) ∧ ∀ y ∀ z ( [ z / x ] ph → [ y / x ] ph ) ) ) ;;
	step 2 : wff = df-nf () |- ( F/ x ph ↔ ∀ x ( ph → ∀ x ph ) ) ;;
	step 3 : wff = sbhb () |- ( ( ph → ∀ x ph ) ↔ ∀ z ( ph → [ z / x ] ph ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x ( ph → ∀ x ph ) ↔ ∀ x ∀ z ( ph → [ z / x ] ph ) ) ;;
	step 5 : wff = alcom () |- ( ∀ x ∀ z ( ph → [ z / x ] ph ) ↔ ∀ z ∀ x ( ph → [ z / x ] ph ) ) ;;
	step 6 : wff = 3bitri (step 2, step 4, step 5) |- ( F/ x ph ↔ ∀ z ∀ x ( ph → [ z / x ] ph ) ) ;;
	step 7 : wff = nfv () |- F/ y ( ph → [ z / x ] ph ) ;;
	step 8 : wff = sb8 (step 7) |- ( ∀ x ( ph → [ z / x ] ph ) ↔ ∀ y [ y / x ] ( ph → [ z / x ] ph ) ) ;;
	step 9 : wff = nfs1v () |- F/ x [ z / x ] ph ;;
	step 10 : wff = sblim (step 9) |- ( [ y / x ] ( ph → [ z / x ] ph ) ↔ ( [ y / x ] ph → [ z / x ] ph ) ) ;;
	step 11 : wff = albii (step 10) |- ( ∀ y [ y / x ] ( ph → [ z / x ] ph ) ↔ ∀ y ( [ y / x ] ph → [ z / x ] ph ) ) ;;
	step 12 : wff = bitri (step 8, step 11) |- ( ∀ x ( ph → [ z / x ] ph ) ↔ ∀ y ( [ y / x ] ph → [ z / x ] ph ) ) ;;
	step 13 : wff = albii (step 12) |- ( ∀ z ∀ x ( ph → [ z / x ] ph ) ↔ ∀ z ∀ y ( [ y / x ] ph → [ z / x ] ph ) ) ;;
	step 14 : wff = alcom () |- ( ∀ z ∀ y ( [ y / x ] ph → [ z / x ] ph ) ↔ ∀ y ∀ z ( [ y / x ] ph → [ z / x ] ph ) ) ;;
	step 15 : wff = 3bitri (step 6, step 13, step 14) |- ( F/ x ph ↔ ∀ y ∀ z ( [ y / x ] ph → [ z / x ] ph ) ) ;;
	step 16 : wff = df-nf () |- ( F/ x ph ↔ ∀ x ( ph → ∀ x ph ) ) ;;
	step 17 : wff = sbhb () |- ( ( ph → ∀ x ph ) ↔ ∀ y ( ph → [ y / x ] ph ) ) ;;
	step 18 : wff = albii (step 17) |- ( ∀ x ( ph → ∀ x ph ) ↔ ∀ x ∀ y ( ph → [ y / x ] ph ) ) ;;
	step 19 : wff = alcom () |- ( ∀ x ∀ y ( ph → [ y / x ] ph ) ↔ ∀ y ∀ x ( ph → [ y / x ] ph ) ) ;;
	step 20 : wff = 3bitri (step 16, step 18, step 19) |- ( F/ x ph ↔ ∀ y ∀ x ( ph → [ y / x ] ph ) ) ;;
	step 21 : wff = nfv () |- F/ z ( ph → [ y / x ] ph ) ;;
	step 22 : wff = sb8 (step 21) |- ( ∀ x ( ph → [ y / x ] ph ) ↔ ∀ z [ z / x ] ( ph → [ y / x ] ph ) ) ;;
	step 23 : wff = nfs1v () |- F/ x [ y / x ] ph ;;
	step 24 : wff = sblim (step 23) |- ( [ z / x ] ( ph → [ y / x ] ph ) ↔ ( [ z / x ] ph → [ y / x ] ph ) ) ;;
	step 25 : wff = albii (step 24) |- ( ∀ z [ z / x ] ( ph → [ y / x ] ph ) ↔ ∀ z ( [ z / x ] ph → [ y / x ] ph ) ) ;;
	step 26 : wff = bitri (step 22, step 25) |- ( ∀ x ( ph → [ y / x ] ph ) ↔ ∀ z ( [ z / x ] ph → [ y / x ] ph ) ) ;;
	step 27 : wff = albii (step 26) |- ( ∀ y ∀ x ( ph → [ y / x ] ph ) ↔ ∀ y ∀ z ( [ z / x ] ph → [ y / x ] ph ) ) ;;
	step 28 : wff = bitri (step 20, step 27) |- ( F/ x ph ↔ ∀ y ∀ z ( [ z / x ] ph → [ y / x ] ph ) ) ;;
	step 29 : wff = anbi12i (step 15, step 28) |- ( ( F/ x ph ∧ F/ x ph ) ↔ ( ∀ y ∀ z ( [ y / x ] ph → [ z / x ] ph ) ∧ ∀ y ∀ z ( [ z / x ] ph → [ y / x ] ph ) ) ) ;;
	step 30 : wff = anidm () |- ( ( F/ x ph ∧ F/ x ph ) ↔ F/ x ph ) ;;
	step 31 : wff = 3bitr2ri (step 1, step 29, step 30) |- ( F/ x ph ↔ ∀ y ∀ z ( [ y / x ] ph ↔ [ z / x ] ph ) ) ;;
	qed prop 1 = step 31 ;;
}

/* If ` z ` is not free in ` ph ` , it is not free in ` [ y / x ] ph ` when
       ` y ` and ` z ` are distinct.  (Contributed by Mario Carneiro,
       11-Aug-2016.) */

theorem nfsb (ph : wff, x : set, y : set, z : set) disjointed(y z) {
	hyp 1 : wff = |- F/ z ph ;;
	-----------------------
	prop 1 : wff = |- F/ z [ y / x ] ph ;;
}

proof of nfsb {
	step 1 : wff = a16nf () |- ( ∀ z z = y → F/ z [ y / x ] ph ) ;;
	step 2 : wff = nfsb4 (hyp 1) |- ( ¬ ∀ z z = y → F/ z [ y / x ] ph ) ;;
	step 3 : wff = pm2.61i (step 1, step 2) |- F/ z [ y / x ] ph ;;
	qed prop 1 = step 3 ;;
}

/* If ` z ` is not free in ` ph ` , it is not free in ` [ y / x ] ph ` when
       ` y ` and ` z ` are distinct.  (Contributed by NM, 12-Aug-1993.) */

theorem hbsb (ph : wff, x : set, y : set, z : set) disjointed(y z) {
	hyp 1 : wff = |- ( ph → ∀ z ph ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph → ∀ z [ y / x ] ph ) ;;
}

proof of hbsb {
	step 1 : wff = nfi (hyp 1) |- F/ z ph ;;
	step 2 : wff = nfsb (step 1) |- F/ z [ y / x ] ph ;;
	step 3 : wff = nfri (step 2) |- ( [ y / x ] ph → ∀ z [ y / x ] ph ) ;;
	qed prop 1 = step 3 ;;
}

/* Deduction version of ~ nfsb .  (Contributed by NM, 15-Feb-2013.) */

theorem nfsbd (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(y z) {
	hyp 1 : wff = |- F/ x ph ;;
	hyp 2 : wff = |- ( ph → F/ z ps ) ;;
	-----------------------
	prop 1 : wff = |- ( ph → F/ z [ y / x ] ps ) ;;
}

proof of nfsbd {
	step 1 : wff = alrimi (hyp 1, hyp 2) |- ( ph → ∀ x F/ z ps ) ;;
	step 2 : wff = nfsb4t () |- ( ∀ x F/ z ps → ( ¬ ∀ z z = y → F/ z [ y / x ] ps ) ) ;;
	step 3 : wff = syl (step 1, step 2) |- ( ph → ( ¬ ∀ z z = y → F/ z [ y / x ] ps ) ) ;;
	step 4 : wff = a16nf () |- ( ∀ z z = y → F/ z [ y / x ] ps ) ;;
	step 5 : wff = pm2.61d2 (step 3, step 4) |- ( ph → F/ z [ y / x ] ps ) ;;
	qed prop 1 = step 5 ;;
}

/* Equivalence for double substitution.  (Contributed by NM,
       3-Feb-2005.) */

theorem 2sb5 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z, w y) {
	prop 1 : wff = |- ( [ z / x ] [ w / y ] ph ↔ ∃ x ∃ y ( ( x = z ∧ y = w ) ∧ ph ) ) ;;
}

proof of 2sb5 {
	step 1 : wff = sb5 () |- ( [ z / x ] [ w / y ] ph ↔ ∃ x ( x = z ∧ [ w / y ] ph ) ) ;;
	step 2 : wff = 19.42v () |- ( ∃ y ( x = z ∧ ( y = w ∧ ph ) ) ↔ ( x = z ∧ ∃ y ( y = w ∧ ph ) ) ) ;;
	step 3 : wff = anass () |- ( ( ( x = z ∧ y = w ) ∧ ph ) ↔ ( x = z ∧ ( y = w ∧ ph ) ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y ( ( x = z ∧ y = w ) ∧ ph ) ↔ ∃ y ( x = z ∧ ( y = w ∧ ph ) ) ) ;;
	step 5 : wff = sb5 () |- ( [ w / y ] ph ↔ ∃ y ( y = w ∧ ph ) ) ;;
	step 6 : wff = anbi2i (step 5) |- ( ( x = z ∧ [ w / y ] ph ) ↔ ( x = z ∧ ∃ y ( y = w ∧ ph ) ) ) ;;
	step 7 : wff = 3bitr4ri (step 2, step 4, step 6) |- ( ( x = z ∧ [ w / y ] ph ) ↔ ∃ y ( ( x = z ∧ y = w ) ∧ ph ) ) ;;
	step 8 : wff = exbii (step 7) |- ( ∃ x ( x = z ∧ [ w / y ] ph ) ↔ ∃ x ∃ y ( ( x = z ∧ y = w ) ∧ ph ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( [ z / x ] [ w / y ] ph ↔ ∃ x ∃ y ( ( x = z ∧ y = w ) ∧ ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Equivalence for double substitution.  (Contributed by NM,
       3-Feb-2005.) */

theorem 2sb6 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z, w y) {
	prop 1 : wff = |- ( [ z / x ] [ w / y ] ph ↔ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
}

proof of 2sb6 {
	step 1 : wff = sb6 () |- ( [ z / x ] [ w / y ] ph ↔ ∀ x ( x = z → [ w / y ] ph ) ) ;;
	step 2 : wff = 19.21v () |- ( ∀ y ( x = z → ( y = w → ph ) ) ↔ ( x = z → ∀ y ( y = w → ph ) ) ) ;;
	step 3 : wff = impexp () |- ( ( ( x = z ∧ y = w ) → ph ) ↔ ( x = z → ( y = w → ph ) ) ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ y ( ( x = z ∧ y = w ) → ph ) ↔ ∀ y ( x = z → ( y = w → ph ) ) ) ;;
	step 5 : wff = sb6 () |- ( [ w / y ] ph ↔ ∀ y ( y = w → ph ) ) ;;
	step 6 : wff = imbi2i (step 5) |- ( ( x = z → [ w / y ] ph ) ↔ ( x = z → ∀ y ( y = w → ph ) ) ) ;;
	step 7 : wff = 3bitr4ri (step 2, step 4, step 6) |- ( ( x = z → [ w / y ] ph ) ↔ ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ( x = z → [ w / y ] ph ) ↔ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 9 : wff = bitri (step 1, step 8) |- ( [ z / x ] [ w / y ] ph ↔ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/* Commutativity law for substitution.  Used in proof of Theorem 9.7 of
       [Megill] p. 449 (p. 16 of the preprint).  (Contributed by NM,
       27-May-1997.) */

theorem sbcom2 (ph : wff, x : set, y : set, z : set, w : set) disjointed(x z, x w, y z) {
	prop 1 : wff = |- ( [ w / z ] [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ;;
}

proof of sbcom2 {
	step 1 : wff = alcom () |- ( ∀ z ∀ x ( x = y → ( z = w → ph ) ) ↔ ∀ x ∀ z ( x = y → ( z = w → ph ) ) ) ;;
	step 2 : wff = bi2.04 () |- ( ( x = y → ( z = w → ph ) ) ↔ ( z = w → ( x = y → ph ) ) ) ;;
	step 3 : wff = albii (step 2) |- ( ∀ x ( x = y → ( z = w → ph ) ) ↔ ∀ x ( z = w → ( x = y → ph ) ) ) ;;
	step 4 : wff = 19.21v () |- ( ∀ x ( z = w → ( x = y → ph ) ) ↔ ( z = w → ∀ x ( x = y → ph ) ) ) ;;
	step 5 : wff = bitri (step 3, step 4) |- ( ∀ x ( x = y → ( z = w → ph ) ) ↔ ( z = w → ∀ x ( x = y → ph ) ) ) ;;
	step 6 : wff = albii (step 5) |- ( ∀ z ∀ x ( x = y → ( z = w → ph ) ) ↔ ∀ z ( z = w → ∀ x ( x = y → ph ) ) ) ;;
	step 7 : wff = 19.21v () |- ( ∀ z ( x = y → ( z = w → ph ) ) ↔ ( x = y → ∀ z ( z = w → ph ) ) ) ;;
	step 8 : wff = albii (step 7) |- ( ∀ x ∀ z ( x = y → ( z = w → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = w → ph ) ) ) ;;
	step 9 : wff = 3bitr3i (step 1, step 6, step 8) |- ( ∀ z ( z = w → ∀ x ( x = y → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = w → ph ) ) ) ;;
	step 10 : wff = a1i (step 9) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = w ) → ( ∀ z ( z = w → ∀ x ( x = y → ph ) ) ↔ ∀ x ( x = y → ∀ z ( z = w → ph ) ) ) ) ;;
	step 11 : wff = sb4b () |- ( ¬ ∀ z z = w → ( [ w / z ] [ y / x ] ph ↔ ∀ z ( z = w → [ y / x ] ph ) ) ) ;;
	step 12 : wff = sb4b () |- ( ¬ ∀ x x = y → ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 13 : wff = imbi2d (step 12) |- ( ¬ ∀ x x = y → ( ( z = w → [ y / x ] ph ) ↔ ( z = w → ∀ x ( x = y → ph ) ) ) ) ;;
	step 14 : wff = albidv (step 13) |- ( ¬ ∀ x x = y → ( ∀ z ( z = w → [ y / x ] ph ) ↔ ∀ z ( z = w → ∀ x ( x = y → ph ) ) ) ) ;;
	step 15 : wff = sylan9bbr (step 11, step 14) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = w ) → ( [ w / z ] [ y / x ] ph ↔ ∀ z ( z = w → ∀ x ( x = y → ph ) ) ) ) ;;
	step 16 : wff = sb4b () |- ( ¬ ∀ x x = y → ( [ y / x ] [ w / z ] ph ↔ ∀ x ( x = y → [ w / z ] ph ) ) ) ;;
	step 17 : wff = sb4b () |- ( ¬ ∀ z z = w → ( [ w / z ] ph ↔ ∀ z ( z = w → ph ) ) ) ;;
	step 18 : wff = imbi2d (step 17) |- ( ¬ ∀ z z = w → ( ( x = y → [ w / z ] ph ) ↔ ( x = y → ∀ z ( z = w → ph ) ) ) ) ;;
	step 19 : wff = albidv (step 18) |- ( ¬ ∀ z z = w → ( ∀ x ( x = y → [ w / z ] ph ) ↔ ∀ x ( x = y → ∀ z ( z = w → ph ) ) ) ) ;;
	step 20 : wff = sylan9bb (step 16, step 19) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = w ) → ( [ y / x ] [ w / z ] ph ↔ ∀ x ( x = y → ∀ z ( z = w → ph ) ) ) ) ;;
	step 21 : wff = 3bitr4d (step 10, step 15, step 20) |- ( ( ¬ ∀ x x = y ∧ ¬ ∀ z z = w ) → ( [ w / z ] [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ) ;;
	step 22 : wff = ex (step 21) |- ( ¬ ∀ x x = y → ( ¬ ∀ z z = w → ( [ w / z ] [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ) ) ;;
	step 23 : wff = nfae () |- F/ z ∀ x x = y ;;
	step 24 : wff = sbequ12 () |- ( x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 25 : wff = sps (step 24) |- ( ∀ x x = y → ( ph ↔ [ y / x ] ph ) ) ;;
	step 26 : wff = sbbid (step 23, step 25) |- ( ∀ x x = y → ( [ w / z ] ph ↔ [ w / z ] [ y / x ] ph ) ) ;;
	step 27 : wff = sbequ12 () |- ( x = y → ( [ w / z ] ph ↔ [ y / x ] [ w / z ] ph ) ) ;;
	step 28 : wff = sps (step 27) |- ( ∀ x x = y → ( [ w / z ] ph ↔ [ y / x ] [ w / z ] ph ) ) ;;
	step 29 : wff = bitr3d (step 26, step 28) |- ( ∀ x x = y → ( [ w / z ] [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ) ;;
	step 30 : wff = sbequ12 () |- ( z = w → ( [ y / x ] ph ↔ [ w / z ] [ y / x ] ph ) ) ;;
	step 31 : wff = sps (step 30) |- ( ∀ z z = w → ( [ y / x ] ph ↔ [ w / z ] [ y / x ] ph ) ) ;;
	step 32 : wff = nfae () |- F/ x ∀ z z = w ;;
	step 33 : wff = sbequ12 () |- ( z = w → ( ph ↔ [ w / z ] ph ) ) ;;
	step 34 : wff = sps (step 33) |- ( ∀ z z = w → ( ph ↔ [ w / z ] ph ) ) ;;
	step 35 : wff = sbbid (step 32, step 34) |- ( ∀ z z = w → ( [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ) ;;
	step 36 : wff = bitr3d (step 31, step 35) |- ( ∀ z z = w → ( [ w / z ] [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ) ;;
	step 37 : wff = pm2.61ii (step 22, step 29, step 36) |- ( [ w / z ] [ y / x ] ph ↔ [ y / x ] [ w / z ] ph ) ;;
	qed prop 1 = step 37 ;;
}

/* Theorem *11.07 in [WhiteheadRussell] p. 159.  (Contributed by Andrew
       Salmon, 17-Jun-2011.) */

theorem pm11.07 (ph : wff, x : set, y : set, z : set, w : set) disjointed(ph x y z, w x z) {
	prop 1 : wff = |- ( [ w / x ] [ y / z ] ph ↔ [ y / x ] [ w / z ] ph ) ;;
}

proof of pm11.07 {
	step 1 : wff = a9ev () |- ∃ x x = w ;;
	step 2 : wff = a9ev () |- ∃ z z = y ;;
	step 3 : wff = pm3.2i (step 1, step 2) |- ( ∃ x x = w ∧ ∃ z z = y ) ;;
	step 4 : wff = a9ev () |- ∃ x x = y ;;
	step 5 : wff = a9ev () |- ∃ z z = w ;;
	step 6 : wff = pm3.2i (step 4, step 5) |- ( ∃ x x = y ∧ ∃ z z = w ) ;;
	step 7 : wff = 2th (step 3, step 6) |- ( ( ∃ x x = w ∧ ∃ z z = y ) ↔ ( ∃ x x = y ∧ ∃ z z = w ) ) ;;
	step 8 : wff = eeanv () |- ( ∃ x ∃ z ( x = w ∧ z = y ) ↔ ( ∃ x x = w ∧ ∃ z z = y ) ) ;;
	step 9 : wff = eeanv () |- ( ∃ x ∃ z ( x = y ∧ z = w ) ↔ ( ∃ x x = y ∧ ∃ z z = w ) ) ;;
	step 10 : wff = 3bitr4i (step 7, step 8, step 9) |- ( ∃ x ∃ z ( x = w ∧ z = y ) ↔ ∃ x ∃ z ( x = y ∧ z = w ) ) ;;
	step 11 : wff = anbi1i (step 10) |- ( ( ∃ x ∃ z ( x = w ∧ z = y ) ∧ ph ) ↔ ( ∃ x ∃ z ( x = y ∧ z = w ) ∧ ph ) ) ;;
	step 12 : wff = 19.41vv () |- ( ∃ x ∃ z ( ( x = w ∧ z = y ) ∧ ph ) ↔ ( ∃ x ∃ z ( x = w ∧ z = y ) ∧ ph ) ) ;;
	step 13 : wff = 19.41vv () |- ( ∃ x ∃ z ( ( x = y ∧ z = w ) ∧ ph ) ↔ ( ∃ x ∃ z ( x = y ∧ z = w ) ∧ ph ) ) ;;
	step 14 : wff = 3bitr4i (step 11, step 12, step 13) |- ( ∃ x ∃ z ( ( x = w ∧ z = y ) ∧ ph ) ↔ ∃ x ∃ z ( ( x = y ∧ z = w ) ∧ ph ) ) ;;
	step 15 : wff = 2sb5 () |- ( [ w / x ] [ y / z ] ph ↔ ∃ x ∃ z ( ( x = w ∧ z = y ) ∧ ph ) ) ;;
	step 16 : wff = 2sb5 () |- ( [ y / x ] [ w / z ] ph ↔ ∃ x ∃ z ( ( x = y ∧ z = w ) ∧ ph ) ) ;;
	step 17 : wff = 3bitr4i (step 14, step 15, step 16) |- ( [ w / x ] [ y / z ] ph ↔ [ y / x ] [ w / z ] ph ) ;;
	qed prop 1 = step 17 ;;
}

/* Equivalence for substitution.  (Contributed by NM, 5-Aug-1993.) */

theorem sb6a (ph : wff, x : set, y : set) disjointed(x y) {
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∀ x ( x = y → [ x / y ] ph ) ) ;;
}

proof of sb6a {
	step 1 : wff = sb6 () |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	step 2 : wff = sbequ12 () |- ( y = x → ( ph ↔ [ x / y ] ph ) ) ;;
	step 3 : wff = equcoms (step 2) |- ( x = y → ( ph ↔ [ x / y ] ph ) ) ;;
	step 4 : wff = pm5.74i (step 3) |- ( ( x = y → ph ) ↔ ( x = y → [ x / y ] ph ) ) ;;
	step 5 : wff = albii (step 4) |- ( ∀ x ( x = y → ph ) ↔ ∀ x ( x = y → [ x / y ] ph ) ) ;;
	step 6 : wff = bitri (step 1, step 5) |- ( [ y / x ] ph ↔ ∀ x ( x = y → [ x / y ] ph ) ) ;;
	qed prop 1 = step 6 ;;
}

/* Reversed double substitution.  (Contributed by NM, 3-Feb-2005.)
       (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem 2sb5rf (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y, x w, y z, z w) {
	hyp 1 : wff = |- F/ z ph ;;
	hyp 2 : wff = |- F/ w ph ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ∃ z ∃ w ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ) ;;
}

proof of 2sb5rf {
	step 1 : wff = sb5rf (hyp 1) |- ( ph ↔ ∃ z ( z = x ∧ [ z / x ] ph ) ) ;;
	step 2 : wff = 19.42v () |- ( ∃ w ( z = x ∧ ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ↔ ( z = x ∧ ∃ w ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ) ;;
	step 3 : wff = sbcom2 () |- ( [ z / x ] [ w / y ] ph ↔ [ w / y ] [ z / x ] ph ) ;;
	step 4 : wff = anbi2i (step 3) |- ( ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ↔ ( ( z = x ∧ w = y ) ∧ [ w / y ] [ z / x ] ph ) ) ;;
	step 5 : wff = anass () |- ( ( ( z = x ∧ w = y ) ∧ [ w / y ] [ z / x ] ph ) ↔ ( z = x ∧ ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ↔ ( z = x ∧ ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ) ;;
	step 7 : wff = exbii (step 6) |- ( ∃ w ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ↔ ∃ w ( z = x ∧ ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ) ;;
	step 8 : wff = nfsb (hyp 2) |- F/ w [ z / x ] ph ;;
	step 9 : wff = sb5rf (step 8) |- ( [ z / x ] ph ↔ ∃ w ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ;;
	step 10 : wff = anbi2i (step 9) |- ( ( z = x ∧ [ z / x ] ph ) ↔ ( z = x ∧ ∃ w ( w = y ∧ [ w / y ] [ z / x ] ph ) ) ) ;;
	step 11 : wff = 3bitr4ri (step 2, step 7, step 10) |- ( ( z = x ∧ [ z / x ] ph ) ↔ ∃ w ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ) ;;
	step 12 : wff = exbii (step 11) |- ( ∃ z ( z = x ∧ [ z / x ] ph ) ↔ ∃ z ∃ w ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ) ;;
	step 13 : wff = bitri (step 1, step 12) |- ( ph ↔ ∃ z ∃ w ( ( z = x ∧ w = y ) ∧ [ z / x ] [ w / y ] ph ) ) ;;
	qed prop 1 = step 13 ;;
}

/* Reversed double substitution.  (Contributed by NM, 3-Feb-2005.)
       (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem 2sb6rf (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y, x w, y z, z w) {
	hyp 1 : wff = |- F/ z ph ;;
	hyp 2 : wff = |- F/ w ph ;;
	-----------------------
	prop 1 : wff = |- ( ph ↔ ∀ z ∀ w ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ) ;;
}

proof of 2sb6rf {
	step 1 : wff = sb6rf (hyp 1) |- ( ph ↔ ∀ z ( z = x → [ z / x ] ph ) ) ;;
	step 2 : wff = 19.21v () |- ( ∀ w ( z = x → ( w = y → [ w / y ] [ z / x ] ph ) ) ↔ ( z = x → ∀ w ( w = y → [ w / y ] [ z / x ] ph ) ) ) ;;
	step 3 : wff = sbcom2 () |- ( [ z / x ] [ w / y ] ph ↔ [ w / y ] [ z / x ] ph ) ;;
	step 4 : wff = imbi2i (step 3) |- ( ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ↔ ( ( z = x ∧ w = y ) → [ w / y ] [ z / x ] ph ) ) ;;
	step 5 : wff = impexp () |- ( ( ( z = x ∧ w = y ) → [ w / y ] [ z / x ] ph ) ↔ ( z = x → ( w = y → [ w / y ] [ z / x ] ph ) ) ) ;;
	step 6 : wff = bitri (step 4, step 5) |- ( ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ↔ ( z = x → ( w = y → [ w / y ] [ z / x ] ph ) ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ w ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ↔ ∀ w ( z = x → ( w = y → [ w / y ] [ z / x ] ph ) ) ) ;;
	step 8 : wff = nfsb (hyp 2) |- F/ w [ z / x ] ph ;;
	step 9 : wff = sb6rf (step 8) |- ( [ z / x ] ph ↔ ∀ w ( w = y → [ w / y ] [ z / x ] ph ) ) ;;
	step 10 : wff = imbi2i (step 9) |- ( ( z = x → [ z / x ] ph ) ↔ ( z = x → ∀ w ( w = y → [ w / y ] [ z / x ] ph ) ) ) ;;
	step 11 : wff = 3bitr4ri (step 2, step 7, step 10) |- ( ( z = x → [ z / x ] ph ) ↔ ∀ w ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ) ;;
	step 12 : wff = albii (step 11) |- ( ∀ z ( z = x → [ z / x ] ph ) ↔ ∀ z ∀ w ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ) ;;
	step 13 : wff = bitri (step 1, step 12) |- ( ph ↔ ∀ z ∀ w ( ( z = x ∧ w = y ) → [ z / x ] [ w / y ] ph ) ) ;;
	qed prop 1 = step 13 ;;
}

/* An alternate definition of proper substitution ~ df-sb .  By introducing
       a dummy variable ` z ` in the definiens, we are able to eliminate any
       distinct variable restrictions among the variables ` x ` , ` y ` , and
       ` ph ` of the definiendum.  No distinct variable conflicts arise because
       ` z ` effectively insulates ` x ` from ` y ` .  To achieve this, we use
       a chain of two substitutions in the form of ~ sb5 , first ` z ` for
       ` x ` then ` y ` for ` z ` .  Compare Definition 2.1'' of [Quine] p. 17,
       which is obtained from this theorem by applying ~ df-clab .  Theorem
       ~ sb7h provides a version where ` ph ` and ` z ` don't have to be
       distinct.  (Contributed by NM, 28-Jan-2004.) */

theorem dfsb7 (ph : wff, x : set, y : set, z : set) disjointed(x z, y z, z ph) {
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
}

proof of dfsb7 {
	step 1 : wff = sb5 () |- ( [ z / x ] ph ↔ ∃ x ( x = z ∧ ph ) ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ y / z ] [ z / x ] ph ↔ [ y / z ] ∃ x ( x = z ∧ ph ) ) ;;
	step 3 : wff = nfv () |- F/ z ph ;;
	step 4 : wff = sbco2 (step 3) |- ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ;;
	step 5 : wff = sb5 () |- ( [ y / z ] ∃ x ( x = z ∧ ph ) ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
	step 6 : wff = 3bitr3i (step 2, step 4, step 5) |- ( [ y / x ] ph ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
	qed prop 1 = step 6 ;;
}

/* This version of ~ dfsb7 does not require that ` ph ` and ` z ` be
       distinct.  This permits it to be used as a definition for substitution
       in a formalization that omits the logically redundant axiom ~ ax-17 i.e.
       that doesn't have the concept of a variable not occurring in a wff.
       ( ~ df-sb is also suitable, but its mixing of free and bound variables
       is distasteful to some logicians.)  (Contributed by NM, 26-Jul-2006.)
       (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sb7f (ph : wff, x : set, y : set, z : set) disjointed(x z, y z) {
	hyp 1 : wff = |- F/ z ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
}

proof of sb7f {
	step 1 : wff = sb5 () |- ( [ z / x ] ph ↔ ∃ x ( x = z ∧ ph ) ) ;;
	step 2 : wff = sbbii (step 1) |- ( [ y / z ] [ z / x ] ph ↔ [ y / z ] ∃ x ( x = z ∧ ph ) ) ;;
	step 3 : wff = sbco2 (hyp 1) |- ( [ y / z ] [ z / x ] ph ↔ [ y / x ] ph ) ;;
	step 4 : wff = sb5 () |- ( [ y / z ] ∃ x ( x = z ∧ ph ) ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
	step 5 : wff = 3bitr3i (step 2, step 3, step 4) |- ( [ y / x ] ph ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
	qed prop 1 = step 5 ;;
}

/* This version of ~ dfsb7 does not require that ` ph ` and ` z ` be
       distinct.  This permits it to be used as a definition for substitution
       in a formalization that omits the logically redundant axiom ~ ax-17 i.e.
       that doesn't have the concept of a variable not occurring in a wff.
       ( ~ df-sb is also suitable, but its mixing of free and bound variables
       is distasteful to some logicians.)  (Contributed by NM, 26-Jul-2006.)
       (Proof shortened by Andrew Salmon, 25-May-2011.) */

theorem sb7h (ph : wff, x : set, y : set, z : set) disjointed(x z, y z) {
	hyp 1 : wff = |- ( ph → ∀ z ph ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ph ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
}

proof of sb7h {
	step 1 : wff = nfi (hyp 1) |- F/ z ph ;;
	step 2 : wff = sb7f (step 1) |- ( [ y / x ] ph ↔ ∃ z ( z = y ∧ ∃ x ( x = z ∧ ph ) ) ) ;;
	qed prop 1 = step 2 ;;
}

/* Hao Wang's identity axiom P6 in Irving Copi, _Symbolic Logic_ (5th ed.,
       1979), p. 328.  In traditional predicate calculus, this is a sole axiom
       for identity from which the usual ones can be derived.  (Contributed by
       NM, 9-May-2005.)  (Revised by Mario Carneiro, 6-Oct-2016.) */

theorem sb10f (ph : wff, x : set, y : set, z : set) disjointed(x y) {
	hyp 1 : wff = |- F/ x ph ;;
	-----------------------
	prop 1 : wff = |- ( [ y / z ] ph ↔ ∃ x ( x = y ∧ [ x / z ] ph ) ) ;;
}

proof of sb10f {
	step 1 : wff = nfsb (hyp 1) |- F/ x [ y / z ] ph ;;
	step 2 : wff = sbequ () |- ( x = y → ( [ x / z ] ph ↔ [ y / z ] ph ) ) ;;
	step 3 : wff = equsex (step 1, step 2) |- ( ∃ x ( x = y ∧ [ x / z ] ph ) ↔ [ y / z ] ph ) ;;
	step 4 : wff = bicomi (step 3) |- ( [ y / z ] ph ↔ ∃ x ( x = y ∧ [ x / z ] ph ) ) ;;
	qed prop 1 = step 4 ;;
}

/* An identity law for substitution.  Used in proof of Theorem 9.7 of
       [Megill] p. 449 (p. 16 of the preprint).  (Contributed by NM,
       5-Aug-1993.) */

theorem sbid2v (ph : wff, x : set, y : set) disjointed(x ph) {
	prop 1 : wff = |- ( [ y / x ] [ x / y ] ph ↔ ph ) ;;
}

proof of sbid2v {
	step 1 : wff = nfv () |- F/ x ph ;;
	step 2 : wff = sbid2 (step 1) |- ( [ y / x ] [ x / y ] ph ↔ ph ) ;;
	qed prop 1 = step 2 ;;
}

/* Elimination of substitution.  (Contributed by NM, 5-Aug-1993.) */

theorem sbelx (ph : wff, x : set, y : set) disjointed(x y, x ph) {
	prop 1 : wff = |- ( ph ↔ ∃ x ( x = y ∧ [ x / y ] ph ) ) ;;
}

proof of sbelx {
	step 1 : wff = sbid2v () |- ( [ y / x ] [ x / y ] ph ↔ ph ) ;;
	step 2 : wff = sb5 () |- ( [ y / x ] [ x / y ] ph ↔ ∃ x ( x = y ∧ [ x / y ] ph ) ) ;;
	step 3 : wff = bitr3i (step 1, step 2) |- ( ph ↔ ∃ x ( x = y ∧ [ x / y ] ph ) ) ;;
	qed prop 1 = step 3 ;;
}

/* Note:  A more general case could also be proved with
       "$d x z $.  $d y w $.  $d x ph $.  $d y ph $.", but with more
       difficulty. */

/* Elimination of double substitution.  (Contributed by NM, 5-Aug-1993.) */

theorem sbel2x (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z, w y, x y ph) {
	prop 1 : wff = |- ( ph ↔ ∃ x ∃ y ( ( x = z ∧ y = w ) ∧ [ y / w ] [ x / z ] ph ) ) ;;
}

proof of sbel2x {
	step 1 : wff = sbelx () |- ( [ x / z ] ph ↔ ∃ y ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ;;
	step 2 : wff = anbi2i (step 1) |- ( ( x = z ∧ [ x / z ] ph ) ↔ ( x = z ∧ ∃ y ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ) ;;
	step 3 : wff = exbii (step 2) |- ( ∃ x ( x = z ∧ [ x / z ] ph ) ↔ ∃ x ( x = z ∧ ∃ y ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ) ;;
	step 4 : wff = sbelx () |- ( ph ↔ ∃ x ( x = z ∧ [ x / z ] ph ) ) ;;
	step 5 : wff = exdistr () |- ( ∃ x ∃ y ( x = z ∧ ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ↔ ∃ x ( x = z ∧ ∃ y ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ) ;;
	step 6 : wff = 3bitr4i (step 3, step 4, step 5) |- ( ph ↔ ∃ x ∃ y ( x = z ∧ ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ) ;;
	step 7 : wff = anass () |- ( ( ( x = z ∧ y = w ) ∧ [ y / w ] [ x / z ] ph ) ↔ ( x = z ∧ ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ) ;;
	step 8 : wff = 2exbii (step 7) |- ( ∃ x ∃ y ( ( x = z ∧ y = w ) ∧ [ y / w ] [ x / z ] ph ) ↔ ∃ x ∃ y ( x = z ∧ ( y = w ∧ [ y / w ] [ x / z ] ph ) ) ) ;;
	step 9 : wff = bitr4i (step 6, step 8) |- ( ph ↔ ∃ x ∃ y ( ( x = z ∧ y = w ) ∧ [ y / w ] [ x / z ] ph ) ) ;;
	qed prop 1 = step 9 ;;
}

/* A theorem used in elimination of disjoint variable restriction on ` x `
       and ` y ` by replacing it with a distinctor ` -. A. x x = z ` .
       (Contributed by NM, 5-Aug-1993.) */

theorem sbal1 (ph : wff, x : set, y : set, z : set) disjointed(x y) {
	prop 1 : wff = |- ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
}

proof of sbal1 {
	step 1 : wff = sbequ12 () |- ( y = z → ( ∀ x ph ↔ [ z / y ] ∀ x ph ) ) ;;
	step 2 : wff = sps (step 1) |- ( ∀ y y = z → ( ∀ x ph ↔ [ z / y ] ∀ x ph ) ) ;;
	step 3 : wff = sbequ12 () |- ( y = z → ( ph ↔ [ z / y ] ph ) ) ;;
	step 4 : wff = sps (step 3) |- ( ∀ y y = z → ( ph ↔ [ z / y ] ph ) ) ;;
	step 5 : wff = dral2 (step 4) |- ( ∀ y y = z → ( ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	step 6 : wff = bitr3d (step 2, step 5) |- ( ∀ y y = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	step 7 : wff = a1d (step 6) |- ( ∀ y y = z → ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ) ;;
	step 8 : wff = nfa1 () |- F/ x ∀ x ph ;;
	step 9 : wff = nfsb4 (step 8) |- ( ¬ ∀ x x = z → F/ x [ z / y ] ∀ x ph ) ;;
	step 10 : wff = nfrd (step 9) |- ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph → ∀ x [ z / y ] ∀ x ph ) ) ;;
	step 11 : wff = sp () |- ( ∀ x ph → ph ) ;;
	step 12 : wff = sbimi (step 11) |- ( [ z / y ] ∀ x ph → [ z / y ] ph ) ;;
	step 13 : wff = alimi (step 12) |- ( ∀ x [ z / y ] ∀ x ph → ∀ x [ z / y ] ph ) ;;
	step 14 : wff = syl6 (step 10, step 13) |- ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph → ∀ x [ z / y ] ph ) ) ;;
	step 15 : wff = adantl (step 14) |- ( ( ¬ ∀ y y = z ∧ ¬ ∀ x x = z ) → ( [ z / y ] ∀ x ph → ∀ x [ z / y ] ph ) ) ;;
	step 16 : wff = sb4 () |- ( ¬ ∀ y y = z → ( [ z / y ] ph → ∀ y ( y = z → ph ) ) ) ;;
	step 17 : wff = al2imi (step 16) |- ( ∀ x ¬ ∀ y y = z → ( ∀ x [ z / y ] ph → ∀ x ∀ y ( y = z → ph ) ) ) ;;
	step 18 : wff = hbnaes (step 17) |- ( ¬ ∀ y y = z → ( ∀ x [ z / y ] ph → ∀ x ∀ y ( y = z → ph ) ) ) ;;
	step 19 : wff = ax-7 () |- ( ∀ x ∀ y ( y = z → ph ) → ∀ y ∀ x ( y = z → ph ) ) ;;
	step 20 : wff = syl6 (step 18, step 19) |- ( ¬ ∀ y y = z → ( ∀ x [ z / y ] ph → ∀ y ∀ x ( y = z → ph ) ) ) ;;
	step 21 : wff = dveeq2 () |- ( ¬ ∀ x x = z → ( y = z → ∀ x y = z ) ) ;;
	step 22 : wff = alim () |- ( ∀ x ( y = z → ph ) → ( ∀ x y = z → ∀ x ph ) ) ;;
	step 23 : wff = syl9 (step 21, step 22) |- ( ¬ ∀ x x = z → ( ∀ x ( y = z → ph ) → ( y = z → ∀ x ph ) ) ) ;;
	step 24 : wff = al2imi (step 23) |- ( ∀ y ¬ ∀ x x = z → ( ∀ y ∀ x ( y = z → ph ) → ∀ y ( y = z → ∀ x ph ) ) ) ;;
	step 25 : wff = sb2 () |- ( ∀ y ( y = z → ∀ x ph ) → [ z / y ] ∀ x ph ) ;;
	step 26 : wff = syl6 (step 24, step 25) |- ( ∀ y ¬ ∀ x x = z → ( ∀ y ∀ x ( y = z → ph ) → [ z / y ] ∀ x ph ) ) ;;
	step 27 : wff = hbnaes (step 26) |- ( ¬ ∀ x x = z → ( ∀ y ∀ x ( y = z → ph ) → [ z / y ] ∀ x ph ) ) ;;
	step 28 : wff = sylan9 (step 20, step 27) |- ( ( ¬ ∀ y y = z ∧ ¬ ∀ x x = z ) → ( ∀ x [ z / y ] ph → [ z / y ] ∀ x ph ) ) ;;
	step 29 : wff = impbid (step 15, step 28) |- ( ( ¬ ∀ y y = z ∧ ¬ ∀ x x = z ) → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	step 30 : wff = ex (step 29) |- ( ¬ ∀ y y = z → ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ) ;;
	step 31 : wff = pm2.61i (step 7, step 30) |- ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	qed prop 1 = step 31 ;;
}

/* Move universal quantifier in and out of substitution.  (Contributed by
       NM, 5-Aug-1993.) */

theorem sbal (ph : wff, x : set, y : set, z : set) disjointed(x y, x z) {
	prop 1 : wff = |- ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ;;
}

proof of sbal {
	step 1 : wff = a16gb () |- ( ∀ x x = z → ( ph ↔ ∀ x ph ) ) ;;
	step 2 : wff = sbimi (step 1) |- ( [ z / y ] ∀ x x = z → [ z / y ] ( ph ↔ ∀ x ph ) ) ;;
	step 3 : wff = sbequ5 () |- ( [ z / y ] ∀ x x = z ↔ ∀ x x = z ) ;;
	step 4 : wff = sbbi () |- ( [ z / y ] ( ph ↔ ∀ x ph ) ↔ ( [ z / y ] ph ↔ [ z / y ] ∀ x ph ) ) ;;
	step 5 : wff = 3imtr3i (step 2, step 3, step 4) |- ( ∀ x x = z → ( [ z / y ] ph ↔ [ z / y ] ∀ x ph ) ) ;;
	step 6 : wff = a16gb () |- ( ∀ x x = z → ( [ z / y ] ph ↔ ∀ x [ z / y ] ph ) ) ;;
	step 7 : wff = bitr3d (step 5, step 6) |- ( ∀ x x = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	step 8 : wff = sbal1 () |- ( ¬ ∀ x x = z → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	step 9 : wff = pm2.61i (step 7, step 8) |- ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ;;
	qed prop 1 = step 9 ;;
}

/* Move existential quantifier in and out of substitution.  (Contributed by
       NM, 27-Sep-2003.) */

theorem sbex (ph : wff, x : set, y : set, z : set) disjointed(x y, x z) {
	prop 1 : wff = |- ( [ z / y ] ∃ x ph ↔ ∃ x [ z / y ] ph ) ;;
}

proof of sbex {
	step 1 : wff = sbn () |- ( [ z / y ] ¬ ∀ x ¬ ph ↔ ¬ [ z / y ] ∀ x ¬ ph ) ;;
	step 2 : wff = sbal () |- ( [ z / y ] ∀ x ¬ ph ↔ ∀ x [ z / y ] ¬ ph ) ;;
	step 3 : wff = sbn () |- ( [ z / y ] ¬ ph ↔ ¬ [ z / y ] ph ) ;;
	step 4 : wff = albii (step 3) |- ( ∀ x [ z / y ] ¬ ph ↔ ∀ x ¬ [ z / y ] ph ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( [ z / y ] ∀ x ¬ ph ↔ ∀ x ¬ [ z / y ] ph ) ;;
	step 6 : wff = xchbinx (step 1, step 5) |- ( [ z / y ] ¬ ∀ x ¬ ph ↔ ¬ ∀ x ¬ [ z / y ] ph ) ;;
	step 7 : wff = df-ex () |- ( ∃ x ph ↔ ¬ ∀ x ¬ ph ) ;;
	step 8 : wff = sbbii (step 7) |- ( [ z / y ] ∃ x ph ↔ [ z / y ] ¬ ∀ x ¬ ph ) ;;
	step 9 : wff = df-ex () |- ( ∃ x [ z / y ] ph ↔ ¬ ∀ x ¬ [ z / y ] ph ) ;;
	step 10 : wff = 3bitr4i (step 6, step 8, step 9) |- ( [ z / y ] ∃ x ph ↔ ∃ x [ z / y ] ph ) ;;
	qed prop 1 = step 10 ;;
}

/* Quantify with new variable inside substitution.  (Contributed by NM,
       18-Aug-1993.) */

theorem sbalv (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(x z, y z) {
	hyp 1 : wff = |- ( [ y / x ] ph ↔ ps ) ;;
	-----------------------
	prop 1 : wff = |- ( [ y / x ] ∀ z ph ↔ ∀ z ps ) ;;
}

proof of sbalv {
	step 1 : wff = sbal () |- ( [ y / x ] ∀ z ph ↔ ∀ z [ y / x ] ph ) ;;
	step 2 : wff = albii (hyp 1) |- ( ∀ z [ y / x ] ph ↔ ∀ z ps ) ;;
	step 3 : wff = bitri (step 1, step 2) |- ( [ y / x ] ∀ z ph ↔ ∀ z ps ) ;;
	qed prop 1 = step 3 ;;
}

/* An equivalent expression for existence.  (Contributed by NM,
       2-Feb-2005.) */

theorem exsb (ph : wff, x : set, y : set) disjointed(x y, y ph) {
	prop 1 : wff = |- ( ∃ x ph ↔ ∃ y ∀ x ( x = y → ph ) ) ;;
}

proof of exsb {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = nfa1 () |- F/ x ∀ x ( x = y → ph ) ;;
	step 3 : wff = ax11v () |- ( x = y → ( ph → ∀ x ( x = y → ph ) ) ) ;;
	step 4 : wff = sp () |- ( ∀ x ( x = y → ph ) → ( x = y → ph ) ) ;;
	step 5 : wff = com12 (step 4) |- ( x = y → ( ∀ x ( x = y → ph ) → ph ) ) ;;
	step 6 : wff = impbid (step 3, step 5) |- ( x = y → ( ph ↔ ∀ x ( x = y → ph ) ) ) ;;
	step 7 : wff = cbvex (step 1, step 2, step 6) |- ( ∃ x ph ↔ ∃ y ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 7 ;;
}

/* An equivalent expression for existence.  Obsolete as of 19-Jun-2017.
       (Contributed by NM, 2-Feb-2005.)  (New usage is discouraged.) */

theorem exsbOLD (ph : wff, x : set, y : set) disjointed(x y, y ph) {
	prop 1 : wff = |- ( ∃ x ph ↔ ∃ y ∀ x ( x = y → ph ) ) ;;
}

proof of exsbOLD {
	step 1 : wff = nfv () |- F/ y ph ;;
	step 2 : wff = sb8e (step 1) |- ( ∃ x ph ↔ ∃ y [ y / x ] ph ) ;;
	step 3 : wff = sb6 () |- ( [ y / x ] ph ↔ ∀ x ( x = y → ph ) ) ;;
	step 4 : wff = exbii (step 3) |- ( ∃ y [ y / x ] ph ↔ ∃ y ∀ x ( x = y → ph ) ) ;;
	step 5 : wff = bitri (step 2, step 4) |- ( ∃ x ph ↔ ∃ y ∀ x ( x = y → ph ) ) ;;
	qed prop 1 = step 5 ;;
}

/* An equivalent expression for double existence.  (Contributed by NM,
       2-Feb-2005.) */

theorem 2exsb (ph : wff, x : set, y : set, z : set, w : set) disjointed(x y z, y w, z w ph) {
	prop 1 : wff = |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
}

proof of 2exsb {
	step 1 : wff = exsb () |- ( ∃ y ph ↔ ∃ w ∀ y ( y = w → ph ) ) ;;
	step 2 : wff = exbii (step 1) |- ( ∃ x ∃ y ph ↔ ∃ x ∃ w ∀ y ( y = w → ph ) ) ;;
	step 3 : wff = excom () |- ( ∃ x ∃ w ∀ y ( y = w → ph ) ↔ ∃ w ∃ x ∀ y ( y = w → ph ) ) ;;
	step 4 : wff = bitri (step 2, step 3) |- ( ∃ x ∃ y ph ↔ ∃ w ∃ x ∀ y ( y = w → ph ) ) ;;
	step 5 : wff = exsb () |- ( ∃ x ∀ y ( y = w → ph ) ↔ ∃ z ∀ x ( x = z → ∀ y ( y = w → ph ) ) ) ;;
	step 6 : wff = impexp () |- ( ( ( x = z ∧ y = w ) → ph ) ↔ ( x = z → ( y = w → ph ) ) ) ;;
	step 7 : wff = albii (step 6) |- ( ∀ y ( ( x = z ∧ y = w ) → ph ) ↔ ∀ y ( x = z → ( y = w → ph ) ) ) ;;
	step 8 : wff = 19.21v () |- ( ∀ y ( x = z → ( y = w → ph ) ) ↔ ( x = z → ∀ y ( y = w → ph ) ) ) ;;
	step 9 : wff = bitr2i (step 7, step 8) |- ( ( x = z → ∀ y ( y = w → ph ) ) ↔ ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 10 : wff = albii (step 9) |- ( ∀ x ( x = z → ∀ y ( y = w → ph ) ) ↔ ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 11 : wff = exbii (step 10) |- ( ∃ z ∀ x ( x = z → ∀ y ( y = w → ph ) ) ↔ ∃ z ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 12 : wff = bitri (step 5, step 11) |- ( ∃ x ∀ y ( y = w → ph ) ↔ ∃ z ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 13 : wff = exbii (step 12) |- ( ∃ w ∃ x ∀ y ( y = w → ph ) ↔ ∃ w ∃ z ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 14 : wff = excom () |- ( ∃ w ∃ z ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ↔ ∃ z ∃ w ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 15 : wff = bitri (step 13, step 14) |- ( ∃ w ∃ x ∀ y ( y = w → ph ) ↔ ∃ z ∃ w ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	step 16 : wff = bitri (step 4, step 15) |- ( ∃ x ∃ y ph ↔ ∃ z ∃ w ∀ x ∀ y ( ( x = z ∧ y = w ) → ph ) ) ;;
	qed prop 1 = step 16 ;;
}

/* Version of ~ dvelim that doesn't use ~ ax-10 .  (See ~ dvelimh for a
       version that doesn't use ~ ax-11 .)  (Contributed by NM, 17-May-2008.)
       (New usage is discouraged.)  (Proof modification is discouraged.) */

theorem dvelimALT (ph : wff, ps : wff, x : set, y : set, z : set) disjointed(z ps, x z, y z) {
	hyp 1 : wff = |- ( ph → ∀ x ph ) ;;
	hyp 2 : wff = |- ( z = y → ( ph ↔ ps ) ) ;;
	-----------------------
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
}

proof of dvelimALT {
	step 1 : wff = ax-17 () |- ( ¬ ∀ x x = y → ∀ z ¬ ∀ x x = y ) ;;
	step 2 : wff = ax16ALT () |- ( ∀ x x = z → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ;;
	step 3 : wff = a1d (step 2) |- ( ∀ x x = z → ( ¬ ∀ x x = y → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ) ;;
	step 4 : wff = hbn1 () |- ( ¬ ∀ x x = z → ∀ x ¬ ∀ x x = z ) ;;
	step 5 : wff = hbn1 () |- ( ¬ ∀ x x = y → ∀ x ¬ ∀ x x = y ) ;;
	step 6 : wff = hban (step 4, step 5) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ∀ x ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) ) ;;
	step 7 : wff = ax12o () |- ( ¬ ∀ x x = z → ( ¬ ∀ x x = y → ( z = y → ∀ x z = y ) ) ) ;;
	step 8 : wff = imp (step 7) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( z = y → ∀ x z = y ) ) ;;
	step 9 : wff = a1i (hyp 1) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ph → ∀ x ph ) ) ;;
	step 10 : wff = hbimd (step 6, step 8, step 9) |- ( ( ¬ ∀ x x = z ∧ ¬ ∀ x x = y ) → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ;;
	step 11 : wff = ex (step 10) |- ( ¬ ∀ x x = z → ( ¬ ∀ x x = y → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ) ;;
	step 12 : wff = pm2.61i (step 3, step 11) |- ( ¬ ∀ x x = y → ( ( z = y → ph ) → ∀ x ( z = y → ph ) ) ) ;;
	step 13 : wff = hbald (step 1, step 12) |- ( ¬ ∀ x x = y → ( ∀ z ( z = y → ph ) → ∀ x ∀ z ( z = y → ph ) ) ) ;;
	step 14 : wff = ax-17 () |- ( ps → ∀ z ps ) ;;
	step 15 : wff = equsalh (step 14, hyp 2) |- ( ∀ z ( z = y → ph ) ↔ ps ) ;;
	step 16 : wff = ax-17 () |- ( ps → ∀ z ps ) ;;
	step 17 : wff = equsalh (step 16, hyp 2) |- ( ∀ z ( z = y → ph ) ↔ ps ) ;;
	step 18 : wff = albii (step 17) |- ( ∀ x ∀ z ( z = y → ph ) ↔ ∀ x ps ) ;;
	step 19 : wff = 3imtr3g (step 13, step 15, step 18) |- ( ¬ ∀ x x = y → ( ps → ∀ x ps ) ) ;;
	qed prop 1 = step 19 ;;
}

/* Move quantifier in and out of substitution.  (Contributed by NM,
       2-Jan-2002.) */

theorem sbal2 (ph : wff, x : set, y : set, z : set) disjointed(z y, z x) {
	prop 1 : wff = |- ( ¬ ∀ x x = y → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
}

proof of sbal2 {
	step 1 : wff = alcom () |- ( ∀ y ∀ x ( y = z → ph ) ↔ ∀ x ∀ y ( y = z → ph ) ) ;;
	step 2 : wff = nfnae () |- F/ y ¬ ∀ x x = y ;;
	step 3 : wff = nfnae () |- F/ x ¬ ∀ x x = y ;;
	step 4 : wff = dveeq1 () |- ( ¬ ∀ x x = y → ( y = z → ∀ x y = z ) ) ;;
	step 5 : wff = nfd (step 3, step 4) |- ( ¬ ∀ x x = y → F/ x y = z ) ;;
	step 6 : wff = 19.21t () |- ( F/ x y = z → ( ∀ x ( y = z → ph ) ↔ ( y = z → ∀ x ph ) ) ) ;;
	step 7 : wff = syl (step 5, step 6) |- ( ¬ ∀ x x = y → ( ∀ x ( y = z → ph ) ↔ ( y = z → ∀ x ph ) ) ) ;;
	step 8 : wff = albid (step 2, step 7) |- ( ¬ ∀ x x = y → ( ∀ y ∀ x ( y = z → ph ) ↔ ∀ y ( y = z → ∀ x ph ) ) ) ;;
	step 9 : wff = syl5rbbr (step 1, step 8) |- ( ¬ ∀ x x = y → ( ∀ y ( y = z → ∀ x ph ) ↔ ∀ x ∀ y ( y = z → ph ) ) ) ;;
	step 10 : wff = sb6 () |- ( [ z / y ] ∀ x ph ↔ ∀ y ( y = z → ∀ x ph ) ) ;;
	step 11 : wff = sb6 () |- ( [ z / y ] ph ↔ ∀ y ( y = z → ph ) ) ;;
	step 12 : wff = albii (step 11) |- ( ∀ x [ z / y ] ph ↔ ∀ x ∀ y ( y = z → ph ) ) ;;
	step 13 : wff = 3bitr4g (step 9, step 10, step 12) |- ( ¬ ∀ x x = y → ( [ z / y ] ∀ x ph ↔ ∀ x [ z / y ] ph ) ) ;;
	qed prop 1 = step 13 ;;
}


